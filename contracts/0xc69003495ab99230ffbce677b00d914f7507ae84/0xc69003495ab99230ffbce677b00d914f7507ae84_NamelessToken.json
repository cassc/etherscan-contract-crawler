{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/INamelessTemplateLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INamelessTemplateLibrary {\\n  function getTemplate(uint256 templateIndex) external view returns (bytes32[] memory dataSection, bytes32[] memory codeSection);\\n  function getContentApis() external view returns (string memory arweaveContentApi, string memory ipfsContentApi);\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessDataV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../utils/BinaryDecoder.sol';\\nimport '../utils/PackedVarArray.sol';\\n\\n\\nlibrary NamelessDataV1 {\\n  /*\\n   * Special Column Types\\n   */\\n\\n  uint256 private constant MAX_COLUMN_WORDS = 65535;\\n  uint256 private constant MAX_CONTENT_LIBRARIES_PER_COLUMN = 256;\\n  uint256 private constant CONTENT_LIBRARY_SECTION_SIZE = 32 * MAX_CONTENT_LIBRARIES_PER_COLUMN;\\n\\n  uint256 public constant COLUMN_TYPE_STRING = 1;\\n  uint256 public constant COLUMN_TYPE_UINT256 = 2;\\n\\n  /**\\n    * @dev Returns an `uint256[MAX_COLUMN_WORDS]` located at `slot`.\\n    */\\n  function getColumn(bytes32 slot) internal pure returns (bytes32[MAX_COLUMN_WORDS] storage r) {\\n      // solhint-disable-next-line no-inline-assembly\\n      assembly {\\n          r.slot := slot\\n      }\\n  }\\n\\n  function getBufferIndexAndOffset(uint index, uint stride) internal pure returns (uint, uint) {\\n    uint offset = index * stride;\\n    return (offset / 32, offset % 32);\\n  }\\n\\n  function getBufferIndexAndOffset(uint index, uint stride, uint baseOffset) internal pure returns (uint, uint) {\\n    uint offset = (index * stride) + baseOffset;\\n    return (offset / 32, offset % 32);\\n  }\\n\\n  /*\\n   * Content Library Column\\n   *\\n   * @dev a content library column references content from a secondary data source like arweave of IPFS\\n   *      this content has been batched into libraries to save space.  Each library is a JSON-encoded\\n   *      array stored on the secondary data source that provides an indirection to the \\\"real\\\" content.\\n   *      each content library can hold up to 256 content references and each column can reference 256\\n   *      libraries. This results in a total of 65536 addressable content hashes while only consuming\\n   *      2 bytes per distinct token.\\n   */\\n  function readContentLibraryColumn(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint contentLibraryHash,\\n    uint contentIndex\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    (uint bufferIndex, uint offset) = getBufferIndexAndOffset(ordinal, 2, CONTENT_LIBRARY_SECTION_SIZE);\\n    uint row = 0;\\n    (row, , ) = BinaryDecoder.decodeUint16Aligned(column, bufferIndex, offset);\\n\\n    uint contentLibraryIndex = row >> 8;\\n    contentIndex = row & 0xFF;\\n    contentLibraryHash = uint256(column[contentLibraryIndex]);\\n  }\\n\\n  function readDictionaryString(bytes32 dictionarySlot, uint ordinal) public view returns ( string memory ) {\\n    return PackedVarArray.getString(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  function getDictionaryStringInfo(bytes32 dictionarySlot, uint ordinal) internal view returns ( bytes32 firstSlot, uint offset, uint length ) {\\n    return PackedVarArray.getStringInfo(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  function readDictionaryStringLength(bytes32 dictionarySlot, uint ordinal) public view returns ( uint ) {\\n    return PackedVarArray.getStringLength(getColumn(dictionarySlot), ordinal);\\n  }\\n\\n  /*\\n   * Uint256 Column\\n   *\\n   */\\n  function readUint256Column(bytes32 columnSlot, uint ordinal) public view returns (\\n    uint\\n  ) {\\n    bytes32[MAX_COLUMN_WORDS] storage column = getColumn(columnSlot);\\n    return uint256(column[ordinal]);\\n  }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessMetadataURIV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nimport './NamelessDataV1.sol';\\nimport '../utils/Base64.sol';\\n\\nlibrary NamelessMetadataURIV1 {\\n  bytes constant private BASE_64_URL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\\n\\n  function base64EncodeBuffer(bytes memory buffer, bytes memory output, uint outOffset) internal pure returns (uint) {\\n    uint outLen = (buffer.length + 2) / 3 * 4 - ((3 - ( buffer.length % 3 )) % 3);\\n\\n    uint256 i = 0;\\n    uint256 j = outOffset;\\n\\n    for (; i + 3 <= buffer.length; i += 3) {\\n        (output[j], output[j+1], output[j+2], output[j+3]) = base64Encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            uint8(buffer[i+2])\\n        );\\n\\n        j += 4;\\n    }\\n\\n    if ((i + 2) == buffer.length) {\\n      (output[j], output[j+1], output[j+2], ) = base64Encode3(\\n          uint8(buffer[i]),\\n          uint8(buffer[i+1]),\\n          0\\n      );\\n    } else if ((i + 1) == buffer.length) {\\n      (output[j], output[j+1], , ) = base64Encode3(\\n          uint8(buffer[i]),\\n          0,\\n          0\\n      );\\n    }\\n\\n    return outOffset + outLen;\\n  }\\n\\n  function base64Encode(uint256 bigint, bytes memory output, uint outOffset) internal pure returns (uint) {\\n      bytes32 buffer = bytes32(bigint);\\n\\n      uint256 i = 0;\\n      uint256 j = outOffset;\\n\\n      for (; i + 3 <= 32; i += 3) {\\n          (output[j], output[j+1], output[j+2], output[j+3]) = base64Encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n      (output[j], output[j+1], output[j+2], ) = base64Encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n      return outOffset + 43;\\n  }\\n\\n  function base64Encode3(uint256 a0, uint256 a1, uint256 a2)\\n      internal\\n      pure\\n      returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)\\n  {\\n\\n      uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n      uint256 c0 = (n >> 18) & 63;\\n      uint256 c1 = (n >> 12) & 63;\\n      uint256 c2 = (n >>  6) & 63;\\n      uint256 c3 = (n      ) & 63;\\n\\n      b0 = BASE_64_URL_CHARS[c0];\\n      b1 = BASE_64_URL_CHARS[c1];\\n      b2 = BASE_64_URL_CHARS[c2];\\n      b3 = BASE_64_URL_CHARS[c3];\\n  }\\n\\n\\n  function writeAddressToString(address addr, bytes memory output, uint outOffset) internal pure returns(uint) {\\n    bytes32 value = bytes32(uint256(uint160(addr)));\\n    bytes memory alphabet = '0123456789abcdef';\\n\\n    output[outOffset++] = '0';\\n    output[outOffset++] = 'x';\\n    for (uint256 i = 0; i < 20; i++) {\\n      output[outOffset + (i*2) ]    = alphabet[uint8(value[i + 12] >> 4)];\\n      output[outOffset + (i*2) + 1] = alphabet[uint8(value[i + 12] & 0x0f)];\\n    }\\n    outOffset += 40;\\n    return outOffset;\\n  }\\n\\n  function copyDictionaryString(Context memory context, bytes32 columnSlot, uint256 ordinal) internal view returns (uint) {\\n    bytes32 curSlot;\\n    uint offset;\\n    uint length;\\n    (curSlot, offset, length) = NamelessDataV1.getDictionaryStringInfo(columnSlot, ordinal);\\n\\n    bytes32 curBuffer;\\n    uint remaining = length;\\n    uint bufferCap = 32 - offset;\\n    uint outIdx = 0;\\n\\n    while (outIdx < length) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = offset + copyCount;\\n      curBuffer = StorageSlot.getBytes32Slot(curSlot).value;\\n\\n      while( offset < lastOffset) {\\n        context.output[context.outOffset + outIdx++] = curBuffer[offset++];\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      offset = 0;\\n      curSlot = bytes32(uint(curSlot) + 1);\\n    }\\n\\n    return context.outOffset + outIdx;\\n  }\\n\\n  function copyString(Context memory context, string memory value) internal pure returns (uint) {\\n    for (uint idx = 0; idx < bytes(value).length; idx++) {\\n      context.output[context.outOffset + idx] = bytes(value)[idx];\\n    }\\n\\n    return context.outOffset + bytes(value).length;\\n  }\\n\\n\\n  struct Context {\\n    uint codeBufferIndex;\\n    uint codeBufferOffset;\\n    uint256 tokenId;\\n    address owner;\\n    string arweaveContentApi;\\n    string ipfsContentApi;\\n\\n    uint opsRetired;\\n\\n    uint outOffset;\\n    bytes output;\\n    bool done;\\n    uint8  stackLength;\\n    bytes32[0xFF] stack;\\n  }\\n\\n  // 4byte opcode to write the bytes32 at the top of the stack to the output raw and consume it\\n  // byte 1 is the write codepoint,\\n  // byte 2 is the write format (0 = raw, 1 = hex, 2 = base64),\\n  // byte 3 is the offset big-endian to start at and\\n  // byte 4 is the big-endian byte to stop at (non-inclusive)\\n  function execWrite(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal pure {\\n    require(context.stackLength > 0, 'stack underflow');\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint start = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint end = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    if (format == 0) {\\n      bytes32 stackTop = bytes32(context.stack[context.stackLength - 1]);\\n      for (uint idx = start; idx < end; idx++) {\\n        context.output[ context.outOffset ++ ] = stackTop[idx];\\n      }\\n    } else if (format == 1) {\\n      uint256 stackTop = uint256(context.stack[context.stackLength - 1]);\\n      bytes memory alphabet = '0123456789abcdef';\\n      uint startNibble = start * 2;\\n      uint endNibble = end * 2;\\n\\n      stackTop >>= (64 - endNibble) * 4;\\n\\n      context.output[context.outOffset++] = '0';\\n      context.output[context.outOffset++] = 'x';\\n      for (uint256 i = endNibble-1; i >= startNibble; i--) {\\n        uint nibble = stackTop & 0xf;\\n        stackTop >>= 4;\\n        context.output[context.outOffset + i - startNibble ] = alphabet[nibble];\\n      }\\n      context.outOffset += endNibble - startNibble;\\n    } else if (format == 2) {\\n      uint256 stackTop = uint256(context.stack[context.stackLength - 1]);\\n      if (start == 0 && end == 32) {\\n        context.outOffset = base64Encode(stackTop, context.output, context.outOffset);\\n      } else {\\n        uint length = end - start;\\n        bytes memory temp = new bytes(length);\\n        for (uint idx = 0; idx < length; idx++) {\\n          temp[idx] = bytes32(stackTop)[start + idx];\\n        }\\n        context.outOffset = base64EncodeBuffer(temp, context.output, context.outOffset);\\n      }\\n    }\\n\\n\\n    context.stackLength--;\\n  }\\n  // 2byte opcode to write the column-specific data indicated by the column name on the top of the stack\\n  // this column has \\\"typed\\\" data like strings etc\\n  function execWriteContext(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal view {\\n    require(context.stack.length > 0, 'stack underflow');\\n    uint contextId = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    if (contextId == CONTEXT_TOKEN_ID || contextId == CONTEXT_TOKEN_OWNER || contextId == CONTEXT_BLOCK_TIMESTAMP) {\\n      require(format != 0, 'invalid format for uint256');\\n      uint value = 0;\\n      if (contextId == CONTEXT_TOKEN_ID) {\\n        value = context.tokenId;\\n      } else if (contextId == CONTEXT_TOKEN_OWNER ) {\\n        value = uint256(uint160(context.owner));\\n      } else if (contextId == CONTEXT_BLOCK_TIMESTAMP ) {\\n        // solhint-disable-next-line not-rely-on-time\\n        value = uint256(block.timestamp);\\n      }\\n\\n      if (format == 1) {\\n        bytes memory alphabet = '0123456789abcdef';\\n        context.output[context.outOffset++] = '0';\\n        context.output[context.outOffset++] = 'x';\\n        for (uint256 i = 63; i >= 0; i--) {\\n          uint nibble = value & 0xf;\\n          value >>= 4;\\n          context.output[context.outOffset + i] = alphabet[nibble];\\n        }\\n        context.outOffset += 64;\\n      } else if (format == 2) {\\n        context.outOffset = base64Encode(value, context.output, context.outOffset);\\n      }\\n\\n    } else if (contextId == CONTEXT_ARWEAVE_CONTENT_API || contextId == CONTEXT_IPFS_CONTENT_API ) {\\n      require(format == 0, 'invalid format for string');\\n      string memory value;\\n      if (contextId == CONTEXT_ARWEAVE_CONTENT_API) {\\n        value = context.arweaveContentApi;\\n      } else if ( contextId == CONTEXT_IPFS_CONTENT_API) {\\n        value = context.ipfsContentApi;\\n      }\\n\\n      context.outOffset = copyString(context, value);\\n    } else {\\n      revert('Unknown/unsupported context ID');\\n    }\\n  }\\n\\n  // 2byte opcode to write the column-specific data indicated by the column name on the top of the stack\\n  // this column has \\\"typed\\\" data like strings etc\\n  function execWriteColumnar(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal view {\\n    require(context.stack.length > 1, 'stack underflow');\\n    bytes32 columnSlot = context.stack[context.stackLength - 2];\\n    uint columnIndex = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength -= 2;\\n\\n    uint format = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint256 columnMetadata = StorageSlot.getUint256Slot(columnSlot).value;\\n    uint columnType = (columnMetadata >> 248) & 0xFF;\\n\\n    if (columnType == NamelessDataV1.COLUMN_TYPE_STRING) {\\n      require(format == 0, 'invalid format for string');\\n      context.outOffset = copyDictionaryString(context, bytes32(uint256(columnSlot) + 1), columnIndex);\\n    } else if (columnType == NamelessDataV1.COLUMN_TYPE_UINT256) {\\n      require(format != 0, 'invalid format for uint256');\\n      uint value = NamelessDataV1.readUint256Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      if (format == 1) {\\n        bytes memory alphabet = '0123456789abcdef';\\n        context.output[context.outOffset++] = '0';\\n        context.output[context.outOffset++] = 'x';\\n        for (uint256 i = 63; i >= 0; i--) {\\n          uint nibble = value & 0xf;\\n          value >>= 4;\\n          context.output[context.outOffset + i] = alphabet[nibble];\\n        }\\n        context.outOffset += 64;\\n      } else if (format == 2) {\\n        context.outOffset = base64Encode(value, context.output, context.outOffset);\\n      }\\n    } else {\\n      revert('unknown column type');\\n    }\\n  }\\n\\n  // 1byte opcode to push the bytes32 at a given index in the data section onto the stack\\n  // byte 1 is the push codepoint,\\n  function execPushData(Context memory context, bytes32[] memory dataSegment, bytes32[] memory) internal pure {\\n    context.stack[context.stackLength-1] = dataSegment[uint256(context.stack[context.stackLength-1])];\\n  }\\n\\n  // Nbyte opcode to push the immediate bytes in the codeSegment onto the stack\\n  // byte 1 is the pushImmediate codepoint,\\n  // byte 2 big-endian offset to write the first loaded byte from\\n  // byte 3 number of immediate bytes\\n  // bytes 4-N big-endian immediate bytes\\n  function execPushImmediate(Context memory context, bytes32[] memory, bytes32[] memory codeSegment) internal pure {\\n    uint startShiftByte = 31 - uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint length = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n    incrementCodeOffset(context);\\n\\n    uint256 value = 0;\\n    for (uint idx = 0; idx < length; idx++) {\\n      uint byteVal = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n      incrementCodeOffset(context);\\n      value |= byteVal << ((startShiftByte - idx) * 8);\\n    }\\n\\n    context.stack[context.stackLength++] = bytes32(value);\\n  }\\n\\n  uint private constant CONTEXT_TOKEN_ID = 0;\\n  uint private constant CONTEXT_TOKEN_OWNER = 1;\\n  uint private constant CONTEXT_BLOCK_TIMESTAMP = 2;\\n  uint private constant CONTEXT_ARWEAVE_CONTENT_API = 3;\\n  uint private constant CONTEXT_IPFS_CONTENT_API = 4;\\n\\n  // 2byte opcode to push well-known context data to the stack\\n  // byte 1 is the push codepoint,\\n  // byte 2 well-known context id\\n  function execPushContext(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    uint contextId = uint256(context.stack[context.stackLength-1]);\\n\\n    if (contextId == CONTEXT_TOKEN_ID) {\\n      context.stack[context.stackLength-1] = bytes32(context.tokenId);\\n    } else if (contextId == CONTEXT_TOKEN_OWNER ) {\\n      context.stack[context.stackLength-1] = bytes32(uint256(uint160(context.owner)));\\n    } else if (contextId == CONTEXT_BLOCK_TIMESTAMP ) {\\n      // solhint-disable-next-line not-rely-on-time\\n      context.stack[context.stackLength-1] = bytes32(uint256(block.timestamp));\\n    } else {\\n      revert('Unknown/unsupported context ID');\\n    }\\n  }\\n\\n  // 1byte opcode to push the 32 bytes at the slot indicated by the top of the stack\\n  function execPushStorage(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    bytes32 stackTop = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 1] = StorageSlot.getBytes32Slot(stackTop).value;\\n  }\\n\\n  // 1byte opcode to push the 32 bytes at the slot indicated by the top of the stack\\n  function execPushColumnar(Context memory context, bytes32[] memory, bytes32[] memory) internal view {\\n    require(context.stack.length > 1, 'stack underflow');\\n    bytes32 columnSlot = context.stack[context.stackLength - 2];\\n    uint columnIndex = uint(context.stack[context.stackLength - 1]);\\n    context.stackLength -= 1;\\n\\n    uint256 columnMetadata = StorageSlot.getUint256Slot(columnSlot).value;\\n    uint columnType = (columnMetadata >> 248) & 0xFF;\\n\\n    if (columnType == NamelessDataV1.COLUMN_TYPE_UINT256) {\\n      uint value = NamelessDataV1.readUint256Column(bytes32(uint256(columnSlot) + 1), columnIndex);\\n      context.stack[context.stackLength - 1] = bytes32(value);\\n    } else {\\n      revert('unknown or bad column type');\\n    }\\n  }\\n\\n  function execPop(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    context.stackLength--;\\n  }\\n\\n  function execDup(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    context.stack[context.stackLength] = context.stack[context.stackLength - 1];\\n    context.stackLength++;\\n  }\\n\\n  function execSwap(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    (context.stack[context.stackLength - 1], context.stack[context.stackLength - 2]) = (context.stack[context.stackLength - 2], context.stack[context.stackLength - 1]);\\n  }\\n\\n  function execAdd(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a + b);\\n    context.stackLength--;\\n  }\\n\\n  function execSub(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a - b);\\n    context.stackLength--;\\n  }\\n\\n  function execMul(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a * b);\\n    context.stackLength--;\\n  }\\n\\n  function execDiv(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a / b);\\n    context.stackLength--;\\n  }\\n\\n  function execMod(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(a % b);\\n    context.stackLength--;\\n  }\\n\\n  function execJumpPos(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    addCodeOffset(context, offset);\\n  }\\n\\n  function execJumpNeg(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength--;\\n\\n    subCodeOffset(context, offset);\\n  }\\n\\n  function execBrEZPos(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 value = uint256(context.stack[context.stackLength - 2]);\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength-=2;\\n\\n    if (value == 0) {\\n      addCodeOffset(context, offset);\\n    }\\n  }\\n\\n  function execBrEZNeg(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 value = uint256(context.stack[context.stackLength - 2]);\\n    uint256 offset = uint256(context.stack[context.stackLength - 1]);\\n    context.stackLength-=2;\\n\\n    if (value == 0) {\\n      subCodeOffset(context, offset);\\n    }\\n  }\\n\\n  function execSha3(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 1] = keccak256(abi.encodePacked(a));\\n  }\\n\\n  function execXor(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a ^ b;\\n    context.stackLength--;\\n  }\\n\\n  function execOr(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a | b;\\n    context.stackLength--;\\n  }\\n\\n  function execAnd(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = a & b;\\n    context.stackLength--;\\n  }\\n\\n  function execGt(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a > b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execGte(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a >= b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execLt(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a < b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execLte(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    uint256 a = uint256(context.stack[context.stackLength - 2]);\\n    uint256 b = uint256(context.stack[context.stackLength - 1]);\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a <= b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execEq(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a == b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  function execNeq(Context memory context, bytes32[] memory, bytes32[] memory) internal pure {\\n    bytes32 a = context.stack[context.stackLength - 2];\\n    bytes32 b = context.stack[context.stackLength - 1];\\n    context.stack[context.stackLength - 2] = bytes32(uint256(a != b ? 1 : 0));\\n    context.stackLength--;\\n  }\\n\\n  uint private constant OP_NOOP                = 0x00;\\n  uint private constant OP_WRITE               = 0x01;\\n  uint private constant OP_WRITE_CONTEXT       = 0x02;\\n  uint private constant OP_WRITE_COLUMNAR      = 0x04;\\n  uint private constant OP_PUSH_DATA           = 0x05;\\n  uint private constant OP_PUSH_STORAGE        = 0x06;\\n  uint private constant OP_PUSH_IMMEDIATE      = 0x07;\\n  uint private constant OP_PUSH_CONTEXT        = 0x08;\\n  uint private constant OP_PUSH_COLUMNAR       = 0x09;\\n  uint private constant OP_POP                 = 0x0a;\\n  uint private constant OP_DUP                 = 0x0b;\\n  uint private constant OP_SWAP                = 0x0c;\\n  uint private constant OP_ADD                 = 0x0d;\\n  uint private constant OP_SUB                 = 0x0e;\\n  uint private constant OP_MUL                 = 0x0f;\\n  uint private constant OP_DIV                 = 0x10;\\n  uint private constant OP_MOD                 = 0x11;\\n  uint private constant OP_JUMP_POS            = 0x12;\\n  uint private constant OP_JUMP_NEG            = 0x13;\\n  uint private constant OP_BRANCH_POS_EQ_ZERO  = 0x14;\\n  uint private constant OP_BRANCH_NEG_EQ_ZERO  = 0x15;\\n  uint private constant OP_SHA3                = 0x16;\\n  uint private constant OP_XOR                 = 0x17;\\n  uint private constant OP_OR                  = 0x18;\\n  uint private constant OP_AND                 = 0x19;\\n  uint private constant OP_GT                  = 0x1a;\\n  uint private constant OP_GTE                 = 0x1b;\\n  uint private constant OP_LT                  = 0x1c;\\n  uint private constant OP_LTE                 = 0x1d;\\n  uint private constant OP_EQ                  = 0x1e;\\n  uint private constant OP_NEQ                 = 0x1f;\\n\\n  function incrementCodeOffset(Context memory context) internal pure {\\n    context.codeBufferOffset++;\\n    if (context.codeBufferOffset == 32) {\\n      context.codeBufferOffset = 0;\\n      context.codeBufferIndex++;\\n    }\\n  }\\n\\n  function addCodeOffset(Context memory context, uint offset) internal pure {\\n    uint pc = (context.codeBufferIndex * 32) + context.codeBufferOffset;\\n    pc += offset;\\n    context.codeBufferOffset = pc % 32;\\n    context.codeBufferIndex = pc / 32;\\n  }\\n\\n  function subCodeOffset(Context memory context, uint offset) internal pure {\\n    uint pc = (context.codeBufferIndex * 32) + context.codeBufferOffset;\\n    pc -= offset;\\n    context.codeBufferOffset = pc % 32;\\n    context.codeBufferIndex = pc / 32;\\n  }\\n\\n  function execOne(Context memory context, bytes32[] memory dataSegment, bytes32[] memory codeSegment) internal view {\\n    uint nextOp = uint8(codeSegment[context.codeBufferIndex][context.codeBufferOffset]);\\n\\n    incrementCodeOffset(context);\\n\\n    if (nextOp == OP_NOOP) {\\n      //solhint-disable-previous-line no-empty-blocks\\n    } else if (nextOp == OP_WRITE) {\\n      execWrite(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_WRITE_CONTEXT) {\\n      execWriteContext(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_WRITE_COLUMNAR) {\\n      execWriteColumnar(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_DATA) {\\n      execPushData(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_STORAGE) {\\n      execPushStorage(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_IMMEDIATE) {\\n      execPushImmediate(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_CONTEXT) {\\n      execPushContext(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_PUSH_COLUMNAR) {\\n      execPushColumnar(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_POP) {\\n      execPop(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_DUP) {\\n      execDup(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SWAP) {\\n      execSwap(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_ADD) {\\n      execAdd(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SUB) {\\n      execSub(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_MUL) {\\n      execMul(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_DIV) {\\n      execDiv(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_MOD) {\\n      execMod(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_JUMP_POS) {\\n      execJumpPos(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_JUMP_NEG) {\\n      execJumpNeg(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_BRANCH_POS_EQ_ZERO) {\\n      execBrEZPos(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_BRANCH_NEG_EQ_ZERO) {\\n      execBrEZNeg(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_SHA3) {\\n      execSha3(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_XOR) {\\n      execXor(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_OR) {\\n      execOr(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_AND) {\\n      execAnd(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_GT) {\\n      execGt(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_GTE) {\\n      execGte(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_LT) {\\n      execLt(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_LTE) {\\n      execLte(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_EQ) {\\n      execEq(context, dataSegment, codeSegment);\\n    } else if (nextOp == OP_NEQ) {\\n      execNeq(context, dataSegment, codeSegment);\\n    } else {\\n      revert(string(abi.encodePacked('bad op code: ', Strings.toString(nextOp), ' next_pc: ', Strings.toString(context.codeBufferIndex), ',',  Strings.toString(context.codeBufferOffset))));\\n    }\\n\\n    context.opsRetired++;\\n\\n    if (/*context.opsRetired > 7 || */context.codeBufferIndex >= codeSegment.length) {\\n      context.done = true;\\n    }\\n  }\\n\\n  function interpolateTemplate(uint256 tokenId, address owner, string memory arweaveContentApi, string memory ipfsContentApi, bytes32[] memory dataSegment, bytes32[] memory codeSegment) public view returns (bytes memory) {\\n    Context memory context;\\n    context.output = new bytes(0xFFFF);\\n    context.tokenId = tokenId;\\n    context.owner = owner;\\n    context.arweaveContentApi = arweaveContentApi;\\n    context.ipfsContentApi = ipfsContentApi;\\n    context.outOffset = 0;\\n\\n    while (!context.done) {\\n      execOne(context, dataSegment, codeSegment);\\n    }\\n\\n    bytes memory result = context.output;\\n    uint resultLen = context.outOffset;\\n\\n    //solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      mstore(result, resultLen)\\n    }\\n\\n    return result;\\n  }\\n\\n  function makeDataURI( string memory uriBase, uint256 tokenId, address owner, string memory arweaveContentApi, string memory ipfsContentApi, bytes32[] memory dataSegment, bytes32[] memory codeSegment ) public view returns (string memory) {\\n    bytes memory metadata = interpolateTemplate(tokenId, owner, arweaveContentApi, ipfsContentApi, dataSegment, codeSegment);\\n    return string(abi.encodePacked(uriBase,Base64.encode(metadata)));\\n  }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\n\\nimport './NamelessMetadataURIV1.sol';\\nimport './INamelessTemplateLibrary.sol';\\n\\ncontract NamelessToken is ERC721Enumerable, AccessControl, Initializable {\\n  event TokenMetadataChanged(uint256 tokenId);\\n\\n  bytes32 public constant INFRA_ROLE = keccak256('INFRA_ROLE');\\n  bytes32 public constant MINTER_ROLE = keccak256('MINTER_ROLE');\\n\\n  // Duplicate Token name for cloneability\\n  string private _name;\\n  // Duplicate Token symbol for cloneability\\n  string private _symbol;\\n\\n  address private _templateLibrary;\\n  string private _uriBase;\\n\\n  address payable public royaltyAddress;\\n  uint256 public royaltyBps;\\n\\n  function initialize (\\n    string memory name_,\\n    string memory symbol_,\\n    address templateLibrary_,\\n    address initialAdmin\\n  ) public initializer {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _templateLibrary = templateLibrary_;\\n    _uriBase = 'data:application/json;base64,';\\n    _setupRole(DEFAULT_ADMIN_ROLE, initialAdmin);\\n  }\\n\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    address templateLibrary_\\n  ) ERC721(name_, symbol_) {\\n    initialize(name_, symbol_, templateLibrary_, msg.sender);\\n  }\\n\\n  bool public isSealed;\\n\\n  modifier onlyUnsealed() {\\n    require(!isSealed, 'tokens are sealed');\\n    _;\\n  }\\n\\n  modifier onlySealed() {\\n    require(isSealed, 'tokens are not sealed');\\n    _;\\n  }\\n\\n  function sealTokens() public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed {\\n    isSealed = true;\\n  }\\n\\n  function setColumnData(uint256 columnHash, bytes32[] calldata data, uint offset ) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed {\\n    bytes32[0xFFFF] storage storageData;\\n    uint256 columnDataHash = columnHash + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := columnDataHash\\n    }\\n\\n    for( uint idx = 0; idx < data.length; idx++) {\\n      storageData[idx + offset] = data[idx];\\n    }\\n  }\\n\\n  function setColumnMetadata(uint256 columnHash, uint columnType ) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed {\\n    uint256[1] storage columnMetadata;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      columnMetadata.slot := columnHash\\n    }\\n\\n    columnMetadata[0] = columnMetadata[0] | ((columnType & 0xFF) << 248);\\n  }\\n\\n  function setURIBase(string calldata uriBase_) public onlyRole(INFRA_ROLE) {\\n    _uriBase = uriBase_;\\n  }\\n\\n  /**\\n    * @dev See {IERC721Metadata-name}.\\n    */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n    * @dev See {IERC721Metadata-symbol}.\\n    */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n\\n  function getFeeRecipients(uint256) public view returns (address payable[] memory) {\\n    address payable[] memory result = new address payable[](1);\\n    result[0] = royaltyAddress;\\n    return result;\\n  }\\n\\n  function getFeeBps(uint256) public view returns (uint256[] memory) {\\n    uint256[] memory result = new uint256[](1);\\n    result[0] = royaltyBps;\\n    return result;\\n  }\\n\\n  function setRoyalties( address payable newRoyaltyAddress, uint256 newRoyaltyBps ) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    royaltyAddress = newRoyaltyAddress;\\n    royaltyBps = newRoyaltyBps;\\n  }\\n\\n  uint256 public templateIndex;\\n  bytes32[] public templateData;\\n  bytes32[] public templateCode;\\n\\n  function setLibraryTemplate(uint256 which) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    templateIndex = which;\\n    delete(templateData);\\n    delete(templateCode);\\n  }\\n\\n  function setCustomTemplate(bytes32[] calldata _data, bytes32[] calldata _code) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    templateIndex = type(uint256).max;\\n    templateData = _data;\\n    templateCode = _code;\\n  }\\n\\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n    require(_exists(tokenId), 'no such token');\\n    string memory arweaveContentApi;\\n    string memory ipfsContentApi;\\n    (arweaveContentApi, ipfsContentApi) = INamelessTemplateLibrary(_templateLibrary).getContentApis();\\n\\n    if (templateIndex == type(uint256).max) {\\n      return NamelessMetadataURIV1.makeDataURI(_uriBase, tokenId, ownerOf(tokenId), arweaveContentApi, ipfsContentApi, templateData, templateCode);\\n    } else {\\n      bytes32[] memory libraryTemplateData;\\n      bytes32[] memory libraryTemplateCode;\\n      (libraryTemplateData, libraryTemplateCode) = INamelessTemplateLibrary(_templateLibrary).getTemplate(templateIndex);\\n      return NamelessMetadataURIV1.makeDataURI(_uriBase, tokenId, ownerOf(tokenId), arweaveContentApi, ipfsContentApi, libraryTemplateData, libraryTemplateCode);\\n    }\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_COUNT_EXTENSION = 0x1;\\n  uint256 public constant TOKEN_TRANSFER_TIME_EXTENSION  = 0x2;\\n\\n  uint256 public extensions;\\n  function enableExtensions(uint256 newExtensions) public onlyRole(DEFAULT_ADMIN_ROLE) onlyUnsealed {\\n    extensions = extensions | newExtensions;\\n\\n    if (newExtensions & TOKEN_TRANSFER_COUNT_EXTENSION != 0) {\\n      initializeTokenTransferCountExtension();\\n    }\\n\\n    if (newExtensions & TOKEN_TRANSFER_TIME_EXTENSION != 0) {\\n      initializeTokenTransferTimeExtension();\\n    }\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_COUNT_EXTENSION_SLOT = uint256(keccak256('TOKEN_TRANSFER_COUNT_EXTENSION_SLOT'));\\n  function initializeTokenTransferCountExtension() internal {\\n    uint256[1] storage storageMetadata;\\n    uint256 metadataSlot = TOKEN_TRANSFER_COUNT_EXTENSION_SLOT;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageMetadata.slot := metadataSlot\\n    }\\n\\n    storageMetadata[0] = 0x2 << 248;\\n  }\\n\\n  function processTokenTransferCountExtension(uint256 tokenId) internal {\\n    uint256[0xFFFF] storage storageData;\\n    uint256 columnDataHash = TOKEN_TRANSFER_COUNT_EXTENSION_SLOT + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := columnDataHash\\n    }\\n\\n    storageData[tokenId] = storageData[tokenId] + 1;\\n  }\\n\\n  uint256 public constant TOKEN_TRANSFER_TIME_EXTENSION_SLOT = uint256(keccak256('TOKEN_TRANSFER_TIME_EXTENSION_SLOT'));\\n  function initializeTokenTransferTimeExtension() internal {\\n    uint256[1] storage storageMetadata;\\n    uint256 metadataSlot = TOKEN_TRANSFER_TIME_EXTENSION_SLOT;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageMetadata.slot := metadataSlot\\n    }\\n\\n    storageMetadata[0] = 0x2 << 248;\\n  }\\n\\n  function processTokenTransferTimeExtension(uint256 tokenId) internal {\\n    uint256[0xFFFF] storage storageData;\\n    uint256 columnDataHash = TOKEN_TRANSFER_TIME_EXTENSION_SLOT + 1;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      storageData.slot := columnDataHash\\n    }\\n\\n    // solhint-disable-next-line not-rely-on-time\\n    storageData[tokenId] = block.timestamp;\\n  }\\n\\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n    super._beforeTokenTransfer(from, to, tokenId);\\n    if (extensions & TOKEN_TRANSFER_COUNT_EXTENSION != 0) {\\n      // don't count minting as a transfer\\n      if (from != address(0)) {\\n        processTokenTransferCountExtension(tokenId);\\n      }\\n    }\\n\\n    if (extensions & TOKEN_TRANSFER_TIME_EXTENSION != 0) {\\n      processTokenTransferTimeExtension(tokenId);\\n    }\\n\\n    if (extensions != 0) {\\n      emit TokenMetadataChanged(tokenId);\\n    }\\n  }\\n\\n  function mint(address to, uint256 tokenId) public onlyRole(MINTER_ROLE) onlySealed {\\n    _safeMint(to, tokenId);\\n  }\\n\\n  function mint(address creator, address recipient, uint256 tokenId) public onlyRole(MINTER_ROLE) onlySealed {\\n    _safeMint(creator, tokenId);\\n    _safeTransfer(creator, recipient, tokenId, '');\\n  }\\n\\n  /**\\n    * @dev See {IERC165-supportsInterface}.\\n    */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, AccessControl) returns (bool) {\\n    return interfaceId == _INTERFACE_ID_FEES\\n      || ERC721Enumerable.supportsInterface(interfaceId)\\n      || AccessControl.supportsInterface(interfaceId);\\n  }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/Base64.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n// Adapted from OpenZeppelin public expiriment\\n// @dev see https://github.com/OpenZeppelin/solidity-jwt/blob/2a787f1c12c50da649eed1670b3a6d9c0221dd8e/contracts/Base64.sol for original\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n\\n    bytes constant private BASE_64_URL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\\n\\n    function encode(bytes memory buffer, bytes memory output, uint outOffset) public pure returns (uint) {\\n      uint outLen = (buffer.length + 2) / 3 * 4 - ((3 - ( buffer.length % 3 )) % 3);\\n\\n      uint256 i = 0;\\n      uint256 j = outOffset;\\n\\n      for (; i + 3 <= buffer.length; i += 3) {\\n          (output[j], output[j+1], output[j+2], output[j+3]) = encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n\\n      if (i + 2 == buffer.length) {\\n        (output[j], output[j+1], output[j+2], ) = encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            0\\n        );\\n      } else if (i + 1 == buffer.length) {\\n        (output[j], output[j+1], , ) = encode3(\\n            uint8(buffer[i]),\\n            0,\\n            0\\n        );\\n      }\\n\\n      return outOffset + outLen;\\n    }\\n\\n    function encode(bytes memory buffer) public pure returns (bytes memory) {\\n      uint outLen = (buffer.length + 2) / 3 * 4 - ((3 - ( buffer.length % 3 )) % 3);\\n      bytes memory result = new bytes(outLen);\\n\\n      uint256 i = 0;\\n      uint256 j = 0;\\n\\n      for (; i + 3 <= buffer.length; i += 3) {\\n          (result[j], result[j+1], result[j+2], result[j+3]) = encode3(\\n              uint8(buffer[i]),\\n              uint8(buffer[i+1]),\\n              uint8(buffer[i+2])\\n          );\\n\\n          j += 4;\\n      }\\n\\n      if (i + 2 == buffer.length) {\\n        (result[j], result[j+1], result[j+2], ) = encode3(\\n            uint8(buffer[i]),\\n            uint8(buffer[i+1]),\\n            0\\n        );\\n      } else if (i + 1 == buffer.length) {\\n        (result[j], result[j+1], , ) = encode3(\\n            uint8(buffer[i]),\\n            0,\\n            0\\n        );\\n      }\\n\\n      return result;\\n    }\\n\\n    function encode(uint256 bigint, bytes memory output, uint outOffset) external pure returns (uint) {\\n        bytes32 buffer = bytes32(bigint);\\n\\n        uint256 i = 0;\\n        uint256 j = outOffset;\\n\\n        for (; i + 3 <= 32; i += 3) {\\n            (output[j], output[j+1], output[j+2], output[j+3]) = encode3(\\n                uint8(buffer[i]),\\n                uint8(buffer[i+1]),\\n                uint8(buffer[i+2])\\n            );\\n\\n            j += 4;\\n        }\\n        (output[j], output[j+1], output[j+2], ) = encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n        return outOffset + 43;\\n    }\\n\\n    function encode(uint256 bigint) external pure returns (string memory) {\\n        bytes32 buffer = bytes32(bigint);\\n        bytes memory res = new bytes(43);\\n\\n        uint256 i = 0;\\n        uint256 j = 0;\\n\\n        for (; i + 3 <= 32; i += 3) {\\n            (res[j], res[j+1], res[j+2], res[j+3]) = encode3(\\n                uint8(buffer[i]),\\n                uint8(buffer[i+1]),\\n                uint8(buffer[i+2])\\n            );\\n\\n            j += 4;\\n        }\\n        (res[j], res[j+1], res[j+2], ) = encode3(uint8(buffer[30]), uint8(buffer[31]), 0);\\n        return string(res);\\n    }\\n\\n    function encode3(uint256 a0, uint256 a1, uint256 a2)\\n        private\\n        pure\\n        returns (bytes1 b0, bytes1 b1, bytes1 b2, bytes1 b3)\\n    {\\n\\n        uint256 n = (a0 << 16) | (a1 << 8) | a2;\\n\\n        uint256 c0 = (n >> 18) & 63;\\n        uint256 c1 = (n >> 12) & 63;\\n        uint256 c2 = (n >>  6) & 63;\\n        uint256 c3 = (n      ) & 63;\\n\\n        b0 = BASE_64_URL_CHARS[c0];\\n        b1 = BASE_64_URL_CHARS[c1];\\n        b2 = BASE_64_URL_CHARS[c2];\\n        b3 = BASE_64_URL_CHARS[c3];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/BinaryDecoder.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary BinaryDecoder {\\n    function increment(uint bufferIdx, uint offset, uint amount) internal pure returns (uint, uint) {\\n      offset+=amount;\\n      return (bufferIdx + (offset / 32), offset % 32);\\n    }\\n\\n    function decodeUint8(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint8, uint, uint) {\\n      uint8 result = 0;\\n      result |= uint8(buffers[bufferIdx][offset]);\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (result, bufferIdx, offset);\\n    }\\n\\n    function decodeUint16(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint16, uint, uint) {\\n      uint result = 0;\\n      if (offset % 32 < 31) {\\n        return decodeUint16Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint16(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint16Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint16, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 2);\\n      return (uint16(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint32(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint32, uint, uint) {\\n      if (offset % 32 < 29) {\\n        return decodeUint32Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 16;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint32(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint32Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint32, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1])) << 16;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 2])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 3]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 4);\\n      return (uint32(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint64(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint64, uint, uint) {\\n      if (offset % 32 < 25) {\\n        return decodeUint64Aligned(buffers, bufferIdx, offset);\\n      }\\n\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 56;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 48;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 40;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 32;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 24;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 16;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 8;\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      result |= uint(uint8(buffers[bufferIdx][offset]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 1);\\n      return (uint64(result), bufferIdx, offset);\\n    }\\n\\n    function decodeUint64Aligned(bytes32[0xFFFF] storage buffers, uint bufferIdx, uint offset) internal view returns (uint64, uint, uint) {\\n      uint result = 0;\\n      result |= uint(uint8(buffers[bufferIdx][offset])) << 56;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 1])) << 48;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 2])) << 40;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 3])) << 32;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 4])) << 24;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 5])) << 16;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 6])) << 8;\\n      result |= uint(uint8(buffers[bufferIdx][offset + 7]));\\n      (bufferIdx, offset) = increment(bufferIdx, offset, 8);\\n      return (uint64(result), bufferIdx, offset);\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/bart/git/InfinityTokens-contract/contracts/utils/PackedVarArray.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './BinaryDecoder.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nlibrary PackedVarArray {\\n  function getString(bytes32[0xFFFF] storage buffers, uint offset, uint len) internal view returns (string memory) {\\n    bytes memory result = new bytes(len);\\n\\n    uint bufferIdx = offset / 32;\\n    uint bufferOffset = offset % 32;\\n    uint outIdx = 0;\\n    uint remaining = len;\\n    uint bufferCap = 32 - bufferOffset;\\n\\n\\n    while (outIdx < len) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = bufferOffset + copyCount;\\n      bytes32 buffer = bytes32(buffers[bufferIdx]);\\n      while( bufferOffset < lastOffset) {\\n        result[outIdx++] = buffer[bufferOffset++];\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      bufferOffset = 0;\\n      bufferIdx++;\\n    }\\n\\n    return string(result);\\n  }\\n\\n  function getString(bytes32[0xFFFF] storage buffers, uint index) internal view returns (string memory) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint stringOffset = stringOffsetLen & 0xFFFF;\\n    uint stringLen = stringOffsetLen >> 16;\\n\\n    return getString(buffers, stringOffset, stringLen);\\n  }\\n\\n  function getStringInfo(bytes32[0xFFFF] storage buffers, uint index) internal view returns ( bytes32 firstSlot, uint offset, uint length ) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint stringOffset = stringOffsetLen & 0xFFFF;\\n    uint stringLen = stringOffsetLen >> 16;\\n    uint bufferIdx = stringOffset / 32;\\n    uint bufferOffset = stringOffset % 32;\\n    bytes32 bufferSlot;\\n\\n    //solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      bufferSlot := buffers.slot\\n    }\\n\\n    bufferSlot = bytes32(uint(bufferSlot) +  bufferIdx);\\n\\n\\n    return (bufferSlot, bufferOffset, stringLen);\\n  }\\n\\n  function getStringLength(bytes32[0xFFFF] storage buffers, uint index) internal view returns (uint) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint stringOffsetLen;\\n    (stringOffsetLen,,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    return stringOffsetLen >> 24;\\n  }\\n\\n  function getUint16Array(bytes32[0xFFFF] storage buffers, uint offset, uint len) internal view returns (uint16[] memory) {\\n    uint16[] memory result = new uint16[](len);\\n\\n    uint bufferIdx = offset / 32;\\n    uint bufferOffset = offset % 32;\\n    uint outIdx = 0;\\n    uint remaining = len * 2;\\n    uint bufferCap = 32 - bufferOffset;\\n\\n\\n    while (outIdx < len) {\\n      uint copyCount = remaining > bufferCap ? bufferCap : remaining;\\n      uint lastOffset = bufferOffset + copyCount;\\n      bytes32 buffer = bytes32(buffers[bufferIdx]);\\n      while (bufferOffset < lastOffset) {\\n        result[outIdx]  = uint16(uint8(buffer[bufferOffset++])) << 8;\\n        result[outIdx] |= uint16(uint8(buffer[bufferOffset++]));\\n        outIdx++;\\n      }\\n      remaining -= copyCount;\\n      bufferCap = 32;\\n      bufferOffset = 0;\\n      bufferIdx++;\\n    }\\n\\n    return result;\\n  }\\n\\n  function getUint16Array(bytes32[0xFFFF] storage buffers, uint index) internal view returns (uint16[] memory) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint arrOffsetLen;\\n    (arrOffsetLen, ,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint arrOffset = arrOffsetLen & 0xFFFFFF;\\n    uint arrLen = arrOffsetLen >> 24;\\n\\n    return getUint16Array(buffers, arrOffset, arrLen);\\n  }\\n\\n  function getUint16ArrayInfo(bytes32[0xFFFF] storage buffers, uint index) internal view returns ( uint, uint, uint ) {\\n    uint offsetLoc = uint(index) * 4;\\n    uint arrOffsetLen;\\n    (arrOffsetLen, ,) = BinaryDecoder.decodeUint32Aligned(buffers, offsetLoc / 32, offsetLoc % 32);\\n    uint arrOffset = arrOffsetLen & 0xFFFFFF;\\n    uint arrLen = arrOffsetLen >> 24;\\n    uint bufferIdx = arrOffset / 32;\\n    uint bufferOffset = arrOffset % 32;\\n\\n    return (bufferIdx, bufferOffset, arrLen);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                Strings.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                Strings.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n            || interfaceId == type(IERC721Metadata).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n            : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/bart/git/InfinityTokens-contract/contracts/nameless/NamelessMetadataURIV1.sol\": {\r\n        \"NamelessMetadataURIV1\": \"0xC023F3c051cc457CD7138E026a6c6939b3122D31\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"templateLibrary_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenMetadataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFRA_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_COUNT_EXTENSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_COUNT_EXTENSION_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_TIME_EXTENSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_TRANSFER_TIME_EXTENSION_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newExtensions\",\"type\":\"uint256\"}],\"name\":\"enableExtensions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getFeeBps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getFeeRecipients\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"templateLibrary_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sealTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"columnHash\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"setColumnData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"columnHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"columnType\",\"type\":\"uint256\"}],\"name\":\"setColumnMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_data\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_code\",\"type\":\"bytes32[]\"}],\"name\":\"setCustomTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"which\",\"type\":\"uint256\"}],\"name\":\"setLibraryTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newRoyaltyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newRoyaltyBps\",\"type\":\"uint256\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uriBase_\",\"type\":\"string\"}],\"name\":\"setURIBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templateCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templateData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"templateIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NamelessToken", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000164e616d656c65737320436c6f6e61626c6520426173650000000000000000000000000000000000000000000000000000000000000000000000000000000000034e43420000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}