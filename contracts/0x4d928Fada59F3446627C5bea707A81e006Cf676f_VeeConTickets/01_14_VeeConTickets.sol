/*
WWWNNWNNNNNNNNNNNNNNNXXXXXXXXXXXXXXKKKKKKKKKKKKKKKKKNWMMMMMMMMMMMMMWNXXKK0000000000000000000000OOO0X
WNNNNNXXXXXXXXXXXXKKKKKKKKKK00000000000OOOOOOOOOOOOKNMMMMMMMMMWWNXK0OOOkkkkkkkkkxxxxxxxxxxxxxxxxxxx0
MWNNXXXXXXXXXXXXXKKKKKKKKKKKKK00000000000000OOOO0KXWMMMMMMMWNXK0OOOOOOOkkkkkkkkkkkkkkxxxxxxxxxxxxxx0
MMWNXXXXXXXXXXXXXKKKKKKKKKKKKKKKKK00000000000000XWMMMMMMMWNK0OOOOOOOOOOOOOOkkkkkkkkkkkkkkkkkxxxxxxk0
MMMWNXXXXXXXXXXKKKKKKKKKKKKKKKKKKKKKKKKK0000000XWMMMMMMWXK00000OOOOOOOOOOOOOOOOOkkkkkkkkkkkkkkkkkkkK
MMMMWNXXXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KK0KXWMMMMMWNK000000000OOOOOOOOOOOOOOOOOOOkkkkkkkkkkkkkkkK
MMMMMWXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXWMMMMMWXK00000000000000OOOOOOOOOOOOOOOOOOOOOOOkkkkkkOK
MMMMMMWXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KXWMMMMMWX00000000000000000000OOOOOOOOOOOOOOOOOOOOOOOOOOK
MMMMMMMWXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000KXWMMMMWNX0000000000000000000000000000OOOOOOOOOOOOOOOOOOOK
MMMMMMMMWXKKKKKKKKKKKKKKKKKKKKK0000000000KXWMMMMMNXK0000000000000000000000000000000000OOOOOOOOOOOOOX
MMMMMMMMMWXKKKKKKKKKKKK00000000000000000KXWMMMMMWX0000000000000000000000000000000000000000000000000X
MMMMMMMMMMWXK0K000000000000000000000000KXWMMMMMMNK00KKKKKKKKKKK0KKK00000000000000000000000000000000X
MMMMMMMMMMMWXK000000000000000000000000KNWMMMMMMMNKKKKKKKKKKKKKKKKKKKKKKKKK0000000000000000000000000X
MMMMMMMMMMMMWXK00000000000000000KK000KNWMMMMMMMMNKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000000000000000000KX
MMMMMMMMMMMMMWXK000000K0000KKKK0KKKKKNWMMMMMMMMMNXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKN
MMMMMMMMMMMMMMWXK00KKKKKKKKKKKKKKKKKNWMMMMMMMMMMWXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKN
MMMMMMMMMMMMMMMWNKKKKKKKKKKKKKKKKKXNMMMMMMMMMMMMWNXXXKXXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKN
MMMMMMMMMMMMMMMMWNKKKKKKKKKKKKKKKXNMMMMMMMMMMMMMMWWNXXXXXXXXKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXXXN
MMMMMMMMMMMMMMMMMWNKKKKKKKKKXXXXXWMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXN
MMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXWMMMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXN
MMMMMMMMMMMMMMMMMMMMNXXXXXXXXXNWMMMMMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXN
MMMMMMMMMMMMMMMMMMMMWNXXXXXXXNWMMMMMMMMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXN
MMMMMMMMMMMMMMMMMMMMMMWNXXXXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMWNXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKKKKKKXN
MMMMMMMMMMMMMMMMMMMMMMMWXXXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNNXXXXXXXXXXXXXXXXXXXXXXXXKKKKKKKKKKKKKN
MMMMMMMMMMMMMMMMMMMMMMMMWNNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXXXXXXXXXXXXKKKKKKKKKKKKKKKKKKKKKN
MMMMMMMMMMMMMMMMMMMMMMMMMWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWNNNNNNNNNNNNNNNNNNNNNNXXXXXXXXN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NXXWMMMMMMWXXWMMMMMWXXXXXXXXNWMMMMMWXXXXXXXXNMMMMMMMMMWNKKKXNWMMMMMMMMMNXKKKXWMMMMMMMMMWXXNWMMMMMWXX
O;,OMMMMMWx'cXMMMMM0;.';;;;;dNMMMMMO,.';;;;;xWMMMMMMXx:,,,,,,dNMMMMMW0l,,;;,';dXMMMMMMMK:.,xWMMMMk':
Nc :XMMMM0,.xWMMMMMO. lKKKKKNWMMMMMk..oKKKKKNMMMMMMK;.,xKXX0xOWMMMMWd..o0XXKx, ,0MMMMMMK,  .oXMMMd.,
M0,.dWMMNc.lNMMMMMMO..oNNNNWMMMMMMMk..xNNNNWMMMMMNKl '0MMMMMMMMMMMMO..oWMMMMMO' lNMMMMMK,.:,.:KMMd.,
MWx.'0MWd.,KMMMMMMM0' .;;;:kWMMMMMMO. .;;;:OMMMMMKx, :XMMMMMMMMMMMWd..kMMMMMMX; ;XMMMMMK,.kKc.,OWd.,
MMXc.cNO'.kMMMMMMMM0'.l0000NMMMMMMMO..l00O0NMMMMMXO; ;KMMMMMMMMMMMMx..xMMMMMMK, cNMMMMMK,.kMNo..do.,
MMM0'.o:.oNMMMMMMMM0'.xMMMMMMMMMMMMO..kMMMMMMMMMMWNd..lXMMMWNNWMMMMK; ;KWMMMNo..kMMMMMMK,.kMMWk'.. ,
MMMWd.  :XMMMMMMMMMO. 'cccccxNMMMMMk. ,ccccckWMMMMMNx,.':lc:;dNMMMMM0c.'clol;.;OWMMMMMMK,.xMMMW0;  ,
MMMMXl,:OMMMMMMMMMMKc,,,,,,,dNMMMMM0c,,,,,,,xWMMMMMMMKd;'.';oKWMMMMMMNkc'..'ckNMMMMMMMMXl:0MMMMM0c,o
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract VeeConTickets is ERC721, IERC721Enumerable, Ownable, ReentrancyGuard {
    string private baseUri;
    uint256 private currentIndex;

    struct YearConfig {
        uint256 firstId;
        uint256 numTokens;
    }

    uint256 public currentYear;
    mapping(uint256 => YearConfig) public ticketYearConfig;
    mapping(uint256 => uint256) public numMintedByYear;

    constructor(
        string memory initialBaseUri,
        string memory contractName,
        string memory contractSymbol
    ) ERC721(contractName, contractSymbol) {
        setBaseURI(initialBaseUri);
    }

    function setYearConfig(uint256 year, uint256 numTokens) public onlyOwner {
        require(
            currentYear == 0 ||
                currentYear == year ||
                numMintedByYear[currentYear] ==
                ticketYearConfig[currentYear].numTokens,
            "Current year still minting"
        );
        require(numMintedByYear[year] == 0, "Year already minted");

        ticketYearConfig[year] = YearConfig(currentIndex, numTokens);
        numMintedByYear[year] = 0;
        currentYear = year;
    }

    function setBaseURI(string memory newBaseUri)
        public
        onlyOwner
        returns (string memory)
    {
        require(
            bytes(newBaseUri).length > 0,
            "Cannot set base address with an invalid 'baseUrl'."
        );

        baseUri = newBaseUri;
        return baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseUri;
    }

    function mintTicketsBatch(
        uint256 year,
        address[] memory addresses,
        uint256[] memory quantities
    ) public onlyOwner {
        uint256 updatedIndex = currentIndex;

        require(
            addresses.length == quantities.length,
            "Address and quantities need to be equal length"
        );
        require(year == currentYear, "Year is not active or configured");

        uint256 mintCount = 0;
        uint256[][] memory allIds = new uint256[][](addresses.length);

        for (uint256 i; i < addresses.length; i++) {
            uint256 addressQuantity = quantities[i];
            uint256[] memory addressIds = new uint256[](addressQuantity);
            for (uint256 x; x < addressQuantity; x++) {
                addressIds[x] = updatedIndex;
                updatedIndex++;
            }
            mintCount += addressQuantity;
            allIds[i] = addressIds;
        }

        require(
            numMintedByYear[year] + mintCount <=
                ticketYearConfig[year].numTokens,
            "Not enough left to mint batch"
        );

        for (uint256 i; i < allIds.length; i++) {
            for (uint256 x; x < allIds[i].length; x++) {
                _safeMint(addresses[i], allIds[i][x]);
            }
        }

        numMintedByYear[year] += mintCount;
        currentIndex = updatedIndex;
    }

    function transferFromBatch(
        address from,
        address[] memory addresses,
        uint256[] memory tokenIds
    ) public nonReentrant {
        require(
            addresses.length == tokenIds.length,
            "Address and quantities need to be equal length"
        );
        for (uint256 i; i < addresses.length; i++) {
            uint256 tokenId = tokenIds[i];
            require(
                _isApprovedOrOwner(_msgSender(), tokenId),
                "ERC721: transfer caller is not owner nor approved"
            );

            _transfer(from, addresses[i], tokenId);
        }
    }

    function totalSupply() public view returns (uint256) {
        return currentIndex;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 index)
        external
        view
        returns (uint256)
    {
        uint256 balance = balanceOf(_owner);
        require(index < balance, "Owner index out of bounds");

        uint256[] memory ownerTokens = _tokensOfOwner(_owner);
        require(
            balance == ownerTokens.length,
            "Unable to get token of owner by index"
        );

        return ownerTokens[index];
    }

    function tokenByIndex(uint256 index) external view returns (uint256) {
        require(index < totalSupply(), "Global index out of bounds");
        return index;
    }

    function tokensOfOwner(address _owner)
        external
        view
        returns (uint256[] memory ownerTokens)
    {
        return _tokensOfOwner(_owner);
    }

    function _tokensOfOwner(address _owner)
        internal
        view
        returns (uint256[] memory ownerTokens)
    {
        uint256 tokenCount = balanceOf(_owner);

        if (tokenCount == 0) {
            return new uint256[](0);
        } else {
            uint256[] memory result = new uint256[](tokenCount);
            uint256 total = totalSupply();
            uint256 resultIndex = 0;

            uint256 tokenId;
            for (tokenId = 0; tokenId < total; tokenId++) {
                if (_exists(tokenId)) {
                    if (ownerOf(tokenId) == _owner) {
                        result[resultIndex] = tokenId;
                        resultIndex++;
                    }
                }
            }

            return result;
        }
    }

    function _balanceOfOwnerByYear(address _owner, uint256 year)
        internal
        view
        returns (uint256)
    {
        uint256 startTokenId = ticketYearConfig[year].firstId;
        uint256 total = ticketYearConfig[year].numTokens;
        uint256 end = startTokenId + total;
        uint256 balance = 0;

        uint256 tokenId;
        for (tokenId = startTokenId; tokenId < end; tokenId++) {
            if (_exists(tokenId)) {
                if (ownerOf(tokenId) == _owner) {
                    balance++;
                }
            }
        }

        return balance;
    }

    function tokensOfOwnerByYear(address _owner, uint256 year)
        external
        view
        returns (uint256[] memory ownerTokens)
    {
        uint256 tokenCount = _balanceOfOwnerByYear(_owner, year);

        if (tokenCount == 0) {
            return new uint256[](0);
        } else {
            uint256[] memory result = new uint256[](tokenCount);
            uint256 startTokenId = ticketYearConfig[year].firstId;
            uint256 total = ticketYearConfig[year].numTokens;
            uint256 end = startTokenId + total;
            uint256 resultIndex = 0;

            uint256 tokenId;
            for (tokenId = startTokenId; tokenId < end; tokenId++) {
                if (_exists(tokenId)) {
                    if (ownerOf(tokenId) == _owner) {
                        result[resultIndex] = tokenId;
                        resultIndex++;
                    }
                }
            }

            return result;
        }
    }

    function withdraw() public onlyOwner nonReentrant {
        uint256 amount = address(this).balance;
        require(amount > 0, "no balance");
        Address.sendValue(payable(msg.sender), amount);
    }

    function withdrawERC20(address token) public onlyOwner nonReentrant {
        require(address(token) != address(0));
        uint256 balance = IERC721(token).balanceOf(address(this));
        require(balance > 0, "no balance");
        IERC20(token).transfer(msg.sender, balance);
    }

    function withdrawERC721(address token, uint256 tokenId)
        public
        onlyOwner
        nonReentrant
    {
        uint256 balance = IERC721(token).balanceOf(address(this));
        address _owner = IERC721(token).ownerOf(tokenId);
        require(balance > 0, "no balance");
        require(_owner == address(this), "not owner");
        IERC721(token).safeTransferFrom(address(this), msg.sender, tokenId);
    }

    function freezeTokenURI(uint256 id) public onlyOwner {
        emit PermanentURI(baseUri, id);
    }

    function freezeTokenURIBatch(uint256[] memory ids) public onlyOwner {
        for (uint256 i; i < ids.length; i++) {
            emit PermanentURI(baseUri, ids[i]);
        }
    }

    /**
     * @dev Emitted when `tokenMetaData` is ready to be frozen
     */
    event PermanentURI(string _value, uint256 indexed _id);
}