{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Create/contracts/v1/RandomDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {RandomMintModule} from \\\"create/contracts/v1/RandomMintModule.sol\\\";\\nimport {RandomEditionRenderer} from \\\"create/contracts/v1/RandomEditionRenderer.sol\\\";\\nimport {Ownable} from \\\"solady/auth/Ownable.sol\\\";\\n\\n/// @dev This contract is used to deploy RandomMintModule and RandomEditionRenderer\\n/// to a deterministic addresses while using constructor arguments.\\ncontract RandomDeployer is Ownable {\\n    constructor() {\\n        _initializeOwner(tx.origin);\\n    }\\n\\n    function deploy(address mintPayoutAddress)\\n        external\\n        onlyOwner\\n        returns (address randomMintModuleAddress, address randomEditionRendererAddress)\\n    {\\n        randomMintModuleAddress = address(new RandomMintModule(mintPayoutAddress));\\n        randomEditionRendererAddress = address(new RandomEditionRenderer(randomMintModuleAddress));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/RandomMintModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IRandomMintModule, IConfigurable} from \\\"create/interfaces/v1/IRandomMintModule.sol\\\";\\nimport {IMintPayout} from \\\"create/interfaces/v1/IMintPayout.sol\\\";\\nimport {IMintContract} from \\\"create/interfaces/v1/IMintContract.sol\\\";\\nimport {IOwnable} from \\\"create/interfaces/v1/IOwnable.sol\\\";\\nimport {BasicMintConfiguration} from \\\"create/interfaces/v1/BasicMintConfiguration.sol\\\";\\nimport {Version} from \\\"create/contracts/v1/Version.sol\\\";\\n\\ncontract RandomMintModule is IRandomMintModule, Version {\\n    IMintPayout public immutable mintPayout;\\n\\n    mapping(address => BasicMintConfiguration) private _configurations;\\n    mapping(address => mapping(address => uint256)) private _mintedByAddress;\\n    mapping(address => uint256) public mintedByContract;\\n    mapping(address => mapping(uint256 => bytes32)) public tokenRandom;\\n\\n    /// @notice Emitted when quantity is zero.\\n    error InvalidQuantity();\\n    /// @notice Emitted if the collector is minting too many tokens per transaction.\\n    error TooManyTokensPerTransaction();\\n    /// @notice Emitted if the collector is minting too many tokens per wallet.\\n    error TooManyTokensPerCollector();\\n    /// @notice Emitted if the collector is minting more tokens than this module is allowed to mint.\\n    error TooManyTokensForModule();\\n    /// @notice Emitted if the mint has not started yet.\\n    error MintNotStarted();\\n    /// @notice Emitted if the mint has ended.\\n    error MintEnded();\\n    /// @notice Emitted when the value sent is incorrect.\\n    error IncorrectPayment();\\n    /// @notice Emitted when the max supply is reached.\\n    error MaxSupplyReached();\\n    /// @notice Emitted when a function is called by a non-owner.\\n    error OnlyOwner();\\n    /// @notice Emitted when a token has already been randomized.\\n    error AlreadyRandomized();\\n    /// @notice Emitted when an invalid token ID is provided.\\n    error InvalidTokenId();\\n\\n    constructor(address _mintPayout) Version(1) {\\n        mintPayout = IMintPayout(_mintPayout);\\n    }\\n\\n    /// @inheritdoc IConfigurable\\n    function updateConfiguration(bytes calldata args) external override {\\n        BasicMintConfiguration memory _config = abi.decode(args, (BasicMintConfiguration));\\n\\n        _configurations[msg.sender] = _config;\\n        emit ConfigurationUpdated(msg.sender, _config);\\n    }\\n\\n    /// @inheritdoc IRandomMintModule\\n    function configuration(address _contract) external view returns (BasicMintConfiguration memory) {\\n        return _configurations[_contract];\\n    }\\n\\n    /// @inheritdoc IRandomMintModule\\n    function mint(address _contract, address _to, address _referrer, uint256 _quantity) external payable {\\n        _mint(_contract, _to, _referrer, _quantity);\\n    }\\n\\n    /// @inheritdoc IRandomMintModule\\n    function mint_efficient_7e80c46e(address _contract, address _to, address _referrer, uint256 _quantity)\\n        external\\n        payable\\n    {\\n        _mint(_contract, _to, _referrer, _quantity);\\n    }\\n\\n    /// @notice The implementation of the mint function.\\n    /// @dev This is implemented as an internal function to share the logic between the `mint` and `mint_efficient_7e80c46e` functions.\\n    /// See the documentation for those functions for information on the parameters.\\n    function _mint(address _contract, address _to, address _referrer, uint256 _quantity) internal {\\n        BasicMintConfiguration memory config = _configurations[_contract];\\n\\n        if (_quantity == 0) revert InvalidQuantity();\\n        if (config.maxPerTransaction > 0 && _quantity > config.maxPerTransaction) revert TooManyTokensPerTransaction();\\n\\n        if (config.maxPerWallet > 0) {\\n            if (_mintedByAddress[_contract][_to] + _quantity > config.maxPerWallet) {\\n                revert TooManyTokensPerCollector();\\n            }\\n        }\\n\\n        if (config.maxForModule > 0 && mintedByContract[_contract] + _quantity > config.maxForModule) {\\n            revert TooManyTokensForModule();\\n        }\\n\\n        if (block.timestamp < config.mintStart) revert MintNotStarted();\\n        if (config.mintEnd > 0 && block.timestamp > config.mintEnd) revert MintEnded();\\n\\n        uint256 protocolFee = mintPayout.protocolFee();\\n        if (msg.value != (config.price + protocolFee) * _quantity) revert IncorrectPayment();\\n\\n        uint256 totalMinted = IMintContract(_contract).totalMinted();\\n        if (config.maxSupply > 0 && totalMinted + _quantity > config.maxSupply) {\\n            revert MaxSupplyReached();\\n        }\\n\\n        _mintedByAddress[_contract][_to] += _quantity;\\n        mintedByContract[_contract] += _quantity;\\n\\n        mintPayout.mintDeposit{value: msg.value}(_contract, msg.sender, _referrer, _quantity);\\n        IMintContract(_contract).mint(_to, _quantity);\\n\\n        for (uint256 i = 1; i <= _quantity;) {\\n            _setRandomForToken(_contract, totalMinted + i);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _setRandomForToken(address _contract, uint256 _tokenId) internal {\\n        tokenRandom[_contract][_tokenId] =\\n            keccak256(abi.encodePacked(_contract, _tokenId, block.prevrandao, blockhash(block.number - 1)));\\n    }\\n\\n    /// @inheritdoc IRandomMintModule\\n    function randomizeTokens(address _contract, uint256[] calldata _tokenIds) external {\\n        address owner = IOwnable(_contract).owner();\\n        if (msg.sender != owner) revert OnlyOwner();\\n\\n        uint256 totalMinted = IMintContract(_contract).totalMinted();\\n\\n        for (uint256 i; i < _tokenIds.length;) {\\n            uint256 _tokenId = _tokenIds[i];\\n            if (tokenRandom[_contract][_tokenId] != bytes32(0)) {\\n                revert AlreadyRandomized();\\n            }\\n\\n            if (_tokenId == 0 || _tokenId > totalMinted) {\\n                revert InvalidTokenId();\\n            }\\n\\n            _setRandomForToken(_contract, _tokenId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/RandomEditionRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {Strings} from \\\"openzeppelin/utils/Strings.sol\\\";\\nimport {Base64} from \\\"openzeppelin/utils/Base64.sol\\\";\\nimport {IMetadataRenderer} from \\\"create/interfaces/v1/IMetadataRenderer.sol\\\";\\nimport {IRandomEditionRenderer, IConfigurable} from \\\"create/interfaces/v1/IRandomEditionRenderer.sol\\\";\\nimport {\\n    RandomEditionRendererConfiguration,\\n    RandomTokenConfiguration,\\n    TokenTrait\\n} from \\\"create/interfaces/v1/RandomEditionRendererConfiguration.sol\\\";\\nimport {IRandomMintModule} from \\\"create/interfaces/v1/IRandomMintModule.sol\\\";\\nimport {Version} from \\\"create/contracts/v1/Version.sol\\\";\\nimport {RandomTokenSelection} from \\\"create/contracts/v1/RandomTokenSelection.sol\\\";\\n\\ncontract RandomEditionRenderer is IMetadataRenderer, IRandomEditionRenderer, Version {\\n    IRandomMintModule public immutable randomMintModule;\\n    mapping(address => RandomEditionRendererConfiguration) _configurations;\\n\\n    error InvalidTokenConfiguration();\\n\\n    using RandomTokenSelection for RandomEditionRendererConfiguration;\\n\\n    constructor(address _randomMintModule) Version(1) {\\n        randomMintModule = IRandomMintModule(_randomMintModule);\\n    }\\n\\n    /// @inheritdoc IConfigurable\\n    function updateConfiguration(bytes calldata args) external {\\n        RandomEditionRendererConfiguration memory config = abi.decode(args, (RandomEditionRendererConfiguration));\\n        if (config.totalWeight == 0) {\\n            revert InvalidTokenConfiguration();\\n        }\\n\\n        if (config.tokens.length == 0) {\\n            revert InvalidTokenConfiguration();\\n        }\\n\\n        _configurations[msg.sender].totalWeight = config.totalWeight;\\n        delete _configurations[msg.sender].tokens;\\n        uint32 totalWeight;\\n        for (uint256 i; i < config.tokens.length;) {\\n            RandomTokenConfiguration memory tokenConfig = config.tokens[i];\\n            RandomTokenConfiguration storage dest = _configurations[msg.sender].tokens.push();\\n            dest.weight = tokenConfig.weight;\\n            dest.tokenName = tokenConfig.tokenName;\\n            dest.tokenDescription = tokenConfig.tokenDescription;\\n            dest.imageIPFSHash = tokenConfig.imageIPFSHash;\\n            dest.animationIPFSHash = tokenConfig.animationIPFSHash;\\n            dest.animationMimeType = tokenConfig.animationMimeType;\\n            for (uint256 j; j < tokenConfig.traits.length;) {\\n                TokenTrait memory trait = tokenConfig.traits[j];\\n                dest.traits.push(trait);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            totalWeight += tokenConfig.weight;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (totalWeight != config.totalWeight) {\\n            revert InvalidTokenConfiguration();\\n        }\\n\\n        emit ConfigurationUpdated(msg.sender, config);\\n    }\\n\\n    /// @inheritdoc IRandomEditionRenderer\\n    function configuration(address mintContract)\\n        external\\n        view\\n        override\\n        returns (RandomEditionRendererConfiguration memory)\\n    {\\n        return _configurations[mintContract];\\n    }\\n\\n    function _tokenConfiguration(address mintContract, uint256 tokenId)\\n        internal\\n        view\\n        returns (RandomTokenConfiguration memory)\\n    {\\n        bytes32 random = randomMintModule.tokenRandom(mintContract, tokenId);\\n        return _configurations[mintContract].getConfiguredToken(random);\\n    }\\n\\n    function tokenURIJSON(address mintContract, uint256 tokenId) public view returns (string memory) {\\n        RandomTokenConfiguration memory config = _tokenConfiguration(mintContract, tokenId);\\n\\n        string memory name =\\n            string.concat('\\\"name\\\":\\\"', escapeJsonString(config.tokenName), \\\" #\\\", Strings.toString(tokenId), '\\\"');\\n\\n        string memory description = bytes(config.tokenDescription).length == 0\\n            ? \\\"\\\"\\n            : string.concat(',\\\"description\\\":\\\"', escapeJsonString(config.tokenDescription), '\\\"');\\n\\n        string memory image = string.concat(',\\\"image\\\":\\\"ipfs://', config.imageIPFSHash, '\\\"');\\n\\n        string memory animation = bytes(config.animationIPFSHash).length == 0\\n            ? \\\"\\\"\\n            : string.concat(\\n                ',\\\"animation_url\\\":\\\"ipfs://',\\n                config.animationIPFSHash,\\n                '\\\",\\\"content\\\":{\\\"mime\\\":\\\"',\\n                config.animationMimeType,\\n                '\\\",\\\"uri\\\":\\\"ipfs://',\\n                config.animationIPFSHash,\\n                '\\\"}'\\n            );\\n\\n        string memory attributes;\\n        if (config.traits.length > 0) {\\n            attributes = ',\\\"attributes\\\":[';\\n            for (uint256 i; i < config.traits.length;) {\\n                attributes = string.concat(\\n                    attributes,\\n                    '{\\\"trait_type\\\":\\\"',\\n                    escapeJsonString(config.traits[i].traitType),\\n                    '\\\",\\\"value\\\":\\\"',\\n                    escapeJsonString(config.traits[i].traitValue),\\n                    '\\\"}'\\n                );\\n\\n                if (i < config.traits.length - 1) {\\n                    attributes = string.concat(attributes, \\\",\\\");\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            attributes = string.concat(attributes, \\\"]\\\");\\n        }\\n\\n        return string.concat(\\\"{\\\", name, description, image, animation, attributes, \\\"}\\\");\\n    }\\n\\n    /// @inheritdoc IMetadataRenderer\\n    function tokenURI(uint256 tokenId) external view override returns (string memory) {\\n        return string.concat(\\\"data:application/json;base64,\\\", Base64.encode(bytes(tokenURIJSON(msg.sender, tokenId))));\\n    }\\n\\n    // JSON escaping code copied from https://github.com/bmeredith/solidity-json-writer\\n    // Used under MIT license, (c) 2016-2020 zOS Global Limited\\n\\n    bytes1 constant BACKSLASH = bytes1(uint8(92));\\n    bytes1 constant BACKSPACE = bytes1(uint8(8));\\n    bytes1 constant CARRIAGE_RETURN = bytes1(uint8(13));\\n    bytes1 constant DOUBLE_QUOTE = bytes1(uint8(34));\\n    bytes1 constant FORM_FEED = bytes1(uint8(12));\\n    bytes1 constant FRONTSLASH = bytes1(uint8(47));\\n    bytes1 constant HORIZONTAL_TAB = bytes1(uint8(9));\\n    bytes1 constant NEWLINE = bytes1(uint8(10));\\n\\n    function escapeJsonString(string memory value) private pure returns (string memory str) {\\n        bytes memory b = bytes(value);\\n        bool foundEscapeChars;\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (b[i] == BACKSLASH) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == DOUBLE_QUOTE) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == FRONTSLASH) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == HORIZONTAL_TAB) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == FORM_FEED) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == NEWLINE) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == CARRIAGE_RETURN) {\\n                foundEscapeChars = true;\\n                break;\\n            } else if (b[i] == BACKSPACE) {\\n                foundEscapeChars = true;\\n                break;\\n            }\\n        }\\n\\n        if (!foundEscapeChars) {\\n            return value;\\n        }\\n\\n        for (uint256 i; i < b.length; i++) {\\n            if (b[i] == BACKSLASH) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\\\\\\\\\\\\"));\\n            } else if (b[i] == DOUBLE_QUOTE) {\\n                str = string(abi.encodePacked(str, '\\\\\\\\\\\"'));\\n            } else if (b[i] == FRONTSLASH) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\/\\\"));\\n            } else if (b[i] == HORIZONTAL_TAB) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\t\\\"));\\n            } else if (b[i] == FORM_FEED) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\f\\\"));\\n            } else if (b[i] == NEWLINE) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\n\\\"));\\n            } else if (b[i] == CARRIAGE_RETURN) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\r\\\"));\\n            } else if (b[i] == BACKSPACE) {\\n                str = string(abi.encodePacked(str, \\\"\\\\\\\\b\\\"));\\n            } else {\\n                str = string(abi.encodePacked(str, b[i]));\\n            }\\n        }\\n\\n        return str;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IRandomMintModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {BasicMintConfiguration} from \\\"create/interfaces/v1/BasicMintConfiguration.sol\\\";\\nimport {IConfigurable} from \\\"create/interfaces/v1/IConfigurable.sol\\\";\\n\\ninterface IRandomMintModuleEvents {\\n    /// @notice Emitted when a contract's mint configuration is updated.\\n    /// @param _contract The address of the contract being configured.\\n    /// @param _config The new configuration.\\n    event ConfigurationUpdated(address indexed _contract, BasicMintConfiguration _config);\\n\\n    /// @notice Emitted when a token's random value is set.\\n    /// @param _contract The address of the contract.\\n    /// @param _tokenId The token ID.\\n    /// @param _random The random value.\\n    event TokenRandomSet(address indexed _contract, uint256 indexed _tokenId, bytes32 _random);\\n}\\n\\ninterface IRandomMintModule is IConfigurable, IRandomMintModuleEvents {\\n    /// @notice Retrieves the minting configuration for a contract.\\n    /// @param _contract The address of the contract.\\n    /// @return The current minting configuration.\\n    function configuration(address _contract) external view returns (BasicMintConfiguration memory);\\n\\n    /// @notice Retrieves the token random value for a given token.\\n    /// @dev This will return the zero value if this hasn't been set yet.\\n    /// @param _contract The address of the contract.\\n    /// @param _tokenId The token ID.\\n    /// @return The token random value.\\n    function tokenRandom(address _contract, uint256 _tokenId) external view returns (bytes32);\\n\\n    /// @notice Randomizes the provided tokens for a contract.\\n    /// @dev Tokens must not be randomized already.\\n    /// Caller must be the owner of the contract.\\n    /// @param _contract The address of the contract.\\n    /// @param _tokenIds The token IDs to randomize.\\n    function randomizeTokens(address _contract, uint256[] calldata _tokenIds) external;\\n\\n    /// @notice Mints tokens for a NFT contract to a recipient.\\n    /// @dev Reverts if the mint does not work in the current configuration.\\n    /// @param _contract The address of the contract to mint for.\\n    /// @param _to The recipient of the tokens.\\n    /// @param _referrer The referrer of this mint, or the zero address if none.\\n    /// @param _quantity The quantity of tokens to mint.\\n    function mint(address _contract, address _to, address _referrer, uint256 _quantity) external payable;\\n\\n    /// @notice Mints tokens for a NFT contract to a recipient.\\n    /// @dev Reverts if the mint does not work in the current configuration.\\n    /// This function is preferred over `mint` because the four byte signature is 0x00000000 which is cheaper to call.\\n    /// The implementation is identical to `mint`.\\n    /// @param _contract The address of the contract to mint for.\\n    /// @param _to The recipient of the tokens.\\n    /// @param _referrer The referrer of this mint, or the zero address if none.\\n    /// @param _quantity The quantity of tokens to mint.\\n    function mint_efficient_7e80c46e(address _contract, address _to, address _referrer, uint256 _quantity)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintPayout.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMintPayoutEvents {\\n    /// @notice Emitted when a deposit has been made.\\n    /// @param from The depositor's address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    /// @param amount The deposit amount.\\n    event Deposit(address from, address to, bytes4 reason, uint256 amount);\\n\\n    /// @notice Emitted when a withdrawal has been made.\\n    /// @param from The address withdrawing.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    event Withdraw(address from, address to, uint256 amount);\\n\\n    /// @notice Emitted during a mint deposit to provide additional context.\\n    /// @param depositedBy The address of the mint initiator.\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the person minting.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param creator The address of the contract creator, or the protocol fee recipient if none.\\n    /// @param creatorPayout The amount being paid to the creator.\\n    /// @param referralPayout The amount being paid to the referrer.\\n    /// @param protocolPayout The amount being paid to the protocol.\\n    /// @param totalAmount The total deposit amount.\\n    /// @param quantity The number of tokens being minted.\\n    /// @param protocolFee The per-mint fee for the protocol.\\n    event MintDeposit(\\n        address depositedBy,\\n        address mintContract,\\n        address minter,\\n        address referrer,\\n        address creator,\\n        uint256 creatorPayout,\\n        uint256 referralPayout,\\n        uint256 protocolPayout,\\n        uint256 totalAmount,\\n        uint256 quantity,\\n        uint256 protocolFee\\n    );\\n\\n    /// @notice Emitted when the protocol fee is updated.\\n    /// @param fee The new protocol fee.\\n    event ProtocolFeeUpdated(uint256 fee);\\n}\\n\\ninterface IMintPayout is IMintPayoutEvents {\\n    function balanceOf(address owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice The current protocol fee per-mint.\\n    function protocolFee() external view returns (uint256 fee);\\n\\n    /// @notice Sets the protocol fee per-mint.\\n    /// @dev Only callable by the owner.\\n    /// @param fee The new protocol fee.\\n    function setProtocolFee(uint256 fee) external;\\n\\n    /// @notice Magic value used to represent the fees belonging to the protocol.\\n    function protocolFeeRecipientAccount() external view returns (address);\\n\\n    /// @notice Withdraws from the protocol fee balance.\\n    /// @dev Only callable by the owner.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdrawProtocolFee(address to, uint256 amount) external;\\n\\n    /// @notice Deposits ether for a mint.\\n    /// @dev Ensure that `quantity` is > 0. The `protocolFee` should be per-mint, not the total taken.\\n    /// Will trigger a `MintDeposit` event, followed by `Deposit` events for:\\n    /// creator payout, protocol payout, and referrer payout (if a referrer is specified).\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the minter.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param quantity The amount being minted.\\n    function mintDeposit(address mintContract, address minter, address referrer, uint256 quantity) external payable;\\n\\n    /// @notice Deposits ether to an address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    function deposit(address to, bytes4 reason) external payable;\\n\\n    /// @notice Deposits ether to multiple addresses.\\n    /// @dev The length of `recipients`, `amounts`, and `reasons` must be the same.\\n    /// @param recipients List of addresses receiving the deposits.\\n    /// @param amounts List of deposit amounts.\\n    /// @param reasons List of reason codes for the deposits.\\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, bytes4[] calldata reasons)\\n        external\\n        payable;\\n\\n    /// @notice Withdraws ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdraw(address to, uint256 amount) external;\\n\\n    /// @notice Withdraws all ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    function withdrawAll(address to) external;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IMetadataRenderer} from \\\"create/interfaces/v1/IMetadataRenderer.sol\\\";\\n\\ninterface IMintContractEvents {\\n    /// @notice Emitted when the royalty is updated.\\n    event RoyaltyUpdated(uint256 bps);\\n    /// @notice Emitted when a new mint module is added.\\n    event ModuleAdded(address module);\\n    /// @notice Emitted when a mint module is removed.\\n    event ModuleRemoved(address module);\\n    /// @notice Emitted when the metadata renderer is updated.\\n    event MetadataRendererUpdated(address renderer);\\n}\\n\\ninterface IMintContract is IMintContractEvents {\\n    /// @notice Mints tokens using approved mint modules.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function mint(address to, uint256 quantity) external;\\n\\n    /// @notice Mints tokens, callable only by the contract owner.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function adminMint(address to, uint256 quantity) external;\\n\\n    /// @notice Retrieves the payout recipient address for this mint contract.\\n    /// @return recipient address of the payout recipient.\\n    function payoutRecipient() external view returns (address recipient);\\n\\n    /// @notice Returns the total number of tokens minted.\\n    /// @return total number of tokens minted.\\n    function totalMinted() external view returns (uint256 total);\\n\\n    /// @notice Adds a new mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// Must be approved in the MintModuleRegistry.\\n    /// @param mintModule The contract address of the mint module.\\n    function addMintModule(address mintModule) external;\\n\\n    /// @notice Removes a mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// @param mintModule The contract address of the mint module.\\n    function removeMintModule(address mintModule) external;\\n\\n    /// @notice Returns whether a mint module is approved.\\n    /// @param mintModule The contract address of the mint module.\\n    /// @return isApproved Whether the mint module is approved.\\n    function isMintModuleApproved(address mintModule) external view returns (bool isApproved);\\n\\n    /// @notice Updates configuration located in an external contract.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// The cardinality of `configurables` and `configData` must be the same.\\n    /// @param configurables The contract addresses to configure.\\n    /// @param configData The configuration data for the contracts.\\n    function updateExternalConfiguration(address[] calldata configurables, bytes[] calldata configData) external;\\n\\n    /// @notice Sets the metadata renderer.\\n    /// @dev This will not request a metadata refresh. If needed, call `refreshMetadata`.\\n    /// @param renderer The new metadata renderer.\\n    function setMetadataRenderer(IMetadataRenderer renderer) external;\\n\\n    /// @notice Returns the metadata renderer for this contract.\\n    /// @return metadataRenderer The metadata renderer.\\n    function metadataRenderer() external returns (IMetadataRenderer metadataRenderer);\\n\\n    /// @notice Triggers a batch metadata update.\\n    function refreshMetadata() external;\\n\\n    /// @notice Updates the royalty for this contract.\\n    /// @dev Can only be called by the contract owner.\\n    /// Emits a `RoyaltyUpdated` event.\\n    /// @param bps The new royalty.\\n    function setRoyalty(uint256 bps) external;\\n\\n    /// @notice Returns the royalty for this contract.\\n    /// @return bps The royalty.\\n    function royaltyBps() external returns (uint256 bps);\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IOwnable {\\n    /// @notice Returns the address of the current owner, or the zero address if there is none.\\n    /// @return The address of the owner of this contract.\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/BasicMintConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nstruct BasicMintConfiguration {\\n    /// @notice Purchase cost per token.\\n    uint256 price;\\n    /// @notice UNIX timestamp of mint start.\\n    uint64 mintStart;\\n    /// @notice UNIX timestamp of mint end, or zero if open-ended.\\n    uint64 mintEnd;\\n    /// @notice Maximum token purchase limit per wallet, or zero if no limit.\\n    uint32 maxPerWallet;\\n    /// @notice Maximum tokens mintable per transaction, or zero if no limit.\\n    uint32 maxPerTransaction;\\n    /// @notice Maximum tokens mintable by this module, or zero if no limit.\\n    uint32 maxForModule;\\n    /// @notice Maximum tokens that can be minted in total, or zero if no max.\\n    uint32 maxSupply;\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/Version.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nabstract contract Version {\\n    /// @notice The version of the contract.\\n    uint32 public immutable contractVersion;\\n\\n    constructor(uint32 _contractVersion) {\\n        contractVersion = _contractVersion;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMetadataRenderer {\\n    /// @notice Retrieves the token URI for the specified token ID.\\n    /// @param tokenId The ID of the token.\\n    /// @return uri The URI of the token.\\n    function tokenURI(uint256 tokenId) external view returns (string memory uri);\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IRandomEditionRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {RandomEditionRendererConfiguration} from \\\"create/interfaces/v1/RandomEditionRendererConfiguration.sol\\\";\\nimport {IConfigurable} from \\\"create/interfaces/v1/IConfigurable.sol\\\";\\n\\ninterface IRandomEditionRendererEvents {\\n    /// @notice Emitted when the configuration is updated for a mint contract.\\n    /// @param mintContract The address of the contract being configured.\\n    /// @param config The new configuration.\\n    event ConfigurationUpdated(address indexed mintContract, RandomEditionRendererConfiguration config);\\n}\\n\\ninterface IRandomEditionRenderer is IRandomEditionRendererEvents, IConfigurable {\\n    /// @notice Retrieves the configuration for a contract.\\n    /// @param mintContract The contract to retreive the configuration for.\\n    /// @return config The current configuration.\\n    function configuration(address mintContract)\\n        external\\n        view\\n        returns (RandomEditionRendererConfiguration memory config);\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/RandomEditionRendererConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nstruct RandomEditionRendererConfiguration {\\n    /// @notice The total weight of all the tokens.\\n    uint32 totalWeight;\\n    /// @notice The configuration for each token.\\n    RandomTokenConfiguration[] tokens;\\n}\\n\\nstruct RandomTokenConfiguration {\\n    /// @notice The weight of this token if it is selected.\\n    uint32 weight;\\n    /// @notice Name of the token\\n    string tokenName;\\n    /// @notice Description of the token\\n    string tokenDescription;\\n    /// @notice IPFS hash for token's image content\\n    string imageIPFSHash;\\n    /// @notice IPFS hash for token's animated content (if any)\\n    /// If empty, no animated content is associated with the token\\n    string animationIPFSHash;\\n    /// @notice Mime type for token's animated content (if any)\\n    string animationMimeType;\\n    /// @notice The traits to display on this token.\\n    TokenTrait[] traits;\\n}\\n\\nstruct TokenTrait {\\n    /// @notice The trait type.\\n    string traitType;\\n    /// @notice The trait value.\\n    string traitValue;\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/RandomTokenSelection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {\\n    RandomEditionRendererConfiguration,\\n    RandomTokenConfiguration\\n} from \\\"create/interfaces/v1/RandomEditionRendererConfiguration.sol\\\";\\n\\nlibrary RandomTokenSelection {\\n    error TokenNotRandomized();\\n    error Unreachable();\\n\\n    function getConfiguredToken(RandomEditionRendererConfiguration storage contractConfig, bytes32 random)\\n        internal\\n        view\\n        returns (RandomTokenConfiguration memory)\\n    {\\n        if (random == 0) {\\n            revert TokenNotRandomized();\\n        }\\n\\n        uint32 totalWeight = contractConfig.totalWeight;\\n        uint32 randomWeight = uint32(bytes4(random)) % totalWeight;\\n\\n        uint32 currentWeight = 0;\\n        for (uint256 i = 0; i < contractConfig.tokens.length; i++) {\\n            RandomTokenConfiguration memory tokenConfig = contractConfig.tokens[i];\\n            currentWeight += tokenConfig.weight;\\n            if (randomWeight < currentWeight) {\\n                return tokenConfig;\\n            }\\n        }\\n\\n        revert Unreachable();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IConfigurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IConfigurable {\\n    /// @notice Updates the configuration for the calling contract.\\n    /// @param data The configuration data.\\n    function updateConfiguration(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"fundrop/=src/Fundrop/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/src/\",\r\n      \"base64/=lib/base64/\",\r\n      \"create/=src/Create/\",\r\n      \"erc4626-tests/=lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/erc721a-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/operator-filter-registry/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 250000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mintPayoutAddress\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"randomMintModuleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"randomEditionRendererAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "RandomDeployer", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "250000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}