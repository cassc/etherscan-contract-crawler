{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"script/foundry/utils/HooksFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { Hook } from \\\"contracts/lib/hooks/Hook.sol\\\";\\n\\ncontract HooksFactory {\\n    function deploy(bytes memory code_, uint256 hookTypeFlag_, uint256 seed_) external returns (address hookAddr) {\\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed_)));\\n        for (uint256 i = 0; i < 1500; i++) {\\n            bytes32 salt = bytes32(randomNumber + i);\\n            bytes32 bytecodeHash = keccak256(code_);\\n            address expectedAddress = Create2.computeAddress(salt, bytecodeHash);\\n            uint160 prefix = hookTypeFlag_ == Hook.SYNC_FLAG ? 0x02 : 0x01;\\n            if (_doesAddressStartWith(expectedAddress, prefix)) {\\n                hookAddr = Create2.deploy(0, salt, code_);\\n                return hookAddr;\\n            }\\n        }\\n    }\\n\\n    function _doesAddressStartWith(address address_,uint160 prefix_) private pure returns (bool) {\\n        return uint160(address_) >> (160 - 2) == prefix_;\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/hooks/Hook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\\npragma solidity ^0.8.19;\\n\\nimport { IHook } from \\\"contracts/interfaces/hooks/base/IHook.sol\\\";\\n\\n/// @title Hooks Library\\n/// @notice This library defines the ExecutionContext struct used when executing hooks.\\n/// @dev The ExecutionContext struct contains two fields: config and params, both of type bytes.\\nlibrary Hook {\\n    uint256 internal constant SYNC_FLAG = 1 << 159;\\n    uint256 internal constant ASYNC_FLAG = 1 << 158;\\n    /// @notice Defines the execution context for a hook.\\n    /// @dev The ExecutionContext struct is used as a parameter when executing hooks.\\n    struct ExecutionContext {\\n        /// @notice The configuration data for the hook, encoded as bytes.\\n        /// @dev This data is used to configure the hook before execution.\\n        /// The configuration is stored in the Module.\\n        bytes config;\\n        /// @notice The parameters for the hook, encoded as bytes.\\n        /// @dev These parameters are passed from the external caller when executing modules.\\n        bytes params;\\n    }\\n\\n    /// @notice Checks if the hook can support synchronous calls.\\n    /// @dev This function checks if the first bit of the hook address is set to 1,\\n    ///      indicating that the hook can support synchronous calls.\\n    /// @param self_ The hook to check.\\n    /// @return A boolean indicating if the hook can support synchronous calls.\\n    function canSupportSyncCall(IHook self_) internal pure returns (bool) {\\n        return uint256(uint160(address(self_))) & SYNC_FLAG != 0;\\n    }\\n\\n    /// @notice Checks if the hook can support asynchronous calls.\\n    /// @dev This function checks if the second bit of the hook address is set to 1,\\n    ///      indicating that the hook can support asynchronous calls.\\n    /// @param self_ The hook to check.\\n    /// @return A boolean indicating if the hook can support asynchronous calls.\\n    function canSupportAsyncCall(IHook self_) internal pure returns (bool) {\\n        return uint256(uint160(address(self_))) & ASYNC_FLAG != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/hooks/base/IHook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @notice Enum for representing various states of an async hook.\\nenum HookResult {\\n    Pending, // Indicates the hook is ongoing execution.\\n    Completed // Indicates the hook has successfully completed.\\n}\\n\\n/// @title Hook Interface.\\n/// @notice This interface defines methods for synchronous and asynchronous hooks.\\n/// @dev Hooks are used to execute custom logic in response to certain events or conditions.\\ninterface IHook {\\n    /// @notice Executes a synchronous hook.\\n    /// @param hookContext_ The context of an executing hook. It is an encoded version of Hook.ExecutionContext\\n    /// @return result The result of the hook execution.\\n    /// @return hookData The data returned by the hook.\\n    function executeSync(bytes calldata hookContext_) external returns (HookResult result, bytes memory hookData);\\n\\n    /// @notice Executes an asynchronous hook.\\n    /// @param hookContext_ The context of an executing hook. It is an encoded version of Hook.ExecutionContext\\n    /// @param callbackHandler_ The address of the callback handler.\\n    /// @return result The result of the hook execution.\\n    /// @return hookData The data returned by the hook.\\n    /// @return requestId The id of the request.\\n    function executeAsync(\\n        bytes calldata hookContext_,\\n        address callbackHandler_\\n    ) external returns (HookResult result, bytes memory hookData, bytes32 requestId);\\n\\n    /// @notice Validates the configuration for the hook.\\n    /// @dev This should be overridden by hook implementations to provide custom validation logic.\\n    /// @param hookConfig_ The configuration data for the hook.\\n    function validateConfig(bytes calldata hookConfig_) external view;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ethereum-waffle/=node_modules/@ethereum-waffle/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"base64-sol/=node_modules/base64-sol/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"solmate/=node_modules/solmate/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"code_\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"hookTypeFlag_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed_\",\"type\":\"uint256\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hookAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HooksFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}