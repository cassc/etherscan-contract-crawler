{"SourceCode": "{\"ACONameFormatter.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\u0027./BokkyPooBahsDateTimeLibrary.sol\\u0027;\\r\\nimport \\u0027./Strings.sol\\u0027;\\r\\n\\r\\nlibrary ACONameFormatter {\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the `value` formatted.\\r\\n\\t * The function returns a string for the `value` with a point (character \\u0027.\\u0027) in the proper position considering the `decimals`.\\r\\n\\t * Beyond that, the string returned presents only representative digits.\\r\\n\\t * For example, a `value` with 18 decimals:\\r\\n\\t *  - For 100000000000000000000 the return is \\\"100\\\"\\r\\n\\t *  - For 100100000000000000000 the return is \\\"100.1\\\"\\r\\n\\t *  - For 100000000000000000 the return is \\\"0.1\\\"\\r\\n\\t *  - For 100000000000000 the return is \\\"0.0001\\\"\\r\\n\\t *  - For 100000000000000000001 the return is \\\"100.000000000000000001\\\"\\r\\n\\t * @param value The number to be formatted.\\r\\n\\t * @param decimals The respective number decimals.\\r\\n     * @return The value formatted on a string.\\r\\n     */\\r\\n    function formatNumber(uint256 value, uint8 decimals) internal pure returns(string memory) {\\r\\n        uint256 digits;\\r\\n        uint256 count;\\r\\n        bool foundRepresentativeDigit = false;\\r\\n        uint256 addPointAt = 0;\\r\\n        uint256 temp = value;\\r\\n        uint256 number = value;\\r\\n        while (temp != 0) {\\r\\n            if (!foundRepresentativeDigit \\u0026\\u0026 (temp % 10 != 0 || count == uint256(decimals))) {\\r\\n                foundRepresentativeDigit = true;\\r\\n                number = temp;\\r\\n            }\\r\\n            if (foundRepresentativeDigit) {\\r\\n                if (count == uint256(decimals)) {\\r\\n                    addPointAt = digits;\\r\\n                }\\r\\n                digits++;\\r\\n            }\\r\\n            temp /= 10;\\r\\n            count++;\\r\\n        }\\r\\n        if (count \\u003c= uint256(decimals)) {\\r\\n            digits = digits + 2 + uint256(decimals) - count;\\r\\n            addPointAt = digits - 2;\\r\\n        } else if (addPointAt \\u003e 0) {\\r\\n            digits++;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = number;\\r\\n        for (uint256 i = 0; i \\u003c digits; ++i) {\\r\\n            if (i \\u003e 0 \\u0026\\u0026 i == addPointAt) {\\r\\n                buffer[index--] = byte(\\\".\\\");\\r\\n            } else if (number == 0) {\\r\\n                buffer[index--] = byte(\\\"0\\\");\\r\\n            } else {\\r\\n                buffer[index--] = byte(uint8(48 + number % 10));\\r\\n                number /= 10;\\r\\n            }\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the `unixTime` formatted.\\r\\n     * @param unixTime The UNIX time to be formatted.\\r\\n     * @return The unix time formatted on a string.\\r\\n     */\\r\\n    function formatTime(uint256 unixTime) internal pure returns(string memory) {\\r\\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(unixTime); \\r\\n        return string(abi.encodePacked(\\r\\n            _getDateNumberWithTwoCharacters(day),\\r\\n            _getMonthFormatted(month),\\r\\n            _getYearFormatted(year),\\r\\n            \\\"-\\\",\\r\\n            _getDateNumberWithTwoCharacters(hour),\\r\\n            _getDateNumberWithTwoCharacters(minute),\\r\\n            \\\"UTC\\\"\\r\\n            )); \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token type description.\\r\\n     * @return The token type description.\\r\\n     */\\r\\n    function formatType(bool isCall) internal pure returns(string memory) {\\r\\n        if (isCall) {\\r\\n            return \\\"C\\\";\\r\\n        } else {\\r\\n            return \\\"P\\\";\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the year formatted with 2 characters.\\r\\n     * @return The year formatted.\\r\\n     */\\r\\n    function _getYearFormatted(uint256 year) private pure returns(string memory) {\\r\\n        bytes memory yearBytes = bytes(Strings.toString(year));\\r\\n        bytes memory result = new bytes(2);\\r\\n        uint256 startIndex = yearBytes.length - 2;\\r\\n        for (uint256 i = startIndex; i \\u003c yearBytes.length; i++) {\\r\\n            result[i - startIndex] = yearBytes[i];\\r\\n        }\\r\\n        return string(result);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the month abbreviation.\\r\\n     * @return The month abbreviation.\\r\\n     */\\r\\n    function _getMonthFormatted(uint256 month) private pure returns(string memory) {\\r\\n        if (month == 1) {\\r\\n            return \\\"JAN\\\";\\r\\n        } else if (month == 2) {\\r\\n            return \\\"FEB\\\";\\r\\n        } else if (month == 3) {\\r\\n            return \\\"MAR\\\";\\r\\n        } else if (month == 4) {\\r\\n            return \\\"APR\\\";\\r\\n        } else if (month == 5) {\\r\\n            return \\\"MAY\\\";\\r\\n        } else if (month == 6) {\\r\\n            return \\\"JUN\\\";\\r\\n        } else if (month == 7) {\\r\\n            return \\\"JUL\\\";\\r\\n        } else if (month == 8) {\\r\\n            return \\\"AUG\\\";\\r\\n        } else if (month == 9) {\\r\\n            return \\\"SEP\\\";\\r\\n        } else if (month == 10) {\\r\\n            return \\\"OCT\\\";\\r\\n        } else if (month == 11) {\\r\\n            return \\\"NOV\\\";\\r\\n        } else if (month == 12) {\\r\\n            return \\\"DEC\\\";\\r\\n        } else {\\r\\n            return \\\"INVALID\\\";\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the date number with 2 characters.\\r\\n     * @return The 2 characters for the number.\\r\\n     */\\r\\n    function _getDateNumberWithTwoCharacters(uint256 number) private pure returns(string memory) {\\r\\n        string memory _string = Strings.toString(number);\\r\\n        if (number \\u003c 10) {\\r\\n            return string(abi.encodePacked(\\\"0\\\", _string));\\r\\n        } else {\\r\\n            return _string;\\r\\n        }\\r\\n    }\\r\\n}\"},\"ACOToken.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./ACONameFormatter.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ACOToken\\r\\n * @dev The implementation of the ACO token.\\r\\n * The token is ERC20 compliant.\\r\\n */\\r\\ncontract ACOToken is ERC20 {\\r\\n    using Address for address;\\r\\n    \\r\\n    /**\\r\\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\\r\\n     */\\r\\n    struct TokenCollateralized {\\r\\n        /**\\r\\n         * @dev Current amount of tokens.\\r\\n         */\\r\\n        uint256 amount;\\r\\n        \\r\\n        /**\\r\\n         * @dev Index on the collateral owners array.\\r\\n         */\\r\\n        uint256 index;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when collateral is deposited on the contract.\\r\\n     * @param account Address of the collateral owner.\\r\\n     * @param amount Amount of collateral deposited.\\r\\n     */\\r\\n    event CollateralDeposit(address indexed account, uint256 amount);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when collateral is withdrawn from the contract.\\r\\n     * @param account Address of the account.\\r\\n     * @param recipient Address of the collateral destination.\\r\\n     * @param amount Amount of collateral withdrawn.\\r\\n     * @param fee The fee amount charged on the withdrawal.\\r\\n     */\\r\\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\\r\\n    \\r\\n    /**\\r\\n     * @dev Emitted when the collateral is used on an assignment.\\r\\n     * @param from Address of the account of the collateral owner.\\r\\n     * @param to Address of the account that exercises tokens to get the collateral.\\r\\n     * @param paidAmount Amount paid to the collateral owner.\\r\\n     * @param tokenAmount Amount of tokens used to exercise.\\r\\n     */\\r\\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the collateralized token is transferred.\\r\\n     * @param from Address of the account of the collateral owner.\\r\\n     * @param to Address of the account to get the collateralized tokens.\\r\\n     * @param tokenCollateralizedAmount Amount of collateralized tokens transferred.\\r\\n     */\\r\\n    event TransferCollateralOwnership(address indexed from, address indexed to, uint256 tokenCollateralizedAmount);\\r\\n\\r\\n    /**\\r\\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \\r\\n     */\\r\\n    address public underlying;\\r\\n    \\r\\n    /**\\r\\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \\r\\n     */\\r\\n    address public strikeAsset;\\r\\n    \\r\\n    /**\\r\\n     * @dev Address of the fee destination charged on the exercise.\\r\\n     */\\r\\n    address payable public feeDestination;\\r\\n    \\r\\n    /**\\r\\n     * @dev True if the type is CALL, false for PUT.\\r\\n     */\\r\\n    bool public isCall;\\r\\n    \\r\\n    /**\\r\\n     * @dev The strike price for the token with the strike asset precision.\\r\\n     */\\r\\n    uint256 public strikePrice;\\r\\n    \\r\\n    /**\\r\\n     * @dev The UNIX time for the token expiration.\\r\\n     */\\r\\n    uint256 public expiryTime;\\r\\n    \\r\\n    /**\\r\\n     * @dev The total amount of collateral on the contract.\\r\\n     */\\r\\n    uint256 public totalCollateral;\\r\\n    \\r\\n    /**\\r\\n     * @dev The fee value. It is a percentage value (100000 is 100%).\\r\\n     */\\r\\n    uint256 public acoFee;\\r\\n    \\r\\n    /**\\r\\n     * @dev Symbol of the underlying asset.\\r\\n     */\\r\\n    string public underlyingSymbol;\\r\\n    \\r\\n    /**\\r\\n     * @dev Symbol of the strike asset.\\r\\n     */\\r\\n    string public strikeAssetSymbol;\\r\\n    \\r\\n    /**\\r\\n     * @dev Decimals for the underlying asset.\\r\\n     */\\r\\n    uint8 public underlyingDecimals;\\r\\n    \\r\\n    /**\\r\\n     * @dev Decimals for the strike asset.\\r\\n     */\\r\\n    uint8 public strikeAssetDecimals;\\r\\n    \\r\\n    /**\\r\\n     * @dev The maximum number of accounts that can be exercised by transaction.\\r\\n     */\\r\\n    uint256 public maxExercisedAccounts;\\r\\n    \\r\\n    /**\\r\\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\\r\\n     */\\r\\n    uint256 internal underlyingPrecision;\\r\\n    \\r\\n    /**\\r\\n     * @dev Accounts that generated tokens with a collateral deposit.\\r\\n     */\\r\\n    mapping(address =\\u003e TokenCollateralized) internal tokenData;\\r\\n    \\r\\n    /**\\r\\n     * @dev Array with all accounts with collateral deposited.\\r\\n     */\\r\\n    address[] internal _collateralOwners;\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal data to control the reentrancy.\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 transfer function.\\r\\n     */\\r\\n    bytes4 internal _transferSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Selector for ERC20 transfer from function.\\r\\n     */\\r\\n    bytes4 internal _transferFromSelector;\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to check if the token is not expired.\\r\\n     * It is executed only while the token is not expired.\\r\\n     */\\r\\n    modifier notExpired() {\\r\\n        require(_notExpired(), \\\"ACOToken::Expired\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Modifier to prevent a contract from calling itself during the function execution.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"ACOToken::Reentry\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to initialize the contract.\\r\\n     * It should be called when creating the token.\\r\\n     * It must be called only once. The first `require` is to guarantee that behavior.\\r\\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\\r\\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\\r\\n     * @param _isCall True if the type is CALL, false for PUT.\\r\\n     * @param _strikePrice The strike price with the strike asset precision.\\r\\n     * @param _expiryTime The UNIX time for the token expiration.\\r\\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\\r\\n     * @param _feeDestination Address of the fee destination charged on the exercise.\\r\\n     * @param _maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\\r\\n     */\\r\\n    function init(\\r\\n        address _underlying,\\r\\n        address _strikeAsset,\\r\\n        bool _isCall,\\r\\n        uint256 _strikePrice,\\r\\n        uint256 _expiryTime,\\r\\n        uint256 _acoFee,\\r\\n        address payable _feeDestination,\\r\\n        uint256 _maxExercisedAccounts\\r\\n    ) public {\\r\\n        require(underlying == address(0) \\u0026\\u0026 strikeAsset == address(0) \\u0026\\u0026 strikePrice == 0, \\\"ACOToken::init: Already initialized\\\");\\r\\n        \\r\\n        require(_expiryTime \\u003e now, \\\"ACOToken::init: Invalid expiry\\\");\\r\\n        require(_strikePrice \\u003e 0, \\\"ACOToken::init: Invalid strike price\\\");\\r\\n        require(_underlying != _strikeAsset, \\\"ACOToken::init: Same assets\\\");\\r\\n        require(_acoFee \\u003c= 500, \\\"ACOToken::init: Invalid ACO fee\\\"); // Maximum is 0.5%\\r\\n        require(_isEther(_underlying) || _underlying.isContract(), \\\"ACOToken::init: Invalid underlying\\\");\\r\\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \\\"ACOToken::init: Invalid strike asset\\\");\\r\\n        require(_maxExercisedAccounts \\u003e= 25 \\u0026\\u0026 _maxExercisedAccounts \\u003c= 150, \\\"ACOToken::init: Invalid number to max exercised accounts\\\");\\r\\n        \\r\\n        underlying = _underlying;\\r\\n        strikeAsset = _strikeAsset;\\r\\n        isCall = _isCall;\\r\\n        strikePrice = _strikePrice;\\r\\n        expiryTime = _expiryTime;\\r\\n        acoFee = _acoFee;\\r\\n        feeDestination = _feeDestination;\\r\\n        maxExercisedAccounts = _maxExercisedAccounts;\\r\\n        underlyingDecimals = _getAssetDecimals(_underlying);\\r\\n        require(underlyingDecimals \\u003c 78, \\\"ACOToken::init: Invalid underlying decimals\\\");\\r\\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\\r\\n        underlyingSymbol = _getAssetSymbol(_underlying);\\r\\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\\r\\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\\r\\n\\r\\n        _transferSelector = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n        _transferFromSelector = bytes4(keccak256(bytes(\\\"transferFrom(address,address,uint256)\\\")));\\r\\n        _notEntered = true;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to guarantee that the contract will not receive ether directly.\\r\\n     */\\r\\n    receive() external payable {\\r\\n        revert();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token name.\\r\\n     */\\r\\n    function name() public view override returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token symbol, that it is equal to the name.\\r\\n     */\\r\\n    function symbol() public view override returns(string memory) {\\r\\n        return _name();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\\r\\n     */\\r\\n    function decimals() public view override returns(uint8) {\\r\\n        return underlyingDecimals;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the current amount of collateral for an account.\\r\\n     * @param account Address of the account.\\r\\n     * @return The current amount of collateral.\\r\\n     */\\r\\n    function currentCollateral(address account) public view returns(uint256) {\\r\\n        return getCollateralAmount(currentCollateralizedTokens(account));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the current amount of unassignable collateral for an account.\\r\\n     * After expiration, the unassignable collateral is equal to the account\\u0027s collateral balance.\\r\\n     * @param account Address of the account.\\r\\n     * @return The respective amount of unassignable collateral.\\r\\n     */\\r\\n    function unassignableCollateral(address account) public view returns(uint256) {\\r\\n        return getCollateralAmount(unassignableTokens(account));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get  the current amount of assignable collateral for an account.\\r\\n     * After expiration, the assignable collateral is zero.\\r\\n     * @param account Address of the account.\\r\\n     * @return The respective amount of assignable collateral.\\r\\n     */\\r\\n    function assignableCollateral(address account) public view returns(uint256) {\\r\\n        return getCollateralAmount(assignableTokens(account));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the current amount of collateralized tokens for an account.\\r\\n     * @param account Address of the account.\\r\\n     * @return The current amount of collateralized tokens.\\r\\n     */\\r\\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\\r\\n        return tokenData[account].amount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the current amount of unassignable tokens for an account.\\r\\n     * After expiration, the unassignable tokens is equal to the account\\u0027s collateralized tokens.\\r\\n     * @param account Address of the account.\\r\\n     * @return The respective amount of unassignable tokens.\\r\\n     */\\r\\n    function unassignableTokens(address account) public view returns(uint256) {\\r\\n        if (balanceOf(account) \\u003e tokenData[account].amount || !_notExpired()) {\\r\\n            return tokenData[account].amount;\\r\\n        } else {\\r\\n            return balanceOf(account);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get  the current amount of assignable tokens for an account.\\r\\n     * After expiration, the assignable tokens is zero.\\r\\n     * @param account Address of the account.\\r\\n     * @return The respective amount of assignable tokens.\\r\\n     */\\r\\n    function assignableTokens(address account) public view returns(uint256) {\\r\\n        if (_notExpired()) {\\r\\n            return _getAssignableAmount(account);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the equivalent collateral amount for a token amount.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @return The respective amount of collateral.\\r\\n     */\\r\\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\\r\\n        if (isCall) {\\r\\n            return tokenAmount;\\r\\n        } else if (tokenAmount \\u003e 0) {\\r\\n            return _getTokenStrikePriceRelation(tokenAmount);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the equivalent token amount for a collateral amount.\\r\\n     * @param collateralAmount Amount of collateral.\\r\\n     * @return The respective amount of tokens.\\r\\n     */\\r\\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\\r\\n        if (isCall) {\\r\\n            return collateralAmount;\\r\\n        } else if (collateralAmount \\u003e 0) {\\r\\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the number of addresses that have collateral deposited.\\r\\n     * @return The number of addresses.\\r\\n     */\\r\\n    function numberOfAccountsWithCollateral() public view returns(uint256) {\\r\\n        return _collateralOwners.length;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the base data for exercise of an amount of token.\\r\\n     * To call the exercise the value returned must be added by the number of accounts that could be exercised:\\r\\n     * - using the \u00b4exercise\u00b4 or \u00b4exerciseFrom\u00b4 functions it will be equal to `maxExercisedAccounts`.\\r\\n     * - using the \u00b4exerciseAccounts\u00b4 or `exerciseAccountsFrom` functions it will be equal to the number of accounts sent as function argument.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @return The asset and the respective base amount that should be sent to get the collateral.\\r\\n     */\\r\\n    function getBaseExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\\r\\n        if (isCall) {\\r\\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \\r\\n        } else {\\r\\n            return (underlying, tokenAmount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @return The collateral to be received and the respective fee.\\r\\n     */\\r\\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\\r\\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\\r\\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\\r\\n        collateralAmount = collateralAmount.sub(fee);\\r\\n        return (collateralAmount, fee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the collateral asset.\\r\\n     * @return The address of the collateral asset.\\r\\n     */\\r\\n    function collateral() public view returns(address) {\\r\\n        if (isCall) {\\r\\n            return underlying;\\r\\n        } else {\\r\\n            return strikeAsset;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to mint tokens with Ether deposited as collateral.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @return The amount of tokens minted.\\r\\n     */\\r\\n    function mintPayable() external payable returns(uint256) {\\r\\n        require(_isEther(collateral()), \\\"ACOToken::mintPayable: Invalid call\\\");\\r\\n        return _mintToken(msg.sender, msg.value);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\\r\\n     * However, the minted tokens are assigned to the transaction sender.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @param account Address of the account that will be the collateral owner.\\r\\n     * @return The amount of tokens minted.\\r\\n     */\\r\\n    function mintToPayable(address account) external payable returns(uint256) {\\r\\n        require(_isEther(collateral()), \\\"ACOToken::mintToPayable: Invalid call\\\");\\r\\n       return _mintToken(account, msg.value);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @param collateralAmount Amount of collateral deposited.\\r\\n     * @return The amount of tokens minted.\\r\\n     */\\r\\n    function mint(uint256 collateralAmount) external returns(uint256) {\\r\\n        address _collateral = collateral();\\r\\n        require(!_isEther(_collateral), \\\"ACOToken::mint: Invalid call\\\");\\r\\n        \\r\\n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\\r\\n        return _mintToken(msg.sender, collateralAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\\r\\n     * However, the minted tokens are assigned to the transaction sender.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @param account Address of the account that will be the collateral owner.\\r\\n     * @param collateralAmount Amount of collateral deposited.\\r\\n     * @return The amount of tokens minted.\\r\\n     */\\r\\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256) {\\r\\n        address _collateral = collateral();\\r\\n        require(!_isEther(_collateral), \\\"ACOToken::mintTo: Invalid call\\\");\\r\\n        \\r\\n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\\r\\n        return _mintToken(account, collateralAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @param tokenAmount Amount of tokens to be burned.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function burn(uint256 tokenAmount) external returns(uint256) {\\r\\n        return _burn(msg.sender, tokenAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\\r\\n     * The token allowance must be respected.\\r\\n     * The collateral is sent to the transaction sender.\\r\\n     * NOTE: The function only works when the token is NOT expired yet. \\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens to be burned.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256) {\\r\\n        return _burn(account, tokenAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the collateral, not assigned, back.\\r\\n     * NOTE: The function only works when the token IS expired. \\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function redeem() external returns(uint256) {\\r\\n        return _redeem(msg.sender);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to get the collateral from a specific account sent back to its address .\\r\\n     * The token allowance must be respected.\\r\\n     * The collateral is sent to the transaction sender.\\r\\n     * NOTE: The function only works when the token IS expired. \\r\\n     * @param account Address of the account.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function redeemFrom(address account) external returns(uint256) {\\r\\n        require(tokenData[account].amount \\u003c= allowance(account, msg.sender), \\\"ACOToken::redeemFrom: Allowance too low\\\");\\r\\n        return _redeem(account);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\\r\\n     * The paid amount is sent to the collateral owners that were assigned.\\r\\n     * NOTE: The function only works when the token is NOT expired. \\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256) {\\r\\n        return _exercise(msg.sender, tokenAmount, salt);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\\r\\n     * The token allowance must be respected.\\r\\n     * The paid amount is sent to the collateral owners that were assigned.\\r\\n     * The collateral is transferred to the transaction sender.\\r\\n     * NOTE: The function only works when the token is NOT expired. \\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256) {\\r\\n        return _exercise(account, tokenAmount, salt);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\\r\\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\\r\\n     * NOTE: The function only works when the token is NOT expired. \\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param accounts The array of addresses to get collateral from.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256) {\\r\\n        return _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to transfer collateralized tokens.\\r\\n     * @param recipient Address of the destination.\\r\\n     * @param tokenCollateralizedAmount Amount of collateralized tokens to be transferred.\\r\\n     */\\r\\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external {\\r\\n        require(recipient != address(0), \\\"ACOToken::transferCollateralOwnership: Invalid recipient\\\");\\r\\n        require(tokenCollateralizedAmount \\u003e 0, \\\"ACOToken::transferCollateralOwnership: Invalid amount\\\");\\r\\n\\r\\n        TokenCollateralized storage senderData = tokenData[msg.sender];\\r\\n        senderData.amount = senderData.amount.sub(tokenCollateralizedAmount);\\r\\n\\r\\n        _removeCollateralDataIfNecessary(msg.sender);\\r\\n\\r\\n        TokenCollateralized storage recipientData = tokenData[recipient];\\r\\n        if (_hasCollateral(recipientData)) {\\r\\n            recipientData.amount = recipientData.amount.add(tokenCollateralizedAmount);\\r\\n        } else {\\r\\n            tokenData[recipient] = TokenCollateralized(tokenCollateralizedAmount, _collateralOwners.length);\\r\\n            _collateralOwners.push(recipient);\\r\\n        }\\r\\n\\r\\n        emit TransferCollateralOwnership(msg.sender, recipient, tokenCollateralizedAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\\r\\n     * The token allowance must be respected.\\r\\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\\r\\n     * The collateral is transferred to the transaction sender.\\r\\n     * NOTE: The function only works when the token is NOT expired. \\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param accounts The array of addresses to get the deposited collateral.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256) {\\r\\n        return _exerciseFromAccounts(account, tokenAmount, accounts);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to redeem respective collateral from an account.\\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _redeemCollateral(address account, uint256 tokenAmount) internal returns(uint256) {\\r\\n        require(_accountHasCollateral(account), \\\"ACOToken::_redeemCollateral: No collateral available\\\");\\r\\n        require(tokenAmount \\u003e 0, \\\"ACOToken::_redeemCollateral: Invalid token amount\\\");\\r\\n        \\r\\n        TokenCollateralized storage data = tokenData[account];\\r\\n        data.amount = data.amount.sub(tokenAmount);\\r\\n        \\r\\n        _removeCollateralDataIfNecessary(account);\\r\\n        \\r\\n        return _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to mint tokens.\\r\\n     * The tokens are minted for the transaction sender.\\r\\n     * @param account Address of the account.\\r\\n     * @param collateralAmount Amount of collateral deposited.\\r\\n     * @return The amount of tokens minted.\\r\\n     */\\r\\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal returns(uint256) {\\r\\n        require(collateralAmount \\u003e 0, \\\"ACOToken::_mintToken: Invalid collateral amount\\\");\\r\\n        \\r\\n        if (!_accountHasCollateral(account)) {\\r\\n            tokenData[account].index = _collateralOwners.length;\\r\\n            _collateralOwners.push(account);\\r\\n        }\\r\\n        \\r\\n        uint256 tokenAmount = getTokenAmount(collateralAmount);\\r\\n        require(tokenAmount != 0, \\\"ACOToken::_mintToken: Invalid token amount\\\");\\r\\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\\r\\n        \\r\\n        totalCollateral = totalCollateral.add(collateralAmount);\\r\\n        \\r\\n        emit CollateralDeposit(account, collateralAmount);\\r\\n        \\r\\n        super._mintAction(msg.sender, tokenAmount);\\r\\n        return tokenAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer collateral. \\r\\n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\\r\\n     * The collateral destination is always the transaction sender address.\\r\\n     * @param account Address of the account.\\r\\n     * @param collateralAmount Amount of collateral to be transferred.\\r\\n     * @param fee Amount of fee charged.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal returns(uint256) {\\r\\n        \\r\\n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\\r\\n        \\r\\n        address _collateral = collateral();\\r\\n        if (_isEther(_collateral)) {\\r\\n            payable(msg.sender).transfer(collateralAmount);\\r\\n            if (fee \\u003e 0) {\\r\\n                feeDestination.transfer(fee);   \\r\\n            }\\r\\n        } else {\\r\\n            _transferERC20(_collateral, msg.sender, collateralAmount);\\r\\n            if (fee \\u003e 0) {\\r\\n                _transferERC20(_collateral, feeDestination, fee);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\\r\\n        return collateralAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to exercise the tokens from an account. \\r\\n     * @param account Address of the account that is exercising.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _exercise(address account, uint256 tokenAmount, uint256 salt) nonReentrant internal returns(uint256) {\\r\\n        _validateAndBurn(account, tokenAmount, maxExercisedAccounts);\\r\\n         _exerciseOwners(account, tokenAmount, salt);\\r\\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\\r\\n        return _transferCollateral(account, collateralAmount, fee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to exercise the tokens from an account. \\r\\n     * @param account Address of the account that is exercising.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param accounts The array of addresses to get the collateral from.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal returns(uint256) {\\r\\n        _validateAndBurn(account, tokenAmount, accounts.length);\\r\\n        _exerciseAccounts(account, tokenAmount, accounts);\\r\\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\\r\\n        return _transferCollateral(account, collateralAmount, fee);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \\r\\n     * @param exerciseAccount Address of the account that is exercising.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param salt Random number to calculate the start index of the array of accounts to be exercised.\\r\\n     */\\r\\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount, uint256 salt) internal {\\r\\n        uint256 accountsExercised = 0;\\r\\n        uint256 start = salt.mod(_collateralOwners.length);\\r\\n        uint256 index = start;\\r\\n        uint256 count = 0;\\r\\n        while (tokenAmount \\u003e 0 \\u0026\\u0026 count \\u003c _collateralOwners.length) {\\r\\n            \\r\\n            uint256 remainingAmount = _exerciseAccount(_collateralOwners[index], tokenAmount, exerciseAccount);\\r\\n            if (remainingAmount \\u003c tokenAmount) {\\r\\n                accountsExercised++;\\r\\n                require(accountsExercised \\u003c maxExercisedAccounts || remainingAmount == 0, \\\"ACOToken::_exerciseOwners: Too many accounts to exercise\\\");\\r\\n            }\\r\\n            tokenAmount = remainingAmount;\\r\\n            \\r\\n            ++index;\\r\\n            if (index == _collateralOwners.length) {\\r\\n                index = 0;\\r\\n            }\\r\\n            ++count;\\r\\n        }\\r\\n        require(tokenAmount == 0, \\\"ACOToken::_exerciseOwners: Invalid remaining amount\\\");\\r\\n        \\r\\n        uint256 indexOnModifyIteration;\\r\\n        bool shouldModifyIteration = false;\\r\\n        if (index == 0) {\\r\\n            index = _collateralOwners.length;\\r\\n        } else if (index \\u003c= start) {\\r\\n            indexOnModifyIteration = index - 1;\\r\\n            shouldModifyIteration = true;\\r\\n            index = _collateralOwners.length;\\r\\n        }\\r\\n            \\r\\n        for (uint256 i = 0; i \\u003c count; ++i) {\\r\\n            --index;\\r\\n            if (shouldModifyIteration \\u0026\\u0026 index \\u003c start) {\\r\\n                index = indexOnModifyIteration;\\r\\n                shouldModifyIteration = false;\\r\\n            }\\r\\n            _removeCollateralDataIfNecessary(_collateralOwners[index]);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \\r\\n     * @param exerciseAccount Address of the account that is exercising.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param accounts The array of addresses to get the collateral from.\\r\\n     */\\r\\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\\r\\n        for (uint256 i = 0; i \\u003c accounts.length; ++i) {\\r\\n            if (tokenAmount == 0) {\\r\\n                break;\\r\\n            }\\r\\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\\r\\n            _removeCollateralDataIfNecessary(accounts[i]);\\r\\n        }\\r\\n        require(tokenAmount == 0, \\\"ACOToken::_exerciseAccounts: Invalid remaining amount\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param exerciseAccount Address of the account that is exercising.\\r\\n     * @return Remaining amount of tokens.\\r\\n     */\\r\\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\\r\\n        uint256 available = _getAssignableAmount(account);\\r\\n        if (available \\u003e 0) {\\r\\n            \\r\\n            TokenCollateralized storage data = tokenData[account];\\r\\n            uint256 valueToTransfer;\\r\\n            if (available \\u003c tokenAmount) {\\r\\n                valueToTransfer = available;\\r\\n                tokenAmount = tokenAmount.sub(available);\\r\\n            } else {\\r\\n                valueToTransfer = tokenAmount;\\r\\n                tokenAmount = 0;\\r\\n            }\\r\\n            \\r\\n            (address exerciseAsset, uint256 amount) = getBaseExerciseData(valueToTransfer);\\r\\n            // To guarantee that the minter will be paid.\\r\\n            amount = amount.add(1);\\r\\n            \\r\\n            data.amount = data.amount.sub(valueToTransfer); \\r\\n            \\r\\n            if (_isEther(exerciseAsset)) {\\r\\n                payable(account).transfer(amount);\\r\\n            } else {\\r\\n                _transferERC20(exerciseAsset, account, amount);\\r\\n            }\\r\\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\\r\\n        }\\r\\n        return tokenAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\\r\\n     * @param account Address of the account that is exercising.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @param maximumNumberOfAccounts The maximum number of accounts that can be exercised.\\r\\n     */\\r\\n    function _validateAndBurn(address account, uint256 tokenAmount, uint256 maximumNumberOfAccounts) notExpired internal {\\r\\n        require(tokenAmount \\u003e 0, \\\"ACOToken::_validateAndBurn: Invalid token amount\\\");\\r\\n        \\r\\n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\\r\\n        if (_accountHasCollateral(account)) {\\r\\n            require(tokenAmount \\u003c= balanceOf(account).sub(tokenData[account].amount), \\\"ACOToken::_validateAndBurn: Token amount not available\\\"); \\r\\n        }\\r\\n        \\r\\n        _callBurn(account, tokenAmount);\\r\\n        \\r\\n        (address exerciseAsset, uint256 expectedAmount) = getBaseExerciseData(tokenAmount);\\r\\n        expectedAmount = expectedAmount.add(maximumNumberOfAccounts);\\r\\n\\r\\n        if (_isEther(exerciseAsset)) {\\r\\n            require(msg.value == expectedAmount, \\\"ACOToken::_validateAndBurn: Invalid ether amount\\\");\\r\\n        } else {\\r\\n            require(msg.value == 0, \\\"ACOToken::_validateAndBurn: No ether expected\\\");\\r\\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to calculate the token strike price relation.\\r\\n     * @param tokenAmount Amount of tokens.\\r\\n     * @return Calculated value with strike asset precision.\\r\\n     */\\r\\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\\r\\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the collateral sent back from an account.\\r\\n     * Function to be called when the token IS expired.\\r\\n     * @param account Address of the account.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _redeem(address account) nonReentrant internal returns(uint256) {\\r\\n        require(!_notExpired(), \\\"ACOToken::_redeem: Token not expired yet\\\");\\r\\n        \\r\\n        uint256 collateralAmount = _redeemCollateral(account, tokenData[account].amount);\\r\\n        super._burnAction(account, balanceOf(account));\\r\\n        return collateralAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens to be burned.\\r\\n     * @return The amount of collateral transferred.\\r\\n     */\\r\\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal returns(uint256) {\\r\\n        uint256 collateralAmount = _redeemCollateral(account, tokenAmount);\\r\\n        _callBurn(account, tokenAmount);\\r\\n        return collateralAmount;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to burn tokens.\\r\\n     * @param account Address of the account.\\r\\n     * @param tokenAmount Amount of tokens to be burned.\\r\\n     */\\r\\n    function _callBurn(address account, uint256 tokenAmount) internal {\\r\\n        if (account == msg.sender) {\\r\\n            super._burnAction(account, tokenAmount);\\r\\n        } else {\\r\\n            super._burnFrom(account, tokenAmount);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the amount of assignable token from an account.\\r\\n     * @param account Address of the account.\\r\\n     * @return The assignable amount of tokens.\\r\\n     */\\r\\n    function _getAssignableAmount(address account) internal view returns(uint256) {\\r\\n        if (tokenData[account].amount \\u003e balanceOf(account)) {\\r\\n            return tokenData[account].amount.sub(balanceOf(account));\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\\r\\n     * @param account Address of account.\\r\\n     */\\r\\n    function _removeCollateralDataIfNecessary(address account) internal {\\r\\n        TokenCollateralized storage data = tokenData[account];\\r\\n        if (!_hasCollateral(data)) {\\r\\n            uint256 lastIndex = _collateralOwners.length - 1;\\r\\n            if (lastIndex != data.index) {\\r\\n                address last = _collateralOwners[lastIndex];\\r\\n                tokenData[last].index = data.index;\\r\\n                _collateralOwners[data.index] = last;\\r\\n            }\\r\\n            _collateralOwners.pop();\\r\\n            delete tokenData[account];\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if the token is not expired.\\r\\n     * @return Whether the token is NOT expired.\\r\\n     */\\r\\n    function _notExpired() internal view returns(bool) {\\r\\n        return now \\u003c expiryTime;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if an account has collateral deposited.\\r\\n     * @param account Address of the account.\\r\\n     * @return Whether the account has collateral deposited.\\r\\n     */\\r\\n    function _accountHasCollateral(address account) internal view returns(bool) {\\r\\n        return _hasCollateral(tokenData[account]);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if an account has collateral deposited.\\r\\n     * @param data Token data from an account.\\r\\n     * @return Whether the account has collateral deposited.\\r\\n     */    \\r\\n    function _hasCollateral(TokenCollateralized storage data) internal view returns(bool) {\\r\\n        return data.amount \\u003e 0;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get if the address is for Ethereum (0x0).\\r\\n     * @param _address Address to be checked.\\r\\n     * @return Whether the address is for Ethereum.\\r\\n     */ \\r\\n    function _isEther(address _address) internal pure returns(bool) {\\r\\n        return _address == address(0);\\r\\n    } \\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to get the token name.\\r\\n     * The token name is assembled  with the token data:\\r\\n     * ACO UNDERLYING_SYMBOL-STRIKE_PRICE_STRIKE_ASSET_SYMBOL-TYPE-EXPIRYTIME\\r\\n     * @return The token name.\\r\\n     */\\r\\n    function _name() internal view returns(string memory) {\\r\\n        return string(abi.encodePacked(\\r\\n            \\\"ACO \\\",\\r\\n            underlyingSymbol,\\r\\n            \\\"-\\\",\\r\\n            ACONameFormatter.formatNumber(strikePrice, strikeAssetDecimals),\\r\\n            strikeAssetSymbol,\\r\\n            \\\"-\\\",\\r\\n            ACONameFormatter.formatType(isCall),\\r\\n            \\\"-\\\",\\r\\n            ACONameFormatter.formatTime(expiryTime)\\r\\n        ));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset decimals.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset decimals.\\r\\n     */\\r\\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\\r\\n        if (_isEther(asset)) {\\r\\n            return uint8(18);\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\\\"decimals()\\\"));\\r\\n            require(success, \\\"ACOToken::_getAssetDecimals: Invalid asset decimals\\\");\\r\\n            return abi.decode(returndata, (uint8));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to the asset symbol.\\r\\n     * @param asset Address of the asset.\\r\\n     * @return The asset symbol.\\r\\n     */\\r\\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\\r\\n        if (_isEther(asset)) {\\r\\n            return \\\"ETH\\\";\\r\\n        } else {\\r\\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\\\"symbol()\\\"));\\r\\n            require(success, \\\"ACOToken::_getAssetSymbol: Invalid asset symbol\\\");\\r\\n            return abi.decode(returndata, (string));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to transfer ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _transferERC20(address token, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferSelector, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOToken::_transferERC20\\\");\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Internal function to call transferFrom on ERC20 tokens.\\r\\n     * @param token Address of the token.\\r\\n     * @param sender Address of the sender.\\r\\n     * @param recipient Address of the transfer destination.\\r\\n     * @param amount Amount to transfer.\\r\\n     */\\r\\n     function _transferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\\r\\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(_transferFromSelector, sender, recipient, amount));\\r\\n        require(success \\u0026\\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \\\"ACOToken::_transferFromERC20\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"Address.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\"},\"BokkyPooBahsDateTimeLibrary.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah\\u0027s DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | \\u003e= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\r\\n    uint constant SECONDS_PER_MINUTE = 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    uint constant DOW_MON = 1;\\r\\n    uint constant DOW_TUE = 2;\\r\\n    uint constant DOW_WED = 3;\\r\\n    uint constant DOW_THU = 4;\\r\\n    uint constant DOW_FRI = 5;\\r\\n    uint constant DOW_SAT = 6;\\r\\n    uint constant DOW_SUN = 7;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // days = day\\r\\n    //      - 32075\\r\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\r\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\r\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\r\\n    //      - offset\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\r\\n        require(year \\u003e= 1970);\\r\\n        int _year = int(year);\\r\\n        int _month = int(month);\\r\\n        int _day = int(day);\\r\\n\\r\\n        int __days = _day\\r\\n          - 32075\\r\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\r\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\r\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\r\\n          - OFFSET19700101;\\r\\n\\r\\n        _days = uint(__days);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\r\\n    }\\r\\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\\r\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\\r\\n    }\\r\\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\r\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n        secs = secs % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n        second = secs % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\r\\n        if (year \\u003e= 1970 \\u0026\\u0026 month \\u003e 0 \\u0026\\u0026 month \\u003c= 12) {\\r\\n            uint daysInMonth = _getDaysInMonth(year, month);\\r\\n            if (day \\u003e 0 \\u0026\\u0026 day \\u003c= daysInMonth) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\r\\n        if (isValidDate(year, month, day)) {\\r\\n            if (hour \\u003c 24 \\u0026\\u0026 minute \\u003c 60 \\u0026\\u0026 second \\u003c 60) {\\r\\n                valid = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\r\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        leapYear = _isLeapYear(year);\\r\\n    }\\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) \\u0026\\u0026 (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\r\\n        weekDay = getDayOfWeek(timestamp) \\u003c= DOW_FRI;\\r\\n    }\\r\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\r\\n        weekEnd = getDayOfWeek(timestamp) \\u003e= DOW_SAT;\\r\\n    }\\r\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\r\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        daysInMonth = _getDaysInMonth(year, month);\\r\\n    }\\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n    // 1 = Monday, 7 = Sunday\\r\\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\r\\n        uint _days = timestamp / SECONDS_PER_DAY;\\r\\n        dayOfWeek = (_days + 3) % 7 + 1;\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\r\\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\r\\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\r\\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n    }\\r\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\r\\n        uint secs = timestamp % SECONDS_PER_DAY;\\r\\n        hour = secs / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\r\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\r\\n        minute = secs / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\r\\n        second = timestamp % SECONDS_PER_MINUTE;\\r\\n    }\\r\\n\\r\\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year += _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        month += _months;\\r\\n        year += (month - 1) / 12;\\r\\n        month = (month - 1) % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp + _seconds;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        year -= _years;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\r\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\r\\n        year = yearMonth / 12;\\r\\n        month = yearMonth % 12 + 1;\\r\\n        uint daysInMonth = _getDaysInMonth(year, month);\\r\\n        if (day \\u003e daysInMonth) {\\r\\n            day = daysInMonth;\\r\\n        }\\r\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\r\\n        newTimestamp = timestamp - _seconds;\\r\\n        require(newTimestamp \\u003c= timestamp);\\r\\n    }\\r\\n\\r\\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _years = toYear - fromYear;\\r\\n    }\\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\r\\n    }\\r\\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\r\\n    }\\r\\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\r\\n    }\\r\\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\r\\n        require(fromTimestamp \\u003c= toTimestamp);\\r\\n        _seconds = toTimestamp - fromTimestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC20\\r\\n * @dev Base implementation of ERC20 token.\\r\\n */\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    uint256 private _totalSupply;\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    function name() public view virtual returns(string memory);\\r\\n    function symbol() public view virtual returns(string memory);\\r\\n    function decimals() public view virtual returns(uint8);\\r\\n\\r\\n    function totalSupply() public view override returns(uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns(uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns(uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\\r\\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\r\\n        _transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns(bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        _transferAction(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        _approveAction(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _burnFrom(address account, uint256 amount) internal {\\r\\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\r\\n        _burnAction(account, amount);\\r\\n    }\\r\\n\\r\\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\\r\\n        require(sender != address(0), \\\"ERC20::_transferAction: Invalid sender\\\");\\r\\n        require(recipient != address(0), \\\"ERC20::_transferAction: Invalid recipient\\\");\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        \\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    function _approveAction(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"ERC20::_approveAction: Invalid owner\\\");\\r\\n        require(spender != address(0), \\\"ERC20::_approveAction: Invalid spender\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        \\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _mintAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_mintAction: Invalid account\\\");\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        \\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burnAction(address account, uint256 amount) internal {\\r\\n        require(account != address(0), \\\"ERC20::_burnAction: Invalid account\\\");\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount);\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        \\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n}    \\r\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Strings.sol\":{\"content\":\"pragma solidity ^0.6.6;\\r\\n\\r\\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = value;\\r\\n        while (temp != 0) {\\r\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\r\\n            temp /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Assigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollateralDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"CollateralWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCollateralizedAmount\",\"type\":\"uint256\"}],\"name\":\"TransferCollateralOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"assignableCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"assignableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"currentCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"currentCollateralizedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"exercise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"exerciseAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"exerciseAccountsFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"exerciseFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDestination\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getBaseExerciseData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getCollateralOnExercise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strikeAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCall\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_acoFee\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_feeDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxExercisedAccounts\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxExercisedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPayable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"mintToPayable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfAccountsWithCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"redeemFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAssetDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikeAssetSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strikePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenCollateralizedAmount\",\"type\":\"uint256\"}],\"name\":\"transferCollateralOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unassignableCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unassignableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ACOToken", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cb30ae80319463574ff120f520633d68378fa215960c0dd60da4052df64ca491"}