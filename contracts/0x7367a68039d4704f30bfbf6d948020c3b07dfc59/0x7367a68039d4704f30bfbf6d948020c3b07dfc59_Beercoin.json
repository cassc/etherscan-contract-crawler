{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n * A contract containing the fundamental state variables of the Beercoin\r\n */\r\ncontract InternalBeercoin {\r\n    // As 18 decimal places will be used, the constants are multiplied by 10^18\r\n    uint256 internal constant INITIAL_SUPPLY = 15496000000 * 10**18;\r\n    uint256 internal constant DIAMOND_VALUE = 10000 * 10**18;\r\n    uint256 internal constant GOLD_VALUE = 100 * 10**18;\r\n    uint256 internal constant SILVER_VALUE = 10 * 10**18;\r\n    uint256 internal constant BRONZE_VALUE = 1 * 10**18;\r\n\r\n    // In addition to the initial total supply of 15496000000 Beercoins,\r\n    // more Beercoins will only be added by scanning bottle caps.\r\n    // 20800000000 bottle caps will be eventually produced.\r\n    //\r\n    // Within 10000 bottle caps,\r\n    // 1 (i.e. every 10000th cap in total) has a value of 10000 (\"Diamond\") Beercoins,\r\n    // 9 (i.e. every 1000th cap in total) have a value of 100 (\"Gold\") Beercoins,\r\n    // 990 (i.e. every 10th cap in total) have a value of 10 (\"Silver\") Beercoins,\r\n    // 9000 (i.e. every remaining cap) have a value of 1 (\"Bronze\") Beercoin.\r\n    //\r\n    // Therefore one bottle cap has an average Beercoin value of\r\n    // (1 * 10000 + 9 * 100 + 990 * 10 + 9000 * 1) / 10000 = 2.98.\r\n    //\r\n    // This means the total Beercoin value of all bottle caps that will\r\n    // be eventually produced equals 20800000000 * 2.98 = 61984000000.\r\n    uint64 internal producibleCaps = 20800000000;\r\n\r\n    // The  amounts of diamond, gold, silver, and bronze caps are stored\r\n    // as a single 256-bit value divided into four sections of 64 bits.\r\n    //\r\n    // Bits 255 to 192 are used for the amount of diamond caps,\r\n    // bits 191 to 128 are used for the amount of gold caps,\r\n    // bits 127 to 64 are used for the amount of silver caps,\r\n    // bits 63 to 0 are used for the amount of bronze caps.\r\n    //\r\n    // For example, the following numbers represent a single cap of a certain type:\r\n    // 0x0000000000000001000000000000000000000000000000000000000000000000 (diamond)\r\n    // 0x0000000000000000000000000000000100000000000000000000000000000000 (gold)\r\n    // 0x0000000000000000000000000000000000000000000000010000000000000000 (silver)\r\n    // 0x0000000000000000000000000000000000000000000000000000000000000001 (bronze)\r\n    uint256 internal packedProducedCaps = 0;\r\n    uint256 internal packedScannedCaps = 0;\r\n\r\n    // The amount of irreversibly burnt Beercoins\r\n    uint256 internal burntValue = 0;\r\n}\r\n\r\n\r\n/**\r\n * A contract containing functions to understand the packed low-level data\r\n */\r\ncontract ExplorableBeercoin is InternalBeercoin {\r\n    /**\r\n     * The amount of caps that can still be produced\r\n     */\r\n    function unproducedCaps() public view returns (uint64) {\r\n        return producibleCaps;\r\n    }\r\n\r\n    /**\r\n     * The amount of caps that is produced but not yet scanned\r\n     */\r\n    function unscannedCaps() public view returns (uint64) {\r\n        uint256 caps = packedProducedCaps - packedScannedCaps;\r\n        uint64 amount = uint64(caps >> 192);\r\n        amount += uint64(caps >> 128);\r\n        amount += uint64(caps >> 64);\r\n        amount += uint64(caps);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * The amount of all caps produced so far\r\n     */\r\n    function producedCaps() public view returns (uint64) {\r\n        uint256 caps = packedProducedCaps;\r\n        uint64 amount = uint64(caps >> 192);\r\n        amount += uint64(caps >> 128);\r\n        amount += uint64(caps >> 64);\r\n        amount += uint64(caps);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * The amount of all caps scanned so far\r\n     */\r\n    function scannedCaps() public view returns (uint64) {\r\n        uint256 caps = packedScannedCaps;\r\n        uint64 amount = uint64(caps >> 192);\r\n        amount += uint64(caps >> 128);\r\n        amount += uint64(caps >> 64);\r\n        amount += uint64(caps);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * The amount of diamond caps produced so far\r\n     */\r\n    function producedDiamondCaps() public view returns (uint64) {\r\n        return uint64(packedProducedCaps >> 192);\r\n    }\r\n\r\n    /**\r\n     * The amount of diamond caps scanned so far\r\n     */\r\n    function scannedDiamondCaps() public view returns (uint64) {\r\n        return uint64(packedScannedCaps >> 192);\r\n    }\r\n\r\n    /**\r\n     * The amount of gold caps produced so far\r\n     */\r\n    function producedGoldCaps() public view returns (uint64) {\r\n        return uint64(packedProducedCaps >> 128);\r\n    }\r\n\r\n    /**\r\n     * The amount of gold caps scanned so far\r\n     */\r\n    function scannedGoldCaps() public view returns (uint64) {\r\n        return uint64(packedScannedCaps >> 128);\r\n    }\r\n\r\n    /**\r\n     * The amount of silver caps produced so far\r\n     */\r\n    function producedSilverCaps() public view returns (uint64) {\r\n        return uint64(packedProducedCaps >> 64);\r\n    }\r\n\r\n    /**\r\n     * The amount of silver caps scanned so far\r\n     */\r\n    function scannedSilverCaps() public view returns (uint64) {\r\n        return uint64(packedScannedCaps >> 64);\r\n    }\r\n\r\n    /**\r\n     * The amount of bronze caps produced so far\r\n     */\r\n    function producedBronzeCaps() public view returns (uint64) {\r\n        return uint64(packedProducedCaps);\r\n    }\r\n\r\n    /**\r\n     * The amount of bronze caps scanned so far\r\n     */\r\n    function scannedBronzeCaps() public view returns (uint64) {\r\n        return uint64(packedScannedCaps);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * A contract implementing all standard ERC20 functionality for the Beercoin\r\n */\r\ncontract ERC20Beercoin is ExplorableBeercoin {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowances;\r\n\r\n    /**\r\n     * Beercoin's name\r\n     */\r\n    function name() public pure returns (string) {\r\n        return \"Beercoin\";\r\n    }\r\n\r\n    /**\r\n     * Beercoin's symbol\r\n     */\r\n    function symbol() public pure returns (string) {\r\n        return \"\ud83c\udf7a\";\r\n    }\r\n\r\n    /**\r\n     * Beercoin's decimal places\r\n     */\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * The current total supply of Beercoins\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        uint256 caps = packedScannedCaps;\r\n        uint256 supply = INITIAL_SUPPLY;\r\n        supply += (caps >> 192) * DIAMOND_VALUE;\r\n        supply += ((caps >> 128) & 0xFFFFFFFFFFFFFFFF) * GOLD_VALUE;\r\n        supply += ((caps >> 64) & 0xFFFFFFFFFFFFFFFF) * SILVER_VALUE;\r\n        supply += (caps & 0xFFFFFFFFFFFFFFFF) * BRONZE_VALUE;\r\n        return supply - burntValue;\r\n    }\r\n\r\n    /**\r\n     * Check the balance of a Beercoin user\r\n     *\r\n     * @param _owner the user to check\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * Transfer Beercoins to another user\r\n     *\r\n     * @param _to the address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != 0x0);\r\n\r\n        uint256 balanceFrom = balances[msg.sender];\r\n\r\n        require(_value <= balanceFrom);\r\n\r\n        uint256 oldBalanceTo = balances[_to];\r\n        uint256 newBalanceTo = oldBalanceTo + _value;\r\n\r\n        require(oldBalanceTo <= newBalanceTo);\r\n\r\n        balances[msg.sender] = balanceFrom - _value;\r\n        balances[_to] = newBalanceTo;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer Beercoins from other address if a respective allowance exists\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _to the address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != 0x0);\r\n\r\n        uint256 balanceFrom = balances[_from];\r\n        uint256 allowanceFrom = allowances[_from][msg.sender];\r\n\r\n        require(_value <= balanceFrom);\r\n        require(_value <= allowanceFrom);\r\n\r\n        uint256 oldBalanceTo = balances[_to];\r\n        uint256 newBalanceTo = oldBalanceTo + _value;\r\n\r\n        require(oldBalanceTo <= newBalanceTo);\r\n\r\n        balances[_from] = balanceFrom - _value;\r\n        balances[_to] = newBalanceTo;\r\n        allowances[_from][msg.sender] = allowanceFrom - _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow another user to spend a certain amount of Beercoins on your behalf\r\n     *\r\n     * @param _spender the address of the user authorized to spend\r\n     * @param _value the maximum amount that can be spent on your behalf\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowances[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The amount of Beercoins that can be spent by a user on behalf of another\r\n     *\r\n     * @param _owner the address of the user user whose Beercoins are spent\r\n     * @param _spender the address of the user who executes the transaction\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * A contract that defines a master with special debiting abilities\r\n * required for operating a user-friendly Beercoin redemption system\r\n */\r\ncontract MasteredBeercoin is ERC20Beercoin {\r\n    address internal beercoinMaster;\r\n    mapping (address => bool) internal directDebitAllowances;\r\n\r\n    /**\r\n     * Construct the MasteredBeercoin contract\r\n     * and make the sender the master\r\n     */\r\n    function MasteredBeercoin() public {\r\n        beercoinMaster = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Restrict to the master only\r\n     */\r\n    modifier onlyMaster {\r\n        require(msg.sender == beercoinMaster);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The master of the Beercoin\r\n     */\r\n    function master() public view returns (address) {\r\n        return beercoinMaster;\r\n    }\r\n\r\n    /**\r\n     * Declare a master at another address\r\n     *\r\n     * @param newMaster the new owner's address\r\n     */\r\n    function declareNewMaster(address newMaster) public onlyMaster {\r\n        beercoinMaster = newMaster;\r\n    }\r\n\r\n    /**\r\n     * Allow the master to withdraw Beercoins from your\r\n     * account so you don't have to send Beercoins yourself\r\n     */\r\n    function allowDirectDebit() public {\r\n        directDebitAllowances[msg.sender] = true;\r\n    }\r\n\r\n    /**\r\n     * Forbid the master to withdraw Beercoins from you account\r\n     */\r\n    function forbidDirectDebit() public {\r\n        directDebitAllowances[msg.sender] = false;\r\n    }\r\n\r\n    /**\r\n     * Check whether a user allows direct debits by the master\r\n     *\r\n     * @param user the user to check\r\n     */\r\n    function directDebitAllowance(address user) public view returns (bool) {\r\n        return directDebitAllowances[user];\r\n    }\r\n\r\n    /**\r\n     * Withdraw Beercoins from multiple users\r\n     *\r\n     * Beercoins are only withdrawn this way if and only if\r\n     * a user deliberately wants it to happen by initiating\r\n     * a transaction on a plattform operated by the owner\r\n     *\r\n     * @param users the addresses of the users to take Beercoins from\r\n     * @param values the respective amounts to take\r\n     */\r\n    function debit(address[] users, uint256[] values) public onlyMaster returns (bool) {\r\n        require(users.length == values.length);\r\n\r\n        uint256 oldBalance = balances[msg.sender];\r\n        uint256 newBalance = oldBalance;\r\n\r\n        address currentUser;\r\n        uint256 currentValue;\r\n        uint256 currentBalance;\r\n        for (uint256 i = 0; i < users.length; ++i) {\r\n            currentUser = users[i];\r\n            currentValue = values[i];\r\n            currentBalance = balances[currentUser];\r\n\r\n            require(directDebitAllowances[currentUser]);\r\n            require(currentValue <= currentBalance);\r\n            balances[currentUser] = currentBalance - currentValue;\r\n            \r\n            newBalance += currentValue;\r\n\r\n            Transfer(currentUser, msg.sender, currentValue);\r\n        }\r\n\r\n        require(oldBalance <= newBalance);\r\n        balances[msg.sender] = newBalance;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Withdraw Beercoins from multiple users\r\n     *\r\n     * Beercoins are only withdrawn this way if and only if\r\n     * a user deliberately wants it to happen by initiating\r\n     * a transaction on a plattform operated by the owner\r\n     *\r\n     * @param users the addresses of the users to take Beercoins from\r\n     * @param value the amount to take from each user\r\n     */\r\n    function debitEqually(address[] users, uint256 value) public onlyMaster returns (bool) {\r\n        uint256 oldBalance = balances[msg.sender];\r\n        uint256 newBalance = oldBalance + (users.length * value);\r\n\r\n        require(oldBalance <= newBalance);\r\n        balances[msg.sender] = newBalance;\r\n\r\n        address currentUser;\r\n        uint256 currentBalance;\r\n        for (uint256 i = 0; i < users.length; ++i) {\r\n            currentUser = users[i];\r\n            currentBalance = balances[currentUser];\r\n\r\n            require(directDebitAllowances[currentUser]);\r\n            require(value <= currentBalance);\r\n            balances[currentUser] = currentBalance - value;\r\n\r\n            Transfer(currentUser, msg.sender, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Send Beercoins to multiple users\r\n     *\r\n     * @param users the addresses of the users to send Beercoins to\r\n     * @param values the respective amounts to send\r\n     */\r\n    function credit(address[] users, uint256[] values) public onlyMaster returns (bool) {\r\n        require(users.length == values.length);\r\n\r\n        uint256 balance = balances[msg.sender];\r\n        uint256 totalValue = 0;\r\n\r\n        address currentUser;\r\n        uint256 currentValue;\r\n        uint256 currentOldBalance;\r\n        uint256 currentNewBalance;\r\n        for (uint256 i = 0; i < users.length; ++i) {\r\n            currentUser = users[i];\r\n            currentValue = values[i];\r\n            currentOldBalance = balances[currentUser];\r\n            currentNewBalance = currentOldBalance + currentValue;\r\n\r\n            require(currentOldBalance <= currentNewBalance);\r\n            balances[currentUser] = currentNewBalance;\r\n\r\n            totalValue += currentValue;\r\n\r\n            Transfer(msg.sender, currentUser, currentValue);\r\n        }\r\n\r\n        require(totalValue <= balance);\r\n        balances[msg.sender] = balance - totalValue;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Send Beercoins to multiple users\r\n     *\r\n     * @param users the addresses of the users to send Beercoins to\r\n     * @param value the amounts to send to each user\r\n     */\r\n    function creditEqually(address[] users, uint256 value) public onlyMaster returns (bool) {\r\n        uint256 balance = balances[msg.sender];\r\n        uint256 totalValue = users.length * value;\r\n\r\n        require(totalValue <= balance);\r\n        balances[msg.sender] = balance - totalValue;\r\n\r\n        address currentUser;\r\n        uint256 currentOldBalance;\r\n        uint256 currentNewBalance;\r\n        for (uint256 i = 0; i < users.length; ++i) {\r\n            currentUser = users[i];\r\n            currentOldBalance = balances[currentUser];\r\n            currentNewBalance = currentOldBalance + value;\r\n\r\n            require(currentOldBalance <= currentNewBalance);\r\n            balances[currentUser] = currentNewBalance;\r\n\r\n            Transfer(msg.sender, currentUser, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * A contract that defines the central business logic\r\n * which also mirrors the life of a Beercoin\r\n */\r\ncontract Beercoin is MasteredBeercoin {\r\n    event Produce(uint256 newCaps);\r\n    event Scan(address[] users, uint256[] caps);\r\n    event Burn(uint256 value);\r\n\r\n    /**\r\n     * Construct the Beercoin contract and\r\n     * assign the initial supply to the creator\r\n     */\r\n    function Beercoin() public {\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    /**\r\n     * Increase the amounts of produced diamond, gold, silver, and\r\n     * bronze bottle caps in respect to their occurrence probabilities\r\n     *\r\n     * This function is called if and only if a brewery has actually\r\n     * ordered codes to produce the specified amount of bottle caps\r\n     *\r\n     * @param numberOfCaps the number of bottle caps to be produced\r\n     */\r\n    function produce(uint64 numberOfCaps) public onlyMaster returns (bool) {\r\n        require(numberOfCaps <= producibleCaps);\r\n\r\n        uint256 producedCaps = packedProducedCaps;\r\n\r\n        uint64 targetTotalCaps = numberOfCaps;\r\n        targetTotalCaps += uint64(producedCaps >> 192);\r\n        targetTotalCaps += uint64(producedCaps >> 128);\r\n        targetTotalCaps += uint64(producedCaps >> 64);\r\n        targetTotalCaps += uint64(producedCaps);\r\n\r\n        uint64 targetDiamondCaps = (targetTotalCaps - (targetTotalCaps % 10000)) / 10000;\r\n        uint64 targetGoldCaps = ((targetTotalCaps - (targetTotalCaps % 1000)) / 1000) - targetDiamondCaps;\r\n        uint64 targetSilverCaps = ((targetTotalCaps - (targetTotalCaps % 10)) / 10) - targetDiamondCaps - targetGoldCaps;\r\n        uint64 targetBronzeCaps = targetTotalCaps - targetDiamondCaps - targetGoldCaps - targetSilverCaps;\r\n\r\n        uint256 targetProducedCaps = 0;\r\n        targetProducedCaps |= uint256(targetDiamondCaps) << 192;\r\n        targetProducedCaps |= uint256(targetGoldCaps) << 128;\r\n        targetProducedCaps |= uint256(targetSilverCaps) << 64;\r\n        targetProducedCaps |= uint256(targetBronzeCaps);\r\n\r\n        producibleCaps -= numberOfCaps;\r\n        packedProducedCaps = targetProducedCaps;\r\n\r\n        Produce(targetProducedCaps - producedCaps);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Approve scans of multiple users and grant Beercoins\r\n     *\r\n     * This function is called periodically to mass-transfer Beercoins to\r\n     * multiple users if and only if each of them has scanned codes that\r\n     * our server has never verified before for the same or another user\r\n     *\r\n     * @param users the addresses of the users who scanned valid codes\r\n     * @param caps the amounts of caps the users have scanned as single 256-bit values\r\n     */\r\n    function scan(address[] users, uint256[] caps) public onlyMaster returns (bool) {\r\n        require(users.length == caps.length);\r\n\r\n        uint256 scannedCaps = packedScannedCaps;\r\n\r\n        uint256 currentCaps;\r\n        uint256 capsValue;\r\n        for (uint256 i = 0; i < users.length; ++i) {\r\n            currentCaps = caps[i];\r\n\r\n            capsValue = DIAMOND_VALUE * (currentCaps >> 192);\r\n            capsValue += GOLD_VALUE * ((currentCaps >> 128) & 0xFFFFFFFFFFFFFFFF);\r\n            capsValue += SILVER_VALUE * ((currentCaps >> 64) & 0xFFFFFFFFFFFFFFFF);\r\n            capsValue += BRONZE_VALUE * (currentCaps & 0xFFFFFFFFFFFFFFFF);\r\n\r\n            balances[users[i]] += capsValue;\r\n            scannedCaps += currentCaps;\r\n        }\r\n\r\n        require(scannedCaps <= packedProducedCaps);\r\n        packedScannedCaps = scannedCaps;\r\n\r\n        Scan(users, caps);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Remove Beercoins from the system irreversibly\r\n     *\r\n     * @param value the amount of Beercoins to burn\r\n     */\r\n    function burn(uint256 value) public onlyMaster returns (bool) {\r\n        uint256 balance = balances[msg.sender];\r\n        require(value <= balance);\r\n\r\n        balances[msg.sender] = balance - value;\r\n        burntValue += value;\r\n\r\n        Burn(value);\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"directDebitAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"producedCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"producedDiamondCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forbidDirectDebit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"producedSilverCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"producedGoldCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scannedBronzeCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scannedCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaster\",\"type\":\"address\"}],\"name\":\"declareNewMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"producedBronzeCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scannedDiamondCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unproducedCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unscannedCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"debitEqually\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scannedSilverCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"creditEqually\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"debit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowDirectDebit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"caps\",\"type\":\"uint256[]\"}],\"name\":\"scan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberOfCaps\",\"type\":\"uint64\"}],\"name\":\"produce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scannedGoldCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"credit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newCaps\",\"type\":\"uint256\"}],\"name\":\"Produce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"users\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"caps\",\"type\":\"uint256[]\"}],\"name\":\"Scan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Beercoin", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://bc9f64cea4d31ef8a9ad99d5a705b573f2beab4f553f567d78d8e32a4be40017"}