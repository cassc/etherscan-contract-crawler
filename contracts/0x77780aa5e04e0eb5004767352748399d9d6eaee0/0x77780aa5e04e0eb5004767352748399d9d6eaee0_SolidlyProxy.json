{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SolidlyV2/ProxyPattern/SolidlyProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @title Solidly+ governance killable proxy\\r\\n * @author Solidly+\\r\\n * @notice EIP-1967 upgradeable proxy with the ability to kill governance and render the contract immutable\\r\\n */\\r\\ncontract SolidlyProxy {\\r\\n    bytes32 constant IMPLEMENTATION_SLOT =\\r\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; // keccak256('eip1967.proxy.implementation'), actually used for interface so etherscan picks up the interface\\r\\n    bytes32 constant LOGIC_SLOT =\\r\\n        0x5942be825425c77e56e4bce97986794ab0f100954e40fc1390ae0e003710a3ab; // keccak256('LOGIC') - 1, actual logic implementation\\r\\n    bytes32 constant GOVERNANCE_SLOT =\\r\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; // keccak256('eip1967.proxy.admin')\\r\\n    bytes32 constant INITIALIZED_SLOT =\\r\\n        0x834ce84547018237034401a09067277cdcbe7bbf7d7d30f6b382b0a102b7b4a3; // keccak256('eip1967.proxy.initialized')\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if msg.sender is not governance\\r\\n     */\\r\\n    modifier onlyGovernance() {\\r\\n        require(msg.sender == governanceAddress(), \\\"Only governance\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if contract is already initialized\\r\\n     * @dev Used by implementations to ensure initialize() is only called once\\r\\n     */\\r\\n    modifier notInitialized() {\\r\\n        bool initialized;\\r\\n        assembly {\\r\\n            initialized := sload(INITIALIZED_SLOT)\\r\\n            if eq(initialized, 1) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n            sstore(INITIALIZED_SLOT, 1)\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets up deployer as a proxy governance\\r\\n     */\\r\\n    constructor() {\\r\\n        address _governanceAddress = msg.sender;\\r\\n        assembly {\\r\\n            sstore(GOVERNANCE_SLOT, _governanceAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Detect whether or not governance is killed\\r\\n     * @return Return true if governance is killed, false if not\\r\\n     * @dev If governance is killed this contract becomes immutable\\r\\n     */\\r\\n    function governanceIsKilled() public view returns (bool) {\\r\\n        return governanceAddress() == address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Kill governance, making this contract immutable\\r\\n     * @dev Only governance can kil governance\\r\\n     */\\r\\n    function killGovernance() external onlyGovernance {\\r\\n        updateGovernanceAddress(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update implementation address\\r\\n     * @param _interfaceAddress Address of the new interface\\r\\n     * @dev Only governance can update implementation\\r\\n     */\\r\\n    function updateInterfaceAddress(address _interfaceAddress)\\r\\n        external\\r\\n        onlyGovernance\\r\\n    {\\r\\n        assembly {\\r\\n            sstore(IMPLEMENTATION_SLOT, _interfaceAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Actually updates interface, kept for etherscan pattern recognition\\r\\n     * @param _implementationAddress Address of the new implementation\\r\\n     * @dev Only governance can update implementation\\r\\n     */\\r\\n    function updateImplementationAddress(address _implementationAddress)\\r\\n        external\\r\\n        onlyGovernance\\r\\n    {\\r\\n        assembly {\\r\\n            sstore(IMPLEMENTATION_SLOT, _implementationAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update implementation address\\r\\n     * @param _logicAddress Address of the new implementation\\r\\n     * @dev Only governance can update implementation\\r\\n     */\\r\\n    function updateLogicAddress(address _logicAddress) external onlyGovernance {\\r\\n        assembly {\\r\\n            sstore(LOGIC_SLOT, _logicAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update governance address\\r\\n     * @param _governanceAddress New governance address\\r\\n     * @dev Only governance can update governance\\r\\n     */\\r\\n    function updateGovernanceAddress(address _governanceAddress)\\r\\n        public\\r\\n        onlyGovernance\\r\\n    {\\r\\n        assembly {\\r\\n            sstore(GOVERNANCE_SLOT, _governanceAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fetch the current implementation address\\r\\n     * @return _implementationAddress Returns the current implementation address\\r\\n     */\\r\\n    function implementationAddress()\\r\\n        public\\r\\n        view\\r\\n        returns (address _implementationAddress)\\r\\n    {\\r\\n        assembly {\\r\\n            _implementationAddress := sload(IMPLEMENTATION_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fetch the current implementation address\\r\\n     * @return _interfaceAddress Returns the current implementation address\\r\\n     */\\r\\n    function interfaceAddress()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (address _interfaceAddress)\\r\\n    {\\r\\n        assembly {\\r\\n            _interfaceAddress := sload(IMPLEMENTATION_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fetch the current implementation address\\r\\n     * @return _logicAddress Returns the current implementation address\\r\\n     */\\r\\n    function logicAddress()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (address _logicAddress)\\r\\n    {\\r\\n        assembly {\\r\\n            _logicAddress := sload(LOGIC_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fetch current governance address\\r\\n     * @return _governanceAddress Returns current governance address\\r\\n     */\\r\\n    function governanceAddress()\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (address _governanceAddress)\\r\\n    {\\r\\n        assembly {\\r\\n            _governanceAddress := sload(GOVERNANCE_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fallback function that delegatecalls the subimplementation instead of what's in the IMPLEMENTATION_SLOT\\r\\n     */\\r\\n    function _delegateCallSubimplmentation() internal virtual {\\r\\n        assembly {\\r\\n            let contractLogic := sload(LOGIC_SLOT)\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let success := delegatecall(\\r\\n                gas(),\\r\\n                contractLogic,\\r\\n                0x0,\\r\\n                calldatasize(),\\r\\n                0,\\r\\n                0\\r\\n            )\\r\\n            let returnDataSize := returndatasize()\\r\\n            returndatacopy(0, 0, returnDataSize)\\r\\n            switch success\\r\\n            case 0 {\\r\\n                revert(0, returnDataSize)\\r\\n            }\\r\\n            default {\\r\\n                return(0, returnDataSize)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Delegatecall fallback proxy\\r\\n     */\\r\\n    fallback() external payable virtual {\\r\\n        _delegateCallSubimplmentation();\\r\\n    }\\r\\n\\r\\n    receive() external payable virtual {\\r\\n        _delegateCallSubimplmentation();\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"governanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_governanceAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsKilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_implementationAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interfaceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_interfaceAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_logicAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceAddress\",\"type\":\"address\"}],\"name\":\"updateGovernanceAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementationAddress\",\"type\":\"address\"}],\"name\":\"updateImplementationAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interfaceAddress\",\"type\":\"address\"}],\"name\":\"updateInterfaceAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logicAddress\",\"type\":\"address\"}],\"name\":\"updateLogicAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SolidlyProxy", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xb600c9be12c2487140d603c63506a462a6feac17", "SwarmSource": ""}