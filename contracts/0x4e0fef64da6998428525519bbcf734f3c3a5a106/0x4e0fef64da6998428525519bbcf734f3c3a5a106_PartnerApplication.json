{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IGenerator {\r\n    function create(\r\n        address nft_,\r\n        address rewardToken_,\r\n        uint256 lockTime_,\r\n        uint256 rewardsPerSecond_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address lockTimeSetter_\r\n    ) external returns (address);\r\n}\r\n\r\n/**\r\n    Have a toggle for NFT baggage claim Contracts to hide from the front end\r\n */\r\ncontract PartnerApplication is Ownable {\r\n\r\n    // application fee\r\n    uint256 public applicationFee;\r\n\r\n    // Partner Data Struct\r\n    struct PartnerData {\r\n        string socialLink;\r\n        string description;\r\n        uint256 fee;\r\n        address requester;\r\n        bool isAccepted;\r\n        bool isInApplicationPhase;\r\n    }\r\n\r\n    // Partner Struct\r\n    struct Partner {        \r\n        address nft;\r\n        string nftName;\r\n        string nftSymbol;\r\n        address rewardToken;\r\n        uint256 lockTime;\r\n        uint256 rewardsPerSecond;\r\n        address nftOwner;\r\n    }\r\n\r\n    // Maps a partnerNonce to a Partner Struct\r\n    mapping ( uint256 => Partner ) public partners;\r\n\r\n    // Maps a partnerNonce to a Partner Struct\r\n    mapping ( uint256 => PartnerData ) public partnerData;\r\n\r\n    // Partner Nonce\r\n    uint256 public partnerNonce;\r\n\r\n    // NFT Generator\r\n    address public generator;\r\n\r\n    constructor(\r\n        address generator_\r\n    ) {\r\n        generator = generator_;\r\n    }\r\n\r\n    function accept(uint256 partnerId) external onlyOwner returns(address newBaggageClaim) {\r\n        require(\r\n            partnerId < partnerNonce,\r\n            'Invalid ID'\r\n        );\r\n        require(\r\n            partnerData[partnerId].isInApplicationPhase == true &&\r\n            partnerData[partnerId].isAccepted == false,\r\n            'Parnter Already Accepted'\r\n        );\r\n\r\n        // delete application phase\r\n        delete partnerData[partnerId].isInApplicationPhase;\r\n\r\n        // set to be accepted\r\n        partnerData[partnerId].isAccepted = true;\r\n\r\n        // send value to owner\r\n        _send(this.getOwner(), partnerData[partnerId].fee);\r\n\r\n        // create nft baggage claim contract\r\n        newBaggageClaim = IGenerator(generator).create(\r\n            partners[partnerId].nft,\r\n            partners[partnerId].rewardToken,\r\n            partners[partnerId].lockTime,\r\n            partners[partnerId].rewardsPerSecond,\r\n            partners[partnerId].nftName,\r\n            partners[partnerId].nftSymbol,\r\n            partners[partnerId].nftOwner\r\n        );\r\n    }\r\n\r\n    function reject(uint256 partnerId) external onlyOwner {\r\n        require(\r\n            partnerId < partnerNonce,\r\n            'Invalid ID'\r\n        );\r\n        require(\r\n            partnerData[partnerId].isInApplicationPhase == true,\r\n            'Parnter Already Rejected'\r\n        );\r\n\r\n        // delete application phase\r\n        delete partnerData[partnerId].isInApplicationPhase;\r\n\r\n        // send value to initial requester\r\n        _send(partnerData[partnerId].requester, partnerData[partnerId].fee);\r\n    }\r\n\r\n    function setGenerator(address generator_) external onlyOwner {\r\n        generator = generator_;\r\n    }\r\n\r\n    function setApplicationFee(uint256 newFee) external onlyOwner {\r\n        applicationFee = newFee;\r\n    }\r\n\r\n    /**\r\n        strings = [nftName, nftSymbol, socialLink, description]\r\n    */\r\n    function Apply(\r\n        string[] calldata strings,\r\n        address rewardToken_,\r\n        address nft_,\r\n        uint256 lockTime,\r\n        uint256 rewardsPerDay_,\r\n        address ownerOfBaggageClaimPool\r\n    ) external payable {\r\n        require(\r\n            msg.value >= applicationFee,\r\n            'Insufficient Value Sent'\r\n        );\r\n        require(\r\n            nft_ != address(0), 'Zero Address'\r\n        );\r\n        require(\r\n            rewardsPerDay_ >= 1 days,\r\n            'Unit Too Small'\r\n        );\r\n\r\n        partners[partnerNonce] = Partner({\r\n            nft: nft_,\r\n            nftName: strings[0],\r\n            nftSymbol: strings[1],\r\n            rewardToken: rewardToken_,\r\n            lockTime: lockTime,\r\n            rewardsPerSecond: rewardsPerDay_ / 1 days,\r\n            nftOwner: ownerOfBaggageClaimPool\r\n        });\r\n\r\n        partnerData[partnerNonce] = PartnerData({\r\n            socialLink: strings[2],\r\n            description: strings[3],\r\n            fee: msg.value,\r\n            requester: msg.sender,\r\n            isAccepted: false,\r\n            isInApplicationPhase: true\r\n        });\r\n\r\n        unchecked {\r\n            ++partnerNonce;\r\n        }\r\n    }\r\n\r\n    function _send(address to, uint256 fee) internal {\r\n        if (fee > address(this).balance) {\r\n            fee = address(this).balance;\r\n        }\r\n        if (fee == 0) {\r\n            return;\r\n        }\r\n        (bool s,) = payable(to).call{value: fee}(\"\");\r\n        require(s, 'Failure To Send Fee');\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"generator_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"strings\",\"type\":\"string[]\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerDay_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ownerOfBaggageClaimPool\",\"type\":\"address\"}],\"name\":\"Apply\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partnerId\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newBaggageClaim\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applicationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partnerData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"socialLink\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAccepted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isInApplicationPhase\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partnerNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"nftName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"nftSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partnerId\",\"type\":\"uint256\"}],\"name\":\"reject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setApplicationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"generator_\",\"type\":\"address\"}],\"name\":\"setGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PartnerApplication", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "0000000000000000000000009b643a2c7ba6c798de33784c1f0c9e7e9370e6a4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c70de8fce9a0413b1096c1d1df06eb1ddb93fe360f8f6f4a8b7030785fba6b74"}