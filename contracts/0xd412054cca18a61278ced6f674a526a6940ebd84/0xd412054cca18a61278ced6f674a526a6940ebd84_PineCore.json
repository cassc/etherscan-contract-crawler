{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-08-30\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n//\r\n// Original work by Pine.Finance\r\n//  - https://github.com/pine-finance\r\n//\r\n// Authors:\r\n//  - Ignacio Mazzara <@nachomazzara>\r\n//  - Agustin Aguilar <@agusx1211>\r\n\r\n//\r\n//                                                                                                    \r\n//                                                /                                                   \r\n//                                                @,                                                  \r\n//                                               /&&                                                  \r\n//                                              &&%%&/                                                \r\n//                                            &%%%%&%%,..                                             \r\n//                                         */%&,*&&&&&&%%&*                                           \r\n//                                           /&%%%%%%%#.                                              \r\n//                                    ./%&%%%&#/%%%%&#&%%%&#(*.                                       \r\n//                                         .%%%%%%%&&%&/ ..,...                                       \r\n//                                       .*,%%%%%%%%%&&%%%%(                                          \r\n//                                     ,&&%%%&&*%%%%%%%%.*(#%&/                                       \r\n//                                  ./,(*,*,#%%%%%%%%%%%%%%%(,                                        \r\n//                                 ,(%%%%%%%%%%%%&%%%%%%%%%#&&%%%#/(*                                 \r\n//                                     *#%%%%%%%&%%%&%%#%%%%%%(                                       \r\n//                              .(####%%&%&#*&%%##%%%%%%%%%%%#.,,                                     \r\n//                                      ,&%%%%%###%%%%%%%%%%%%#&&.                                    \r\n//                             ..,(&%%%%%%%%%%%%%%%%%%&&%%%%#%&&%&%%%%&&#,                            \r\n//                           ,##//%((#*/#%%%%%%%%%%%%%%%%%%%%%&(.                                     \r\n//                                  (%%%%%%%%%%%%%%%%%%%#%%%%%%%%%&&&&#(*,                            \r\n//                                   ./%%%%&%%%%#%&%%%%%%##%%&&&&%%(*,                                \r\n//                                #%%%%%%&&%%%#%%%%%%%%%%%%%%%&#,*&&#.                                \r\n//                            /%##%(%&/ #%%%%%%%%%%%%%%%%%%%%%%%%%&%%%.                               \r\n//                                 *&%%%%&%%%%%%%%#%%%%%%%%%%%%%%%%%&%%%#%#%%,                        \r\n//                        .*(#&%%%%%%%%&&%%%%%%%%%%#%%%%%%%%%%%%%%%(,                                 \r\n//                    ./#%%%%%%%%%%%%%%%%%%%%%%%#%&%#%%%%%%%%%%%%%%%%%%%%&%%%#####(.                  \r\n//                          .,,*#%%%%%%%%%%%%%##%%&&%#%%%%%%%%&&%%%%%%(&*#&**/(*                      \r\n//                        .,(&%%%%%#((%%%%%%#%%%%%%%%%#%%%%%%%&&&&&%%%%&%*                            \r\n//                         ,,,,,..*&%%%%%%%%%%%%%%%%%%%%%%%&%%%%%%%%%#/*.                             \r\n//                           ,#&%%%%%%%%%%%%%%%%%%%%%%%%&%%%%%%%%%%%%%%%%%%/,                         \r\n//           .     .,*(#%%%%%%%%%&&&&%%%%%%&&&%%%%%%%%%&&%##%%%%%#,(%%%%%%%%%%%(((*                   \r\n//             ,/((%%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%%%%%%%&#  . . ...                       \r\n//                      .,.,,**(%%%%%%%%&%##%%%%%%%%%%%%%%%%%%###%%%%%%%%%&*                          \r\n//                       ,%&%%%%%&&%%%%%%%#%%%%%%%%%%%%%%%%%%&%%%%##%%%%%%%%%%%%%%%%&&#.              \r\n//              .(&&&%%%%%%&#&&%&%%%%%%%##%%%%&&%%%#%%%%%%&%%%%%%&&%%%%&&&/*(,(#(,,.                  \r\n//                         ..&%%%%%%#%#%%%%%%%%%%%##%%%%%%%&%%%%%%%%%%%%%%%%&&(.                      \r\n//                      ,%%%%%%%%%##%%%&%%%%%%%%&%%#%%&&%%%%&%%%%%%&%%%%%&(#%%%#,                     \r\n//              ./%&%%%%%%%%%%%%%%%%%%%%%%%%%&&&%%%##%%%%%%%%%%%%%&&&%%%%%%%%&#.//*/,..               \r\n//      ,#%%%%%%%%%%%%%%%%%%&&%%%%%&&&&%%%%%&&&%%%%%#%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%&&(,..            \r\n//            ,#* ,&&&%,.,*(%%%%%%%%%&%%%%&&&%%%%%&%%%%#%%%%##%%%%%%%&&%%%%%%%%%%%#%%%%%%%%&%(*.      \r\n//          .,,/((#%&%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&&&&&%#%%%%%%%%%%%%%%%%%#%%%%%%%((*           \r\n// *,//**,...,/#%%%%%%%%%%%&&&&%%%%%%%%%%%%%#%%%%%%&&&%%%%&&&&%%%#%%#%%%%%%%%%%%%%%%#*.       .,(#%&@*\r\n//  .*%%(*(%%%%%%%%%%&&&&&&&&%%%%%%%&&%%%%%%%%%%%%%&&&%%%%%%%%%##%%%%%%%%%%%%%%%%%%%%%%%%%%%&%%%/..   \r\n//      .,/%&%%%%%%@#(&%&%%%%%%%%%#&&%%##%#%%%#%%%%&&&%%%%%%%%###%%%%%&&&%%%%%%%%%%%%%%%%&(//%%/      \r\n//          ,..     .(%%%%##%%%#%%%%%%#%%%%%##%%%%%&&&&%%%%%%%#&%#%%%%%%&&&%%%%%##//  ,,.             \r\n//            .,(%#%%##%%%#%%%#%%%#%%*,.*%%%%%%%%%&.,/&%%%%%%% #&%%#%%%%%&%(&%((%&&&(*                \r\n//                        ,/#/(%%,    ,&%%#%/.//         %*&(%#    .(,(%%%.          \r\n\r\npragma solidity ^0.6.8;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/ECDSA.sol\r\n\r\npragma solidity ^0.6.8;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/libs/Fabric.sol\r\n\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\n\r\n/**\r\n * @title Fabric\r\n * @dev Create deterministics vaults.\r\n *\r\n * Original work by Pine.Finance\r\n * - https://github.com/pine-finance\r\n *\r\n * Authors:\r\n * - Agustin Aguilar <agusx1211>\r\n * - Ignacio Mazzara <nachomazzara>\r\n */\r\nlibrary Fabric {\r\n    /*Vault bytecode\r\n\r\n        def _fallback() payable:\r\n            call cd[56] with:\r\n                funct call.data[0 len 4]\r\n                gas cd[56] wei\r\n                args call.data[4 len 64]\r\n            selfdestruct(tx.origin)\r\n\r\n        // Constructor bytecode\r\n        0x6012600081600A8239f3\r\n\r\n        0x60 12 - PUSH1 12           // Size of the contract to return\r\n        0x60 00 - PUSH1 00           // Memory offset to return stored code\r\n        0x81    - DUP2  12           // Size of code to copy\r\n        0x60 0a - PUSH1 0A           // Start of the code to copy\r\n        0x82    - DUP3  00           // Dest memory for code copy\r\n        0x39    - CODECOPY 00 0A 12  // Code copy to memory\r\n        0xf3    - RETURN 00 12       // Return code to store\r\n\r\n        // Deployed contract bytecode\r\n        0x60008060448082803781806038355AF132FF\r\n\r\n        0x60 00 - PUSH1 00                    // Size for the call output\r\n        0x80    - DUP1  00                    // Offset for the call output\r\n        0x60 44 - PUSH1 44                    // Size for the call input\r\n        0x80    - DUP1  44                    // Size for copying calldata to memory\r\n        0x82    - DUP3  00                    // Offset for calldata copy\r\n        0x80    - DUP1  00                    // Offset for destination of calldata copy\r\n        0x37    - CALLDATACOPY 00 00 44       // Execute calldata copy, is going to be used for next call\r\n        0x81    - DUP2  00                    // Offset for call input\r\n        0x80    - DUP1  00                    // Amount of ETH to send during call\r\n        0x60 38 - PUSH1 38                    // calldata pointer to load value into stack\r\n        0x35    - CALLDATALOAD 38 (A)         // Load value (A), address to call\r\n        0x5a    - GAS                         // Remaining gas\r\n        0xf1    - CALL (A) (A) 00 00 44 00 00 // Execute call to address (A) with calldata mem[0:64]\r\n        0x32    - ORIGIN (B)                  // Dest funds for selfdestruct\r\n        0xff    - SELFDESTRUCT (B)            // selfdestruct contract, end of execution\r\n    */\r\n    bytes public constant code = hex\"6012600081600A8239F360008060448082803781806038355AF132FF\";\r\n    bytes32 public constant vaultCodeHash = bytes32(0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97);\r\n\r\n    /**\r\n    * @dev Get a deterministics vault.\r\n    */\r\n    function getVault(bytes32 _key) internal view returns (address) {\r\n        return address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0xff),\r\n                        address(this),\r\n                        _key,\r\n                        vaultCodeHash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Create deterministic vault.\r\n    */\r\n    function executeVault(bytes32 _key, IERC20 _token, address _to) internal returns (uint256 value) {\r\n        address addr;\r\n        bytes memory slotcode = code;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly{\r\n          // Create the contract arguments for the constructor\r\n          addr := create2(0, add(slotcode, 0x20), mload(slotcode), _key)\r\n        }\r\n\r\n        value = _token.balanceOf(addr);\r\n        /* solium-disable-next-line */\r\n        (bool success, ) = addr.call(\r\n            abi.encodePacked(\r\n                abi.encodeWithSelector(\r\n                    _token.transfer.selector,\r\n                    _to,\r\n                    value\r\n                ),\r\n                address(_token)\r\n            )\r\n        );\r\n\r\n        require(success, \"Error pulling tokens\");\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IModule.sol\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\n\r\n/**\r\n * Original work by Pine.Finance\r\n * - https://github.com/pine-finance\r\n *\r\n * Authors:\r\n * - Ignacio Mazzara <nachomazzara>\r\n * - Agustin Aguilar <agusx1211>\r\n */\r\ninterface IModule {\r\n    /// @notice receive ETH\r\n    receive() external payable;\r\n\r\n    /**\r\n     * @notice Executes an order\r\n     * @param _inputToken - Address of the input token\r\n     * @param _inputAmount - uint256 of the input token amount (order amount)\r\n     * @param _owner - Address of the order's owner\r\n     * @param _data - Bytes of the order's data\r\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\r\n     * @return bought - amount of output token bought\r\n     */\r\n    function execute(\r\n        IERC20 _inputToken,\r\n        uint256 _inputAmount,\r\n        address payable _owner,\r\n        bytes calldata _data,\r\n        bytes calldata _auxData\r\n    ) external returns (uint256 bought);\r\n\r\n    /**\r\n     * @notice Check whether an order can be executed or not\r\n     * @param _inputToken - Address of the input token\r\n     * @param _inputAmount - uint256 of the input token amount (order amount)\r\n     * @param _data - Bytes of the order's data\r\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\r\n     * @return bool - whether the order can be executed or not\r\n     */\r\n    function canExecute(\r\n        IERC20 _inputToken,\r\n        uint256 _inputAmount,\r\n        bytes calldata _data,\r\n        bytes calldata _auxData\r\n    ) external view returns (bool);\r\n}\r\n\r\n// File: contracts/commons/Order.sol\r\n\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\ncontract Order {\r\n    address public constant ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n}\r\n\r\n// File: contracts/PineCore.sol\r\n\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Original work by Pine.Finance\r\n * - https://github.com/pine-finance\r\n *\r\n * Authors:\r\n * - Ignacio Mazzara <nachomazzara>\r\n * - Agustin Aguilar <agusx1211>\r\n */\r\ncontract PineCore is Order {\r\n    using SafeMath for uint256;\r\n    using Fabric for bytes32;\r\n\r\n    // ETH orders\r\n    mapping(bytes32 => uint256) public ethDeposits;\r\n\r\n    // Events\r\n    event DepositETH(\r\n        bytes32 indexed _key,\r\n        address indexed _caller,\r\n        uint256 _amount,\r\n        bytes _data\r\n    );\r\n\r\n    event OrderExecuted(\r\n        bytes32 indexed _key,\r\n        address _inputToken,\r\n        address _owner,\r\n        address _witness,\r\n        bytes _data,\r\n        bytes _auxData,\r\n        uint256 _amount,\r\n        uint256 _bought\r\n    );\r\n\r\n    event OrderCancelled(\r\n        bytes32 indexed _key,\r\n        address _inputToken,\r\n        address _owner,\r\n        address _witness,\r\n        bytes _data,\r\n        uint256 _amount\r\n    );\r\n\r\n    /**\r\n     * @dev Prevent users to send Ether directly to this contract\r\n     */\r\n    receive() external payable {\r\n        require(\r\n            msg.sender != tx.origin,\r\n            \"PineCore#receive: NO_SEND_ETH_PLEASE\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Create an ETH to token order\r\n     * @param _data - Bytes of an ETH to token order. See `encodeEthOrder` for more info\r\n     */\r\n    function depositEth(\r\n        bytes calldata _data\r\n    ) external payable {\r\n        require(msg.value > 0, \"PineCore#depositEth: VALUE_IS_0\");\r\n\r\n        (\r\n            address module,\r\n            address inputToken,\r\n            address payable owner,\r\n            address witness,\r\n            bytes memory data,\r\n        ) = decodeOrder(_data);\r\n\r\n        require(inputToken == ETH_ADDRESS, \"PineCore#depositEth: WRONG_INPUT_TOKEN\");\r\n\r\n        bytes32 key = keyOf(\r\n            IModule(uint160(module)),\r\n            IERC20(inputToken),\r\n            owner,\r\n            witness,\r\n            data\r\n        );\r\n\r\n        ethDeposits[key] = ethDeposits[key].add(msg.value);\r\n        emit DepositETH(key, msg.sender, msg.value, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel order\r\n     * @dev The params should be the same used for the order creation\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     */\r\n    function cancelOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes calldata _data\r\n    ) external {\r\n        require(msg.sender == _owner, \"PineCore#cancelOrder: INVALID_OWNER\");\r\n        bytes32 key = keyOf(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            _witness,\r\n            _data\r\n        );\r\n\r\n        uint256 amount = _pullOrder(_inputToken, key, msg.sender);\r\n\r\n        emit OrderCancelled(\r\n            key,\r\n            address(_inputToken),\r\n            _owner,\r\n            _witness,\r\n            _data,\r\n            amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the calldata needed to create a token to token/ETH order\r\n     * @dev Returns the input data that the user needs to use to create the order\r\n     * The _secret is used to prevent a front-running at the order execution\r\n     * The _amount is used as the param `_value` for the ERC20 `transfer` function\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @param _secret - Private key of the _witness\r\n     * @param _amount - uint256 of the order amount\r\n     * @return bytes - input data to send the transaction\r\n     */\r\n    function encodeTokenOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes calldata _data,\r\n        bytes32 _secret,\r\n        uint256 _amount\r\n    ) external view returns (bytes memory) {\r\n        return abi.encodeWithSelector(\r\n            _inputToken.transfer.selector,\r\n            vaultOfOrder(\r\n                _module,\r\n                _inputToken,\r\n                _owner,\r\n                _witness,\r\n                _data\r\n            ),\r\n            _amount,\r\n            abi.encode(\r\n                _module,\r\n                _inputToken,\r\n                _owner,\r\n                _witness,\r\n                _data,\r\n                _secret\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the calldata needed to create a ETH to token order\r\n     * @dev Returns the input data that the user needs to use to create the order\r\n     * The _secret is used to prevent a front-running at the order execution\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @param _secret -  Private key of the _witness\r\n     * @return bytes - input data to send the transaction\r\n     */\r\n    function encodeEthOrder(\r\n        address _module,\r\n        address _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes calldata _data,\r\n        bytes32 _secret\r\n    ) external pure returns (bytes memory) {\r\n        return abi.encode(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            _witness,\r\n            _data,\r\n            _secret\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get order's properties\r\n     * @param _data - Bytes of the order\r\n     * @return module - Address of the module to use for the order execution\r\n     * @return inputToken - Address of the input token\r\n     * @return owner - Address of the order's owner\r\n     * @return witness - Address of the witness\r\n     * @return data - Bytes of the order's data\r\n     * @return secret -  Private key of the _witness\r\n     */\r\n    function decodeOrder(\r\n        bytes memory _data\r\n    ) public pure returns (\r\n        address module,\r\n        address inputToken,\r\n        address payable owner,\r\n        address witness,\r\n        bytes memory data,\r\n        bytes32 secret\r\n    ) {\r\n        (\r\n            module,\r\n            inputToken,\r\n            owner,\r\n            witness,\r\n            data,\r\n            secret\r\n        ) = abi.decode(\r\n            _data,\r\n            (\r\n                address,\r\n                address,\r\n                address,\r\n                address,\r\n                bytes,\r\n                bytes32\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the vault's address of a token to token/ETH order\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @return address - The address of the vault\r\n     */\r\n    function vaultOfOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes memory _data\r\n    ) public view returns (address) {\r\n        return keyOf(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            _witness,\r\n            _data\r\n        ).getVault();\r\n    }\r\n\r\n     /**\r\n     * @notice Executes an order\r\n     * @dev The sender should use the _secret to sign its own address\r\n     * to prevent front-runnings\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _data - Bytes of the order's data\r\n     * @param _signature - Signature to calculate the witness\r\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\r\n     */\r\n    function executeOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        bytes calldata _data,\r\n        bytes calldata _signature,\r\n        bytes calldata _auxData\r\n    ) external {\r\n        // Calculate witness using signature\r\n        address witness = ECDSA.recover(\r\n            keccak256(abi.encodePacked(msg.sender)),\r\n            _signature\r\n        );\r\n\r\n        bytes32 key = keyOf(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            witness,\r\n            _data\r\n        );\r\n\r\n        // Pull amount\r\n        uint256 amount = _pullOrder(_inputToken, key, address(_module));\r\n        require(amount > 0, \"PineCore#executeOrder: INVALID_ORDER\");\r\n\r\n        uint256 bought = _module.execute(\r\n            _inputToken,\r\n            amount,\r\n            _owner,\r\n            _data,\r\n            _auxData\r\n        );\r\n\r\n        emit OrderExecuted(\r\n            key,\r\n            address(_inputToken),\r\n            _owner,\r\n            witness,\r\n            _data,\r\n            _auxData,\r\n            amount,\r\n            bought\r\n        );\r\n    }\r\n\r\n     /**\r\n     * @notice Check whether an order exists or not\r\n     * @dev Check the balance of the order\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @return bool - whether the order exists or not\r\n     */\r\n    function existOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes calldata _data\r\n    ) external view returns (bool) {\r\n        bytes32 key = keyOf(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            _witness,\r\n           _data\r\n        );\r\n\r\n        if (address(_inputToken) == ETH_ADDRESS) {\r\n            return ethDeposits[key] != 0;\r\n        } else {\r\n            return _inputToken.balanceOf(key.getVault()) != 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether an order can be executed or not\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\r\n     * @return bool - whether the order can be executed or not\r\n     */\r\n    function canExecuteOrder(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes calldata _data,\r\n        bytes calldata _auxData\r\n    ) external view returns (bool) {\r\n        bytes32 key = keyOf(\r\n            _module,\r\n            _inputToken,\r\n            _owner,\r\n            _witness,\r\n            _data\r\n        );\r\n\r\n        // Pull amount\r\n        uint256 amount;\r\n        if (address(_inputToken) == ETH_ADDRESS) {\r\n            amount = ethDeposits[key];\r\n        } else {\r\n            amount = _inputToken.balanceOf(key.getVault());\r\n        }\r\n\r\n        return _module.canExecute(\r\n            _inputToken,\r\n            amount,\r\n            _data,\r\n            _auxData\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the order amount to a recipient.\r\n     * @dev For an ETH order, the ETH will be transferred from this contract\r\n     * For a token order, its vault will be executed transferring the amount of tokens to\r\n     * the recipient\r\n     * @param _inputToken - Address of the input token\r\n     * @param _key - Order's key\r\n     * @param _to - Address of the recipient\r\n     * @return amount - amount transferred\r\n     */\r\n    function _pullOrder(\r\n        IERC20 _inputToken,\r\n        bytes32 _key,\r\n        address payable _to\r\n    ) private returns (uint256 amount) {\r\n        if (address(_inputToken) == ETH_ADDRESS) {\r\n            amount = ethDeposits[_key];\r\n            ethDeposits[_key] = 0;\r\n            (bool success,) = _to.call{value: amount}(\"\");\r\n            require(success, \"PineCore#_pullOrder: PULL_ETHER_FAILED\");\r\n        } else {\r\n            amount = _key.executeVault(_inputToken, _to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the order's key\r\n     * @param _module - Address of the module to use for the order execution\r\n     * @param _inputToken - Address of the input token\r\n     * @param _owner - Address of the order's owner\r\n     * @param _witness - Address of the witness\r\n     * @param _data - Bytes of the order's data\r\n     * @return bytes32 - order's key\r\n     */\r\n    function keyOf(\r\n        IModule _module,\r\n        IERC20 _inputToken,\r\n        address payable _owner,\r\n        address _witness,\r\n        bytes memory _data\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                _module,\r\n                _inputToken,\r\n                _owner,\r\n                _witness,\r\n                _data\r\n            )\r\n        );\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"DepositETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bought\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"}],\"name\":\"canExecuteOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decodeOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"depositEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"encodeEthOrder\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"encodeTokenOrder\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ethDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"}],\"name\":\"executeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"existOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"keyOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"vaultOfOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PineCore", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b9629d6bde831624e17df60c10ae7e2e41f4545b708a2d79841593aacf138231"}