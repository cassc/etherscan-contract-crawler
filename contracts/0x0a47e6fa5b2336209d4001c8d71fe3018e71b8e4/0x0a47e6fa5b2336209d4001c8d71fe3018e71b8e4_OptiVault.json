{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OptiVault.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\nimport '@uniswap/v2-periphery/contracts/interfaces/IERC20.sol';\\r\\n\\r\\ninterface IOptiVaultBalanceLookup {\\r\\n  function sharesOf(address user) external view returns (uint256 _shares); //shares\\r\\n}\\r\\n\\r\\ncontract OptiVault {\\r\\n  // **********************************************************************************\\r\\n  // *       OptiVaults provide an easy way to lock tokens as a group.                *\\r\\n  // *    Reflective staking means that early withdrawals are allowed,                *\\r\\n  // *      for a 20% penalty that is distributed to everyone else.                   *\\r\\n  // **********************************************************************************\\r\\n\\r\\n  bool private initialized;\\r\\n  IERC20 public token; \\r\\n  uint256 public lockupDate;                         // deposits cannot be made after this\\r\\n  uint256 public minimumTokenCommitment;             // deposited tokens must exceed this amount to lock\\r\\n  bool public failed;                                // campaign failed to reach minimum and is not subject to lock\\r\\n  bool public succeeded;                             // campaign reached minimum and is locked\\r\\n  uint256 public withdrawalsLockedUntilTimestamp;    // time at which haircut-free withdrawal is available.\\r\\n  mapping (address => uint256) private shareBalance; // internal balance tracking for self-contained campaigns\\r\\n  uint256 private totalShares;                       // the denominator which decreases faster than the token balance\\r\\n  IOptiVaultBalanceLookup public shareBalanceLookup; // external balance tracking for use by other contracts\\r\\n  mapping (address => bool) public withdrawn;        // instead of zeroing share balances, this flag is set.\\r\\n\\r\\n  function initialize(address _token, uint256 _lockupDate, uint256 _minimumTokenCommitment, uint256 _withdrawalsLockedUntilTimestamp, address _balanceLookup) external {\\r\\n     require(!initialized);\\r\\n     token = IERC20(_token);\\r\\n     lockupDate = _lockupDate;\\r\\n     minimumTokenCommitment = _minimumTokenCommitment;\\r\\n     withdrawalsLockedUntilTimestamp = _withdrawalsLockedUntilTimestamp;\\r\\n     if (lockupDate == 0) {\\r\\n       totalShares = token.balanceOf(address(this));\\r\\n     }\\r\\n     shareBalanceLookup = IOptiVaultBalanceLookup(_balanceLookup);\\r\\n     initialized = true;\\r\\n   }\\r\\n \\r\\n  function unlockTimestamp() external view returns (uint256 _unlockTimestamp) {\\r\\n    _unlockTimestamp = withdrawalsLockedUntilTimestamp;\\r\\n  }\\r\\n\\r\\n  function sharesOf(address user) external view returns (uint256 _shares) {\\r\\n    //Shares in the staking venture.    \\r\\n    _shares = shareBalance[user];\\r\\n  }\\r\\n\\r\\n  function tokenBalanceOf(address user) external view returns (uint256 _amount) {\\r\\n    //The number of tokens redeemable by the user's share.\\r\\n    if (withdrawn[msg.sender]) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 shares = shareBalanceLookup.sharesOf(user);\\r\\n    _amount = (shares * token.balanceOf(address(this))) / totalShares;\\r\\n  }\\r\\n\\r\\n  function tokenLocked() external view returns (address _token) {\\r\\n    _token = address(token);\\r\\n  }\\r\\n\\r\\n  function withdrawable() public view returns (bool) {\\r\\n    return (failed || block.timestamp >= withdrawalsLockedUntilTimestamp);\\r\\n  }\\r\\n\\r\\n  function contribute(uint tokenAmount) public {\\r\\n    require(block.timestamp < lockupDate, \\\"OptiVault: Pooling phase has ended.\\\");\\r\\n    token.transferFrom(msg.sender, address(this), tokenAmount);\\r\\n    shareBalance[msg.sender] += tokenAmount;\\r\\n    totalShares += tokenAmount;\\r\\n    if (token.balanceOf(address(this)) >= minimumTokenCommitment) {\\r\\n      succeeded = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function fail() public {\\r\\n    require(block.timestamp > lockupDate, \\\"OptiVault: Still in Pooling phase.\\\");\\r\\n    require(token.balanceOf(address(this)) < minimumTokenCommitment, \\\"OptiVault: Staking succesful.\\\");\\r\\n    require(!succeeded, \\\"OptiVault: Campaign already succeeded.\\\");\\r\\n    require(!failed, \\\"OptiVault: Campaign already marked failed.\\\");\\r\\n    failed = true;\\r\\n  }\\r\\n\\r\\n  function earlyWithdrawTokens() public {\\r\\n    require(withdrawn[msg.sender] == false, \\\"OptiVault: Already withdrawn.\\\");\\r\\n    require(block.timestamp > lockupDate, \\\"OptiVault: Still in Pooling phase.\\\");\\r\\n    require(!withdrawable(), \\\"OptiVault: Staking period has ended.\\\");\\r\\n    uint userTokenBalance = this.tokenBalanceOf(msg.sender);\\r\\n    uint userShareBalance = shareBalanceLookup.sharesOf(msg.sender);\\r\\n\\r\\n    uint toTransfer; \\r\\n    if (userShareBalance == totalShares) {\\r\\n      toTransfer = userTokenBalance;\\r\\n    } else {\\r\\n      toTransfer = userTokenBalance * 80 / 100;\\r\\n    }\\r\\n\\r\\n    totalShares -= userShareBalance;\\r\\n    token.transfer(msg.sender, toTransfer);\\r\\n    withdrawn[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function withdrawTokens() public {\\r\\n    require(withdrawable(), \\\"OptiVault: Tokens still locked.\\\");\\r\\n    require(withdrawn[msg.sender] == false, \\\"OptiVault: Already withdrawn.\\\");\\r\\n    uint toTransfer =  this.tokenBalanceOf(msg.sender);\\r\\n    token.transfer(msg.sender, toTransfer);\\r\\n    totalShares -= shareBalanceLookup.sharesOf(msg.sender);\\r\\n    withdrawn[msg.sender] = true;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyWithdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockupDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumTokenCommitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalsLockedUntilTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_balanceLookup\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokenCommitment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareBalanceLookup\",\"outputs\":[{\"internalType\":\"contract IOptiVaultBalanceLookup\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"succeeded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLocked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsLockedUntilTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OptiVault", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}