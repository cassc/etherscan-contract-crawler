{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/settings/SuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { QuorumManager } from \\\"src/crosschain-data/utils/QuorumManager.sol\\\";\\nimport { ISuperRBAC } from \\\"src/interfaces/ISuperRBAC.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\n/// @title SuperRegistry\\n/// @dev Keeps information on all addresses used in the Superform ecosystem\\n/// @author Zeropoint Labs\\ncontract SuperRegistry is ISuperRegistry, QuorumManager {\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    uint256 private constant MIN_DELAY = 15 minutes;\\n    uint256 private constant MAX_DELAY = 24 hours;\\n    uint64 public immutable CHAIN_ID;\\n\\n    /// @dev core protocol - identifiers\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override SUPERFORM_ROUTER = keccak256(\\\"SUPERFORM_ROUTER\\\");\\n\\n    /// @dev can be used to set a new factory that has form ids paused\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override SUPERFORM_FACTORY = keccak256(\\\"SUPERFORM_FACTORY\\\");\\n\\n    /// @dev can be used to set a new paymaster to forward payments to\\n    /// @dev could be allowed to be changed\\n    bytes32 public constant override PAYMASTER = keccak256(\\\"PAYMASTER\\\");\\n\\n    /// @dev accessed in some areas of the protocol to calculate AMB fees. Already has a function to alter the\\n    /// configuration\\n    /// @dev could be allowed to be changed\\n    bytes32 public constant override PAYMENT_HELPER = keccak256(\\\"PAYMENT_HELPER\\\");\\n\\n    /// @dev accessed in many areas of the protocol. has direct access to superforms\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override CORE_STATE_REGISTRY = keccak256(\\\"CORE_STATE_REGISTRY\\\");\\n\\n    /// @dev accessed in many areas of the protocol. has direct access to timelock form\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override TIMELOCK_STATE_REGISTRY = keccak256(\\\"TIMELOCK_STATE_REGISTRY\\\");\\n\\n    /// @dev used to sync messages for pausing superforms or deploying transmuters\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override BROADCAST_REGISTRY = keccak256(\\\"BROADCAST_REGISTRY\\\");\\n\\n    /// @dev not accessed in protocol\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override SUPER_POSITIONS = keccak256(\\\"SUPER_POSITIONS\\\");\\n\\n    /// @dev accessed in many areas of the protocol\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override SUPER_RBAC = keccak256(\\\"SUPER_RBAC\\\");\\n\\n    /// @dev not accessed in protocol\\n    /// @dev could be allowed to be changed\\n    bytes32 public constant override PAYLOAD_HELPER = keccak256(\\\"PAYLOAD_HELPER\\\");\\n\\n    /// @dev accessed in CSR and validators. can be used to alter behaviour of update deposit payloads\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override DST_SWAPPER = keccak256(\\\"DST_SWAPPER\\\");\\n\\n    /// @dev accessed in base form to send payloads to emergency queue\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override EMERGENCY_QUEUE = keccak256(\\\"EMERGENCY_QUEUE\\\");\\n\\n    /// @dev receiver of bridge refunds and airdropped tokens\\n    /// @notice should not be allowed to be changed\\n    bytes32 public constant override SUPERFORM_RECEIVER = keccak256(\\\"SUPERFORM_RECEIVER\\\");\\n\\n    /// @dev default keepers - identifiers\\n    /// @dev could be allowed to be changed\\n    bytes32 public constant override PAYMENT_ADMIN = keccak256(\\\"PAYMENT_ADMIN\\\");\\n    bytes32 public constant override CORE_REGISTRY_PROCESSOR = keccak256(\\\"CORE_REGISTRY_PROCESSOR\\\");\\n    bytes32 public constant override BROADCAST_REGISTRY_PROCESSOR = keccak256(\\\"BROADCAST_REGISTRY_PROCESSOR\\\");\\n    bytes32 public constant override TIMELOCK_REGISTRY_PROCESSOR = keccak256(\\\"TIMELOCK_REGISTRY_PROCESSOR\\\");\\n    bytes32 public constant override CORE_REGISTRY_UPDATER = keccak256(\\\"CORE_REGISTRY_UPDATER\\\");\\n    bytes32 public constant override CORE_REGISTRY_RESCUER = keccak256(\\\"CORE_REGISTRY_RESCUER\\\");\\n    bytes32 public constant override CORE_REGISTRY_DISPUTER = keccak256(\\\"CORE_REGISTRY_DISPUTER\\\");\\n    bytes32 public constant override DST_SWAPPER_PROCESSOR = keccak256(\\\"DST_SWAPPER_PROCESSOR\\\");\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev canonical permit2 contract\\n    address private permit2Address;\\n\\n    /// @dev rescue timelock delay config\\n    uint256 public delay;\\n\\n    mapping(bytes32 id => mapping(uint64 chainid => address moduleAddress)) private registry;\\n    /// @dev liquidityBridge id is mapped to a liquidityBridge address (to prevent interaction with unauthorized\\n    /// bridges)\\n    mapping(uint8 bridgeId => address bridgeAddress) public bridgeAddresses;\\n    mapping(uint8 bridgeId => address bridgeValidator) public bridgeValidator;\\n    mapping(uint8 ambId => address ambAddresses) public ambAddresses;\\n    mapping(uint8 ambId => bool isBroadcastAMB) public isBroadcastAMB;\\n\\n    mapping(uint64 chainId => uint256 vaultLimitPerDestination) public vaultLimitPerDestination;\\n\\n    mapping(uint8 registryId => address registryAddress) public registryAddresses;\\n    /// @dev is the reverse mapping of registryAddresses\\n    mapping(address registryAddress => uint8 registryId) public stateRegistryIds;\\n    /// @dev is the reverse mapping of ambAddresses\\n    mapping(address ambAddress => uint8 ambId) public ambIds;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlyEmergencyAdmin() {\\n        if (!ISuperRBAC(registry[SUPER_RBAC][CHAIN_ID]).hasEmergencyAdminRole(msg.sender)) {\\n            revert Error.NOT_EMERGENCY_ADMIN();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProtocolAdmin() {\\n        if (!ISuperRBAC(registry[SUPER_RBAC][CHAIN_ID]).hasProtocolAdminRole(msg.sender)) {\\n            revert Error.NOT_PROTOCOL_ADMIN();\\n        }\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(address superRBAC_) {\\n        if (superRBAC_ == address(0)) {\\n            revert Error.ZERO_ADDRESS();\\n        }\\n\\n        if (block.chainid > type(uint64).max) {\\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n        }\\n\\n        CHAIN_ID = uint64(block.chainid);\\n        registry[SUPER_RBAC][CHAIN_ID] = superRBAC_;\\n\\n        emit AddressUpdated(SUPER_RBAC, CHAIN_ID, address(0), superRBAC_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getAddress(bytes32 id_) external view override returns (address addr) {\\n        addr = registry[id_][CHAIN_ID];\\n        if (addr == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view override returns (address addr) {\\n        addr = registry[id_][chainId_];\\n        if (addr == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getBridgeAddress(uint8 bridgeId_) external view override returns (address bridgeAddress_) {\\n        bridgeAddress_ = bridgeAddresses[bridgeId_];\\n        if (bridgeAddress_ == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getBridgeValidator(uint8 bridgeId_) external view override returns (address bridgeValidator_) {\\n        bridgeValidator_ = bridgeValidator[bridgeId_];\\n        if (bridgeValidator_ == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getAmbAddress(uint8 ambId_) external view override returns (address ambAddress_) {\\n        ambAddress_ = ambAddresses[ambId_];\\n        if (ambAddress_ == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getAmbId(address ambAddress_) external view override returns (uint8 ambId_) {\\n        ambId_ = ambIds[ambAddress_];\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getStateRegistry(uint8 registryId_) external view override returns (address registryAddress_) {\\n        registryAddress_ = registryAddresses[registryId_];\\n        if (registryAddress_ == address(0)) revert Error.ZERO_ADDRESS();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getStateRegistryId(address registryAddress_) external view override returns (uint8 registryId_) {\\n        registryId_ = stateRegistryIds[registryAddress_];\\n        if (registryId_ == 0) revert Error.INVALID_REGISTRY_ID();\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function getVaultLimitPerDestination(uint64 chainId_)\\n        external\\n        view\\n        override\\n        returns (uint256 vaultLimitPerDestination_)\\n    {\\n        vaultLimitPerDestination_ = vaultLimitPerDestination[chainId_];\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function isValidStateRegistry(address registryAddress_) external view override returns (bool valid_) {\\n        if (stateRegistryIds[registryAddress_] != 0) return true;\\n\\n        return false;\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function isValidAmbImpl(address ambAddress_) external view override returns (bool valid_) {\\n        uint8 ambId = ambIds[ambAddress_];\\n        if (ambId != 0 && !isBroadcastAMB[ambId]) return true;\\n\\n        return false;\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view override returns (bool valid_) {\\n        uint8 ambId = ambIds[ambAddress_];\\n        if (ambId != 0 && isBroadcastAMB[ambId]) return true;\\n\\n        return false;\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function PERMIT2() external view override returns (address) {\\n        if (permit2Address == address(0)) revert Error.ZERO_ADDRESS();\\n        return permit2Address;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external override onlyEmergencyAdmin {\\n        if (vaultLimit_ == 0) {\\n            revert Error.ZERO_INPUT_VALUE();\\n        }\\n\\n        vaultLimitPerDestination[chainId_] = vaultLimit_;\\n        emit SetVaultLimitPerDestination(chainId_, vaultLimit_);\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setDelay(uint256 delay_) external override onlyProtocolAdmin {\\n        if (delay_ < MIN_DELAY || delay_ > MAX_DELAY) {\\n            revert Error.INVALID_TIMELOCK_DELAY();\\n        }\\n\\n        uint256 oldDelay_ = delay;\\n        delay = delay_;\\n\\n        emit SetDelay(oldDelay_, delay_);\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setPermit2(address permit2_) external override onlyProtocolAdmin {\\n        if (permit2Address != address(0)) revert Error.DISABLED();\\n        if (permit2_ == address(0)) revert Error.ZERO_ADDRESS();\\n\\n        permit2Address = permit2_;\\n\\n        emit SetPermit2(permit2_);\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function batchSetAddress(\\n        bytes32[] calldata ids_,\\n        address[] calldata newAddresses_,\\n        uint64[] calldata chainIds_\\n    )\\n        external\\n        override\\n        onlyProtocolAdmin\\n    {\\n        uint256 len = ids_.length;\\n\\n        if (len != newAddresses_.length || len != chainIds_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < len; ++i) {\\n            setAddress(ids_[i], newAddresses_[i], chainIds_[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) public override onlyProtocolAdmin {\\n        address oldAddress = registry[id_][chainId_];\\n        if (oldAddress != address(0)) {\\n            /// @notice SUPERFORM_FACTORY, CORE_STATE_REGISTRY, TIMELOCK_STATE_REGISTRY, BROADCAST_REGISTRY, SUPER_RBAC,\\n            /// DST_SWAPPER, EMERGENCY_QUEUE, SUPER_POSITIONS and SUPERFORM_ROUTER  cannot be changed once set\\n            if (\\n                id_ == SUPERFORM_FACTORY || id_ == CORE_STATE_REGISTRY || id_ == TIMELOCK_STATE_REGISTRY\\n                    || id_ == BROADCAST_REGISTRY || id_ == SUPER_RBAC || id_ == DST_SWAPPER || id_ == EMERGENCY_QUEUE\\n                    || id_ == SUPER_POSITIONS || id_ == SUPERFORM_ROUTER\\n            ) {\\n                revert Error.DISABLED();\\n            }\\n        }\\n\\n        registry[id_][chainId_] = newAddress_;\\n\\n        emit AddressUpdated(id_, chainId_, oldAddress, newAddress_);\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external\\n        override\\n        onlyProtocolAdmin\\n    {\\n        uint256 len = bridgeId_.length;\\n        if (len != bridgeAddress_.length || len != bridgeValidator_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < len; ++i) {\\n            uint8 bridgeId = bridgeId_[i];\\n            address bridgeAddress = bridgeAddress_[i];\\n            address bridgeValidatorT = bridgeValidator_[i];\\n            if (bridgeAddress == address(0)) revert Error.ZERO_ADDRESS();\\n            if (bridgeId == 0) revert Error.ZERO_INPUT_VALUE();\\n            if (bridgeValidatorT == address(0)) revert Error.ZERO_ADDRESS();\\n\\n            if (bridgeAddresses[bridgeId] != address(0)) revert Error.DISABLED();\\n\\n            bridgeAddresses[bridgeId] = bridgeAddress;\\n            bridgeValidator[bridgeId] = bridgeValidatorT;\\n            emit SetBridgeAddress(bridgeId, bridgeAddress);\\n            emit SetBridgeValidator(bridgeId, bridgeValidatorT);\\n        }\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external\\n        override\\n        onlyProtocolAdmin\\n    {\\n        uint256 len = ambId_.length;\\n        if (len != ambAddress_.length || len != isBroadcastAMB_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < len; ++i) {\\n            address ambAddress = ambAddress_[i];\\n            uint8 ambId = ambId_[i];\\n            bool broadcastAMB = isBroadcastAMB_[i];\\n\\n            if (ambAddress == address(0)) revert Error.ZERO_ADDRESS();\\n            if (ambId == 0) revert Error.ZERO_INPUT_VALUE();\\n            if (ambAddresses[ambId] != address(0)) revert Error.DISABLED();\\n\\n            ambAddresses[ambId] = ambAddress;\\n            ambIds[ambAddress] = ambId;\\n            isBroadcastAMB[ambId] = broadcastAMB;\\n            emit SetAmbAddress(ambId, ambAddress, broadcastAMB);\\n        }\\n    }\\n\\n    /// @inheritdoc ISuperRegistry\\n    function setStateRegistryAddress(\\n        uint8[] memory registryId_,\\n        address[] memory registryAddress_\\n    )\\n        external\\n        override\\n        onlyProtocolAdmin\\n    {\\n        uint256 len = registryId_.length;\\n        if (len != registryAddress_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < len; ++i) {\\n            address registryAddress = registryAddress_[i];\\n            uint8 registryId = registryId_[i];\\n            if (registryAddress == address(0)) revert Error.ZERO_ADDRESS();\\n            if (registryId == 0) revert Error.ZERO_INPUT_VALUE();\\n            if (registryAddresses[registryId] != address(0)) {\\n                revert Error.DISABLED();\\n            }\\n\\n            registryAddresses[registryId] = registryAddress;\\n            stateRegistryIds[registryAddress] = registryId;\\n            emit SetStateRegistryAddress(registryId, registryAddress);\\n        }\\n    }\\n\\n    /// @inheritdoc QuorumManager\\n    function setRequiredMessagingQuorum(uint64 srcChainId_, uint256 quorum_) external override onlyProtocolAdmin {\\n        if (srcChainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n\\n        requiredQuorum[srcChainId_] = quorum_;\\n\\n        emit QuorumSet(srcChainId_, quorum_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/crosschain-data/utils/QuorumManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IQuorumManager } from \\\"src/interfaces/IQuorumManager.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\n/// @title QuorumManager\\n/// @dev Quorum thresholds using in sending proofs from chain to chain\\n/// @author ZeroPoint Labs\\nabstract contract QuorumManager is IQuorumManager {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    mapping(uint64 srcChainId => uint256 quorum) internal requiredQuorum;\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IQuorumManager\\n    function getRequiredMessagingQuorum(uint64 srcChainId_) public view returns (uint256 quorum_) {\\n        /// @dev no chain can have chain id zero. (validates that here)\\n        if (srcChainId_ == 0) {\\n            revert Error.ZERO_INPUT_VALUE();\\n        }\\n        return requiredQuorum[srcChainId_];\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc IQuorumManager\\n    function setRequiredMessagingQuorum(uint64 srcChainId_, uint256 quorum_) external virtual;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IAccessControl } from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\n/// @title ISuperRBAC\\n/// @dev Interface for SuperRBAC\\n/// @author Zeropoint Labs\\ninterface ISuperRBAC is IAccessControl {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct InitialRoleSetup {\\n        address admin;\\n        address emergencyAdmin;\\n        address paymentAdmin;\\n        address csrProcessor;\\n        address tlProcessor;\\n        address brProcessor;\\n        address csrUpdater;\\n        address srcVaaRelayer;\\n        address dstSwapper;\\n        address csrRescuer;\\n        address csrDisputer;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when superRegistry is set\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev is emitted when an admin is set for a role\\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the id of the protocol admin role\\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency admin role\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin role\\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcaster role\\n    function BROADCASTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor role\\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock state registry processor role\\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry processor role\\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater role\\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper role\\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescuer role\\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescue disputer role\\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of wormhole vaa relayer role\\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns whether the given address has the protocol admin role\\n    /// @param admin_ the address to check\\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\\n\\n    /// @dev returns whether the given address has the emergency admin role\\n    /// @param admin_ the address to check\\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev updates the super registry address\\n    function setSuperRegistry(address superRegistry_) external;\\n\\n    /// @dev configures a new role in superForm\\n    /// @param role_ the role to set\\n    /// @param adminRole_ the admin role to set as admin\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\\n\\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\\n    /// @param role_ the role to revoke\\n    /// @param extraData_ amb config if broadcasting is required\\n    /// @param superRegistryAddressId_ the super registry address id\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows sync of global roles from different chains using broadcast registry\\n    /// @notice may not work for all roles\\n    function stateSyncBroadcast(bytes memory data_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperRegistry\\n/// @dev Interface for SuperRegistry\\n/// @author Zeropoint Labs\\ninterface ISuperRegistry {\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when permit2 is set.\\n    event SetPermit2(address indexed permit2);\\n\\n    /// @dev is emitted when an address is set.\\n    event AddressUpdated(\\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\\n    );\\n\\n    /// @dev is emitted when a new token bridge is configured.\\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\\n\\n    /// @dev is emitted when a new bridge validator is configured.\\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\\n\\n    /// @dev is emitted when a new amb is configured.\\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\\n\\n    /// @dev is emitted when a new state registry is configured.\\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\\n\\n    /// @dev is emitted when a new delay is configured.\\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\\n\\n    /// @dev is emitted when a new vault limit is configured\\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the deposit rescue delay\\n    function delay() external view returns (uint256);\\n\\n    /// @dev returns the permit2 address\\n    function PERMIT2() external view returns (address);\\n\\n    /// @dev returns the id of the superform router module\\n    function SUPERFORM_ROUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform factory module\\n    function SUPERFORM_FACTORY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform paymaster contract\\n    function PAYMASTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform payload helper contract\\n    function PAYMENT_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry module\\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry module\\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry module\\n    function BROADCAST_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super positions module\\n    function SUPER_POSITIONS() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super rbac module\\n    function SUPER_RBAC() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payload helper module\\n    function PAYLOAD_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper keeper\\n    function DST_SWAPPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency queue\\n    function EMERGENCY_QUEUE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform receiver\\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin keeper\\n    function PAYMENT_ADMIN() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor keeper\\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast registry processor keeper\\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry processor keeper\\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev gets the address of a contract on current chain\\n    /// @param id_ is the id of the contract\\n    function getAddress(bytes32 id_) external view returns (address);\\n\\n    /// @dev gets the address of a contract on a target chain\\n    /// @param id_ is the id of the contract\\n    /// @param chainId_ is the chain id of that chain\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\\n\\n    /// @dev gets the address of a bridge\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeAddress_ is the address of the form\\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\\n\\n    /// @dev gets the address of a bridge validator\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeValidator_ is the address of the form\\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\\n\\n    /// @dev gets the address of a amb\\n    /// @param ambId_ is the id of a bridge\\n    /// @return ambAddress_ is the address of the form\\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\\n\\n    /// @dev gets the id of the amb\\n    /// @param ambAddress_ is the address of an amb\\n    /// @return ambId_ is the identifier of an amb\\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\\n\\n    /// @dev gets the address of the registry\\n    /// @param registryId_ is the id of the state registry\\n    /// @return registryAddress_ is the address of the state registry\\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\\n\\n    /// @dev gets the id of the registry\\n    /// @notice reverts if the id is not found\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return registryId_ is the id of the state registry\\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\\n\\n    /// @dev gets the safe vault limit\\n    /// @param chainId_ is the id of the remote chain\\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\\n    /// without hitting out of gas error\\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\\n\\n    /// @dev helps validate if an address is a valid state registry\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid amb implementation\\n    /// @param ambAddress_ is the address of the amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid broadcast amb implementation\\n    /// @param ambAddress_ is the address of the broadcast amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev sets the deposit rescue delay\\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\\n    function setDelay(uint256 delay_) external;\\n\\n    /// @dev sets the permit2 address\\n    /// @param permit2_ the address of the permit2 contract\\n    function setPermit2(address permit2_) external;\\n\\n    /// @dev sets the safe vault limit\\n    /// @param chainId_ is the remote chain identifier\\n    /// @param vaultLimit_ is the max limit of vaults per transaction\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\\n\\n    /// @dev sets new addresses on specific chains.\\n    /// @param ids_ are the identifiers of the address on that chain\\n    /// @param newAddresses_  are the new addresses on that chain\\n    /// @param chainIds_ are the chain ids of that chain\\n    function batchSetAddress(\\n        bytes32[] calldata ids_,\\n        address[] calldata newAddresses_,\\n        uint64[] calldata chainIds_\\n    )\\n        external;\\n\\n    /// @dev sets a new address on a specific chain.\\n    /// @param id_ the identifier of the address on that chain\\n    /// @param newAddress_ the new address on that chain\\n    /// @param chainId_ the chain id of that chain\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\\n\\n    /// @dev allows admin to set the bridge address for an bridge id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param bridgeId_         represents the bridge unique identifier.\\n    /// @param bridgeAddress_    represents the bridge address.\\n    /// @param bridgeValidator_  represents the bridge validator address.\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the amb address for an amb id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param ambId_         represents the bridge unique identifier.\\n    /// @param ambAddress_    represents the bridge address.\\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the state registry address for an state registry id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param registryId_    represents the state registry's unique identifier.\\n    /// @param registryAddress_    represents the state registry's address.\\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nlibrary Error {\\n    //////////////////////////////////////////////////////////////\\n    //                  CONFIGURATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown in protocol setup\\n\\n    /// @dev thrown if chain id exceeds max(uint64)\\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if not possible to revoke a role in broadcasting\\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n\\n    /// @dev thrown if not possible to revoke last admin\\n    error CANNOT_REVOKE_LAST_ADMIN();\\n\\n    /// @dev thrown if trying to set again pseudo immutables in super registry\\n    error DISABLED();\\n\\n    /// @dev thrown if rescue delay is not yet set for a chain\\n    error DELAY_NOT_SET();\\n\\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\\n    error INVALID_NATIVE_TOKEN_PRICE();\\n\\n    /// @dev thrown if wormhole refund chain id is not set\\n    error REFUND_CHAIN_ID_NOT_SET();\\n\\n    /// @dev thrown if wormhole relayer is not set\\n    error RELAYER_NOT_SET();\\n\\n    /// @dev thrown if a role to be revoked is not assigned\\n    error ROLE_NOT_ASSIGNED();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  AUTHORIZATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if functions cannot be called\\n\\n    /// COMMON AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if caller is not address(this), internal call\\n    error INVALID_INTERNAL_CALL();\\n\\n    /// @dev thrown if msg.sender is not a valid amb implementation\\n    error NOT_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not an allowed broadcaster\\n    error NOT_ALLOWED_BROADCASTER();\\n\\n    /// @dev thrown if msg.sender is not broadcast amb implementation\\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not broadcast state registry\\n    error NOT_BROADCAST_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not core state registry\\n    error NOT_CORE_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not emergency admin\\n    error NOT_EMERGENCY_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not emergency queue\\n    error NOT_EMERGENCY_QUEUE();\\n\\n    /// @dev thrown if msg.sender is not minter\\n    error NOT_MINTER();\\n\\n    /// @dev thrown if msg.sender is not minter state registry\\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\\n\\n    /// @dev thrown if msg.sender is not paymaster\\n    error NOT_PAYMASTER();\\n\\n    /// @dev thrown if msg.sender is not payment admin\\n    error NOT_PAYMENT_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not protocol admin\\n    error NOT_PROTOCOL_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not state registry\\n    error NOT_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not super registry\\n    error NOT_SUPER_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not superform router\\n    error NOT_SUPERFORM_ROUTER();\\n\\n    /// @dev thrown if msg.sender is not a superform\\n    error NOT_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not superform factory\\n    error NOT_SUPERFORM_FACTORY();\\n\\n    /// @dev thrown if msg.sender is not timelock form\\n    error NOT_TIMELOCK_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not timelock state registry\\n    error NOT_TIMELOCK_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not user or disputer\\n    error NOT_VALID_DISPUTER();\\n\\n    /// @dev thrown if the msg.sender is not privileged caller\\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\\n\\n    /// STATE REGISTRY AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\\n    error CALLER_NOT_ENDPOINT();\\n\\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\\n    error CALLER_NOT_MAILBOX();\\n\\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\\n    error CALLER_NOT_RELAYER();\\n\\n    /// @dev thrown if src chain sender is not valid\\n    error INVALID_SRC_SENDER();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INPUT VALIDATION ERRORS                 //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if input variables are not valid\\n\\n    /// COMMON INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if there is an array length mismatch\\n    error ARRAY_LENGTH_MISMATCH();\\n\\n    /// @dev thrown if payload id does not exist\\n    error INVALID_PAYLOAD_ID();\\n\\n    /// @dev error thrown when msg value should be zero in certain payable functions\\n    error MSG_VALUE_NOT_ZERO();\\n\\n    /// @dev thrown if amb ids length is 0\\n    error ZERO_AMB_ID_LENGTH();\\n\\n    /// @dev thrown if address input is address 0\\n    error ZERO_ADDRESS();\\n\\n    /// @dev thrown if amount input is 0\\n    error ZERO_AMOUNT();\\n\\n    /// @dev thrown if final token is address 0\\n    error ZERO_FINAL_TOKEN();\\n\\n    /// @dev thrown if value input is 0\\n    error ZERO_INPUT_VALUE();\\n\\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the vaults data is invalid\\n    error INVALID_SUPERFORMS_DATA();\\n\\n    /// @dev thrown if receiver address is not set\\n    error RECEIVER_ADDRESS_NOT_SET();\\n\\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if a form is not ERC165 compatible\\n    error ERC165_UNSUPPORTED();\\n\\n    /// @dev thrown if a form is not form interface compatible\\n    error FORM_INTERFACE_UNSUPPORTED();\\n\\n    /// @dev error thrown if form implementation address already exists\\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\\n\\n    /// @dev error thrown if form implementation id already exists\\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\\n\\n    /// @dev thrown if a form does not exist\\n    error FORM_DOES_NOT_EXIST();\\n\\n    /// @dev thrown if form id is larger than max uint16\\n    error INVALID_FORM_ID();\\n\\n    /// @dev thrown if superform not on factory\\n    error SUPERFORM_ID_NONEXISTENT();\\n\\n    /// @dev thrown if same vault and form implementation is used to create new superform\\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\\n\\n    /// FORM INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\\n    /// in case of txData, if token output of swap != vault.asset()\\n    error DIFFERENT_TOKENS();\\n\\n    /// @dev thrown if the amount in direct withdraw is not correct\\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// @dev thrown if the amount in xchain withdraw is not correct\\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if route id is blacklisted in socket\\n    error BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev thrown if route id is not blacklisted in socket\\n    error NOT_BLACKLISTED_ROUTE_ID();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is a blacklisted selector\\n    error BLACKLISTED_SELECTOR();\\n\\n    /// @dev error thrown when txData selector of lifi bridge is not a blacklisted selector\\n    error NOT_BLACKLISTED_SELECTOR();\\n\\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\\n    error INVALID_ACTION();\\n\\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\\n\\n    /// @dev thrown if index is invalid\\n    error INVALID_INDEX();\\n\\n    /// @dev thrown if the chain id in the txdata is invalid\\n    error INVALID_TXDATA_CHAIN_ID();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\\n    error INVALID_TXDATA_RECEIVER();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\\n    error INVALID_TXDATA_TOKEN();\\n\\n    /// @dev thrown if txData is not present (in case of xChain actions)\\n    error NO_TXDATA_PRESENT();\\n\\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n\\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n\\n    /// @dev thrown if keeper update final token is different than the vault underlying\\n    error INVALID_UPDATE_FINAL_TOKEN();\\n\\n    /// @dev thrown if broadcast finality for wormhole is invalid\\n    error INVALID_BROADCAST_FINALITY();\\n\\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\\n    error INVALID_BRIDGE_ID();\\n\\n    /// @dev thrown if chain id involved in xchain message is invalid\\n    error INVALID_CHAIN_ID();\\n\\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\\n    error INVALID_DST_SWAP_AMOUNT();\\n\\n    /// @dev thrown if message amb and proof amb are the same\\n    error INVALID_PROOF_BRIDGE_ID();\\n\\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\\n    error INVALID_PROOF_BRIDGE_IDS();\\n\\n    /// @dev thrown if rescue data lengths are invalid\\n    error INVALID_RESCUE_DATA();\\n\\n    /// @dev thrown if delay is invalid\\n    error INVALID_TIMELOCK_DELAY();\\n\\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\\n    error NEGATIVE_SLIPPAGE();\\n\\n    /// @dev thrown if slippage is outside of bounds\\n    error SLIPPAGE_OUT_OF_BOUNDS();\\n\\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if src senders mismatch in state sync\\n    error SRC_SENDER_MISMATCH();\\n\\n    /// @dev thrown if src tx types mismatch in state sync\\n    error SRC_TX_TYPE_MISMATCH();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  EXECUTION ERRORS                        //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown due to function execution logic\\n\\n    /// COMMON EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\\n    error DIRECT_DEPOSIT_SWAP_FAILED();\\n\\n    /// @dev thrown if payload is not unique\\n    error DUPLICATE_PAYLOAD();\\n\\n    /// @dev thrown if native tokens fail to be sent to superform contracts\\n    error FAILED_TO_SEND_NATIVE();\\n\\n    /// @dev thrown if allowance is not correct to deposit\\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\\n\\n    /// @dev thrown if contract has insufficient balance for operations\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @dev thrown if native amount is not at least equal to the amount in the request\\n    error INSUFFICIENT_NATIVE_AMOUNT();\\n\\n    /// @dev thrown if payload cannot be decoded\\n    error INVALID_PAYLOAD();\\n\\n    /// @dev thrown if payload status is invalid\\n    error INVALID_PAYLOAD_STATUS();\\n\\n    /// @dev thrown if payload type is invalid\\n    error INVALID_PAYLOAD_TYPE();\\n\\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\\n\\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\\n    error FAILED_TO_EXECUTE_TXDATA(address token);\\n\\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\\n    error INVALID_DEPOSIT_TOKEN();\\n\\n    /// STATE REGISTRY EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if bridge tokens haven't arrived to destination\\n    error BRIDGE_TOKENS_PENDING();\\n\\n    /// @dev thrown if withdrawal tx data cannot be updated\\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n\\n    /// @dev thrown if rescue passed dispute deadline\\n    error DISPUTE_TIME_ELAPSED();\\n\\n    /// @dev thrown if message failed to reach the specified level of quorum needed\\n    error INSUFFICIENT_QUORUM();\\n\\n    /// @dev thrown if broadcast payload is invalid\\n    error INVALID_BROADCAST_PAYLOAD();\\n\\n    /// @dev thrown if broadcast fee is invalid\\n    error INVALID_BROADCAST_FEE();\\n\\n    /// @dev thrown if retry fees is less than required\\n    error INVALID_RETRY_FEE();\\n\\n    /// @dev thrown if broadcast message type is wrong\\n    error INVALID_MESSAGE_TYPE();\\n\\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\\n    error INVALID_PAYLOAD_HASH();\\n\\n    /// @dev thrown if update payload function was called on a wrong payload\\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\\n\\n    /// @dev thrown if a state registry id is 0\\n    error INVALID_REGISTRY_ID();\\n\\n    /// @dev thrown if a form state registry id is 0\\n    error INVALID_FORM_REGISTRY_ID();\\n\\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\\n    error LOCKED();\\n\\n    /// @dev thrown if payload is already updated (during xChain deposits)\\n    error PAYLOAD_ALREADY_UPDATED();\\n\\n    /// @dev thrown if payload is already processed\\n    error PAYLOAD_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if payload is not in UPDATED state\\n    error PAYLOAD_NOT_UPDATED();\\n\\n    /// @dev thrown if rescue is still in timelocked state\\n    error RESCUE_LOCKED();\\n\\n    /// @dev thrown if rescue is already proposed\\n    error RESCUE_ALREADY_PROPOSED();\\n\\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\\n    error ZERO_PAYLOAD_HASH();\\n\\n    /// DST SWAPPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if process dst swap is tried for processed payload id\\n    error DST_SWAP_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if indices have duplicates\\n    error DUPLICATE_INDEX();\\n\\n    /// @dev thrown if failed dst swap is already updated\\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\\n\\n    /// @dev thrown if indices are out of bounds\\n    error INDEX_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if failed swap token amount is 0\\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\\n\\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\\n    error INVALID_INTERIM_TOKEN();\\n\\n    /// @dev thrown if dst swap output is less than minimum expected\\n    error INVALID_SWAP_OUTPUT();\\n\\n    /// FORM EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if try to forward 4626 share from the superform\\n    error CANNOT_FORWARD_4646_TOKEN();\\n\\n    /// @dev thrown in KYCDAO form if no KYC token is present\\n    error NO_VALID_KYC_TOKEN();\\n\\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\\n    error PAUSED();\\n\\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\\n    error VAULT_IMPLEMENTATION_FAILED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TOKEN_NOT_UPDATED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\\n\\n    /// @dev thrown when redeeming from vault yields zero collateral\\n    error WITHDRAW_ZERO_COLLATERAL();\\n\\n    /// PAYMENT HELPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if chainlink is reporting an improper price\\n    error CHAINLINK_MALFUNCTION();\\n\\n    /// @dev thrown if chainlink is reporting an incomplete round\\n    error CHAINLINK_INCOMPLETE_ROUND();\\n\\n    /// @dev thrown if feed decimals is not 8\\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\\n\\n    /// EMERGENCY QUEUE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if emergency withdraw is not queued\\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\\n\\n    /// @dev thrown if emergency withdraw is already processed\\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\\n\\n    /// SUPERPOSITION EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if uri cannot be updated\\n    error DYNAMIC_URI_FROZEN();\\n\\n    /// @dev thrown if tx history is not found while state sync\\n    error TX_HISTORY_NOT_FOUND();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuorumManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IQuorumManager\\n/// @dev Interface for QuorumManager\\n/// @author ZeroPoint Labs\\ninterface IQuorumManager {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                           //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when a new quorum is set for a specific chain\\n    /// @param srcChainId the chain id from which the message (payload) is sent\\n    /// @param quorum the minimum number of message bridges required for processing\\n    event QuorumSet(uint64 indexed srcChainId, uint256 indexed quorum);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the required quorum for the srcChain & dstChain\\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\\n    /// @return quorum_ the minimum number of message bridges required for processing\\n    function getRequiredMessagingQuorum(uint64 srcChainId_) external view returns (uint256 quorum_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows inheriting contracts to set the messaging quorum for a specific sender chain\\n    /// @notice quorum is the number of extra ambs a message proof must go through and be validated\\n    /// @param srcChainId_ is the chain id from which the message (payload) is sent\\n    /// @param quorum_ the minimum number of message bridges required for processing\\n    /// NOTE: overriding child contracts should handle the sender validation & setting of message quorum\\n    function setRequiredMessagingQuorum(uint64 srcChainId_, uint256 quorum_) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/ERC1155A/lib/solmate/src/\",\r\n      \"@openzeppelin/contracts/=lib/ERC1155A/lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC1155A/=lib/ERC1155A/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ERC1155A/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/ERC1155A/lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\",\r\n      \"super-vaults/=lib/super-vaults/src/\",\r\n      \"v2-core/=lib/super-vaults/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/super-vaults/lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/super-vaults/lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superRBAC_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ARRAY_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DISABLED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_REGISTRY_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_TIMELOCK_DELAY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_EMERGENCY_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PROTOCOL_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_INPUT_VALUE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"protocolAddressId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"QuorumSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"ambId_\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ambAddress_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isBroadcastAMB_\",\"type\":\"bool\"}],\"name\":\"SetAmbAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"}],\"name\":\"SetBridgeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridgeValidator\",\"type\":\"address\"}],\"name\":\"SetBridgeValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldDelay_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newDelay_\",\"type\":\"uint256\"}],\"name\":\"SetDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"permit2\",\"type\":\"address\"}],\"name\":\"SetPermit2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"registryId_\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registryAddress_\",\"type\":\"address\"}],\"name\":\"SetStateRegistryAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultLimit_\",\"type\":\"uint256\"}],\"name\":\"SetVaultLimitPerDestination\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BROADCAST_REGISTRY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BROADCAST_REGISTRY_PROCESSOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_REGISTRY_DISPUTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_REGISTRY_PROCESSOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_REGISTRY_RESCUER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_REGISTRY_UPDATER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CORE_STATE_REGISTRY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DST_SWAPPER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DST_SWAPPER_PROCESSOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_QUEUE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYLOAD_HELPER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMASTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_HELPER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERFORM_FACTORY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERFORM_RECEIVER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERFORM_ROUTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPER_POSITIONS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPER_RBAC\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK_REGISTRY_PROCESSOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK_STATE_REGISTRY\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"ambId\",\"type\":\"uint8\"}],\"name\":\"ambAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ambAddresses\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ambAddress\",\"type\":\"address\"}],\"name\":\"ambIds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"ambId\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ids_\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"newAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint64[]\",\"name\":\"chainIds_\",\"type\":\"uint64[]\"}],\"name\":\"batchSetAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"}],\"name\":\"bridgeAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"}],\"name\":\"bridgeValidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeValidator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id_\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id_\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"}],\"name\":\"getAddressByChainId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"ambId_\",\"type\":\"uint8\"}],\"name\":\"getAmbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ambAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ambAddress_\",\"type\":\"address\"}],\"name\":\"getAmbId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"ambId_\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bridgeId_\",\"type\":\"uint8\"}],\"name\":\"getBridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bridgeId_\",\"type\":\"uint8\"}],\"name\":\"getBridgeValidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeValidator_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"}],\"name\":\"getRequiredMessagingQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quorum_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"registryId_\",\"type\":\"uint8\"}],\"name\":\"getStateRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress_\",\"type\":\"address\"}],\"name\":\"getStateRegistryId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"registryId_\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"}],\"name\":\"getVaultLimitPerDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultLimitPerDestination_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"ambId\",\"type\":\"uint8\"}],\"name\":\"isBroadcastAMB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isBroadcastAMB\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ambAddress_\",\"type\":\"address\"}],\"name\":\"isValidAmbImpl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ambAddress_\",\"type\":\"address\"}],\"name\":\"isValidBroadcastAmbImpl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress_\",\"type\":\"address\"}],\"name\":\"isValidStateRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"registryId\",\"type\":\"uint8\"}],\"name\":\"registryAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newAddress_\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"ambId_\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"ambAddress_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isBroadcastAMB_\",\"type\":\"bool[]\"}],\"name\":\"setAmbAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"bridgeId_\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"bridgeAddress_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"bridgeValidator_\",\"type\":\"address[]\"}],\"name\":\"setBridgeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay_\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"permit2_\",\"type\":\"address\"}],\"name\":\"setPermit2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"quorum_\",\"type\":\"uint256\"}],\"name\":\"setRequiredMessagingQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"registryId_\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"registryAddress_\",\"type\":\"address[]\"}],\"name\":\"setStateRegistryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId_\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"vaultLimit_\",\"type\":\"uint256\"}],\"name\":\"setVaultLimitPerDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"stateRegistryIds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"registryId\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"}],\"name\":\"vaultLimitPerDestination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultLimitPerDestination\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SuperRegistry", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002e639444763e402f80a9ec9d03361be351b9d40c", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}