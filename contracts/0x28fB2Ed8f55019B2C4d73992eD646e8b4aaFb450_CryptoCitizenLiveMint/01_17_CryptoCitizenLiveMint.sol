// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import {IERC721} from '@openzeppelin/contracts/interfaces/IERC721.sol';
import {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import {IERC20} from '@openzeppelin/contracts/interfaces/IERC20.sol';
import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
import {IMinter} from './IMinter.sol';
contract CryptoCitizenLiveMint is Ownable, ReentrancyGuard
{  
    struct City
    {
        string _Name;
        uint _QRCurrentIndex;
        address _GoldenToken;
        address _ERC20;
        bytes32 _Root;
    } 

    /*-------------------*/
    /*  STATE VARIABLES  */
    /*-------------------*/

    bytes32 private immutable _MINTER_ROLE = keccak256("MINTER_ROLE");                    // Minter Role
    address private immutable _BRT_MULTISIG = 0xcff43A597911a9457071d89d2b2AC3D5b1862b86; // BRT Multisig Burn Address (mint.brightmoments.eth)
    address public _ArtBlocksMinter = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b;         // ArtBlocks Minter Contract
    uint public _CurrentCityIndex = 5;                                                    // Current City Index

    /*-------------------*/
    /*     MAPPINGS      */
    /*-------------------*/
    
    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct
    mapping(uint => mapping(address => bool)) public _RedeemedQR;        // [CityIndex][Wallet] => If User Has Redeemed QR
    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation
    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient 
    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not
    mapping(uint => mapping(uint => string)) public _Data;               // [CityIndex][TicketID] => Data For Golden Token Checkins
    mapping(uint => mapping(uint => uint)) public _MintedTokenID;        // [CityIndex][TicketID] => MintedTokenID
    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role

    /*-------------------*/
    /*      EVENTS       */
    /*-------------------*/

    /**
     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.
     **/
    event LiveMintComplete(address indexed Redeemer, uint TicketID, uint TokenID, string Data);

    /**
     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` 
     **/
    event GoldenTokenRedeemed(address indexed Redeemer, uint TicketID, string Data);

    /**
     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` 
     **/
    event QRRedeemed(address indexed Redeemer, uint TicketID, string Data);

    /**
     * @dev Emitted When `NewMinter` Is Added To BRT Minter List
     */
    event MinterAdded(address NewMinter);

    /**
     * @dev Emitted When `RemovedMinter` Is Removed From BRT Minter List
     */
    event MinterRemoved(address RemovedMinter);

    /**
     * @dev Emitted When `NewMintingAddress` Replaces `OldMintingAddress`
     */
    event ArtBlocksMintingAddressChanged(address OldMintingAddress, address NewMintingAddress);

    /**
     * @dev Emitted When `NewGTAddress` Replaces `OldGTAddress`
     */
    event GoldenTokenAddressChanged(address OldGTAddress, address NewGTAddress);

    /**
     * @dev Emitted When `NewERC20Address` Replaces `OldERC20Address`
     */
    event ERC20AddressChanged(address OldERC20Address, address NewERC20Address);

    /**
     * @dev Emitted When Merkle Root Is Changed
     */
    event MerkleRootChanged(bytes32 OldRoot, bytes32 NewRoot);
    
    /**
     * @dev Emitted When A Reservation Is Wiped
     */
    event ReservationWiped(uint TicketID, address Redeemer, string Data);

    /**
     * @dev Emitted When QR Allocations Are Overwritten
     */
    event QRAllocationsOverwritten(address[] Addresses, uint[] Amounts);

    /**
     * @dev Emitted When QR Allocations Are Incremented
     */
    event QRAllocationsIncremented(address[] Addresses, uint[] Amounts);

    /**
     * @dev Emitted When New City State Variables Are Modified 
     */
    event NewCityStarted(City);

    /*-------------------*/
    /*    CONSTRUCTOR    */
    /*-------------------*/

    constructor()
    { 
        Cities[0]._Name = "CryptoGalacticans";
        Cities[1]._Name = "CryptoVenetians";
        Cities[2]._Name = "CryptoNewYorkers";
        Cities[3]._Name = "CryptoBerliners";
        Cities[4]._Name = "CryptoLondoners";
        Cities[5] = City(
            "CryptoMexas",                             
            333,                                       
            0xE0D1Fa3fBd72db2eD179F80C0459B7dA93Fe4FE8,
            0x4b691e5C0705F0CE2688F44f5a65a82F9Cd22119,
            0xb758b036d1138a2bb39fb7c4411547cdcc531246fba01a766495e5577286d28b
        );
        Cities[6]._Name = "CryptoCitizen City #7";
        Cities[6]._GoldenToken = 0x762F5C8137C445164c53e138da33032C21F44D65;
        Cities[7]._Name = "CryptoCitizen City #8";
        Cities[7]._GoldenToken = 0x0205f9cEb478FC77E2cDB77efD27B414dD31bAE5;
        Cities[8]._Name = "CryptoCitizen City #9";
        Cities[8]._GoldenToken = 0x1b02C7f98e62dDF1aC434C372A282E862b03acC6;
        Cities[9]._Name = "CryptoCitizen City #10";
        Cities[9]._GoldenToken = 0xB8d1611bE514202b60AdfcC8910F5A963E4Eb38D;
        IERC20(Cities[_CurrentCityIndex]._ERC20).approve(
            _ArtBlocksMinter,
            0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // Maximum Approval
        ); 
        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1
        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2
        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3
        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4
        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5
        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6
        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7
        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8
        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9
        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10
        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11
        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12
        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _MINTER_ROLE; // BRT Minter #13
        Role[0x7603C5eed8e57Ad795ec5F0081eFB21d1eEBf937] = _MINTER_ROLE; // BRT Minter #14
        Role[msg.sender] = _MINTER_ROLE;
        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);
    }

    /*-------------------*/
    /*  PUBLIC FUNCTIONS */
    /*-------------------*/

    /**
     * @dev Redeems Golden Tokens & BrightLists Address To Receive CryptoCitizen
     **/
    function RedeemGT(
        uint[] calldata TicketIDs, 
        string[] calldata Data
    ) external nonReentrant {
        for(uint x; x < TicketIDs.length; x++)
        {
            require(
                IERC721(Cities[_CurrentCityIndex]._GoldenToken).ownerOf(TicketIDs[x]) == msg.sender, 
                "LiveMint: Sender Does Not Own Token With The Input Token ID"
            );
            IERC721(Cities[_CurrentCityIndex]._GoldenToken).transferFrom(msg.sender, _BRT_MULTISIG, TicketIDs[x]);
            _BrightListCitizen[_CurrentCityIndex][TicketIDs[x]] = msg.sender;
            _Data[_CurrentCityIndex][TicketIDs[x]] = Data[x];
            require(
                IERC721(Cities[_CurrentCityIndex]._GoldenToken).ownerOf(TicketIDs[x]) == _BRT_MULTISIG, 
                "LiveMint: Golden Token Redemption Failed"
            );
            emit GoldenTokenRedeemed(msg.sender, TicketIDs[x], Data[x]);
        }
    }
    
    /**
     * @dev Redeems Spot For IRL Minting
     */
    function RedeemQR(string calldata Data, bytes32[] calldata Proof) external nonReentrant 
    {
        require(readQREligibility(msg.sender, Proof), "LiveMint: User Is Not Eligible To Redeem QR");
        unchecked
        {
            if(_QRAllocation[_CurrentCityIndex][msg.sender] == 0) // User Is Able To Redeem Explicitly 1 QR Code
            {
                require(!_RedeemedQR[_CurrentCityIndex][msg.sender], "LiveMint: User Has Already Redeemed");
                _Data[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data;
                _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = msg.sender;
                emit QRRedeemed(msg.sender, Cities[_CurrentCityIndex]._QRCurrentIndex, Data);
                Cities[_CurrentCityIndex]._QRCurrentIndex++; 
            }
            else // User Is Able To Redeem More Than 1 QR Code Because Their Integer Allocation > 0
            {
                uint _Allocation = _QRAllocation[_CurrentCityIndex][msg.sender];
                uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;
                uint _Limit = _Allocation + _CurrentQR;
                _QRAllocation[_CurrentCityIndex][msg.sender] = 0;
                Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;
                for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)
                {
                    _Data[_CurrentCityIndex][_CurrentQR] = Data;
                    _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = msg.sender;
                    emit QRRedeemed(msg.sender, _CurrentQR, Data);
                }
            }
            _RedeemedQR[_CurrentCityIndex][msg.sender] = true;
        } 
    }

    /*-------------------*/
    /*     BRT STAFF     */
    /*-------------------*/

    /*-----------------------
     * CITIZEN LIVE MINTING *
    -------------------------/

    /**
     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens
     */
    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter
    {
        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)
        {
            address Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];
            require(Recipient != address(0), "LiveMint: Golden Token Entered Is Not Brightlisted");
            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], "LiveMint: Golden Token Already Minted");
            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;
            uint TokenID = IMinter(_ArtBlocksMinter).purchaseTo(Recipient, _CurrentCityIndex);
            _MintedTokenID[_CurrentCityIndex][TicketIDs[TicketID]] = TokenID;
            emit LiveMintComplete(Recipient, TicketIDs[TicketID], TokenID, _Data[_CurrentCityIndex][TicketIDs[TicketID]]); 
        }
    }

    /*-------------------*/
    /*  OWNER FUNCTIONS  */
    /*-------------------*/

    /**
     * @dev Batch Approves BRT For Purchasing
     */
    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators, uint[] calldata Amounts) external onlyOwner
    {
        require(ERC20s.length == Operators.length && Operators.length == Amounts.length, "LiveMint: Arrays Must Be Equal Length");
        for(uint i; i < ERC20s.length; i++)
        {
            IERC20(ERC20s[i]).approve(Operators[i], Amounts[i]);
        }
    }

    /**
     * @dev Grants Address BRT Minter Role
     **/
    function __MinterAdd(address Minter) external onlyOwner 
    { 
        Role[Minter] = _MINTER_ROLE; 
        emit MinterAdded(Minter);
    }

    /**
     * @dev Deactivates Address From BRT Minter Role
     **/
    function __MinterRemove(address Minter) external onlyOwner 
    { 
        Role[Minter] = 0x0; 
        emit MinterRemoved(Minter);
    }

    /**
     * @dev Wipes Reservation If Someone Mistakenly Burns GT
     */
    function __WipeReservationGT(uint TicketID) external onlyOwner
    {
        string memory Data = _Data[_CurrentCityIndex][TicketID];
        address Redeemer = _BrightListCitizen[_CurrentCityIndex][TicketID];
        _Data[_CurrentCityIndex][TicketID] = "";
        _BrightListCitizen[_CurrentCityIndex][TicketID] = address(0);
        IERC721(Cities[_CurrentCityIndex]._GoldenToken).transferFrom(
            _BRT_MULTISIG, 
            Redeemer, 
            TicketID
        );
        emit ReservationWiped(TicketID, Redeemer, Data);
    }

    /**
     * @dev Modifies ArtBlocks Minting Address Citizens
     */
    function __ChangeArtBlocksMintingAddress(address NewMintingAddress) external onlyOwner
    {
        address OldMintingAddress = _ArtBlocksMinter;
        _ArtBlocksMinter = NewMintingAddress;
        emit ArtBlocksMintingAddressChanged(OldMintingAddress, _ArtBlocksMinter);
    }

    /**
     * @dev Modifies Golden Token Address
     */
    function __ChangeGoldenTokenAddress(address NewGTAddress) external onlyOwner
    {
        address OldAddress = Cities[_CurrentCityIndex]._GoldenToken;
        Cities[_CurrentCityIndex]._GoldenToken = NewGTAddress;
        emit GoldenTokenAddressChanged(OldAddress, Cities[_CurrentCityIndex]._GoldenToken);
    }

    /**
     * @dev Modifies ERC20 BRT Minting Token Address
     */
    function __ChangeERC20Address(address NewERC20Address) external onlyOwner
    {
        address OldAddress = Cities[_CurrentCityIndex]._ERC20;
        Cities[_CurrentCityIndex]._ERC20 = NewERC20Address;
        emit ERC20AddressChanged(OldAddress, Cities[_CurrentCityIndex]._ERC20);
    }

    /**
     * @dev Changes QR Current Index
     */
    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }

    /**
     * @dev Changes Merkle Root
     */
    function __ChangeRoot(bytes32 NewRoot) external onlyOwner
    {
        bytes32 OldRoot = Cities[_CurrentCityIndex]._Root;
        Cities[_CurrentCityIndex]._Root = NewRoot;
        emit MerkleRootChanged(OldRoot, NewRoot);
    }

    /**
     * @dev Overwrites QR Allocation
     */
    function __OverwriteQRAllocations(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMint: Input Arrays Must Match");
        for(uint x; x < Addresses.length; x++)
        {
            _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x];
        }
        emit QRAllocationsOverwritten(Addresses, Amounts);
    }

    /**
     * @dev Increments QR Allocations
     */
    function __IncrementQRAllocations(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner
    {
        require(Addresses.length == Amounts.length, "LiveMint: Input Arrays Must Match");
        for(uint x; x < Addresses.length; x++)
        {
            _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x];
        }
        emit QRAllocationsIncremented(Addresses, Amounts);
    }

    /**
     * @dev Instantiates New City
     * note: CityIndex Always Corresponds To ArtBlocks ProjectID
     * note: QRCurrentIndex Should Typically Always Equal 333 
     */
    function __NewCity(
        string calldata Name,
        uint CityIndex,
        uint QRCurrentIndex,
        address ERC20Token,
        address GoldenTokenAddress
    ) external onlyOwner {
        _CurrentCityIndex = CityIndex;
        Cities[CityIndex]._Name = Name;
        Cities[CityIndex]._ERC20 = ERC20Token;
        Cities[CityIndex]._GoldenToken = GoldenTokenAddress;
        Cities[CityIndex]._QRCurrentIndex = QRCurrentIndex;
        IERC20(ERC20Token).approve(
            _ArtBlocksMinter, 
            0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        );
        emit NewCityStarted(Cities[CityIndex]);
    }

    /**
     * @dev Instantiates A New City
     */
    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }

    /**
     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig
     **/
    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws ERC20 Tokens to Multisig
     **/
    function __WithdrawERC20(address TokenAddress) external onlyOwner 
    { 
        IERC20 erc20Token = IERC20(TokenAddress);
        uint balance = erc20Token.balanceOf(address(this));
        require(balance > 0, "0 ERC20 Balance At `TokenAddress`");
        erc20Token.transfer(msg.sender, balance);
    }

    /**
     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.
     */
    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner
    {
        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);
    }
    
    /*-------------------*/
    /*    PUBLIC VIEW    */
    /*-------------------*/

    /**
     * @dev Returns If User Is Eligible To Redeem QR Code
     */
    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);
        if(
            (BrightListEligible && !_RedeemedQR[_CurrentCityIndex][Recipient])
            || 
            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)
        ) { return true; }
        else { return false; }
    }

    /**
     * @dev Returns An Array Of Unminted Golden Tokens
     */
    function readUnmintedGoldenTokens() public view returns(uint[] memory)
    {
        uint[] memory UnmintedTokenIDs = new uint[](1000);
        uint Counter;
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            if(
                !_MintedCitizen[_CurrentCityIndex][TokenID]
                &&
                _BrightListCitizen[_CurrentCityIndex][TokenID] != address(0)
            ) 
            { 
                UnmintedTokenIDs[Counter] = TokenID; 
                Counter++;
            }
        }
        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);
        uint Found;
        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)
        {
            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))
            {
                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];
                Found++;
            }
        }
        return FormattedUnMintedTokenIDs;
    }

    /**
     * @dev Returns An Array Of Unminted Golden Tokens
     */
    function readMintedGoldenTokens() public view returns(uint[] memory)
    {
        uint[] memory MintedTokenIDs = new uint[](1000);
        uint Counter;
        for(uint TokenID; TokenID < 1000; TokenID++)
        {
            if(_MintedCitizen[_CurrentCityIndex][TokenID]) 
            { 
                MintedTokenIDs[Counter] = TokenID; 
                Counter++;
            }
        }
        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);
        uint Found;
        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)
        {
            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))
            {
                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];
                Found++;
            }
        }
        return FormattedMintedTokenIDs;
    }

    /**
     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs
     */
    function readCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)
    {
        uint[] memory _TokenIDs = new uint[](1000);
        uint Counter;
        for(uint TicketID; TicketID < 1000; TicketID++)
        {
            if(_BrightListCitizen[_CurrentCityIndex][TicketID] != address(0)) 
            { 
                _TokenIDs[Counter] = TicketID; 
                Counter++;
            }
        }
        uint[] memory FormattedCheckedInTickets = new uint[](Counter);
        uint Found;
        for(uint x; x < Counter; x++)
        {
            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))
            {
                FormattedCheckedInTickets[Found] = _TokenIDs[x];
                Found++;
            }
        }
        return FormattedCheckedInTickets;
    }

    /**
     * @dev Returns Original Recipients Of Citizens
     */
    function readBrightList(uint CityIndex) public view returns(address[] memory Recipients)
    {
        address[] memory _Recipients = new address[](1000);
        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][x]; }
        return _Recipients;
    }

    /**
     * @dev Returns The City Struct At `CityIndex`
     */
    function readCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }

    /*------------------*/
    /*     MODIFIERS    */
    /*------------------*/

    /**
     * @dev Function Modifier That Allows Only BrightListed BRT Minters To Access
     **/
    modifier onlyMinter() 
    {
        require(Role[msg.sender] == _MINTER_ROLE, "OnlyMinter: Caller Is Not Approved BRT Minter");
        _;
    }
}