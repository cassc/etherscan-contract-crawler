{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/NounsRaffle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface ILightClient {\\n    function head() external view returns (uint256);\\n\\n    function headers(uint256 slot) external view returns (bytes32);\\n}\\n\\ninterface ISuccinctGateway {\\n    function requestCallback(\\n        bytes32 _functionId,\\n        bytes memory _input,\\n        bytes memory _context,\\n        bytes4 _callbackSelector,\\n        uint32 _callbackGasLimit\\n    ) external payable returns (bytes32);\\n\\n    function requestCall(\\n        bytes32 _functionId,\\n        bytes memory _input,\\n        address _address,\\n        bytes memory _data,\\n        uint32 _gasLimit\\n    ) external payable;\\n\\n    function verifiedCall(\\n        bytes32 _functionId,\\n        bytes memory _input\\n    ) external view returns (bytes memory);\\n\\n    function isCallback() external view returns (bool);\\n}\\n\\ncontract NounsRaffle {\\n    /// @notice Number of blocks iterated over per proof.\\n    uint64 public constant NB_BLOCKS_PER_PROOF = 262144;\\n\\n    /// @notice Callback gas limit.\\n    uint32 public constant CALLBACK_GAS_LIMIT = 2000000;\\n\\n    /// @notice The address of the gateway.\\n    address public gateway;\\n\\n    /// @notice The function id of the oracle.\\n    bytes32 public functionId;\\n\\n    /// @notice Payout amount for prize.\\n    uint256 public payoutAmount;\\n\\n    /// @notice The light client.\\n    ILightClient public lightClient;\\n\\n    /// @notice The owner of the contract.\\n    address payable public owner;\\n\\n    /// @notice The prover.\\n    address public prover;\\n\\n    /// @notice Whether the n'th raffle is completed.\\n    mapping(uint64 => bool) public raffleCompleted;\\n\\n    /// @notice The reentrancy status of the contract.\\n    bool internal locked;\\n\\n    /// @notice The raffle bounds.\\n    uint64[19] public raffleBounds = [\\n        6123599,\\n        6339599,\\n        6562799,\\n        6778799,\\n        7001999,\\n        7225199,\\n        7441199,\\n        7664399,\\n        7880399,\\n        8103599,\\n        8326799,\\n        8535599,\\n        8758799,\\n        8974799,\\n        9197999,\\n        9413999,\\n        9637199,\\n        9860399,\\n        10076399\\n    ];\\n\\n    event RaffleRequest(uint64 indexed raffleIdx);\\n    event RaffleWinnerSkipped(\\n        uint64 indexed raffleIdx,\\n        uint256 indexed i,\\n        bytes32 indexed withdrawalAddress\\n    );\\n    event RaffleWinner(\\n        uint64 indexed raffleIdx,\\n        uint256 indexed i,\\n        bytes32 indexed withdrawalAddress\\n    );\\n    event RaffleFulfilled(uint64 indexed raffleIdx);\\n\\n    constructor(\\n        address _gateway,\\n        bytes32 _functionId,\\n        address _lightClient,\\n        address _owner,\\n        address _prover,\\n        uint256 _payoutAmount\\n    ) {\\n        gateway = _gateway;\\n        functionId = _functionId;\\n        lightClient = ILightClient(_lightClient);\\n        owner = payable(_owner);\\n        prover = _prover;\\n        payoutAmount = _payoutAmount;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not the contract owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyProver() {\\n        require(msg.sender == prover, \\\"Not the contract prover\\\");\\n        _;\\n    }\\n\\n    modifier noReentrant() {\\n        require(!locked, \\\"No re-entrancy\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    function readBytes32Array(\\n        bytes memory input\\n    ) public pure returns (bytes32[10] memory) {\\n        require(input.length == 320, \\\"Input must be 320 bytes in length\\\");\\n        bytes32[10] memory output;\\n        assembly {\\n            mstore(add(output, 0), mload(add(input, 32)))\\n            mstore(add(output, 32), mload(add(input, 64)))\\n            mstore(add(output, 64), mload(add(input, 96)))\\n            mstore(add(output, 96), mload(add(input, 128)))\\n            mstore(add(output, 128), mload(add(input, 160)))\\n            mstore(add(output, 160), mload(add(input, 192)))\\n            mstore(add(output, 192), mload(add(input, 224)))\\n            mstore(add(output, 224), mload(add(input, 256)))\\n            mstore(add(output, 256), mload(add(input, 288)))\\n            mstore(add(output, 288), mload(add(input, 320)))\\n        }\\n        return output;\\n    }\\n\\n    function startRaffle(\\n        uint64 raffleIdx,\\n        uint64 targetSlot\\n    ) external onlyProver {\\n        // Check that the raffle is not completed.\\n        require(\\n            !raffleCompleted[raffleIdx],\\n            \\\"NounsRaffle: raffle already completed\\\"\\n        );\\n\\n        // Grab the start and end slots for the raffle.\\n        uint64 startSlot = raffleBounds[raffleIdx];\\n        uint64 endSlot = raffleBounds[raffleIdx + 1];\\n        require(\\n            targetSlot - startSlot < NB_BLOCKS_PER_PROOF,\\n            \\\"NounsRaffle: target slot out of range\\\"\\n        );\\n\\n        // In the future, we will grab the latest head from the light client using the code below.\\n        uint256 head = lightClient.head();\\n        bytes32 blockRoot = lightClient.headers(head);\\n        require(blockRoot != bytes32(0), \\\"NounsRaffle: block root is zero\\\");\\n        require(head >= endSlot, \\\"NounsRaffle: head is before end slot\\\");\\n\\n        // Compute pseudorandomness. We use the block hash of the previous block as the seed. This\\n        // is sufficient for our purposes, since we can assume the requester is not adversarial.\\n        //\\n        // Gamma is a random element of the cubic extension defined over the Goldilocks field.\\n        bytes32 seed = keccak256(abi.encode(blockhash(block.number - 1)));\\n        uint64 gammaA = uint64(uint256(seed)) % 18446744069414584321;\\n        seed = keccak256(abi.encode(seed));\\n        uint64 gammaB = uint64(uint256(seed)) % 18446744069414584321;\\n        seed = keccak256(abi.encode(seed));\\n        uint64 gammaC = uint64(uint256(seed)) % 18446744069414584321;\\n        seed = keccak256(abi.encode(seed));\\n        uint32 shuffleSeed = uint32(uint256(seed));\\n\\n        // Request for the proof and callback.\\n        ISuccinctGateway(gateway).requestCallback(\\n            functionId,\\n            abi.encodePacked(\\n                startSlot,\\n                endSlot,\\n                targetSlot,\\n                blockRoot,\\n                gammaA,\\n                gammaB,\\n                gammaC,\\n                shuffleSeed\\n            ),\\n            abi.encode(raffleIdx),\\n            this.endRaffle.selector,\\n            CALLBACK_GAS_LIMIT\\n        );\\n\\n        emit RaffleRequest(raffleIdx);\\n    }\\n\\n    function endRaffle(\\n        bytes memory output,\\n        bytes memory context\\n    ) public noReentrant {\\n        // Check that the callback is coming from the gateway.\\n        require(\\n            tx.origin == prover,\\n            \\\"NounsRaffle: proof not from approved prover\\\"\\n        );\\n        require(\\n            msg.sender == gateway && ISuccinctGateway(gateway).isCallback()\\n        );\\n\\n        // Decode the context and check that the raffle is not yet completed.\\n        uint64 raffleIdx = abi.decode(context, (uint64));\\n        require(!raffleCompleted[raffleIdx]);\\n        raffleCompleted[raffleIdx] = true;\\n\\n        // The withdrawal address of the winners.\\n        bytes32[10] memory winners = readBytes32Array(output);\\n\\n        // Distribute funds.\\n        require(\\n            winners.length * payoutAmount <= address(this).balance,\\n            \\\"NounsRaffle: not enough funds\\\"\\n        );\\n        for (uint256 i = 0; i < winners.length; i++) {\\n            bytes20 withdrawalAddressBytes = bytes20(winners[i] << 96);\\n            address withdrawalAddress = address(\\n                uint160(withdrawalAddressBytes)\\n            );\\n            if (winners[i] != bytes32(0)) {\\n                (bool success, ) = withdrawalAddress.call{value: payoutAmount}(\\n                    \\\"\\\"\\n                );\\n                if (!success) {\\n                    emit RaffleWinnerSkipped(raffleIdx, i, winners[i]);\\n                } else {\\n                    emit RaffleWinner(raffleIdx, i, winners[i]);\\n                }\\n            }\\n        }\\n\\n        emit RaffleFulfilled(raffleIdx);\\n    }\\n\\n    /// @notice Restore funds to the owner in case of issue.\\n    function emergency() external onlyOwner {\\n        address safe = 0x3200A7c6467F66734B1DE7aC2dAA4365cFDBcCf8;\\n        (bool success, ) = safe.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"NounsRaffle: emergency failed\\\");\\n    }\\n\\n    function upgradeGateway(address _gateway) external onlyOwner {\\n        gateway = _gateway;\\n    }\\n\\n    function upgradeFunctionId(bytes32 _functionId) external onlyOwner {\\n        functionId = _functionId;\\n    }\\n\\n    function upgradeLightClient(address _lightClient) external onlyOwner {\\n        lightClient = ILightClient(_lightClient);\\n    }\\n\\n    function restartRaffle(uint64 raffleIdx) external onlyOwner {\\n        raffleCompleted[raffleIdx] = false;\\n    }\\n\\n    function updatePayoutAmount(uint256 _payoutAmount) external onlyOwner {\\n        payoutAmount = _payoutAmount;\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_functionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_prover\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_payoutAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"}],\"name\":\"RaffleFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"}],\"name\":\"RaffleRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalAddress\",\"type\":\"bytes32\"}],\"name\":\"RaffleWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalAddress\",\"type\":\"bytes32\"}],\"name\":\"RaffleWinnerSkipped\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CALLBACK_GAS_LIMIT\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NB_BLOCKS_PER_PROOF\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"output\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"endRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"functionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightClient\",\"outputs\":[{\"internalType\":\"contract ILightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raffleBounds\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"raffleCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"readBytes32Array\",\"outputs\":[{\"internalType\":\"bytes32[10]\",\"name\":\"\",\"type\":\"bytes32[10]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"}],\"name\":\"restartRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"raffleIdx\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetSlot\",\"type\":\"uint64\"}],\"name\":\"startRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_payoutAmount\",\"type\":\"uint256\"}],\"name\":\"updatePayoutAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_functionId\",\"type\":\"bytes32\"}],\"name\":\"upgradeFunctionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"}],\"name\":\"upgradeGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lightClient\",\"type\":\"address\"}],\"name\":\"upgradeLightClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NounsRaffle", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006e4f1e9ea315ebfd69d18c2db974eef6105fb80364699cf367ef7ad72dad20aea6bb68a7624e8aef7e8e3c96e675020a398275f000000000000000000000000053fd3133bef76dda3ca18fb24769ebe59e28bb24000000000000000000000000c5d0ff59ff452668080b1f0385bd90b86195efdd000000000000000000000000ded0000e32f8f40414d3ab3a830f735a3553e18e0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}