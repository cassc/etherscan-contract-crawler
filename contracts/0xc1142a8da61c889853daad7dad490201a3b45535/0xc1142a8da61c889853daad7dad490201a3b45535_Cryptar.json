{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Cryptar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n//                                                                                                                    //\\n//                                                @@@@@@@@@@@@@@@@@@@@                                                //\\n//                                             @@@@@@@@@@@@@@@@@@@@@@@@@@                                             //\\n//                                         @@@@@@@@@@              @@@@@@@@@@                                         //\\n//                                      @@@@@@@@@                     @@@@@@@@@@                                      //\\n//                                   @@@@@@@@                        @@@@@@@@@@@@@@                                   //\\n//                                 @@@@@@@                         @@@@@@@@@@ @@@@@@                                  //\\n//                                  @@@@   @@@                           @@@@ @@@@@@                                  //\\n//                                  @@@@   @@@@@@@@@@@            @@@@@@@@@@@ @@@@@@                                  //\\n//                                  @@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@                                  //\\n//                                   @@@@  @@@@@    @@@@@@@@@@@@@@@@@@@ @@@@@ @@@@@                                   //\\n//                                   @@@@  @@@@@           @@@     @@@@ @@@@@  @@@@                                   //\\n//                                   @@@@  @@@@@           @@      @@@@ @@@@@ @@@@@                                   //\\n//                                   @@@@@  @@@@           @@      @@@@ @@@@@ @@@@@                                   //\\n//                                  @@@@@@  @@@@           @@     @@@@ @@@@@@ @@@@@@                                  //\\n//                                  @@@@@@  @@@@@          @@     @@@@ @@@@@  @@@@@@                                  //\\n//                                 @@@@@@@  @@@@@          @@     @@@@ @@@@@  @@ @@@@                                 //\\n//                                 @@@@ @@  @@@@@    @@@   @@   @@@@@@ @@@@@  @@ @@@@                                 //\\n//                      @@@       @@@@@  @  @@@@@@   @@@   @@   @@@@@ @@@@@@  @  @@@@@       @@@                      //\\n//                     @@@@@      @@@@   @  @@@@@@         @@     @@@ @@@@@@ @@   @@@@      @@@@@                     //\\n//                   @@@@@@@@@   @@@@@    @ @@@@@@               @@@@ @@@@@@ @    @@@@@   @@@@@@@@@                   //\\n//                     @@@@      @@@@       @@@@@@@              @@@@@@@@@@@       @@@@      @@@@                     //\\n//                      @@      @@@@@       @@@@@@@              @@@ @@@@@@@       @@@@@      @@                      //\\n//              @@               @@@@@       @@@@@@              @@@ @@@@@@       @@@@@               @@              //\\n//             @@@@    @@         @@@@@@     @@@@@@@@            @@ @@@@@@@     @@@@@@         @@    @@@@             //\\n//            @@@@@@  @@@@          @@@@@     @@@@@@@@          @ @@@@@@@@     @@@@@          @@@@  @@@@@@            //\\n//              @@@    @@            @@@@@    @@@@@@@@@          @@@@@@@@     @@@@@            @@    @@@              //\\n//               @@             @@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@             @@               //\\n//                          @@@@@@@@@@  @@@@    @@@@@@@@@@@@@@@@@@@@@@@@    @@@@   @@@@@@@@@                          //\\n//                     @@@@@@@@@@        @@@@@   @@@@@@@@@@@@@@@@@@@@@@@  @@@@@        @@@@@@@@@@                     //\\n//                @@@@@@@@@@              @@@@@  @@@@@@@@@@@@@@@@@@@@@@  @@@@@     @        @@@@@@@@@@                //\\n//            @@@@@@@@@               @@    @@@@  @@@@@@@@@@@@@@@@@@@@  @@@@    @@@@             @@@@@@@@@            //\\n//          @@@@@@@   @@@      @@@@   @@@@   @@@@  @@@@@@@@  @@@@@@@@  @@@@   @@@@@   @@@      @@@   @@@@@@@          //\\n//        @@@@@@@@@@   @@@      @@@@   @@@@@  @@@@ @@@@@@      @@@@@@ @@@@  @@@@@@@  @@@@     @@@@  @@@@@@@@@@        //\\n//      @@@@@@@@@@@@@  @@@@     @@@@@  @@@@@@@ @@@@@@@@@        @@@@@@@@  @@@@@@@@  @@@@     @@@@  @@@@@@@@@@@@@      //\\n//    @@@@@@@@@@@@@@@@@ @@@@     @@@@@  @@@@@@@@@@@@@@@@ @    @ @@@@@@@@@@@@@@@@@ @@@@@    @@@@ @@@@@@@@@@@@@@@@@    //\\n//     @@@@@@@@@@@@@@@@@ @@@@    @@@@@@ @@@@@@@@@@@@@@@@@  @@  @@@@@@@@@@@@@@@@@@ @@@@@    @@@@ @@@@@@@@@@@@@@@@@     //\\n//       @@@@@@     @@@@@ @@@     @@@@@@ @@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@ @@@@@     @@@ @@@@@      @@@@@       //\\n//        @@@@@@@@@@@@@@@@ @@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@ @@@@@@@@@@@@@@@@        //\\n//         @@@@@@@@@@@@@@@@ @@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@ @@@@@@@@@@@@@@@@         //\\n//         @@@        @@@@@@@@@@   @@@@@@@@@@@@@@@@#                @@@@@@@@@@@@@@@@@   @@@@@@@@@@        @@@         //\\n//         @@@@   @@@@@@@@@@@@@@@   @@@@@@@@@@@@           @@@@@@      @@@@@@@@@@@@@   @@@@@@@@@@@@@@@   @@@@         //\\n//         @@@@   @@@@@@@@@@@@@@@@  @@@@@@@@@@                   @@@@     @@@@@@@@@@  @@@@@@@@@@@@@@@@   @@@@         //\\n//  @@@   @@@@@@  @@@@@@@@@@@@@@@@@  @@@@@@@                          @@@   @@@@@@@  @@@@@@@@@@@@@@@@@  @@@@@@   @@@  //\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@    @@                      @@@   @@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //\\n// @@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@                           @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@ @@@ @@@@ //\\n//  @@@  @@  @@@@@@@@@@@@@@@   @@@@@@@@@       @@                         @@@  @@@@@@@@@@   @@@@@@@@@@@@@@@  @@  @@@  //\\n//  @@@  @@@@@   @@@@@@@@@@    @@@@@@@@@                                   @@@  @@@@@@@@@    @@@@@@@@@@   @@@@@ @@@@  //\\n//   @@@@@ @@@@@@@@@@@@@@@@    @@@@@@@@                                     @@   @@@@@@@@    @@@@@@@@@@@@@@@@ @@@@@   //\\n//   @@@@    @@@@    @@@@@    @@@@@@@@@                                     @@@  @@@@@@@@@    @@@@@    @@@@    @@@    //\\n//    @@@@  @@@       @@@@@@@@@@@@@@@@@   @@                                 @@  @@@@@@@@@@@@@@@@@       @@@  @@@@    //\\n//    @@@@@@@@        @@@@@@@@@@@@@@@@                                       @@   @@@@@@@@@@@@@@@@        @@@@@@@@    //\\n//   @@@@@@@@@@@     @@@@    @@@@@@@@@@                                      @@  @@@@@@@@@@    @@@      @@@@@@@@@@@   //\\n//    @@@   @@@@@@   @@@     @@@@@@@@@@                                     @@   @@@@@@@@@@     @@@   @@@@@@   @@@    //\\n//     @@@   @@@@@   @@      @@@@@@@@@@                                     @@   @@@@@@@@@@      @@   @@@@@   @@@     //\\n//     @@@@  @@@@@@@ @@@    @@@@@@@@@@@@                                   @@   @@@@@@@@@@@@    @@@ @@@@@@@  @@@@     //\\n//      @@@@@@@   @@@ @@   @@@@@@@@@@@@@                                  @@   @@@@@@@@@@@@@@  @@@ @@@   @@@@@@@      //\\n//       @@@@@@@   @@  @@@@@@@@@@@  @@@@@@                                    @@@@@@  @@@@@@@@@@@  @@@  @@@@@@@       //\\n//        @@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@                                  @@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@         //\\n//         @@@ @@@@@@@@@@@@@ @@@@@@ @@@@@@@@             @@@@@@@           @@@@@@@@@ @@@@@@@@@@@@@@@@@@@@ @@@         //\\n//         @@@  @@@@@@@@@@@@@@@@@@@ @@@@@@@@@@      @@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@         //\\n//         @@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@         //\\n//         @@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@         //\\n//         @@@  @@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@  @@@         //\\n//         @@@  @@@@@@   @@@          @@@@@@@@@@                   @@@@@@@@@@@@@@@          @@@   @@@@@@  @@@         //\\n//         @@@  @@@@@@   @@@       @@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     @@@      @@@   @@@@@@  @@@         //\\n//         @@@@ @@@      @@@       @@ @@      @@@@                    @@@@      @@ @@       @@@      @@@ @@@@         //\\n//          @@@@@@@      @@@        @@@@ @@@   @@@@@@@@@@@@@@@@@@@@@@@@@@   @@@ @@@@        @@@      @@@@@@@          //\\n//            @@@@@       @            @@@     @@@@       @@   @@@@@@@@@@    @@@             @       @@@@@            //\\n//             @@@@      @@@          @@@    @@@@@         @@@@@@@@@@@@@@@@   @@@           @@@      @@@@             //\\n//              @@@       @                 @@@@             @@@@@@@@@@@@@@@                 @       @@@              //\\n//               @@                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                         @@               //\\n//                                         @@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@                                          //\\n//                                         @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@                                          //\\n//                                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                           //\\n//                                                                                                                    //\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n// 8\\\"\\\"\\\"\\\"8   8\\\"\\\"\\\"8    8    8   8\\\"\\\"\\\"\\\"8  \\\"\\\"8\\\"\\\"   8\\\"\\\"\\\"\\\"8   8\\\"\\\"\\\"8       8\\\"\\\"\\\"\\\"8   8\\\"\\\"\\\"\\\"8   8\\\"\\\"\\\"\\\"   8\\\"\\\"\\\"\\\"8   8   8    8\\\"\\\"\\\"\\\"8 //\\n// 8    \\\"   8   8    8    8   8    8    8     8    8   8   8       8        8    8   8       8    8   8   8    8      //\\n// 8e       8eee8e   8eeee8   8eeee8    8e    8eeee8   8eee8e      8eeeee   8eeee8   8eeee   8eeee8   8eee8e   8eeeee //\\n// 88       88   8     88     88        88    88   8   88   8          88   88       88      88   8   88   8       88 //\\n// 88   e   88   8     88     88        88    88   8   88   8      e   88   88       88      88   8   88   8   e   88 //\\n// 88eee8   88   8     88     88        88    88   8   88   8      8eee88   88       88eee   88   8   88   8   8eee88 //\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\npragma solidity ^0.8.23;\\n\\nimport {ERC721PsiBurnable, ERC721Psi} from \\\"./external/ERC721Psi/extension/ERC721PsiBurnable.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {Base64} from \\\"solady/src/utils/Base64.sol\\\";\\nimport {LibPRNG} from \\\"solady/src/utils/LibPRNG.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/src/utils/SafeTransferLib.sol\\\";\\nimport {FortuneCard, IFortuneCard} from \\\"./FortuneCard.sol\\\";\\nimport {FortuneTeller, IFortuneTeller} from \\\"./FortuneTeller.sol\\\";\\nimport \\\"./Fortune.sol\\\";\\n\\n/// VERSION: 1.0.0\\ncontract Cryptar is\\nERC721PsiBurnable,\\nReentrancyGuard,\\nOwnable\\n{\\n    using LibPRNG for LibPRNG.PRNG;\\n    using SafeTransferLib for address payable;\\n    using LibString for uint256;\\n    using LibString for int256;\\n    using LibString for string;\\n    using Base64 for string;\\n    using Fortune for uint256;\\n    using Fortune for int256;\\n\\n    int256 private constant GRADIENT_MAX = 250;\\n    int256 private constant GRADIENT_MIN = -250;\\n\\n    uint256 public tokenPrice;\\n\\n    mapping(uint256 => uint256) private _fortunes;\\n    mapping(uint256 => uint256) private _curses;\\n    uint256 private _totalCurses = 1;\\n    address payable private _teamAddress;\\n    IFortuneTeller private _fortuneTeller;\\n    IFortuneCard   private _fortuneCard;\\n\\n    error ErrorInvalidToken();\\n    error ErrorMintTxPrice();\\n    error ErrorBurnTxPrice();\\n\\n    event CryptarSpeaks(address indexed owner, uint256 indexed fortuneId);\\n    event CryptarCursesYou(address indexed owner, uint256 indexed fortuneId, uint256 indexed curseId);\\n\\n    constructor(\\n        uint256 _price,\\n        address payable _team,\\n        address _card,\\n        address _teller\\n    )\\n    ERC721Psi(\\\"Cryptar\\\", \\\"CRYPT\\\")\\n    Ownable(msg.sender)\\n    {\\n        tokenPrice = _price;\\n        _teamAddress = _team;\\n        _fortuneCard = IFortuneCard(_card);\\n        _fortuneTeller = IFortuneTeller(_teller);\\n        _mint(msg.sender, 1);\\n    }\\n\\n    function setFortuneCard(\\n        address delegate\\n    ) external onlyOwner {\\n        _fortuneCard = IFortuneCard(delegate);\\n    }\\n\\n    function setFortuneTeller(\\n        address delegate\\n    ) external onlyOwner {\\n        _fortuneTeller = IFortuneTeller(delegate);\\n    }\\n\\n    function setTeamAddress(\\n        address payable teamAddress\\n    ) external onlyOwner {\\n        _teamAddress = teamAddress;\\n    }\\n\\n    function setTokenPrice(\\n        uint256 _tokenPrice\\n    ) external onlyOwner {\\n        tokenPrice = _tokenPrice;\\n    }\\n\\n    function mint(\\n    ) external payable nonReentrant {\\n        if (msg.value < tokenPrice) revert ErrorMintTxPrice();\\n        uint256 fortuneId = _nextTokenId();\\n        _fortunes[fortuneId] = _makePrediction(fortuneId);\\n        _mint(msg.sender, 1);\\n        emit CryptarSpeaks(msg.sender, fortuneId);\\n    }\\n\\n    function burn(\\n        uint256 fortuneId\\n    ) external payable nonReentrant {\\n        if (msg.value < tokenPrice) revert ErrorBurnTxPrice();\\n        if (!_exists(fortuneId)) revert ErrorInvalidToken();\\n        uint256 curseId = _nextTokenId();\\n        unchecked { _curses[curseId] = (_totalCurses++ << CURSE_OFFSET) | _makePrediction(fortuneId); }\\n        _burn(fortuneId);\\n        _mint(msg.sender, 1);\\n        emit CryptarCursesYou(msg.sender, fortuneId, curseId);\\n    }\\n\\n    function withdraw(\\n    ) external nonReentrant {\\n        _teamAddress.safeTransferAllETH();\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) override public view returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        return (_isCursed(tokenId)) ? _cursedURI(tokenId) : _fortuneURI(tokenId);\\n    }\\n\\n    function _isCursed(uint256 tokenId) internal view virtual returns (bool){\\n        return _curses[tokenId] != 0;\\n    }\\n\\n    function _fortuneURI(\\n        uint256 tokenId\\n    ) internal view returns (string memory) {\\n        uint256 data = _fortunes[tokenId];\\n        string[] memory fortune = _fortuneTeller.revealFortune(data);\\n        return _formatMetadata(\\n            string.concat(fortune[0],' #', tokenId.toString()),\\n            fortune[2], _fortuneImageData(data, fortune), _fortuneAttributes(fortune)\\n        );\\n    }\\n\\n    function _cursedURI(\\n        uint256 tokenId\\n    ) internal view returns (string memory) {\\n        uint256 data = _curses[tokenId];\\n        string[] memory curse = _fortuneTeller.revealCurse(data);\\n        return _formatMetadata(\\n            string.concat('Curse #', (data >> CURSE_OFFSET).toString()),\\n            curse[1], _cursedImageData(data, curse), _cursedAttributes(curse)\\n        );\\n    }\\n\\n    function _formatMetadata(\\n        string memory name,\\n        string memory description,\\n        string memory imageData,\\n        string memory attributes\\n    ) internal pure returns (string memory) {\\n        return string.concat('data:application/json;ascii,'\\n        '{',\\n            _stringTrait(\\\"name\\\", name), ',',\\n            _stringTrait(\\\"description\\\", description), ',',\\n            '\\\"image_data\\\":\\\"', imageData, '\\\",',\\n            '\\\"animation_url\\\":\\\"', imageData, '\\\",',\\n            '\\\"attributes\\\":[', attributes, ']'\\n        '}');\\n    }\\n\\n    function _makePrediction(\\n        uint256 tokenId\\n    ) private view returns (uint256) {\\n        LibPRNG.PRNG memory rng;\\n        rng.seed(uint256(keccak256(abi.encodePacked(\\n            block.prevrandao, tokenId, msg.sender, block.timestamp\\n        ))));\\n        unchecked {\\n            bool[FORTUNE_MAX] memory used;\\n            uint256 data;\\n            uint256 offset = 0;\\n            uint256 num;\\n            for (uint256 i = 0; i < FORTUNE_COUNT; i++) {\\n                do {\\n                    num = rng.uniform(FORTUNE_MAX);\\n                } while (used[num]);\\n                used[num] = true;\\n                data |= num << offset;\\n                offset += 8;\\n            }\\n            return data;\\n        }\\n    }\\n\\n    function _fortuneImageData(\\n        uint256 data,\\n        string[] memory fortune\\n    ) private view returns (string memory) {\\n        bool cosmic = data.isCosmic();\\n        string[3] memory text = [fortune[1], fortune[2], fortune[3]];\\n        return _formatImageData(data, text, _fortuneCard.revealFortuneCard(cosmic), cosmic);\\n    }\\n\\n    function _cursedImageData(\\n        uint256 data,\\n        string[] memory curse\\n    ) private view returns (string memory) {\\n        bool infernal = data.isInfernal();\\n        string[3] memory text = [curse[2], curse[3], curse[6]];\\n        return _formatImageData(data, text, _fortuneCard.revealCursedCard(infernal), infernal);\\n    }\\n\\n    function _formatImageData(\\n        uint256 data,\\n        string[3] memory text,\\n        string[] memory card,\\n        bool legendary\\n    ) private pure returns (string memory) {\\n        string memory seed = legendary ? _turbulenceSeed(data) : _gradientPos(data);\\n        return string.concat('data:image/svg+xml;base64,',\\n            Base64.encode(bytes(\\n                string.concat(\\n                    card[0], seed, card[1], text[0], card[2], text[1], card[3], text[2], card[4])\\n            ))\\n        );\\n    }\\n\\n    function _fortuneAttributes(\\n        string[] memory fortune\\n    ) private pure returns (string memory) {\\n        return string.concat(\\n            '{\\\"value\\\":\\\"Fortune\\\"},',\\n            '{', _attribute(\\\"Lucky Numbers\\\",   fortune[3]), '},',\\n            '{', _attribute(\\\"Lucky Numbers\\\",   fortune[3]), '},',\\n            '{', _attribute(\\\"Lucky Color\\\",     fortune[4]), '},',\\n            '{', _attribute(\\\"Lucky Charm\\\",     fortune[5]), '},',\\n            '{', _attribute(\\\"Cursed Artifact\\\", fortune[6]), '},',\\n            '{', _attribute(\\\"Animal Familiar\\\", fortune[7]), '},',\\n            '{', _attribute(\\\"Astral Plane\\\",    fortune[8]), '},',\\n            '{', _attribute(\\\"Auspicious Date\\\", fortune[9]),',\\\"display_type\\\":\\\"date\\\"}'\\n        );\\n    }\\n\\n    function _cursedAttributes(\\n        string[] memory curse\\n    ) private pure returns (string memory) {\\n        return string.concat(\\n            '{\\\"value\\\":\\\"Curse\\\"},',\\n            '{', _attribute(\\\"Cursed Fate\\\",     curse[2]), '},',\\n            '{', _attribute(\\\"Unlucky Numbers\\\", curse[3]), '},',\\n            '{', _attribute(\\\"Deadly Familiar\\\", curse[4]), '},',\\n            '{', _attribute(\\\"Astral Plane\\\",    curse[5]), '},',\\n            '{', _attribute(\\\"Ominous Date\\\",    curse[6]),',\\\"display_type\\\":\\\"date\\\"}'\\n        );\\n    }\\n\\n    function _stringTrait(\\n        string memory name,\\n        string memory value\\n    ) private pure returns (string memory) {\\n        return string.concat('\\\"', name, '\\\":\\\"', value, '\\\"');\\n    }\\n\\n    function _attribute(\\n        string memory name,\\n        string memory value\\n    ) private pure returns (string memory) {\\n        return string.concat('\\\"trait_type\\\":\\\"', name, '\\\",\\\"value\\\":\\\"', value,'\\\"');\\n    }\\n\\n    function _gradientPos(\\n        uint256 data\\n    ) private pure returns (string memory) {\\n        return string.concat(\\n            ' ', _scaleGradient(data, 6), ' ', _scaleGradient(data, 3)\\n        );\\n    }\\n\\n    function _turbulenceSeed(\\n        uint256 data\\n    ) private pure returns (string memory) {\\n        return (100 + data.avgValue(6) * 6).toString();\\n    }\\n\\n    function _scaleGradient(\\n        uint256 fortune,\\n        uint256 index\\n    ) private pure returns (string memory) {\\n        unchecked {\\n            return int256(fortune.avgValue(index)).scaleToRange(\\n                int256(FORTUNE_MIN), int256(FORTUNE_MAX), GRADIENT_MIN, GRADIENT_MAX\\n            ).toString();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Fortune.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\n// sjasjaksj USE 9 numbers\\n\\nuint256 constant FORTUNE_MIN = 1;\\nuint256 constant FORTUNE_MAX = 100;\\nuint256 constant FORTUNE_COUNT = 9;\\nuint256 constant FORTUNE_MASK = 0xFF;\\nuint256 constant FORTUNE_ELEMENTS = 10;\\nuint256 constant FORTUNE_TITLES = 25;\\n\\nuint256 constant CURSE_ELEMENTS = 7;\\nuint256 constant CURSE_OFFSET = 72;\\n\\nlibrary Fortune {\\n\\n    uint256 private constant DEADLY_MAX = 7;\\n    uint256 private constant COMMANDS_MAX = 50;\\n\\n    uint256 private constant MASK_UINT8_1 = 0xFF0000000000;\\n    uint256 private constant MASK_UINT8_2 = 0x00FF00000000;\\n    uint256 private constant MASK_UINT8_3 = 0x0000FF000000;\\n    uint256 private constant MASK_UINT8_4 = 0x000000FF0000;\\n    uint256 private constant MASK_UINT8_5 = 0x00000000FF00;\\n    uint256 private constant MASK_UINT8_6 = 0x0000000000FF;\\n\\n    uint256 private constant MASK_UINT16_1 = 0xFFFF00000000;\\n    uint256 private constant MASK_UINT16_2 = 0x00FFFF000000;\\n    uint256 private constant MASK_UINT16_3 = 0x0000FFFF0000;\\n    uint256 private constant MASK_UINT16_4 = 0x000000FFFF00;\\n    uint256 private constant MASK_UINT16_5 = 0x00000000FFFF;\\n\\n    function titleIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return ((_at(fortune, 0)) * _at(fortune, 3) * _at(fortune, 6)) % FORTUNE_TITLES; }\\n    }\\n\\n    function colorIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return (_at(fortune, 0) + _at(fortune, 1) + _at(fortune, 2)) % FORTUNE_MAX; }\\n    }\\n\\n    function animalIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return (_at(fortune, 3) + _at(fortune, 4) + _at(fortune, 5)) % FORTUNE_MAX; }\\n    }\\n\\n    function charmIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return (_at(fortune, 6) + _at(fortune, 7) + _at(fortune, 8)) % FORTUNE_MAX; }\\n    }\\n\\n    function cursedIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return (_value(fortune, 1) + _value(fortune, 4) + _value(fortune, 7)) % FORTUNE_MAX; }\\n    }\\n\\n    function deadlyIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return ((_at(fortune, 2)) + _at(fortune, 5) + _at(fortune, 8)) % DEADLY_MAX; }\\n    }\\n\\n    function dateIndex(\\n        uint256 fortune\\n    ) internal pure returns(uint256) {\\n        unchecked { return (_value(fortune, 1) * _value(fortune, 4) * _value(fortune, 7)); }\\n    }\\n\\n    function cmdIndex(\\n        uint256 fortune,\\n        uint256 offset\\n    ) internal pure returns (uint256) {\\n        return (_value(fortune, offset) + offset) % COMMANDS_MAX;\\n    }\\n\\n    uint256 private constant CHECK_69_1 = 0x450000000000;\\n    uint256 private constant CHECK_69_2 = 0x004500000000;\\n    uint256 private constant CHECK_69_3 = 0x000045000000;\\n    uint256 private constant CHECK_69_4 = 0x000000450000;\\n    uint256 private constant CHECK_69_5 = 0x000000004500;\\n    uint256 private constant CHECK_69_6 = 0x000000000045;\\n\\n    uint256 private constant CHECK_420_1 = 0x041400000000;\\n    uint256 private constant CHECK_420_2 = 0x000414000000;\\n    uint256 private constant CHECK_420_3 = 0x000004140000;\\n    uint256 private constant CHECK_420_4 = 0x000000041400;\\n    uint256 private constant CHECK_420_5 = 0x000000000414;\\n\\n    function isCosmic(\\n        uint256 fortune\\n    ) internal pure returns (bool) {\\n        if (fortune == 0) return true;\\n        return ((\\n            // Checking for the presence of 69 (0x45) at any position in the sequence\\n            ((fortune & MASK_UINT8_1) == CHECK_69_1) ||\\n            ((fortune & MASK_UINT8_2) == CHECK_69_2) ||\\n            ((fortune & MASK_UINT8_3) == CHECK_69_3) ||\\n            ((fortune & MASK_UINT8_4) == CHECK_69_4) ||\\n            ((fortune & MASK_UINT8_5) == CHECK_69_5) ||\\n            ((fortune & MASK_UINT8_6) == CHECK_69_6)\\n        ) && (\\n            // Checking for the sequence 4, 20 (0x0414) anywhere in the sequence\\n            ((fortune & MASK_UINT16_1) == CHECK_420_1) ||\\n            ((fortune & MASK_UINT16_2) == CHECK_420_2) ||\\n            ((fortune & MASK_UINT16_3) == CHECK_420_3) ||\\n            ((fortune & MASK_UINT16_4) == CHECK_420_4) ||\\n            ((fortune & MASK_UINT16_5) == CHECK_420_5)\\n        ));\\n    }\\n\\n    uint256 private constant CHECK_13_1 = 0x0D0000000000;\\n    uint256 private constant CHECK_13_2 = 0x000D00000000;\\n    uint256 private constant CHECK_13_3 = 0x00000D000000;\\n    uint256 private constant CHECK_13_4 = 0x0000000D0000;\\n    uint256 private constant CHECK_13_5 = 0x000000000D00;\\n    uint256 private constant CHECK_13_6 = 0x00000000000D;\\n\\n    uint256 private constant CHECK_666_1 = 0x064200000000;\\n    uint256 private constant CHECK_666_2 = 0x000642000000;\\n    uint256 private constant CHECK_666_3 = 0x000006420000;\\n    uint256 private constant CHECK_666_4 = 0x000000064200;\\n    uint256 private constant CHECK_666_5 = 0x000000000642;\\n\\n    function isInfernal(\\n        uint256 fortune\\n    ) internal pure returns (bool) {\\n        return ((\\n            // Checking for the presence of 13 (0x0D) at any position in the sequence\\n            ((fortune & MASK_UINT8_1) == CHECK_13_1) ||\\n            ((fortune & MASK_UINT8_2) == CHECK_13_2) ||\\n            ((fortune & MASK_UINT8_3) == CHECK_13_3) ||\\n            ((fortune & MASK_UINT8_4) == CHECK_13_4) ||\\n            ((fortune & MASK_UINT8_5) == CHECK_13_5) ||\\n            ((fortune & MASK_UINT8_6) == CHECK_13_6)\\n        ) && (\\n            // Checking for the sequence 6, 66 (0x0642) anywhere in the sequence\\n            ((fortune & MASK_UINT16_1) == CHECK_666_1) ||\\n            ((fortune & MASK_UINT16_2) == CHECK_666_2) ||\\n            ((fortune & MASK_UINT16_3) == CHECK_666_3) ||\\n            ((fortune & MASK_UINT16_4) == CHECK_666_4) ||\\n            ((fortune & MASK_UINT16_5) == CHECK_666_5)\\n        ));\\n    }\\n\\n    function scaleToRange(\\n        int256 number,\\n        int256 min,\\n        int256 max,\\n        int256 newMin,\\n        int256 newMax\\n    ) internal pure returns (int256) {\\n        unchecked {\\n            return (number - min) * (newMax - newMin) / (max - min) + newMin;\\n        }\\n    }\\n\\n    function scaleToRange(\\n        uint256 number,\\n        uint256 min,\\n        uint256 max,\\n        uint256 newMin,\\n        uint256 newMax\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return (number - min) * (newMax - newMin) / (max - min) + newMin;\\n        }\\n    }\\n\\n    function avgValue(\\n        uint256 fortune,\\n        uint256 index\\n    ) internal pure returns (uint256) {\\n       return (_value(fortune, index) + _value(fortune, index+1) + _value(fortune, index+2))/3;\\n    }\\n\\n    function value(\\n        uint256 fortune,\\n        uint256 index\\n    ) internal pure returns(uint256) {\\n        return _value(fortune, index);\\n    }\\n\\n    function at(\\n        uint256 fortune,\\n        uint256 index\\n    ) internal pure returns(uint256) {\\n        return _at(fortune, index);\\n    }\\n\\n    function _value(\\n        uint256 fortune,\\n        uint256 index\\n    ) private pure returns(uint256) {\\n        unchecked { return _at(fortune, index) + 1; }\\n    }\\n\\n    function _at(\\n        uint256 fortune,\\n        uint256 index\\n    ) private pure returns(uint256) {\\n        return (fortune >> (index * 8) & FORTUNE_MASK);\\n    }\\n}\\n\"\r\n    },\r\n    \"FortuneTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\nimport {JSONParserLib} from \\\"solady/src/utils/JSONParserLib.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {LibZip} from \\\"solady/src/utils/LibZip.sol\\\";\\n\\nimport {Binding} from \\\"./Binding.sol\\\";\\nimport {IFortuneTeller} from \\\"./interface/IFortuneTeller.sol\\\";\\nimport \\\"./Fortune.sol\\\";\\n\\ncontract FortuneTeller is IFortuneTeller, Binding {\\n    using JSONParserLib for JSONParserLib.Item;\\n    using JSONParserLib for string;\\n    using LibString for uint256;\\n    using Fortune for uint256;\\n\\n    uint256 private constant INDEX_COMMANDS = 9;\\n    uint256 private constant INDEX_TITLES = 10;\\n    uint256 private constant INDEX_OBJECT = 11;\\n    uint256 private constant INDEX_ANIMAL = 12;\\n    uint256 private constant INDEX_COLORS = 13;\\n    uint256 private constant INDEX_PLANES = 14;\\n    uint256 private constant INDEX_CURSED = 15;\\n    uint256 private constant INDEX_HEXES = 16;\\n    uint256 private constant INDEX_SINS = 17;\\n\\n    uint256 private constant CURSE_INDEX_TITLE = 0;\\n    uint256 private constant CURSE_INDEX_DESC = 1;\\n\\n    uint256 private constant PLANE_INDEX_COSMIC = 0;\\n    uint256 private constant PLANE_INDEX_TERRESTRIAL = 1;\\n    uint256 private constant PLANE_INDEX_SHADOW = 2;\\n    uint256 private constant PLANE_INDEX_INFERNAL = 3;\\n\\n    uint256 private constant MIN_DATE = 1;\\n    uint256 private constant MAX_DATE = 1000000;\\n    uint256 private constant ONE_YEAR = 31536000;\\n    uint256 private constant TEN_YEAR = 31536000 * 10;\\n\\n    function revealFortune (\\n        uint256 fortune\\n    ) external view returns (string[] memory) {\\n        string[] memory result = new string[](FORTUNE_ELEMENTS);\\n        JSONParserLib.Item memory json = _decompressData();\\n        result[0] = _fortuneTitle(fortune, json);\\n        result[1] = _luckyColorHex(fortune);\\n        result[2] = _fortuneText(fortune, json);\\n        result[3] = _luckyNumbers(fortune);\\n        result[4] = _luckyColor(fortune, json);\\n        result[5] = _luckyCharm(fortune, json);\\n        result[6] = _cursedArtifact(fortune, json);\\n        result[7] = _animalFamiliar(fortune, json);\\n        result[8] = _astralPlane(fortune, json);\\n        result[9] = _futureDate(fortune);\\n        return result;\\n    }\\n\\n    function revealCurse (\\n        uint256 curse\\n    ) external view returns (string[] memory) {\\n        string[] memory result = new string[](CURSE_ELEMENTS);\\n        JSONParserLib.Item memory json = _decompressData();\\n        result[0] = _curseTitle(json);\\n        result[1] = _curseTagline(json);\\n        result[2] = _curseText(curse, json);\\n        result[3] = _luckyNumbers(curse);\\n        result[4] = _deadlyFamiliar(curse, json);\\n        result[5] = _cursedPlane(curse, json);\\n        result[6] = _futureDate(curse);\\n        return result;\\n    }\\n\\n    function _fortuneTitle(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_TITLES, fortune.titleIndex());\\n    }\\n\\n    function _fortuneText(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return string.concat(\\n            _fortuneLine(fortune, json, 0), ' ',\\n            _fortuneLine(fortune, json, 3), ' ',\\n            _fortuneLine(fortune, json, 6)\\n        );\\n    }\\n\\n    function _fortuneLine(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json,\\n        uint256 offset\\n    ) private pure returns (string memory) {\\n        unchecked {\\n            string memory join = offset == 0 ? '' :\\n                _jsonString(json, INDEX_COMMANDS, fortune.cmdIndex(offset));\\n            return string.concat(\\n                _jsonString(json, offset,   fortune.at(offset)), join, ' ',\\n                _jsonString(json, offset+1, fortune.at(offset+1)), ' ',\\n                _jsonString(json, offset+2, fortune.at(offset+2)), '.'\\n            );\\n        }\\n    }\\n\\n    function _luckyNumbers(\\n        uint256 fortune\\n    ) private pure returns (string memory) {\\n        if (fortune == 0) return \\\"?, ?, ?, ?, ?, ?\\\";\\n        return string.concat(\\n            fortune.value(0).toString(), ', ',\\n            fortune.value(1).toString(), ', ',\\n            fortune.value(2).toString(), ', ',\\n            fortune.value(3).toString(), ', ',\\n            fortune.value(4).toString(), ', ',\\n            fortune.value(5).toString()\\n        );\\n    }\\n\\n    function _luckyColor(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_COLORS, fortune.colorIndex());\\n    }\\n\\n    function _luckyColorHex(\\n        uint256 fortune\\n    ) private pure returns (string memory) {\\n        uint256 index = fortune.colorIndex() * 3;\\n        return (\\n            (uint256(uint8(COLOR_DATA[index  ])) << 16) |\\n            (uint256(uint8(COLOR_DATA[index+1])) << 8 ) |\\n            (uint256(uint8(COLOR_DATA[index+2]))))\\n        .toHexStringNoPrefix(3);\\n    }\\n\\n    function _luckyCharm(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_OBJECT, fortune.charmIndex());\\n    }\\n\\n    function _cursedArtifact(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_OBJECT, fortune.cursedIndex());\\n    }\\n\\n    function _animalFamiliar(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_ANIMAL, fortune.animalIndex());\\n    }\\n\\n    function _curseTitle(\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_CURSED, CURSE_INDEX_TITLE);\\n    }\\n\\n    function _curseTagline(\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_CURSED, CURSE_INDEX_DESC);\\n    }\\n\\n    function _curseText(\\n        uint256 curse,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_HEXES, curse.cursedIndex());\\n    }\\n\\n    function _deadlyFamiliar(\\n        uint256 curse,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return string.concat(_animalFamiliar(curse, json), ' of ',\\n            _jsonString(json, INDEX_SINS, curse.deadlyIndex()));\\n    }\\n\\n    function _futureDate(\\n        uint256 fortune\\n    ) private view returns (string memory) {\\n        unchecked {\\n            uint256 future = fortune.dateIndex().scaleToRange(MIN_DATE, MAX_DATE, ONE_YEAR, TEN_YEAR);\\n            return (block.timestamp + future).toString();\\n        }\\n    }\\n\\n    function _astralPlane(\\n        uint256 fortune,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_PLANES, fortune.isCosmic() ? PLANE_INDEX_COSMIC: PLANE_INDEX_TERRESTRIAL);\\n    }\\n\\n    function _cursedPlane(\\n        uint256 curse,\\n        JSONParserLib.Item memory json\\n    ) private pure returns (string memory) {\\n        return _jsonString(json, INDEX_PLANES, curse.isInfernal() ? PLANE_INDEX_INFERNAL: PLANE_INDEX_SHADOW);\\n    }\\n\\n    function _decompressData(\\n    ) private pure returns(JSONParserLib.Item memory) {\\n        return string(LibZip.flzDecompress(FORTUNE_DATA)).parse();\\n    }\\n\\n    function _jsonString(\\n        JSONParserLib.Item memory json,\\n        uint256 index,\\n        uint256 at\\n    ) private pure returns (string memory) {\\n        return json.at(index).at(at).value().decodeString();\\n    }\\n\\n    bytes private constant COLOR_DATA = hex\\\"E32636E52B50FFBF009966CCFBCEB120B2AA7FFFD4007FFFFFE4C40000FFFFB6C1CD7F32A52A2A800020DEB887702963960018007BA7FFDAB97FFF00D2691E0047ABB87333FF7F506495EDDC143C00FFFF1560BD61405150C878B22222228B22FF00FFFFD700DAA520008000FF69B44B008200A86BBDB76BBC8F8FE6E6FAFFF44F00FF00FF00FF800000E066FF19197098FB988A9A5BB8860B00BFFFCC7722808000FF8C00DA70D68B008BFFE5B4CCCCFFCD853F01796FFFC0CBDDA0DDCC8899E30B5DDE5D831C39BBCD5C5CF4C430BCB88AFA8072F4A46092000A0F52BAFF24002E8B57A0522DC0C0C087CEEB6A5ACD6A442E00FF7F4682B4E4D96FFFDA03FD5E53F28500008080E2725BD8BFD8FF6347FFC87C40E0D0E4CFE97851A9120A8F008064E34234EE82EEC682EF\\\";\\n\\n    bytes private constant FORTUNE_DATA = hex\\\"1f5b5b2241206275726e696e672070617373696f6e2072657665616c7320796f750b2077696c6c20736f6f6e222c8029147374206f6620656e6572677920696e646963617465e00b2b056368616e6365202906636f756e746572804a036c656164605801746f605140250167652048092074686520627265657a400de00756602b00646050207d0664657374696e79202e20b6807ba04e1564697374616e74206d656c6f64792077686973706572802240ca604703666c6565203f00672072046f75676874207de0036f02736861a0280967656e746c65206e756420a20566726f6d206620ec2020016f7760520027c027036c696d6d20e1209a06686f7065206c6920550073205e046520776179c09b03677569644075601de001446097e101620568696464656e218b017468e1088860bd214100704069026661692022e1020203636c6f732084a109046d6573736120b62159066120647265616d200ae003e6e1000e026d6f6d20e7405205636c61726974213641f46059e103aa802701277320962141016374422ae00552e1013903726970702139207c41040a636f736d6f73207369676ec257e0012a20b300652098067069746f757320227a208b6080046361757365e0038004737061726b60a720ce0274697640aa210d0064618b20f70477617264736123047374726f6b622a21c200692056e207d2e00625066c75636b206177215101732c60714080e00623e001a7e20b7801737561b6e205ce0077211e201901676722af80a4006d42198058803001696e2115220e40706221e004f1211201636840f122c8016d73e00fed01747722f5204940b921ff00612178e00474e1016b802922a662c7607341404038206b6097017669e40c03601b2085434e406a41d60273696c23dd0065e10c5c0d6e206f6c642070726f706865637920080065227ba1044077404f066e20756e657870224a036564206a20bb016e65a27b016d6121bd247e602501636982120173642380027361798149e000d48367006d4102006320cc0072e105c10043227a06696320666f726324a5218f64af405be000410044219d444dc22302746861239e24f2e00425034563686f20416405007423d8046675747572210323df20a8e0004c01456e63de251f0064a330037320616822a4a05e602ca1000046444c0268617324cf22d120306079404d40206082210003466f72742127002020c7006c20800175708098002c601f402d848500498193006e2101a09be204c9a01e2338016c6d420001706f25eb0262696c22cd8027c299024d6167212f224c40e402616972e2044a806a014d792130006320a4006e237a21590265746520aec0bc002721150461626f7574825100532148002c2482415d006c23b520b360dd21aae2027780250074215703756e697625b1a29d453381ad629e0054202000612160006ec4b1403104706c616e6521664061c45e4062213b402f016261201f22a522f5016e6161b3c0b2e20548602b02727573636f026120662462006822ebe30449c124402b0063262540542025406e006460d18052e4018aa028036d2062654075602c0373746f7222c8e402160027e000ac006344c2a0c9202c2288420ec2eb604d00652205017469201e03626f64692210610f40d3602ae1002601636845c420f403646f756222cfe0026ee004c6006582d72028016c61470c20f221d7e30925407b01666920c2202903616d6269e10fc96027036c69636b2048402a20d2016e644491c734412cc19b03666c6f7740250274696d21a8e701cde603ca4050026d7572200260a5416e22e326fae010a6026f726124094112026573652121e10047e20215007028eb471e20a2e0077ce1004201707581e1c86e403e80a5e1056a047175696574e103e1036461776ee00df0e7043a209820da0269727221bbe1049f4068002280f904726879746863b1026c6966223b0075e6024ce20316e0012722300172202471017274206de30c110072244e007324780076204f00702727239f203460756454a07a007321b88172419d41bf402643de811044b0463341a001736345a3414c20d204756e6b6e6f2101c1a08314e003ad200b00644943e0063080af4065608cc087006f2170a0294473e310680273706928be0073e600a6e100f7206ee0014d00742622209a201d006524dd2a9c246c289b00756158e0087b602da6bd2032a390e40307007424a180c941260061232162c849e94155e10022247a6b65a0c90070227d2076e30015e003a3e0062a406120f9219d6059e0055602756e662769406d20580261206d259b016572e601cc4082e0035a2923006d233b202b006b219e2207e003834063a1740377686565643e24b6667e4093234ae9006441f5a80f80fd21f8619dc711a04c005921600420617572612b2541f200774ab5402ce60281205620766029036465657024df457e205720ad006e60c2c170a02325002bfe80fa27ef464b410140ece0024a26ec006d20dea1d9e100bce00398465f403941e7212722d420cc621b21a02127e0014d63512afc207c4505e101b8404e22a36336609e01696e2d1c0320766f692674e10021e0007dc18ca02a017475a549895ae002284057c115c91c21b2659981d76114e0047aa02720a6a40fa0fc802fe00351444d2026ad27e00826e00455252b01742049a8007229894946221387f3217026bbe0062c213601697325c221c1e40258248a20ec23870079c0d440292082006447ef2ba6212d83ffe001ace00458007226f84d8e22b1007023b3213761f7802de201976157e0022b841460fb602f40b3202ec084218e24892086036d6f76656855c0dc8058201fe10186804b202c4734e1068ce1035ce00027a18fe1055fe0045201756e2c3200724b00410e201b43232156604fe004ff04756e79696583e9406b20e3e506dc035d2c5b222eff006320c8007220de016163482a00722a63a00c00704c780061281720384012026e737780280172722182401100772b7645fd01626524be20100262656ca02c24782ca5801c007528ec201c20b72fb96008026f6f7360084e3e006641df67bf401a026f6e662dc48009006e2be8400923966093006325ac036963697a401e00642dd9605d00642a2440412f0380062df340352008006c2273203f006420be026c6f7040090069600f06696d696e697368601020fdc067600c247760a3223b0076807502656d62281e403803656d706f8101227c90a320432e8b600520dd8025026e6a6f408904656e7269634064026578682e98409323122722402d2cc4831b800c810e006680662fa743c700668247006641472025006623ca800680ba2f51403c25cb25254018026f72678195016761618b0167726017222c006d201e006880cc2494405b0268656c410f24be006460c30068261120242e5b27114056016a6f6043239240172006007241de21500120674309006c8069503f2036006c22406006811c036d61676e81d5006d3136201843292006006e2237609230f1404d2035017263304a201a007081c3037072616960512e06007481fc00702bde61aa01717545c465342e1a00756139291c822c0272656a802e29c0407122ea00692ed6822a017265261540c60072805c29e2006b207300734229811545cc4036200741b92b6f411d301302656e67267940ac017375231d0065404503737566666134017465231b204801747229184155239a40d3201200754157226540db017765a32426ec201a03776f726b6379016120cc6802746f20a1dd2013006f28af276c00742c5840924011204d006127a120260163722d85204420152314016b206e5c00722d3a806a40160069527a202ac375201324fc696a6348710560426c8f2029016164656961f74015215244d36c3822faa174201944d92111605ea2abe001154714016f62214125c7805e6310604921b0233be00348a0450277656ca2012048056f6e7472696220cb474f006f6fd2604893c52011233322e542cd20140065449f22862698a02601656390892029006d2172803b281d4059444a2057a013880d2027e301db2051006941d723d9606be001412016036963756c302c006847a18042217d006d20572c8421a8a013007568972f4b016c66297a60272e130072406720db017175621940132524299421e42016252200744645802e23d321ca0067265be0011323d7016f742026277a036d6f72798028007541af40590373686170807f01676f2b09207f2294a58300612bb202726d6f28f82016a2f52013209300742311229e0067e702a46057b44b20d3007442d90061e6008f20ac651e23b28081006c27e2404001696d2aeb0073520160402429f4016ba01100732b8f401831ad433f2024006980ba00652006006822bd0067a02925972975016f2028ae810fa86c201240b4604e8104401200632f6c841ae004152199007480cc20e022c502646574854f2010615540cb22d6e000c9e00115668ea31ce00115007023e6a050e0003fe10120a01320a20072280d016d62a1e4cb55201702736f6c64fe0061316a0077636c01727323ce60cd4011673b4be8e0001122e7333522b0e002372403201536aa4a7d8029230a405f23678396601500702ea622e8401868f4e00015a0a322620063210281ad684121da0065d283e20075208201696f64884646a1ca007033902426605b266381a341fe22c34014c6f94014016f6644b628f274ad809a370f25814029006b2396601321ad421d412652ad80138ec12013e600dc20280369736b20253b28f20274616b2279802a006f2fb620280070863f202600758010651e60224e6860230263617040bd8014533f60b3e501b3202a01656e209e210f2909036f6d706c225de10010e0001b26f38581e0001100756a8c00798058326a404157d5e0001000692440586321a924f7a01625498469e002aa4eb720cd0073c0de268882eb0074332f803701747240432439006934e628f3a29a20172f9740795699802a027572702135204b95c560142714a1ac4a38016361676d20162371403c287aa1eb6e9b247b437944ae803d4eb0211fa2462267e0011620b7006169ae203bd684280901696380220272616429bc829844f601696ea29a2764006120aa6040e70005635f2047205245e6804235d0a0a400748144007620dd80512043a7ec201545a5403b0062352b006587f900612e18262a20ba254340866051e00013037863697423bda2d12694016c2d26240265727630b1e8003d01616e44ec228141ca8070e7001b21f333cf0166722cee64e2006e225749e376a8201321842071006720356c2e4f1f200f84a023132167a012b7e401736fa92ae002464a554bb136bf209c2140007922d22c7520484012205b2ebb016d61226d201d8014a057835ba02800742ea927642ff302666c79210e4d4ae0021a22a3338b212a24a6536ce0031a026c6f752d3dab5f2073404a23282348227e0265616b801101736b430ae0001e23d70063a7c264e9e003500072307b26b48f4680b2405327b42e6f2649e002130265616723d901736f2fe4e00128745e006231262ff822b8695fa07802666c61279cb457e0033229412ac423db2752e002170167752229006921b8027761742659e00219424331e62249e0032fcda8c2cbe00230c01ab06de001ae036c61627934b222d904756e766569c1ba40f2006c42c80072e005dd221e00732157006c64dde00246a6722b4d2620e00417230c02776178e00313006e4c3d41502b72e0022ab4f0266521b5e001a0026f776c24b9016f74e00212007038c4026e6978457fe0035725cb39a762cc2328e00319409438502c0ce0024500732d5446fae0054428bb006420262475006c44dda1b94c822807e106ea222830eb229b006743bbc02a6014519277f2e001c880182431016e6b6654c02f00752164e0068320120073380ce0013b017468676b218de3005c00742333735302656262e003292077201c227fe0013d2cae20ff264623fe27ace0022d0077200e2a5f405823a9e00131448530fd017261384820032150e0021b2da043922636e00331016f6c46610077e20340271a2481408be00228057a6570687972f2002a20573aba3d37218ba2d62aac73b4843ee0032024d22233428444d1c0372ef64f2027d75073661d6d39c01f4129ccd6256d0079202720f601207920c1e0025c6025026c6f6f22e16b07400f4231693ce0034a42194047402024102128e0064541fb4f77c02403636f6d702901e00625046c6f79616c2b9d209140490068489ae00622403542a4a02220476ebae0038c4022c0b02708e006404257c03d57cee0061e217642d5a05eed00724ad4e0036343f04e73c0280062215fe00749037769667434763477a0ce01617747f1e003464207c0aa22bb016b654592e00320849be00222036c6f7475e1073623ae4496a06623e6e0078ab483c02142ade006ac27b300643d84a04221a92721636cc08ca02000672a4f6c1d014475252128b134ddc5482052bc8c006228897fcf229d0165794181c01800722d7125bde201084401e001382728006d214b270f211b211049584e47a03e0163792eb440a40073288b006f6341a019e2005c23e94772e00152325fe101a640586774c036270ee000f5600c613ba01d740c211220af410e624d417bc01e92704021e008750066459d02746570e100fc2466006c20d5e002eb0267617a603b40e785e7e001b4575140572519254900684826a074600e601a211e016461e002e8026d6964273120ae481a2a3d848aa036ba8c201da312a01720ff006c288e201700694a04006ec929e0001e6c87e2025d8048e001a9cb2020412d400369747564e002c6218a016c6ce30302006c8fefa05da296607e40ce6704c05a22572990244b006fb66c006de000ec23d460337d00202f005520272fbe21102bbe016f70643f425741abe0011be1036fe00a1d270840c44045656c47a5e0045be1047938f721b30022e0035f4b392229610a404526b1e0041f27c4e501242c10262d0074228de005a4e00424e00882e0051d31ffe0046048aa40c2aed3e0041b692d20d7438e613b6b9c4aa62bf1006e4d7b44112c1837c8938d01616629b5437b201067cb00614d690066405601616e222c8bdb301560850061e00042f6006a0261736b2082016265b4b34d3e211620124de00069b5b44105006e739429cc259a5061006331200065204f402a026f6d6d2b5a600920276cb72009b1a320092c0e01706c808baaa5a0be5209c0640364617a7a635d0164658fe2312222ac6fb543e3205e00652d8e26a10074406a23d736b4401483e04009006e2089007086b02359268060140072ee00aa200bb6442a36007275bba0094931200a25738033348274b5200965b640480076c08c84242012219e01686f417d276e2569611724bc6077006728824f950068321b016f6e81ad200b4367203921ac28384008026c6c7527b880d321b023dd6016006d24e361b3283101756c605101696e206f0075a029d7d82ad5270b6032216601726c915d600bc0cd006920c301676f347a802500762eda2078026c6962d89dec02e62db64262207c607223c2200a80bc016e752d566069016f722206275b805130dc0073381360190070356f653d017175218c4226636f6079017265220900632fa9207c34c2582b2035600c64be6009e10017368300753548c03a30a30064a039016e6557a0017265c21b4009e000272efb2067804b20a0621636be62bb20072a4d2066007344ae4007b6ba2c28400d01756220eb60f62045a24622268033204c046e736669782028600a016d7560d422f629b240e82aaaa011295a620902756e6d835d00752282808201756e2261416020daa14c017669333e60392d74a21d7a6963f7f4043332d82541c13963e300622b5d24a100202c4124760072936f00624991239c4b0723ced6a3e001162143017267403fe003122ba9037369617342cee00116b88c8416922ae00080006967662230606a0077c1fa2010230b2027036861707022cd62efe0001422360065499221473a4f01726e2eb0299535ec4010220f002d235d2ae3403f016b6e2b9400653780a01a2ff02b4290162ee46ecf4032d53c261c6114e00313f501504375e00319a0d9e0031230a32d9d608a6ea601666556a784d2275c40416017d5ee2f6d6102006822b65b9d30df2558204380f343c3530224090074c772326744a202726162292220ea4145006e3dd320e2e0041ae102260069235200733bac006260335327204e808d201a2bf5007480182406006942f821729b2200696063c1ea401629732be22e28401942e120476079322a22bd20120074608ee0041333a101696228e0201a80a6a02ce1022de000138a7f603e207700202f10a04c609d2213389303756d706880480376616c75608a214623c3a014210760b9366a79f5209380a523d9007044df6032361d016f728091c1ffe20519270501652d2ca721612077d8ce40634019006c541c5a1de00410e0035400692158409741a52258c085e0011700703b54026e74696645006d25b72b15280b21f26b9147de601220fb421d406724b995c7f7011a612147f124ba026f6c75a0ea34695e3c207c232d73cf403e23e3803e52bbe0020e24d73db5403aa025440927f121fb899940164295007722a00070271e814f61bf0164692ec0802b2e8c4641402c20b132f820be245964ed26d4284b2037601d036f756c2d20dd313121592187e0031840cbe3053261fa26b7006c431c3e65203420bd00742a07ed04363a3251572a21b92e4a40022d686f379820b6208594f140804019611d2005006749cc404f2a6e6013e10182e00012e200952045e000cb34c048d68b7fe00618b273406b01756e44fb006b6273c22f56e5213940f620d5a4482588a6d220ae23480068803d2014027075742012006d383485b420142fc901672029bb26aa215420be2647202a20142d946530e000100063254c016f738495201424327506e000d32144e200e5213a6d374013489960b56d5a808c21c602676574842f0061dca7e0091a4064235b006e8497e00536e1041a88afe00765e0021500735de7a0cf2240283600642e5d270c65a8e00113252261c5e0011148c12d1f67cae0011501736b292f002260116317607a830e01756e455620322632e000120071344a41616027b0b7603e340823a841700070e3001020152a8b403ee1061bc016e102730073468a016f7056c020f0a51a20160068a22a2220006632cf2142606ee00017d812201223faa2560065a6ff4014299c39c043028197a0112233239a372c4224a01988a420edbca3c47a2864416140dc02666f637087e00212e10305e00027e6026e01756e687d403d2411529e60c1e0001422306b074c950041241e23c736ca71ca2c984cd96e15036472616d4d79e00622237200702306e00026503a4191a0262304401a0079207821986825a0192674236ba06123546a3ce00239a01f2024027973694120e0043732a3e00173621420d4e00421a436407daa8f8398e004242cee37ff2f4460e2268ce00880414822e6e00023a32ee0016d46acee03a42f40e00d23e002906025486ce00646e001a8e0006fe005252c012e16d089206ae200d8e001493f8b23b027fce1079ae0132b006628e559d8e0007702736167e102ede00053e00ec402426579254020d7249d2dc4215443da4125e00319293f428560c120afe0021a81ece0075c026f6479230ee00645802a007237f2e000abe1016fe007522565e00025c225e00523293c409323896728e0021ce10ad8e10341e0022921953748e003460055a183006c40bc015768240124c8002021af0273616923de212a01646f6e16601b4136c37236a83a44218d0120755a8473f4e001242d6f016c7583caa377205328514c81e00b2520943077404d007727b228de2176e00b27e8027124993e57e00f5026840075227f27a9cd5ae0014e2e4e34a6224a9818e00118743e4b26006c2a0143cae0001a441e20c14d73e00399066570696c6f677527a000652f3ee0043181fe4436e0131b414de005698037006226823cfbe006a0801bc151e00f3b2d7a2822216e203ee003aca03da0fd252679d9e000e2801e48c923d520eb2e4c3033e1045f8022006e2a7e2188202623bce00af3453e2e00006f30ca27f4e00981027069653305206124c60063e00b6060209a4e478d006f8028e00948027269642e0140496618e00aaa86ce625701756e65b8e00b25e604e2404e0167723141e00b29919220dc411ce00390a3d94227e10411a01700272287234b2e9601726f2733e10535e00123815f29ad3617430b2ef6e3050963eae300dc41634366e0054e6023c2232165e30a50e004228346e004b5601f01646f2bbf2869e00a817709405b23d1534fe10479603c53362360e00b9a2327461980e100672388e00a3ea1124134e009980070335e002030c3e3056f607601707553c94099e209116020462de11236017365233c20a240d9007620dbe00a9a754520202dcb2b5ce2030360604516401e893de00c1e220b00637454e3007aa0b6e40c7968a741684236002043d700632e090061520ee0003fe600f52c643b7c407f6dafe0037ee00623817ee00be5e0002823c1225d4db34050442fe004cfe000272d3d60f2e60729e00120a934006920c042d6006d2217e00c9ac1f68079e2063ce0004e40b48e7502206f6324cee20421e0002563fae207dc69dee00c650069202ce603dec96aa34840aee00f224f708a11e00122006f664329c84048e00375e0044861606725a4f226956514e009256186418347bdc686e0009160486022e001b703726f6e6924a7e00e4a20276096625ee0042301756c28fc6f72402421133d0f230c905ce0007284aae4038a60f1e0046e8023c1fd0079e100f7c0b6801f2743007038ebe0048480193cee2a5723e88367e00536847a80a75da72117e003c680412b142cd640c72e96e0099b201988d43fad01697a6f0ee0006563cda1fd419764b4e00361602081fb42d8e40170c0a76020221a25cce500c8c01be200a620612e39300c3202e0045ee00021006738ee2847016869218463d1e00843478bb1c14d1b51c02eea60ef056162736f726220b6026163633ce86008f403dd016166d9c5269a016563b730246ab85341d69738400949162042400a0172652a2c408e827b63d0200a352900678079200c2095d933200df9138a6271405a036465647562fe016469311f40af0064243c35ad20764009b7b8f904792e03403a2ef2006ff90183aa1a01656e6bc46589f903832346803327d1264e205d016571b8e00165785a339ac90265786834814086309932a540f034cc303340132253b98423304707204600674934442e210621454011026c656140be0167722854200f398af900963053f90283200c22b0810802696d623926202e564730924009f90179a11b01696e3550609e34f5006fbb32275f51a9603053016044006e308c6a0d204a00652089616c400b007221c9802b200bc1163520217c006920c2403c20bf617f006d3bd7006620172059006d4a61801dcb5efd00f8006d9bf1016f6233e678f4016f624b6e203531db01636532fe400a22b3a01e291225c48014006f205f45ce83dc401322942fb7801f200b006f341ec0172ade91a54017344120562009203a60b529e9006521978043f901e63288562539ef2222208e6034016a6f34f560092657a00880a700722c3e016d6261c7200a4d85a028006efa140b808b2daba04d21d5a037485560692b1c2057c02022868077fa0928202d01736580f40373796d6223536100aacf201d229627cf51a1600c52e44062007521c401696c64110561206261747424ee32643e8303746c7920281f2d1e2030201b4f11006521fe22c42019a3fc646b201c0172693907247f35dc24c734eb803380162b9b22e53f10a1a1e0002f2018e0019622af6034e401eb734d35b0206e43d123b880562021007020884b80016365801f63de40d9e0011d4fff002d2451289d0064a01a3a8a2c5322d8c03660108036d78153452ee8c686401822e4006e210b363c231de0002e80159536201b203233458c0f20342b1640de237120a8007320770274756d42b3e0011a026e65772dc02e104694e0091af307bc203822b4006d4086206a200a41e1a0ba200d006d2af0007347db222b201f007028f00075a01e01666522a72cb227cc20a740c35389616b43bb0277617940a9006160902a986f2ce0041ae5001ee00b3722b49ff927fb6096006d80cb66900073955f20762093e6029d0161207aa8408f71a32192fa0082fc0452e0097ac99720cd21a701662dc5ef4819e0041d4272606560e9c03622722171219360e980aae0021b605220aee10425e0021f4054585fe007536017b174e003303b6e2bc9665de00432629c213a2384a1a528c6409c00682ead315fe800316035a01b25194f4e006c212e016f77747ce0001af500fa00612f91026761632201396200642175026c6566807aafb3268c2019016768601a25b2a07ec35375ec00692101201f02777269b164203d25d480b544f38277401343eb418b2500291da0af58724a0ddcfa60c460212dac23b920c3205eda3b804c2536245f36cb245956ca2b69e80482202062df22462408277a447c20f720277984806324222286212858ba2063a616a06200792967208225f060802879c0ca006edafae102480070235027f521316130e401d6e000182ebce2062ae0021a205220996a3181c550f1412a626323b223c022f56a4fe0011ce0047f202f00724f0540c801686f3d5a60e46017207b294523ec4f9ac5d923e5e00321827c006868490079801805696c6772696d40d5233f016661213de007172058007425ac832440aa8020364be404eb41622724a15903706f656d3aed026f7175217e20ade20339228821ba25fe406d212f201e006baa6444a63dbf201b601667eb81aa64bf006977ae0165782aaa2afc671a006194f726980072232a0067293be206252081a01e80c16de060c2e00119e00713bdf486f2625c22a480872ae0006b26c643a722b0b1682016026f61646350203b401bc02d40162158e4059360152156006e2210ed000a8212c01a4167002d864a007960ac0073239a37a640e62f38216c233e2958a1dfe0021de00e1601756e2899017273242b60ec806d2240216b209fa0e3c27b24545e5b036c6f64693d6a20e8017375c0683d4a0120614350273280982ca92424f7001f35df234dc0b5401c2a238242e702ef6018c290a73aa04e4413e4037434ce817a801a20ada19e602f583f25d50072298a63c2e0002d21870069664ae60931801a20944180c19a0069a181e0001c4b04fe0906402001656b40852cc73a6d006ea106c015203efd00b1a3c9601a206da29e25ab23a08180c01a0074236001756e44de83d161a32117016570217c202d21b902746f6f810629f32059209e230201646945d1cb61a27402766f7943cfe10293a4756130a01d21462c9b016c6f4767e00819627dc1188197a03620c68346e20000257fdd98405425eb26184604406d016e202aab4016a0c33819a2b2302598fd401d2112a6bee00416411581856a8e002c20d225bf268d2294564e208d2064e00516e00112463f2446e00628c015a02730cc00202c79471060473ca30065e006316012e0022e29d46d12602f25510079e0062f6012a02f2e1401726344eb006352c0a0142c116c1ce00337e00013a0234459e0043440a84043216c204f443e60fac01621cb2cd4e00917242f00628840e00630006f3fb70067e0092f00722ecf2dfbe0085fe0023d0163614248807a200b37d6e000892d4f63aba01c400d40e4e0001f3b3b615de00510e0025b0068253be004316010e00220026d6179e0003c200be00b1f23d5e005bf4027e003a5006d2626e00182600de009474023e009498015e002c0423be00410607ce003216010e002c1496a6032e00914e002256264e0044700733a99e1025c800ee004213d3b4a86817c400ce008d56014e007908014e002d30077e00468600d601f522403437279702ad521830341756775641b00432727006e6c50201504436c616972442b85170044277b2d2a201802446976261623ba423c004628a6201301466f2ee227ca8412200d0174756f78004997ea202102496e7427f48034004d2fe324d72015004d89b62009004f29dd20060050236528418027005022be0069df0d200c5135e0011aa04220172347c030046f70686563404f00523c6a808d00522f692fd580210053501f408f005620110063e001c70056804241180042278d45d302416d75282c209302416e6b46a10342617562754d03417468616514202945c8004220f8202600429d2703426f6f6b400d4e89803f0342726f6f5072034275636b60400342757474613d0043254560110143615218014361221735b5203e218a006c90920043357f408503436c6f614058200727fe402234166006715a01436fd2fa004320800069415c0043258b604b00722165602b0344616767603b02446961214c40bc014475605d04456c697869405501456d20e440ad00462a81278d2061004634c7407900474079411902476c7967b30047247a6121004747a1202900472a80006f2474200a0248617240d201486f723920063ce501686f6019036f757267205240490249646f4037004a5fd12034014b6541ba20052723623f004b82cd024c616d404c004c29c62c612028034c6f636b6079024d617220832011004d80a3024d656460e96007006c81f3004d25a528b84024026972726c4e034d6f6e6f971a014d6f2bc3a06d004f25db22120022200900706045014f725539005029b0409d005027a52081201e2009017461803f01506fa25900502a4f41370551756172747a202401517583c5200781b00052235a006320180252696231716008636901526f73e7005268150252756241030052833f025361742d33407c0453636162622e712036200a60f2200701726140a00053433261aa005331a5628c00532c83402a2c2160322044600f01696761a80053232661a601537020ff4028007436086007817800532999609c015375e1001e00532f57404c02546172646303546561708008006834ac609202546f6f6b9200543e21410c00565280375322e7635b0344726167606f00412097027661724256004121a730ac6197004121e0006c3c7120330241726d23c1016c6c41b70541786f6c6f7440490242616280b00142613295429d0142614191238a600c732d024275663fda403843692e30006c41520043602823582b0e00656084235a0265746143db004320c10370616e7a603e200c006e376d016c6c4209236e02776e662e9120920043816e235701636f209a40a5014465608403446f6c702035202380e18071004423f0201201456136014007016c656c89200a0246616c32be4008016c6128c7006740ab01466f5bd20346726f6720170247617a21b1403502476972219a6009016f6f742300472e79809c0248616d2a2b40f802486177406a01486521150068604104486970706f219f02616d754369638120580248756d407001626961ca0248796562ef03496775616008004a20750079a0ee024b616e36cc006f409b004b246b410d034c656d75406e034c656f7021c1204f004c8363024c697aa00f35f68092024c796e40d0034d6163612d9f202a23ab006767f4004d2134006b618d23870067a0d5200a310b4026a010034e61727725052011004f25496268044f63746f7060ce004f2e5b0173754262004f2ba60167752a8f402801726340a5004f41f4400e0077403d0050227c401520070067353b4027200aa4db0150612411419123e400632454203523dc01677580260069418a0050263c007980750050363001757096530250756d40550052239600694040005250bc61d3005228fa406500522211006f38ba006f417f005321402bdd2bff2062239d00684511800a40a443a8407c03536b756e600720f0427201536e2e984026017069a03a49d536a6401327bea1aa01537760ff00542a08405f02546f7529cf2022035475727462450357616c7261380057249d8220025765612c1d202400572165406301576f7011005a5a3b63ad01416c41d5610a01416d246b2134202e0041b70e00413aaf006825a9401238a10063614600413944401020062031812902417a75646b02426973820801426c620f20066356271f23792035200866b0004226202c66420c200a026c79778d300242797a2082006961f5004330f9805d034365727532ed40ed43db027061676639200b00722d930075616401436823b121c6406404436f62616c40b400433586612d02436f726183200723b8006f3f3f208b004326ca2f3c4009290220060344656e69426f04456767706c20872012004538fa006169c9004626f43711623f28fd87b105467563687369410e00478ef84006330665e702477265622405486f7420506961f301496e3af3436d014a617b4d044b68616b692066004c8fa0014c61225682042386609a004c978d004d294c2690202a004d43af40ad024d61757966034d69646e4aea401b2fbd4006233840060075281363c1024e61764169004f3e30411f004f5404202063578008250c43ea034f78626c8189432c420a29ad00693b4888d5200c0075203720cc4035200642c700503ade40149bd300523b000262657269f0005284cc00522ee2016c20220a403400522094202d005324f0221360096082233c80f0005323416016006e32eb40f002536170257860b8470e888e235e02666f614077035369656e64d7015369340f41d702536b79c06d0053a211235b6ffa005322c586f30074375640663002007740070075e20117200b007368790054208320fe60ec2709402f005420da24450074618a27140073837b02546f6d26de20470054253448190554757271756f2dfc40132bb4a1a001547920d340f501556c2078e3003e02566572221701726941b5200b006d202f611b0256696f80ee00572068208983b303436f736d6865408c22872017409a245f01646f40cb02496e6629422013015d2c202c384a40842a214c0b3ffa200f00734e8a002e601f02312920241c41920531303078204c2b4927c0403104353125204120e862f10539392520536c266f801b27d0026f7720200520de27a60120474ab0016e618c47401000543f92016e6f20a640d247b9002022b789cf400d276c0120543b6041e900428d6425ad20354a0300429a77004880790042345c202b006140194b01948f026420413648007562ee0344444f53e001a900442bb100202c25006a2f62209d01446f4bd202205370806c0044247e002020a060190178782047253681634b26e00146014578375321fe608671ab01457834d1014c69259c02646974434e6010229242850245787022a20164204d52400f05464f4d4f20532769012d4f6974600fa0c502465544207e004632f1203025d640d9a00d2021016e733e7821fe4138a015005735e8006422a721d24013006d515104444a20417021c80049424d2da201204622d862fe286f215d28c8657924aa026b204328ae0075ad400647617320466565405e400a2319667d400b2638206004484f444c20205101696763b02be50164204045201a2259006c201832d002427567a00f3633271405722044756d70405402496e762cd720d80169672e42007563b7024c5020293423484177004c4ca160ea344a2044014c6526ff0464204b5943400c0069415f00614063400d27ae201a004626296029006f21a1004b2c3a601a200b0053503c0250687226e560120077e1049f004d20870063727e20ff236e0063420f22863bb401204321f52032200d2294e1002ca00e054d616e69707580e92024034e474d494006399900742be703205969656611024e65742b2e615d5fab21164025006fe00483200e025768692af123c0601d232201204528904169024f7270226320e001426c20e800222010237c0168793c85e202c0401324b53ce803204e4654202400503ca60072229681130050204102746f6de2033940232499289a0067c29e2cb9207700442f3b401c600c004927476111232b0074473b002022c3016c6f68e828f80270202661d2202f025265622160e000b500522089ee00d50352656b74407b66cd0052350131d2e4003404527567205023be204325ce026477693713e0001c4338e002e6c00e608a4030006524a9236701204239276689434d203030588254293f0177202062402c277c6440004225996f88293823f5c15725ed05616479204c6162460153742bb4c378800ce30277204e005444bc01204461b462b2201e50692174006c41c5200ec3a5413443f8203500553d600074238f017075402300552d5300612d310120542832639700553fab0372696669413ee2018f015741225d214f28b12043848c21a8c32c005723c5409d407e401f24510273204e2e9066ce25b92061c3790057275003672041643e5067ff800fe0026b005a2aa8400f0166692d7842af4348025f62722b5a2a0620c446300057366447f848bd40d62166600f223561e4014c7562c901456e68520a476c7574746f6e79225d5d\\\";\\n}\\n\"\r\n    },\r\n    \"FortuneCard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\nimport {JSONParserLib} from \\\"solady/src/utils/JSONParserLib.sol\\\";\\nimport {LibZip} from \\\"solady/src/utils/LibZip.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\n\\nimport {Binding} from \\\"./Binding.sol\\\";\\nimport {IFortuneCard} from \\\"./interface/IFortuneCard.sol\\\";\\n\\ncontract FortuneCard is IFortuneCard, Binding {\\n    using JSONParserLib for JSONParserLib.Item;\\n    using JSONParserLib for string;\\n    using LibString for uint256;\\n\\n    uint256 private constant INDEX_MASK = 0xFF;\\n\\n    uint256 private constant FORTUNE_START = 0;\\n    uint256 private constant FORTUNE_FILTER_NORMAL_1 = 1;\\n    uint256 private constant FORTUNE_FILTER_NORMAL_2 = 2;\\n    uint256 private constant FORTUNE_FILTER_COSMIC_1 = 3;\\n    uint256 private constant FORTUNE_FILTER_COSMIC_2 = 4;\\n    uint256 private constant FORTUNE_STYLE = 5;\\n    uint256 private constant FORTUNE_BACKGROUND_NORMAL = 6;\\n    uint256 private constant FORTUNE_BACKGROUND_COSMIC = 7;\\n    uint256 private constant FORTUNE_COLOR_START = 8;\\n    uint256 private constant FORTUNE_TEXT_START = 9;\\n    uint256 private constant FORTUNE_NUMBERS_START = 10;\\n    uint256 private constant FORTUNE_CLOSE = 11;\\n\\n    uint256 private constant FORTUNE_CARD_ELEMENTS = 5;\\n\\n    uint256 private constant FORTUNE_INDEXES =\\n        FORTUNE_FILTER_NORMAL_1 << 16 | FORTUNE_FILTER_NORMAL_2 << 8 | FORTUNE_BACKGROUND_NORMAL;\\n    uint256 private constant COSMIC_INDEXES =\\n        FORTUNE_FILTER_COSMIC_1 << 16 | FORTUNE_FILTER_COSMIC_2 << 8 | FORTUNE_BACKGROUND_COSMIC;\\n\\n    function revealFortuneCard(\\n        bool cosmic\\n    ) external pure returns (string[] memory) {\\n        JSONParserLib.Item memory jsonItem = JSONParserLib.parse(string(LibZip.flzDecompress(FORTUNE_CARD_DATA)));\\n        string[] memory result = new string[](FORTUNE_CARD_ELEMENTS);\\n        uint256 indexes = cosmic ? COSMIC_INDEXES : FORTUNE_INDEXES;\\n        result[0] = string.concat(\\n            _jsonString(jsonItem, FORTUNE_START),\\n            _jsonString(jsonItem, indexes >> 16 & INDEX_MASK)\\n        );\\n        result[1] = string.concat(\\n            _jsonString(jsonItem, indexes >> 8 & INDEX_MASK),\\n            _jsonString(jsonItem, FORTUNE_STYLE),\\n            _jsonString(jsonItem, indexes & INDEX_MASK),\\n            _jsonString(jsonItem, FORTUNE_COLOR_START)\\n        );\\n        result[2] = _jsonString(jsonItem, FORTUNE_TEXT_START);\\n        result[3] = _jsonString(jsonItem, FORTUNE_NUMBERS_START);\\n        result[4] = _jsonString(jsonItem, FORTUNE_CLOSE);\\n        return result;\\n    }\\n\\n    uint256 private constant CURSED_START = 0;\\n    uint256 private constant CURSED_FILTER_NORMAL_START = 1;\\n    uint256 private constant CURSED_FILTER_NORMAL_CLOSE = 2;\\n    uint256 private constant CURSED_FILTER_INFERNAL_START = 3;\\n    uint256 private constant CURSED_FILTER_INFERNAL_CLOSE = 4;\\n    uint256 private constant CURSED_GRADIENT = 5;\\n    uint256 private constant CURSED_GRADIENT_NORMAL = 6;\\n    uint256 private constant CURSED_GRADIENT_INFERNAL = 7;\\n    uint256 private constant CURSED_STYLE = 8;\\n    uint256 private constant CURSED_STYLE_NORMAL = 9;\\n    uint256 private constant CURSED_STYLE_INFERNAL = 10;\\n    uint256 private constant CURSED_CLIP = 11;\\n    uint256 private constant CURSED_BACKGROUND_NORMAL = 12;\\n    uint256 private constant CURSED_BACKGROUND_INFERNAL = 13;\\n    uint256 private constant CURSED_TEXT = 14;\\n    uint256 private constant CURSED_NUMBERS = 15;\\n    uint256 private constant CURSED_DATE  = 16;\\n    uint256 private constant CURSED_CLOSE = 17;\\n\\n    uint256 private constant CURSED_CARD_ELEMENTS = 5;\\n\\n    uint256 private constant CURSED_INDEXES =\\n        CURSED_FILTER_NORMAL_START << 32 | CURSED_FILTER_NORMAL_CLOSE << 24 | CURSED_GRADIENT_NORMAL << 16 |\\n        CURSED_STYLE_NORMAL << 8  | CURSED_BACKGROUND_NORMAL;\\n    uint256 private constant INFERNAL_INDEXES =\\n        CURSED_FILTER_INFERNAL_START << 32 | CURSED_FILTER_INFERNAL_CLOSE << 24 | CURSED_GRADIENT_INFERNAL << 16 |\\n        CURSED_STYLE_INFERNAL << 8 | CURSED_BACKGROUND_INFERNAL;\\n    \\n    function revealCursedCard(\\n        bool infernal\\n    ) external pure returns (string[] memory) {\\n        JSONParserLib.Item memory jsonItem = JSONParserLib.parse(string(LibZip.flzDecompress(CURSED_CARD_DATA)));\\n        string[] memory result = new string[](CURSED_CARD_ELEMENTS);\\n        uint256 indexes = infernal ? INFERNAL_INDEXES : CURSED_INDEXES;\\n        result[0] = string.concat(\\n            _jsonString(jsonItem, CURSED_START),\\n            _jsonString(jsonItem, indexes >> 32 & INDEX_MASK) // start\\n        );\\n        result[1] = string.concat(\\n            _jsonString(jsonItem, indexes >> 24 & INDEX_MASK), // close\\n            _jsonString(jsonItem, CURSED_GRADIENT),\\n            _jsonString(jsonItem, indexes >> 16 & INDEX_MASK),\\n            _jsonString(jsonItem, CURSED_STYLE),\\n            _jsonString(jsonItem, indexes >> 8 & INDEX_MASK),\\n            _jsonString(jsonItem, CURSED_CLIP),\\n            _jsonString(jsonItem, indexes & INDEX_MASK),\\n            _jsonString(jsonItem, CURSED_TEXT)\\n        );\\n        result[2] = _jsonString(jsonItem, CURSED_NUMBERS);\\n        result[3] = _jsonString(jsonItem, CURSED_DATE);\\n        result[4] = _jsonString(jsonItem, CURSED_CLOSE);\\n        return result;\\n    }\\n\\n    function _jsonString(JSONParserLib.Item memory item, uint256 index) private pure returns (string memory) {\\n        return item.at(index).value().decodeString();\\n    }\\n\\n    bytes private constant FORTUNE_CARD_DATA = hex\\\"1f5b223c73766720786d6c6e733d5c22687474703a2f2f7777772e77332e6f7267052f323030302f2022095c222076696577426f782026053020302035306003105c223e3c646566733e3c70617468206964201e0061202c4007134d35382e34203133312e34632d322e352e332d34200302322e342007003720030b352d2e322d312e3720302d332014200206352e312d312d3520070032200302372d382023400340260038200502332e3620412025036131392020024089013120405506312e3920372e336003401500302015003820290333632e3620720232203140700320322d36204202352d3120094015408e0232733220380031401d012e36200301356320920332202e38204220170020202f203f2017602302342033201e400b003620070033201900312025003460394025203120f540074027212420b040230032207f401b02362d36201902326139200d400340aa0030608b00352079002d2015208520ce02352038200721240520395a5c222fe103600077c16001323040f2053133362e3163203220a2204801362d206b003340754151208c002d60160039200a4083414a40fb218c202c414c218a21742001200d4042201e218e21302124404d003820af403d0235613720e5400320b120014063013463205c2063202d219901203420390039213b20e620030032211621722126401b0031201160512007003421464025801f0038201100382027415a003320ad200e41b32054209b414521592007400f01352d206420d2414b20fb20e120794057402a42030032e1072c0073c12c20b2006320252095219a20bc003421700033206c20732003409100362011400f20a52064013120210a0235203620790038208781e1625240ce41a820b52073402b0033202440984026003720152032210f0036227f003822bf4025412561ce20310033201b416a4186401b403d40d261b0218f20ef42d042d8219960810334432d35209d003820862025207a0320304830e007ea0052c0ea003960c7003421aa007321d121206005200902762d3120a00163302084412e41ae4159003120b00432483834612006210b003221dc20014014400d017631237600632368207e20334012201a003140070068408fe00435604a201e0432762d33354036203241df606a4032401b01683120e500612176406620cba04d03563332302067216e21d54227210801326c20fc20204268237123f5223421e62060003120df202e21282124414b200506762e315a4d3838406a013133607c40e722354076032d33682d223420af807220e3c0e50176372061404b40ab420360ab20772116003522360038202a200c20cc408c204940ad013133e107810059c18101313224b6022033322262e001e740a620d0203c20fa234e200520562001002dc0d121f8608540cd444c41b460070061200540292044401b04315633333560de22882518215e401602396c2d21ab42a3003620e4205e2003205e6034003321fb22406034212824934003206a201f20648081214020400037e0006d203a20f001326c615021782007210c803280ce208f625600364207a0cf415d2070006822abe004132017007620280036e107350050e1003501353922fd0133322416610641bb416f4254203c042e3148313440d96198209c2001214c600d40b7820de240a4013231e007bd406622b9015a6d22f620fe22a3614e40a6e2026221c540a460b040a2c0a4e21163006840322158462f2064e217650054e1002f0038208d22e924d4c389e009754283614d205721e961b040076098400f6011400901762d202be101b2415b6179c05b616840362250200d4003007624af205d20b10037422a259d6018046831382e39e1033d20fd60282024412d200f403f4005e2070c0041c0dc003227df64c32151003022cee00e7d0032607d0038205821828024400700682562006121a02017c6af224b20e5013263201e25668005602c200d2007200625a1410e2647002d226a01393967542107212520f2400520030076206580c8405120c24172409c6151600f206960072017e004f66015207840196155241c603a20642001601a401e653b003960d860644013404c4007016835e40239409040e201346c2203274201376323c924ca208100352005244e0276382e219f200f4176c07f60ad22c501313020f1003228df269020f202302e34e301f9210520320068245ee10d0525a46057417940574053600321790038e108794898e5082d0053e100ea003940bda1ec2603207b214c24d221744176e0009520ef400f0068407c209f21332074202d6080411d02762d392349a0bc2075003320142018006c45f7002d204821772032205c2001416a201b403423d58519a16e2023201902683136e00379a001803a200d02483238e105bf6330403ae300e9604e2011401560030068277f0038e000bae2052941c2815220ba4035208220222007e307230045c13800332530202100342709413820de6182a0a3203d200323a3278920592055608f20132033601b013168216d241920302319415e2005400d2013642d416e201121d56123e00460e001ee0039e2100b615861cd205621bd204ae102cd414520832922270c206740032057e0025927ae811220916112202340bc0032a202402f209d405a2005204c203d201560bb205e8013e1073e0055e1003e013330203102313230236c211d2336211b003423134978012e38274d432020c30036201e20202a104a90214d4021006c203d29c600302116207a2078207a208222800073204a207b4a3e200f024c333242de01393720442018404822ec205f2a6401346c23e82be90137632087201c29d98017042e384c33352034272ee00d5d20402860284c2084002020840037e007e5004fa0e5026d32364059003720c823e340832337231825182120003920f101336c2269264900632132401d4019430220dc2852258623372099c0e020bc20b721bb2033236b202e42b0208c204a2014015a6d226220f12648400e20034038407120516152215b4720202b2003201a401c20c4401c20100231392e426741e541cd4001201b2071218c407040a12012215e402d203823de22612188e107010075a101014d37409e0134372681016133203280742031217a28ed2d74003721d7404d40ff254f260b20936127400b006c200a201e013161219521b34a0b203e20212d2d006c207f013120401f006340d72145200e204a202f01346c200c2378209b259521af28d62004006c212e264120f02aea469b2231222c400d20f12003013273201321232069209a2063212e209320542058003641784171203f2092217e2027260420052e05604440042e0441152086202521f923a040524a1c20bf601825ec216a201f400480d1406b263f60b72f386093210920042ab6209b01387620f0002d206e2627207100206004603a204e4b9440b041916107213f4068402e4004201020b9202e204d20932022e201d9214e2038228620950076283929e600204003801921a32202e3006320d320ce40c7219e415c2d242006213a20102095200426f4200f223220ce0035e207160072e2001621ad221624632601202b2031216a2088262920bd253180522020201b0032802120d3201c013868208220cf20cd8004201e207b20ba003322b840e520d2225c00392014a027211720200036614741b66037207021bc203a436401382020d24001406d206742992ad5214d20f44004408e2033201424502003412022da20b421ba23dc012e37413c0033297b00206004404c413e213a44e12039218e273b202960eb612b419742e62046201d209020fe20b640f20035208a802430a92034003342bb20652074400e20392c100061267d2eaa4004806f222720a82506600380132232241970c70666696c74657220722a325720100b65476175737369616e426c752018006e32430c536f757263654772617068696321af0a737464446576696174696f401e013136604a002f804b2042e002530062e02e530034e0055204636c697050f200d30068405472e272d920d400683301007620030248307a8038c030e0073a20be2012066972636c652063533e01323533360220637920e602313633200a00722009013738e0064509222c223c72616469616c2105046469656e7481320078203060460131352032804602323535200a4046805b0067a031085472616e73666f726d206008726f7461746528343520580029202dc02303556e697453fb0d7573657253706163654f6e55736520200a7370726561644d6574686f40f3067265666c65637440cc0a73746f70206f6666736574205840cc4011042d636f6c6f408302236665400160cf4018e0012a00314056203ce0012a05656565356432602a002f40b4e001ed6100e103d70066203c04776964746820730331383025200e0468656967684083a00f415d012d34601a415da00a8044e00fe7223c0a6554757262756c656e636581630071205b086261736546726571752016404c40e6086e756d4f63746176654130417202736565411b215220310374797065209b026672612023036c4e6f694146002f405fe204dfe206ca003220582024c2ca204a033c2f64655551057374796c653e357c007b419b022d7365417f093a6e6f6e653b706f696e2344022d6576221700736013087d2e627b6d69782d6220c710642d6d6f64653a6d756c7469706c793b7442070069433b063a31737d2e747b6147063a34313070783b8144003a35e9200c05666f6e743a6920be01696334570270782f23e91035656d2076657264616e613b746578742d201d15676e3a6a7573746966793b6261636b67726f756e643a2316063b626f726465726092063b726573697a65600b027d3c2f80cf40e063482196006c212e0575726c2823784291047374726f6b41410523623561613923c7e30f6ce0074302233835421de02140023c672043ae002d4088c08300682083e304e3022d313063e50256373563e4203201617341f9409920bd2180c03b0066203b2055404ec0b30039603b2f7de01e3b012f6760d600722363e200e6013530231ae201e5800e62e4434942956008208b006c208961e50270617222122035e10a0c8012002d61fc202f0031227920d3e10a064051e002dd006220dd012072407745770120724078600961d1204981f3002d43c00275733a2496210b0067834a006f2030e008630063405020b5e0026300672012e50626013439403b806cc52600384110203940ef00232206606a213a003c24e500652295024f626ae1034022e1204382e120a721d0200e40c800344008405a0133364009006f22df03666c6f77202303766973692343408d42ec214e0061f9121f302406392f7868746d6c20580063a21f217e61cb002fc04020a2e0049f805a8088003540d140890134384089c1526388003739640331367078e3007e00204051082d616e63686f723a2023e8e00369e2037f213c27940132382c9c2bf1286227c9335627b12bda297b2953023661342cca0020600423b828280231362d28724a23282e3012501640032ad2280b481e0035284800322dae00363694401320346a4e202168150038203d0431613131202002605338112c0900634afe48844e4e4874013461209901332060046027012d33291a012d352a17401400398004601901203220c9062d38322e3541372e2700206004a0192d2020420037404c392e40048018003650fc0034400400382064c0622c93209800302d515a8e48c4003920e8576d20c5202f209020a128db4ce02118200b2d3649a82a70315c201f409f2051202d2045600734cf405f00322131016134204420dd2001414b20593189217d20672d1b00322900295d2d332acc2a94006d20230039299a00612a8538cb4004203721a6205c01313521b720134002404e00302008218000372b3820094002401301302d201502312d372069025a6d33204a012031201000374a992e5840472983217621fe52e141bb207f203129bc35ae200a00372ec62d75411740a82a1f003720192b7a21194100204d2092200d200320be20052ddd40d02de04143203d333a2d9d21470036613022062033201320a94c4b20862a5c20bb2b3f002d20012010215f005a63b6e5012d34c12148202201613640c6600420df4146202d0120332b802abd0036209542442df0205d208b204a205c210721c5206220cf01613622b100206004403f213720212b0a430422b620ef22e422a522482190608c212120102b10210b22cf20232b4c20552320002d20104012003820d00037414c21f1214525db2e4321c232b721190031205c417b20522118222643043a0c200d4bff211920a9604d01376c212d5cdc6f8520642022003720202b7040332177201020052014400d228020074177204e5026226320d00036200b20fe2026222820032060200721844206002d23f73c3120f6006341882142218b202c229f2ef8202b4058402200333aed220401613322d0241c20012320207920e2409d20cd40102146439943c441e34171441c212b4e62237360a2202a2c8f200e00324026ad6f0275736564e001353944d644e00231303725240368726566256600235e250074489725194a9f077363616c65282e372607263d403de00229a01145b9022d333749794050012d394706c0265d15e009502151412a0031e001566044013530465160448614e0184542db0032e0054500354bb4604401323245c5e01543012e36e0013de00229e002da003646f040930034e103285cc0e009d7e0034d40d1003966e9403c00382d1be00060e00e3c0035e0018a403c00324a84603c003460d2c09ee01d3d0036c18f013434e1038fe01d3c013334282e607a0131394009e0027a2119ed0336013138411e880f00354120497d207ae00626604560256d66e00d24013431e0004b0132334209e00e266225604c0039e0117100374040602480a2404b8e4ce004be60e8602601323020b660262007e006be3afc201b802668a4404d21d12026e5012f003625780020f511f54436f50ff5401b55f5f4045402312032309122df24f72428002d60113cfa003424eff307c52308200300763637403125b723fe2052200340180031d5f145c040464050600335ca003460328064246d8017860be303ef005260ede003113d5620ffe003113c32e006113b14e006113a49a01142e301313521450020c25ee00963388ce0032d003725e0e0022fe0096f3783e0122f807be101b1013432295681b2281120f926b425ff616a327c53ea2c6f25f8214e2163290f212720070068278fff0996416d00315cf1203521804035262680354007fb0db06054380c2700e103fd002d2188355481b024e521b627655e8b3301205d2657201226446007360f291100632673401b484b2018272901376c266920d220ae0063260b20ec20563237281b012e31e0026e35b956032987205e2889265b2720326f46c4266e204d6234403e00203a4b209946c620bd2019c2693e460039e001534814e2014581eb4344c1ebe105d9022d3239204821da452b2982e0032922670020e5036ab133012d39220ce5053129c72872202e4045013131e00344004f2015e00b44013738e00642003464aa404028682034c0af589ee00b4000313f9ae00786603860424a33e0034522e1e00c450134308086e2009b026d323321100120352a46290221ce42a047c828c9621d425a01386c20182178364521872c464ac42a05200e401c28d7419fa03a4a6521d648c5482d373f003720082be139652018203f601b48ba402a0038423a2c963ff42042002d427d3514284d2003225be102e8200d4015224040b128f880aa4087e003aa40262901f800b4423e201f2aea403720b44255a06820752019606840fb22c2609748e9406b0036e20158c19e21dfe302f885cb6181013337e80304e10e7f0032e806893a7c21a8603f0134354694c06624cfe10bbf2b0be20247c02c22322093e101d2003329d326702119216c24422bad20f820d22011834a218f2178003220203ae2e10062237e002d2194216021012b0fe0011820162df2417b003223e7215e2b912409422523e14181601e23d14016400f2230200f2017006c2cf320153b6a21df223a43c5205b22384ad201326c20220120398258244826d82184200a20073b0300344e2701313442590020204e20522056406a4421774ce002a421c96690006c2b9e01322d36b3e000bf244b2051202c6067406520a0204d4283377e40a1249220d2229b428a22be00342c2ce40657242e436261ad00366ad7c180260de10bad0039aa31e1019900342159372c227f607f003525f6219520f04134208f5864209b40e900382f3640e95a734ca500372f742005210138045829203321cc200121b220034f30205c2004216420ce20fe00342bbb0020600481db4c4738f20038210b60048015210a4c6c3885217225f323cb20042186208e4059baab21dc208c211801413420a000206004404002302035203f01373139be201725cb409020273e152051f800fd21b6404f215b20012d71245b216d20eb00384db50133202db540bc20012c5d2db24ff821e44004201320ec227722b4265e4010602b204cdb2c20b90161383d9800206004603022c020fc20d12272208a24a0207044be21f0200c217b403620a32ef226b08135218e20d5200e201b002d20704002202220fb2041006121bd20524004606122a200332e4b0237203921a18004c017312b47132035215d0161322d1920cb60056021201d4d7f0138203fc0a004801780b32381209001326120a6a01740a2279c202c4003802b002e47f83f1f20aa40b220623ac62028217f2369618d2164221a21644dad413e281f2da820036063204320e520df2008232e20392237274f211c40b7200740622071405d2026210f28aeef09c03170420222c83a8021562f852162620a2170e50088418021e5436620d9205023a64095200320aa2900205e208320680134612691a0e620012045212ea00f201f2aae2031208e204820da20a0006141864003611a219844e821ab200180112062003643fc22354024209d207c203d21c2200122124005c2e9201924e1006c209d206e4106422b2013207420b7213200392006003942cc0132682338206c2049200422cc20662f864008265a00613284236a400440852f4c205222102f7e21b24001214c204a0031407e20075f4e21212133200c201022e1202420832011414d402620ed61f320a4200a407621a52436e402abc4953f00261600752f89c0113cfb2011e4018e013130409b013437256520500134612204301e4074407680ad49a722b621082007600520cd41de448e809842b120bd002d24844199e0052d204da02d20c4013761309c003850a182c532c4202e32a80120322206202a200133c0203420d922c520942130289b21d22a8923b92038208525a60068200b66d82044202c2068207f23a801366128cb003448d041ed2001002d22212207c00d413453dae0010f268d4058223022bb2083215c20c4600501356122db227d4004204a209b435726ae201e211a819921182146201020b4200b61e2200602613133215729374005803c25bd002d270901336342d4202720b1205120472003423b46be21d02047254681fd205a2136209c42af20a22003413a2040411220380038212ee802a74b00459b2691c1f58207e100f5024d3132416043af013376233a3233210d400460a4257e2066210923d4206440b1200a013573238820f560e1363ba13e20862012631e20bd210e200d20fb23a20073201120e3200a20be621d21ba006320d7633c445721f3205c003226cc205120f221c2430c20215e40a0f9200a204441fc208e203a2016205f404020b4205f21b8200640ae22842082205124ca2004828441cc202f3fe1c4f020a7268c43992102400440f468df2f05201e602e41cd21b920c3404c2060470420012f10200c408b23034009203021c5207620c3408f66d84005012e398a3ae102752d792136652523c920fb20292ac2203c411b20dc203500372005201822822007415a205c260d200920010032233c233a2079200120402331215240a9202f40f2214720082425202d267643c94003202d22b822f723a80035218a219d201d280121014004801f220d238c27b0204920ca204b203220e040b5217525dc2003209a48a961a843ef422b253c2dc2257d013476206303613632202002805300352071003823c6220a20ab40952165611e206d202321d460552005415e207e207346f3207e20836226216040924c342155201469a04014006c432f223e203d212d203a2025201f2362012e34258421dc600f42c5600522a7200c206d2021207a201040832001002d20a0a0022011401c42b5228c016131208540fe200121346075a645207540553607e50753437d61e76cfd425540c421be202f617a60072006207722c6209e20200031e602f12015212c45490036413342f120aa200a82e3291c200f0234613120a0440a212d210d003945ae006c201a230c209a215b382e213527ff200120a720032da9200f403d41114334243a204b4091444a2250202141a0203a51ae200b20198001405281662041002e2f8020570020600440822a05204221c8006c2158432e401620fd20042018274a403b2e02206d410727b0209800206004403c471a27f24754205c0038253a42208005201d20e122ba224c003128600261313020922baf4005401c4644003922e940d0204e415241cd2087229a20092141213b27dd42412190200d238820ae242d39884059221b24f5003622c823642044400320582001212b218d00392048204301336120cd4303200120ce205c43c82158006139800136206004201a201c20ca002028e9204a2028808f2005201d20042038406f2159205942264113860b2579022d33682130202e200a201de9010a203a2ae1006c22420061e9000d20cc4056b19020e740552167453420a920ab246a400520db206f202e00363b9f202138b840052055229957c920113008219b6005601723d200362d46003623c022a220a121b7204142d623598056207d22862027229643b82019216320b5610f40f02001209843985250402920642050609567d140964de12024205921130039393e2061220f013461211f249a82e7239a2064206100634048206a240e229428fd2043204720a4408a215c0076234f0132202002203440e0207321e62548209d419621c320b1002d20862011200e20406002217220d8419f2c59204e201620f42060209821e300202002605120848f5820444074811b400720ca405b245020578054200520bf201945512b89216b3b6a0261333920e260044052401f410823a32024616c610e224322e720a240a422b0002d20ca20bb2007205f20c1200820b4202021828002003743432184808e849e00752a0448190131302079e8111a026d3138241124bc34ac20c2208d60883cdb21054cf920c72001220b207d20a0c3e620a229a32b10323e219a20fc20102424408240cf41f1ef02a820b24019402a414f203f211b2cba2012202a2010203b2155202626ad41cf265901613521c00020600460826220411d245e206921042066222f200a482520a421092087213f208e20022025212b200520c32007400420702b54201621e84132219f204501366132ab2d28400440482e90208d445c21b9203e402a20be205f212b200a64d423ef20ae202b40742025246a4f7e22c94004204441342048259c203820582082200720050073202f4008003820782b88315c400440314078422a4d5260af40cf262d418f210b400320242058453d2151217d20262001419f4ded27cc208a45f140da201220b14021203c20042b79206d200821ea2003286660c52320202b209c23b2603c41a621ef204720242109203141482024212d4ff5a20d29dd20a024714068430c21c5885e2057222c203e20702001238d201f2016607d204b20bb422520b6604c003782b3e9013a003222b520ef293a4ab0274f422140515d5f242e203c2230603b49c32534201d204720052e132010212120102068200621ede5013f201b002d2028276b40df377b20bd52fa331349e36004815141eb20cd250b223320a8204820f7218e20ce21f7209120df84a82286204840852300202326b32143203861342119200b204a40346188219e349b405720034052208e20552063205520140036201c6068ef0149204140bb21df404522c72003003821c040bf20e4374021aa2e9c226e402141b420a8205529172029212a602720524e02217f2e0840284001407943cb002d4feb414f20a9220d4010200a0231613826184050200122d03f6f602430ef21ee2056215f41c92982e9051821c5214361c50237762e2ec340b720c820a9203522ac2001213360100073233840b122bd41192006405941cf00342cb14200203120c421ef21be5447214341ea215821d421d12005200a61d620434017422341012017200e201521054069601c205b21420061323f20772079a059213e22c42416402561f40033ec01fa20152075ca0f003780cb82e328cc20030039e101af80444f4a2131204a20a3203e205b23f5208d20b421cf26d82007303f200b2232405d216f202f20ce220c4343206f203b402621e5211b4006422d2237203323b440022207225e27390032419b20ce200120de20c0250c23c3804460d6a1a40075c61e2976fb0327f0062f004d3e2921a1438800362d5101336c445a23db25b5208d20ba20052179206120076079202d200420890076461e20f301613226e42250200161f921c10063202120e340d420952200204720a62004404b20ed4037400e613a4027613c0135682209202e203d41b42025210663296037408b2075253b2007201d2034200745152107406f28d8201a844321ab20102125403720be21f9200a408d400d2028418b425d26cd20672025015a6d2eba400b405129f9438ba2ce41b3209e006c205020082016202620b3202521b121bb6054208120092004012e3821492cae29da237920ae21e1436e2034407220cb200d20b4200920380031288a214323df8141201625e4414f20522178810f600f2076208920042065209a22f4207f600f21212dc920f0440e22f6002d207b2077205320894004201b0032f4037c2089279e20ac41e82064205a219a2050404a20fa40132140762e21232313208f2065405b205145dc207b827d201623e5407ca27b1673637269707420747970653d5c22746578742f65636d6180160f5c223e3c215b43444154415b7661722040221f687474703a2f2f7777772e77332e6f72672f323030302f7376675c222c723d640d6f63756d656e742e676574456c65400a1342794964285c226f5c22292c743d5b5c222366303977002c2008013066c00801306680110238303880080066401a1a5d2c633d3365332c763d2e352c613d446174652e6e6f7728292c6ee01269007120691f3b636f6e737420733d28293d3e287b783a3132352b4d6174682e72616e646f6d0a28292a3235302c793a3330e00916007dc03e05753d743d3e7b40fa0e613d604d20247b745b305d2e787d2ca00907797d603b666f7228402116723d312c653d742e6c656e6774683b723c653b722b2b29603d0a6e3d6628745b722d315d2c400600326006035d292c6f8017600ea01c002b40230a727565293b612b3d6020432074006e8071006e206e200d006f800d006f800d204ee0009020092090007d408c0024605800304058006580580c315d293b72657475726e20612b805700248049002420352057402e80106009e00d1301607da15809663d28742c612c722c65215fa0e303617c7c7420d20072400601243d20a7002d20b921c120aa200903792c733d61800e7371727428242a242b632a63292c7580140d6174616e3228632c24292b28653f60270350493a30c0b3057b783a742e7881a909636f732875292a732a7621be02742e7980150273696ea015007dc0a3006f60a3c09fe2029b026372652249a29e034e532865228b48ef42370d722e73657441747472696275746522b704636c61737362930062e00c1f0366696c6c201e0061403a22de0073229ce00203005d20502112182e742e6d61702873293b742e617070656e644368696c642872203581940072c0b5002420b5023d3630c0b605613d6e65772042f9003b41d802723d61435a03486f75722065032a36302b600f024d696e20ad2011800e01536522fe0064200e022f3630a060072e3030352b282e30244220090b292a28287225743c742f323f2007023a742d200502292f28200f0829297d3b6c6574206822cb40b32301076f28722c742b5c223d220c29293b66756e6374696f6e204d2202007220f861fe0065e3059d61c1006d219307312c28652d61292f21eae1010720384197439721d6062a28312d6e292b2128015b612282012a6e81d7e005160b792a6e7d29292c243d75286f2134e107a5006421820b24293b6966286e3e3d31297b2171043d5b2e2e2e2054e108820f613d657d72657175657374416e696d6140cc054672616d6528442cc0d503297d742e23db0345616368c0af034d28612c610b01292c4190848a2111216c246b0069646b23a6e20640046261736546606f026e637940a620332194e00b7f0069201a007d60c40029200a053b5d5d3e3c2f858a083e3c2f7376673e225d\\\";\\n    \\n    bytes private constant CURSED_CARD_DATA = hex\\\"1f5b223c73766720786d6c6e733d5c22687474703a2f2f7777772e77332e6f7267052f323030302f2022095c222076696577426f782026053020302035306003125c223e3c646566733e3c66696c74657220696420200062202e800f03556e697440590d7573657253706163654f6e55736540350c6665476175737369616e426c752037006e20370c536f757263654772617068696320430a737464446576696174696f401e0031206e032f3e3c2f805a2042e002720068202e04776964746820460334303025200e05686569676874e0010f40ba012d31801b00792016c00b8046e045a9e004a809222c223c72616469616c20da046469656e748126007820a40063409502313538400a409402323535200a0072209e01323520ee012067a031085472616e73666f726d201908726f7461746528343520580029e00223e00fc20b207370726561644d6574686f419e067265666c65637441850973746f70206f66667365412840704011042d636f6c6f408302233838209921734015e0012720dee00627023737376027002f40aee001e7053e3c7061746880ed21f50020407d1f4d3531362e3220313139632d2e3820312d312e3720312e382d322e3620322e3402613138401e40044268201f201c40180220313940184004a01800302035204b006320420234203020400038200506342d2e336131392028e00126003420260338632d324022012d33200e003720090039404001362e206000202011013220201008332e31682d2e356131206c2051200102312d382032012e332063208300352036063520352e322d3420ac02362e372031003460170331302034404a003420a203332e366c202800324049023230202002400100312033043820352031203e80048015203904322e33203220fc0036e00012208b02352e31612020b420518069407f0032202e02312d36201302382d39207d003420956141003321060035201c40240035201e01342d205520480039200d20a0202f202b2047002d2099003620252156002d40f201386c200a2097406f2035203302342d39203f00322033400ce1074c0033203d214c02312e3660e400322053003520550238613121c70037a0c220950120302171202d206a20f9202f003740382062013368200c003921e721e5a02e80f1412ae1012d092d372e396c2d2e372e36e0052a20b74096808120ab003320600031212e208a61a40033207541164019003721ac20980133202002816e222f20db0035409a0037208d0036202a20fd212421d12096423d203f20ae20b441512009419d205d0033213e00332015214de2062221c22129e002bb013132208f21d00031206c6004807b221c2153022e376c2047213e016132216cc266405b22c9230420870035608d20f94030202c200220ae232e211520ade2049f40ec2250e203f0208c811f20324105211f204800356045231b23360020600480952089210201326320ab206b2005223e207120ed0131612292200280270037412a602c203ee0003c43162142e1026122fe203b219f21e9204b20b1231b43190031217821cbe0022a22e3012d32232b002d427b20fa40ae003522b241760038200e202f400b208f2009200b21e4200522b2209f202023b52080213a41a440e4201b200d21aa201122a4002d208900302040217f2005210c2019406242fd003222fb202ae304a0211422c240ba4337204d42e10034206842c123d32060c01e2282404620df20ad21f92157003221392069200140d80037202d003742a32103223a003320272043002021bb438f6004802a210f2064223e20a66004a0160030205f003621442071420a616720156008213021802061213122f6209f012e34209e002042ebe1049c20cf20e42045203b4132602b201640a1e105dd24b9003420a50037204620bb43f5251a0020600480902153204b2100232a8004801722d0246d4062208c00374225202a215d217e2041006124112002802a403e201744d6201d240320db21da20ff0432762d3836257a0733562d31396835332123017634201c006820190239382e205e2148209520bf22112060403e01375a265287bd27150575726c282362270f002f677080170020688f006620270077a81c013138e8051ca00f4786012d34601a4786a00a8044e70f5728810a6554757262756c656e6365806a0071206a086261736546726571752016404c4756086e756d4f6374617665490d47e202736565470d27c22031037479706520c2026672612023036c4e6f6949232776e90624e9060f003220586024004347ae054d6174726978c04a0473617475722825205c0376616c756076802ec93e2079e80c950073203268950035610d60c1800a416580090066412ea00a40e1600a6051e8052860414012002de8005103666638634a3720b84018e801540037e00c2c00612a68003680b8e0052ea9c84014e0035c0066602b40db4019e0015de00a5c0138622adc602ee0062be00b8905623332323334e02289a05a4089e908140067822b006f4169026c61734212200b073e3c636972636c65817d89fe617d800a417d003320ae4294006c222c214942d70063a04021b620c8696e4257014d32244b249e003426e445d924a7236c003126ba24b92003242523c6003223f123bc20032575200740152903201723e823954008200d20034544241f202702326131200e841501302029a6252f46bc2039201d65bf002024736400200e201623b0003223e7207e23b82995022d2e39201f206300382017494424a50031200c60732537200c244a00392077853901362d247044f120c4201d24a42078201f209320c3013320200f2080016137208040034096267120bd003520b2a4a6203b20ee20aa20eb2060203b80e024840061c02445c626300063408a207160bc400740be257120cb20c3209f20d120492003209420bc2093200b25ce20dd215a60c6202d206d25a3206a201a20dd2008401020b32003409c200d40d32724203d20124057204360e3206e218c2057205c265a2010413a2028200924ff200d409121a9200300372556203c200120bd201b255020072090200b403940034013217120272a0100612ab920982001284d208526ed20ae2019402722326031459420d22ae3203721e5205f2172202e20cc2060280b006126d4202020e1206845f300332267402520b721914013202d203320cd200d4b71203b200726894032409f205b202e2018205201356127d0206981b0209b2087409c20dd200d2267809920fc226601356120824206807e202901356c404d60822185407b226b4056006c20bf217f02613239203060044035405121db29fe0076207e015a6d2c6f0038285e003722ca210d0031623e0036210541014853200920b8202e20072011035a6d2d3720912879006321592025218b400d20092013207620912127002d214220c00038202e403c013563402a21ed202e400920050073217c405b200a015a6d26f12b9f20842042003642cb225f208522e320d02082401e20032041416f40d621e821f8221820312011022d355a6406012f67e4006400554458e40216003140b7043139306137232d207920014798415428272318206142a62921207820070061217820244026616829dc2001a0102012224d238b4003801340f720e923e5213521c120492037006c802a20bd418e012d3141a8202020d68400006c21b5203a202040012161006323e2203e44102062204101613264bb4004806822ca216c21202001401120716122403920cc20792a02006c211860c7429542dc2272240380132087205940190039e2061e41a14163253b20a22192226020b620574132200660a32272203f0132764a1b20cc219c200e238b2094213c22cf003722cfc26f20c22926203c44a3234c21642e7720b920564037209301356c43c2013276202a256429292567400520db2025207420ef220c20018011203421692075405d25322080200621ad408d221820a820110039215b6360821be2020b00322088003921280076202521a1403be102ed233e405d20484002218b20a1244ce0025d446e229e20786144422e2378407541b2202a407821200068204720fd20fb40ef21290033212f81d4003424600020600460d223da204e0036202d21c020ec205e21c24165613a20844052201721d52020202a200920612069600c4101400c407645e020304482218440132006013273205a2157217f236520744211201720b7012e336178023639202002608d226242ebe103706b93220b21712081207a20610037e6004120134337003142fd2afc201e40a481822278273b003226d6a05d209264fb4b71207c2026a1b423872351206b214b0033434c21f6003381bc43d804636c697050f100560072e305df20b700682932007620030248307a840cc030203e93ab057374796c653e33d6017b753397022d7365520e0a3a6e6f6e653b706f696e74201301657632a60073801311666f6e743a313270782076657264616e613b2b170b6c3a2365336461633961617d28e4022e6f7b80140137384001027d2e73a00f28a5e0041f8975e0021f400c06767b6d69782d622b4710642d6d6f64653a6d756c7469706c793b7452f700695400023a31734048013c2f80bd294440d7002d42ce290d6bfd00722bfd697140140020408fc019007820192a2b02726f6b4b670523623561613954a5692ae10a33211700206c3a54864aec002d215020424aec4007a05b042342424236201600683352206a00234b6e60b1b3a9057363616c65284308207f299e4056e0113aa020e0066e20792061c03502464646e01b70223320036074219c013c7233eeed010100306b0cf5001ea00fc061d3f26143610353ee81282e7f625e02563735625d21828abe0076200b204022392106618b0066607ce002450032202280450120396044017632e01f44e024be00422b794131e0029ae1020460d0006e208a0077ce0fe1150d01313120fd20c7abb2006d2039006f36c7016974a2094019e005f8006820f8e00223002e354081f8c2242bea205043c9e0073a4ebde01e3a403e611660d0006c2037c0d0f607fd37c2570d625500316da8e207c561af0073e005b6214120a4620341b4026d313752f8013138282924aa44c92c3385258607023820362788878925c6012d34291824c0258528f72bc048070034202a2033203145a3282520032520002e2a4d22ae862025556546201074984b21033661333426a60020800523ae257e25124cc42a0f252a6005201520178031287f262d20ab4062336f26652653202026214060259b28d902353920200220352001463b208727814949407e45b8262420912a1743c3205b45a72057276b20b5400446b7200b202925c8200800362030202f269620ea033161333520120020800540656a3c0120312c9a26e8800420142016298c022e33632a8a20648d3f211a270d400726ae266420b4276f2c5a213e60c9417e206a0233732d2096209120b326384042207220ac20300035284640a38005206720172053205720842024c09429e220fa207a6921204520c32072210a206c276a204329c920a621012062002d2202611726a720772015414b20206004606626b22133205501203121ba206d6005c01a3353006c40d929d4003731dd00208005601d012d3832220137202268a004801542463429207f002e320c203228e320bd4785684c209ee803ba274d4783212240c1213320de20c821a62b4b003821e80031216b354d202140db27ff2024356f202f2965200420e020e60034ec0166201320ee411b607b2c8f204d216c40932281202a00322c4d28736005202f20ca4050220b2022227720b52182203e206160052a3e21a587d7e30068024d32306c980039230f288e003235ad35ab204d200621a622032047210a207c213e235f210f200b421d4ced221f200721604007ed04a121a84082212821af2031400328f4208620cc601421b0201b2b7040a521954011201a225b006121c8222d40046088212d413b29282001801120364060202620a84003423320a221216001421620b523282145203a20a120102145202d202020e9200120d72038003322b4202f6004605c20882c742ac720380233682e4e672018804120cf003223de20c62027ad6802356136207a002060044040442c50e54238208d22b4202b831e0233372020022022202420232036443863bb20412112200323ee201f60b8402122d6224c207020072c6b207420d720a1205840ec414e211d201b6032226581e100752851c6012d93e5035c014d322a70e101f100362cd2809343ac24a2210c003221d0413180132a16208a318320028013211d206e2444200180112021209a2c1c41f3208d200321ee20aa239320c840170037200b20ae6e7220ff2213601e403920f30161332f400020600460512b22220e0120352528800480152f868f9ce001a1209d45f901376c41220134632081414a42642160407ca1502b2820b4213841d721352131200f21a720132437201f20532066204420b12b0a218322070237613340086004608360973c4d203b202b232621202057200722452007204621a6229f21f5200cc00220182013211c401d2374203f20816102003723cc20a46004606220fc0034368b21f622a5400462b24e922c52400440254ffb3b0b20a4c18640bb4bc1003442272078207e207221730339612e39215d4021809a429b200f20b3207d272820070161343b6b002060042025201b37fc20d821a0396e209d600420172019003226be003222b9234b2021205a4169214443c0200f401341500036ec00a86cf727252196200b21e8209840432049205f210941684450508601362d204ae201c5484955080020e210ce0039229c24c001397621b6006c251421a0477e205620b5002d206026c52005200723c640c320b123c5212b0076217a00373d950020600440a720d2587767d0224240ca2180219b204f20e0201242f922cf601321a141f5200800683062404140fd4005202820cd8040248720882012003127ee43bc0037456a424040163a44204044e00034211901366120fc211a2243200143574082602c2058206d2086432f40dd237120612251208d40564003033761392021d8200121fc60f6015a6d237120bb203b45910038216762e92038295321052450209d22352005236d2f980031400900632028601320662e4520630035e102cf223521d02171003681a9e60151003322372040023932768145218c204e23e5200528f12001003960f72396e900d420ad606d27a5407d209f709602326133222d401e202022a541180033211c41c8401123c5203822cb202a411c20af2095447b20f0211a340c20144027219a2024413620b5204b20113c1920d76004604d210b539200334440410a21c141f6204624322022221940c840c0204720be003720162078e1001421702127237c403121ec601e441623b32098202a209a200320342a9b201d220c015a6d21a42019277740184004408c83da20a429de21ef2045207d200440f92258002d20344018201bf5011740e0206727fd205a200a208624e92038421e40d0e1026e22060020207b26f30031214e67e3401441f0400564a225f72008607540472004201e21302022205de701ec60112043206322162418200340c540a66145408d202120cd4076408d414722552157406141af243a015a6d21ce45db006122914426615144bf20c920ef800220362008201e20fa44df247b208e2194404e40b9200c20100035201620902192436221308234208b2004229131e4230d200b2037437c6026013561c54840a424f620d52071402322b2205520c2035a4d323431a0033132682d22fd0237682d2475053335683432762005032d31307620122018200b0134762004e0000a35923d62023136682022012d396029003921802b94006880230035402300392038e0032067b803746578746505ed014d0134374d6309616c69676e6d656e742d5c02026c696e506c046d6964646c50185146032d73697a4014013234253f4047052d616e63686f4f35c0276fb0002f401be00c699a9c2e72006c2f690423636363372049e02178013133202e405ce01a786e5a0064202f45f1e001eb00396e4fe02481e00d700520646174612d2004411130a6615c4ed805736372697074dcca403c042f65636d6180162121123c215b43444154415b76617220733d646f63754175062e676574456c65400a0442794964286fe801293b40240064e012242f3c80240069e012242ff88024006fe012243dfc80240074e01224215003293b742e40d500433358222d053d6e657720442106002860c20141743dc8016275200e202cc1212034092a316533292e746f4c6f5255402f00532028046e6728756e33d6226c06642c7b6461793a225d042d646967692129012c6d20610068e004110379656172e00310117d292e7265706c616365282f5c5c2f2f672c30b3206d123b636f6e737420613d28742c652c61293d3e7b8011006ee001db0263726520b5a172014e5320af11687474703a2f2f7777772e77332e6f72672f307e01302f346a208c055c22616e696d2031005453d453224067026e2e73e005f30061c0ff024e616d20f720360074e0142f5f3c20260074e00a4a016475351e022c612b2098e00c6a20f920c103436f756e412c025c226981490069616fe009999f4920510065e00a1c0261646434a70076408a33f8007560db0172653f85046e206e7d3be200a3057175657279537571046f72416c6c21340023346401292e210f064561636828286520ca053d3e5b5b7b7421a760fa006c213320750069200f24b4002c2003003b200600326005400c032d31352c4005600d2028006420285277017d2c604374852016403f03312c313b2664002c2003003b2005e0030b202160380135352039015d2ce00d7f2063207d606a207f4007208504352c31353b6018601ea0482050e01080003220800032a080e0000ba037002e34e0e0107f406f4075208400326102012d352102003540060035a011201cc00a208e202c2011c093605be12215e0099c611c035d5b745de100b011743d3e652e617070656e644368696c64286123c704742c742e6920030164292000a34b0063a34b032c6e3d3221e10c7b696628743c6129742b3d3234a22a00282597062b652f3630292f22348370006de001362017203744d009723d742a36302b652b61202ca03c072e3030352b282e30278f20090b292a282872256e3c6e2f323f2007023a6e2d200502292f28200f012929c05b01753d20bd60500065e40085032c613d65454a06486f757273282920ad600e024d696e24932010003b20b70d613e3d32307c7c613c36297b692e7791002ed5170031657106723d283138302b2003022a632820f222ae21b400292095004d38bb032e50492f201a204be307fd62f0230b233f012c60600c42fd0728247b2d3330302a603b07636f732872297d2c2013043132302b36a0160273696e4016072960297d656c7365e00897003040b8026f296fe0077147ab024672652398026e63792075006d60ae60f3055365636f6e6420f3213180f50a31392626613c3231297b73e008f60064e00711002d80f901313980910020804201323141380235297be0072f0030e00041390d0042590c004d390b27e626f801656536b460d7a045003540870037e0094480720035e004710037402b0039e009b2e00780c0b00037e0043d60f10031206ae007f1e0073ee010bf036c69676826e8a0c0e0184780c22071007d619502737441663604696f6e4672261201287522be0069e107c5622ae20937053630302c20302213013b7522b9015d5d2860214d0b6970743e3c2f7376673e225d\\\";\\n}\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `smallString` must be null terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\\n        if (smallString == bytes32(0)) return result;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} 1 {} {\\n                n := add(n, 1)\\n                if iszero(byte(n, smallString)) { break } // Scan for '\\\\0'.\\n            }\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, smallString)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\\n    /// `b` must be null terminated, or behavior will be undefined.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let x := and(b, add(not(b), 1))\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibPRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\nlibrary LibPRNG {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\n                    mstore8(3, mload(and(input, 0x3F)))\\n                    mstore(ptr, mload(0x00))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\n                let o := div(2, mod(dataLength, 3))\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\n                // Set `o` to zero if there is padding.\\n                o := mul(iszero(iszero(noPadding)), o)\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                for {} 1 {} {\\n                    // If padded.\\n                    if iszero(and(dataLength, 3)) {\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\n                        // forgefmt: disable-next-item\\n                        decodedLength := sub(\\n                            decodedLength,\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\n                        )\\n                        break\\n                    }\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                    break\\n                }\\n                result := mload(0x40)\\n\\n                // Write the length of the bytes.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, decodedLength)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    // forgefmt: disable-next-item\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n                    ptr := add(ptr, 3)\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\n                mstore(0x60, 0) // Restore the zero slot.\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"external/ERC721Psi/extension/ERC721PsiBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n  ______ _____   _____ ______ ___  __ _  _  _ \\n |  ____|  __ \\\\ / ____|____  |__ \\\\/_ | || || |\\n | |__  | |__) | |        / /   ) || | \\\\| |/ |\\n |  __| |  _  /| |       / /   / / | |\\\\_   _/ \\n | |____| | \\\\ \\\\| |____  / /   / /_ | |  | |   \\n |______|_|  \\\\_\\\\\\\\_____|/_/   |____||_|  |_|   \\n                                              \\n                                            \\n */\\npragma solidity ^0.8.0;\\n\\nimport \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport \\\"../ERC721Psi.sol\\\";\\n\\nabstract contract ERC721PsiBurnable is ERC721Psi {\\n    using LibBitmap for LibBitmap.Bitmap;\\n    LibBitmap.Bitmap private _burnedToken;\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address from = ownerOf(tokenId);\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n        _burnedToken.set(tokenId);\\n        \\n        emit Transfer(from, address(0), tokenId);\\n\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view override virtual returns (bool){\\n        if(_burnedToken.get(tokenId)) {\\n            return false;\\n        } \\n        return super._exists(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        if (_burnedToken.get(tokenId)) {\\n            return address(0);\\n        }\\n        else {\\n            return super.ownerOf(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _currentIndex - _burned() - _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns number of token burned.\\n     */\\n    function _burned() internal view returns (uint256 burned){\\n        return _burnedToken.popCount( _startTokenId(), _totalMinted());\\n    }\\n}\"\r\n    },\r\n    \"external/ERC721Psi/ERC721Psi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n  ______ _____   _____ ______ ___  __ _  _  _ \\n |  ____|  __ \\\\ / ____|____  |__ \\\\/_ | || || |\\n | |__  | |__) | |        / /   ) || | \\\\| |/ |\\n |  __| |  _  /| |       / /   / / | |\\\\_   _/ \\n | |____| | \\\\ \\\\| |____  / /   / /_ | |  | |   \\n |______|_|  \\\\_\\\\\\\\_____|/_/   |____||_|  |_|   \\n\\n - github: https://github.com/estarriolvetch/ERC721Psi\\n - npm: https://www.npmjs.com/package/erc721psi\\n\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport \\\"./interface/IERC721Psi.sol\\\";\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721Psi__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ncontract ERC721Psi is IERC721Psi {\\n    \\n    using Address for address;\\n    using Strings for uint256;\\n    using LibBitmap for LibBitmap.Bitmap;\\n\\n    LibBitmap.Bitmap private _batchHead;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) internal _owners;\\n    uint256 internal _currentIndex;\\n\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        return _currentIndex - _startTokenId();\\n    }\\n\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) \\n        public \\n        view \\n        virtual \\n        override \\n        returns (uint) \\n    {\\n        if(owner == address(0)) revert BalanceQueryForZeroAddress();\\n\\n        uint count;\\n        for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){\\n            if(_exists(i)){\\n                if( owner == ownerOf(i)){\\n                    ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        (address owner, ) = _ownerAndBatchHeadOf(tokenId);\\n        return owner;\\n    }\\n\\n    function _ownerAndBatchHeadOf(uint256 tokenId) internal view returns (address owner, uint256 tokenIdBatchHead){\\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\\n        tokenIdBatchHead = _getBatchHead(tokenId);\\n        owner = _owners[tokenIdBatchHead];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if( !_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721Psi() != owner) {\\n            if (!isApprovedForAll(owner, _msgSenderERC721Psi())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address) \\n    {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, 1, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return tokenId < _nextTokenId() && _startTokenId() <= tokenId;\\n    }\\n\\n    error OperatorQueryForNonexistentToken();\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        if (!_exists(tokenId)) revert OperatorQueryForNonexistentToken();\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, \\\"\\\");\\n    }\\n\\n    \\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n        uint256 end = _currentIndex;\\n        if (!_checkOnERC721Received(address(0), to, end - quantity, quantity, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n        // Reentrancy protection.\\n        if (_currentIndex != end) revert();\\n    }\\n\\n\\n    function _mint(\\n        address to,\\n        uint256 quantity\\n    ) internal virtual {\\n        uint256 nextTokenId = _nextTokenId();\\n        \\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (to == address(0)) revert MintToZeroAddress();\\n        \\n        _beforeTokenTransfers(address(0), to, nextTokenId, quantity);\\n        _currentIndex += quantity;\\n        _owners[nextTokenId] = to;\\n        _batchHead.set(nextTokenId);\\n\\n        uint256 toMasked;\\n        uint256 end = nextTokenId + quantity;\\n\\n        // Use assembly to loop and emit the `Transfer` event for gas savings.\\n        // The duplicated `log4` removes an extra check and reduces stack juggling.\\n        // The assembly, together with the surrounding Solidity code, have been\\n        // delicately arranged to nudge the compiler into producing optimized opcodes.\\n        assembly {\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            toMasked := and(to, _BITMASK_ADDRESS)\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                0, // `address(0)`.\\n                toMasked, // `to`.\\n                nextTokenId // `tokenId`.\\n            )\\n\\n            // The `iszero(eq(,))` check ensures that large values of `quantity`\\n            // that overflows uint256 will make the loop run out of gas.\\n            // The compiler will optimize the `iszero` away for performance.\\n            for {\\n                let tokenId := add(nextTokenId, 1)\\n            } iszero(eq(tokenId, end)) {\\n                tokenId := add(tokenId, 1)\\n            } {\\n                // Emit the `Transfer` event. Similar to above.\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n            }\\n        }\\n\\n        _afterTokenTransfers(address(0), to, nextTokenId, quantity);\\n    }\\n\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n\\n        (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);\\n\\n        if (owner != from) revert TransferFromIncorrectOwner();\\n\\n        if (!_isApprovedOrOwner(_msgSenderERC721Psi(), tokenId)) {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);   \\n\\n        uint256 subsequentTokenId = tokenId + 1;\\n\\n        if(!_batchHead.get(subsequentTokenId) &&  \\n            subsequentTokenId < _nextTokenId()\\n        ) {\\n            _owners[subsequentTokenId] = from;\\n            _batchHead.set(subsequentTokenId);\\n        }\\n\\n        _owners[tokenId] = to;\\n        if(tokenId != tokenIdBatchHead) {\\n            _batchHead.set(tokenId);\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param startTokenId uint256 the first ID of the tokens to be transferred\\n     * @param quantity uint256 amount of the tokens to be transfered.\\n     * @param _data bytes optional data to send along with the call\\n     * @return r bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) private returns (bool r) {\\n        /// @dev removed isContract() in v5.0 but their ERC721 uses this check:\\n        if (to.code.length > 0) {\\n            r = true;\\n            for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){\\n                try ERC721Psi__IERC721Receiver(to).onERC721Received( _msgSenderERC721Psi(), from, tokenId, _data) returns (bytes4 retval) {\\n                    r = r && retval == ERC721Psi__IERC721Receiver.onERC721Received.selector;\\n                } catch (bytes memory reason) {\\n                    if (reason.length == 0) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    } else {\\n                        assembly {\\n                            revert(add(32, reason), mload(reason))\\n                        }\\n                    }\\n                }\\n            }\\n            return r;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {\\n        tokenIdBatchHead = _batchHead.findLastSet(tokenId); \\n    }\\n\\n\\n    function totalSupply() public virtual override view returns (uint256) {\\n        return _totalMinted();\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * This function is compatiable with ERC721AQueryable.\\n     */\\n    function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                if (_exists(i)) {\\n                    if (ownerOf(i) == owner) {\\n                        tokenIds[tokenIdsIdx++] = i;\\n                    }\\n                }\\n            }\\n            return tokenIds;   \\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721Psi() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"solady/src/utils/LibBitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibBit} from \\\"./LibBit.sol\\\";\\n\\n/// @notice Library for storage of packed unsigned booleans.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\\nlibrary LibBitmap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when a bitmap scan does not find a result.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\\n        // Both cost the same amount of gas, but the former allows the returned value\\n        // to be reused without cleaning the upper bits.\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            isSet := b\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to true.\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to false.\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n\\n    /// @dev Flips the bit at `index` in `bitmap`.\\n    /// Returns the boolean result of the flipped bit.\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let shift := and(index, 0xff)\\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\\n            // It makes sense to return the `newIsSet`,\\n            // as it allow us to skip an additional warm `sload`,\\n            // and it costs minimal gas (about 15),\\n            // which may be optimized away if the returned value is unused.\\n            newIsSet := and(1, shr(shift, storageValue))\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let storageValue := sload(storageSlot)\\n            let shift := and(index, 0xff)\\n            sstore(\\n                storageSlot,\\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), max)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\n        }\\n    }\\n\\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), 0)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns number of set bits within a range by\\n    /// scanning `amount` of bits starting from the bit at `start`.\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 count)\\n    {\\n        unchecked {\\n            uint256 bucket = start >> 8;\\n            uint256 shift = start & 0xff;\\n            if (!(amount + shift < 257)) {\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\n                amount = (amount + shift) & 0xff;\\n                shift = 0;\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\n                }\\n            }\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\n        }\\n    }\\n\\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\\n    /// If no set bit is found, returns `NOT_FOUND`.\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\n        internal\\n        view\\n        returns (uint256 setBitIndex)\\n    {\\n        uint256 bucket;\\n        uint256 bucketBits;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            setBitIndex := not(0)\\n            bucket := shr(8, before)\\n            mstore(0x00, bucket)\\n            mstore(0x20, bitmap.slot)\\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\n            if iszero(or(bucketBits, iszero(bucket))) {\\n                for {} 1 {} {\\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\\n                    mstore(0x00, bucket)\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\n                    if or(bucketBits, iszero(bucket)) { break }\\n                }\\n            }\\n        }\\n        if (bucketBits != 0) {\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interface/IFortuneTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\ninterface IFortuneTeller {\\n    function revealFortune(uint256 fortune) external view returns (string[] memory);\\n    function revealCurse(uint256 curse) external view returns (string[] memory);\\n}\\n\"\r\n    },\r\n    \"Binding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {IBinding} from \\\"./interface/IBinding.sol\\\";\\n\\ncontract Binding is IBinding, AccessControl {\\n\\n    bytes32 public constant CRYPTAR_ROLE = keccak256(\\\"CRYPTAR_ROLE\\\");\\n\\n    constructor() {\\n        // Assign the default admin role to the contract deployer\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        _checkRole(DEFAULT_ADMIN_ROLE);\\n        _;\\n    }\\n\\n    modifier onlyCryptar() {\\n        _checkRole(CRYPTAR_ROLE);\\n        _;\\n    }\\n\\n    function bindCryptar(address cryptar) external onlyAdmin {\\n        _grantRole(CRYPTAR_ROLE, cryptar);\\n    }\\n\\n    function transferOwnership(address newAdmin) external onlyAdmin {\\n        if(newAdmin == address(0)) revert InvalidTransferOwnership();\\n        revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibZip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for compressing and decompressing bytes.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\\n///\\n/// @dev Note:\\n/// The accompanying solady.js library includes implementations of\\n/// FastLZ and calldata operations for convenience.\\nlibrary LibZip {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     FAST LZ OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // LZ77 implementation based on FastLZ.\\n    // Equivalent to level 1 compression and decompression at the following commit:\\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\\n    // Decompression is backwards compatible.\\n\\n    /// @dev Returns the compressed `data`.\\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function ms8(d_, v_) -> _d {\\n                mstore8(d_, v_)\\n                _d := add(d_, 1)\\n            }\\n            function u24(p_) -> _u {\\n                let w := mload(p_)\\n                _u := or(shl(16, byte(2, w)), or(shl(8, byte(1, w)), byte(0, w)))\\n            }\\n            function cmp(p_, q_, e_) -> _l {\\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\\n                }\\n            }\\n            function literals(runs_, src_, dest_) -> _o {\\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\\n                    mstore(ms8(_o, 31), mload(src_))\\n                    _o := add(_o, 0x21)\\n                    src_ := add(src_, 0x20)\\n                }\\n                if iszero(runs_) { leave }\\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\\n                _o := add(1, add(_o, runs_))\\n            }\\n            function match(l_, d_, o_) -> _o {\\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\\n                }\\n                if iszero(lt(l_, 7)) {\\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\\n                    leave\\n                }\\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\\n            }\\n            function setHash(i_, v_) {\\n                let p := add(mload(0x40), shl(2, i_))\\n                mstore(p, xor(mload(p), shl(224, xor(shr(224, mload(p)), v_))))\\n            }\\n            function getHash(i_) -> _h {\\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\\n            }\\n            function hash(v_) -> _r {\\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\\n            }\\n            function setNextHash(ip_, ipStart_) -> _ip {\\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\\n                _ip := add(ip_, 1)\\n            }\\n            codecopy(mload(0x40), codesize(), 0x8000) // Zeroize the hashmap.\\n            let op := add(mload(0x40), 0x8000)\\n            let a := add(data, 0x20)\\n            let ipStart := a\\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\\n                let r := 0\\n                let d := 0\\n                for {} 1 {} {\\n                    let s := u24(ip)\\n                    let h := hash(s)\\n                    r := add(ipStart, getHash(h))\\n                    setHash(h, sub(ip, ipStart))\\n                    d := sub(ip, r)\\n                    if iszero(lt(ip, ipLimit)) { break }\\n                    ip := add(ip, 1)\\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\\n                }\\n                if iszero(lt(ip, ipLimit)) { break }\\n                ip := sub(ip, 1)\\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\\n                op := match(l, d, op)\\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\\n                a := ip\\n            }\\n            op := literals(sub(add(ipStart, mload(data)), a), a, op)\\n            result := mload(0x40)\\n            let t := add(result, 0x8000)\\n            let n := sub(op, t)\\n            mstore(result, n) // Store the length.\\n            // Copy the result to compact the memory, overwriting the hashmap.\\n            let o := add(result, 0x20)\\n            for { let i } lt(i, n) { i := add(i, 0x20) } { mstore(add(o, i), mload(add(t, i))) }\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := 0\\n            let end := add(add(data, 0x20), mload(data))\\n            result := mload(0x40)\\n            let op := add(result, 0x20)\\n            for { data := add(data, 0x20) } lt(data, end) {} {\\n                let w := mload(data)\\n                let c := byte(0, w)\\n                let t := shr(5, c)\\n                if iszero(t) {\\n                    mstore(add(op, n), mload(add(data, 1)))\\n                    data := add(data, add(2, c))\\n                    n := add(n, add(1, c))\\n                    continue\\n                }\\n                let g := eq(t, 7)\\n                let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w))))))\\n                for {\\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1)\\n                    let r := add(op, sub(n, s))\\n                    let o := add(op, n)\\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\\n                    let j := 0\\n                } 1 {} {\\n                    mstore(add(o, j), mload(add(r, j)))\\n                    j := add(j, f)\\n                    if iszero(lt(j, l)) { break }\\n                }\\n                data := add(data, add(2, g))\\n                n := add(n, l)\\n            }\\n            mstore(result, n) // Store the length.\\n            let o := add(add(result, 0x20), n)\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    CALLDATA OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Calldata compression and decompression using selective run length encoding:\\n    // - Sequences of 0x00 (up to 128 consecutive).\\n    // - Sequences of 0xff (up to 32 consecutive).\\n    //\\n    // A run length encoded block consists of two bytes:\\n    // (0) 0x00\\n    // (1) A control byte with the following bit layout:\\n    //     - [7]     `0: 0x00, 1: 0xff`.\\n    //     - [0..6]  `runLength - 1`.\\n    //\\n    // The first 4 bytes are bitwise negated so that the compressed calldata\\n    // can be dispatched into the `fallback` and `receive` functions.\\n\\n    /// @dev Returns the compressed `data`.\\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function rle(v_, o_, d_) -> _o, _d {\\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\\n                _o := add(o_, 2)\\n            }\\n            result := mload(0x40)\\n            let o := add(result, 0x20)\\n            let z := 0 // Number of consecutive 0x00.\\n            let y := 0 // Number of consecutive 0xff.\\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\\n                data := add(data, 1)\\n                let c := byte(31, mload(data))\\n                if iszero(c) {\\n                    if y { o, y := rle(0xff, o, y) }\\n                    z := add(z, 1)\\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\\n                    continue\\n                }\\n                if eq(c, 0xff) {\\n                    if z { o, z := rle(0x00, o, z) }\\n                    y := add(y, 1)\\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\\n                    continue\\n                }\\n                if y { o, y := rle(0xff, o, y) }\\n                if z { o, z := rle(0x00, o, z) }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            if y { o, y := rle(0xff, o, y) }\\n            if z { o, z := rle(0x00, o, z) }\\n            // Bitwise negate the first 4 bytes.\\n            mstore(add(result, 4), not(mload(add(result, 4))))\\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the decompressed `data`.\\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(data) {\\n                result := mload(0x40)\\n                let o := add(result, 0x20)\\n                let s := add(data, 4)\\n                let v := mload(s)\\n                let end := add(data, mload(data))\\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\\n                for {} lt(data, end) {} {\\n                    data := add(data, 1)\\n                    let c := byte(31, mload(data))\\n                    if iszero(c) {\\n                        data := add(data, 1)\\n                        let d := byte(31, mload(data))\\n                        // Fill with either 0xff or 0x00.\\n                        mstore(o, not(0))\\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                        o := add(o, add(and(d, 0x7f), 1))\\n                        continue\\n                    }\\n                    mstore8(o, c)\\n                    o := add(o, 1)\\n                }\\n                mstore(s, v) // Restore the first 4 bytes.\\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\\n                mstore(o, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev To be called in the `fallback` function.\\n    /// ```\\n    ///     fallback() external payable { LibZip.cdFallback(); }\\n    ///     receive() external payable {} // Silence compiler warning to add a `receive` function.\\n    /// ```\\n    /// For efficiency, this function will directly return the results, terminating the context.\\n    /// If called internally, it must be called at the end of the function.\\n    function cdFallback() internal {\\n        assembly {\\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\\n            let o := 0\\n            let f := not(3) // For negating the first 4 bytes.\\n            for { let i := 0 } lt(i, calldatasize()) {} {\\n                let c := byte(0, xor(add(i, f), calldataload(i)))\\n                i := add(i, 1)\\n                if iszero(c) {\\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\\n                    i := add(i, 1)\\n                    // Fill with either 0xff or 0x00.\\n                    mstore(o, not(0))\\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\\n                    o := add(o, add(and(d, 0x7f), 1))\\n                    continue\\n                }\\n                mstore8(o, c)\\n                o := add(o, 1)\\n            }\\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\\n            returndatacopy(0x00, 0x00, returndatasize())\\n            if iszero(success) { revert(0x00, returndatasize()) }\\n            return(0x00, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/JSONParserLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for parsing JSONs.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\\nlibrary JSONParserLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The input is invalid.\\n    error ParsingFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // There are 6 types of variables in JSON (excluding undefined).\\n\\n    /// @dev For denoting that an item has not been initialized.\\n    /// A item returned from `parse` will never be of an undefined type.\\n    /// Parsing a invalid JSON string will simply revert.\\n    uint8 internal constant TYPE_UNDEFINED = 0;\\n\\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\\n    uint8 internal constant TYPE_ARRAY = 1;\\n\\n    /// @dev Type representing an object (e.g. `{\\\"a\\\":\\\"A\\\",\\\"b\\\":\\\"B\\\"}`).\\n    uint8 internal constant TYPE_OBJECT = 2;\\n\\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\\n    uint8 internal constant TYPE_NUMBER = 3;\\n\\n    /// @dev Type representing a string (e.g. `\\\"hello\\\"`).\\n    uint8 internal constant TYPE_STRING = 4;\\n\\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\\n    uint8 internal constant TYPE_BOOLEAN = 5;\\n\\n    /// @dev Type representing null (i.e. `null`).\\n    uint8 internal constant TYPE_NULL = 6;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A pointer to a parsed JSON node.\\n    struct Item {\\n        // Do NOT modify the `_data` directly.\\n        uint256 _data;\\n    }\\n\\n    // Private constants for packing `_data`.\\n\\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\\n    uint256 private constant _BITMASK_TYPE = 7;\\n    uint256 private constant _KEY_INITED = 1 << 3;\\n    uint256 private constant _VALUE_INITED = 1 << 4;\\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   JSON PARSING OPERATION                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Parses the JSON string `s`, and returns the root.\\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\\n    /// in the same order which they appear in the JSON string.\\n    ///\\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\\n    /// The parsed tree WILL contain offsets to `s`.\\n    /// Do NOT pass in a string that WILL be modified later on.\\n    function parse(string memory s) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // We will use our own allocation instead.\\n        }\\n        bytes32 r = _query(_toInput(s), 255);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    JSON ITEM OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note:\\n    // - An item is a node in the JSON tree.\\n    // - The value of a string item WILL be double-quoted, JSON encoded.\\n    // - We make a distinction between `index` and `key`.\\n    //   - Items in arrays are located by `index` (uint256).\\n    //   - Items in objects are located by `key` (string).\\n    // - Keys are always strings, double-quoted, JSON encoded.\\n    //\\n    // These design choices are made to balance between efficiency and ease-of-use.\\n\\n    /// @dev Returns the string value of the item.\\n    /// This is its exact string representation in the original JSON string.\\n    /// The returned string WILL have leading and trailing whitespace trimmed.\\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function value(Item memory item) internal pure returns (string memory result) {\\n        bytes32 r = _query(_toInput(item), 0);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the index of the item in the array.\\n    /// It the item's parent is not an array, returns 0.\\n    function index(Item memory item) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if and(mload(item), _PARENT_IS_ARRAY) {\\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item's parent is not an object, returns an empty string.\\n    /// The returned string WILL be double-quoted, JSON encoded.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned string.\\n    /// Do NOT modify the returned string.\\n    function key(Item memory item) internal pure returns (string memory result) {\\n        if (item._data & _PARENT_IS_OBJECT != 0) {\\n            bytes32 r = _query(_toInput(item), 1);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := r\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the key of the item in the object.\\n    /// It the item is neither an array nor object, returns an empty array.\\n    ///\\n    /// Note: This function lazily instantiates and caches the returned array.\\n    /// Do NOT modify the returned array.\\n    function children(Item memory item) internal pure returns (Item[] memory result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := r\\n        }\\n    }\\n\\n    /// @dev Returns the number of children.\\n    /// It the item is neither an array nor object, returns zero.\\n    function size(Item memory item) internal pure returns (uint256 result) {\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(r)\\n        }\\n    }\\n\\n    /// @dev Returns the item at index `i` for (array).\\n    /// If `item` is not an array, the result's type WILL be undefined.\\n    /// If there is no item with the index, the result's type WILL be undefined.\\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n        }\\n        bytes32 r = _query(_toInput(item), 3);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(add(add(r, 0x20), shl(5, i)))\\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\\n                result := 0x60 // Reset to the zero pointer.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item at key `k` for (object).\\n    /// If `item` is not an object, the result's type WILL be undefined.\\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\\n    /// - Correct : `item.at('\\\"k\\\"')`.\\n    /// - Wrong   : `item.at(\\\"k\\\")`.\\n    /// For duplicated keys, the last item with the key WILL be returned.\\n    /// If there is no item with the key, the result's type WILL be undefined.\\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\\n            result := 0x60 // Initialize to the zero pointer.\\n        }\\n        if (isObject(item)) {\\n            bytes32 kHash = keccak256(bytes(k));\\n            Item[] memory r = children(item);\\n            // We'll just do a linear search. The alternatives are very bloated.\\n            for (uint256 i = r.length << 5; i != 0;) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    item := mload(add(r, i))\\n                    i := sub(i, 0x20)\\n                }\\n                if (keccak256(bytes(key(item))) != kHash) continue;\\n                result = item;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the item's type.\\n    function getType(Item memory item) internal pure returns (uint8 result) {\\n        result = uint8(item._data & _BITMASK_TYPE);\\n    }\\n\\n    /// Note: All types are mutually exclusive.\\n\\n    /// @dev Returns whether the item is of type undefined.\\n    function isUndefined(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\\n    }\\n\\n    /// @dev Returns whether the item is of type array.\\n    function isArray(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\\n    }\\n\\n    /// @dev Returns whether the item is of type object.\\n    function isObject(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\\n    }\\n\\n    /// @dev Returns whether the item is of type number.\\n    function isNumber(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\\n    }\\n\\n    /// @dev Returns whether the item is of type string.\\n    function isString(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\\n    }\\n\\n    /// @dev Returns whether the item is of type boolean.\\n    function isBoolean(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\\n    }\\n\\n    /// @dev Returns whether the item is of type null.\\n    function isNull(Item memory item) internal pure returns (bool result) {\\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\\n    }\\n\\n    /// @dev Returns the item's parent.\\n    /// If the item does not have a parent, the result's type will be undefined.\\n    function parent(Item memory item) internal pure returns (Item memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     UTILITY FUNCTIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\\n    /// or if the parsed number is too big for a uint256.\\n    function parseUint(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            let preMulOverflowThres := div(not(0), 10)\\n            for { let i := 0 } 1 {} {\\n                i := add(i, 1)\\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\\n                let mulOverflowed := gt(result, preMulOverflowThres)\\n                let product := mul(10, result)\\n                result := add(product, digit)\\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\\n    /// or if the parsed number is too big for a int256.\\n    function parseInt(string memory s) internal pure returns (int256 result) {\\n        uint256 n = bytes(s).length;\\n        uint256 sign;\\n        uint256 isNegative;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if n {\\n                let c := and(mload(add(s, 1)), 0xff)\\n                isNegative := eq(c, 45)\\n                if or(eq(c, 43), isNegative) {\\n                    sign := c\\n                    s := add(s, 1)\\n                    mstore(s, sub(n, 1))\\n                }\\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\\n            }\\n        }\\n        uint256 x = parseUint(s);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if shr(255, x) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if sign {\\n                mstore(s, sign)\\n                s := sub(s, 1)\\n                mstore(s, n)\\n            }\\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\\n        }\\n    }\\n\\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number is too big for a uint256.\\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(s)\\n            // Skip two if starts with '0x' or '0X'.\\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\\n            for {} 1 {} {\\n                i := add(i, 1)\\n                let c :=\\n                    byte(\\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\\n                        0x3010a071000000b0104040208000c05090d060e0f\\n                    )\\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\\n                result := add(shl(4, result), sub(c, 1))\\n                if iszero(lt(i, n)) { break }\\n            }\\n            if iszero(n) {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Decodes a JSON encoded string.\\n    /// The string MUST be double-quoted, JSON encoded.\\n    /// Reverts if the string is invalid.\\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\\n    function decodeString(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\\n                _pOut := add(pIn_, 4)\\n                let b_ := iszero(gt(_pOut, end_))\\n                let t_ := mload(pIn_) // Load the whole word.\\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\\n                    let c_ := sub(byte(i_, t_), 48)\\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\\n                    _unicode := add(shl(4, _unicode), c_)\\n                }\\n            }\\n\\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\\n                    let t_ := mload(_pOut) // Load the whole word.\\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\\\\\u'.\\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\\n                }\\n            }\\n\\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\\n                if iszero(gt(c_, 0x7f)) {\\n                    mstore8(pIn_, c_)\\n                    _pOut := add(pIn_, 1)\\n                    leave\\n                }\\n                mstore8(0x1f, c_)\\n                mstore8(0x1e, shr(6, c_))\\n                if iszero(gt(c_, 0x7ff)) {\\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 2)\\n                    leave\\n                }\\n                mstore8(0x1d, shr(12, c_))\\n                if iszero(gt(c_, 0xffff)) {\\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\\n                    _pOut := add(pIn_, 3)\\n                    leave\\n                }\\n                mstore8(0x1c, shr(18, c_))\\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            let n := mload(s)\\n            let end := add(add(s, n), 0x1f)\\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\\n                fail() // Fail if not double-quoted.\\n            }\\n            let out := add(mload(0x40), 0x20)\\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\\n                let c := chr(curr)\\n                curr := add(curr, 1)\\n                // Not '\\\\\\\\'.\\n                if iszero(eq(c, 92)) {\\n                    // Not '\\\"'.\\n                    if iszero(eq(c, 34)) {\\n                        mstore8(out, c)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    curr := end\\n                }\\n                if iszero(eq(curr, end)) {\\n                    let escape := chr(curr)\\n                    curr := add(curr, 1)\\n                    // '\\\"', '/', '\\\\\\\\'.\\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(escape, 117) {\\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\\n                        out := appendCodePointAsUTF8(out, escape)\\n                        continue\\n                    }\\n                    // `{'b':'\\\\b', 'f':'\\\\f', 'n':'\\\\n', 'r':'\\\\r', 't':'\\\\t'}`.\\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\\n                    if escape {\\n                        mstore8(out, escape)\\n                        out := add(out, 1)\\n                        continue\\n                    }\\n                }\\n                fail()\\n                break\\n            }\\n            mstore(out, 0) // Zeroize the last slot.\\n            result := mload(0x40)\\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Performs a query on the input with the given mode.\\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function fail() {\\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            function chr(p_) -> _c {\\n                _c := byte(0, mload(p_))\\n            }\\n\\n            function skipWhitespace(pIn_, end_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\\\n\\\\r\\\\t'.\\n                }\\n            }\\n\\n            function setP(packed_, bitpos_, p_) -> _packed {\\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\\n            }\\n\\n            function getP(packed_, bitpos_) -> _p {\\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\\n            }\\n\\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\\n                _item := mload(0x40)\\n                // forgefmt: disable-next-item\\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\\n                mstore(_item, or(packed_, type_))\\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\\n            }\\n\\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\\n                _pOut := skipWhitespace(pIn_, end_)\\n                if iszero(lt(_pOut, end_)) { leave }\\n                for { let c_ := chr(_pOut) } 1 {} {\\n                    // If starts with '\\\"'.\\n                    if eq(c_, 34) {\\n                        let pStart_ := _pOut\\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\\n                        break\\n                    }\\n                    // If starts with '['.\\n                    if eq(c_, 91) {\\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with '{'.\\n                    if eq(c_, 123) {\\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    // If starts with any in '0123456789-'.\\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\\n                        break\\n                    }\\n                    if iszero(gt(add(_pOut, 4), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(224, mload(_pOut))\\n                        // 'true' in hex format.\\n                        if eq(w_, 0x74727565) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                        // 'null' in hex format.\\n                        if eq(w_, 0x6e756c6c) {\\n                            _pOut := add(_pOut, 4)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\\n                            break\\n                        }\\n                    }\\n                    if iszero(gt(add(_pOut, 5), end_)) {\\n                        let pStart_ := _pOut\\n                        let w_ := shr(216, mload(_pOut))\\n                        // 'false' in hex format.\\n                        if eq(w_, 0x66616c7365) {\\n                            _pOut := add(_pOut, 5)\\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\\n                            break\\n                        }\\n                    }\\n                    fail()\\n                    break\\n                }\\n                _pOut := skipWhitespace(_pOut, end_)\\n            }\\n\\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                let j_ := 0\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 93) { break } // ']'.\\n                    }\\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\\n                    if _item {\\n                        // forgefmt: disable-next-item\\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\\n                            _BITPOS_KEY, j_))\\n                        j_ := add(j_, 1)\\n                        let c_ := chr(_pOut)\\n                        if eq(c_, 93) { break } // ']'.\\n                        if eq(c_, 44) { continue } // ','.\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\\n            }\\n\\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(_pOut, end_)) { fail() }\\n                    if iszero(_item) {\\n                        _pOut := skipWhitespace(_pOut, end_)\\n                        if eq(chr(_pOut), 125) { break } // '}'.\\n                    }\\n                    _pOut := skipWhitespace(_pOut, end_)\\n                    let pKeyStart_ := _pOut\\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\\n                    // If ':'.\\n                    if eq(chr(_pOut), 58) {\\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\\n                        if _item {\\n                            // forgefmt: disable-next-item\\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\\n                            let c_ := chr(_pOut)\\n                            if eq(c_, 125) { break } // '}'.\\n                            if eq(c_, 44) { continue } // ','.\\n                        }\\n                    }\\n                    _pOut := end_\\n                }\\n                _pOut := add(_pOut, 1)\\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\\n            }\\n\\n            function checkStringU(p_, o_) {\\n                // If not in '0123456789abcdefABCDEF', revert.\\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\\n            }\\n\\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\\n                if iszero(lt(pIn_, end_)) { fail() }\\n                for { _pOut := add(pIn_, 1) } 1 {} {\\n                    let c_ := chr(_pOut)\\n                    if eq(c_, 34) { break } // '\\\"'.\\n                    // Not '\\\\'.\\n                    if iszero(eq(c_, 92)) {\\n                        _pOut := add(_pOut, 1)\\n                        continue\\n                    }\\n                    c_ := chr(add(_pOut, 1))\\n                    // '\\\"', '\\\\', '//', 'b', 'f', 'n', 'r', 't'.\\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\\n                        _pOut := add(_pOut, 2)\\n                        continue\\n                    }\\n                    // 'u'.\\n                    if eq(c_, 117) {\\n                        checkStringU(_pOut, 2)\\n                        _pOut := add(_pOut, 6)\\n                        continue\\n                    }\\n                    _pOut := end_\\n                    break\\n                }\\n                if iszero(lt(_pOut, end_)) { fail() }\\n                _pOut := add(_pOut, 1)\\n            }\\n\\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\\n                }\\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\\n            }\\n\\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\\n                _pOut := pIn_\\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\\n                let c_ := chr(_pOut)\\n                _pOut := add(_pOut, 1)\\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\\n                let t_ := mload(_pOut)\\n                // 'E', 'e'.\\n                if eq(or(0x20, byte(0, t_)), 101) {\\n                    // forgefmt: disable-next-item\\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\\n                        add(_pOut, 1)), end_, 1)\\n                }\\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\\n            }\\n\\n            function copyStr(s_, offset_, len_) -> _sCopy {\\n                _sCopy := mload(0x40)\\n                s_ := add(s_, offset_)\\n                let w_ := not(0x1f)\\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\\n                    if iszero(i_) { break }\\n                }\\n                mstore(_sCopy, len_) // Copy the length.\\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\\n            }\\n\\n            function value(item_) -> _value {\\n                let packed_ := mload(item_)\\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\\n                if iszero(and(_VALUE_INITED, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\\n                    mstore(s_, or(_VALUE_INITED, packed_))\\n                }\\n            }\\n\\n            function children(item_) -> _arr {\\n                _arr := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\\n                    if or(iszero(packed_), iszero(item_)) { break }\\n                    if and(packed_, _CHILDREN_INITED) {\\n                        _arr := getP(packed_, _BITPOS_CHILD)\\n                        break\\n                    }\\n                    _arr := mload(0x40)\\n                    let o_ := add(_arr, 0x20)\\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\\n                        mstore(o_, h_)\\n                        let q_ := mload(h_)\\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\\n                        h_ := y_\\n                        o_ := add(o_, 0x20)\\n                    }\\n                    let w_ := not(0x1f)\\n                    let n_ := add(w_, sub(o_, _arr))\\n                    mstore(_arr, shr(5, n_))\\n                    mstore(0x40, o_) // Allocate memory.\\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\\n                    // Reverse the array.\\n                    if iszero(lt(n_, 0x40)) {\\n                        let lo_ := add(_arr, 0x20)\\n                        let hi_ := add(_arr, n_)\\n                        for {} 1 {} {\\n                            let temp_ := mload(lo_)\\n                            mstore(lo_, mload(hi_))\\n                            mstore(hi_, temp_)\\n                            hi_ := add(hi_, w_)\\n                            lo_ := add(lo_, 0x20)\\n                            if iszero(lt(lo_, hi_)) { break }\\n                        }\\n                    }\\n                    break\\n                }\\n            }\\n\\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\\n                _result := 0x60 // Initialize to the zero pointer.\\n                let packed_ := mload(item_)\\n                if or(iszero(item_), iszero(packed_)) { leave }\\n                _result := getP(packed_, bitpos_)\\n                if iszero(and(bitmaskInited_, packed_)) {\\n                    let s_ := getP(packed_, _BITPOS_STRING)\\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\\n                }\\n            }\\n\\n            switch mode\\n            // Get value.\\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\\n            // Get key.\\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\\n            // Get children.\\n            case 3 { result := children(input) }\\n            // Parse.\\n            default {\\n                let p := add(input, 0x20)\\n                let e := add(p, mload(input))\\n                if iszero(eq(p, e)) {\\n                    let c := chr(e)\\n                    mstore8(e, 34) // Place a '\\\"' at the end to speed up parsing.\\n                    // The `34 << 248` makes `mallocItem` preserve '\\\"' at the end.\\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\\n                    result, p := parseValue(input, 0, p, e)\\n                    mstore8(e, c) // Restore the original char at the end.\\n                }\\n                if or(lt(p, e), iszero(result)) { fail() }\\n            }\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(string memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n\\n    /// @dev Casts the input to a bytes32.\\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := input\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interface/IFortuneCard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\ninterface IFortuneCard {\\n    function revealFortuneCard(bool legendary) external view returns (string[] memory);\\n    function revealCursedCard(bool legendary) external view returns (string[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibBit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for bit twiddling and boolean operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\\nlibrary LibBit {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  BIT TWIDDLING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Find last set.\\n    /// Returns the index of the most significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Count leading zeros.\\n    /// Returns the number of zeros preceding the most significant one bit.\\n    /// If `x` is zero, returns 256.\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\\n        }\\n    }\\n\\n    /// @dev Find first set.\\n    /// Returns the index of the least significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `ctz` (count trailing zeros), which gives\\n    /// the number of zeros following the least significant one bit.\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Isolate the least significant bit.\\n            let b := and(x, add(not(x), 1))\\n\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\\n        }\\n    }\\n\\n    /// @dev Returns the number of set bits in `x`.\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let isMax := eq(x, max)\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\n            x := and(add(x, shr(4, x)), div(max, 17))\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\n        }\\n    }\\n\\n    /// @dev Returns whether `x` is a power of 2.\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `x && !(x & (x - 1))`.\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the bit level.\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if iszero(s) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the byte level.\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if eq(s, 4) { break }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     BOOLEAN OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\\n    // Non-zero values are true, zero is false.\\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\\n    // Usually, if not always, the bool result of a regular Solidity expression,\\n    // or the argument of a public/external function will be a clean bool.\\n    // You can usually use the raw variants for more performance.\\n    // If uncertain, test (best with exact compiler settings).\\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\\n\\n    /// @dev Returns `x & y`. Inputs must be clean.\\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`. Inputs must be clean.\\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\\n    function rawToUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := b\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0.\\n    function toUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"external/ERC721Psi/interface/IERC721Psi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of ERC721Psi.\\n */\\ninterface IERC721Psi {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"interface/IBinding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.23;\\n\\ninterface IBinding {\\n\\n    error InvalidTransferOwnership();\\n\\n    function bindCryptar(address cryptar) external;\\n\\n    function transferOwnership(address newAdmin) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_team\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_card\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorBurnTxPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorInvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintTxPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperatorQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fortuneId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"curseId\",\"type\":\"uint256\"}],\"name\":\"CryptarCursesYou\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fortuneId\",\"type\":\"uint256\"}],\"name\":\"CryptarSpeaks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fortuneId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setFortuneCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setFortuneTeller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"teamAddress\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Cryptar", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000eebe0b40e8000000000000000000000000000f97333766a80564286dbef73cfa553e6597f40d30000000000000000000000008c1a3ddab98a055a356fd58f3f89a118663bab0d000000000000000000000000e249e336c3a339299fa23980ca6ef4a4b330521a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}