{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/rewards/RewardVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {LinkTokenInterface} from \\\"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\\\";\\nimport {TypeAndVersionInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\\\";\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {FixedPointMathLib} from \\\"@solmate/utils/FixedPointMathLib.sol\\\";\\n\\nimport {IRewardVault} from \\\"../interfaces/IRewardVault.sol\\\";\\nimport {IStakingPool} from \\\"../interfaces/IStakingPool.sol\\\";\\nimport {PausableWithAccessControl} from \\\"../PausableWithAccessControl.sol\\\";\\nimport {CommunityStakingPool} from \\\"../pools/CommunityStakingPool.sol\\\";\\nimport {OperatorStakingPool} from \\\"../pools/OperatorStakingPool.sol\\\";\\n\\n/// @notice This contract is the reward vault for the staking pools. Admin can deposit rewards into\\n/// the vault and set the aggregate reward rate for each pool to control the reward distribution.\\n/// @dev This contract interacts with the community and operator staking pools that it is connected\\n/// to. A reward vault is connected to only one community and operator staking pool during its\\n/// lifetime, which means when we upgrade either one of the pools or introduce a new type of pool,\\n/// we will need to update this contract and deploy a new reward vault.\\n/// @dev invariant LINK balance of the contract is greater than or equal to the sum of unvested\\n/// rewards.\\n/// @dev invariant The sum of all stakers' rewards is less than or equal to the sum of available\\n/// rewards.\\n/// @dev invariant The reward bucket with zero aggregate reward rate has zero reward.\\n/// @dev invariant Stakers' multipliers are within 0 and the max value.\\n/// @dev We only support LINK token in v0.2 staking. Rebasing tokens, ERC777 tokens, fee-on-transfer\\n/// tokens or tokens that do not have 18 decimal places are not supported.\\ncontract RewardVault is IRewardVault, PausableWithAccessControl, TypeAndVersionInterface {\\n  using FixedPointMathLib for uint256;\\n  using SafeCast for uint256;\\n\\n  /// @notice This error is thrown when the pool address is not one of the registered staking pools\\n  error InvalidPool();\\n\\n  /// @notice This error is thrown when the reward amount is invalid when adding rewards\\n  error InvalidRewardAmount();\\n\\n  /// @notice This error is thrown when the aggregate reward rate is invalid when adding rewards\\n  error InvalidEmissionRate();\\n\\n  /// @notice This error is thrown when the delegation rate is invalid when setting delegation rate\\n  error InvalidDelegationRate();\\n\\n  /// @notice This error is thrown when an address who doesn't have access tries to call a function\\n  /// For example, when the caller is not a rewarder and adds rewards to the vault, or\\n  /// when the caller is not a staking pool and tries to call updateRewardPerToken.\\n  error AccessForbidden();\\n\\n  /// @notice This error is thrown whenever a zero-address is supplied when\\n  /// a non-zero address is required\\n  error InvalidZeroAddress();\\n\\n  /// @notice This error is thrown when the reward duration is too short when adding rewards\\n  error RewardDurationTooShort();\\n\\n  /// @notice this error is thrown when the rewards remaining are insufficient for the new\\n  /// delegation rate\\n  error InsufficentRewardsForDelegationRate();\\n\\n  /// @notice This error is thrown when calling an operation that is not allowed when the vault is\\n  /// closed.\\n  error VaultAlreadyClosed();\\n\\n  /// @notice This error is thrown when the staker tries to claim rewards and the staker has no\\n  /// rewards to claim.\\n  error NoRewardToClaim();\\n\\n  /// @notice This event is emitted when the delegation rate is updated.\\n  /// @param oldDelegationRate The old delegationRate\\n  /// @param newDelegationRate The new delegationRate\\n  event DelegationRateSet(uint256 oldDelegationRate, uint256 newDelegationRate);\\n\\n  /// @notice This event is emitted when rewards are added to the vault\\n  /// @param pool The pool to which the rewards are added\\n  /// @param amount The reward amount\\n  /// @param emissionRate The target aggregate reward rate (token/second)\\n  event RewardAdded(address indexed pool, uint256 amount, uint256 emissionRate);\\n\\n  /// @notice This event is emitted when the vault is opened.\\n  event VaultOpened();\\n\\n  /// @notice This event is emitted when the vault is closed.\\n  /// @param totalUnvestedRewards The total amount of unvested rewards at the\\n  /// time the vault was closed\\n  event VaultClosed(uint256 totalUnvestedRewards);\\n\\n  /// @notice This event is emitted when the staker claims rewards\\n  event RewardClaimed(address indexed staker, uint256 claimedRewards);\\n\\n  /// @notice This event is emitted when the forfeited rewards are shared back into the reward\\n  /// buckets.\\n  /// @param vestedReward The amount of forfeited rewards shared in juels\\n  /// @param vestedRewardPerToken The amount of forfeited rewards per token added.\\n  /// @param reclaimedReward The amount of forfeited rewards reclaimed.\\n  /// @param isOperatorReward True if the forfeited reward is from the operator staking pool.\\n  event ForfeitedRewardDistributed(\\n    uint256 vestedReward,\\n    uint256 vestedRewardPerToken,\\n    uint256 reclaimedReward,\\n    bool isOperatorReward\\n  );\\n\\n  /// @notice This event is emitted when the community pool rewards are updated\\n  /// @param baseRewardPerToken The per-token base reward of the community staking pool\\n  /// pool\\n  event CommunityPoolRewardUpdated(uint256 baseRewardPerToken);\\n\\n  /// @notice This event is emitted when the operator pool rewards are updated\\n  /// @param baseRewardPerToken The per-token base reward of the operator staking pool\\n  /// @param delegatedRewardPerToken The per-token delegated reward of the operator staking\\n  /// pool\\n  event OperatorPoolRewardUpdated(uint256 baseRewardPerToken, uint256 delegatedRewardPerToken);\\n\\n  /// @notice This event is emitted when a staker's rewards are updated\\n  /// @param staker The staker address\\n  /// @param vestedBaseReward The staker's vested base rewards\\n  /// @param vestedDelegatedReward The staker's vested delegated rewards\\n  /// @param baseRewardPerToken The staker's base reward per token\\n  /// @param operatorDelegatedRewardPerToken The staker's delegated reward per token\\n  /// @param claimedBaseRewardsInPeriod The staker's claimed base rewards in the period\\n  event StakerRewardUpdated(\\n    address indexed staker,\\n    uint256 vestedBaseReward,\\n    uint256 vestedDelegatedReward,\\n    uint256 baseRewardPerToken,\\n    uint256 operatorDelegatedRewardPerToken,\\n    uint256 claimedBaseRewardsInPeriod\\n  );\\n\\n  /// @notice This event is emitted when the staker rewards are finalized\\n  /// @param staker The staker address\\n  /// @param shouldForfeit True if the staker forfeited their rewards\\n  event RewardFinalized(address indexed staker, bool shouldForfeit);\\n\\n  /// @notice The constructor parameters.\\n  struct ConstructorParams {\\n    /// @notice The LINK token.\\n    LinkTokenInterface linkToken;\\n    /// @notice The community staking pool.\\n    CommunityStakingPool communityStakingPool;\\n    /// @notice The operator staking pool.\\n    OperatorStakingPool operatorStakingPool;\\n    /// @notice The delegation rate expressed in basis points. For example, a delegation rate of\\n    /// 4.5% would be represented as 450 basis points.\\n    uint32 delegationRate;\\n    /// @notice The time it takes for a multiplier to reach its max value in seconds.\\n    uint32 multiplierDuration;\\n    /// @notice The time it requires to transfer admin role\\n    uint48 adminRoleTransferDelay;\\n  }\\n\\n  /// @notice This struct is used to store the reward information for a reward bucket.\\n  struct RewardBucket {\\n    /// @notice The reward aggregate reward rate of the reward bucket in Juels/second.\\n    uint80 emissionRate;\\n    /// @notice The timestamp when the reward duration ends.\\n    uint80 rewardDurationEndsAt;\\n    /// @notice The last updated available reward per token of the reward bucket.\\n    /// This value only increases over time as more rewards vest to the\\n    /// stakers.\\n    uint80 vestedRewardPerToken;\\n  }\\n\\n  /// @notice This struct is used to store the reward buckets states.\\n  struct RewardBuckets {\\n    /// @notice The reward bucket for the operator staking pool.\\n    RewardBucket operatorBase;\\n    /// @notice The reward bucket for the community staking pool.\\n    RewardBucket communityBase;\\n    /// @notice The reward bucket for the delegated rewards.\\n    RewardBucket operatorDelegated;\\n  }\\n\\n  /// @notice This struct is used to store the vault config.\\n  struct VaultConfig {\\n    /// @notice The delegation rate expressed in basis points. For example, a delegation rate of\\n    /// 4.5% would be represented as 450 basis points.\\n    uint32 delegationRate;\\n    /// @notice Flag that signals if the reward vault is open\\n    bool isOpen;\\n  }\\n\\n  /// @notice This struct is used to store the checkpoint information at the time the reward vault\\n  /// is closed\\n  struct VestingCheckpointData {\\n    /// @notice The total staked LINK amount of the operator staking pool at the time\\n    /// the reward vault was closed\\n    uint256 operatorPoolTotalPrincipal;\\n    /// @notice The total staked LINK amount of the community staking pool at the time\\n    /// the reward vault was closed\\n    uint256 communityPoolTotalPrincipal;\\n    /// @notice The block number of at the time the reward vault was migrated or closed\\n    uint256 finalBlockNumber;\\n  }\\n\\n  /// @notice This struct is used for aggregating the return values of a function that calculates\\n  /// the reward aggregate reward rate splits.\\n  struct BucketRewardEmissionSplit {\\n    /// @notice The reward for the community staking pool\\n    uint256 communityReward;\\n    /// @notice The reward for the operator staking pool\\n    uint256 operatorReward;\\n    /// @notice The reward for the delegated staking pool\\n    uint256 operatorDelegatedReward;\\n    /// @notice The aggregate reward rate for the community staking pool\\n    uint256 communityRate;\\n    /// @notice The aggregate reward rate for the operator staking pool\\n    uint256 operatorRate;\\n    /// @notice The aggregate reward rate for the delegated staking pool\\n    uint256 delegatedRate;\\n  }\\n\\n  /// @notice This is the ID for the rewarder role, which is given to the\\n  /// addresses that will add rewards to the vault.\\n  /// @dev Hash: beec13769b5f410b0584f69811bfd923818456d5edcf426b0e31cf90eed7a3f6\\n  bytes32 public constant REWARDER_ROLE = keccak256(\\\"REWARDER_ROLE\\\");\\n  /// @notice The maximum possible value of a multiplier. Current implementation requires that this\\n  /// value is 1e18 (i.e. 100%).\\n  uint256 private constant MAX_MULTIPLIER = 1e18;\\n  /// @notice The denominator used to calculate the delegation rate.\\n  uint256 private constant DELEGATION_BASIS_POINTS_DENOMINATOR = 10000;\\n  /// @notice The multiplier ramp up period duration in seconds.\\n  uint256 private immutable i_multiplierDuration;\\n  /// @notice The LINK token\\n  LinkTokenInterface private immutable i_LINK;\\n  /// @notice The community staking pool.\\n  CommunityStakingPool private immutable i_communityStakingPool;\\n  /// @notice The operator staking pool.\\n  OperatorStakingPool private immutable i_operatorStakingPool;\\n  /// @notice The reward buckets.\\n  RewardBuckets private s_rewardBuckets;\\n  /// @notice The vault config.\\n  VaultConfig private s_vaultConfig;\\n  /// @notice The checkpoint information at the time the reward vault was closed\\n  VestingCheckpointData private s_finalVestingCheckpointData;\\n  /// @notice The packed timestamps of reward updates. First digits contain community reward\\n  /// update timestamp and last 18 digits contain operator timestamp, e.g., if both timestamps are\\n  /// 1_697_127_483_832 then the value would be 1_697_127_483_832_000_001_697_127_483_832.\\n  uint256 private s_packedRewardUpdateTimestamps;\\n  /// @notice Stores reward information for each staker\\n  mapping(address => StakerReward) private s_rewards;\\n\\n  constructor(ConstructorParams memory params)\\n    PausableWithAccessControl(params.adminRoleTransferDelay, msg.sender)\\n  {\\n    if (address(params.linkToken) == address(0)) revert InvalidZeroAddress();\\n    if (address(params.communityStakingPool) == address(0)) revert InvalidZeroAddress();\\n    if (address(params.operatorStakingPool) == address(0)) revert InvalidZeroAddress();\\n    if (params.delegationRate > DELEGATION_BASIS_POINTS_DENOMINATOR) revert InvalidDelegationRate();\\n\\n    i_multiplierDuration = params.multiplierDuration;\\n    i_LINK = params.linkToken;\\n    i_communityStakingPool = params.communityStakingPool;\\n    i_operatorStakingPool = params.operatorStakingPool;\\n\\n    s_vaultConfig.delegationRate = params.delegationRate;\\n    emit DelegationRateSet(0, params.delegationRate);\\n\\n    s_vaultConfig.isOpen = true;\\n    emit VaultOpened();\\n  }\\n\\n  /// @notice Adds more rewards into the reward vault\\n  /// Calculates the reward duration from the amount and aggregate reward rate\\n  /// @dev To add rewards to all pools use address(0) as the pool address\\n  /// @dev There is a possibility that a fraction of the added rewards can be locked in this\\n  /// contract as dust, specifically, when the amount is not divided by the aggregate reward rate\\n  /// evenly. We\\n  /// will handle this case operationally and make sure that the amount is large relative to the\\n  /// aggregate reward rate so there will only be small dust (less than 10^18 juels).\\n  /// @param pool The staking pool address\\n  /// @param amount The reward amount\\n  /// @param emissionRate The target aggregate reward rate (token/second)\\n  /// @dev precondition The caller must have the REWARDER role.\\n  /// @dev precondition This contract must be open and not paused.\\n  /// @dev precondition The caller must have at least `amount` LINK tokens.\\n  /// @dev precondition The caller must have approved this contract for the transfer of at least\\n  /// `amount` LINK tokens.\\n  function addReward(\\n    address pool,\\n    uint256 amount,\\n    uint256 emissionRate\\n  ) external onlyRewarder whenOpen whenNotPaused {\\n    // check if the pool is either community staking pool or operator staking pool\\n    // if the pool is the zero address, then the reward is split between all pools\\n    if (\\n      pool != address(0) && pool != address(i_communityStakingPool)\\n        && pool != address(i_operatorStakingPool)\\n    ) {\\n      revert InvalidPool();\\n    }\\n    // check that the aggregate reward rate is greater than zero\\n    if (emissionRate == 0) revert InvalidEmissionRate();\\n\\n    // update the reward per tokens\\n    _updateRewardPerToken();\\n\\n    // update the reward buckets\\n    _updateRewardBuckets({pool: pool, amount: amount, emissionRate: emissionRate});\\n\\n    // transfer the reward tokens to the reward vault\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transferFrom({from: msg.sender, to: address(this), value: amount});\\n\\n    emit RewardAdded(pool, amount, emissionRate);\\n  }\\n\\n  /// @notice Returns the delegation rate\\n  /// @return The delegation rate expressed in basis points\\n  function getDelegationRate() external view returns (uint256) {\\n    return s_vaultConfig.delegationRate;\\n  }\\n\\n  /// @notice Updates the delegation rate\\n  /// @param newDelegationRate The delegation rate.\\n  /// @dev precondition The caller must have the default admin role.\\n  function setDelegationRate(uint256 newDelegationRate) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    uint256 oldDelegationRate = s_vaultConfig.delegationRate;\\n    if (\\n      oldDelegationRate == newDelegationRate\\n        || newDelegationRate > DELEGATION_BASIS_POINTS_DENOMINATOR\\n    ) {\\n      revert InvalidDelegationRate();\\n    }\\n\\n    uint256 communityRateWithoutDelegation =\\n      s_rewardBuckets.communityBase.emissionRate + s_rewardBuckets.operatorDelegated.emissionRate;\\n\\n    uint256 delegatedRate = newDelegationRate == 0\\n      ? 0\\n      : communityRateWithoutDelegation * newDelegationRate / DELEGATION_BASIS_POINTS_DENOMINATOR;\\n\\n    if (delegatedRate == 0 && newDelegationRate != 0 && communityRateWithoutDelegation != 0) {\\n      // delegated rate has rounded down to zero\\n      revert InsufficentRewardsForDelegationRate();\\n    }\\n\\n    _updateRewardPerToken();\\n\\n    uint256 unvestedRewards = _getUnvestedRewards(s_rewardBuckets.communityBase)\\n      + _getUnvestedRewards(s_rewardBuckets.operatorDelegated);\\n    uint256 communityRate = communityRateWithoutDelegation - delegatedRate;\\n    s_rewardBuckets.communityBase.emissionRate = communityRate.toUint80();\\n    s_rewardBuckets.operatorDelegated.emissionRate = delegatedRate.toUint80();\\n\\n    // NOTE - the reward duration for both buckets need to be in sync.\\n    if (newDelegationRate == 0) {\\n      delete s_rewardBuckets.operatorDelegated.rewardDurationEndsAt;\\n      _updateRewardDurationEndsAt({\\n        bucket: s_rewardBuckets.communityBase,\\n        rewardAmount: unvestedRewards,\\n        emissionRate: communityRate\\n      });\\n    } else if (newDelegationRate == DELEGATION_BASIS_POINTS_DENOMINATOR) {\\n      delete s_rewardBuckets.communityBase.rewardDurationEndsAt;\\n      _updateRewardDurationEndsAt({\\n        bucket: s_rewardBuckets.operatorDelegated,\\n        rewardAmount: unvestedRewards,\\n        emissionRate: delegatedRate\\n      });\\n    } else if (unvestedRewards != 0) {\\n      uint256 delegatedRewards =\\n        unvestedRewards * newDelegationRate / DELEGATION_BASIS_POINTS_DENOMINATOR;\\n      uint256 communityRewards = unvestedRewards - delegatedRewards;\\n      _updateRewardDurationEndsAt({\\n        bucket: s_rewardBuckets.communityBase,\\n        rewardAmount: communityRewards,\\n        emissionRate: communityRate\\n      });\\n      _updateRewardDurationEndsAt({\\n        bucket: s_rewardBuckets.operatorDelegated,\\n        rewardAmount: delegatedRewards,\\n        emissionRate: delegatedRate\\n      });\\n    }\\n\\n    s_vaultConfig.delegationRate = newDelegationRate.toUint32();\\n\\n    emit DelegationRateSet(oldDelegationRate, newDelegationRate);\\n  }\\n\\n  // =================\\n  // IRewardVault\\n  // =================\\n\\n  /// @inheritdoc IRewardVault\\n  /// @dev precondition This contract must not be paused.\\n  /// @dev precondition The caller must be a staker with a non-zero reward.\\n  function claimReward() external whenNotPaused returns (uint256) {\\n    bool isOperator = _isOperator(msg.sender);\\n\\n    _updateRewardPerToken(isOperator ? StakerType.OPERATOR : StakerType.COMMUNITY);\\n\\n    IStakingPool stakingPool =\\n      isOperator ? IStakingPool(i_operatorStakingPool) : IStakingPool(i_communityStakingPool);\\n    uint256 stakerPrincipal = _getStakerPrincipal(msg.sender, stakingPool);\\n    StakerReward memory stakerReward = _calculateStakerReward({\\n      staker: msg.sender,\\n      isOperator: isOperator,\\n      stakerPrincipal: stakerPrincipal\\n    });\\n\\n    uint112 newVestedBaseRewards = _calculateNewVestedBaseRewards(\\n      stakerReward, _getMultiplier(_getStakerStakedAtTime(msg.sender, stakingPool))\\n    );\\n\\n    stakerReward.unvestedBaseReward -= newVestedBaseRewards;\\n    stakerReward.claimedBaseRewardsInPeriod += newVestedBaseRewards;\\n\\n    uint256 newVestedRewards = stakerReward.vestedBaseReward + newVestedBaseRewards;\\n    delete stakerReward.vestedBaseReward;\\n\\n    if (isOperator) {\\n      newVestedRewards += stakerReward.vestedDelegatedReward;\\n      delete stakerReward.vestedDelegatedReward;\\n    }\\n\\n    if (newVestedRewards == 0) {\\n      revert NoRewardToClaim();\\n    }\\n\\n    s_rewards[msg.sender] = stakerReward;\\n\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, newVestedRewards);\\n\\n    emit RewardClaimed(msg.sender, newVestedRewards);\\n    emit StakerRewardUpdated(\\n      msg.sender,\\n      0,\\n      0,\\n      stakerReward.baseRewardPerToken,\\n      stakerReward.operatorDelegatedRewardPerToken,\\n      stakerReward.claimedBaseRewardsInPeriod\\n    );\\n\\n    return newVestedRewards;\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  /// @dev precondition The caller must be a staking pool.\\n  function updateReward(address staker, uint256 stakerPrincipal) external onlyStakingPool {\\n    _updateRewardPerToken();\\n\\n    StakerReward memory stakerReward = _calculateStakerReward({\\n      staker: staker,\\n      isOperator: msg.sender == address(i_operatorStakingPool),\\n      stakerPrincipal: stakerPrincipal\\n    });\\n    s_rewards[staker] = stakerReward;\\n\\n    emit StakerRewardUpdated(\\n      staker,\\n      stakerReward.vestedBaseReward,\\n      stakerReward.vestedDelegatedReward,\\n      stakerReward.baseRewardPerToken,\\n      stakerReward.operatorDelegatedRewardPerToken,\\n      stakerReward.claimedBaseRewardsInPeriod\\n    );\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  /// @dev This applies any final logic such as the multipliers to the staker's newly accrued and\\n  /// stored rewards and store the value.\\n  /// @dev The caller staking pool must update the total staked LINK amount of the pool AFTER\\n  /// calling this\\n  /// function.\\n  /// @dev precondition The caller must be a staking pool.\\n  function concludeRewardPeriod(\\n    address staker,\\n    uint256 oldPrincipal,\\n    uint256 stakedAt,\\n    uint256 unstakedAmount,\\n    bool shouldForfeit\\n  ) external onlyStakingPool {\\n    // _isOperator is not used here to save gas.  The _isOperator function\\n    // currently checks for 2 things.  The first that the staker is currently\\n    // an operator and the other is that the staker is a removed operator.  As\\n    // this function will only be called by a staking pool, the contract can\\n    // safely assume that the staker is an operator if the msg.sender is the\\n    // operator staking pool as upgrading a pool/reward vault means that the operator\\n    // staking pool will point to a new reward vault.  Additionally the contract\\n    // assumes that it does not need to do the second check to determine whether\\n    // or not an operator had been removed as it is unlikely that an operator\\n    // is removed after the reward vault is closed.\\n    bool isOperator = msg.sender == address(i_operatorStakingPool);\\n\\n    _updateRewardPerToken(isOperator ? StakerType.OPERATOR : StakerType.COMMUNITY);\\n\\n    StakerReward memory stakerReward = _calculateStakerReward({\\n      staker: staker,\\n      isOperator: isOperator,\\n      stakerPrincipal: oldPrincipal\\n    });\\n\\n    uint112 newVestedBaseRewards =\\n      _calculateNewVestedBaseRewards(stakerReward, _getMultiplier(stakedAt));\\n\\n    stakerReward.unvestedBaseReward -= newVestedBaseRewards;\\n    stakerReward.vestedBaseReward += newVestedBaseRewards;\\n\\n    // claimedBaseRewardsInPeriod is reset as this function ends a\\n    // reward period for the staker.  This variable only tracks the amount\\n    // of rewards a staker has claimed within a period hence should only\\n    // accumulate from zero after this function is called.\\n    delete stakerReward.claimedBaseRewardsInPeriod;\\n\\n    if (!shouldForfeit) {\\n      return _storeRewardAndEmitEvents(staker, stakerReward, shouldForfeit);\\n    }\\n\\n    uint112 unvestedRewardAmount = stakerReward.unvestedBaseReward;\\n\\n    // The function terminates here as a staker that has reached the maximum\\n    // multiplier will not have any unvested rewards hence will not forfeit\\n    // anything.\\n    if (unvestedRewardAmount == 0) {\\n      return _storeRewardAndEmitEvents(staker, stakerReward, shouldForfeit);\\n    }\\n\\n    IStakingPool stakingPool =\\n      isOperator ? IStakingPool(i_operatorStakingPool) : IStakingPool(i_communityStakingPool);\\n\\n    uint256 remainingPoolPrincipal = _getTotalPrincipal(stakingPool) - oldPrincipal;\\n\\n    // This is the case when the last staker exits the pool.\\n    if (remainingPoolPrincipal == 0) {\\n      delete stakerReward.unvestedBaseReward;\\n      stakerReward.vestedBaseReward += unvestedRewardAmount;\\n      emit ForfeitedRewardDistributed(0, 0, unvestedRewardAmount, isOperator);\\n      return _storeRewardAndEmitEvents(staker, stakerReward, shouldForfeit);\\n    }\\n\\n    // This handles an edge case when an operator with 0 principal remaining (due to\\n    // slashing) gets removed and forfeits rewards. In this scenario, the reward vault will\\n    // forfeit the full amount of unclaimable rewards instead of calculating\\n    // the proportion of the unclaimable rewards that should be forfeited.\\n    // There is another case when forfeitedRewardAmount rounds down to 0, which is when a staker has\\n    // earned too little rewards and unstakes a very small amount. In this case, we do not forfeit\\n    // any rewards.\\n    uint256 forfeitedRewardAmount = oldPrincipal == 0\\n      ? unvestedRewardAmount\\n      : unvestedRewardAmount * unstakedAmount / oldPrincipal;\\n\\n    RewardBucket storage rewardBucket =\\n      isOperator ? s_rewardBuckets.operatorBase : s_rewardBuckets.communityBase;\\n\\n    uint256 redistributedRewardPerToken = forfeitedRewardAmount.divWadDown(remainingPoolPrincipal);\\n\\n    /// There is an extreme edge case where redistributedRewardPerToken may overflow\\n    /// because the remaining principal in a pool is an extremely small amount.\\n    /// This scenario is however extremely unlikely because there is a minimum\\n    /// staked amount for both the operator and community staking pools.\\n    /// Operators may be slashed so that the sum of remaining staked amounts\\n    /// is extremely small but this scenario is also unlikely to happen as\\n    /// it would mean multiple CL services going down at the same time.\\n    rewardBucket.vestedRewardPerToken += redistributedRewardPerToken.toUint80();\\n\\n    emit ForfeitedRewardDistributed(\\n      forfeitedRewardAmount, redistributedRewardPerToken, 0, isOperator\\n    );\\n\\n    // Update stakerRewardPerToken so that the staker doesn't benefit from redistributed\\n    // tokens\\n    _updateStakerRewardPerToken(stakerReward, isOperator);\\n\\n    stakerReward.unvestedBaseReward -= forfeitedRewardAmount.toUint112();\\n\\n    return _storeRewardAndEmitEvents(staker, stakerReward, shouldForfeit);\\n  }\\n\\n  /// @notice Updates a staker's reward data and emits events\\n  /// @param staker The address of the staker to update reward data for\\n  /// @param stakerReward The staker's new reward data\\n  /// @param shouldForfeit True if the staker has forfeited some unvested\\n  /// rewards\\n  function _storeRewardAndEmitEvents(\\n    address staker,\\n    StakerReward memory stakerReward,\\n    bool shouldForfeit\\n  ) internal {\\n    s_rewards[staker] = stakerReward;\\n\\n    emit RewardFinalized(staker, shouldForfeit);\\n    emit StakerRewardUpdated(\\n      staker,\\n      stakerReward.vestedBaseReward,\\n      stakerReward.vestedDelegatedReward,\\n      stakerReward.baseRewardPerToken,\\n      stakerReward.operatorDelegatedRewardPerToken,\\n      stakerReward.claimedBaseRewardsInPeriod\\n    );\\n  }\\n\\n  /// @notice Calculates new vested base rewards, taking into account the multiplier\\n  /// and the rewards that have already been claimed.\\n  /// @return New vested base rewards\\n  function _calculateNewVestedBaseRewards(\\n    StakerReward memory stakerReward,\\n    uint256 multiplier\\n  ) internal pure returns (uint112) {\\n    return uint256(stakerReward.unvestedBaseReward + stakerReward.claimedBaseRewardsInPeriod)\\n      .mulWadDown(multiplier).toUint112() - stakerReward.claimedBaseRewardsInPeriod;\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  /// @dev Withdraws any unvested LINK rewards to the owner's address.\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition This contract must be open.\\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\\n    (, uint256 totalUnvestedRewards,,,) = _stopVestingRewardsToBuckets();\\n    delete s_vaultConfig.isOpen;\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, totalUnvestedRewards);\\n    emit VaultClosed(totalUnvestedRewards);\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function getReward(address staker) external view returns (uint256) {\\n    // Determine if staker is operator or community\\n    bool isOperator = _isOperator(staker);\\n\\n    IStakingPool stakingPool =\\n      isOperator ? IStakingPool(i_operatorStakingPool) : IStakingPool(i_communityStakingPool);\\n\\n    uint256 stakerPrincipal = _getStakerPrincipal(staker, stakingPool);\\n\\n    (StakerReward memory stakerReward, uint256 forfeitedReward) =\\n      _getReward(staker, stakerPrincipal, isOperator);\\n\\n    (,, uint256 reclaimableReward) = _calculateForfeitedRewardDistribution(\\n      forfeitedReward, _getTotalPrincipal(stakingPool) - stakerPrincipal\\n    );\\n\\n    return stakerReward.vestedBaseReward + stakerReward.vestedDelegatedReward + reclaimableReward;\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function isOpen() external view returns (bool) {\\n    return s_vaultConfig.isOpen;\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function hasRewardDurationEnded(address stakingPool) external view returns (bool) {\\n    if (stakingPool == address(i_operatorStakingPool)) {\\n      return s_rewardBuckets.operatorBase.rewardDurationEndsAt <= block.timestamp\\n        && s_rewardBuckets.operatorDelegated.rewardDurationEndsAt <= block.timestamp;\\n    }\\n    if (stakingPool == address(i_communityStakingPool)) {\\n      return s_rewardBuckets.communityBase.rewardDurationEndsAt <= block.timestamp;\\n    }\\n\\n    revert InvalidPool();\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function hasRewardAdded() external view returns (bool) {\\n    return s_rewardBuckets.operatorBase.emissionRate != 0\\n      || s_rewardBuckets.communityBase.emissionRate != 0\\n      || s_rewardBuckets.operatorDelegated.emissionRate != 0;\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function getStoredReward(address staker) external view returns (StakerReward memory) {\\n    return s_rewards[staker];\\n  }\\n\\n  /// @notice Returns the reward buckets within this vault\\n  /// @return The reward buckets\\n  function getRewardBuckets() external view returns (RewardBuckets memory) {\\n    return s_rewardBuckets;\\n  }\\n\\n  /// @notice Returns the timestamp of the last reward per token update\\n  /// @return uint256 communityRewardUpdateTimestamp The timestamp of the last update\\n  /// @return uint256 operatorRewardUpdateTimestamp The timestamp of the last update\\n  function getRewardPerTokenUpdatedAt() external view returns (uint256, uint256) {\\n    return _getRewardUpdateTimestamps(s_packedRewardUpdateTimestamps);\\n  }\\n\\n  /// @notice Returns the multiplier ramp up time\\n  /// @return uint256 The multiplier ramp up time\\n  function getMultiplierDuration() external view returns (uint256) {\\n    return i_multiplierDuration;\\n  }\\n\\n  /// @notice Returns the ramp up multiplier of the staker\\n  /// @dev Multipliers are in the range of 0 and 1, so we multiply them by 1e18 (WAD) to preserve\\n  /// the decimals.\\n  /// @param staker The address of the staker\\n  /// @return uint256 The staker's multiplier\\n  function getMultiplier(address staker) external view returns (uint256) {\\n    IStakingPool stakingPool = _isOperator(staker)\\n      ? IStakingPool(i_operatorStakingPool)\\n      : IStakingPool(i_communityStakingPool);\\n\\n    return _getMultiplier(_getStakerStakedAtTime(staker, stakingPool));\\n  }\\n\\n  /// @notice Calculates and returns the latest reward info of the staker\\n  /// @param staker The staker address\\n  /// @return StakerReward The staker's reward info\\n  /// @return uint256 The staker's forfeited reward in juels\\n  function calculateLatestStakerReward(address staker)\\n    external\\n    view\\n    returns (StakerReward memory, uint256)\\n  {\\n    // Determine if staker is operator or community\\n    bool isOperator = _isOperator(staker);\\n\\n    IStakingPool stakingPool =\\n      isOperator ? IStakingPool(i_operatorStakingPool) : IStakingPool(i_communityStakingPool);\\n\\n    uint256 stakerPrincipal = _getStakerPrincipal(staker, stakingPool);\\n    return _getReward(staker, stakerPrincipal, isOperator);\\n  }\\n\\n  /// @notice Returns the final checkpoint data\\n  /// @return VestingCheckpointData The final checkpoint\\n  function getFinalVestingCheckpointData() external view returns (VestingCheckpointData memory) {\\n    return s_finalVestingCheckpointData;\\n  }\\n\\n  /// @notice Returns the unvested rewards\\n  /// @return unvestedCommunityBaseRewards The unvested community base rewards\\n  /// @return unvestedOperatorBaseRewards The unvested operator base rewards\\n  /// @return unvestedOperatorDelegatedRewards The unvested operator delegated rewards\\n  function getUnvestedRewards() external view returns (uint256, uint256, uint256) {\\n    uint256 unvestedCommunityBaseRewards = _getUnvestedRewards(s_rewardBuckets.communityBase);\\n    uint256 unvestedOperatorBaseRewards = _getUnvestedRewards(s_rewardBuckets.operatorBase);\\n    uint256 unvestedOperatorDelegatedRewards =\\n      _getUnvestedRewards(s_rewardBuckets.operatorDelegated);\\n    return\\n      (unvestedCommunityBaseRewards, unvestedOperatorBaseRewards, unvestedOperatorDelegatedRewards);\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function isPaused() external view returns (bool) {\\n    return paused();\\n  }\\n\\n  /// @inheritdoc IRewardVault\\n  function getStakingPools() external view override returns (address[] memory) {\\n    address[] memory stakingPools = new address[](2);\\n    stakingPools[0] = address(i_operatorStakingPool);\\n    stakingPools[1] = address(i_communityStakingPool);\\n    return stakingPools;\\n  }\\n\\n  // =========\\n  // Helpers\\n  // =========\\n\\n  /// @notice Stops rewards in all buckets from vesting and close the vault.\\n  /// @dev This will also checkpoint the staking pools\\n  /// @return uint256 The total aggregate reward rate from all three buckets\\n  /// @return uint256 The total amount of available rewards in juels\\n  /// @return uint256 The amount of available operator base rewards in juels\\n  /// @return uint256 The amount of available community base rewards in juels\\n  /// @return uint256 The amount of available operator delegated rewards in juels\\n  function _stopVestingRewardsToBuckets()\\n    private\\n    returns (uint256, uint256, uint256, uint256, uint256)\\n  {\\n    _updateRewardPerToken();\\n\\n    uint256 unvestedOperatorBaseRewards = _stopVestingBucketRewards(s_rewardBuckets.operatorBase);\\n    uint256 unvestedCommunityBaseRewards = _stopVestingBucketRewards(s_rewardBuckets.communityBase);\\n    uint256 unvestedOperatorDelegatedRewards =\\n      _stopVestingBucketRewards(s_rewardBuckets.operatorDelegated);\\n    uint256 totalUnvestedRewards =\\n      unvestedOperatorBaseRewards + unvestedCommunityBaseRewards + unvestedOperatorDelegatedRewards;\\n\\n    _checkpointStakingPools();\\n\\n    return (\\n      s_rewardBuckets.operatorBase.emissionRate + s_rewardBuckets.communityBase.emissionRate\\n        + s_rewardBuckets.operatorDelegated.emissionRate,\\n      totalUnvestedRewards,\\n      unvestedOperatorBaseRewards,\\n      unvestedCommunityBaseRewards,\\n      unvestedOperatorDelegatedRewards\\n    );\\n  }\\n\\n  /// @notice Returns the total staked LINK amount staked in a staking pool.  This will\\n  /// return the staking pool's latest total staked LINK amount if the vault has not been\\n  /// closed and the pool's total staked LINK amount at the time the vault was\\n  /// closed if the vault has already been closed.\\n  /// @param stakingPool The staking pool to query the total staked LINK amount for\\n  /// @return uint256 The total staked LINK amount staked in the staking pool\\n  function _getTotalPrincipal(IStakingPool stakingPool) private view returns (uint256) {\\n    return s_vaultConfig.isOpen\\n      ? stakingPool.getTotalPrincipal()\\n      : _getFinalTotalPoolPrincipal(stakingPool);\\n  }\\n\\n  /// @notice Returns the staker's staked LINK amount in a staking pool.  This will\\n  /// return the staker's latest staked LINK amount if the vault has not been\\n  /// closed and the staker's staked LINK amount at the time the vault was\\n  /// closed if the vault has already been closed.\\n  /// @param staker The staker to query the total staked LINK amount for\\n  /// @param stakingPool The staking pool to query the total staked LINK amount for\\n  /// @return uint256 The staker's staked LINK amount in the staking pool in juels\\n  function _getStakerPrincipal(\\n    address staker,\\n    IStakingPool stakingPool\\n  ) private view returns (uint256) {\\n    return s_vaultConfig.isOpen\\n      ? stakingPool.getStakerPrincipal(staker)\\n      : stakingPool.getStakerPrincipalAt(staker, s_finalVestingCheckpointData.finalBlockNumber);\\n  }\\n\\n  /// @notice Helper function to get a staker's current multiplier\\n  /// @param stakedAt The time the staker last staked at\\n  /// @return uint256 The staker's multiplier\\n  function _getMultiplier(uint256 stakedAt) private view returns (uint256) {\\n    if (stakedAt == 0) return 0;\\n\\n    if (!s_vaultConfig.isOpen) return MAX_MULTIPLIER;\\n\\n    uint256 multiplierDuration = i_multiplierDuration;\\n    if (multiplierDuration == 0) return MAX_MULTIPLIER;\\n\\n    return Math.min(\\n      FixedPointMathLib.divWadDown(block.timestamp - stakedAt, multiplierDuration), MAX_MULTIPLIER\\n    );\\n  }\\n\\n  /// @notice Returns the staker's staked at time in a staking pool.  This will\\n  /// return the staker's latest staked at time if the vault has not been\\n  /// closed and the staker's staked at time at the time the vault was\\n  /// closed if the vault has already been closed.\\n  /// @param staker The staker to query the staked at time for\\n  /// @param stakingPool The staking pool to query the staked at time for\\n  /// @return uint256 The staker's average staked at time in the staking pool\\n  function _getStakerStakedAtTime(\\n    address staker,\\n    IStakingPool stakingPool\\n  ) private view returns (uint256) {\\n    return s_vaultConfig.isOpen\\n      ? stakingPool.getStakerStakedAtTime(staker)\\n      : stakingPool.getStakerStakedAtTimeAt(staker, s_finalVestingCheckpointData.finalBlockNumber);\\n  }\\n\\n  /// @notice Return the staking pool's total staked LINK amount at the time the vault was\\n  /// closed\\n  /// @param stakingPool The staking pool to query the total staked LINK amount for\\n  /// @return uint256 The pool's total staked LINK amount at the time the vault was\\n  /// closed\\n  function _getFinalTotalPoolPrincipal(IStakingPool stakingPool) private view returns (uint256) {\\n    return address(stakingPool) == address(i_operatorStakingPool)\\n      ? s_finalVestingCheckpointData.operatorPoolTotalPrincipal\\n      : s_finalVestingCheckpointData.communityPoolTotalPrincipal;\\n  }\\n\\n  /// @notice Records the final block number and the total staked LINK amounts\\n  /// in the operator and community staking pools\\n  function _checkpointStakingPools() private {\\n    s_finalVestingCheckpointData.operatorPoolTotalPrincipal =\\n      i_operatorStakingPool.getTotalPrincipal();\\n    s_finalVestingCheckpointData.communityPoolTotalPrincipal =\\n      i_communityStakingPool.getTotalPrincipal();\\n    s_finalVestingCheckpointData.finalBlockNumber = block.number;\\n  }\\n\\n  /// @notice Stops rewards in a bucket from vesting\\n  /// @param bucket The bucket to stop vesting rewards for\\n  /// @return uint256 The amount of unvested rewards in juels\\n  function _stopVestingBucketRewards(RewardBucket storage bucket) private returns (uint256) {\\n    uint256 unvestedRewards = _getUnvestedRewards(bucket);\\n    bucket.rewardDurationEndsAt = block.timestamp.toUint80();\\n    return unvestedRewards;\\n  }\\n\\n  /// @notice Updates the reward buckets\\n  /// @param pool The staking pool address\\n  /// @param amount The reward amount\\n  /// @param emissionRate The target aggregate reward rate (Juels/second)\\n  function _updateRewardBuckets(address pool, uint256 amount, uint256 emissionRate) private {\\n    // split the reward and aggregate reward rate for the different reward buckets\\n    BucketRewardEmissionSplit memory emissionSplitData = _getBucketRewardAndEmissionRateSplit({\\n      pool: pool,\\n      amount: amount,\\n      emissionRate: emissionRate,\\n      isDelegated: s_vaultConfig.delegationRate != 0\\n    });\\n\\n    // If the aggregate reward rate is zero, we don't update the reward bucket\\n    // This is because we do not allow a zero aggregate reward rate\\n    // A zero aggregate reward rate means no rewards have been added\\n    if (emissionSplitData.communityRate != 0) {\\n      _updateRewardBucket({\\n        bucket: s_rewardBuckets.communityBase,\\n        amount: emissionSplitData.communityReward,\\n        emissionRate: emissionSplitData.communityRate\\n      });\\n    }\\n    if (emissionSplitData.operatorRate != 0) {\\n      _updateRewardBucket({\\n        bucket: s_rewardBuckets.operatorBase,\\n        amount: emissionSplitData.operatorReward,\\n        emissionRate: emissionSplitData.operatorRate\\n      });\\n    }\\n    if (emissionSplitData.delegatedRate != 0) {\\n      _updateRewardBucket({\\n        bucket: s_rewardBuckets.operatorDelegated,\\n        amount: emissionSplitData.operatorDelegatedReward,\\n        emissionRate: emissionSplitData.delegatedRate\\n      });\\n    }\\n  }\\n\\n  /// @notice Updates the reward bucket\\n  /// @param bucket The reward bucket\\n  /// @param amount The reward amount\\n  /// @param emissionRate The target aggregate reward rate (token/second)\\n  function _updateRewardBucket(\\n    RewardBucket storage bucket,\\n    uint256 amount,\\n    uint256 emissionRate\\n  ) private {\\n    // calculate the remaining rewards\\n    uint256 remainingRewards = _getUnvestedRewards(bucket);\\n\\n    // if the amount of rewards is less than what becomes available per second, we revert\\n    if (amount + remainingRewards < emissionRate) revert RewardDurationTooShort();\\n\\n    _updateRewardDurationEndsAt({\\n      bucket: bucket,\\n      rewardAmount: amount + remainingRewards,\\n      emissionRate: emissionRate\\n    });\\n    bucket.emissionRate = emissionRate.toUint80();\\n  }\\n\\n  /// @notice Updates the reward duration end time of the bucket\\n  /// @param bucket The reward bucket\\n  /// @param rewardAmount The reward amount\\n  /// @param emissionRate The aggregate reward rate\\n  function _updateRewardDurationEndsAt(\\n    RewardBucket storage bucket,\\n    uint256 rewardAmount,\\n    uint256 emissionRate\\n  ) private {\\n    if (emissionRate == 0) return;\\n    bucket.rewardDurationEndsAt = (block.timestamp + (rewardAmount / emissionRate)).toUint80();\\n  }\\n\\n  /// @notice Splits the reward and aggregate reward rates between the different reward buckets\\n  /// @dev If the pool is not targeted, the returned reward and aggregate reward rate will be zero\\n  /// @param pool The staking pool address (or zero address if the reward is split between all\\n  /// pools)\\n  /// @param amount The reward amount\\n  /// @param emissionRate The aggregate reward rate (juels/second)\\n  /// @param isDelegated Whether the reward is delegated or not\\n  /// @return BucketRewardEmissionSplit The rewards and aggregate reward rates after\\n  /// distributing the reward amount to the buckets\\n  function _getBucketRewardAndEmissionRateSplit(\\n    address pool,\\n    uint256 amount,\\n    uint256 emissionRate,\\n    bool isDelegated\\n  ) private view returns (BucketRewardEmissionSplit memory) {\\n    // when splitting reward and rate, a pool's share is 0 if it is not targeted by the pool\\n    // address,\\n    // otherwise it is the pool's max size\\n    // a pool's share is used to split rewards and aggregate reward rates proportionally\\n    uint256 communityPoolShare =\\n      pool != address(i_operatorStakingPool) ? i_communityStakingPool.getMaxPoolSize() : 0;\\n    uint256 operatorPoolShare =\\n      pool != address(i_communityStakingPool) ? i_operatorStakingPool.getMaxPoolSize() : 0;\\n    uint256 totalPoolShare = communityPoolShare + operatorPoolShare;\\n\\n    uint256 operatorReward;\\n    uint256 communityReward;\\n    uint256 operatorRate;\\n    uint256 communityRate;\\n    if (pool == address(i_operatorStakingPool)) {\\n      operatorReward = amount;\\n      operatorRate = emissionRate;\\n    } else if (pool == address(i_communityStakingPool)) {\\n      communityReward = amount;\\n      communityRate = emissionRate;\\n    } else {\\n      // prevent a possible rounding to zero error by validating inputs\\n      _checkForRoundingToZeroRewardAmountSplit({\\n        rewardAmount: amount,\\n        operatorPoolShare: operatorPoolShare,\\n        totalPoolShare: totalPoolShare\\n      });\\n      _checkForRoundingToZeroEmissionRateSplit({\\n        emissionRate: emissionRate,\\n        operatorPoolShare: operatorPoolShare,\\n        totalPoolShare: totalPoolShare\\n      });\\n\\n      operatorReward = amount * operatorPoolShare / totalPoolShare;\\n      operatorRate = emissionRate * operatorPoolShare / totalPoolShare;\\n\\n      communityReward = amount - operatorReward;\\n      communityRate = emissionRate - operatorRate;\\n    }\\n\\n    uint256 operatorDelegatedReward;\\n    uint256 delegatedRate;\\n    // if there is no delegation or the community pool is not targeted, the delegated reward and\\n    // rate is zero\\n    if (isDelegated && communityPoolShare != 0) {\\n      // calculate the delegated pool reward and remove from community reward\\n      operatorDelegatedReward =\\n        communityReward * s_vaultConfig.delegationRate / DELEGATION_BASIS_POINTS_DENOMINATOR;\\n      if (communityReward > 0 && operatorDelegatedReward == 0) revert InvalidRewardAmount();\\n      communityReward -= operatorDelegatedReward;\\n\\n      // calculate the delegated pool aggregate reward rate and remove from community rate\\n      delegatedRate =\\n        communityRate * s_vaultConfig.delegationRate / DELEGATION_BASIS_POINTS_DENOMINATOR;\\n      if (communityRate > 0 && delegatedRate == 0) revert InvalidEmissionRate();\\n      communityRate -= delegatedRate;\\n    }\\n\\n    return (\\n      BucketRewardEmissionSplit({\\n        communityReward: communityReward,\\n        operatorReward: operatorReward,\\n        operatorDelegatedReward: operatorDelegatedReward,\\n        communityRate: communityRate,\\n        operatorRate: operatorRate,\\n        delegatedRate: delegatedRate\\n      })\\n    );\\n  }\\n\\n  /// @notice Validates the added reward amount after splitting to avoid a rounding error when\\n  /// dividing\\n  /// @param rewardAmount The reward amount\\n  /// @param operatorPoolShare The size of the operator staking pool to take into account\\n  /// @param totalPoolShare The total size of the pools to take into account\\n  function _checkForRoundingToZeroRewardAmountSplit(\\n    uint256 rewardAmount,\\n    uint256 operatorPoolShare,\\n    uint256 totalPoolShare\\n  ) private pure {\\n    if (\\n      rewardAmount != 0\\n        && ((operatorPoolShare != 0 && rewardAmount * operatorPoolShare < totalPoolShare))\\n    ) {\\n      revert InvalidRewardAmount();\\n    }\\n  }\\n\\n  /// @notice Validates the aggregate reward rate after splitting to avoid a rounding error when\\n  /// dividing\\n  /// @param emissionRate The aggregate reward rate\\n  /// @param operatorPoolShare The size of the operator staking pool to take into account\\n  /// @param totalPoolShare The total size of the pools to take into account\\n  function _checkForRoundingToZeroEmissionRateSplit(\\n    uint256 emissionRate,\\n    uint256 operatorPoolShare,\\n    uint256 totalPoolShare\\n  ) private pure {\\n    if ((operatorPoolShare != 0 && emissionRate * operatorPoolShare < totalPoolShare)) {\\n      revert InvalidEmissionRate();\\n    }\\n  }\\n\\n  /// @notice Private util function to unpack and return reward update timestamps.\\n  /// @return uint256 communityRewardUpdateTimestamp\\n  /// @return uint256 operatorRewardUpdateTimestamp\\n  function _getRewardUpdateTimestamps(uint256 packedRewardUpdateTimestamps)\\n    private\\n    pure\\n    returns (uint256, uint256)\\n  {\\n    uint256 communityRewardUpdateTimestamp = packedRewardUpdateTimestamps / 1e18;\\n    uint256 operatorRewardUpdateTimestamp = packedRewardUpdateTimestamps % 1e18;\\n\\n    return (communityRewardUpdateTimestamp, operatorRewardUpdateTimestamp);\\n  }\\n\\n  /// @notice Private util function to pack and set reward update timestamps.\\n  function _setRewardUpdateTimestamps(\\n    uint256 communityRewardUpdateTimestamp,\\n    uint256 operatorRewardUpdateTimestamp\\n  ) private {\\n    s_packedRewardUpdateTimestamps =\\n      communityRewardUpdateTimestamp * 1e18 + operatorRewardUpdateTimestamp;\\n  }\\n\\n  /// @notice Private util function for updateRewardPerToken\\n  function _updateRewardPerToken() private {\\n    (uint256 communityRewardUpdateTimestamp, uint256 operatorRewardUpdateTimestamp) =\\n      _getRewardUpdateTimestamps(s_packedRewardUpdateTimestamps);\\n\\n    if (\\n      communityRewardUpdateTimestamp == block.timestamp\\n        && operatorRewardUpdateTimestamp == block.timestamp\\n    ) {\\n      // if the pools were previously updated in the same block there is no recalculation of reward\\n      return;\\n    }\\n\\n    (\\n      uint256 communityRewardPerToken,\\n      uint256 operatorRewardPerToken,\\n      uint256 operatorDelegatedRewardPerToken\\n    ) = _calculatePoolsRewardPerToken();\\n\\n    s_rewardBuckets.communityBase.vestedRewardPerToken = communityRewardPerToken.toUint80();\\n    s_rewardBuckets.operatorBase.vestedRewardPerToken = operatorRewardPerToken.toUint80();\\n    s_rewardBuckets.operatorDelegated.vestedRewardPerToken =\\n      operatorDelegatedRewardPerToken.toUint80();\\n\\n    _setRewardUpdateTimestamps(block.timestamp, block.timestamp);\\n    emit CommunityPoolRewardUpdated(communityRewardPerToken);\\n    emit OperatorPoolRewardUpdated(operatorRewardPerToken, operatorDelegatedRewardPerToken);\\n  }\\n\\n  /// @notice Private util function for updateRewardPerToken\\n  /// @param stakerType The staker type to update the reward for.\\n  function _updateRewardPerToken(StakerType stakerType) private {\\n    (uint256 communityRewardUpdateTimestamp, uint256 operatorRewardUpdateTimestamp) =\\n      _getRewardUpdateTimestamps(s_packedRewardUpdateTimestamps);\\n\\n    if (stakerType == StakerType.COMMUNITY) {\\n      if (communityRewardUpdateTimestamp == block.timestamp) {\\n        return;\\n      }\\n\\n      s_rewardBuckets.communityBase.vestedRewardPerToken = _calculateVestedRewardPerToken(\\n        s_rewardBuckets.communityBase,\\n        _getTotalPrincipal(i_communityStakingPool),\\n        communityRewardUpdateTimestamp\\n      ).toUint80();\\n\\n      _setRewardUpdateTimestamps(block.timestamp, operatorRewardUpdateTimestamp);\\n      emit CommunityPoolRewardUpdated(s_rewardBuckets.communityBase.vestedRewardPerToken);\\n    } else if (stakerType == StakerType.OPERATOR) {\\n      if (operatorRewardUpdateTimestamp == block.timestamp) {\\n        return;\\n      }\\n\\n      uint256 operatorTotalPrincipal = _getTotalPrincipal(i_operatorStakingPool);\\n      s_rewardBuckets.operatorBase.vestedRewardPerToken = _calculateVestedRewardPerToken(\\n        s_rewardBuckets.operatorBase, operatorTotalPrincipal, operatorRewardUpdateTimestamp\\n      ).toUint80();\\n      s_rewardBuckets.operatorDelegated.vestedRewardPerToken = _calculateVestedRewardPerToken(\\n        s_rewardBuckets.operatorDelegated, operatorTotalPrincipal, operatorRewardUpdateTimestamp\\n      ).toUint80();\\n\\n      _setRewardUpdateTimestamps(communityRewardUpdateTimestamp, block.timestamp);\\n      emit OperatorPoolRewardUpdated(\\n        s_rewardBuckets.operatorBase.vestedRewardPerToken,\\n        s_rewardBuckets.operatorDelegated.vestedRewardPerToken\\n      );\\n    }\\n  }\\n\\n  /// @notice Util function for calculating the current reward per token for the pools\\n  /// @return uint256 The community reward per token\\n  /// @return uint256 The operator reward per token\\n  /// @return uint256 The operator delegated reward per token\\n  function _calculatePoolsRewardPerToken() private view returns (uint256, uint256, uint256) {\\n    uint256 communityTotalPrincipal = _getTotalPrincipal(i_communityStakingPool);\\n    uint256 operatorTotalPrincipal = _getTotalPrincipal(i_operatorStakingPool);\\n    (uint256 communityRewardUpdateTimestamp, uint256 operatorRewardUpdateTimestamp) =\\n      _getRewardUpdateTimestamps(s_packedRewardUpdateTimestamps);\\n\\n    return (\\n      _calculateVestedRewardPerToken(\\n        s_rewardBuckets.communityBase, communityTotalPrincipal, communityRewardUpdateTimestamp\\n        ),\\n      _calculateVestedRewardPerToken(\\n        s_rewardBuckets.operatorBase, operatorTotalPrincipal, operatorRewardUpdateTimestamp\\n        ),\\n      _calculateVestedRewardPerToken(\\n        s_rewardBuckets.operatorDelegated, operatorTotalPrincipal, operatorRewardUpdateTimestamp\\n        )\\n    );\\n  }\\n\\n  /// @notice Calculate a bucket\u2019s available rewards earned per token\\n  /// @param rewardBucket The reward bucket to calculate the vestedRewardPerToken for\\n  /// @param totalPrincipal The total staked LINK amount staked in a pool associated with the reward\\n  /// bucket\\n  /// @return uint256 The available rewards earned per token\\n  function _calculateVestedRewardPerToken(\\n    RewardBucket memory rewardBucket,\\n    uint256 totalPrincipal,\\n    uint256 lastUpdateTimestamp\\n  ) private view returns (uint256) {\\n    if (totalPrincipal == 0) return rewardBucket.vestedRewardPerToken;\\n\\n    uint256 latestRewardEmittedAt = Math.min(rewardBucket.rewardDurationEndsAt, block.timestamp);\\n\\n    if (latestRewardEmittedAt <= lastUpdateTimestamp) {\\n      return rewardBucket.vestedRewardPerToken;\\n    }\\n\\n    uint256 elapsedTime = latestRewardEmittedAt - lastUpdateTimestamp;\\n\\n    return rewardBucket.vestedRewardPerToken\\n      + (elapsedTime * rewardBucket.emissionRate).divWadDown(totalPrincipal);\\n  }\\n\\n  /// @notice Calculates a stakers earned base reward\\n  /// @param stakerReward The staker's reward info\\n  /// @param stakerPrincipal The staker's staked LINK amount\\n  /// @param baseRewardPerToken The base reward per token of the staking pool\\n  /// @return uint256 The earned base reward\\n  function _calculateEarnedBaseReward(\\n    StakerReward memory stakerReward,\\n    uint256 stakerPrincipal,\\n    uint256 baseRewardPerToken\\n  ) private pure returns (uint256) {\\n    uint256 earnedBaseReward = _calculateAccruedReward({\\n      principal: stakerPrincipal,\\n      rewardPerToken: stakerReward.baseRewardPerToken,\\n      vestedRewardPerToken: baseRewardPerToken\\n    });\\n\\n    return earnedBaseReward;\\n  }\\n\\n  /// @notice Calculates an operator's earned delegated reward\\n  /// @param stakerReward The staker's reward info\\n  /// @param stakerPrincipal The staker's staked LINK amount\\n  /// @param operatorDelegatedRewardPerToken The operator delegated reward per token\\n  /// @return uint256 The earned delegated reward\\n  function _calculateEarnedDelegatedReward(\\n    StakerReward memory stakerReward,\\n    uint256 stakerPrincipal,\\n    uint256 operatorDelegatedRewardPerToken\\n  ) private pure returns (uint256) {\\n    uint256 earnedDelegatedReward = _calculateAccruedReward({\\n      principal: stakerPrincipal,\\n      rewardPerToken: stakerReward.operatorDelegatedRewardPerToken,\\n      vestedRewardPerToken: operatorDelegatedRewardPerToken\\n    });\\n\\n    return earnedDelegatedReward;\\n  }\\n\\n  /// @notice Calculates the newly accrued reward of a staker since the last time the staker's\\n  /// reward was updated\\n  /// @param principal The staker's staked LINK amount\\n  /// @param rewardPerToken The base or delegated reward per token of the staker\\n  /// @param vestedRewardPerToken The available reward per token of the staking pool\\n  /// @return uint256 The accrued reward amount\\n  function _calculateAccruedReward(\\n    uint256 principal,\\n    uint256 rewardPerToken,\\n    uint256 vestedRewardPerToken\\n  ) private pure returns (uint256) {\\n    return principal.mulWadDown(vestedRewardPerToken - rewardPerToken);\\n  }\\n\\n  /// @notice Calculates and updates a staker's rewards\\n  /// @param staker The staker's address\\n  /// @param isOperator True if the staker is an operator, false otherwise\\n  /// @param stakerPrincipal The staker's staked LINK amount\\n  /// @dev Staker rewards are forfeited when a staker unstakes before they\\n  /// have reached their maximum ramp up period multiplier.  Additionally an\\n  /// operator will also forfeit any unclaimed rewards if they are removed\\n  /// before they reach the maximum ramp up period multiplier.\\n  /// @return StakerReward The staker's updated reward info\\n  function _calculateStakerReward(\\n    address staker,\\n    bool isOperator,\\n    uint256 stakerPrincipal\\n  ) private view returns (StakerReward memory) {\\n    StakerReward memory stakerReward = s_rewards[staker];\\n\\n    if (stakerReward.stakerType != StakerType.NOT_STAKED) {\\n      // do nothing\\n    } else {\\n      stakerReward.stakerType = isOperator ? StakerType.OPERATOR : StakerType.COMMUNITY;\\n    }\\n\\n    // Calculate earned base rewards\\n    stakerReward.unvestedBaseReward += _calculateEarnedBaseReward({\\n      stakerReward: stakerReward,\\n      stakerPrincipal: stakerPrincipal,\\n      baseRewardPerToken: isOperator\\n        ? s_rewardBuckets.operatorBase.vestedRewardPerToken\\n        : s_rewardBuckets.communityBase.vestedRewardPerToken\\n    }).toUint112();\\n\\n    // Calculate earned delegated rewards if the staker is an operator\\n    if (isOperator) {\\n      // Multipliers do not apply to the delegation reward, i.e. always treat them as\\n      // multiplied by the max multiplier, which is 1.\\n      stakerReward.vestedDelegatedReward += _calculateEarnedDelegatedReward({\\n        stakerReward: stakerReward,\\n        stakerPrincipal: stakerPrincipal,\\n        operatorDelegatedRewardPerToken: s_rewardBuckets.operatorDelegated.vestedRewardPerToken\\n      }).toUint112();\\n    }\\n\\n    // Update the staker's earned reward per token\\n    _updateStakerRewardPerToken(stakerReward, isOperator);\\n\\n    return stakerReward;\\n  }\\n\\n  /// @notice Helper function for calculating the available reward per token and the reclaimable\\n  /// reward\\n  /// @dev If the pool the staker is in is empty and we can't calculate the reward per token, we\\n  /// allow the staker to reclaim the forfeited reward.\\n  /// @param forfeitedReward The amount of forfeited reward\\n  /// @param amountOfRecipientTokens The amount of tokens that the forfeited rewards should be\\n  /// shared to\\n  /// @return uint256 The amount of shared forfeited reward\\n  /// @return uint256 The shared forfeited reward per token\\n  /// @return uint256 The amount of reclaimable reward\\n  function _calculateForfeitedRewardDistribution(\\n    uint256 forfeitedReward,\\n    uint256 amountOfRecipientTokens\\n  ) private pure returns (uint256, uint256, uint256) {\\n    if (forfeitedReward == 0) return (0, 0, 0);\\n\\n    uint256 vestedReward;\\n    uint256 vestedRewardPerToken;\\n    uint256 reclaimableReward;\\n\\n    if (amountOfRecipientTokens != 0) {\\n      vestedReward = forfeitedReward;\\n      vestedRewardPerToken = forfeitedReward.divWadDown(amountOfRecipientTokens);\\n    } else {\\n      reclaimableReward = forfeitedReward;\\n    }\\n\\n    return (vestedReward, vestedRewardPerToken, reclaimableReward);\\n  }\\n\\n  /// @notice Updates the staker's base and/or delegated reward per token values\\n  /// @dev This function is called when staking, unstaking, claiming rewards, finalizing rewards for\\n  /// removed operators, and slashing operators.\\n  /// @param stakerReward The staker reward struct\\n  /// @param isOperator Whether the staker is an operator or not\\n  function _updateStakerRewardPerToken(\\n    StakerReward memory stakerReward,\\n    bool isOperator\\n  ) private view {\\n    if (isOperator) {\\n      stakerReward.baseRewardPerToken = s_rewardBuckets.operatorBase.vestedRewardPerToken;\\n      stakerReward.operatorDelegatedRewardPerToken =\\n        s_rewardBuckets.operatorDelegated.vestedRewardPerToken;\\n    } else {\\n      stakerReward.baseRewardPerToken = s_rewardBuckets.communityBase.vestedRewardPerToken;\\n    }\\n  }\\n\\n  /// @notice Calculates a staker's earned rewards\\n  /// @param staker The staker\\n  /// @return The staker reward info\\n  /// @return The forfeited reward\\n  function _getReward(\\n    address staker,\\n    uint256 stakerPrincipal,\\n    bool isOperator\\n  ) private view returns (StakerReward memory, uint256) {\\n    StakerReward memory stakerReward = s_rewards[staker];\\n\\n    // Calculate latest reward per token for the pools\\n    (\\n      uint256 communityRewardPerToken,\\n      uint256 operatorRewardPerToken,\\n      uint256 operatorDelegatedRewardPerToken\\n    ) = _calculatePoolsRewardPerToken();\\n\\n    // Calculate earned base rewards\\n    stakerReward.unvestedBaseReward += _calculateEarnedBaseReward({\\n      stakerReward: stakerReward,\\n      stakerPrincipal: stakerPrincipal,\\n      baseRewardPerToken: isOperator ? operatorRewardPerToken : communityRewardPerToken\\n    }).toUint112();\\n\\n    // If operator Calculate earned delegated rewards\\n    if (isOperator) {\\n      // Multipliers do not apply to the delegation reward, i.e. always treat them as\\n      // multiplied by the max multiplier, which is 1.\\n      stakerReward.vestedDelegatedReward += _calculateEarnedDelegatedReward({\\n        stakerReward: stakerReward,\\n        stakerPrincipal: stakerPrincipal,\\n        operatorDelegatedRewardPerToken: operatorDelegatedRewardPerToken\\n      }).toUint112();\\n    }\\n\\n    uint112 newVestedBaseRewards = _calculateNewVestedBaseRewards({\\n      stakerReward: stakerReward,\\n      multiplier: _getMultiplier(\\n        _getStakerStakedAtTime(\\n          staker,\\n          isOperator ? IStakingPool(i_operatorStakingPool) : IStakingPool(i_communityStakingPool)\\n        )\\n        )\\n    });\\n\\n    stakerReward.vestedBaseReward += newVestedBaseRewards;\\n    uint256 forfeitedRewards = stakerReward.unvestedBaseReward - newVestedBaseRewards;\\n\\n    // Forfeit rewards\\n    delete stakerReward.unvestedBaseReward;\\n\\n    return (stakerReward, forfeitedRewards);\\n  }\\n\\n  /// @notice Calculates the amount of unvested rewards in a reward bucket\\n  /// @param bucket The bucket to calculate unvested rewards for\\n  /// @return uint256 The amount of unvested rewards in the bucket\\n  function _getUnvestedRewards(RewardBucket memory bucket) private view returns (uint256) {\\n    return bucket.rewardDurationEndsAt <= block.timestamp\\n      ? 0\\n      : bucket.emissionRate * (bucket.rewardDurationEndsAt - block.timestamp);\\n  }\\n\\n  /// @notice Returns whether or not an address is currently an operator or\\n  /// is a removed operator\\n  /// @param staker The staker address\\n  /// @return bool True if the staker is either an operator or a removed operator.\\n  function _isOperator(address staker) private view returns (bool) {\\n    return i_operatorStakingPool.isOperator(staker) || i_operatorStakingPool.isRemoved(staker);\\n  }\\n\\n  // =========\\n  // Modifiers\\n  // =========\\n\\n  /// @dev Reverts if the msg.sender doesn't have the rewarder role.\\n  modifier onlyRewarder() {\\n    if (!hasRole(REWARDER_ROLE, msg.sender)) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Reverts if the msg.sender is not a valid staking pool\\n  modifier onlyStakingPool() {\\n    if (\\n      msg.sender != address(i_operatorStakingPool) && msg.sender != address(i_communityStakingPool)\\n    ) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Reverts if the reward vault has been closed\\n  modifier whenOpen() {\\n    if (!s_vaultConfig.isOpen) revert VaultAlreadyClosed();\\n    _;\\n  }\\n\\n  // =======================\\n  // TypeAndVersionInterface\\n  // =======================\\n\\n  /// @inheritdoc TypeAndVersionInterface\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"RewardVault 1.0.0\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRewardVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IRewardVault {\\n  /// @notice This enum describes the different staker types\\n  enum StakerType {\\n    NOT_STAKED,\\n    COMMUNITY,\\n    OPERATOR\\n  }\\n\\n  /// @notice This struct is used to store the reward information for a staker.\\n  struct StakerReward {\\n    /// @notice The staker's accrued multiplier-applied reward that's accounted for and stored.\\n    /// This is used for storing delegated rewards and preserving the staker's past rewards between\\n    /// unstakes or multiplier resets.\\n    /// To get the full claimable reward amount, this value is added to the stored reward *\\n    /// multiplier.\\n    /// @dev This value is reset when a staker calls claimRewards and rewards\\n    /// are transferred to the staker.\\n    uint112 vestedBaseReward;\\n    /// @notice The staker's accrued delegated reward that's accounted for and stored.\\n    /// Delegated rewards are not subject to the ramp up multiplier and are immediately finalized.\\n    /// @dev This value is reset when a staker calls claimRewards and rewards\\n    /// are transferred to the staker.\\n    uint112 vestedDelegatedReward;\\n    /// @notice The last updated per-token base reward of the staker.  This\\n    /// value only increases over time\\n    uint112 baseRewardPerToken;\\n    /// @notice The last updated per-token delegated reward of the operator\\n    uint112 operatorDelegatedRewardPerToken;\\n    /// @notice The staker type\\n    /// @dev This value is set once the first time a staker stakes. This value is used to enforce\\n    /// that a community staker is not added as an operator.\\n    StakerType stakerType;\\n    /// @notice The amount of base rewards that the staker has claimed between\\n    /// the last time they staked/unstaked until they stake, unstake again or\\n    /// when an operator is removed.\\n    /// @dev This is reset to 0 whenever concludeRewardPeriod is called\\n    /// @dev This is set to vestedBaseReward whenever claimReward is called\\n    /// @dev Invariant: The sum of unvestedBaseReward and claimedBaseRewardsInPeriod\\n    /// is the total amount of base rewards a staker has earned since the last time\\n    /// they stake/unstake.\\n    uint112 claimedBaseRewardsInPeriod;\\n    /// @notice The staker's earned but unvested base rewards. The staker's current multiplier is\\n    /// applied to get the vested base reward amount.\\n    uint112 unvestedBaseReward;\\n  }\\n\\n  /// @notice Claims reward earned by a staker.\\n  /// @return uint256 The amount of rewards claimed in juels\\n  function claimReward() external returns (uint256);\\n\\n  /// @notice Updates the staking pools' reward per token and staker\u2019s reward state\\n  /// in the reward vault. This is called whenever an operator is slashed as we want\\n  /// to update the operator's rewards state without resetting their multiplier.\\n  /// @param staker The staker's address. If this is set to zero address,\\n  /// staker's reward update will be skipped\\n  /// @param stakerPrincipal The staker's current staked LINK amount in juels\\n  function updateReward(address staker, uint256 stakerPrincipal) external;\\n\\n  /// @notice Concludes the staker's current reward period (defined by a multiplier reset).\\n  /// This will apply the staker's current ramp up multiplier to their\\n  /// earned rewards and store the amount of rewards they have earned before\\n  /// their multiplier is reset.\\n  /// @dev This is called whenever 1) A staker stakes 2) A staker unstakes\\n  /// 3) An operator is removed as we want to update the staker's\\n  /// rewards AND reset their multiplier.\\n  /// @dev Staker rewards are not forfeited when they stake before they have\\n  /// reached their maximum ramp up period multiplier.  Instead these\\n  /// rewards are stored as already earned rewards and will be subject to the\\n  /// multiplier the next time the contract calculates the staker's claimable\\n  /// rewards.\\n  /// @dev Staker rewards are forfeited when a staker unstakes before they\\n  /// have reached their maximum ramp up period multiplier.  Additionally an\\n  /// operator will also forfeit any unclaimable rewards if they are removed\\n  /// before they reach the maximum ramp up period multiplier.  The amount of\\n  /// rewards forfeited is proportional to the amount unstaked relative to\\n  /// the staker's total staked LINK amount when unstaking.  A removed operator forfeits\\n  /// 100% of their unclaimable rewards.\\n  /// @param staker The staker addres\\n  /// @param oldPrincipal The staker's staked LINK amount before finalizing\\n  /// @param stakedAt The last time the staker staked at\\n  /// @param unstakedAmount The amount that the staker has unstaked in juels\\n  /// @param shouldForfeit True if rewards should be forfeited\\n  function concludeRewardPeriod(\\n    address staker,\\n    uint256 oldPrincipal,\\n    uint256 stakedAt,\\n    uint256 unstakedAmount,\\n    bool shouldForfeit\\n  ) external;\\n\\n  /// @notice Closes the reward vault, disabling adding rewards and staking\\n  function close() external;\\n\\n  /// @notice Returns a boolean that is true if the reward vault is open\\n  /// @return True if open, false otherwise\\n  function isOpen() external view returns (bool);\\n\\n  /// @notice Returns the rewards that the staker would get if they withdraw now\\n  /// Rewards calculation is based on the staker's multiplier\\n  /// @param staker The staker's address\\n  /// @return The reward amount\\n  function getReward(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the stored reward info of the staker\\n  /// @param staker The staker address\\n  /// @return The staker's stored reward info\\n  function getStoredReward(address staker) external view returns (StakerReward memory);\\n\\n  /// @notice Returns whether or not the vault is paused\\n  /// @return bool True if the vault is paused\\n  function isPaused() external view returns (bool);\\n\\n  /// @notice Returns whether or not the reward duration for the pool has ended\\n  /// @param stakingPool The address of the staking pool rewards are being shared to\\n  /// @return bool True if the reward duration has ended\\n  function hasRewardDurationEnded(address stakingPool) external view returns (bool);\\n\\n  /// @notice Returns whether or not the reward vault has had rewards added to it\\n  /// @return bool True if the reward vault has had rewards added to it\\n  function hasRewardAdded() external view returns (bool);\\n\\n  /// @notice Returns the staking pools that are earning rewards from\\n  /// the reward vault\\n  /// @return address[] The staking pools that are earning rewards from the\\n  /// reward vault\\n  function getStakingPools() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IRewardVault} from \\\"./IRewardVault.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\n\\ninterface IStakingPool {\\n  /// @notice This error is thrown when a caller tries to execute a transaction\\n  /// that they do not have permissions for\\n  error AccessForbidden();\\n\\n  /// @notice This event is emitted when the migration proxy address has been set\\n  /// @param oldMigrationProxy The old migration proxy contract address\\n  /// @param newMigrationProxy The new migration proxy contract address\\n  event MigrationProxySet(address indexed oldMigrationProxy, address indexed newMigrationProxy);\\n\\n  /// @notice This event is emitted when the staking pool's maximum size is\\n  /// increased\\n  /// @param maxPoolSize the new maximum pool size\\n  event PoolSizeIncreased(uint256 maxPoolSize);\\n\\n  /// @notice This event is emitted when the maximum stake amount\\n  // for the stakers in the pool is increased\\n  /// @param maxPrincipalPerStaker the new maximum stake amount\\n  event MaxPrincipalAmountIncreased(uint256 maxPrincipalPerStaker);\\n\\n  /// @notice This event is emitted when a staker adds stake to the pool.\\n  /// @param staker Staker address\\n  /// @param amount Amount of stake added\\n  /// @param newStake New LINK amount staked\\n  /// @param newTotalPrincipal Total amount of juels staked in the pool\\n  event Staked(address indexed staker, uint256 amount, uint256 newStake, uint256 newTotalPrincipal);\\n\\n  /// @notice This event is emitted when a staker removes stake from the pool.\\n  /// @param staker Staker address\\n  /// @param amount Amount of stake removed\\n  /// @param newStake New LINK amount staked\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event Unstaked(\\n    address indexed staker, uint256 amount, uint256 newStake, uint256 newTotalPrincipal\\n  );\\n\\n  /// @notice This error is thrown whenever a zero-address is supplied when\\n  /// a non-zero address is required\\n  error InvalidZeroAddress();\\n\\n  /// @notice This error is thrown whenever the sender is not the LINK token\\n  error SenderNotLinkToken();\\n\\n  /// @notice This error is thrown whenever the migration proxy address has not been set\\n  error MigrationProxyNotSet();\\n\\n  /// @notice This error is thrown whenever the reward vault address has not been set\\n  error RewardVaultNotSet();\\n\\n  /// @notice This error is thrown when invalid data is passed to the onTokenTransfer function\\n  error InvalidData();\\n\\n  /// @notice This error is thrown when the staker tries to stake less than the min amount\\n  error InsufficientStakeAmount();\\n\\n  /// @notice This error is thrown when the staker tries to stake more than the max amount\\n  error ExceedsMaxStakeAmount();\\n\\n  /// @notice This error is thrown when the staker tries to stake more than the max pool size\\n  error ExceedsMaxPoolSize();\\n\\n  /// @notice This error is raised when stakers attempt to exit the pool\\n  /// @param staker address of the staker\\n  error StakeNotFound(address staker);\\n\\n  /// @notice This error is thrown when the staker tries to unstake a zero amount\\n  error UnstakeZeroAmount();\\n\\n  /// @notice This error is thrown when the staker tries to unstake more than the\\n  /// staked LINK amount\\n  error UnstakeExceedsPrincipal();\\n\\n  /// @notice This error is thrown when the staker tries to unstake an amount that leaves their\\n  /// staked LINK amount below the minimum amount\\n  error UnstakePrincipalBelowMinAmount();\\n\\n  /// @notice This struct defines the state of a staker\\n  struct Staker {\\n    /// @notice The combined staked LINK amount and staked at time history\\n    /// @dev Both the staker staked LINK amount and staked at timestamp are stored in uint112 to\\n    /// save space\\n    /// @dev The max value of uint112 is greater than the total supply of LINK\\n    /// @dev The max value of uint112 can represent a timestamp in the year 3615, long after the\\n    /// staking program has ended\\n    /// @dev The combination is performed as such:\\n    /// uint224 history = (uint224(uint112(principal)) << 112) |\\n    /// uint224(uint112(stakedAtTime))\\n    Checkpoints.History history;\\n    /// @notice The staker's unbonding period end time\\n    uint128 unbondingPeriodEndsAt;\\n    /// @notice The staker's claim period end time\\n    uint128 claimPeriodEndsAt;\\n  }\\n\\n  /// @notice Unstakes amount LINK tokens from the staker\u2019s staked LINK amount\\n  /// @param amount The amount of LINK tokens to unstake\\n  function unstake(uint256 amount) external;\\n\\n  /// @notice Returns the total amount staked in the pool\\n  /// @return The total amount staked in pool\\n  function getTotalPrincipal() external view returns (uint256);\\n\\n  /// @notice Returns the staker's staked LINK amount\\n  /// @param staker The address of the staker to query for\\n  /// @return uint256 The staker's staked LINK amount\\n  function getStakerPrincipal(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the staker's staked LINK amount\\n  /// @param staker The address of the staker to query for\\n  /// @param blockNumber The block number to fetch the staker's balance for.  Pass 0\\n  /// to return the staker's latest staked LINK amount\\n  /// @return uint256 The staker's staked LINK amount\\n  function getStakerPrincipalAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256);\\n\\n  /// @notice Returns the staker's average staked at time\\n  /// @param staker The address of the staker to query for\\n  /// @return uint256 The staker's average staked at time\\n  function getStakerStakedAtTime(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the staker's last staked at time for a block number ID\\n  /// @param staker The address of the staker to query for\\n  /// @param blockNumber The block number to query for\\n  /// @return uint256 The staker's staked at time for the block number ID\\n  function getStakerStakedAtTimeAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256);\\n\\n  /// @notice Returns the current reward vault address\\n  /// @return The reward vault\\n  function getRewardVault() external view returns (IRewardVault);\\n\\n  /// @notice Returns the address of the LINK token contract\\n  /// @return The LINK token contract's address that is used by the pool\\n  function getChainlinkToken() external view returns (address);\\n\\n  /// @notice Returns the migration proxy contract address\\n  /// @return The migration proxy contract address\\n  function getMigrationProxy() external view returns (address);\\n\\n  /// @notice Returns a boolean that is true if the pool is open\\n  /// @return True if the pool is open, false otherwise\\n  function isOpen() external view returns (bool);\\n\\n  /// @notice Returns a boolean that is true if the pool is active,\\n  /// i.e. is open and there are remaining rewards to vest in the pool.\\n  /// @return True if the pool is active, false otherwise\\n  function isActive() external view returns (bool);\\n\\n  /// @notice Returns the minimum and maximum amounts a staker can stake in the\\n  /// pool\\n  /// @return uint256 minimum amount that can be staked by a staker\\n  /// @return uint256 maximum amount that can be staked by a staker\\n  function getStakerLimits() external view returns (uint256, uint256);\\n\\n  /// @notice uint256 Returns the maximum amount that can be staked in the pool\\n  /// @return uint256 current maximum staking pool size\\n  function getMaxPoolSize() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/PausableWithAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport {IPausable} from \\\"./interfaces/IPausable.sol\\\";\\n\\n/// @notice Base contract that adds pausing and access control functionality.\\nabstract contract PausableWithAccessControl is IPausable, Pausable, AccessControlDefaultAdminRules {\\n  /// @notice This is the ID for the pauser role, which is given to the addresses that can pause and\\n  /// unpause the contract.\\n  /// @dev Hash: 65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  constructor(\\n    uint48 adminRoleTransferDelay,\\n    address defaultAdmin\\n  ) AccessControlDefaultAdminRules(adminRoleTransferDelay, defaultAdmin) {}\\n\\n  /// @inheritdoc IPausable\\n  function emergencyPause() external onlyRole(PAUSER_ROLE) {\\n    _pause();\\n  }\\n\\n  /// @inheritdoc IPausable\\n  function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\\n    _unpause();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/pools/CommunityStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\\\";\\n\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport {IMerkleAccessController} from \\\"../interfaces/IMerkleAccessController.sol\\\";\\nimport {OperatorStakingPool} from \\\"./OperatorStakingPool.sol\\\";\\nimport {StakingPoolBase} from \\\"./StakingPoolBase.sol\\\";\\n\\n/// @notice This contract manages the staking of LINK tokens for the community stakers.\\n/// @dev This contract inherits the StakingPoolBase contract and interacts with the MigrationProxy,\\n/// OperatorStakingPool, and RewardVault contracts.\\n/// @dev invariant Operators cannot stake in the community staking pool.\\ncontract CommunityStakingPool is StakingPoolBase, IMerkleAccessController, TypeAndVersionInterface {\\n  /// @notice This error is thrown when the pool is opened with an empty\\n  /// merkle root\\n  error MerkleRootNotSet();\\n\\n  /// @notice This event is emitted when the operator staking pool is changed\\n  /// @param oldOperatorStakingPool The old operator staking pool\\n  /// @param newOperatorStakingPool The new operator staking pool\\n  event OperatorStakingPoolChanged(\\n    address indexed oldOperatorStakingPool, address indexed newOperatorStakingPool\\n  );\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct ConstructorParams {\\n    /// @notice The base staking pool constructor parameters\\n    ConstructorParamsBase baseParams;\\n    /// @notice The operator staking pool contract\\n    OperatorStakingPool operatorStakingPool;\\n  }\\n\\n  /// @notice The operator staking pool contract\\n  OperatorStakingPool private s_operatorStakingPool;\\n  /// @notice The merkle root of the merkle tree generated from the list\\n  /// of staker addresses with early access.\\n  bytes32 private s_merkleRoot;\\n\\n  constructor(ConstructorParams memory params) StakingPoolBase(params.baseParams) {\\n    if (address(params.operatorStakingPool) == address(0)) {\\n      revert InvalidZeroAddress();\\n    }\\n\\n    s_operatorStakingPool = params.operatorStakingPool;\\n  }\\n\\n  // =======================\\n  // IMerkleAccessController\\n  // =======================\\n\\n  /// @inheritdoc IMerkleAccessController\\n  function hasAccess(address staker, bytes32[] calldata proof) external view returns (bool) {\\n    return _hasAccess(staker, proof);\\n  }\\n\\n  /// @inheritdoc IMerkleAccessController\\n  /// @dev precondition The caller must have the initiator admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setMerkleRoot(bytes32 newMerkleRoot) external onlyRole(INITIATOR_ROLE) whenBeforeClosing {\\n    bytes32 oldMerkleRoot = s_merkleRoot;\\n    if (oldMerkleRoot == newMerkleRoot) return;\\n\\n    s_merkleRoot = newMerkleRoot;\\n    emit MerkleRootChanged(oldMerkleRoot, newMerkleRoot);\\n  }\\n\\n  /// @inheritdoc IMerkleAccessController\\n  function getMerkleRoot() external view returns (bytes32) {\\n    return s_merkleRoot;\\n  }\\n\\n  /// @notice This function sets the operator staking pool\\n  /// @param newOperatorStakingPool The new operator staking pool\\n  /// @dev precondition The caller must have the default admin role.\\n  function setOperatorStakingPool(OperatorStakingPool newOperatorStakingPool)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    if (address(newOperatorStakingPool) == address(0)) revert InvalidZeroAddress();\\n    address oldOperatorStakingPool = address(s_operatorStakingPool);\\n    if (oldOperatorStakingPool == address(newOperatorStakingPool)) return;\\n\\n    s_operatorStakingPool = newOperatorStakingPool;\\n    emit OperatorStakingPoolChanged(oldOperatorStakingPool, address(newOperatorStakingPool));\\n  }\\n\\n  // =======================\\n  // TypeAndVersionInterface\\n  // =======================\\n\\n  /// @inheritdoc TypeAndVersionInterface\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"CommunityStakingPool 1.0.0\\\";\\n  }\\n\\n  // ===============\\n  // StakingPoolBase\\n  // ===============\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateOnTokenTransfer(\\n    address sender,\\n    address staker,\\n    bytes calldata data\\n  ) internal view override(StakingPoolBase) {\\n    // check if staker has access\\n    // if the sender is the migration proxy, the staker is allowed to stake\\n    // if currently in public phase (merkle root set to empty bytes) data is ignored\\n    // if in the access limited phase data is the merkle proof\\n    // if in migrations only phase, the merkle root is set to double hash of the migration proxy\\n    // address. This is essentially only used as a placeholder to differentiate between the open\\n    // phase (empty merkle root) and access limited phase (merkle root generated from allowlist)\\n    if (\\n      sender != address(s_migrationProxy) && s_merkleRoot != bytes32(0)\\n        && !_hasAccess(staker, abi.decode(data, (bytes32[])))\\n    ) {\\n      revert AccessForbidden();\\n    }\\n\\n    // check if the sender is an operator\\n    if (s_operatorStakingPool.isOperator(staker) || s_operatorStakingPool.isRemoved(staker)) {\\n      revert AccessForbidden();\\n    }\\n  }\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateBeforeOpen() internal view override(StakingPoolBase) {\\n    if (s_merkleRoot == bytes32(0)) {\\n      revert MerkleRootNotSet();\\n    }\\n  }\\n\\n  /// @notice Util function that validates if a community staker has access to an\\n  /// access limited community staking pool\\n  /// @param staker The community staker's address\\n  /// @param proof Merkle proof for the community staker's allowlist\\n  /// @return bool True if the community staker has access to the access limited\\n  /// community staking pool\\n  function _hasAccess(address staker, bytes32[] memory proof) private view returns (bool) {\\n    if (s_merkleRoot == bytes32(0)) return true;\\n    return MerkleProof.verify({\\n      proof: proof,\\n      root: s_merkleRoot,\\n      leaf: keccak256(bytes.concat(keccak256(abi.encode(staker))))\\n    });\\n  }\\n}\\n\"\r\n    },\r\n    \"src/pools/OperatorStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\\\";\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport {ISlashable} from \\\"../interfaces/ISlashable.sol\\\";\\nimport {IRewardVault} from \\\"../interfaces/IRewardVault.sol\\\";\\nimport {StakingPoolBase} from \\\"./StakingPoolBase.sol\\\";\\n\\n/// @notice This contract manages the staking of LINK tokens for the operator stakers.\\n/// @dev This contract inherits the StakingPoolBase contract and interacts with the MigrationProxy,\\n/// PriceFeedAlertsController, CommunityStakingPool, and RewardVault contracts.\\n/// @dev invariant Only addresses added as operators by the contract manager can stake in this pool.\\n/// @dev invariant contract's LINK token balance should be greater than or equal to the sum of\\n/// totalPrincipal and s_alerterRewardFunds.\\ncontract OperatorStakingPool is ISlashable, StakingPoolBase, TypeAndVersionInterface {\\n  using Checkpoints for Checkpoints.History;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice This error is raised when adding the zero address as an operator\\n  error InvalidOperator();\\n  /// @notice Error code for when the operator list is invalid\\n  error InvalidOperatorList();\\n  /// @notice Error code for when the staker is not an operator\\n  error StakerNotOperator();\\n  /// @notice This error is raised when an address is duplicated in the supplied list of operators.\\n  /// This can happen in addOperators and setFeedOperators functions.\\n  /// @param operator address of the operator\\n  error OperatorAlreadyExists(address operator);\\n  /// @notice This error is raised when removing an operator that doesn't exist.\\n  /// @param operator Address of the operator\\n  error OperatorDoesNotExist(address operator);\\n  /// @notice This error is raised when an operator to add has been removed previously.\\n  /// @param operator Address of the operator\\n  error OperatorHasBeenRemoved(address operator);\\n  /// @notice This error is raised when an operator to add is already a community staker.\\n  error OperatorCannotBeCommunityStaker(address operator);\\n  /// @notice This error is thrown whenever the max pool size is less than the\\n  /// reserved space for operators\\n  /// @param maxPoolSize The maximum pool size of the operator staking pool\\n  /// @param maxPrincipalPerStaker The maximum amount an operator can stake in the\\n  /// pool\\n  /// @param numOperators The number of operators in the pool\\n  error InsufficientPoolSpace(\\n    uint256 maxPoolSize, uint256 maxPrincipalPerStaker, uint256 numOperators\\n  );\\n  /// @notice This error is raised when attempting to open the staking pool with less\\n  /// than the minimum required node operators\\n  /// @param numOperators The current number of operators in the staking pool\\n  /// @param minInitialOperatorCount The minimum required number of operators\\n  /// in the staking pool before it can be opened\\n  error InadequateInitialOperatorCount(uint256 numOperators, uint256 minInitialOperatorCount);\\n  /// @notice This error is thrown when the contract manager tries to add a zero amount\\n  /// to the alerter reward funds\\n  error InvalidAlerterRewardFundAmount();\\n  /// @notice This error is thrown whenever the contract manager tries to withdraw\\n  /// more than the remaining balance in the alerter reward funds\\n  /// @param amountToWithdraw The amount that the contract manager tried to withdraw\\n  /// @param remainingBalance The remaining balance of the alerter reward funds\\n  error InsufficientAlerterRewardFunds(uint256 amountToWithdraw, uint256 remainingBalance);\\n\\n  /// @notice This event is emitted when an operator is removed\\n  /// @param operator Address of the operator\\n  /// @param principal Operator's staked LINK amount\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event OperatorRemoved(address indexed operator, uint256 principal, uint256 newTotalPrincipal);\\n  /// @notice This event is emitted when an operator is added\\n  /// @param operator Address of the operator\\n  event OperatorAdded(address indexed operator);\\n  /// @notice This event is emitted whenever the alerter reward funds is funded\\n  /// @param amountFunded The amount added to the alerter reward funds\\n  /// @param totalBalance  The current balance of the alerter reward funds\\n  event AlerterRewardDeposited(uint256 amountFunded, uint256 totalBalance);\\n  /// @notice This event is emitted whenever the contract manager withdraws from the\\n  /// alerter reward funds\\n  /// @param amountWithdrawn The amount withdrawn from the alerter reward funds\\n  /// @param remainingBalance The remaining balance of the alerter reward funds\\n  event AlerterRewardWithdrawn(uint256 amountWithdrawn, uint256 remainingBalance);\\n  /// @notice This event is emitted whenever the alerter is paid the full\\n  /// alerter reward amount\\n  /// @param alerter The address of the alerter\\n  /// @param alerterRewardActual The amount of rewards sent to the alerter in juels.\\n  /// This can be lower than the expected value, if the reward fund is low or we aren't able to\\n  /// slash enough.\\n  /// @param alerterRewardExpected The amount of expected rewards for the alerter\\n  /// in juels\\n  event AlertingRewardPaid(\\n    address indexed alerter, uint256 alerterRewardActual, uint256 alerterRewardExpected\\n  );\\n  /// @notice This event is emitted when the slasher config is set\\n  /// @param slasher The address of the slasher\\n  /// @param refillRate The refill rate of the slasher\\n  /// @param slashCapacity The slash capacity of the slasher\\n  event SlasherConfigSet(address indexed slasher, uint256 refillRate, uint256 slashCapacity);\\n  /// @notice This event is emitted when an operator is slashed\\n  /// @param operator The address of the operator\\n  /// @param slashedAmount The amount slashed from the operator's staked LINK\\n  /// amount\\n  /// @param updatedStakerPrincipal The operator's updated staked LINK amount\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event Slashed(\\n    address indexed operator,\\n    uint256 slashedAmount,\\n    uint256 updatedStakerPrincipal,\\n    uint256 newTotalPrincipal\\n  );\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct ConstructorParams {\\n    /// @notice The base staking pool constructor parameters\\n    ConstructorParamsBase baseParams;\\n    /// @notice The minimum number of node operators required to open the\\n    /// staking pool.\\n    uint256 minInitialOperatorCount;\\n  }\\n\\n  /// @notice This struct defines the operator-specific states.\\n  struct Operator {\\n    /// @notice The operator's staked LINK amount when they get removed.\\n    uint256 removedPrincipal;\\n    /// @notice Flag that signals whether the operator is an operator.\\n    bool isOperator;\\n    /// @notice Flag that signals whether the operator has been removed.\\n    bool isRemoved;\\n  }\\n\\n  /// @notice This is the ID for the alert rewarder role, which is given to the\\n  /// addresses that will deposit and withdraw the alerter reward.\\n  /// @dev Hash: 8d2cf17e37ecc80f26d65bcf3868b78960ab38b0762747f6c5e311e75068a88b\\n  bytes32 public constant ALERT_REWARDER_ROLE = keccak256(\\\"ALERT_REWARDER_ROLE\\\");\\n  /// @notice This is the ID for the operator manager role, which is given to the address that will\\n  /// add and remove operators\\n  /// @dev Hash: 001fdceeaab2d33566b504ecfe97e6dc3cf82cc816e696d9fe5cce35954bed17\\n  bytes32 public constant OPERATOR_MANAGER_ROLE = keccak256(\\\"OPERATOR_MANAGER_ROLE\\\");\\n  /// @notice This is the ID for the slasher role, which will be given to the\\n  /// AlertsController contract.\\n  /// @dev Hash: 12b42e8a160f6064dc959c6f251e3af0750ad213dbecf573b4710d67d6c28e39\\n  bytes32 public constant SLASHER_ROLE = keccak256(\\\"SLASHER_ROLE\\\");\\n  /// @notice Mapping of addresses to the Operator struct.\\n  mapping(address operator => Operator) private s_operators;\\n  /// @notice Mapping of the slashers to slasher config and state.\\n  mapping(address slasher => Slasher) private s_slashers;\\n  /// @notice The set of operators that are currently on-feed (slashable).\\n  EnumerableSet.AddressSet private s_operatorSet;\\n  /// @notice The number of node operators that have been set in the pool\\n  uint256 private s_numOperators;\\n  /// @notice Tracks the balance of the alerter reward funds.  This bucket holds all\\n  /// slashed funds and also funds alerter rewards.\\n  uint256 private s_alerterRewardFunds;\\n  /// @notice The minimum number of node operators required to open the\\n  /// staking pool.\\n  uint256 private immutable i_minInitialOperatorCount;\\n\\n  constructor(ConstructorParams memory params) StakingPoolBase(params.baseParams) {\\n    i_minInitialOperatorCount = params.minInitialOperatorCount;\\n  }\\n\\n  /// @notice Adds LINK to the alerter reward funds\\n  /// @param amount The amount of LINK to add to the alerter reward funds\\n  /// @dev precondition The caller must have the alert rewarder role.\\n  /// @dev precondition The caller must have at least `amount` LINK tokens.\\n  /// @dev precondition The caller must have approved this contract for the transfer of at least\\n  /// `amount` LINK tokens.\\n  function depositAlerterReward(uint256 amount)\\n    external\\n    onlyRole(ALERT_REWARDER_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (amount == 0) revert InvalidAlerterRewardFundAmount();\\n    uint256 alerterRewardFunds = s_alerterRewardFunds;\\n    alerterRewardFunds += amount;\\n    s_alerterRewardFunds = alerterRewardFunds;\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transferFrom({from: msg.sender, to: address(this), value: amount});\\n    emit AlerterRewardDeposited(amount, alerterRewardFunds);\\n  }\\n\\n  /// @notice Withdraws LINK from the alerter reward funds\\n  /// @param amount The amount of LINK withdrawn from the alerter reward funds\\n  /// @dev precondition The caller must have the alert rewarder role.\\n  /// @dev precondition This contract must have at least `amount` LINK tokens as the alerter reward\\n  /// funds.\\n  /// @dev precondition This contract must be closed (before opening or after closing).\\n  function withdrawAlerterReward(uint256 amount) external onlyRole(ALERT_REWARDER_ROLE) {\\n    if (amount == 0) revert InvalidAlerterRewardFundAmount();\\n    if (s_isOpen) revert PoolNotClosed();\\n    uint256 alerterRewardFunds = s_alerterRewardFunds;\\n    if (amount > alerterRewardFunds) {\\n      revert InsufficientAlerterRewardFunds(amount, alerterRewardFunds);\\n    }\\n    alerterRewardFunds -= amount;\\n    s_alerterRewardFunds = alerterRewardFunds;\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, amount);\\n    emit AlerterRewardWithdrawn(amount, alerterRewardFunds);\\n  }\\n\\n  /// @notice Returns the balance of the pool's alerter reward funds\\n  /// @return uint256 The balance of the pool's alerter reward funds\\n  function getAlerterRewardFunds() external view returns (uint256) {\\n    return s_alerterRewardFunds;\\n  }\\n\\n  // ===============\\n  // StakingPoolBase\\n  // ===============\\n\\n  /// @inheritdoc StakingPoolBase\\n  /// @dev The access control is done in StakingPoolBase.\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker\\n  )\\n    external\\n    override(StakingPoolBase)\\n    validatePoolSpace(maxPoolSize, maxPrincipalPerStaker, s_numOperators)\\n    whenOpen\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    _setPoolConfig(maxPoolSize, maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc StakingPoolBase\\n  /// @dev Removed operators need to go through the unbonding period before they can withdraw. This\\n  /// function will check if the operator has removed principal they can unstake.\\n  function unbond() external override {\\n    Staker storage staker = s_stakers[msg.sender];\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    if (stakerPrincipal == 0 && s_operators[msg.sender].removedPrincipal == 0) {\\n      revert StakeNotFound(msg.sender);\\n    }\\n\\n    _unbond(staker);\\n  }\\n\\n  /// @notice Registers operators from a list of unique, sorted addresses\\n  /// Addresses must be provided in sorted order so that\\n  /// address(0xNext) > address(0xPrev)\\n  /// @dev Previously removed operators cannot be readded to the pool.\\n  /// @dev precondition The caller must have the operator manager role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  /// @param operators The sorted list of operator addresses\\n  function addOperators(address[] calldata operators)\\n    external\\n    whenBeforeClosing\\n    validateRewardVaultSet\\n    validatePoolSpace(\\n      s_pool.configs.maxPoolSize,\\n      s_pool.configs.maxPrincipalPerStaker,\\n      s_numOperators + operators.length\\n    )\\n    onlyRole(OPERATOR_MANAGER_ROLE)\\n  {\\n    for (uint256 i; i < operators.length; ++i) {\\n      address operatorAddress = operators[i];\\n      if (operatorAddress == address(0)) revert InvalidOperator();\\n      IRewardVault.StakerReward memory stakerReward = s_rewardVault.getStoredReward(operatorAddress);\\n      if (stakerReward.stakerType == IRewardVault.StakerType.COMMUNITY) {\\n        revert OperatorCannotBeCommunityStaker(operatorAddress);\\n      }\\n      // verify input list is sorted and addresses are unique\\n      if (i < operators.length - 1 && operatorAddress >= operators[i + 1]) {\\n        revert InvalidOperatorList();\\n      }\\n      Operator storage operator = s_operators[operatorAddress];\\n      if (operator.isOperator) revert OperatorAlreadyExists(operatorAddress);\\n      if (operator.isRemoved) revert OperatorHasBeenRemoved(operatorAddress);\\n      operator.isOperator = true;\\n      s_operatorSet.add(operatorAddress);\\n      emit OperatorAdded(operatorAddress);\\n    }\\n\\n    unchecked {\\n      s_numOperators += operators.length;\\n    }\\n  }\\n\\n  /// @notice Removes one or more operators from a list of operators.\\n  /// @dev Should only be callable by the owner when the pool is open.\\n  /// When an operator is removed, we store their staked LINK amount in a separate mapping to\\n  /// stop it from accruing rewards. They can withdraw their removedPrincipal and exit the system\\n  /// after going through the unbonding period.\\n  /// Removed operators are no longer slashable.\\n  /// @param operators A list of operator addresses to remove\\n  /// @dev precondition The caller must have the operator manager role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  /// @dev precondition The operators must be currently added operators.\\n  function removeOperators(address[] calldata operators)\\n    external\\n    onlyRole(OPERATOR_MANAGER_ROLE)\\n    whenBeforeClosing\\n  {\\n    Operator storage operator;\\n    Staker storage staker;\\n    uint256 totalPrincipal = s_pool.state.totalPrincipal;\\n    for (uint256 i; i < operators.length; ++i) {\\n      address operatorAddress = operators[i];\\n      operator = s_operators[operatorAddress];\\n      if (!operator.isOperator) revert OperatorDoesNotExist(operatorAddress);\\n\\n      staker = s_stakers[operatorAddress];\\n      uint224 history = staker.history.latest();\\n      uint256 principal = uint256(history >> 112);\\n      uint256 stakedAtTime = uint112(history);\\n      s_rewardVault.concludeRewardPeriod({\\n        staker: operatorAddress,\\n        oldPrincipal: principal,\\n        unstakedAmount: principal,\\n        shouldForfeit: true,\\n        stakedAt: stakedAtTime\\n      });\\n\\n      totalPrincipal -= principal;\\n      s_pool.state.totalPrincipal = totalPrincipal;\\n      delete operator.isOperator;\\n      s_operatorSet.remove(operatorAddress);\\n      operator.isRemoved = true;\\n      // Reset the staker's stakedAtTime to 0 so their multiplier resets to 0.\\n      _updateStakerHistory({staker: staker, latestPrincipal: 0, latestStakedAtTime: 0});\\n      // Move the operator's staked LINK amount to removedPrincipal so that\\n      // the operator stops earning rewards\\n      operator.removedPrincipal = principal;\\n\\n      _resetUnbondingPeriod(staker, operatorAddress);\\n\\n      emit OperatorRemoved(operatorAddress, principal, totalPrincipal);\\n    }\\n\\n    s_numOperators -= operators.length;\\n  }\\n\\n  /// @notice Getter function to check if an address is registered as an operator\\n  /// @param staker The address of the staker\\n  /// @return bool True if the staker is an operator\\n  function isOperator(address staker) external view returns (bool) {\\n    return s_operators[staker].isOperator;\\n  }\\n\\n  /// @notice Getter function to check if an address is a removed operator\\n  /// @param staker The address of the staker\\n  /// @return bool True if the operator has been removed\\n  function isRemoved(address staker) external view returns (bool) {\\n    return s_operators[staker].isRemoved;\\n  }\\n\\n  /// @notice Getter function for a removed operator's total staked LINK amount\\n  /// @param staker The address of the staker\\n  /// @return uint256 The removed operator's staked LINK amount that hasn't been withdrawn\\n  function getRemovedPrincipal(address staker) external view returns (uint256) {\\n    return s_operators[staker].removedPrincipal;\\n  }\\n\\n  /// @notice Called by removed operators to withdraw their removed stake\\n  /// @dev precondition The caller must be in the claim period or the pool must be closed or paused.\\n  /// @dev precondition The caller must be a removed operator with some removed\\n  /// staked LINK amount.\\n  function unstakeRemovedPrincipal() external {\\n    if (!_canUnstake(s_stakers[msg.sender])) {\\n      revert StakerNotInClaimPeriod(msg.sender);\\n    }\\n\\n    uint256 withdrawableAmount = s_operators[msg.sender].removedPrincipal;\\n    if (withdrawableAmount == 0) {\\n      revert UnstakeExceedsPrincipal();\\n    }\\n    delete s_operators[msg.sender].removedPrincipal;\\n\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, withdrawableAmount);\\n    // Since operator has been removed their total amount staked will be 0\\n    emit Unstaked(msg.sender, withdrawableAmount, 0, s_pool.state.totalPrincipal);\\n  }\\n\\n  /// @notice Returns the number of operators configured in the pool.\\n  /// @return uint256 The number of operators configured in the pool\\n  function getNumOperators() external view returns (uint256) {\\n    return s_numOperators;\\n  }\\n\\n  /// @notice Returns the list of operators configured in the pool.\\n  /// @return address[] The list of operators configured in the pool\\n  function getOperators() external view returns (address[] memory) {\\n    return s_operatorSet.values();\\n  }\\n\\n  // =======================\\n  // ISlashable\\n  // =======================\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function addSlasher(\\n    address slasher,\\n    SlasherConfig calldata config\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    _grantRole(SLASHER_ROLE, slasher);\\n    _setSlasherConfig(slasher, config);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function removeSlasher(address slasher) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    if (!hasRole(SLASHER_ROLE, slasher)) {\\n      revert InvalidSlasher();\\n    }\\n    delete s_slashers[slasher];\\n    _revokeRole(SLASHER_ROLE, slasher);\\n    emit SlasherConfigSet(slasher, 0, 0);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setSlasherConfig(\\n    address slasher,\\n    SlasherConfig calldata config\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    if (!hasRole(SLASHER_ROLE, slasher)) {\\n      revert InvalidSlasher();\\n    }\\n    _setSlasherConfig(slasher, config);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  function getSlasherConfig(address slasher) external view returns (SlasherConfig memory) {\\n    return s_slashers[slasher].config;\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  function getSlashCapacity(address slasher) external view returns (uint256) {\\n    SlasherConfig memory slasherConfig = s_slashers[slasher].config;\\n    return _getRemainingSlashCapacity(slasherConfig, slasher);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev In the current implementation, on-feed operators can raise alerts to rescue a portion of\\n  /// their slashed staked LINK amount. All operators can raise alerts in the priority period. Note\\n  /// that this may change in the future as we add alerting for additional services.\\n  /// @dev We will operationally make sure to remove an operator from the slashable (on-feed)\\n  /// operators list in alerts controllers if they are removed from the operators list in this\\n  /// contract, so there won't be a case where we slash a removed operator.\\n  /// @dev precondition The caller must have the slasher role.\\n  /// @dev precondition This contract must be active (open and stakers are earning rewards).\\n  /// @dev precondition The slasher must have enough capacity to slash.\\n  function slashAndReward(\\n    address[] calldata stakers,\\n    address alerter,\\n    uint256 principalAmount,\\n    uint256 alerterRewardAmount\\n  ) external onlySlasher whenActive whenNotPaused {\\n    SlasherConfig storage slasherConfig = s_slashers[msg.sender].config;\\n    uint256 combinedSlashAmount = stakers.length * principalAmount;\\n\\n    uint256 remainingSlashCapacity = _getRemainingSlashCapacity(slasherConfig, msg.sender);\\n    // check if the total slashed amount exceeds the slasher's capacity\\n    if (combinedSlashAmount > remainingSlashCapacity) {\\n      /// @dev If a slashing occurs with an amount to be slashed that is higher than the remaining\\n      /// slashing capacity, only an amount equal to the remaining capacity is slashed.\\n      principalAmount = remainingSlashCapacity / stakers.length;\\n    }\\n\\n    uint256 totalSlashedAmount = _slashOperators(stakers, principalAmount);\\n\\n    s_slashers[msg.sender].state.remainingSlashCapacityAmount =\\n      remainingSlashCapacity - totalSlashedAmount;\\n    s_slashers[msg.sender].state.lastSlashTimestamp = block.timestamp;\\n\\n    _payAlerter({\\n      alerter: alerter,\\n      totalSlashedAmount: totalSlashedAmount,\\n      alerterRewardAmount: alerterRewardAmount\\n    });\\n  }\\n\\n  // =======================\\n  // TypeAndVersionInterface\\n  // =======================\\n\\n  /// @inheritdoc TypeAndVersionInterface\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OperatorStakingPool 1.0.0\\\";\\n  }\\n\\n  // ==============================\\n  // AccessControlDefaultAdminRules\\n  // ==============================\\n\\n  /// @inheritdoc AccessControlDefaultAdminRules\\n  /// @notice Grants `role` to `account`. Reverts if the contract manager tries to grant the default\\n  /// admin or slasher role.\\n  /// @dev The default admin role must be granted through `beginDefaultAdminTransfer` and\\n  /// `acceptDefaultAdminTransfer`.\\n  /// @dev The slasher role must be granted through `addSlasher`.\\n  /// @param role The role to grant\\n  /// @param account The address to grant the role to\\n  function grantRole(\\n    bytes32 role,\\n    address account\\n  ) public virtual override(AccessControlDefaultAdminRules) {\\n    if (role == SLASHER_ROLE) revert InvalidRole();\\n    super.grantRole(role, account);\\n  }\\n\\n  /// @inheritdoc AccessControlDefaultAdminRules\\n  /// @notice Grants `role` to `account`. Reverts if the contract manager tries to grant the default\\n  /// admin or slasher role.\\n  /// @dev The default admin role must be revoked through `beginDefaultAdminTransfer` and\\n  /// `acceptDefaultAdminTransfer` to another address.\\n  /// @dev The slasher role must be revoked through `removeSlasher`.\\n  /// @param role The role to revoke\\n  /// @param account The address to revoke the role from\\n  function revokeRole(\\n    bytes32 role,\\n    address account\\n  ) public virtual override(AccessControlDefaultAdminRules) {\\n    if (role == SLASHER_ROLE) revert InvalidRole();\\n    super.revokeRole(role, account);\\n  }\\n\\n  // ===============\\n  // StakingPoolBase\\n  // ===============\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateOnTokenTransfer(\\n    address,\\n    address staker,\\n    bytes calldata\\n  ) internal view override(StakingPoolBase) {\\n    // check if staker is an operator\\n    if (!s_operators[staker].isOperator) revert StakerNotOperator();\\n  }\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateBeforeOpen() internal view override(StakingPoolBase) {\\n    if (s_numOperators < i_minInitialOperatorCount) {\\n      revert InadequateInitialOperatorCount(s_numOperators, i_minInitialOperatorCount);\\n    }\\n  }\\n\\n  /// @notice Helper function to set the slasher config\\n  /// @param slasher The slasher\\n  /// @param config The slasher config\\n  function _setSlasherConfig(address slasher, SlasherConfig calldata config) private {\\n    if (config.slashCapacity == 0 || config.refillRate == 0) {\\n      revert ISlashable.InvalidSlasherConfig();\\n    }\\n\\n    s_slashers[slasher].config = config;\\n\\n    // refill capacity\\n    SlasherState storage state = s_slashers[slasher].state;\\n    state.remainingSlashCapacityAmount = config.slashCapacity;\\n    state.lastSlashTimestamp = block.timestamp;\\n\\n    emit SlasherConfigSet(slasher, config.refillRate, config.slashCapacity);\\n  }\\n\\n  /// @notice Helper function to slash operators\\n  /// @param operators The list of operators to slash\\n  /// @param principalAmount The amount to slash from each operator's staked\\n  /// LINK amount\\n  /// @return The total amount slashed from all operators\\n  function _slashOperators(\\n    address[] calldata operators,\\n    uint256 principalAmount\\n  ) private returns (uint256) {\\n    // perform the slash on all operators and add up the total slashed amount\\n    uint256 totalSlashedAmount;\\n    Staker storage staker;\\n    uint256 totalPrincipal = s_pool.state.totalPrincipal;\\n    for (uint256 i; i < operators.length; ++i) {\\n      // verify input list is sorted and addresses are unique\\n      address operatorAddress = operators[i];\\n      if (i < operators.length - 1 && operatorAddress >= operators[i + 1]) {\\n        revert InvalidOperatorList();\\n      }\\n      staker = s_stakers[operatorAddress];\\n      uint224 history = staker.history.latest();\\n      uint256 operatorPrincipal = uint112(history >> 112);\\n      uint256 stakerStakedAtTime = uint112(history);\\n      uint256 slashedAmount =\\n        principalAmount > operatorPrincipal ? operatorPrincipal : principalAmount;\\n      uint256 updatedPrincipal = operatorPrincipal - slashedAmount;\\n\\n      // update the staker's rewards\\n      s_rewardVault.updateReward(operatorAddress, operatorPrincipal);\\n      _updateStakerHistory({\\n        staker: staker,\\n        latestPrincipal: updatedPrincipal,\\n        latestStakedAtTime: stakerStakedAtTime\\n      });\\n\\n      totalSlashedAmount += slashedAmount;\\n      totalPrincipal -= slashedAmount;\\n\\n      emit Slashed(operatorAddress, slashedAmount, updatedPrincipal, totalPrincipal);\\n    }\\n    // update the pool state\\n    s_pool.state.totalPrincipal = totalPrincipal;\\n\\n    return totalSlashedAmount;\\n  }\\n\\n  /// @notice Helper function to reward the alerter\\n  /// @param alerter The alerter\\n  /// @param totalSlashedAmount The total amount slashed from all the operators\\n  /// @param alerterRewardAmount The amount to reward the alerter\\n  function _payAlerter(\\n    address alerter,\\n    uint256 totalSlashedAmount,\\n    uint256 alerterRewardAmount\\n  ) private {\\n    uint256 newAlerterRewardFunds = s_alerterRewardFunds + totalSlashedAmount;\\n    uint256 alerterRewardActual =\\n      newAlerterRewardFunds < alerterRewardAmount ? newAlerterRewardFunds : alerterRewardAmount;\\n    s_alerterRewardFunds = newAlerterRewardFunds - alerterRewardActual;\\n\\n    // We emit an event here instead of reverting so that the alerter can\\n    // immediately receive a portion of their rewards.  This event\\n    // will allow the contract manager to reimburse any remaining rewards to the\\n    // alerter.\\n    emit AlertingRewardPaid(alerter, alerterRewardActual, alerterRewardAmount);\\n\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(alerter, alerterRewardActual);\\n  }\\n\\n  /// @notice Helper function to return the current remaining slash capacity for a slasher\\n  /// @param slasherConfig The slasher's config\\n  /// @param slasher The slasher\\n  /// @return The remaining slashing capacity\\n  function _getRemainingSlashCapacity(\\n    SlasherConfig memory slasherConfig,\\n    address slasher\\n  ) private view returns (uint256) {\\n    SlasherState memory slasherState = s_slashers[slasher].state;\\n    uint256 refilledAmount =\\n      (block.timestamp - slasherState.lastSlashTimestamp) * slasherConfig.refillRate;\\n\\n    return Math.min(\\n      slasherConfig.slashCapacity, slasherState.remainingSlashCapacityAmount + refilledAmount\\n    );\\n  }\\n\\n  /// @dev Reverts if the msg.sender doesn't have the rewarder role.\\n  modifier onlyRewarder() {\\n    if (!hasRole(ALERT_REWARDER_ROLE, msg.sender)) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Reverts if not sent by an address that has the SLASHER role\\n  modifier onlySlasher() {\\n    if (!hasRole(SLASHER_ROLE, msg.sender)) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @notice Checks that the maximum pool size is greater than or equal to\\n  /// the reserved space for operators.\\n  /// @param maxPoolSize The maximum pool size of the operator staking pool\\n  /// @param maxPrincipalPerStaker The maximum amount an operator can stake in the\\n  /// @param numOperators The number of operators in the pool\\n  /// @dev The reserved space is calculated by multiplying the number of\\n  /// operators and the maximum staked LINK amount per operator\\n  modifier validatePoolSpace(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker,\\n    uint256 numOperators\\n  ) {\\n    if (maxPoolSize < maxPrincipalPerStaker * numOperators) {\\n      revert InsufficientPoolSpace(maxPoolSize, maxPrincipalPerStaker, numOperators);\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Checkpoints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SafeCast.sol\\\";\\n\\n/**\\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\\n * time, and later looking up past values by block number. See {Votes} as an example.\\n *\\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\\n * checkpoint for the current transaction block using the {push} function.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Checkpoints {\\n    struct History {\\n        Checkpoint[] _checkpoints;\\n    }\\n\\n    struct Checkpoint {\\n        uint32 _blockNumber;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\\n     * block, the requested block number must be in the past, excluding the current block.\\n     */\\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\\n     * checkpoint is probably \\\"recent\\\", defined as being among the last sqrt(N) checkpoints where N is the number of\\n     * checkpoints.\\n     */\\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\\n        return _insert(self._checkpoints, SafeCast.toUint32(block.number), SafeCast.toUint224(value));\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\\n     * be set to `op(latest, delta)`.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(\\n        History storage self,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) internal returns (uint256, uint256) {\\n        return push(self, op(latest(self), delta));\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(History storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(\\n        History storage self\\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._blockNumber, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(History storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._blockNumber <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._blockNumber == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace224 {\\n        Checkpoint224[] _checkpoints;\\n    }\\n\\n    struct Checkpoint224 {\\n        uint32 _key;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace224 storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace224 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint224({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint224({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint224[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint224 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace160 {\\n        Checkpoint160[] _checkpoints;\\n    }\\n\\n    struct Checkpoint160 {\\n        uint96 _key;\\n        uint160 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace160 storage self) internal view returns (uint160) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace160 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint160({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint160({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint160[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint160 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"./IAccessControlDefaultAdminRules.sol\\\";\\nimport \\\"../utils/math/SafeCast.sol\\\";\\nimport \\\"../interfaces/IERC5313.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\\n * over other roles that may potentially have privileged rights in the system.\\n *\\n * If a specific role doesn't have an admin role assigned, the holder of the\\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\\n *\\n * This contract implements the following risk mitigations on top of {AccessControl}:\\n *\\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\\n *\\n * Example usage:\\n *\\n * ```solidity\\n * contract MyToken is AccessControlDefaultAdminRules {\\n *   constructor() AccessControlDefaultAdminRules(\\n *     3 days,\\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\\n *    ) {}\\n * }\\n * ```\\n *\\n * _Available since v4.9._\\n */\\nabstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {\\n    // pending admin pair read/written together frequently\\n    address private _pendingDefaultAdmin;\\n    uint48 private _pendingDefaultAdminSchedule; // 0 == unset\\n\\n    uint48 private _currentDelay;\\n    address private _currentDefaultAdmin;\\n\\n    // pending delay pair read/written together frequently\\n    uint48 private _pendingDelay;\\n    uint48 private _pendingDelaySchedule; // 0 == unset\\n\\n    /**\\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\\n     */\\n    constructor(uint48 initialDelay, address initialDefaultAdmin) {\\n        require(initialDefaultAdmin != address(0), \\\"AccessControl: 0 default admin\\\");\\n        _currentDelay = initialDelay;\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC5313-owner}.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return defaultAdmin();\\n    }\\n\\n    ///\\n    /// Override AccessControl role management\\n    ///\\n\\n    /**\\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly grant default admin role\\\");\\n        super.grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly revoke default admin role\\\");\\n        super.revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-renounceRole}.\\n     *\\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\\n     * has also passed when calling this function.\\n     *\\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\\n     *\\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\\n     * non-administrated role.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\\n            require(\\n                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),\\n                \\\"AccessControl: only can renounce in two delayed steps\\\"\\n            );\\n            delete _pendingDefaultAdminSchedule;\\n        }\\n        super.renounceRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_grantRole}.\\n     *\\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\\n     * role has been previously renounced.\\n     *\\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE) {\\n            require(defaultAdmin() == address(0), \\\"AccessControl: default admin already granted\\\");\\n            _currentDefaultAdmin = account;\\n        }\\n        super._grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_revokeRole}.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            delete _currentDefaultAdmin;\\n        }\\n        super._revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't violate default admin rules\\\");\\n        super._setRoleAdmin(role, adminRole);\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules accessors\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdmin() public view virtual returns (address) {\\n        return _currentDefaultAdmin;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\\n        return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelay() public view virtual returns (uint48) {\\n        uint48 schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\\n        schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\\n        return 5 days;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _beginDefaultAdminTransfer(newAdmin);\\n    }\\n\\n    /**\\n     * @dev See {beginDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _cancelDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {cancelDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _cancelDefaultAdminTransfer() internal virtual {\\n        _setPendingDefaultAdmin(address(0), 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function acceptDefaultAdminTransfer() public virtual {\\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\\n        require(_msgSender() == newDefaultAdmin, \\\"AccessControl: pending admin must accept\\\");\\n        _acceptDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {acceptDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _acceptDefaultAdminTransfer() internal virtual {\\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\\n        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \\\"AccessControl: transfer delay not passed\\\");\\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\\n        delete _pendingDefaultAdmin;\\n        delete _pendingDefaultAdminSchedule;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _changeDefaultAdminDelay(newDelay);\\n    }\\n\\n    /**\\n     * @dev See {changeDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\\n        _setPendingDelay(newDelay, newSchedule);\\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _rollbackDefaultAdminDelay();\\n    }\\n\\n    /**\\n     * @dev See {rollbackDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _rollbackDefaultAdminDelay() internal virtual {\\n        _setPendingDelay(0, 0);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\\n     * become the new {defaultAdminDelay}.\\n     *\\n     * The value returned guarantees that if the delay is reduced, it will go into effect\\n     * after a wait that honors the previously set delay.\\n     *\\n     * See {defaultAdminDelayIncreaseWait}.\\n     */\\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\\n        uint48 currentDelay = defaultAdminDelay();\\n\\n        // When increasing the delay, we schedule the delay change to occur after a period of \\\"new delay\\\" has passed, up\\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\\n        // using milliseconds instead of seconds.\\n        //\\n        // When decreasing the delay, we wait the difference between \\\"current delay\\\" and \\\"new delay\\\". This guarantees\\n        // that an admin transfer cannot be made faster than \\\"current delay\\\" at the time the delay change is scheduled.\\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\\n        return\\n            newDelay > currentDelay\\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\\n                : currentDelay - newDelay;\\n    }\\n\\n    ///\\n    /// Private setters\\n    ///\\n\\n    /**\\n     * @dev Setter of the tuple for pending admin and its schedule.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\\n\\n        _pendingDefaultAdmin = newAdmin;\\n        _pendingDefaultAdminSchedule = newSchedule;\\n\\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\\n        if (_isScheduleSet(oldSchedule)) {\\n            // Emit for implicit cancellations when another default admin was scheduled.\\n            emit DefaultAdminTransferCanceled();\\n        }\\n    }\\n\\n    /**\\n     * @dev Setter of the tuple for pending delay and its schedule.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\\n        uint48 oldSchedule = _pendingDelaySchedule;\\n\\n        if (_isScheduleSet(oldSchedule)) {\\n            if (_hasSchedulePassed(oldSchedule)) {\\n                // Materialize a virtual delay\\n                _currentDelay = _pendingDelay;\\n            } else {\\n                // Emit for implicit cancellations when another delay was scheduled.\\n                emit DefaultAdminDelayChangeCanceled();\\n            }\\n        }\\n\\n        _pendingDelay = newDelay;\\n        _pendingDelaySchedule = newSchedule;\\n    }\\n\\n    ///\\n    /// Private helpers\\n    ///\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered set. For consistency purposes.\\n     */\\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\\n        return schedule != 0;\\n    }\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered passed. For consistency purposes.\\n     */\\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\\n        return schedule < block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IPausable {\\n  /// @notice This function pauses the contract\\n  /// @dev Sets the pause flag to true\\n  function emergencyPause() external;\\n\\n  /// @notice This function unpauses the contract\\n  /// @dev Sets the pause flag to false\\n  function emergencyUnpause() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMerkleAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IMerkleAccessController {\\n  /// @notice Emitted when the contract owner updates the staking allowlist\\n  /// @param oldMerkleRoot The root of the old Staking allowlist merkle tree\\n  /// @param newMerkleRoot The root of a new Staking allowlist merkle tree\\n  event MerkleRootChanged(bytes32 oldMerkleRoot, bytes32 newMerkleRoot);\\n\\n  /// @notice Validates if a community staker has access to the private staking pool\\n  /// @param staker The community staker's address\\n  /// @param proof Merkle proof for the community staker's allowlist\\n  /// @return true If the staker has access to the private staking pool\\n  function hasAccess(address staker, bytes32[] calldata proof) external view returns (bool);\\n\\n  /// @notice This function is called to update the staking allowlist in a private staking pool\\n  /// @dev Only callable by the contract owner\\n  /// @param newMerkleRoot Merkle Tree root, used to prove access for community stakers\\n  /// will be required at opening but can be removed at any time by the owner when\\n  /// staking access will be granted to the public.\\n  function setMerkleRoot(bytes32 newMerkleRoot) external;\\n\\n  /// @notice This function returns the current root of the Staking allowlist merkle tree\\n  /// @return The current root of the Staking allowlist merkle tree\\n  function getMerkleRoot() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/pools/StakingPoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC677ReceiverInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol\\\";\\nimport {LinkTokenInterface} from \\\"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {IMigratable} from \\\"../interfaces/IMigratable.sol\\\";\\nimport {IRewardVault} from \\\"../interfaces/IRewardVault.sol\\\";\\nimport {IStakingOwner} from \\\"../interfaces/IStakingOwner.sol\\\";\\nimport {IStakingPool} from \\\"../interfaces/IStakingPool.sol\\\";\\nimport {Migratable} from \\\"../Migratable.sol\\\";\\nimport {PausableWithAccessControl} from \\\"../PausableWithAccessControl.sol\\\";\\n\\n/// @notice This contract is the base contract for staking pools. Each staking pool extends this\\n/// contract.\\n/// @dev This contract is abstract and must be inherited.\\n/// @dev invariant maxPoolSize must be greater than or equal to the totalPrincipal.\\n/// @dev invariant maxPoolSize must be greater than or equal to the maxPrincipalPerStaker.\\n/// @dev invariant contract's LINK token balance should be greater than or equal to the\\n/// totalPrincipal.\\n/// @dev invariant The migrated staked LINK amount must be less than or equal to the staker's staked\\n/// LINK amount +\\n/// rewards from the v0.1 staking pool.\\n/// @dev invariant The migrated staked LINK amount must be less than or equal to the\\n/// maxPrincipalPerStaker.\\n/// @dev We only support LINK token in v0.2 staking. Rebasing tokens, ERC777 tokens, fee-on-transfer\\n/// tokens or tokens that do not have 18 decimal places are not supported.\\nabstract contract StakingPoolBase is\\n  ERC677ReceiverInterface,\\n  IStakingPool,\\n  IStakingOwner,\\n  Migratable,\\n  PausableWithAccessControl\\n{\\n  using Checkpoints for Checkpoints.History;\\n  using SafeCast for uint256;\\n\\n  /// @notice This error is thrown when the staking pool is not active.\\n  error PoolNotActive();\\n\\n  /// @notice This error is thrown when the unbonding period is set to 0\\n  error InvalidUnbondingPeriod();\\n\\n  /// @notice This error is thrown when the claim period is set to 0\\n  error InvalidClaimPeriod();\\n\\n  /// @notice This error is thrown whenever a staker tries to unbond during\\n  /// their unbonding period.\\n  /// @param unbondingPeriodEndsAt The time the unbonding period is finished\\n  error UnbondingOrClaimPeriodActive(uint256 unbondingPeriodEndsAt);\\n\\n  /// @notice This error is thrown whenever a staker tries to unstake outside\\n  /// the claim period\\n  /// @param staker The staker trying to unstake\\n  error StakerNotInClaimPeriod(address staker);\\n\\n  /// @notice This error is thrown when an invalid claim period range is provided\\n  /// @param minClaimPeriod The min claim period\\n  /// @param maxClaimPeriod The max claim period\\n  error InvalidClaimPeriodRange(uint256 minClaimPeriod, uint256 maxClaimPeriod);\\n\\n  /// @notice This error is thrown when an invalid max unbonding period is provided\\n  /// @param maxUnbondingPeriod The max unbonding period\\n  error InvalidMaxUnbondingPeriod(uint256 maxUnbondingPeriod);\\n\\n  /// @notice This error is thrown when a staker tries to stake and the reward vault connected to\\n  /// this pool is not open or is paused\\n  error RewardVaultNotActive();\\n\\n  /// @notice This error is thrown when admin tries to open the pool and the reward vault connected\\n  /// to this pool has not had rewards added to it.\\n  error RewardVaultHasNoRewards();\\n\\n  /// @notice This error is thrown when admin tries to set a new reward vault and the old reward\\n  /// vault is not closed yet.\\n  error RewardVaultNotClosed();\\n\\n  /// @notice This event is emitted whenever a staker initiates the unbonding\\n  /// period.\\n  /// @param staker The staker that has started their unbonding period.\\n  event UnbondingPeriodStarted(address indexed staker);\\n\\n  /// @notice This event is emitted when a staker's unbonding period is reset\\n  /// @param staker The staker that has reset their unbonding period\\n  event UnbondingPeriodReset(address indexed staker);\\n\\n  /// @notice This event is emitted when the unbonding period has been changed\\n  /// @param oldUnbondingPeriod The old unbonding period\\n  /// @param newUnbondingPeriod The new unbonding period\\n  event UnbondingPeriodSet(uint256 oldUnbondingPeriod, uint256 newUnbondingPeriod);\\n\\n  /// @notice This event is emitted when the claim period is set\\n  /// @param oldClaimPeriod The old claim period\\n  /// @param newClaimPeriod The new claim period\\n  event ClaimPeriodSet(uint256 oldClaimPeriod, uint256 newClaimPeriod);\\n\\n  /// @notice This event is emitted when the reward vault is set\\n  /// @param oldRewardVault The old reward vault\\n  /// @param newRewardVault The new reward vault\\n  event RewardVaultSet(address indexed oldRewardVault, address indexed newRewardVault);\\n\\n  /// @notice This event is emitted when the staker is migrated to the migration target\\n  /// @param migrationTarget The migration target\\n  /// @param amount The staker's staked LINK amount that was migrated in juels\\n  /// @param migrationData The migration data\\n  event StakerMigrated(address indexed migrationTarget, uint256 amount, bytes migrationData);\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct ConstructorParamsBase {\\n    /// @notice The LINK Token\\n    LinkTokenInterface LINKAddress;\\n    /// @notice The initial maximum total stake amount for all stakers in the\\n    /// pool\\n    uint96 initialMaxPoolSize;\\n    /// @notice The initial maximum stake amount for a staker\\n    uint96 initialMaxPrincipalPerStaker;\\n    /// @notice The minimum stake amount that a staker must stake\\n    uint96 minPrincipalPerStaker;\\n    /// @notice The initial unbonding period\\n    uint32 initialUnbondingPeriod;\\n    /// @notice The max value that the unbonding period can be set to\\n    uint32 maxUnbondingPeriod;\\n    /// @notice The initial claim period\\n    uint32 initialClaimPeriod;\\n    /// @notice The min value that the claim period can be set to\\n    uint32 minClaimPeriod;\\n    /// @notice The max value that the claim period can be set to\\n    uint32 maxClaimPeriod;\\n    /// @notice The time it requires to transfer admin role\\n    uint48 adminRoleTransferDelay;\\n  }\\n\\n  /// @notice This struct defines the params that the pool is configured with\\n  struct PoolConfigs {\\n    /// @notice The max amount of staked LINK allowed in the pool in juels. The max value of this\\n    /// field is expected to be less than 1 billion (10^9 * 10^18), which is less than the max value\\n    /// that can be represented by a uint96 (~7.9*10^28).\\n    uint96 maxPoolSize;\\n    /// @notice The max amount of LINK a staker can stake in juels. The max value of this field is\\n    /// expected to be less than 1 million (10^6 * 10^18), which is less than the max value that can\\n    /// be represented by a uint96 (~7.9*10^28).\\n    uint96 maxPrincipalPerStaker;\\n    /// @notice The length of the unbonding period in seconds. The max value of this field is\\n    /// expected to be less than a year, or 30 million (3.2*10^7), which is less than the max value\\n    /// that can be represented by a uint32 (~4.2*10^9).\\n    uint32 unbondingPeriod;\\n    /// @notice The length of the claim period in seconds. The max value of this field is\\n    /// expected to be less than a year, or 30 million (3.2*10^7), which is less than the max value\\n    /// that can be represented by a uint32 (~4.2*10^9).\\n    uint32 claimPeriod;\\n  }\\n\\n  /// @notice This struct defines the state of the staking pool\\n  struct PoolState {\\n    /// @notice The total staked LINK amount amount in the pool\\n    uint256 totalPrincipal;\\n    /// @notice The time that the pool was closed\\n    uint256 closedAt;\\n  }\\n\\n  /// @notice This struct defines the global state and configuration of the pool\\n  struct Pool {\\n    /// @notice The pool's configuration\\n    PoolConfigs configs;\\n    /// @notice The pool's state\\n    PoolState state;\\n  }\\n\\n  /// @notice This is the ID for the initiator role, which is given to the\\n  /// addresses that will add open the pools, and set the merkle root for the community pool.\\n  /// @dev Hash: 6b8b15f1c11543d8280deaa7c24d12fffba6a357e4428e8c43e4234790186bff\\n  bytes32 public constant INITIATOR_ROLE = keccak256(\\\"INITIATOR_ROLE\\\");\\n  /// @notice The LINK token\\n  LinkTokenInterface internal immutable i_LINK;\\n  /// @notice The staking pool state and configuration\\n  Pool internal s_pool;\\n  /// @notice Mapping of a staker's address to their staker state\\n  mapping(address staker => IStakingPool.Staker) internal s_stakers;\\n  /// @notice Migration proxy address\\n  address internal s_migrationProxy;\\n  /// @notice The latest reward vault address\\n  IRewardVault internal s_rewardVault;\\n  /// @notice The min amount of LINK that a staker can stake\\n  uint96 internal immutable i_minPrincipalPerStaker;\\n  /// @notice The min value that the claim period can be set to\\n  uint32 private immutable i_minClaimPeriod;\\n  /// @notice The max value that the claim period can be set to\\n  uint32 private immutable i_maxClaimPeriod;\\n  /// @notice The max value that the unbonding period can be set to\\n  uint32 private immutable i_maxUnbondingPeriod;\\n  /// @notice Flag that signals if the staking pool is open for staking\\n  bool internal s_isOpen;\\n\\n  constructor(ConstructorParamsBase memory params)\\n    PausableWithAccessControl(params.adminRoleTransferDelay, msg.sender)\\n  {\\n    if (address(params.LINKAddress) == address(0)) revert InvalidZeroAddress();\\n    if (params.minPrincipalPerStaker == 0) revert InvalidMinStakeAmount();\\n    if (params.minPrincipalPerStaker >= params.initialMaxPrincipalPerStaker) {\\n      revert InvalidMinStakeAmount();\\n    }\\n    if (params.maxUnbondingPeriod == 0) {\\n      revert InvalidMaxUnbondingPeriod(params.maxUnbondingPeriod);\\n    }\\n    if (params.minClaimPeriod == 0 || params.minClaimPeriod >= params.maxClaimPeriod) {\\n      revert InvalidClaimPeriodRange(params.minClaimPeriod, params.maxClaimPeriod);\\n    }\\n\\n    i_LINK = params.LINKAddress;\\n    i_minPrincipalPerStaker = params.minPrincipalPerStaker;\\n\\n    i_maxUnbondingPeriod = params.maxUnbondingPeriod;\\n    _setUnbondingPeriod(params.initialUnbondingPeriod);\\n\\n    _setPoolConfig(params.initialMaxPoolSize, params.initialMaxPrincipalPerStaker);\\n\\n    i_minClaimPeriod = params.minClaimPeriod;\\n    i_maxClaimPeriod = params.maxClaimPeriod;\\n    _setClaimPeriod(params.initialClaimPeriod);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  /// @dev This will migrate the staker's staked LINK\\n  /// @dev precondition This contract must be closed and upgraded to a new pool.\\n  /// @dev precondition The migration target must be set.\\n  /// @dev precondition The caller must be staked in the pool.\\n  function migrate(bytes calldata data) external whenClosed validateMigrationTargetSet {\\n    // must be in storage to get access to latest()\\n    IStakingPool.Staker storage staker = s_stakers[msg.sender];\\n\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    uint112 stakerStakedAtTime = uint112(history);\\n    if (stakerPrincipal == 0) revert StakeNotFound(msg.sender);\\n\\n    bytes memory migrationData = abi.encode(msg.sender, stakerStakedAtTime, data);\\n\\n    // Finalize staker's rewards to include any rewards they have earned before resetting the\\n    // principal and stakedAtTime.\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: msg.sender,\\n      oldPrincipal: stakerPrincipal,\\n      stakedAt: stakerStakedAtTime,\\n      unstakedAmount: stakerPrincipal,\\n      shouldForfeit: false\\n    });\\n    s_pool.state.totalPrincipal -= stakerPrincipal;\\n\\n    // do not reset staked at time to not reset the multiplier because staker is not forfeiting\\n    // rewards when migrating\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: 0,\\n      latestStakedAtTime: stakerStakedAtTime\\n    });\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transferAndCall({to: s_migrationTarget, value: stakerPrincipal, data: migrationData});\\n    emit StakerMigrated(s_migrationTarget, stakerPrincipal, migrationData);\\n  }\\n\\n  /// @notice Starts the unbonding period for the staker.  A staker may unstake\\n  /// their staked LINK during the claim period that follows the unbonding period.\\n  /// @dev precondition The caller must be staked in the pool.\\n  /// @dev precondition The caller must not be in an unbonding period.\\n  /// @dev precondition The caller must not be in a claim period.\\n  function unbond() external virtual {\\n    Staker storage staker = s_stakers[msg.sender];\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    if (stakerPrincipal == 0) revert StakeNotFound(msg.sender);\\n\\n    _unbond(staker);\\n  }\\n\\n  /// @notice Sets the new unbonding period for the pool.  Stakers that are\\n  /// already unbonding will not be affected.\\n  /// @param newUnbondingPeriod The new unbonding period\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setUnbondingPeriod(uint256 newUnbondingPeriod)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    _setUnbondingPeriod(newUnbondingPeriod);\\n  }\\n\\n  /// @notice Returns the max unbonding period\\n  /// @return uint256 The max value that the unbonding period can be set to\\n  function getMaxUnbondingPeriod() external view returns (uint256) {\\n    return (i_maxUnbondingPeriod);\\n  }\\n\\n  /// @notice Set the claim period\\n  /// @param claimPeriod The claim period\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setClaimPeriod(uint256 claimPeriod)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    _setClaimPeriod(claimPeriod);\\n  }\\n\\n  /// @notice Sets the new reward vault for the pool\\n  /// @param newRewardVault The new reward vault\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setRewardVault(IRewardVault newRewardVault)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (address(newRewardVault) == address(0)) revert InvalidZeroAddress();\\n    address oldRewardVault = address(s_rewardVault);\\n    if (oldRewardVault == address(newRewardVault)) return;\\n    if (address(s_rewardVault) != address(0) && s_rewardVault.isOpen()) {\\n      revert RewardVaultNotClosed();\\n    }\\n    if (\\n      address(s_rewardVault) != address(0)\\n        && (!newRewardVault.isOpen() || newRewardVault.isPaused())\\n    ) revert RewardVaultNotActive();\\n    if (address(s_rewardVault) != address(0) && !newRewardVault.hasRewardAdded()) {\\n      revert RewardVaultHasNoRewards();\\n    }\\n\\n    s_rewardVault = newRewardVault;\\n    emit RewardVaultSet(oldRewardVault, address(newRewardVault));\\n  }\\n\\n  /// @notice LINK transfer callback function called when transferAndCall is called with this\\n  /// contract as a target.\\n  /// @param sender staker's address if they stake into the pool by calling transferAndCall on the\\n  /// LINK token, or MigrationProxy contract when a staker migrates from V0.1 to V0.2\\n  /// @param amount Amount of LINK token transferred\\n  /// @param data Bytes data received, represents migration path\\n  /// @inheritdoc ERC677ReceiverInterface\\n  /// @dev precondition The migration proxy must be set.\\n  /// @dev precondition This contract must be open and not paused.\\n  /// @dev precondition The reward vault must be open and not paused.\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external validateFromLINK validateMigrationProxySet whenOpen whenRewardVaultOpen whenNotPaused {\\n    if (amount == 0) return;\\n\\n    // Check if this call was forwarded from the migration proxy.\\n    address staker = sender == s_migrationProxy ? _getStakerAddress(data) : sender;\\n    if (staker == address(0)) revert InvalidZeroAddress();\\n\\n    // includes access check for non migration proxy\\n    _validateOnTokenTransfer(sender, staker, data);\\n\\n    Staker storage stakerState = s_stakers[staker];\\n    uint224 history = stakerState.history.latest();\\n    uint256 stakerPrincipal = uint256(history >> 112);\\n    uint256 stakedAt = uint112(history);\\n\\n    _resetUnbondingPeriod(stakerState, staker);\\n\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: staker,\\n      oldPrincipal: stakerPrincipal,\\n      unstakedAmount: 0,\\n      shouldForfeit: false,\\n      stakedAt: stakedAt\\n    });\\n\\n    _increaseStake(staker, stakerPrincipal + amount, amount);\\n  }\\n\\n  /// @notice Returns the minimum and maximum claim periods that can be set by the owner\\n  /// @return uint256 minimum claim period\\n  /// @return uint256 maximum claim period\\n  function getClaimPeriodLimits() external view returns (uint256, uint256) {\\n    return (i_minClaimPeriod, i_maxClaimPeriod);\\n  }\\n\\n  // =================\\n  // IStakingOwner\\n  // =================\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker\\n  ) external virtual onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\\n    _setPoolConfig(maxPoolSize, maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the initiator role.\\n  function open()\\n    external\\n    onlyRole(INITIATOR_ROLE)\\n    whenBeforeOpening\\n    validateRewardVaultSet\\n    whenRewardVaultOpen\\n    whenRewardVaultHasRewards\\n  {\\n    _validateBeforeOpen();\\n    s_isOpen = true;\\n    emit PoolOpened();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\\n    s_isOpen = false;\\n    s_pool.state.closedAt = block.timestamp;\\n    emit PoolClosed();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function setMigrationProxy(address migrationProxy)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (migrationProxy == address(0)) revert InvalidZeroAddress();\\n\\n    if (s_migrationProxy == migrationProxy) return;\\n    address oldMigrationProxy = s_migrationProxy;\\n    s_migrationProxy = migrationProxy;\\n\\n    emit MigrationProxySet(oldMigrationProxy, migrationProxy);\\n  }\\n\\n  // =================\\n  // IStakingPool\\n  // =================\\n\\n  /// @inheritdoc IStakingPool\\n  /// @dev precondition The caller must be staked in the pool.\\n  /// @dev precondition The caller must be in the claim period or the pool must be closed or paused.\\n  /// @dev There is a possible reentrancy attack here where a malicious admin\\n  /// can point this pool to a malicious reward vault that calls unstake on the\\n  /// pool again.  This reentrancy attack is possible as the pool updates the\\n  /// staker's staked LINK amount after it calls concludeRewardPeriod on the configured reward\\n  /// vault.  This scenario is mitigated by forcing the admin to go through\\n  /// a timelock period that is longer than the unbonding period, which will\\n  /// provide stakers sufficient time to withdraw their staked LINK from the\\n  /// pool before a malicious reward vault is set.\\n  function unstake(uint256 amount) external {\\n    // cannot unstake 0\\n    if (amount == 0) revert UnstakeZeroAmount();\\n\\n    Staker storage staker = s_stakers[msg.sender];\\n    if (!_canUnstake(staker)) {\\n      revert StakerNotInClaimPeriod(msg.sender);\\n    }\\n\\n    uint224 history = staker.history.latest();\\n    uint256 stakerPrincipal = uint256(history >> 112);\\n    uint256 stakedAt = uint112(history);\\n    // verify that the staker has enough staked LINK amount to unstake\\n    if (amount > stakerPrincipal) revert UnstakeExceedsPrincipal();\\n\\n    uint256 updatedPrincipal = stakerPrincipal - amount;\\n    // in the case of a partial withdrawal, verify new staked LINK amount is above minimum\\n    if (amount < stakerPrincipal && updatedPrincipal < i_minPrincipalPerStaker) {\\n      revert UnstakePrincipalBelowMinAmount();\\n    }\\n\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: msg.sender,\\n      oldPrincipal: stakerPrincipal,\\n      unstakedAmount: amount,\\n      shouldForfeit: true,\\n      stakedAt: stakedAt\\n    });\\n\\n    s_pool.state.totalPrincipal -= amount;\\n\\n    // Reset the staker's staked at time to 0 to prevent the multiplier\\n    // from growing if the staker has unstaked all their staked LINK\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: updatedPrincipal,\\n      latestStakedAtTime: updatedPrincipal == 0 ? 0 : block.timestamp\\n    });\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, amount);\\n\\n    emit Unstaked(msg.sender, amount, updatedPrincipal, s_pool.state.totalPrincipal);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getTotalPrincipal() external view returns (uint256) {\\n    return s_pool.state.totalPrincipal;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerPrincipal(address staker) external view returns (uint256) {\\n    return uint112(s_stakers[staker].history.latest() >> 112);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerPrincipalAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256) {\\n    // `Checkpoints` requires to exclude the current block when calling `getAtBlock`\\n    return (blockNumber == block.number)\\n      ? uint112(s_stakers[staker].history.latest() >> 112)\\n      : uint112(s_stakers[staker].history.getAtBlock(blockNumber) >> 112);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerStakedAtTime(address staker) external view returns (uint256) {\\n    return uint112(s_stakers[staker].history.latest());\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerStakedAtTimeAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256) {\\n    // `Checkpoints` requires to exclude the current block when calling `getAtBlock`\\n    return (blockNumber == block.number)\\n      ? uint112(s_stakers[staker].history.latest())\\n      : uint112(s_stakers[staker].history.getAtBlock(blockNumber));\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getRewardVault() external view returns (IRewardVault) {\\n    return s_rewardVault;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getChainlinkToken() external view returns (address) {\\n    return address(i_LINK);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getMigrationProxy() external view returns (address) {\\n    return s_migrationProxy;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function isOpen() external view returns (bool) {\\n    return s_isOpen;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function isActive() external view returns (bool) {\\n    return _isActive();\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerLimits() external view returns (uint256, uint256) {\\n    return (i_minPrincipalPerStaker, s_pool.configs.maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getMaxPoolSize() external view returns (uint256) {\\n    return s_pool.configs.maxPoolSize;\\n  }\\n\\n  /// @notice Returns the time a staker's unbonding period ends\\n  /// @param staker The address of the staker to query\\n  /// @return uint256 The timestamp of when the staker's unbonding period ends.\\n  /// This value will be 0 if the unbonding period is not active.\\n  function getUnbondingEndsAt(address staker) external view returns (uint256) {\\n    return s_stakers[staker].unbondingPeriodEndsAt;\\n  }\\n\\n  /// @notice Returns the pool's unbonding parameters\\n  /// @return uint256 The pool's unbonding period\\n  /// @return uint256 The pools's claim period\\n  function getUnbondingParams() external view returns (uint256, uint256) {\\n    return (s_pool.configs.unbondingPeriod, s_pool.configs.claimPeriod);\\n  }\\n\\n  /// @notice Returns the time a staker's claim period ends\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return uint256 The timestamp of when the staker's claim period ends.\\n  /// This value will be 0 if the unbonding period has not started.\\n  function getClaimPeriodEndsAt(address staker) external view returns (uint256) {\\n    return s_stakers[staker].claimPeriodEndsAt;\\n  }\\n\\n  // ===============\\n  // ERC165\\n  // ===============\\n\\n  /// @notice This function allows the calling contract to\\n  /// check if the contract deployed at this address is a valid\\n  /// LINKTokenReceiver.  A contract is a valid LINKTokenReceiver\\n  /// if it implements the onTokenTransfer function.\\n  /// @param interfaceID The ID of the interface to check against\\n  /// @return bool True if the contract is a valid LINKTokenReceiver.\\n  function supportsInterface(bytes4 interfaceID) public view override returns (bool) {\\n    return interfaceID == this.onTokenTransfer.selector || super.supportsInterface(interfaceID);\\n  }\\n\\n  // =========\\n  // Helpers\\n  // =========\\n\\n  /// @notice Resets a staker's unbonding period\\n  /// @param stakerState The staker's current state\\n  /// @param staker The address of the staker to reset the unbonding period for\\n  /// @dev This sets the stakerState's unbondingPeriodEndsAt and\\n  /// claimPeriodEndsAt to 0\\n  function _resetUnbondingPeriod(Staker storage stakerState, address staker) internal {\\n    if (stakerState.unbondingPeriodEndsAt != 0) {\\n      delete stakerState.unbondingPeriodEndsAt;\\n      delete stakerState.claimPeriodEndsAt;\\n      emit UnbondingPeriodReset(staker);\\n    }\\n  }\\n\\n  /// @inheritdoc Migratable\\n  /// @dev precondition The migration target must implement the onTokenTransfer function.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function _validateMigrationTarget(address newMigrationTarget) internal override whenBeforeClosing {\\n    Migratable._validateMigrationTarget(newMigrationTarget);\\n    if (\\n      !IERC165(newMigrationTarget).supportsInterface(\\n        ERC677ReceiverInterface.onTokenTransfer.selector\\n      )\\n    ) {\\n      revert InvalidMigrationTarget();\\n    }\\n  }\\n\\n  /// @notice Validate for when LINK is staked or migrated into the pool\\n  /// @param sender The address transferring LINK into the pool. Could be the migration proxy\\n  /// contract or the staker.\\n  /// @param staker The address staking or migrating LINK into the pool\\n  /// @param data Arbitrary data passed when staking or migrating\\n  function _validateOnTokenTransfer(\\n    address sender,\\n    address staker,\\n    bytes calldata data\\n  ) internal view virtual;\\n\\n  /// @notice Validates pool state before opening\\n  function _validateBeforeOpen() internal view virtual;\\n\\n  /// @notice Util function for setting the pool config\\n  /// @param maxPoolSize The max amount of staked LINK allowed in the pool\\n  /// @param maxPrincipalPerStaker The max amount of LINK a staker can stake\\n  /// in the pool.\\n  function _setPoolConfig(uint256 maxPoolSize, uint256 maxPrincipalPerStaker) internal {\\n    PoolConfigs storage configs = s_pool.configs;\\n    // only allow increasing the maxPoolSize\\n    if (maxPoolSize == 0 || maxPoolSize < configs.maxPoolSize) {\\n      revert InvalidPoolSize(maxPoolSize);\\n    }\\n    // only allow increasing the maxPrincipalPerStaker\\n    if (\\n      maxPrincipalPerStaker == 0 || maxPrincipalPerStaker > maxPoolSize\\n        || configs.maxPrincipalPerStaker > maxPrincipalPerStaker\\n    ) revert InvalidMaxStakeAmount(maxPrincipalPerStaker);\\n\\n    if (configs.maxPoolSize != maxPoolSize) {\\n      configs.maxPoolSize = maxPoolSize.toUint96();\\n      emit PoolSizeIncreased(maxPoolSize);\\n    }\\n    if (configs.maxPrincipalPerStaker != maxPrincipalPerStaker) {\\n      configs.maxPrincipalPerStaker = maxPrincipalPerStaker.toUint96();\\n      emit MaxPrincipalAmountIncreased(maxPrincipalPerStaker);\\n    }\\n  }\\n\\n  /// @notice Util function for setting the unbonding period\\n  /// @param unbondingPeriod The unbonding period\\n  function _setUnbondingPeriod(uint256 unbondingPeriod) internal {\\n    if (unbondingPeriod == 0 || unbondingPeriod > i_maxUnbondingPeriod) {\\n      revert InvalidUnbondingPeriod();\\n    }\\n\\n    if (s_pool.configs.unbondingPeriod == unbondingPeriod) return;\\n\\n    uint256 oldUnbondingPeriod = s_pool.configs.unbondingPeriod;\\n    s_pool.configs.unbondingPeriod = unbondingPeriod.toUint32();\\n    emit UnbondingPeriodSet(oldUnbondingPeriod, unbondingPeriod);\\n  }\\n\\n  /// @notice Updates the staking pool state and the staker state\\n  /// @param sender The staker address\\n  /// @param newPrincipal The staker's staked LINK amount after staking\\n  /// @param amount The amount to stake\\n  function _increaseStake(address sender, uint256 newPrincipal, uint256 amount) internal {\\n    Staker storage staker = s_stakers[sender];\\n\\n    // validate staking limits\\n    if (newPrincipal < i_minPrincipalPerStaker) {\\n      revert InsufficientStakeAmount();\\n    }\\n    if (newPrincipal > s_pool.configs.maxPrincipalPerStaker) {\\n      revert ExceedsMaxStakeAmount();\\n    }\\n    uint256 newTotalPrincipal = s_pool.state.totalPrincipal + amount;\\n    if (newTotalPrincipal > s_pool.configs.maxPoolSize) {\\n      revert ExceedsMaxPoolSize();\\n    }\\n\\n    // update the pool state\\n    s_pool.state.totalPrincipal = newTotalPrincipal;\\n\\n    // update the staker state\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: newPrincipal,\\n      latestStakedAtTime: block.timestamp\\n    });\\n\\n    emit Staked(sender, amount, newPrincipal, newTotalPrincipal);\\n  }\\n\\n  /// @notice Gets the staker address from the data passed by the MigrationProxy contract\\n  /// @param data The data passed by the MigrationProxy contract\\n  /// @return The staker address\\n  function _getStakerAddress(bytes calldata data) internal pure returns (address) {\\n    if (data.length == 0) revert InvalidData();\\n\\n    // decode the data\\n    (address staker) = abi.decode(data, (address));\\n\\n    return staker;\\n  }\\n\\n  /// @notice Checks to see whether or not a staker is eligible to\\n  /// unstake their staked LINK amount (when the pool is closed or, when the pool is open and they\\n  /// are in the claim period or, when pool is paused)\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return bool True if the staker is eligible to unstake\\n  function _canUnstake(Staker storage staker) internal view returns (bool) {\\n    return s_pool.state.closedAt != 0 || _inClaimPeriod(staker) || paused();\\n  }\\n\\n  /// @notice Updates the staker's staked LINK amount history\\n  /// @param staker The staker to update\\n  /// @param latestPrincipal The staker's latest staked LINK amount\\n  /// @param latestStakedAtTime The staker's latest average staked at time\\n  function _updateStakerHistory(\\n    Staker storage staker,\\n    uint256 latestPrincipal,\\n    uint256 latestStakedAtTime\\n  ) internal {\\n    staker.history.push(\\n      (uint224(uint112(latestPrincipal)) << 112) | uint224(uint112(latestStakedAtTime))\\n    );\\n  }\\n\\n  /// @notice Starts the unbonding period for the staker\\n  /// @param staker The staker trying to unbond\\n  function _unbond(Staker storage staker) internal {\\n    if (staker.unbondingPeriodEndsAt != 0 && block.timestamp <= staker.claimPeriodEndsAt) {\\n      revert UnbondingOrClaimPeriodActive(staker.unbondingPeriodEndsAt);\\n    }\\n    staker.unbondingPeriodEndsAt = (block.timestamp + s_pool.configs.unbondingPeriod).toUint128();\\n    staker.claimPeriodEndsAt = staker.unbondingPeriodEndsAt + s_pool.configs.claimPeriod;\\n    emit UnbondingPeriodStarted(msg.sender);\\n  }\\n\\n  /// @notice Checks to see whether or not a staker is within the claim period\\n  /// to unstake their staked LINK\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return bool True if the staker is inside the claim period\\n  function _inClaimPeriod(Staker storage staker) private view returns (bool) {\\n    if (staker.unbondingPeriodEndsAt == 0 || block.timestamp < staker.unbondingPeriodEndsAt) {\\n      return false;\\n    }\\n\\n    return block.timestamp <= staker.claimPeriodEndsAt;\\n  }\\n\\n  /// @notice Util function for setting the claim period\\n  /// @param claimPeriod The claim period\\n  function _setClaimPeriod(uint256 claimPeriod) private {\\n    if (claimPeriod < i_minClaimPeriod || claimPeriod > i_maxClaimPeriod) {\\n      revert InvalidClaimPeriod();\\n    }\\n\\n    if (s_pool.configs.claimPeriod == claimPeriod) return;\\n\\n    uint256 oldClaimPeriod = s_pool.configs.claimPeriod;\\n    s_pool.configs.claimPeriod = claimPeriod.toUint32();\\n\\n    emit ClaimPeriodSet(oldClaimPeriod, claimPeriod);\\n  }\\n\\n  /// @notice Util function to check if the reward vault connected to this pool has rewards added to\\n  /// it\\n  /// @return bool True if the reward vault has rewards added to it, false otherwise\\n  function _hasRewardVaultRewardAdded() internal view virtual returns (bool) {\\n    return s_rewardVault.hasRewardAdded();\\n  }\\n\\n  /// @notice Util function to check if the pool is active\\n  /// @return bool True if the pool is active, false otherwise\\n  function _isActive() internal view returns (bool) {\\n    return s_isOpen && !s_rewardVault.hasRewardDurationEnded(address(this));\\n  }\\n\\n  // =========\\n  // Modifiers\\n  // =========\\n\\n  /// @dev Reverts if not sent from the LINK token\\n  modifier validateFromLINK() {\\n    if (msg.sender != address(i_LINK)) revert SenderNotLinkToken();\\n    _;\\n  }\\n\\n  /// @dev Reverts if migration proxy is not set\\n  modifier validateMigrationProxySet() {\\n    if (s_migrationProxy == address(0)) revert MigrationProxyNotSet();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault is not set\\n  modifier validateRewardVaultSet() {\\n    if (address(s_rewardVault) == address(0)) revert RewardVaultNotSet();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is after an opening\\n  modifier whenBeforeOpening() {\\n    if (s_isOpen) revert PoolHasBeenOpened();\\n    if (s_pool.state.closedAt != 0) revert PoolHasBeenClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if the pool is already closed\\n  modifier whenBeforeClosing() {\\n    if (s_pool.state.closedAt != 0) revert PoolHasBeenClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not open\\n  modifier whenOpen() {\\n    if (!s_isOpen) revert PoolNotOpen();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not active (is open and rewards are available for this pool)\\n  modifier whenActive() {\\n    if (!_isActive()) revert PoolNotActive();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not closed\\n  modifier whenClosed() {\\n    if (s_pool.state.closedAt == 0) revert PoolNotClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault is not open or is paused\\n  modifier whenRewardVaultOpen() {\\n    if (!s_rewardVault.isOpen() || s_rewardVault.isPaused()) revert RewardVaultNotActive();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault has not had rewards added to it\\n  modifier whenRewardVaultHasRewards() {\\n    if (!_hasRewardVaultRewardAdded()) revert RewardVaultHasNoRewards();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISlashable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface ISlashable {\\n  /// @notice This error is thrown when the slasher config is invalid\\n  error InvalidSlasherConfig();\\n\\n  /// @notice This error is thrown when the contract manager tries to set the slasher role directly\\n  /// through\\n  /// `grantRole`\\n  error InvalidRole();\\n\\n  /// @notice This error is thrown then the contract manager tries to set the slasher config for an\\n  /// address\\n  /// that doesn't have the slasher role\\n  error InvalidSlasher();\\n\\n  /// @notice This struct defines the parameters of the slasher config\\n  struct SlasherConfig {\\n    /// @notice The pool's refill rate (Juels/sec)\\n    uint256 refillRate;\\n    /// @notice The refillable slash capacity amount\\n    uint256 slashCapacity;\\n  }\\n\\n  /// @notice This struct defines the parameters of the slasher state\\n  struct SlasherState {\\n    /// @notice The last slash timestamp, will be 0 if never slashed\\n    /// The timestamp will be set to the time the slashing configuration was configured\\n    /// instead of 0 if slashing never occurs, refilling slash capacity to full.\\n    uint256 lastSlashTimestamp;\\n    /// @notice The current amount of remaining slash capacity\\n    uint256 remainingSlashCapacityAmount;\\n  }\\n\\n  /// @notice This struct defines the slasher's state and config\\n  struct Slasher {\\n    /// @notice The slasher's config\\n    SlasherConfig config;\\n    /// @notice The slasher's state\\n    SlasherState state;\\n  }\\n\\n  /// @notice Adds a new slasher with the given config\\n  /// @param slasher The address of the slasher\\n  /// @param config The slasher config\\n  function addSlasher(address slasher, SlasherConfig calldata config) external;\\n\\n  /// @notice Removes a slasher by revoking the SLASHER_ROLE and resetting the slasher config\\n  /// @param slasher The address of the slasher\\n  function removeSlasher(address slasher) external;\\n\\n  /// @notice Sets the slasher config\\n  /// @param slasher The address of the slasher\\n  /// @param config The slasher config\\n  function setSlasherConfig(address slasher, SlasherConfig calldata config) external;\\n\\n  /// @notice Returns the slasher config\\n  /// @param slasher The slasher\\n  /// @return The slasher config\\n  function getSlasherConfig(address slasher) external view returns (SlasherConfig memory);\\n\\n  /// @notice Returns the slash capacity for a slasher\\n  /// @param slasher The slasher\\n  /// @return The slash capacity\\n  function getSlashCapacity(address slasher) external view returns (uint256);\\n\\n  /// @notice Slashes stakers and rewards the alerter.  Moves slashed staker\\n  /// funds into the alerter reward funds.  The alerter is then\\n  /// rewarded by the funds in the alerter reward funds.\\n  /// @param stakers The list of stakers to slash\\n  /// @param alerter The alerter that successfully raised the alert\\n  /// @param principalAmount The amount of the staker's staked LINK amount to slash\\n  /// @param alerterRewardAmount The reward amount to be given to the alerter\\n  function slashAndReward(\\n    address[] calldata stakers,\\n    address alerter,\\n    uint256 principalAmount,\\n    uint256 alerterRewardAmount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/IAccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.\\n *\\n * _Available since v4.9._\\n */\\ninterface IAccessControlDefaultAdminRules is IAccessControl {\\n    /**\\n     * @dev Emitted when a {defaultAdmin} transfer is started, setting `newAdmin` as the next\\n     * address to become the {defaultAdmin} by calling {acceptDefaultAdminTransfer} only after `acceptSchedule`\\n     * passes.\\n     */\\n    event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdmin} is reset if it was never accepted, regardless of its schedule.\\n     */\\n    event DefaultAdminTransferCanceled();\\n\\n    /**\\n     * @dev Emitted when a {defaultAdminDelay} change is started, setting `newDelay` as the next\\n     * delay to be applied between default admin transfer after `effectSchedule` has passed.\\n     */\\n    event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdminDelay} is reset if its schedule didn't pass.\\n     */\\n    event DefaultAdminDelayChangeCanceled();\\n\\n    /**\\n     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.\\n     */\\n    function defaultAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Returns a tuple of a `newAdmin` and an accept schedule.\\n     *\\n     * After the `schedule` passes, the `newAdmin` will be able to accept the {defaultAdmin} role\\n     * by calling {acceptDefaultAdminTransfer}, completing the role transfer.\\n     *\\n     * A zero value only in `acceptSchedule` indicates no pending admin transfer.\\n     *\\n     * NOTE: A zero address `newAdmin` means that {defaultAdmin} is being renounced.\\n     */\\n    function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Returns the delay required to schedule the acceptance of a {defaultAdmin} transfer started.\\n     *\\n     * This delay will be added to the current timestamp when calling {beginDefaultAdminTransfer} to set\\n     * the acceptance schedule.\\n     *\\n     * NOTE: If a delay change has been scheduled, it will take effect as soon as the schedule passes, making this\\n     * function returns the new delay. See {changeDefaultAdminDelay}.\\n     */\\n    function defaultAdminDelay() external view returns (uint48);\\n\\n    /**\\n     * @dev Returns a tuple of `newDelay` and an effect schedule.\\n     *\\n     * After the `schedule` passes, the `newDelay` will get into effect immediately for every\\n     * new {defaultAdmin} transfer started with {beginDefaultAdminTransfer}.\\n     *\\n     * A zero value only in `effectSchedule` indicates no pending delay change.\\n     *\\n     * NOTE: A zero value only for `newDelay` means that the next {defaultAdminDelay}\\n     * will be zero after the effect schedule.\\n     */\\n    function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Starts a {defaultAdmin} transfer by setting a {pendingDefaultAdmin} scheduled for acceptance\\n     * after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminRoleChangeStarted event.\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) external;\\n\\n    /**\\n     * @dev Cancels a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * A {pendingDefaultAdmin} not yet accepted can also be cancelled with this function.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function cancelDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Completes a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * After calling the function:\\n     *\\n     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.\\n     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.\\n     * - {pendingDefaultAdmin} should be reset to zero values.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the {pendingDefaultAdmin}'s `newAdmin`.\\n     * - The {pendingDefaultAdmin}'s `acceptSchedule` should've passed.\\n     */\\n    function acceptDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Initiates a {defaultAdminDelay} update by setting a {pendingDefaultAdminDelay} scheduled for getting\\n     * into effect after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * This function guarantees that any call to {beginDefaultAdminTransfer} done between the timestamp this\\n     * method is called and the {pendingDefaultAdminDelay} effect schedule will use the current {defaultAdminDelay}\\n     * set before calling.\\n     *\\n     * The {pendingDefaultAdminDelay}'s effect schedule is defined in a way that waiting until the schedule and then\\n     * calling {beginDefaultAdminTransfer} with the new delay will take at least the same as another {defaultAdmin}\\n     * complete transfer (including acceptance).\\n     *\\n     * The schedule is designed for two scenarios:\\n     *\\n     * - When the delay is changed for a larger one the schedule is `block.timestamp + newDelay` capped by\\n     * {defaultAdminDelayIncreaseWait}.\\n     * - When the delay is changed for a shorter one, the schedule is `block.timestamp + (current delay - new delay)`.\\n     *\\n     * A {pendingDefaultAdminDelay} that never got into effect will be canceled in favor of a new scheduled change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminDelayChangeScheduled event and may emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) external;\\n\\n    /**\\n     * @dev Cancels a scheduled {defaultAdminDelay} change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function rollbackDefaultAdminDelay() external;\\n\\n    /**\\n     * @dev Maximum time in seconds for an increase to {defaultAdminDelay} (that is scheduled using {changeDefaultAdminDelay})\\n     * to take effect. Default to 5 days.\\n     *\\n     * When the {defaultAdminDelay} is scheduled to be increased, it goes into effect after the new delay has passed with\\n     * the purpose of giving enough time for reverting any accidental change (i.e. using milliseconds instead of seconds)\\n     * that may lock the contract. However, to avoid excessive schedules, the wait is capped by this function and it can\\n     * be overrode for a custom {defaultAdminDelay} increase scheduling.\\n     *\\n     * IMPORTANT: Make sure to add a reasonable amount of time while overriding this value, otherwise,\\n     * there's a risk of setting a high new delay that goes into effect almost immediately without the\\n     * possibility of human intervention in the case of an input error (eg. set milliseconds instead of seconds).\\n     */\\n    function defaultAdminDelayIncreaseWait() external view returns (uint48);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC5313.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5313.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface for the Light Contract Ownership Standard.\\n *\\n * A standardized minimal interface required to identify an account that controls a contract\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC5313 {\\n    /**\\n     * @dev Gets the address of the owner.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface ERC677ReceiverInterface {\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"src/interfaces/IMigratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IMigratable {\\n  /// @notice This error is thrown when the owner tries to set the migration target to the\\n  /// zero address or an invalid address as well as when the migration target is not set and owner\\n  /// tries to migrate the contract.\\n  error InvalidMigrationTarget();\\n\\n  /// @notice This event is emitted when the migration target is set\\n  /// @param oldMigrationTarget The previous migration target\\n  /// @param newMigrationTarget The updated migration target\\n  event MigrationTargetSet(address indexed oldMigrationTarget, address indexed newMigrationTarget);\\n\\n  /// @notice Sets the address this contract will be upgraded to\\n  /// @param newMigrationTarget The address of the migration target\\n  function setMigrationTarget(address newMigrationTarget) external;\\n\\n  /// @notice Returns the current migration target of the contract\\n  /// @return address The current migration target\\n  function getMigrationTarget() external view returns (address);\\n\\n  /// @notice Migrates the contract\\n  /// @param data Optional calldata to call on new contract\\n  function migrate(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IStakingOwner {\\n  /// @notice This event is emitted when the staking pool is opened for staking\\n  event PoolOpened();\\n  /// @notice This event is emitted when the staking pool is closed\\n  event PoolClosed();\\n\\n  /// @notice This error is thrown when an invalid min operator stake amount is\\n  /// supplied\\n  error InvalidMinStakeAmount();\\n  /// @notice This error is raised when attempting to decrease maximum pool size\\n  /// @param maxPoolSize the proposed maximum pool size\\n  error InvalidPoolSize(uint256 maxPoolSize);\\n  /// @notice This error is raised when attempting to decrease maximum stake amount\\n  /// for the pool members\\n  /// @param maxStakeAmount the proposed maximum stake amount\\n  error InvalidMaxStakeAmount(uint256 maxStakeAmount);\\n\\n  /// @notice This error is thrown when the staking pool is closed.\\n  error PoolNotOpen();\\n\\n  /// @notice This error is thrown when the staking pool is open.\\n  error PoolNotClosed();\\n\\n  /// @notice This error is thrown when the staking pool has been opened and contract manager tries\\n  /// to re-open.\\n  error PoolHasBeenOpened();\\n\\n  /// @notice This error is thrown when the pool has been closed and contract manager tries to\\n  /// re-open\\n  error PoolHasBeenClosed();\\n\\n  /// @notice Set the pool config\\n  /// @param maxPoolSize The max amount of staked LINK allowed in the pool\\n  /// @param maxPrincipalPerStaker The max amount of LINK a staker can stake\\n  /// in the pool.\\n  function setPoolConfig(uint256 maxPoolSize, uint256 maxPrincipalPerStaker) external;\\n\\n  /// @notice Opens the pool for staking\\n  function open() external;\\n\\n  /// @notice Closes the pool\\n  function close() external;\\n\\n  /// @notice Sets the migration proxy contract address\\n  /// @param migrationProxy The migration proxy contract address\\n  function setMigrationProxy(address migrationProxy) external;\\n}\\n\"\r\n    },\r\n    \"src/Migratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\n\\nimport {IMigratable} from \\\"./interfaces/IMigratable.sol\\\";\\n\\n/// @notice Base contract that adds migration functionality.\\nabstract contract Migratable is IMigratable, AccessControlDefaultAdminRules {\\n  /// @notice The address of the new contract that this contract will be upgraded to.\\n  address internal s_migrationTarget;\\n\\n  function setMigrationTarget(address newMigrationTarget)\\n    external\\n    override\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    _validateMigrationTarget(newMigrationTarget);\\n\\n    address oldMigrationTarget = s_migrationTarget;\\n    s_migrationTarget = newMigrationTarget;\\n\\n    emit MigrationTargetSet(oldMigrationTarget, newMigrationTarget);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  function getMigrationTarget() external view returns (address) {\\n    return s_migrationTarget;\\n  }\\n\\n  /// @notice Helper function for validating the migration target\\n  /// @param newMigrationTarget The address of the new migration target\\n  function _validateMigrationTarget(address newMigrationTarget) internal virtual {\\n    if (\\n      newMigrationTarget == address(0) || newMigrationTarget == address(this)\\n        || newMigrationTarget == s_migrationTarget || newMigrationTarget.code.length == 0\\n    ) {\\n      revert InvalidMigrationTarget();\\n    }\\n  }\\n\\n  /// @dev Reverts if the migration target is not set\\n  modifier validateMigrationTargetSet() {\\n    if (s_migrationTarget == address(0)) {\\n      revert InvalidMigrationTarget();\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"linkToken\",\"type\":\"address\"},{\"internalType\":\"contract CommunityStakingPool\",\"name\":\"communityStakingPool\",\"type\":\"address\"},{\"internalType\":\"contract OperatorStakingPool\",\"name\":\"operatorStakingPool\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"delegationRate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"multiplierDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"adminRoleTransferDelay\",\"type\":\"uint48\"}],\"internalType\":\"struct RewardVault.ConstructorParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficentRewardsForDelegationRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegationRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEmissionRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRewardAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRewardToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardDurationTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultAlreadyClosed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseRewardPerToken\",\"type\":\"uint256\"}],\"name\":\"CommunityPoolRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminDelayChangeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"effectSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminDelayChangeScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"acceptSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminTransferScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDelegationRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDelegationRate\",\"type\":\"uint256\"}],\"name\":\"DelegationRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedRewardPerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reclaimedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOperatorReward\",\"type\":\"bool\"}],\"name\":\"ForfeitedRewardDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseRewardPerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegatedRewardPerToken\",\"type\":\"uint256\"}],\"name\":\"OperatorPoolRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emissionRate\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedRewards\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"shouldForfeit\",\"type\":\"bool\"}],\"name\":\"RewardFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedBaseReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestedDelegatedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseRewardPerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operatorDelegatedRewardPerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedBaseRewardsInPeriod\",\"type\":\"uint256\"}],\"name\":\"StakerRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalUnvestedRewards\",\"type\":\"uint256\"}],\"name\":\"VaultClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"VaultOpened\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionRate\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"beginDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"calculateLatestStakerReward\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"vestedBaseReward\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"vestedDelegatedReward\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"baseRewardPerToken\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"operatorDelegatedRewardPerToken\",\"type\":\"uint112\"},{\"internalType\":\"enum IRewardVault.StakerType\",\"name\":\"stakerType\",\"type\":\"uint8\"},{\"internalType\":\"uint112\",\"name\":\"claimedBaseRewardsInPeriod\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"unvestedBaseReward\",\"type\":\"uint112\"}],\"internalType\":\"struct IRewardVault.StakerReward\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"}],\"name\":\"changeDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shouldForfeit\",\"type\":\"bool\"}],\"name\":\"concludeRewardPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelayIncreaseWait\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelegationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinalVestingCheckpointData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"operatorPoolTotalPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityPoolTotalPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardVault.VestingCheckpointData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultiplierDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardBuckets\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"emissionRate\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"rewardDurationEndsAt\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"vestedRewardPerToken\",\"type\":\"uint80\"}],\"internalType\":\"struct RewardVault.RewardBucket\",\"name\":\"operatorBase\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint80\",\"name\":\"emissionRate\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"rewardDurationEndsAt\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"vestedRewardPerToken\",\"type\":\"uint80\"}],\"internalType\":\"struct RewardVault.RewardBucket\",\"name\":\"communityBase\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint80\",\"name\":\"emissionRate\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"rewardDurationEndsAt\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"vestedRewardPerToken\",\"type\":\"uint80\"}],\"internalType\":\"struct RewardVault.RewardBucket\",\"name\":\"operatorDelegated\",\"type\":\"tuple\"}],\"internalType\":\"struct RewardVault.RewardBuckets\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardPerTokenUpdatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStoredReward\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"vestedBaseReward\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"vestedDelegatedReward\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"baseRewardPerToken\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"operatorDelegatedRewardPerToken\",\"type\":\"uint112\"},{\"internalType\":\"enum IRewardVault.StakerType\",\"name\":\"stakerType\",\"type\":\"uint8\"},{\"internalType\":\"uint112\",\"name\":\"claimedBaseRewardsInPeriod\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"unvestedBaseReward\",\"type\":\"uint112\"}],\"internalType\":\"struct IRewardVault.StakerReward\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnvestedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasRewardAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"hasRewardDurationEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollbackDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelegationRate\",\"type\":\"uint256\"}],\"name\":\"setDelegationRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakerPrincipal\",\"type\":\"uint256\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardVault", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000bc10f2e862ed4502144c7d632a3459f49dfcdb5e000000000000000000000000a1d76a7ca72128541e9fcacafbda3a92ef94fdc50000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}