{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.9;\r\n\r\nlibrary console {\r\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\r\n\r\n    function _sendLogPayload(bytes memory payload) private view {\r\n        uint256 payloadLength = payload.length;\r\n        address consoleAddress = CONSOLE_ADDRESS;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let payloadStart := add(payload, 32)\r\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\r\n        }\r\n    }\r\n\r\n    function log() internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\r\n    }\r\n\r\n    function logInt(int p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\r\n    }\r\n\r\n    function logUint(uint p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\r\n    }\r\n\r\n    function logString(string memory p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\r\n    }\r\n\r\n    function logBool(bool p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\r\n    }\r\n\r\n    function logAddress(address p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\r\n    }\r\n\r\n    function logBytes(bytes memory p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\r\n    }\r\n\r\n    function logBytes1(bytes1 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\r\n    }\r\n\r\n    function logBytes2(bytes2 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\r\n    }\r\n\r\n    function logBytes3(bytes3 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\r\n    }\r\n\r\n    function logBytes4(bytes4 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\r\n    }\r\n\r\n    function logBytes5(bytes5 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\r\n    }\r\n\r\n    function logBytes6(bytes6 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\r\n    }\r\n\r\n    function logBytes7(bytes7 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\r\n    }\r\n\r\n    function logBytes8(bytes8 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\r\n    }\r\n\r\n    function logBytes9(bytes9 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\r\n    }\r\n\r\n    function logBytes10(bytes10 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\r\n    }\r\n\r\n    function logBytes11(bytes11 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\r\n    }\r\n\r\n    function logBytes12(bytes12 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\r\n    }\r\n\r\n    function logBytes13(bytes13 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\r\n    }\r\n\r\n    function logBytes14(bytes14 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\r\n    }\r\n\r\n    function logBytes15(bytes15 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\r\n    }\r\n\r\n    function logBytes16(bytes16 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\r\n    }\r\n\r\n    function logBytes17(bytes17 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\r\n    }\r\n\r\n    function logBytes18(bytes18 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\r\n    }\r\n\r\n    function logBytes19(bytes19 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\r\n    }\r\n\r\n    function logBytes20(bytes20 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\r\n    }\r\n\r\n    function logBytes21(bytes21 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\r\n    }\r\n\r\n    function logBytes22(bytes22 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\r\n    }\r\n\r\n    function logBytes23(bytes23 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\r\n    }\r\n\r\n    function logBytes24(bytes24 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\r\n    }\r\n\r\n    function logBytes25(bytes25 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\r\n    }\r\n\r\n    function logBytes26(bytes26 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\r\n    }\r\n\r\n    function logBytes27(bytes27 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\r\n    }\r\n\r\n    function logBytes28(bytes28 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\r\n    }\r\n\r\n    function logBytes29(bytes29 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\r\n    }\r\n\r\n    function logBytes30(bytes30 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\r\n    }\r\n\r\n    function logBytes31(bytes31 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\r\n    }\r\n\r\n    function logBytes32(bytes32 p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\r\n    }\r\n\r\n    function log(uint p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\r\n    }\r\n\r\n    function log(string memory p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\r\n    }\r\n\r\n    function log(bool p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\r\n    }\r\n\r\n    function log(address p0) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\r\n    }\r\n\r\n    function log(uint p0, uint p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\r\n    }\r\n\r\n    function log(uint p0, string memory p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\r\n    }\r\n\r\n    function log(uint p0, bool p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\r\n    }\r\n\r\n    function log(uint p0, address p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\r\n    }\r\n\r\n    function log(string memory p0, uint p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\r\n    }\r\n\r\n    function log(string memory p0, bool p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\r\n    }\r\n\r\n    function log(string memory p0, address p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\r\n    }\r\n\r\n    function log(bool p0, uint p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\r\n    }\r\n\r\n    function log(bool p0, string memory p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\r\n    }\r\n\r\n    function log(bool p0, bool p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\r\n    }\r\n\r\n    function log(bool p0, address p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\r\n    }\r\n\r\n    function log(address p0, uint p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\r\n    }\r\n\r\n    function log(address p0, string memory p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\r\n    }\r\n\r\n    function log(address p0, bool p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\r\n    }\r\n\r\n    function log(address p0, address p1) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\r\n    }\r\n\r\n    function log(uint p0, uint p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, uint p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, uint p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, uint p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, bool p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, bool p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, bool p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, bool p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, address p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, address p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, address p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, address p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, address p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, address p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, address p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(string memory p0, address p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, uint p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, uint p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, uint p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, uint p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, bool p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, bool p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, bool p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, bool p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, address p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, address p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, address p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(bool p0, address p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, uint p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, uint p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, uint p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, uint p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, string memory p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, string memory p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, string memory p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, string memory p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, bool p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, bool p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, bool p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, bool p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, address p1, uint p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, address p1, string memory p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, address p1, bool p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(address p0, address p1, address p2) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\r\n    }\r\n\r\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, uint p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, bool p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(uint p0, address p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(string memory p0, address p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, uint p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, bool p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(bool p0, address p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, uint p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, string memory p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, bool p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, uint p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, uint p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, uint p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, string memory p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, bool p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, bool p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, bool p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, address p2, uint p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, address p2, string memory p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, address p2, bool p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\r\n    }\r\n\r\n    function log(address p0, address p1, address p2, address p3) internal view {\r\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\r\n    }\r\n\r\n}\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n\r\n/// @notice Minimalist and modern Wrapped Ether implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\r\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\r\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\r\n    using SafeTransferLib for address;\r\n\r\n    event Deposit(address indexed from, uint256 amount);\r\n\r\n    event Withdrawal(address indexed to, uint256 amount);\r\n\r\n    function deposit() public payable virtual {\r\n        _mint(msg.sender, msg.value);\r\n\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public virtual {\r\n        _burn(msg.sender, amount);\r\n\r\n        emit Withdrawal(msg.sender, amount);\r\n\r\n        msg.sender.safeTransferETH(amount);\r\n    }\r\n\r\n    receive() external payable virtual {\r\n        deposit();\r\n    }\r\n}\r\n\r\n/// https://etherscan.io/address/0xdf0770dF86a8034b3EFEf0A1Bb3c889B8332FF56#code\r\nabstract contract LPTokenERC20 is ERC20 {\r\n    function amountLPtoLD(uint256 _lpAmount) external view virtual returns (uint256);\r\n\r\n    function totalLiquidity() external view virtual returns (uint256);\r\n}\r\n\r\n/// @dev\r\n/// https://etherscan.io/address/0xB0D502E938ed5f4df2E681fE6E419ff29631d62b#code\r\n/// basically a Goose MasterChef\r\ninterface ILPStaking {\r\n    function poolInfo(uint256 _pid)\r\n        external\r\n        view\r\n        returns (address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accStargatePerShare);\r\n\r\n    function userInfo(uint256 _pid, address _address) external view returns (uint256 amount, uint256 rewardDebt);\r\n\r\n    function deposit(uint256 _pid, uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _pid, uint256 _amount) external;\r\n}\r\n\r\n/// @dev https://etherscan.io/address/0x8731d54E9D02c286767d56ac03e8037C07e01e98#code\r\ninterface IStargateRouter {\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n    function addLiquidity(uint256 _poolId, uint256 _amountLD, address _to) external;\r\n\r\n    function instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLP, address _to) external returns (uint256);\r\n\r\n    function redeemLocal(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLP,\r\n        bytes calldata _to,\r\n        lzTxObj memory _lzTxParams\r\n    ) external payable;\r\n\r\n    function callDelta(uint256 _poolId, bool _fullMode) external;\r\n\r\n    function quoteLayerZeroFee(\r\n        uint16 _dstChainId,\r\n        uint8 _functionType,\r\n        bytes calldata _toAddress,\r\n        bytes calldata _transferAndCallPayload,\r\n        lzTxObj memory _lzTxParams\r\n    ) external view returns (uint256, uint256);\r\n}\r\n\r\n// https://github.com/Uniswap/swap-router-contracts/blob/main/contracts/interfaces/ISwapRouter02.sol\r\n\r\ninterface ISwapRouter02 {\r\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\n// https://etherscan.io/address/0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f\r\n// it's actually a UniswapV2Router02 but renamed for clarity vs actual uniswap\r\n\r\ninterface ISushiRouter {\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\n/// https://etherscan.io/address/0xBA12222222228d8Ba445958a75a0704d566BF2C8#code\r\n\r\ninterface IAsset {}\r\n\r\ninterface IVault {\r\n    struct JoinPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] maxAmountsIn;\r\n        bytes userData;\r\n        bool fromInternalBalance;\r\n    }\r\n\r\n    enum PoolSpecialization {\r\n        GENERAL,\r\n        MINIMAL_SWAP_INFO,\r\n        TWO_TOKEN\r\n    }\r\n\r\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\r\n\r\n    function getPoolTokens(bytes32 poolId)\r\n        external\r\n        view\r\n        returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\r\n\r\n    function getPoolTokenInfo(bytes32 poolId, address token)\r\n        external\r\n        view\r\n        returns (uint256 cash, uint256 managed, uint256 lastChangedBlock, address assetManager);\r\n\r\n    function queryExit(bytes32 poolId, address sender, address recipient, IVault.ExitPoolRequest memory request)\r\n        external\r\n        returns (uint256 bptIn, uint256[] memory amountsOut);\r\n\r\n    enum SwapKind {\r\n        GIVEN_IN,\r\n        GIVEN_OUT\r\n    }\r\n\r\n    struct BatchSwapStep {\r\n        bytes32 poolId;\r\n        uint256 assetInIndex;\r\n        uint256 assetOutIndex;\r\n        uint256 amount;\r\n        bytes userData;\r\n    }\r\n\r\n    struct FundManagement {\r\n        address sender;\r\n        bool fromInternalBalance;\r\n        address payable recipient;\r\n        bool toInternalBalance;\r\n    }\r\n\r\n    function batchSwap(\r\n        SwapKind kind,\r\n        BatchSwapStep[] memory swaps,\r\n        IAsset[] memory assets,\r\n        FundManagement memory funds,\r\n        int256[] memory limits,\r\n        uint256 deadline\r\n    ) external payable returns (int256[] memory);\r\n\r\n    struct SingleSwap {\r\n        bytes32 poolId;\r\n        SwapKind kind;\r\n        IAsset assetIn;\r\n        IAsset assetOut;\r\n        uint256 amount;\r\n        bytes userData;\r\n    }\r\n\r\n    function swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline)\r\n        external\r\n        returns (uint256 amountCalculated);\r\n\r\n    function exitPool(bytes32 poolId, address sender, address payable recipient, ExitPoolRequest memory request)\r\n        external;\r\n\r\n    struct ExitPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] minAmountsOut;\r\n        bytes userData;\r\n        bool toInternalBalance;\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    error Unauthorized();\r\n\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Public Functions\r\n\r\n    function acceptOwnership() external {\r\n        if (msg.sender != nominatedOwner) revert Unauthorized();\r\n        emit OwnerChanged(owner, msg.sender);\r\n        owner = msg.sender;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    // Restricted Functions: onlyOwner\r\n\r\n    /// @dev nominating zero address revokes a pending nomination\r\n    function nominateOwnership(address _newOwner) external onlyOwner {\r\n        nominatedOwner = _newOwner;\r\n    }\r\n\r\n    // Modifiers\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert Unauthorized();\r\n        _;\r\n    }\r\n}\r\n\r\n// https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/Path.sol\r\n\r\n//https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\nlibrary BytesLib {\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } { mstore(mc, mload(cc)) }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}\r\n\r\n/// @title Functions for manipulating path data for multihop swaps\r\nlibrary Path {\r\n    using BytesLib for bytes;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n    /// @dev The length of the bytes encoded fee\r\n    uint256 private constant FEE_SIZE = 3;\r\n\r\n    /// @dev The offset of a single token address and pool fee\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\r\n    /// @dev The offset of an encoded pool key\r\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\r\n    /// @dev The minimum length of an encoding that contains 2 or more pools\r\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\r\n\r\n    /// @notice Returns true iff the path contains two or more pools\r\n    /// @param path The encoded swap path\r\n    /// @return True if path contains two or more pools, otherwise false\r\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\r\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\r\n    }\r\n\r\n    /// @notice Returns the number of pools in the path\r\n    /// @param path The encoded swap path\r\n    /// @return The number of pools in the path\r\n    function numPools(bytes memory path) internal pure returns (uint256) {\r\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\r\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Decodes the first pool in path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return tokenA The first token of the given pool\r\n    /// @return tokenB The second token of the given pool\r\n    /// @return fee The fee level of the pool\r\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB, uint24 fee) {\r\n        tokenA = path.toAddress(0);\r\n        fee = path.toUint24(ADDR_SIZE);\r\n        tokenB = path.toAddress(NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Gets the segment corresponding to the first pool in the path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return The segment containing all data necessary to target the first pool in the path\r\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(0, POP_OFFSET);\r\n    }\r\n\r\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\r\n    /// @param path The swap path\r\n    /// @return The remaining token + fee elements in the path\r\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice\r\n * Swap contract used by strategies to:\r\n * 1. swap strategy rewards to 'asset'\r\n * 2. zap similar tokens to asset (e.g. USDT to USDC)\r\n */\r\ncontract Swap is Ownable {\r\n    using SafeTransferLib for ERC20;\r\n    using Path for bytes;\r\n\r\n    enum Route {\r\n        Unsupported,\r\n        UniswapV2,\r\n        UniswapV3Direct,\r\n        UniswapV3Path,\r\n        SushiSwap,\r\n        BalancerBatch,\r\n        BalancerSingle\r\n    }\r\n\r\n    /**\r\n     * @dev info depends on route:\r\n     * \t\tUniswapV2: address[] path\r\n     * \t\tUniswapV3Direct: uint24 fee\r\n     * \t\tUniswapV3Path: bytes path (address, uint24 fee, address, uint24 fee, address)\r\n     */\r\n    struct RouteInfo {\r\n        Route route;\r\n        bytes info;\r\n    }\r\n\r\n    ISushiRouter internal constant sushiswap = ISushiRouter(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n    /// @dev single address which supports both uniswap v2 and v3 routes\r\n    ISwapRouter02 internal constant uniswap = ISwapRouter02(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\r\n\r\n    IVault internal constant balancer = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\r\n\r\n    /// @dev tokenIn => tokenOut => routeInfo\r\n    mapping(address => mapping(address => RouteInfo)) public routes;\r\n\r\n    /*//////////////////\r\n    /      Events      /\r\n    //////////////////*/\r\n\r\n    event RouteSet(address indexed tokenIn, address indexed tokenOut, RouteInfo routeInfo);\r\n    event RouteRemoved(address indexed tokenIn, address indexed tokenOut);\r\n\r\n    /*//////////////////\r\n    /      Errors      /\r\n    //////////////////*/\r\n\r\n    error UnsupportedRoute(address tokenIn, address tokenOut);\r\n    error InvalidRouteInfo();\r\n\r\n    constructor() Ownable() {\r\n        address CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;\r\n        address CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\r\n        address LDO = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32;\r\n\r\n        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n        address STG = 0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6;\r\n        address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n        address BAL = 0xba100000625a3754423978a60c9317c58a424e3D;\r\n        address AURA = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\r\n\r\n        _setRoute(CRV, WETH, RouteInfo({route: Route.UniswapV3Direct, info: abi.encode(uint24(3_000))}));\r\n        _setRoute(CVX, WETH, RouteInfo({route: Route.UniswapV3Direct, info: abi.encode(uint24(10_000))}));\r\n        _setRoute(LDO, WETH, RouteInfo({route: Route.UniswapV3Direct, info: abi.encode(uint24(3_000))}));\r\n\r\n        _setRoute(CRV, USDC, RouteInfo({route: Route.UniswapV3Direct, info: abi.encode(uint24(10_000))}));\r\n        _setRoute(\r\n            CVX,\r\n            USDC,\r\n            RouteInfo({route: Route.UniswapV3Path, info: abi.encodePacked(CVX, uint24(10_000), WETH, uint24(500), USDC)})\r\n        );\r\n\r\n        _setRoute(USDC, USDT, RouteInfo({route: Route.UniswapV3Direct, info: abi.encode(uint24(100))}));\r\n\r\n        _setRoute(\r\n            STG,\r\n            USDC,\r\n            RouteInfo({\r\n                route: Route.BalancerSingle,\r\n                info: abi.encode(0x3ff3a210e57cfe679d9ad1e9ba6453a716c56a2e0002000000000000000005d5)\r\n            })\r\n        );\r\n        IAsset[] memory stgWethAssets = new IAsset[](4);\r\n        stgWethAssets[0] = IAsset(STG);\r\n        stgWethAssets[1] = IAsset(USDC);\r\n        stgWethAssets[2] = IAsset(0x79c58f70905F734641735BC61e45c19dD9Ad60bC); // 3pool\r\n        stgWethAssets[3] = IAsset(WETH);\r\n\r\n        bytes32[] memory stgWethPoolIds = new bytes32[](3);\r\n        stgWethPoolIds[0] = 0x3ff3a210e57cfe679d9ad1e9ba6453a716c56a2e0002000000000000000005d5; // STG/USDC\r\n        stgWethPoolIds[1] = 0x79c58f70905f734641735bc61e45c19dd9ad60bc0000000000000000000004e7; // 3pool\r\n        stgWethPoolIds[2] = 0x08775ccb6674d6bdceb0797c364c2653ed84f3840002000000000000000004f0; // 3pool/WETH\r\n\r\n        IVault.BatchSwapStep[] memory stgWethSteps = _constructBalancerBatchSwapSteps(stgWethPoolIds);\r\n\r\n        _setRoute(STG, WETH, RouteInfo({route: Route.BalancerBatch, info: abi.encode(stgWethSteps, stgWethAssets)}));\r\n\r\n        bytes32 balWethPoolId = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;\r\n        _setRoute(BAL, WETH, RouteInfo({route: Route.BalancerSingle, info: abi.encode(balWethPoolId)}));\r\n\r\n        bytes32 auraWethPoolId = 0xcfca23ca9ca720b6e98e3eb9b6aa0ffc4a5c08b9000200000000000000000274;\r\n        _setRoute(AURA, WETH, RouteInfo({route: Route.BalancerSingle, info: abi.encode(auraWethPoolId)}));\r\n    }\r\n\r\n    /*///////////////////////\r\n    /      Public View      /\r\n    ///////////////////////*/\r\n\r\n    function getRoute(address _tokenIn, address _tokenOut) external view returns (RouteInfo memory routeInfo) {\r\n        return routes[_tokenIn][_tokenOut];\r\n    }\r\n\r\n    /*////////////////////////////\r\n    /      Public Functions      /\r\n    ////////////////////////////*/\r\n\r\n    function swapTokens(address _tokenIn, address _tokenOut, uint256 _amount, uint256 _minReceived)\r\n        external\r\n        returns (uint256 received)\r\n    {\r\n        RouteInfo memory routeInfo = routes[_tokenIn][_tokenOut];\r\n\r\n        ERC20 tokenIn = ERC20(_tokenIn);\r\n        tokenIn.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        Route route = routeInfo.route;\r\n        bytes memory info = routeInfo.info;\r\n\r\n        if (route == Route.UniswapV2) {\r\n            received = _uniswapV2(_amount, _minReceived, info);\r\n        } else if (route == Route.UniswapV3Direct) {\r\n            received = _uniswapV3Direct(_tokenIn, _tokenOut, _amount, _minReceived, info);\r\n        } else if (route == Route.UniswapV3Path) {\r\n            received = _uniswapV3Path(_amount, _minReceived, info);\r\n        } else if (route == Route.SushiSwap) {\r\n            received = _sushiswap(_amount, _minReceived, info);\r\n        } else if (route == Route.BalancerBatch) {\r\n            received = _balancerBatch(_amount, _minReceived, info);\r\n        } else if (route == Route.BalancerSingle) {\r\n            received = _balancerSingle(_tokenIn, _tokenOut, _amount, _minReceived, info);\r\n        } else {\r\n            revert UnsupportedRoute(_tokenIn, _tokenOut);\r\n        }\r\n\r\n        // return unswapped amount to sender\r\n        uint256 balance = tokenIn.balanceOf(address(this));\r\n        if (balance > 0) tokenIn.safeTransfer(msg.sender, balance);\r\n    }\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Restricted Functions: onlyOwner      /\r\n    ///////////////////////////////////////////*/\r\n\r\n    function setRoute(address _tokenIn, address _tokenOut, RouteInfo memory _routeInfo) external onlyOwner {\r\n        _setRoute(_tokenIn, _tokenOut, _routeInfo);\r\n    }\r\n\r\n    function unsetRoute(address _tokenIn, address _tokenOut) external onlyOwner {\r\n        delete routes[_tokenIn][_tokenOut];\r\n        emit RouteRemoved(_tokenIn, _tokenOut);\r\n    }\r\n\r\n    /*//////////////////////////////\r\n    /      Internal Functions      /\r\n    //////////////////////////////*/\r\n\r\n    function _setRoute(address _tokenIn, address _tokenOut, RouteInfo memory _routeInfo) internal {\r\n        Route route = _routeInfo.route;\r\n        bytes memory info = _routeInfo.info;\r\n\r\n        if (route == Route.UniswapV2 || route == Route.SushiSwap) {\r\n            address[] memory path = abi.decode(info, (address[]));\r\n\r\n            if (path[0] != _tokenIn) revert InvalidRouteInfo();\r\n            if (path[path.length - 1] != _tokenOut) revert InvalidRouteInfo();\r\n        }\r\n\r\n        // just check that this doesn't throw an error\r\n        if (route == Route.UniswapV3Direct) abi.decode(info, (uint24));\r\n\r\n        if (route == Route.UniswapV3Path) {\r\n            bytes memory path = info;\r\n\r\n            // check first tokenIn\r\n            (address tokenIn,,) = path.decodeFirstPool();\r\n            if (tokenIn != _tokenIn) revert InvalidRouteInfo();\r\n\r\n            // check last tokenOut\r\n            while (path.hasMultiplePools()) path = path.skipToken();\r\n            (, address tokenOut,) = path.decodeFirstPool();\r\n            if (tokenOut != _tokenOut) revert InvalidRouteInfo();\r\n        }\r\n\r\n        // just check that these don't throw an error, i.e. the poolId contains both _tokenIn\r\n        if (route == Route.BalancerSingle) {\r\n            bytes32 poolId = abi.decode(info, (bytes32));\r\n            balancer.getPoolTokenInfo(poolId, _tokenIn);\r\n            balancer.getPoolTokenInfo(poolId, _tokenOut);\r\n        }\r\n\r\n        address router = _getRouterAddress(route);\r\n\r\n        ERC20(_tokenIn).safeApprove(router, 0);\r\n        ERC20(_tokenIn).safeApprove(router, type(uint256).max);\r\n\r\n        routes[_tokenIn][_tokenOut] = _routeInfo;\r\n        emit RouteSet(_tokenIn, _tokenOut, _routeInfo);\r\n    }\r\n\r\n    function _uniswapV2(uint256 _amount, uint256 _minReceived, bytes memory _path) internal returns (uint256) {\r\n        address[] memory path = abi.decode(_path, (address[]));\r\n\r\n        return uniswap.swapExactTokensForTokens(_amount, _minReceived, path, msg.sender);\r\n    }\r\n\r\n    function _sushiswap(uint256 _amount, uint256 _minReceived, bytes memory _path) internal returns (uint256) {\r\n        address[] memory path = abi.decode(_path, (address[]));\r\n\r\n        uint256[] memory received =\r\n            sushiswap.swapExactTokensForTokens(_amount, _minReceived, path, msg.sender, type(uint256).max);\r\n\r\n        return received[received.length - 1];\r\n    }\r\n\r\n    function _uniswapV3Direct(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amount,\r\n        uint256 _minReceived,\r\n        bytes memory _info\r\n    ) internal returns (uint256) {\r\n        uint24 fee = abi.decode(_info, (uint24));\r\n\r\n        return uniswap.exactInputSingle(\r\n            ISwapRouter02.ExactInputSingleParams({\r\n                tokenIn: _tokenIn,\r\n                tokenOut: _tokenOut,\r\n                fee: fee,\r\n                recipient: msg.sender,\r\n                amountIn: _amount,\r\n                amountOutMinimum: _minReceived,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    function _uniswapV3Path(uint256 _amount, uint256 _minReceived, bytes memory _path) internal returns (uint256) {\r\n        return uniswap.exactInput(\r\n            ISwapRouter02.ExactInputParams({\r\n                path: _path,\r\n                recipient: msg.sender,\r\n                amountIn: _amount,\r\n                amountOutMinimum: _minReceived\r\n            })\r\n        );\r\n    }\r\n\r\n    function _balancerBatch(uint256 _amount, uint256 _minReceived, bytes memory _info) internal returns (uint256) {\r\n        (IVault.BatchSwapStep[] memory steps, IAsset[] memory assets) =\r\n            abi.decode(_info, (IVault.BatchSwapStep[], IAsset[]));\r\n\r\n        steps[0].amount = _amount;\r\n\r\n        int256[] memory limits = new int256[](assets.length);\r\n\r\n        limits[0] = int256(_amount);\r\n        limits[limits.length - 1] = -int256(_minReceived);\r\n\r\n        int256[] memory received = balancer.batchSwap(\r\n            IVault.SwapKind.GIVEN_IN,\r\n            steps,\r\n            assets,\r\n            IVault.FundManagement({\r\n                sender: address(this),\r\n                fromInternalBalance: false,\r\n                recipient: payable(address(msg.sender)),\r\n                toInternalBalance: false\r\n            }),\r\n            limits,\r\n            type(uint256).max\r\n        );\r\n\r\n        return uint256(-received[received.length - 1]);\r\n    }\r\n\r\n    function _balancerSingle(\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _amount,\r\n        uint256 _minReceived,\r\n        bytes memory _info\r\n    ) internal returns (uint256) {\r\n        bytes32 poolId = abi.decode(_info, (bytes32));\r\n\r\n        return balancer.swap(\r\n            IVault.SingleSwap({\r\n                poolId: poolId,\r\n                kind: IVault.SwapKind.GIVEN_IN,\r\n                assetIn: IAsset(_tokenIn),\r\n                assetOut: IAsset(_tokenOut),\r\n                amount: _amount,\r\n                userData: \"\"\r\n            }),\r\n            IVault.FundManagement({\r\n                sender: address(this),\r\n                fromInternalBalance: false,\r\n                recipient: payable(address(msg.sender)),\r\n                toInternalBalance: false\r\n            }),\r\n            _minReceived,\r\n            type(uint256).max\r\n        );\r\n    }\r\n\r\n    function _getRouterAddress(Route _route) internal pure returns (address) {\r\n        if (_route == Route.SushiSwap) {\r\n            return address(sushiswap);\r\n        } else if (_route == Route.UniswapV2 || _route == Route.UniswapV3Direct || _route == Route.UniswapV3Path) {\r\n            return address(uniswap);\r\n        } else if (_route == Route.BalancerBatch || _route == Route.BalancerSingle) {\r\n            return address(balancer);\r\n        } else {\r\n            revert InvalidRouteInfo();\r\n        }\r\n    }\r\n\r\n    function _constructBalancerBatchSwapSteps(bytes32[] memory _poolIds)\r\n        internal\r\n        pure\r\n        returns (IVault.BatchSwapStep[] memory steps)\r\n    {\r\n        uint256 length = _poolIds.length;\r\n        steps = new IVault.BatchSwapStep[](length);\r\n\r\n        for (uint8 i = 0; i < length; ++i) {\r\n            steps[i] = IVault.BatchSwapStep({\r\n                poolId: _poolIds[i],\r\n                assetInIndex: i,\r\n                assetOutIndex: i + 1,\r\n                amount: 0,\r\n                userData: \"\"\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide x * y by the denominator.\r\n            z := div(mul(x, y), denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // If x * y modulo the denominator is strictly greater than 0,\r\n            // 1 is added to round up the division of x * y by the denominator.\r\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let y := x // We start y at x, which will help us make our initial estimate.\r\n\r\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\r\n\r\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\r\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\r\n\r\n            // We check y >= 2^(k + 8) but shift right by k bits\r\n            // each branch to ensure that if x >= 256, then y >= 256.\r\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\r\n                y := shr(128, y)\r\n                z := shl(64, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000000000000000)) {\r\n                y := shr(64, y)\r\n                z := shl(32, z)\r\n            }\r\n            if iszero(lt(y, 0x10000000000)) {\r\n                y := shr(32, y)\r\n                z := shl(16, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000)) {\r\n                y := shr(16, y)\r\n                z := shl(8, z)\r\n            }\r\n\r\n            // Goal was to get z*z*y within a small factor of x. More iterations could\r\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\r\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\r\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\r\n\r\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\r\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\r\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\r\n\r\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\r\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\r\n\r\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\r\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\r\n\r\n            // There is no overflow risk here since y < 2^136 after the first branch above.\r\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\r\n\r\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // If x+1 is a perfect square, the Babylonian method cycles between\r\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\r\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\r\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\r\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\r\n            z := sub(z, lt(div(x, z), z))\r\n        }\r\n    }\r\n\r\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Mod x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            z := mod(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Divide x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            r := div(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Add 1 to x * y if x % y > 0. Note this will\r\n            // return 0 instead of reverting if y is zero.\r\n            z := add(gt(mod(x, y), 0), div(x, y))\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownership {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    address public admin;\r\n\r\n    mapping(address => bool) public authorized;\r\n\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n    event AuthAdded(address indexed newAuth);\r\n    event AuthRemoved(address indexed oldAuth);\r\n\r\n    error Unauthorized();\r\n    error AlreadyRole();\r\n    error NotRole();\r\n\r\n    /// @param _authorized maximum of 256 addresses in constructor\r\n    constructor(address _nominatedOwner, address _admin, address[] memory _authorized) {\r\n        owner = msg.sender;\r\n        nominatedOwner = _nominatedOwner;\r\n        admin = _admin;\r\n        for (uint8 i = 0; i < _authorized.length; ++i) {\r\n            authorized[_authorized[i]] = true;\r\n            emit AuthAdded(_authorized[i]);\r\n        }\r\n    }\r\n\r\n    // Public Functions\r\n\r\n    function acceptOwnership() external {\r\n        if (msg.sender != nominatedOwner) revert Unauthorized();\r\n        emit OwnerChanged(owner, msg.sender);\r\n        owner = msg.sender;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    // Restricted Functions: onlyOwner\r\n\r\n    /// @dev nominating zero address revokes a pending nomination\r\n    function nominateOwnership(address _newOwner) external onlyOwner {\r\n        nominatedOwner = _newOwner;\r\n    }\r\n\r\n    function setAdmin(address _newAdmin) external onlyOwner {\r\n        if (admin == _newAdmin) revert AlreadyRole();\r\n        admin = _newAdmin;\r\n    }\r\n\r\n    // Restricted Functions: onlyAdmins\r\n\r\n    function addAuthorized(address _authorized) external onlyAdmins {\r\n        if (authorized[_authorized]) revert AlreadyRole();\r\n        authorized[_authorized] = true;\r\n        emit AuthAdded(_authorized);\r\n    }\r\n\r\n    function removeAuthorized(address _authorized) external onlyAdmins {\r\n        if (!authorized[_authorized]) revert NotRole();\r\n        authorized[_authorized] = false;\r\n        emit AuthRemoved(_authorized);\r\n    }\r\n\r\n    // Modifiers\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert Unauthorized();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmins() {\r\n        if (msg.sender != owner && msg.sender != admin) revert Unauthorized();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != owner && msg.sender != admin && !authorized[msg.sender]) revert Unauthorized();\r\n        _;\r\n    }\r\n}\r\n\r\nabstract contract BlockDelay {\r\n    /// @notice delay before functions with 'useBlockDelay' can be called by the same address\r\n    /// @dev 0 means no delay\r\n    uint256 public blockDelay;\r\n    uint256 internal constant MAX_BLOCK_DELAY = 10;\r\n\r\n    mapping(address => uint256) public lastBlock;\r\n\r\n    error AboveMaxBlockDelay();\r\n    error BeforeBlockDelay();\r\n\r\n    constructor(uint8 _delay) {\r\n        _setBlockDelay(_delay);\r\n    }\r\n\r\n    function _setBlockDelay(uint8 _newDelay) internal {\r\n        if (_newDelay > MAX_BLOCK_DELAY) revert AboveMaxBlockDelay();\r\n        blockDelay = _newDelay;\r\n    }\r\n\r\n    modifier useBlockDelay(address _address) {\r\n        if (block.number < lastBlock[_address] + blockDelay) revert BeforeBlockDelay();\r\n        lastBlock[_address] = block.number;\r\n        _;\r\n    }\r\n}\r\n\r\n/// @notice https://eips.ethereum.org/EIPS/eip-4626\r\ninterface IERC4626 {\r\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\r\n    );\r\n\r\n    function asset() external view returns (ERC20);\r\n\r\n    function totalAssets() external view returns (uint256 assets);\r\n\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    function maxDeposit(address receiver) external view returns (uint256 assets);\r\n\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    function maxMint(address receiver) external view returns (uint256 shares);\r\n\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    function maxWithdraw(address owner) external view returns (uint256 assets);\r\n\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    function maxRedeem(address owner) external view returns (uint256 shares);\r\n\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\ncontract Vault is ERC20, IERC4626, Ownership, BlockDelay {\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    /// @notice token which the vault uses and accumulates\r\n    ERC20 public immutable asset;\r\n\r\n    /// @notice whether deposits and withdrawals are paused\r\n    bool public paused;\r\n\r\n    uint256 private _lockedProfit;\r\n    /// @notice timestamp of last report, used for locked profit calculations\r\n    uint256 public lastReport;\r\n    /// @notice period over which profits are gradually unlocked, defense against sandwich attacks\r\n    uint256 public lockedProfitDuration = 24 hours;\r\n    uint256 internal constant MAX_LOCKED_PROFIT_DURATION = 3 days;\r\n\r\n    /// @dev maximum user can deposit in a single tx\r\n    uint256 private _maxDeposit = type(uint256).max;\r\n\r\n    struct StrategyParams {\r\n        bool added;\r\n        uint256 debt;\r\n        uint256 debtRatio;\r\n    }\r\n\r\n    Strategy[] private _queue;\r\n    mapping(Strategy => StrategyParams) public strategies;\r\n\r\n    uint8 internal constant MAX_QUEUE_LENGTH = 20;\r\n\r\n    uint256 public totalDebt;\r\n    /// @dev proportion of funds kept in vault to facilitate user withdrawals\r\n    uint256 public floatDebtRatio;\r\n    uint256 public totalDebtRatio;\r\n    uint256 internal constant MAX_TOTAL_DEBT_RATIO = 1_000;\r\n\r\n    /*//////////////////\r\n    /      Events      /\r\n    //////////////////*/\r\n\r\n    event Report(Strategy indexed strategy, uint256 harvested, uint256 gain, uint256 loss);\r\n    event Lend(Strategy indexed strategy, uint256 assets, uint256 slippage);\r\n    event Collect(Strategy indexed strategy, uint256 received, uint256 slippage, uint256 bonus);\r\n\r\n    event StrategyAdded(Strategy indexed strategy, uint256 debtRatio);\r\n    event StrategyDebtRatioChanged(Strategy indexed strategy, uint256 newDebtRatio);\r\n    event StrategyRemoved(Strategy indexed strategy);\r\n    event StrategyQueuePositionsSwapped(uint8 i, uint8 j, Strategy indexed newI, Strategy indexed newJ);\r\n\r\n    event LockedProfitDurationChanged(uint256 newDuration);\r\n    event MaxDepositChanged(uint256 newMaxDeposit);\r\n    event FloatDebtRatioChanged(uint256 newFloatDebtRatio);\r\n\r\n    /*//////////////////\r\n    /      Errors      /\r\n    //////////////////*/\r\n\r\n    error Zero();\r\n    error BelowMinimum(uint256);\r\n    error AboveMaximum(uint256);\r\n\r\n    error AboveMaxDeposit();\r\n\r\n    error AlreadyStrategy();\r\n    error NotStrategy();\r\n    error StrategyDoesNotBelongToQueue();\r\n    error StrategyQueueFull();\r\n\r\n    error AlreadyValue();\r\n\r\n    error Paused();\r\n\r\n    /// @dev e.g. USDC becomes 'Unagii USD Coin Vault v3' and 'uUSDCv3'\r\n    constructor(\r\n        ERC20 _asset,\r\n        uint8 _blockDelay,\r\n        uint256 _floatDebtRatio,\r\n        address _nominatedOwner,\r\n        address _admin,\r\n        address[] memory _authorized\r\n    )\r\n        ERC20(\r\n            string(abi.encodePacked(\"Unagii \", _asset.name(), \" Vault v3\")),\r\n            string(abi.encodePacked(\"u\", _asset.symbol(), \"v3\")),\r\n            _asset.decimals()\r\n        )\r\n        Ownership(_nominatedOwner, _admin, _authorized)\r\n        BlockDelay(_blockDelay)\r\n    {\r\n        asset = _asset;\r\n        _setFloatDebtRatio(_floatDebtRatio);\r\n    }\r\n\r\n    /*///////////////////////\r\n    /      Public View      /\r\n    ///////////////////////*/\r\n\r\n    function queue() external view returns (Strategy[] memory) {\r\n        return _queue;\r\n    }\r\n\r\n    function totalAssets() public view returns (uint256 assets) {\r\n        return asset.balanceOf(address(this)) + totalDebt;\r\n    }\r\n\r\n    function lockedProfit() public view returns (uint256 lockedAssets) {\r\n        uint256 last = lastReport;\r\n        uint256 duration = lockedProfitDuration;\r\n\r\n        unchecked {\r\n            // won't overflow since time is nowhere near uint256.max\r\n            if (block.timestamp >= last + duration) return 0;\r\n            // can overflow if _lockedProfit * difference > uint256.max but in practice should never happen\r\n            return _lockedProfit - _lockedProfit.mulDivDown(block.timestamp - last, duration);\r\n        }\r\n    }\r\n\r\n    function freeAssets() public view returns (uint256 assets) {\r\n        return totalAssets() - lockedProfit();\r\n    }\r\n\r\n    function convertToShares(uint256 _assets) public view returns (uint256 shares) {\r\n        uint256 supply = totalSupply;\r\n        return supply == 0 ? _assets : _assets.mulDivDown(supply, totalAssets());\r\n    }\r\n\r\n    function convertToAssets(uint256 _shares) public view returns (uint256 assets) {\r\n        uint256 supply = totalSupply;\r\n        return supply == 0 ? _shares : _shares.mulDivDown(totalAssets(), supply);\r\n    }\r\n\r\n    function maxDeposit(address) external view returns (uint256 assets) {\r\n        return _maxDeposit;\r\n    }\r\n\r\n    function previewDeposit(uint256 _assets) public view returns (uint256 shares) {\r\n        return convertToShares(_assets);\r\n    }\r\n\r\n    function maxMint(address) external view returns (uint256 shares) {\r\n        return convertToShares(_maxDeposit);\r\n    }\r\n\r\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\r\n        uint256 supply = totalSupply;\r\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\r\n    }\r\n\r\n    function maxWithdraw(address owner) external view returns (uint256 assets) {\r\n        return convertToAssets(balanceOf[owner]);\r\n    }\r\n\r\n    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {\r\n        uint256 supply = totalSupply;\r\n        return supply == 0 ? assets : assets.mulDivUp(supply, freeAssets());\r\n    }\r\n\r\n    function maxRedeem(address _owner) external view returns (uint256 shares) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    function previewRedeem(uint256 shares) public view returns (uint256 assets) {\r\n        uint256 supply = totalSupply;\r\n        return supply == 0 ? shares : shares.mulDivDown(freeAssets(), supply);\r\n    }\r\n\r\n    /*////////////////////////////\r\n    /      Public Functions      /\r\n    ////////////////////////////*/\r\n\r\n    function safeDeposit(uint256 _assets, address _receiver, uint256 _minShares) external returns (uint256 shares) {\r\n        shares = deposit(_assets, _receiver);\r\n        if (shares < _minShares) revert BelowMinimum(shares);\r\n    }\r\n\r\n    function safeMint(uint256 _shares, address _receiver, uint256 _maxAssets) external returns (uint256 assets) {\r\n        assets = mint(_shares, _receiver);\r\n        if (assets > _maxAssets) revert AboveMaximum(assets);\r\n    }\r\n\r\n    function safeWithdraw(uint256 _assets, address _receiver, address _owner, uint256 _maxShares)\r\n        external\r\n        returns (uint256 shares)\r\n    {\r\n        shares = withdraw(_assets, _receiver, _owner);\r\n        if (shares > _maxShares) revert AboveMaximum(shares);\r\n    }\r\n\r\n    function safeRedeem(uint256 _shares, address _receiver, address _owner, uint256 _minAssets)\r\n        external\r\n        returns (uint256 assets)\r\n    {\r\n        assets = redeem(_shares, _receiver, _owner);\r\n        if (assets < _minAssets) revert BelowMinimum(assets);\r\n    }\r\n\r\n    /*////////////////////////////////////\r\n    /      ERC4626 Public Functions      /\r\n    ////////////////////////////////////*/\r\n\r\n    function deposit(uint256 _assets, address _receiver) public whenNotPaused returns (uint256 shares) {\r\n        if ((shares = previewDeposit(_assets)) == 0) revert Zero();\r\n\r\n        _deposit(_assets, shares, _receiver);\r\n    }\r\n\r\n    function mint(uint256 _shares, address _receiver) public whenNotPaused returns (uint256 assets) {\r\n        if (_shares == 0) revert Zero();\r\n        assets = previewMint(_shares);\r\n\r\n        _deposit(assets, _shares, _receiver);\r\n    }\r\n\r\n    function withdraw(uint256 _assets, address _receiver, address _owner) public returns (uint256 shares) {\r\n        if (_assets == 0) revert Zero();\r\n        shares = previewWithdraw(_assets);\r\n\r\n        _withdraw(_assets, shares, _owner, _receiver);\r\n    }\r\n\r\n    function redeem(uint256 _shares, address _receiver, address _owner) public returns (uint256 assets) {\r\n        if ((assets = previewRedeem(_shares)) == 0) revert Zero();\r\n\r\n        return _withdraw(assets, _shares, _owner, _receiver);\r\n    }\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Restricted Functions: onlyOwner      /\r\n    ///////////////////////////////////////////*/\r\n\r\n    function addStrategy(Strategy _strategy, uint256 _debtRatio) external onlyOwner {\r\n        if (_strategy.vault() != this) revert StrategyDoesNotBelongToQueue();\r\n        if (strategies[_strategy].added) revert AlreadyStrategy();\r\n        if (_queue.length >= MAX_QUEUE_LENGTH) revert StrategyQueueFull();\r\n\r\n        totalDebtRatio += _debtRatio;\r\n        if (totalDebtRatio > MAX_TOTAL_DEBT_RATIO) revert AboveMaximum(totalDebtRatio);\r\n\r\n        strategies[_strategy] = StrategyParams({added: true, debt: 0, debtRatio: _debtRatio});\r\n        _queue.push(_strategy);\r\n\r\n        emit StrategyAdded(_strategy, _debtRatio);\r\n    }\r\n\r\n    /*////////////////////////////////////////////\r\n    /      Restricted Functions: onlyAdmins      /\r\n    ////////////////////////////////////////////*/\r\n\r\n    function removeStrategy(Strategy _strategy, bool _shouldHarvest, uint256 _minReceived)\r\n        external\r\n        onlyAdmins\r\n        returns (uint256 received)\r\n    {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n\r\n        _setDebtRatio(_strategy, 0);\r\n\r\n        uint256 balanceBefore = asset.balanceOf(address(this));\r\n\r\n        if (_shouldHarvest) _harvest(_strategy);\r\n        else _report(_strategy, 0);\r\n\r\n        received = asset.balanceOf(address(this)) - balanceBefore;\r\n\r\n        if (received < _minReceived) revert BelowMinimum(received);\r\n\r\n        // reorganize queue, filling in the empty strategy\r\n        Strategy[] memory newQueue = new Strategy[](_queue.length - 1);\r\n\r\n        bool found;\r\n        uint8 length = uint8(newQueue.length);\r\n        for (uint8 i = 0; i < length; ++i) {\r\n            if (_queue[i] == _strategy) found = true;\r\n\r\n            if (found) newQueue[i] = _queue[i + 1];\r\n            else newQueue[i] = _queue[i];\r\n        }\r\n\r\n        delete strategies[_strategy];\r\n        _queue = newQueue;\r\n\r\n        emit StrategyRemoved(_strategy);\r\n    }\r\n\r\n    function swapQueuePositions(uint8 _i, uint8 _j) external onlyAdmins {\r\n        Strategy s1 = _queue[_i];\r\n        Strategy s2 = _queue[_j];\r\n\r\n        _queue[_i] = s2;\r\n        _queue[_j] = s1;\r\n\r\n        emit StrategyQueuePositionsSwapped(_i, _j, s2, s1);\r\n    }\r\n\r\n    function setDebtRatio(Strategy _strategy, uint256 _newDebtRatio) external onlyAdmins {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n        _setDebtRatio(_strategy, _newDebtRatio);\r\n    }\r\n\r\n    /// @dev locked profit duration can be 0\r\n    function setLockedProfitDuration(uint256 _newDuration) external onlyAdmins {\r\n        if (_newDuration > MAX_LOCKED_PROFIT_DURATION) revert AboveMaximum(_newDuration);\r\n        if (_newDuration == lockedProfitDuration) revert AlreadyValue();\r\n        lockedProfitDuration = _newDuration;\r\n        emit LockedProfitDurationChanged(_newDuration);\r\n    }\r\n\r\n    function setBlockDelay(uint8 _newDelay) external onlyAdmins {\r\n        _setBlockDelay(_newDelay);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////\r\n    /      Restricted Functions: onlyAuthorized     /\r\n    ///////////////////////////////////////////////*/\r\n\r\n    function suspendStrategy(Strategy _strategy) external onlyAuthorized {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n        _setDebtRatio(_strategy, 0);\r\n    }\r\n\r\n    function collectFromStrategy(Strategy _strategy, uint256 _assets, uint256 _minReceived)\r\n        external\r\n        onlyAuthorized\r\n        returns (uint256 received)\r\n    {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n        (received,) = _collect(_strategy, _assets, address(this));\r\n        if (received < _minReceived) revert BelowMinimum(received);\r\n    }\r\n\r\n    function pause() external onlyAuthorized {\r\n        if (paused) revert AlreadyValue();\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() external onlyAuthorized {\r\n        if (!paused) revert AlreadyValue();\r\n        paused = false;\r\n    }\r\n\r\n    function setMaxDeposit(uint256 _newMaxDeposit) external onlyAuthorized {\r\n        if (_maxDeposit == _newMaxDeposit) revert AlreadyValue();\r\n        _maxDeposit = _newMaxDeposit;\r\n        emit MaxDepositChanged(_newMaxDeposit);\r\n    }\r\n\r\n    /// @dev costs less gas than multiple harvests if active strategies > 1\r\n    function harvestAll() external onlyAuthorized updateLastReport {\r\n        uint8 length = uint8(_queue.length);\r\n        for (uint8 i = 0; i < length; ++i) {\r\n            _harvest(_queue[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev costs less gas than multiple reports if active strategies > 1\r\n    function reportAll() external onlyAuthorized updateLastReport {\r\n        uint8 length = uint8(_queue.length);\r\n        for (uint8 i = 0; i < length; ++i) {\r\n            _report(_queue[i], 0);\r\n        }\r\n    }\r\n\r\n    function harvest(Strategy _strategy) external onlyAuthorized updateLastReport {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n\r\n        _harvest(_strategy);\r\n    }\r\n\r\n    function report(Strategy _strategy) external onlyAuthorized updateLastReport {\r\n        if (!strategies[_strategy].added) revert NotStrategy();\r\n\r\n        _report(_strategy, 0);\r\n    }\r\n\r\n    function setFloatDebtRatio(uint256 _floatDebtRatio) external onlyAuthorized {\r\n        _setFloatDebtRatio(_floatDebtRatio);\r\n    }\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Internal Override: useBlockDelay     /\r\n    ///////////////////////////////////////////*/\r\n\r\n    /// @dev address cannot mint/burn/send/receive share tokens on same block, defense against flash loan exploits\r\n    function _mint(address _to, uint256 _amount) internal override useBlockDelay(_to) {\r\n        if (_to == address(0)) revert Zero();\r\n        ERC20._mint(_to, _amount);\r\n    }\r\n\r\n    /// @dev address cannot mint/burn/send/receive share tokens on same block, defense against flash loan exploits\r\n    function _burn(address _from, uint256 _amount) internal override useBlockDelay(_from) {\r\n        ERC20._burn(_from, _amount);\r\n    }\r\n\r\n    /// @dev address cannot mint/burn/send/receive share tokens on same block, defense against flash loan exploits\r\n    function transfer(address _to, uint256 _amount)\r\n        public\r\n        override\r\n        useBlockDelay(msg.sender)\r\n        useBlockDelay(_to)\r\n        returns (bool)\r\n    {\r\n        return ERC20.transfer(_to, _amount);\r\n    }\r\n\r\n    /// @dev address cannot mint/burn/send/receive share tokens on same block, defense against flash loan exploits\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        public\r\n        override\r\n        useBlockDelay(_from)\r\n        useBlockDelay(_to)\r\n        returns (bool)\r\n    {\r\n        return ERC20.transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /*//////////////////////////////\r\n    /      Internal Functions      /\r\n    //////////////////////////////*/\r\n\r\n    function _deposit(uint256 _assets, uint256 _shares, address _receiver) internal {\r\n        if (_assets > _maxDeposit) revert AboveMaxDeposit();\r\n\r\n        asset.safeTransferFrom(msg.sender, address(this), _assets);\r\n        _mint(_receiver, _shares);\r\n        emit Deposit(msg.sender, _receiver, _assets, _shares);\r\n    }\r\n\r\n    function _withdraw(uint256 _assets, uint256 _shares, address _owner, address _receiver)\r\n        internal\r\n        returns (uint256 received)\r\n    {\r\n        if (msg.sender != _owner) {\r\n            uint256 allowed = allowance[_owner][msg.sender];\r\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - _shares;\r\n        }\r\n\r\n        _burn(_owner, _shares);\r\n\r\n        emit Withdraw(msg.sender, _receiver, _owner, _assets, _shares);\r\n\r\n        // first, withdraw from balance\r\n        uint256 balance = asset.balanceOf(address(this));\r\n\r\n        if (balance > 0) {\r\n            uint256 amount = _assets > balance ? balance : _assets;\r\n            asset.safeTransfer(_receiver, amount);\r\n            _assets -= amount;\r\n            received += amount;\r\n        }\r\n\r\n        // next, withdraw from strategies\r\n        uint8 length = uint8(_queue.length);\r\n        for (uint8 i = 0; i < length; ++i) {\r\n            if (_assets == 0) break;\r\n            (uint256 receivedFromStrategy, uint256 slippage) = _collect(_queue[i], _assets, _receiver);\r\n            _assets -= receivedFromStrategy + slippage; // user pays for slippage, if any\r\n            received += receivedFromStrategy;\r\n        }\r\n    }\r\n\r\n    /// @dev do not touch debt outside of _lend(), _collect() and _report()\r\n    function _lend(Strategy _strategy, uint256 _assets) internal {\r\n        uint256 balance = asset.balanceOf(address(this));\r\n        uint256 amount = _assets > balance ? balance : _assets;\r\n\r\n        asset.safeTransfer(address(_strategy), amount);\r\n        _strategy.invest();\r\n\r\n        uint256 debtBefore = strategies[_strategy].debt;\r\n        uint256 debtAfter = _strategy.totalAssets();\r\n\r\n        uint256 diff = debtAfter - debtBefore;\r\n\r\n        uint256 slippage = amount > diff ? amount - diff : 0;\r\n\r\n        // ignore bonus if diff > amount, safeguard against imprecise `strategy.totalAsset()` calculations that open vault to being drained\r\n        uint256 debt = amount - slippage;\r\n\r\n        strategies[_strategy].debt += debt;\r\n        totalDebt += debt;\r\n\r\n        emit Lend(_strategy, amount, slippage);\r\n    }\r\n\r\n    function _collect(Strategy _strategy, uint256 _assets, address _receiver)\r\n        internal\r\n        returns (uint256 received, uint256 slippage)\r\n    {\r\n        uint256 bonus;\r\n        (received, slippage, bonus) = _strategy.withdraw(_assets);\r\n\r\n        uint256 total = received + slippage;\r\n\r\n        uint256 debt = strategies[_strategy].debt;\r\n\r\n        uint256 amount = debt > total ? received : total;\r\n\r\n        strategies[_strategy].debt -= amount;\r\n        totalDebt -= amount;\r\n\r\n        // do not pass bonuses on to users withdrawing, prevents exploits draining vault\r\n        if (_receiver == address(this)) emit Collect(_strategy, received, slippage, bonus);\r\n        else asset.safeTransfer(_receiver, received);\r\n    }\r\n\r\n    function _harvest(Strategy _strategy) internal {\r\n        _report(_strategy, _strategy.harvest());\r\n    }\r\n\r\n    /// @dev do not touch debt outside of _lend(), _collect() and _report()\r\n    function _report(Strategy _strategy, uint256 _harvested) internal {\r\n        uint256 assets = _strategy.totalAssets();\r\n        uint256 debt = strategies[_strategy].debt;\r\n\r\n        strategies[_strategy].debt = assets; // update debt\r\n\r\n        uint256 gain;\r\n        uint256 loss;\r\n\r\n        uint256 lockedProfitBefore = lockedProfit();\r\n\r\n        if (assets > debt) {\r\n            unchecked {\r\n                gain = assets - debt;\r\n            }\r\n            totalDebt += gain;\r\n\r\n            _lockedProfit = lockedProfitBefore + gain + _harvested;\r\n        } else if (debt > assets) {\r\n            unchecked {\r\n                loss = debt - assets;\r\n                totalDebt -= loss;\r\n\r\n                _lockedProfit = lockedProfitBefore + _harvested > loss ? lockedProfitBefore + _harvested - loss : 0;\r\n            }\r\n        }\r\n\r\n        uint256 possibleDebt =\r\n            totalDebtRatio == 0 ? 0 : totalAssets().mulDivDown(strategies[_strategy].debtRatio, totalDebtRatio);\r\n\r\n        if (possibleDebt > assets) _lend(_strategy, possibleDebt - assets);\r\n        else if (assets > possibleDebt) _collect(_strategy, assets - possibleDebt, address(this));\r\n\r\n        emit Report(_strategy, _harvested, gain, loss);\r\n    }\r\n\r\n    function _setDebtRatio(Strategy _strategy, uint256 _newDebtRatio) internal {\r\n        uint256 currentDebtRatio = strategies[_strategy].debtRatio;\r\n        if (_newDebtRatio == currentDebtRatio) revert AlreadyValue();\r\n\r\n        uint256 newTotalDebtRatio = totalDebtRatio + _newDebtRatio - currentDebtRatio;\r\n        if (newTotalDebtRatio > MAX_TOTAL_DEBT_RATIO) revert AboveMaximum(newTotalDebtRatio);\r\n\r\n        strategies[_strategy].debtRatio = _newDebtRatio;\r\n        totalDebtRatio = newTotalDebtRatio;\r\n\r\n        emit StrategyDebtRatioChanged(_strategy, _newDebtRatio);\r\n    }\r\n\r\n    function _setFloatDebtRatio(uint256 _floatDebtRatio) internal {\r\n        uint256 newTotalDebtRatio = totalDebtRatio + _floatDebtRatio - floatDebtRatio;\r\n        if (newTotalDebtRatio > MAX_TOTAL_DEBT_RATIO) revert AboveMaximum(newTotalDebtRatio);\r\n\r\n        floatDebtRatio = _floatDebtRatio;\r\n        totalDebtRatio = newTotalDebtRatio;\r\n\r\n        emit FloatDebtRatioChanged(_floatDebtRatio);\r\n    }\r\n\r\n    /*/////////////////////\r\n    /      Modifiers      /\r\n    /////////////////////*/\r\n\r\n    modifier updateLastReport() {\r\n        _;\r\n        lastReport = block.timestamp;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        if (paused) revert Paused();\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev\r\n * Strategies have to implement the following virtual functions:\r\n *\r\n * totalAssets()\r\n * _withdraw(uint256, address)\r\n * _harvest()\r\n * _invest()\r\n */\r\nabstract contract Strategy is Ownership {\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    Vault public immutable vault;\r\n    ERC20 public immutable asset;\r\n\r\n    /// @notice address which performance fees are sent to\r\n    address public treasury;\r\n    /// @notice performance fee sent to treasury / FEE_BASIS of 10_000\r\n    uint16 public fee = 1_000;\r\n    uint16 internal constant MAX_FEE = 1_000;\r\n    uint16 internal constant FEE_BASIS = 10_000;\r\n\r\n    /// @notice used to calculate slippage / SLIP_BASIS of 10_000\r\n    /// @dev default to 99% (or 1%)\r\n    uint16 public slip = 9_900;\r\n    uint16 internal constant SLIP_BASIS = 10_000;\r\n\r\n    /*//////////////////\r\n    /      Events      /\r\n    //////////////////*/\r\n\r\n    event FeeChanged(uint16 newFee);\r\n    event SlipChanged(uint16 newSlip);\r\n    event TreasuryChanged(address indexed newTreasury);\r\n\r\n    /*//////////////////\r\n    /      Errors      /\r\n    //////////////////*/\r\n\r\n    error Zero();\r\n    error NotVault();\r\n    error InvalidValue();\r\n    error AlreadyValue();\r\n\r\n    constructor(Vault _vault, address _treasury, address _nominatedOwner, address _admin, address[] memory _authorized)\r\n        Ownership(_nominatedOwner, _admin, _authorized)\r\n    {\r\n        vault = _vault;\r\n        asset = vault.asset();\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /*//////////////////////////\r\n    /      Public Virtual      /\r\n    //////////////////////////*/\r\n\r\n    /// @notice amount of 'asset' currently managed by strategy\r\n    function totalAssets() public view virtual returns (uint256);\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Restricted Functions: onlyVault      /\r\n    ///////////////////////////////////////////*/\r\n\r\n    function withdraw(uint256 _assets) external onlyVault returns (uint256 received, uint256 slippage, uint256 bonus) {\r\n        uint256 total = totalAssets();\r\n        if (total == 0) revert Zero();\r\n\r\n        uint256 assets = _assets > total ? total : _assets;\r\n\r\n        received = _withdraw(assets);\r\n\r\n        unchecked {\r\n            if (assets > received) {\r\n                slippage = assets - received;\r\n            } else if (received > assets) {\r\n                bonus = received - assets;\r\n                // received cannot > assets for vault calcuations\r\n                received = assets;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////\r\n    /      Restricted Functions: onlyAdminOrVault      /\r\n    //////////////////////////////////////////////////*/\r\n\r\n    function harvest() external onlyAdminOrVault returns (uint256 received) {\r\n        _harvest();\r\n\r\n        received = asset.balanceOf(address(this));\r\n\r\n        if (fee > 0) {\r\n            uint256 feeAmount = _calculateFee(received);\r\n            received -= feeAmount;\r\n            asset.safeTransfer(treasury, feeAmount);\r\n        }\r\n\r\n        asset.safeTransfer(address(vault), received);\r\n    }\r\n\r\n    function invest() external onlyAdminOrVault {\r\n        _invest();\r\n    }\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Restricted Functions: onlyOwner      /\r\n    ///////////////////////////////////////////*/\r\n\r\n    function setFee(uint16 _fee) external onlyOwner {\r\n        if (_fee > MAX_FEE) revert InvalidValue();\r\n        if (_fee == fee) revert AlreadyValue();\r\n        fee = _fee;\r\n        emit FeeChanged(_fee);\r\n    }\r\n\r\n    function setTreasury(address _treasury) external onlyOwner {\r\n        if (_treasury == treasury) revert AlreadyValue();\r\n        treasury = _treasury;\r\n        emit TreasuryChanged(_treasury);\r\n    }\r\n\r\n    /*////////////////////////////////////////////\r\n    /      Restricted Functions: onlyAdmins      /\r\n    ////////////////////////////////////////////*/\r\n\r\n    function setSlip(uint16 _slip) external onlyAdmins {\r\n        if (_slip > SLIP_BASIS) revert InvalidValue();\r\n        if (_slip == slip) revert AlreadyValue();\r\n        slip = _slip;\r\n        emit SlipChanged(_slip);\r\n    }\r\n\r\n    /*////////////////////////////\r\n    /      Internal Virtual      /\r\n    ////////////////////////////*/\r\n\r\n    function _withdraw(uint256 _assets) internal virtual returns (uint256 received);\r\n\r\n    /// @dev return harvested assets\r\n    function _harvest() internal virtual;\r\n\r\n    function _invest() internal virtual;\r\n\r\n    /*//////////////////////////////\r\n    /      Internal Functions      /\r\n    //////////////////////////////*/\r\n\r\n    function _calculateSlippage(uint256 _amount) internal view returns (uint256) {\r\n        return _amount.mulDivDown(slip, SLIP_BASIS);\r\n    }\r\n\r\n    function _calculateFee(uint256 _amount) internal view returns (uint256) {\r\n        return _amount.mulDivDown(fee, FEE_BASIS);\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        if (msg.sender != address(vault)) revert NotVault();\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////\r\n    /      Internal Functions      /\r\n    //////////////////////////////*/\r\n\r\n    modifier onlyAdminOrVault() {\r\n        if (msg.sender != owner && msg.sender != admin && msg.sender != address(vault)) revert Unauthorized();\r\n        _;\r\n    }\r\n}\r\n\r\ncontract WethStrategyStargate is Strategy {\r\n    using SafeTransferLib for ERC20;\r\n    using SafeTransferLib for LPTokenERC20;\r\n    using SafeTransferLib for WETH;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    IStargateRouter internal constant router = IStargateRouter(0x8731d54E9D02c286767d56ac03e8037C07e01e98);\r\n    ILPStaking internal constant staking = ILPStaking(0xB0D502E938ed5f4df2E681fE6E419ff29631d62b);\r\n    ERC20 internal constant STG = ERC20(0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6);\r\n\r\n    /// @dev Stargate's version of WETH that automatically unwraps on transfer. Annoyingly, not canonical WETH\r\n    WETH internal constant SGETH = WETH(payable(0x72E2F4830b9E45d52F80aC08CB2bEC0FeF72eD9c));\r\n    /// @dev canonical WETH\r\n    WETH internal constant WETH9 = WETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n\r\n    /// @dev pid of asset in their router\r\n    uint16 public constant routerPoolId = 13;\r\n    /// @dev pid of asset in their LP staking contract\r\n    uint256 public constant stakingPoolId = 2;\r\n    LPTokenERC20 public constant lpToken = LPTokenERC20(0x101816545F6bd2b1076434B54383a1E633390A2E);\r\n\r\n    /// @notice contract used to swap STG rewards to asset\r\n    Swap public swap;\r\n\r\n    /*///////////////\r\n    /     Errors    /\r\n    ///////////////*/\r\n\r\n    error NoRewards();\r\n    error NothingToInvest();\r\n    error BelowMinimum(uint256);\r\n    error InvalidAsset();\r\n\r\n    constructor(\r\n        Vault _vault,\r\n        address _treasury,\r\n        address _nominatedOwner,\r\n        address _admin,\r\n        address[] memory _authorized,\r\n        Swap _swap\r\n    ) Strategy(_vault, _treasury, _nominatedOwner, _admin, _authorized) {\r\n        swap = _swap;\r\n\r\n        if (address(_vault.asset()) != address(WETH9)) revert InvalidAsset();\r\n\r\n        _approve();\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.sender == address(WETH9)) return; // do nothing when unwrapping WETH\r\n\r\n        // SGETH automatically unwraps to ETH upon transfer in `redeemLocal` and `instantRedeemLocal`. We wrap and send\r\n        // WETH from other sources (namely router) to vault as ETH.\r\n        WETH9.deposit{value: msg.value}();\r\n        asset.safeTransfer(address(vault), msg.value);\r\n    }\r\n\r\n    /*///////////////////////\r\n    /      Public View      /\r\n    ///////////////////////*/\r\n\r\n    function totalAssets() public view override returns (uint256 assets) {\r\n        (uint256 stakedBalance,) = staking.userInfo(stakingPoolId, address(this));\r\n        return lpToken.amountLPtoLD(stakedBalance);\r\n    }\r\n\r\n    /*///////////////////////////////////////////\r\n    /      Restricted Functions: onlyOwner      /\r\n    ///////////////////////////////////////////*/\r\n\r\n    function changeSwap(Swap _swap) external onlyOwner {\r\n        _unapproveSwap();\r\n        swap = _swap;\r\n        _approveSwap();\r\n    }\r\n\r\n    /*////////////////////////////////////////////////\r\n    /      Restricted Functions: onlyAuthorized      /\r\n    ////////////////////////////////////////////////*/\r\n\r\n    function reapprove() external onlyAuthorized {\r\n        _unapprove();\r\n        _approve();\r\n    }\r\n\r\n    /**\r\n     * @notice Safeguard to manually withdraw if insufficient delta in Stargate local pool.\r\n     * \t@dev Use router.quoteLayerZeroFee to estimate 'msg.value' (excess will be refunded to `msg.sender`).\r\n     * \t@param _dstChainId STG chainId, see https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet, ideally we want to use the chain with cheapest gas\r\n     * \t@param _assets amount of LP to redeem, use type(uint256).max to withdraw everything\r\n     * \t@param _lzTxObj usually can just be (0, 0, \"0x\")\r\n     */\r\n    function manualWithdraw(uint16 _dstChainId, uint256 _assets, IStargateRouter.lzTxObj calldata _lzTxObj)\r\n        external\r\n        payable\r\n        onlyAuthorized\r\n    {\r\n        uint256 assets = totalAssets();\r\n\r\n        uint256 amount = assets > _assets ? _assets : assets;\r\n        uint256 lpAmount = _convertAssetToLP(amount);\r\n\r\n        staking.withdraw(stakingPoolId, lpAmount);\r\n\r\n        router.redeemLocal{value: msg.value}(\r\n            _dstChainId,\r\n            routerPoolId,\r\n            routerPoolId,\r\n            payable(msg.sender),\r\n            lpAmount,\r\n            abi.encodePacked(address(this)),\r\n            _lzTxObj\r\n        );\r\n    }\r\n\r\n    /*/////////////////////////////\r\n    /      Internal Override      /\r\n    /////////////////////////////*/\r\n\r\n    function _withdraw(uint256 _assets) internal override returns (uint256 received) {\r\n        uint256 lpAmount = _convertAssetToLP(_assets);\r\n\r\n        // lpAmount can round down to 0 which will cause the withdraw to fail\r\n        if (lpAmount == 0) return received;\r\n\r\n        // 1. withdraw from staking contract\r\n        staking.withdraw(stakingPoolId, lpAmount);\r\n\r\n        // withdraw from stargate router\r\n        received = router.instantRedeemLocal(routerPoolId, lpAmount, address(this));\r\n        if (received < _calculateSlippage(_assets)) revert BelowMinimum(received);\r\n    }\r\n\r\n    function _harvest() internal override {\r\n        // empty deposit/withdraw claims rewards withdraw as with all Goose clones\r\n        staking.withdraw(stakingPoolId, 0);\r\n\r\n        uint256 rewardBalance = STG.balanceOf(address(this));\r\n        if (rewardBalance == 0) revert NoRewards(); // nothing to harvest\r\n\r\n        swap.swapTokens(address(STG), address(asset), rewardBalance, 1);\r\n    }\r\n\r\n    function _invest() internal override {\r\n        uint256 assetBalance = asset.balanceOf(address(this));\r\n        if (assetBalance == 0) revert NothingToInvest();\r\n\r\n        WETH9.withdraw(assetBalance);\r\n        SGETH.deposit{value: assetBalance}();\r\n\r\n        router.addLiquidity(routerPoolId, assetBalance, address(this));\r\n\r\n        uint256 balance = lpToken.balanceOf(address(this));\r\n\r\n        if (balance < _calculateSlippage(assetBalance)) revert BelowMinimum(balance);\r\n\r\n        staking.deposit(stakingPoolId, balance);\r\n    }\r\n\r\n    /*//////////////////////////////\r\n    /      Internal Functions      /\r\n    //////////////////////////////*/\r\n\r\n    function _approve() internal {\r\n        // approve deposit SGETH into router\r\n        SGETH.safeApprove(address(router), type(uint256).max);\r\n        // approve deposit lpToken into staking contract\r\n        lpToken.safeApprove(address(staking), type(uint256).max);\r\n\r\n        _approveSwap();\r\n    }\r\n\r\n    function _unapprove() internal {\r\n        SGETH.safeApprove(address(router), 0);\r\n        lpToken.safeApprove(address(staking), 0);\r\n\r\n        _unapproveSwap();\r\n    }\r\n\r\n    // approve swap rewards to asset\r\n    function _unapproveSwap() internal {\r\n        STG.safeApprove(address(swap), 0);\r\n    }\r\n\r\n    // approve swap rewards to asset\r\n    function _approveSwap() internal {\r\n        STG.safeApprove(address(swap), type(uint256).max);\r\n    }\r\n\r\n    function _convertAssetToLP(uint256 _amount) internal view returns (uint256) {\r\n        return _amount.mulDivDown(lpToken.totalSupply(), lpToken.totalLiquidity());\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nominatedOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_authorized\",\"type\":\"address[]\"},{\"internalType\":\"contract Swap\",\"name\":\"_swap\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRewards\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToInvest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Zero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAuth\",\"type\":\"address\"}],\"name\":\"AuthAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAuth\",\"type\":\"address\"}],\"name\":\"AuthRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newFee\",\"type\":\"uint16\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newSlip\",\"type\":\"uint16\"}],\"name\":\"SlipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorized\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Swap\",\"name\":\"_swap\",\"type\":\"address\"}],\"name\":\"changeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract LPTokenERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dstGasForCall\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dstNativeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"dstNativeAddr\",\"type\":\"bytes\"}],\"internalType\":\"struct IStargateRouter.lzTxObj\",\"name\":\"_lzTxObj\",\"type\":\"tuple\"}],\"name\":\"manualWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"nominateOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reapprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorized\",\"type\":\"address\"}],\"name\":\"removeAuthorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerPoolId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_slip\",\"type\":\"uint16\"}],\"name\":\"setSlip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slip\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"contract Swap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WethStrategyStargate", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000006abe5f87e3f4dc87301064f63ca5b244d119980d0000000000000000000000001c064ea662365c09c8e87242791dacbb90002605000000000000000000000000e2ceda90aa1e43647ef306810a903b32c9a3aa94000000000000000000000000f4e2007bb865b78bc0eac0cc242e974efd49c06d00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000df46950003eed5b40bd94fdf0efc4c148858eeb00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000a1f3a2c20a7e8e4470ffa52c01646e1ff4c759a0000000000000000000000001c595009b331fe85fd658aa0b6b7be95b6921021000000000000000000000000beca7b566fad28ccbe6dce59d42d37768ab3cd8b", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bc727841b2b053a7d6b8a974d8ae96afa0d2e60493a50c2cd966fd54d564cf91"}