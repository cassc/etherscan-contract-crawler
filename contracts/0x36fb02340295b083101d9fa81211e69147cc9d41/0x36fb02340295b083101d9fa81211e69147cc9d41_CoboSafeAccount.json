{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CoboSafeAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"BaseAccount.sol\\\";\\n\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface IGnosisSafe {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function enableModule(address module) external;\\n\\n    function isModuleEnabled(address module) external view returns (bool);\\n}\\n\\n/// @title CoboSafeAccount - A GnosisSafe module that implements customized access control\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\ncontract CoboSafeAccount is BaseAccount {\\n    using TxFlags for uint256;\\n\\n    bytes32 public constant NAME = \\\"CoboSafeAccount\\\";\\n    uint256 public constant VERSION = 1;\\n\\n    constructor(address _owner) BaseAccount(_owner) {}\\n\\n    /// @notice The safe of the CoboSafeAccount.\\n    function safe() public view returns (address) {\\n        return owner;\\n    }\\n\\n    /// @dev Execute the transaction from the safe.\\n    function _executeTransaction(\\n        TransactionData memory transaction\\n    ) internal override returns (TransactionResult memory result) {\\n        // execute the transaction from Gnosis Safe, note this call will bypass\\n        // safe owners confirmation.\\n        (result.success, result.data) = IGnosisSafe(payable(safe())).execTransactionFromModuleReturnData(\\n            transaction.to,\\n            transaction.value,\\n            transaction.data,\\n            transaction.flag.isDelegateCall() ? Enum.Operation.DelegateCall : Enum.Operation.Call\\n        );\\n    }\\n\\n    /// @dev Account address is the safe address.\\n    function _getAccountAddress() internal view override returns (address account) {\\n        account = safe();\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"EnumerableSet.sol\\\";\\n\\nimport \\\"Types.sol\\\";\\nimport \\\"BaseOwnable.sol\\\";\\nimport \\\"IAuthorizer.sol\\\";\\nimport \\\"IRoleManager.sol\\\";\\nimport \\\"IAccount.sol\\\";\\n\\n/// @title BaseAccount - A basic smart contract wallet with access control supported.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Extend this and implement `_executeTransaction()` and `_getFromAddress()`.\\nabstract contract BaseAccount is IAccount, BaseOwnable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using TxFlags for uint256;\\n    using AuthFlags for uint256;\\n\\n    address public roleManager;\\n    address public authorizer;\\n\\n    // Simple and basic delegate check.\\n    EnumerableSet.AddressSet delegates;\\n\\n    event RoleManagerSet(address indexed roleManager);\\n    event AuthorizerSet(address indexed authorizer);\\n    event DelegateAdded(address indexed delegate);\\n    event DelegateRemoved(address indexed delegate);\\n    event TransactionExecuted(\\n        address indexed to,\\n        bytes4 indexed selector,\\n        uint256 indexed value,\\n        TransactionData transaction\\n    );\\n\\n    /// @dev RoleManager need BaseAccount to create thus we can not init it in constructor\\n    /// @param _owner Who owns the wallet.\\n    constructor(address _owner) BaseOwnable(_owner) {}\\n\\n    /// @dev Only used in proxy mode. Can be called only once.\\n    function initialize(address _owner, address _roleManager, address _authorizer) public {\\n        initialize(_owner);\\n        _setRoleManager(_roleManager);\\n        _setAuthorizer(_authorizer);\\n    }\\n\\n    /// Modifiers\\n\\n    /// @dev Only added delegates are allowed to call `execTransaction`. This provides a kind\\n    ///      of catch-all rule and simple but strong protection from malicious/compromised/buggy\\n    ///      authorizers which permits any operations.\\n    modifier onlyDelegate() {\\n        require(hasDelegate(msg.sender), Errors.INVALID_DELEGATE);\\n        _;\\n    }\\n\\n    // Public/External functions.\\n    function setRoleManager(address _roleManager) external onlyOwner {\\n        _setRoleManager(_roleManager);\\n    }\\n\\n    function setAuthorizer(address _authorizer) external onlyOwner {\\n        _setAuthorizer(_authorizer);\\n    }\\n\\n    function addDelegate(address _delegate) external onlyOwner {\\n        _addDelegate(_delegate);\\n    }\\n\\n    function addDelegates(address[] calldata _delegates) external onlyOwner {\\n        for (uint256 i = 0; i < _delegates.length; i++) {\\n            _addDelegate(_delegates[i]);\\n        }\\n    }\\n\\n    function removeDelegate(address _delegate) external onlyOwner {\\n        _removeDelegate(_delegate);\\n    }\\n\\n    function removeDelegates(address[] calldata _delegates) external onlyOwner {\\n        for (uint256 i = 0; i < _delegates.length; i++) {\\n            _removeDelegate(_delegates[i]);\\n        }\\n    }\\n\\n    /// @notice Called by authenticated delegates to execute transaction on behalf of the wallet account.\\n    /// @param callData A structure contains `to`, `value`, `data`.\\n    function execTransaction(\\n        CallData calldata callData\\n    ) external onlyDelegate returns (TransactionResult memory result) {\\n        TransactionData memory transaction;\\n        transaction.from = _getAccountAddress();\\n        transaction.delegate = msg.sender;\\n        transaction.flag = callData.flag;\\n        transaction.to = callData.to;\\n        transaction.value = callData.value;\\n        transaction.data = callData.data;\\n        transaction.hint = callData.hint;\\n        transaction.extra = callData.extra;\\n\\n        result = _executeTransactionWithCheck(transaction);\\n        emit TransactionExecuted(callData.to, bytes4(callData.data), callData.value, transaction);\\n    }\\n\\n    /// @notice A Multicall method.\\n    /// @param callDataList `CallData` array to execute in sequence.\\n    function execTransactions(\\n        CallData[] calldata callDataList\\n    ) external onlyDelegate returns (TransactionResult[] memory resultList) {\\n        TransactionData memory transaction;\\n        transaction.from = _getAccountAddress();\\n        transaction.delegate = msg.sender;\\n\\n        resultList = new TransactionResult[](callDataList.length);\\n\\n        for (uint256 i = 0; i < callDataList.length; i++) {\\n            CallData calldata callData = callDataList[i];\\n            transaction.to = callData.to;\\n            transaction.value = callData.value;\\n            transaction.data = callData.data;\\n            transaction.flag = callData.flag;\\n            transaction.hint = callData.hint;\\n            transaction.extra = callData.extra;\\n\\n            resultList[i] = _executeTransactionWithCheck(transaction);\\n\\n            emit TransactionExecuted(callData.to, bytes4(callData.data), callData.value, transaction);\\n        }\\n    }\\n\\n    /// External view functions.\\n\\n    function hasDelegate(address _delegate) public view returns (bool) {\\n        return delegates.contains(_delegate);\\n    }\\n\\n    function getAllDelegates() external view returns (address[] memory) {\\n        return delegates.values();\\n    }\\n\\n    /// @notice The real address of your smart contract wallet address where\\n    ///         stores your assets and sends transactions from.\\n    function getAccountAddress() external view returns (address account) {\\n        account = _getAccountAddress();\\n    }\\n\\n    /// Internal functions.\\n\\n    function _addDelegate(address _delegate) internal {\\n        if (delegates.add(_delegate)) {\\n            emit DelegateAdded(_delegate);\\n        }\\n    }\\n\\n    function _removeDelegate(address _delegate) internal {\\n        if (delegates.remove(_delegate)) {\\n            emit DelegateRemoved(_delegate);\\n        }\\n    }\\n\\n    function _setRoleManager(address _roleManager) internal {\\n        roleManager = _roleManager;\\n        emit RoleManagerSet(_roleManager);\\n    }\\n\\n    function _setAuthorizer(address _authorizer) internal {\\n        authorizer = _authorizer;\\n        emit AuthorizerSet(_authorizer);\\n    }\\n\\n    /// @dev Override this if we prefer not to revert the entire transaction in\\n    //       out wallet contract implementation.\\n    function _preExecCheck(\\n        TransactionData memory transaction\\n    ) internal virtual returns (AuthorizerReturnData memory authData) {\\n        authData = IAuthorizer(authorizer).preExecCheck(transaction);\\n        require(authData.result == AuthResult.SUCCESS, authData.message);\\n    }\\n\\n    function _revertIfTxFails(TransactionResult memory callResult) internal pure {\\n        bool success = callResult.success;\\n        bytes memory data = callResult.data;\\n        if (!success) {\\n            assembly {\\n                revert(add(data, 32), data)\\n            }\\n        }\\n    }\\n\\n    function _postExecCheck(\\n        TransactionData memory transaction,\\n        TransactionResult memory callResult,\\n        AuthorizerReturnData memory predata\\n    ) internal virtual returns (AuthorizerReturnData memory authData) {\\n        _revertIfTxFails(callResult);\\n        authData = IAuthorizer(authorizer).postExecCheck(transaction, callResult, predata);\\n        require(authData.result == AuthResult.SUCCESS, authData.message);\\n    }\\n\\n    function _preExecProcess(TransactionData memory transaction) internal virtual {\\n        IAuthorizer(authorizer).preExecProcess(transaction);\\n    }\\n\\n    function _postExecProcess(\\n        TransactionData memory transaction,\\n        TransactionResult memory callResult\\n    ) internal virtual {\\n        IAuthorizer(authorizer).postExecProcess(transaction, callResult);\\n    }\\n\\n    function _executeTransactionWithCheck(\\n        TransactionData memory transaction\\n    ) internal virtual returns (TransactionResult memory result) {\\n        require(authorizer != address(0), Errors.AUTHORIZER_NOT_SET);\\n        uint256 flag = IAuthorizer(authorizer).flag();\\n        bool doCollectHint = transaction.hint.length == 0;\\n\\n        // Ensures either _preExecCheck or _postExecCheck (or both) will run.\\n        require(flag.isValid(), Errors.INVALID_AUTHORIZER_FLAG);\\n\\n        // 1. Do pre check, revert the entire txn if failed.\\n        AuthorizerReturnData memory preData;\\n        if (doCollectHint || flag.hasPreCheck()) {\\n            // Always run _preExecCheck When collecting hint.\\n            // If not collecting hint, only run if the sub authorizer requires.\\n            preData = _preExecCheck(transaction);\\n        }\\n\\n        // 2. Do pre process.\\n        if (flag.hasPreProcess()) _preExecProcess(transaction);\\n\\n        // 3. Execute the transaction.\\n        result = _executeTransaction(transaction);\\n\\n        // 4. Do post check, revert the entire txn if failed.\\n        AuthorizerReturnData memory postData;\\n        if (doCollectHint || flag.hasPostCheck()) {\\n            postData = _postExecCheck(transaction, result, preData);\\n        }\\n\\n        // 5. Do post process.\\n        if (flag.hasPostProcess()) _postExecProcess(transaction, result);\\n\\n        // 6. Collect hint if when (1) no hint provided and (2) the authorizer supports hint mode.\\n        if (doCollectHint && flag.supportHint()) {\\n            result.hint = IAuthorizerSupportingHint(authorizer).collectHint(preData, postData);\\n        }\\n    }\\n\\n    /// @dev Instance should implement at least two `virtual` function below.\\n\\n    /// @param transaction Transaction to execute.\\n    /// @return result `TransactionResult` which contains call status and return/revert data.\\n    function _executeTransaction(\\n        TransactionData memory transaction\\n    ) internal virtual returns (TransactionResult memory result);\\n\\n    /// @dev The address of wallet which sends the transaction a.k.a `msg.sender`\\n    function _getAccountAddress() internal view virtual returns (address account);\\n\\n    // To receive ETH as a wallet.\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nenum AuthResult {\\n    FAILED,\\n    SUCCESS\\n}\\n\\nstruct CallData {\\n    uint256 flag; // 0x1 delegate call, 0x0 call.\\n    address to;\\n    uint256 value;\\n    bytes data; // calldata\\n    bytes hint;\\n    bytes extra; // for future support: signatures etc.\\n}\\n\\nstruct TransactionData {\\n    address from; // Sender who performs the transaction a.k.a wallet address.\\n    address delegate; // Delegate who calls executeTransactions().\\n    // Same as CallData\\n    uint256 flag; // 0x1 delegate call, 0x0 call.\\n    address to;\\n    uint256 value;\\n    bytes data; // calldata\\n    bytes hint;\\n    bytes extra;\\n}\\n\\nstruct AuthorizerReturnData {\\n    AuthResult result;\\n    string message;\\n    bytes data; // Authorizer return data. usually used for hint purpose.\\n}\\n\\nstruct TransactionResult {\\n    bool success; // Call status.\\n    bytes data; // Return/Revert data.\\n    bytes hint;\\n}\\n\\nlibrary TxFlags {\\n    uint256 internal constant DELEGATE_CALL_MASK = 0x1; // 1 for delegatecall, 0 for call\\n\\n    function isDelegateCall(uint256 flag) internal pure returns (bool) {\\n        return flag & DELEGATE_CALL_MASK == DELEGATE_CALL_MASK;\\n    }\\n}\\n\\nlibrary VarName {\\n    bytes5 internal constant TEMP = \\\"temp.\\\";\\n\\n    function isTemp(bytes32 name) internal pure returns (bool) {\\n        return bytes5(name) == TEMP;\\n    }\\n}\\n\\nlibrary AuthType {\\n    bytes32 internal constant FUNC = \\\"FunctionType\\\";\\n    bytes32 internal constant TRANSFER = \\\"TransferType\\\";\\n    bytes32 internal constant DEX = \\\"DexType\\\";\\n    bytes32 internal constant LENDING = \\\"LendingType\\\";\\n    bytes32 internal constant COMMON = \\\"CommonType\\\";\\n    bytes32 internal constant SET = \\\"SetType\\\";\\n    bytes32 internal constant VM = \\\"VM\\\";\\n}\\n\\nlibrary AuthFlags {\\n    uint256 internal constant HAS_PRE_CHECK_MASK = 0x1;\\n    uint256 internal constant HAS_POST_CHECK_MASK = 0x2;\\n    uint256 internal constant HAS_PRE_PROC_MASK = 0x4;\\n    uint256 internal constant HAS_POST_PROC_MASK = 0x8;\\n\\n    uint256 internal constant SUPPORT_HINT_MASK = 0x40;\\n\\n    uint256 internal constant FULL_MODE =\\n        HAS_PRE_CHECK_MASK | HAS_POST_CHECK_MASK | HAS_PRE_PROC_MASK | HAS_POST_PROC_MASK;\\n\\n    function isValid(uint256 flag) internal pure returns (bool) {\\n        // At least one check handler is activated.\\n        return hasPreCheck(flag) || hasPostCheck(flag);\\n    }\\n\\n    function hasPreCheck(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_PRE_CHECK_MASK == HAS_PRE_CHECK_MASK;\\n    }\\n\\n    function hasPostCheck(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_POST_CHECK_MASK == HAS_POST_CHECK_MASK;\\n    }\\n\\n    function hasPreProcess(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_PRE_PROC_MASK == HAS_PRE_PROC_MASK;\\n    }\\n\\n    function hasPostProcess(uint256 flag) internal pure returns (bool) {\\n        return flag & HAS_POST_PROC_MASK == HAS_POST_PROC_MASK;\\n    }\\n\\n    function supportHint(uint256 flag) internal pure returns (bool) {\\n        return flag & SUPPORT_HINT_MASK == SUPPORT_HINT_MASK;\\n    }\\n}\\n\\n// For Rule VM.\\n\\n// For each VariantType, an extractor should be implement.\\nenum VariantType {\\n    INVALID, // Mark for delete.\\n    EXTRACT_CALLDATA, // extract calldata by path bytes.\\n    NAME, // name for user-defined variant.\\n    RAW, // encoded solidity values.\\n    VIEW, // staticcall view non-side-effect function and get return value.\\n    CALL, // call state changing function and get returned value.\\n    RULE, // rule expression.\\n    ANY\\n}\\n\\n// How the data should be decoded.\\nenum SolidityType {\\n    _invalid, // Mark for delete.\\n    _any,\\n    _bytes,\\n    _bool,\\n    ///// START 1\\n    ///// Generated by gen_rulelib.py (start)\\n    _address,\\n    _uint256,\\n    _int256,\\n    ///// Generated by gen_rulelib.py (end)\\n    ///// END 1\\n    _end\\n}\\n\\n// A common operand in rule.\\nstruct Variant {\\n    VariantType varType;\\n    SolidityType solType;\\n    bytes data;\\n}\\n\\n// OpCode for rule expression which returns v0.\\nenum OP {\\n    INVALID,\\n    // One opnd.\\n    VAR, // v1\\n    NOT, // !v1\\n    // Two opnds.\\n    // checkBySolType() which returns boolean.\\n    EQ, // v1 == v2\\n    NE, // v1 != v2\\n    GT, // v1 > v2\\n    GE, // v1 >= v2\\n    LT, // v1 < v2\\n    LE, // v1 <= v2\\n    IN, // v1 in [...]\\n    NOTIN, // v1 not in [...]\\n    // computeBySolType() which returns bytes (with same solType)\\n    AND, // v1 & v2\\n    OR, // v1 | v2\\n    ADD, // v1 + v2\\n    SUB, // v1 - v2\\n    MUL, // v1 * v2\\n    DIV, // v1 / v2\\n    MOD, // v1 % v2\\n    // Three opnds.\\n    IF, // v1? v2: v3\\n    // Side-effect ones.\\n    ASSIGN, // v1 := v2\\n    VM, // rule list bytes.\\n    NOP // as end.\\n}\\n\\nstruct Rule {\\n    OP op;\\n    Variant[] vars;\\n}\\n\"\r\n    },\r\n    \"BaseOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"BaseVersion.sol\\\";\\n\\n/// @title BaseOwnable - Provides simple ownership access control.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Can be used in both proxy and non-proxy mode.\\nabstract contract BaseOwnable is BaseVersion {\\n    address public owner;\\n    address public pendingOwner;\\n    bool private initialized = false;\\n\\n    event PendingOwnerSet(address indexed to);\\n    event NewOwnerSet(address indexed owner);\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, Errors.CALLER_IS_NOT_OWNER);\\n        _;\\n    }\\n\\n    /// @dev `owner` is set by argument, thus the owner can any address.\\n    ///      When used in non-proxy mode, `initialize` can not be called\\n    ///      after deployment.\\n    constructor(address _owner) {\\n        initialize(_owner);\\n    }\\n\\n    /// @dev When used in proxy mode, `initialize` can be called by anyone\\n    ///      to claim the ownership.\\n    ///      This function can be called only once.\\n    function initialize(address _owner) public {\\n        require(!initialized, Errors.ALREADY_INITIALIZED);\\n        _setOwner(_owner);\\n        initialized = true;\\n    }\\n\\n    /// @notice User should ensure the corrent owner address set, or the\\n    ///         ownership may be transferred to blackhole. It is recommended to\\n    ///         take a safer way with setPendingOwner() + acceptOwner().\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"New Owner is zero\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @notice The original owner calls `setPendingOwner(newOwner)` and the new\\n    ///         owner calls `acceptOwner()` to take the ownership.\\n    function setPendingOwner(address to) external onlyOwner {\\n        pendingOwner = to;\\n        emit PendingOwnerSet(pendingOwner);\\n    }\\n\\n    function acceptOwner() external {\\n        require(msg.sender == pendingOwner);\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /// @notice Make the contract immutable.\\n    function renounceOwnership() external onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    // Internal functions\\n\\n    /// @dev Clear pendingOwner to prevent from reclaiming the ownership.\\n    function _setOwner(address _owner) internal {\\n        owner = _owner;\\n        pendingOwner = address(0);\\n        emit NewOwnerSet(owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @dev Common errors. This helps reducing the contract size.\\nlibrary Errors {\\n    // \\\"E1\\\";\\n\\n    // Call/Static-call failed.\\n    string constant CALL_FAILED = \\\"E2\\\";\\n\\n    // Argument's type not supported in View Variant.\\n    string constant INVALID_VIEW_ARG_SOL_TYPE = \\\"E3\\\";\\n\\n    // Invalid length for variant raw data.\\n    string constant INVALID_VARIANT_RAW_DATA = \\\"E4\\\";\\n\\n    // \\\"E5\\\";\\n\\n    // Invalid variant type.\\n    string constant INVALID_VAR_TYPE = \\\"E6\\\";\\n\\n    // Rule not exists\\n    string constant RULE_NOT_EXISTS = \\\"E7\\\";\\n\\n    // Variant name not found.\\n    string constant VAR_NAME_NOT_FOUND = \\\"E8\\\";\\n\\n    // Rule: v1/v2 solType mismatch\\n    string constant SOL_TYPE_MISMATCH = \\\"E9\\\";\\n\\n    // \\\"E10\\\";\\n\\n    // Invalid rule OP.\\n    string constant INVALID_RULE_OP = \\\"E11\\\";\\n\\n    //  \\\"E12\\\";\\n\\n    // \\\"E13\\\";\\n\\n    //  \\\"E14\\\";\\n\\n    // \\\"E15\\\";\\n\\n    // \\\"E16\\\";\\n\\n    // \\\"E17\\\";\\n\\n    // \\\"E18\\\";\\n\\n    // \\\"E19\\\";\\n\\n    // \\\"E20\\\";\\n\\n    // checkCmpOp: OP not support\\n    string constant CMP_OP_NOT_SUPPORT = \\\"E21\\\";\\n\\n    // checkBySolType: Invalid op for bool\\n    string constant INVALID_BOOL_OP = \\\"E22\\\";\\n\\n    // checkBySolType: Invalid op\\n    string constant CHECK_INVALID_OP = \\\"E23\\\";\\n\\n    // Invalid solidity type.\\n    string constant INVALID_SOL_TYPE = \\\"E24\\\";\\n\\n    // computeBySolType: invalid vm op\\n    string constant INVALID_VM_BOOL_OP = \\\"E25\\\";\\n\\n    // computeBySolType: invalid vm arith op\\n    string constant INVALID_VM_ARITH_OP = \\\"E26\\\";\\n\\n    // onlyCaller: Invalid caller\\n    string constant INVALID_CALLER = \\\"E27\\\";\\n\\n    // \\\"E28\\\";\\n\\n    // Side-effect is not allowed here.\\n    string constant SIDE_EFFECT_NOT_ALLOWED = \\\"E29\\\";\\n\\n    // Invalid variant count for the rule op.\\n    string constant INVALID_VAR_COUNT = \\\"E30\\\";\\n\\n    // extractCallData: Invalid op.\\n    string constant INVALID_EXTRACTOR_OP = \\\"E31\\\";\\n\\n    // extractCallData: Invalid array index.\\n    string constant INVALID_ARRAY_INDEX = \\\"E32\\\";\\n\\n    // extractCallData: No extract op.\\n    string constant NO_EXTRACT_OP = \\\"E33\\\";\\n\\n    // extractCallData: No extract path.\\n    string constant NO_EXTRACT_PATH = \\\"E34\\\";\\n\\n    // BaseOwnable: caller is not owner\\n    string constant CALLER_IS_NOT_OWNER = \\\"E35\\\";\\n\\n    // BaseOwnable: Already initialized\\n    string constant ALREADY_INITIALIZED = \\\"E36\\\";\\n\\n    // \\\"E37\\\";\\n\\n    // \\\"E38\\\";\\n\\n    // BaseACL: ACL check method should not return anything.\\n    string constant ACL_FUNC_RETURNS_NON_EMPTY = \\\"E39\\\";\\n\\n    // \\\"E40\\\";\\n\\n    // BaseAccount: Invalid delegate.\\n    string constant INVALID_DELEGATE = \\\"E41\\\";\\n\\n    // RootAuthorizer: delegateCallAuthorizer not set\\n    string constant DELEGATE_CALL_AUTH_NOT_SET = \\\"E42\\\";\\n\\n    // RootAuthorizer: callAuthorizer not set.\\n    string constant CALL_AUTH_NOT_SET = \\\"E43\\\";\\n\\n    // BaseAccount: Authorizer not set.\\n    string constant AUTHORIZER_NOT_SET = \\\"E44\\\";\\n\\n    // BaseAccount: Invalid authorizer flag.\\n    string constant INVALID_AUTHORIZER_FLAG = \\\"E45\\\";\\n\\n    // BaseAuthorizer: Authorizer paused.\\n    string constant AUTHORIZER_PAUSED = \\\"E46\\\";\\n\\n    // Authorizer set: Invalid hint.\\n    string constant INVALID_HINT = \\\"E47\\\";\\n\\n    // Authorizer set: All auth deny.\\n    string constant ALL_AUTH_FAILED = \\\"E48\\\";\\n\\n    // BaseACL: Method not allow.\\n    string constant METHOD_NOT_ALLOW = \\\"E49\\\";\\n\\n    // AuthorizerUnionSet: Invalid hint collected.\\n    string constant INVALID_HINT_COLLECTED = \\\"E50\\\";\\n\\n    // AuthorizerSet: Empty auth set\\n    string constant EMPTY_AUTH_SET = \\\"E51\\\";\\n\\n    // AuthorizerSet: hint not implement.\\n    string constant HINT_NOT_IMPLEMENT = \\\"E52\\\";\\n\\n    // RoleAuthorizer: Empty role set\\n    string constant EMPTY_ROLE_SET = \\\"E53\\\";\\n\\n    // RoleAuthorizer: No auth for the role\\n    string constant NO_AUTH_FOR_THE_ROLE = \\\"E54\\\";\\n\\n    // BaseACL: No in contract white list.\\n    string constant NOT_IN_CONTRACT_LIST = \\\"E55\\\";\\n\\n    // BaseACL: Same process not allowed to install twice.\\n    string constant SAME_PROCESS_TWICE = \\\"E56\\\";\\n\\n    // BaseAuthorizer: Account not set (then can not find roleManger)\\n    string constant ACCOUNT_NOT_SET = \\\"E57\\\";\\n\\n    // BaseAuthorizer: roleManger not set\\n    string constant ROLE_MANAGER_NOT_SET = \\\"E58\\\";\\n}\\n\"\r\n    },\r\n    \"BaseVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"IVersion.sol\\\";\\n\\n/// @title BaseVersion - Provides version information\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev\\n///    Implement NAME() and VERSION() methods according to IVersion interface.\\n///\\n///    Or just:\\n///      bytes32 public constant NAME = \\\"<Your contract name>\\\";\\n///      uint256 public constant VERSION = <Your contract version>;\\n///\\n///    Change the NAME when writing new kind of contract.\\n///    Change the VERSION when upgrading existing contract.\\nabstract contract BaseVersion is IVersion {\\n    /// @dev Convert to `string` which looks prettier on Etherscan viewer.\\n    function _NAME() external view virtual returns (string memory) {\\n        return string(abi.encodePacked(this.NAME()));\\n    }\\n}\\n\"\r\n    },\r\n    \"IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IVersion {\\n    function NAME() external view returns (bytes32 name);\\n\\n    function VERSION() external view returns (uint256 version);\\n}\\n\"\r\n    },\r\n    \"IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IAuthorizer {\\n    function flag() external view returns (uint256 authFlags);\\n\\n    function setCaller(address _caller) external;\\n\\n    function preExecCheck(TransactionData calldata transaction) external returns (AuthorizerReturnData memory authData);\\n\\n    function postExecCheck(\\n        TransactionData calldata transaction,\\n        TransactionResult calldata callResult,\\n        AuthorizerReturnData calldata preAuthData\\n    ) external returns (AuthorizerReturnData memory authData);\\n\\n    function preExecProcess(TransactionData calldata transaction) external;\\n\\n    function postExecProcess(TransactionData calldata transaction, TransactionResult calldata callResult) external;\\n}\\n\\ninterface IAuthorizerSupportingHint is IAuthorizer {\\n    // When IAuthorizer(auth).flag().supportHint() == true;\\n    function collectHint(\\n        AuthorizerReturnData calldata preAuthData,\\n        AuthorizerReturnData calldata postAuthData\\n    ) external view returns (bytes memory hint);\\n}\\n\"\r\n    },\r\n    \"IRoleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IRoleManager {\\n    function getRoles(address delegate) external view returns (bytes32[] memory);\\n\\n    function hasRole(address delegate, bytes32 role) external view returns (bool);\\n}\\n\\ninterface IFlatRoleManager is IRoleManager {\\n    function addRoles(bytes32[] calldata roles) external;\\n\\n    function grantRoles(bytes32[] calldata roles, address[] calldata delegates) external;\\n\\n    function revokeRoles(bytes32[] calldata roles, address[] calldata delegates) external;\\n\\n    function getDelegates() external view returns (address[] memory);\\n\\n    function getAllRoles() external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Types.sol\\\";\\n\\ninterface IAccount {\\n    /// @notice Call Gnosis Safe to execute a transaction\\n    /// @dev Delegates can call this method to invoke gnosis safe to forward to\\n    ///      transaction to target contract\\n    ///      The function can only be called by delegates.\\n    /// @param callData The callData  to be called by Gnosis Safe\\n    function execTransaction(CallData calldata callData) external returns (TransactionResult memory result);\\n\\n    function execTransactions(\\n        CallData[] calldata callDataList\\n    ) external returns (TransactionResult[] memory resultList);\\n\\n    function setAuthorizer(address _authorizer) external;\\n\\n    function setRoleManager(address _roleManager) external;\\n\\n    function addDelegate(address _delegate) external;\\n\\n    function addDelegates(address[] calldata _delegates) external;\\n\\n    /// @dev Sub instance should override this to set `from` for transaction\\n    /// @return account The address for the contract wallet, also the\\n    ///         `msg.sender` address which send the transaction.\\n    function getAccountAddress() external view returns (address account);\\n\\n    function roleManager() external view returns (address _roleManager);\\n\\n    function authorizer() external view returns (address _authorizer);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CoboSafeAccount.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"}],\"name\":\"AuthorizerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PendingOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"roleManager\",\"type\":\"address\"}],\"name\":\"RoleManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct TransactionData\",\"name\":\"transaction\",\"type\":\"tuple\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"addDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_delegates\",\"type\":\"address[]\"}],\"name\":\"addDelegates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorizer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct CallData\",\"name\":\"callData\",\"type\":\"tuple\"}],\"name\":\"execTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"}],\"internalType\":\"struct CallData[]\",\"name\":\"callDataList\",\"type\":\"tuple[]\"}],\"name\":\"execTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"hint\",\"type\":\"bytes\"}],\"internalType\":\"struct TransactionResult[]\",\"name\":\"resultList\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccountAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDelegates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"hasDelegate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_roleManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"removeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_delegates\",\"type\":\"address[]\"}],\"name\":\"removeDelegates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roleManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"}],\"name\":\"setAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_roleManager\",\"type\":\"address\"}],\"name\":\"setRoleManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CoboSafeAccount", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000089635b6dc339ff219c53ef8a7c53af3368decabb", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}