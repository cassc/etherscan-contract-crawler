{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@balancer-labs/v2-pool-utils/contracts/interfaces/IPoolPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IPoolPriceOracle {\\n    /**\\n     * @dev Returns the raw data of the sample at `index`.\\n     */\\n    function getSample(uint256 index)\\n        external\\n        view\\n        returns (\\n            int256 logPairPrice,\\n            int256 accLogPairPrice,\\n            int256 logBptPrice,\\n            int256 accLogBptPrice,\\n            int256 logInvariant,\\n            int256 accLogInvariant,\\n            uint256 timestamp\\n        );\\n\\n    /**\\n     * @dev Returns the total number of samples.\\n     */\\n    function getTotalSamples() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-pool-utils/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Interface for querying historical data from a Pool that can be used as a Price Oracle.\\n *\\n * This lets third parties retrieve average prices of tokens held by a Pool over a given period of time, as well as the\\n * price of the Pool share token (BPT) and invariant. Since the invariant is a sensible measure of Pool liquidity, it\\n * can be used to compare two different price sources, and choose the most liquid one.\\n *\\n * Once the oracle is fully initialized, all queries are guaranteed to succeed as long as they require no data that\\n * is not older than the largest safe query window.\\n */\\ninterface IPriceOracle {\\n    // The three values that can be queried:\\n    //\\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\\n    //\\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\\n    //\\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\\n    enum Variable { PAIR_PRICE, BPT_PRICE, INVARIANT }\\n\\n    /**\\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\\n     * decimal fixed point values.\\n     */\\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\\n        external\\n        view\\n        returns (uint256[] memory results);\\n\\n    /**\\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\\n     */\\n    function getLatest(Variable variable) external view returns (uint256);\\n\\n    /**\\n     * @dev Information for a Time Weighted Average query.\\n     *\\n     * Each query computes the average over a window of duration `secs` seconds that ended `ago` seconds ago. For\\n     * example, the average over the past 30 minutes is computed by settings secs to 1800 and ago to 0. If secs is 1800\\n     * and ago is 1800 as well, the average between 60 and 30 minutes ago is computed instead.\\n     */\\n    struct OracleAverageQuery {\\n        Variable variable;\\n        uint256 secs;\\n        uint256 ago;\\n    }\\n\\n    /**\\n     * @dev Returns largest time window that can be safely queried, where 'safely' means the Oracle is guaranteed to be\\n     * able to produce a result and not revert.\\n     *\\n     * If a query has a non-zero `ago` value, then `secs + ago` (the oldest point in time) must be smaller than this\\n     * value for 'safe' queries.\\n     */\\n    function getLargestSafeQueryWindow() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the accumulators corresponding to each of `queries`.\\n     */\\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\\n        external\\n        view\\n        returns (int256[] memory results);\\n\\n    /**\\n     * @dev Information for an Accumulator query.\\n     *\\n     * Each query estimates the accumulator at a time `ago` seconds ago.\\n     */\\n    struct OracleAccumulatorQuery {\\n        Variable variable;\\n        uint256 ago;\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./IAuthentication.sol\\\";\\n\\n/**\\n * @dev Building block for performing access control on external functions.\\n *\\n * This contract is used via the `authenticate` modifier (or the `_authenticateCaller` function), which can be applied\\n * to external functions to only make them callable by authorized accounts.\\n *\\n * Derived contracts must implement the `_canPerform` function, which holds the actual access control logic.\\n */\\nabstract contract Authentication is IAuthentication {\\n    bytes32 private immutable _actionIdDisambiguator;\\n\\n    /**\\n     * @dev The main purpose of the `actionIdDisambiguator` is to prevent accidental function selector collisions in\\n     * multi contract systems.\\n     *\\n     * There are two main uses for it:\\n     *  - if the contract is a singleton, any unique identifier can be used to make the associated action identifiers\\n     *    unique. The contract's own address is a good option.\\n     *  - if the contract belongs to a family that shares action identifiers for the same functions, an identifier\\n     *    shared by the entire family (and no other contract) should be used instead.\\n     */\\n    constructor(bytes32 actionIdDisambiguator) {\\n        _actionIdDisambiguator = actionIdDisambiguator;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\\n     */\\n    modifier authenticate() {\\n        _authenticateCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call the entry point function.\\n     */\\n    function _authenticateCaller() internal view {\\n        bytes32 actionId = getActionId(msg.sig);\\n        _require(_canPerform(actionId, msg.sender), Errors.SENDER_NOT_ALLOWED);\\n    }\\n\\n    function getActionId(bytes4 selector) public view override returns (bytes32) {\\n        // Each external function is dynamically assigned an action identifier as the hash of the disambiguator and the\\n        // function selector. Disambiguation is necessary to avoid potential collisions in the function selectors of\\n        // multiple contracts.\\n        return keccak256(abi.encodePacked(_actionIdDisambiguator, selector));\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/BalancerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/IAuthentication.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthentication {\\n    /**\\n     * @dev Returns the action identifier associated with the external function described by `selector`.\\n     */\\n    function getActionId(bytes4 selector) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/ISignaturesValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\\n */\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Returns the EIP712 domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the next nonce used by an address to sign messages.\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/ITemporarilyPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface for the TemporarilyPausable helper.\\n */\\ninterface ITemporarilyPausable {\\n    /**\\n     * @dev Emitted every time the pause state changes by `_setPaused`.\\n     */\\n    event PausedStateChanged(bool paused);\\n\\n    /**\\n     * @dev Returns the current paused state.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        );\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/SignaturesValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./ISignaturesValidator.sol\\\";\\nimport \\\"../openzeppelin/EIP712.sol\\\";\\n\\n/**\\n * @dev Utility for signing Solidity function calls.\\n *\\n * This contract relies on the fact that Solidity contracts can be called with extra calldata, and enables\\n * meta-transaction schemes by appending an EIP712 signature of the original calldata at the end.\\n *\\n * Derived contracts must implement the `_typeHash` function to map function selectors to EIP712 structs.\\n */\\nabstract contract SignaturesValidator is ISignaturesValidator, EIP712 {\\n    // The appended data consists of a deadline, plus the [v,r,s] signature. For simplicity, we use a full 256 bit slot\\n    // for each of these values, even if 'v' is typically an 8 bit value.\\n    uint256 internal constant _EXTRA_CALLDATA_LENGTH = 4 * 32;\\n\\n    // Replay attack prevention for each user.\\n    mapping(address => uint256) internal _nextNonce;\\n\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function getDomainSeparator() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    function getNextNonce(address user) external view override returns (uint256) {\\n        return _nextNonce[user];\\n    }\\n\\n    /**\\n     * @dev Reverts with `errorCode` unless a valid signature for `user` was appended to the calldata.\\n     */\\n    function _validateSignature(address user, uint256 errorCode) internal {\\n        uint256 nextNonce = _nextNonce[user]++;\\n        _require(_isSignatureValid(user, nextNonce), errorCode);\\n    }\\n\\n    function _isSignatureValid(address user, uint256 nonce) private view returns (bool) {\\n        uint256 deadline = _deadline();\\n\\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\\n        // solhint-disable-next-line not-rely-on-time\\n        if (deadline < block.timestamp) {\\n            return false;\\n        }\\n\\n        bytes32 typeHash = _typeHash();\\n        if (typeHash == bytes32(0)) {\\n            // Prevent accidental signature validation for functions that don't have an associated type hash.\\n            return false;\\n        }\\n\\n        // All type hashes have this format: (bytes calldata, address sender, uint256 nonce, uint256 deadline).\\n        bytes32 structHash = keccak256(abi.encode(typeHash, keccak256(_calldata()), msg.sender, nonce, deadline));\\n        bytes32 digest = _hashTypedDataV4(structHash);\\n        (uint8 v, bytes32 r, bytes32 s) = _signature();\\n\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\\n        return recoveredAddress != address(0) && recoveredAddress == user;\\n    }\\n\\n    /**\\n     * @dev Returns the EIP712 type hash for the current entry point function, which can be identified by its function\\n     * selector (available as `msg.sig`).\\n     *\\n     * The type hash must conform to the following format:\\n     *  <name>(bytes calldata, address sender, uint256 nonce, uint256 deadline)\\n     *\\n     * If 0x00, all signatures will be considered invalid.\\n     */\\n    function _typeHash() internal view virtual returns (bytes32);\\n\\n    /**\\n     * @dev Extracts the signature deadline from extra calldata.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _deadline() internal pure returns (uint256) {\\n        // The deadline is the first extra argument at the end of the original calldata.\\n        return uint256(_decodeExtraCalldataWord(0));\\n    }\\n\\n    /**\\n     * @dev Extracts the signature parameters from extra calldata.\\n     *\\n     * This function returns bogus data if no signature is included. This is not a security risk, as that data would not\\n     * be considered a valid signature in the first place.\\n     */\\n    function _signature()\\n        internal\\n        pure\\n        returns (\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        )\\n    {\\n        // v, r and s are appended after the signature deadline, in that order.\\n        v = uint8(uint256(_decodeExtraCalldataWord(0x20)));\\n        r = _decodeExtraCalldataWord(0x40);\\n        s = _decodeExtraCalldataWord(0x60);\\n    }\\n\\n    /**\\n     * @dev Returns the original calldata, without the extra bytes containing the signature.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _calldata() internal pure returns (bytes memory result) {\\n        result = msg.data; // A calldata to memory assignment results in memory allocation and copy of contents.\\n        if (result.length > _EXTRA_CALLDATA_LENGTH) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // We simply overwrite the array length with the reduced one.\\n                mstore(result, sub(calldatasize(), _EXTRA_CALLDATA_LENGTH))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a 256 bit word from 'extra' calldata, at some offset from the expected end of the original calldata.\\n     *\\n     * This function returns bogus data if no signature is included.\\n     */\\n    function _decodeExtraCalldataWord(uint256 offset) private pure returns (bytes32 result) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := calldataload(add(sub(calldatasize(), _EXTRA_CALLDATA_LENGTH), offset))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\nimport \\\"./ITemporarilyPausable.sol\\\";\\n\\n/**\\n * @dev Allows for a contract to be paused during an initial period after deployment, disabling functionality. Can be\\n * used as an emergency switch in case a security vulnerability or threat is identified.\\n *\\n * The contract can only be paused during the Pause Window, a period that starts at deployment. It can also be\\n * unpaused and repaused any number of times during this period. This is intended to serve as a safety measure: it lets\\n * system managers react quickly to potentially dangerous situations, knowing that this action is reversible if careful\\n * analysis later determines there was a false alarm.\\n *\\n * If the contract is paused when the Pause Window finishes, it will remain in the paused state through an additional\\n * Buffer Period, after which it will be automatically unpaused forever. This is to ensure there is always enough time\\n * to react to an emergency, even if the threat is discovered shortly before the Pause Window expires.\\n *\\n * Note that since the contract can only be paused within the Pause Window, unpausing during the Buffer Period is\\n * irreversible.\\n */\\nabstract contract TemporarilyPausable is ITemporarilyPausable {\\n    // The Pause Window and Buffer Period are timestamp-based: they should not be relied upon for sub-minute accuracy.\\n    // solhint-disable not-rely-on-time\\n\\n    uint256 private constant _MAX_PAUSE_WINDOW_DURATION = 90 days;\\n    uint256 private constant _MAX_BUFFER_PERIOD_DURATION = 30 days;\\n\\n    uint256 private immutable _pauseWindowEndTime;\\n    uint256 private immutable _bufferPeriodEndTime;\\n\\n    bool private _paused;\\n\\n    constructor(uint256 pauseWindowDuration, uint256 bufferPeriodDuration) {\\n        _require(pauseWindowDuration <= _MAX_PAUSE_WINDOW_DURATION, Errors.MAX_PAUSE_WINDOW_DURATION);\\n        _require(bufferPeriodDuration <= _MAX_BUFFER_PERIOD_DURATION, Errors.MAX_BUFFER_PERIOD_DURATION);\\n\\n        uint256 pauseWindowEndTime = block.timestamp + pauseWindowDuration;\\n\\n        _pauseWindowEndTime = pauseWindowEndTime;\\n        _bufferPeriodEndTime = pauseWindowEndTime + bufferPeriodDuration;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    modifier whenNotPaused() {\\n        _ensureNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current contract pause status, as well as the end times of the Pause Window and Buffer\\n     * Period.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        override\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        )\\n    {\\n        paused = !_isNotPaused();\\n        pauseWindowEndTime = _getPauseWindowEndTime();\\n        bufferPeriodEndTime = _getBufferPeriodEndTime();\\n    }\\n\\n    /**\\n     * @dev Sets the pause state to `paused`. The contract can only be paused until the end of the Pause Window, and\\n     * unpaused until the end of the Buffer Period.\\n     *\\n     * Once the Buffer Period expires, this function reverts unconditionally.\\n     */\\n    function _setPaused(bool paused) internal {\\n        if (paused) {\\n            _require(block.timestamp < _getPauseWindowEndTime(), Errors.PAUSE_WINDOW_EXPIRED);\\n        } else {\\n            _require(block.timestamp < _getBufferPeriodEndTime(), Errors.BUFFER_PERIOD_EXPIRED);\\n        }\\n\\n        _paused = paused;\\n        emit PausedStateChanged(paused);\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is paused.\\n     */\\n    function _ensureNotPaused() internal view {\\n        _require(_isNotPaused(), Errors.PAUSED);\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is unpaused.\\n     *\\n     * Once the Buffer Period expires, the gas cost of calling this function is reduced dramatically, as storage is no\\n     * longer accessed.\\n     */\\n    function _isNotPaused() internal view returns (bool) {\\n        // After the Buffer Period, the (inexpensive) timestamp check short-circuits the storage access.\\n        return block.timestamp > _getBufferPeriodEndTime() || !_paused;\\n    }\\n\\n    // These getters lead to reduced bytecode size by inlining the immutable variables in a single place.\\n\\n    function _getPauseWindowEndTime() private view returns (uint256) {\\n        return _pauseWindowEndTime;\\n    }\\n\\n    function _getBufferPeriodEndTime() private view returns (uint256) {\\n        return _bufferPeriodEndTime;\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/misc/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../openzeppelin/IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for WETH9.\\n * See https://github.com/gnosis/canonical-weth/blob/0dd1ea3e295eef916d0c6223ec63141137d22d67/contracts/WETH9.sol\\n */\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n        _TYPE_HASH = keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        // Silence state mutability warning without generating bytecode.\\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\\n        // https://github.com/ethereum/solidity/issues/2691\\n        this;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce bytecode size.\\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\\n// private functions, we achieve the same end result with slightly higher runtime gas costs, but reduced bytecode size.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _enterNonReentrant();\\n        _;\\n        _exitNonReentrant();\\n    }\\n\\n    function _enterNonReentrant() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        _require(_status != _ENTERED, Errors.REENTRANCY);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _exitNonReentrant() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/interfaces/IAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/interfaces/IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthorizer {\\n    /**\\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n     */\\n    function canPerform(\\n        bytes32 actionId,\\n        address account,\\n        address where\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/interfaces/IProtocolFeesCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\n\\ninterface IProtocolFeesCollector {\\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external;\\n\\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\\n\\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\\n\\n    function getSwapFeePercentage() external view returns (uint256);\\n\\n    function getFlashLoanFeePercentage() external view returns (uint256);\\n\\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\\n\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    function vault() external view returns (IVault);\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/ISignaturesValidator.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/ITemporarilyPausable.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/misc/IWETH.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\nimport \\\"./IProtocolFeesCollector.sol\\\";\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     *\\n     * Emits an `AuthorizerChanged` event.\\n     */\\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n     */\\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n    // Relayers\\n    //\\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n    // this power, two things must occur:\\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n    //    functions.\\n    //  - Each user must approve the relayer to act on their behalf.\\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n     */\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n    // functionality:\\n    //\\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // which increase with the number of registered tokens.\\n    //\\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n\\n    enum PoolBalanceChangeKind { JOIN, EXIT }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n     */\\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n     *\\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n     * operations of different kinds, with different Pools and tokens, at once.\\n     *\\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n     */\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n    struct PoolBalanceOp {\\n        PoolBalanceOpKind kind;\\n        bytes32 poolId;\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n     */\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        IERC20 indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\\n     * error in some part of the system.\\n     *\\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\\n     *\\n     * While the contract is paused, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     * - Asset Manager interactions\\n     *\\n     * Internal Balance can still be withdrawn, and Pools exited.\\n     */\\n    function setPaused(bool paused) external;\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    function WETH() external view returns (IWETH);\\n    // solhint-disable-previous-line func-name-mixedcase\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/PoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/BalancerErrors.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./VaultAuthorization.sol\\\";\\n\\n/**\\n * @dev Maintains the Pool ID data structure, implements Pool ID creation and registration, and defines useful modifiers\\n * and helper functions for ensuring correct behavior when working with Pools.\\n */\\nabstract contract PoolRegistry is ReentrancyGuard, VaultAuthorization {\\n    // Each pool is represented by their unique Pool ID. We use `bytes32` for them, for lack of a way to define new\\n    // types.\\n    mapping(bytes32 => bool) private _isPoolRegistered;\\n\\n    // We keep an increasing nonce to make Pool IDs unique. It is interpreted as a `uint80`, but storing it as a\\n    // `uint256` results in reduced bytecode on reads and writes due to the lack of masking.\\n    uint256 private _nextPoolNonce;\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\\n     */\\n    modifier withRegisteredPool(bytes32 poolId) {\\n        _ensureRegisteredPool(poolId);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\\n     */\\n    modifier onlyPool(bytes32 poolId) {\\n        _ensurePoolIsSender(poolId);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool.\\n     */\\n    function _ensureRegisteredPool(bytes32 poolId) internal view {\\n        _require(_isPoolRegistered[poolId], Errors.INVALID_POOL_ID);\\n    }\\n\\n    /**\\n     * @dev Reverts unless `poolId` corresponds to a registered Pool, and the caller is the Pool's contract.\\n     */\\n    function _ensurePoolIsSender(bytes32 poolId) private view {\\n        _ensureRegisteredPool(poolId);\\n        _require(msg.sender == _getPoolAddress(poolId), Errors.CALLER_NOT_POOL);\\n    }\\n\\n    function registerPool(PoolSpecialization specialization)\\n        external\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        returns (bytes32)\\n    {\\n        // Each Pool is assigned a unique ID based on an incrementing nonce. This assumes there will never be more than\\n        // 2**80 Pools, and the nonce will not overflow.\\n\\n        bytes32 poolId = _toPoolId(msg.sender, specialization, uint80(_nextPoolNonce));\\n\\n        _require(!_isPoolRegistered[poolId], Errors.INVALID_POOL_ID); // Should never happen as Pool IDs are unique.\\n        _isPoolRegistered[poolId] = true;\\n\\n        _nextPoolNonce += 1;\\n\\n        // Note that msg.sender is the pool's contract\\n        emit PoolRegistered(poolId, msg.sender, specialization);\\n        return poolId;\\n    }\\n\\n    function getPool(bytes32 poolId)\\n        external\\n        view\\n        override\\n        withRegisteredPool(poolId)\\n        returns (address, PoolSpecialization)\\n    {\\n        return (_getPoolAddress(poolId), _getPoolSpecialization(poolId));\\n    }\\n\\n    /**\\n     * @dev Creates a Pool ID.\\n     *\\n     * These are deterministically created by packing the Pool's contract address and its specialization setting into\\n     * the ID. This saves gas by making this data easily retrievable from a Pool ID with no storage accesses.\\n     *\\n     * Since a single contract can register multiple Pools, a unique nonce must be provided to ensure Pool IDs are\\n     * unique.\\n     *\\n     * Pool IDs have the following layout:\\n     * | 20 bytes pool contract address | 2 bytes specialization setting | 10 bytes nonce |\\n     * MSB                                                                              LSB\\n     *\\n     * 2 bytes for the specialization setting is a bit overkill: there only three of them, which means two bits would\\n     * suffice. However, there's nothing else of interest to store in this extra space.\\n     */\\n    function _toPoolId(\\n        address pool,\\n        PoolSpecialization specialization,\\n        uint80 nonce\\n    ) internal pure returns (bytes32) {\\n        bytes32 serialized;\\n\\n        serialized |= bytes32(uint256(nonce));\\n        serialized |= bytes32(uint256(specialization)) << (10 * 8);\\n        serialized |= bytes32(uint256(pool)) << (12 * 8);\\n\\n        return serialized;\\n    }\\n\\n    /**\\n     * @dev Returns the address of a Pool's contract.\\n     *\\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n     */\\n    function _getPoolAddress(bytes32 poolId) internal pure returns (address) {\\n        // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\\n        // since the logical shift already sets the upper bits to zero.\\n        return address(uint256(poolId) >> (12 * 8));\\n    }\\n\\n    /**\\n     * @dev Returns the specialization setting of a Pool.\\n     *\\n     * Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n     */\\n    function _getPoolSpecialization(bytes32 poolId) internal pure returns (PoolSpecialization specialization) {\\n        // 10 byte logical shift left to remove the nonce, followed by a 2 byte mask to remove the address.\\n        uint256 value = uint256(poolId >> (10 * 8)) & (2**(2 * 8) - 1);\\n\\n        // Casting a value into an enum results in a runtime check that reverts unless the value is within the enum's\\n        // range. Passing an invalid Pool ID to this function would then result in an obscure revert with no reason\\n        // string: we instead perform the check ourselves to help in error diagnosis.\\n\\n        // There are three Pool specialization settings: general, minimal swap info and two tokens, which correspond to\\n        // values 0, 1 and 2.\\n        _require(value < 3, Errors.INVALID_POOL_ID);\\n\\n        // Because we have checked that `value` is within the enum range, we can use assembly to skip the runtime check.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            specialization := value\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@balancer-labs/v2-vault/contracts/VaultAuthorization.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/BalancerErrors.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/Authentication.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/TemporarilyPausable.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/BalancerErrors.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/helpers/SignaturesValidator.sol\\\";\\nimport \\\"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./interfaces/IAuthorizer.sol\\\";\\n\\n/**\\n * @dev Manages access control of Vault permissioned functions by relying on the Authorizer and signature validation.\\n *\\n * Additionally handles relayer access and approval.\\n */\\nabstract contract VaultAuthorization is\\n    IVault,\\n    ReentrancyGuard,\\n    Authentication,\\n    SignaturesValidator,\\n    TemporarilyPausable\\n{\\n    // Ideally, we'd store the type hashes as immutable state variables to avoid computing the hash at runtime, but\\n    // unfortunately immutable variables cannot be used in assembly, so we just keep the precomputed hashes instead.\\n\\n    // _JOIN_TYPE_HASH = keccak256(\\\"JoinPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _JOIN_TYPE_HASH = 0x3f7b71252bd19113ff48c19c6e004a9bcfcca320a0d74d58e85877cbd7dcae58;\\n\\n    // _EXIT_TYPE_HASH = keccak256(\\\"ExitPool(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _EXIT_TYPE_HASH = 0x8bbc57f66ea936902f50a71ce12b92c43f3c5340bb40c27c4e90ab84eeae3353;\\n\\n    // _SWAP_TYPE_HASH = keccak256(\\\"Swap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _SWAP_TYPE_HASH = 0xe192dcbc143b1e244ad73b813fd3c097b832ad260a157340b4e5e5beda067abe;\\n\\n    // _BATCH_SWAP_TYPE_HASH = keccak256(\\\"BatchSwap(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _BATCH_SWAP_TYPE_HASH = 0x9bfc43a4d98313c6766986ffd7c916c7481566d9f224c6819af0a53388aced3a;\\n\\n    // _SET_RELAYER_TYPE_HASH =\\n    //     keccak256(\\\"SetRelayerApproval(bytes calldata,address sender,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        private constant _SET_RELAYER_TYPE_HASH = 0xa3f865aa351e51cfeb40f5178d1564bb629fe9030b83caf6361d1baaf5b90b5a;\\n\\n    IAuthorizer private _authorizer;\\n    mapping(address => mapping(address => bool)) private _approvedRelayers;\\n\\n    /**\\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call this function (that\\n     * is, it is a relayer for that function), and either:\\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\\n     *  b) a valid signature from them was appended to the calldata.\\n     *\\n     * Should only be applied to external functions.\\n     */\\n    modifier authenticateFor(address user) {\\n        _authenticateFor(user);\\n        _;\\n    }\\n\\n    constructor(IAuthorizer authorizer)\\n        // The Vault is a singleton, so it simply uses its own address to disambiguate action identifiers.\\n        Authentication(bytes32(uint256(address(this))))\\n        SignaturesValidator(\\\"Balancer V2 Vault\\\")\\n    {\\n        _setAuthorizer(authorizer);\\n    }\\n\\n    function setAuthorizer(IAuthorizer newAuthorizer) external override nonReentrant authenticate {\\n        _setAuthorizer(newAuthorizer);\\n    }\\n\\n    function _setAuthorizer(IAuthorizer newAuthorizer) private {\\n        emit AuthorizerChanged(newAuthorizer);\\n        _authorizer = newAuthorizer;\\n    }\\n\\n    function getAuthorizer() external view override returns (IAuthorizer) {\\n        return _authorizer;\\n    }\\n\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external override nonReentrant whenNotPaused authenticateFor(sender) {\\n        _approvedRelayers[sender][relayer] = approved;\\n        emit RelayerApprovalChanged(relayer, sender, approved);\\n    }\\n\\n    function hasApprovedRelayer(address user, address relayer) external view override returns (bool) {\\n        return _hasApprovedRelayer(user, relayer);\\n    }\\n\\n    /**\\n     * @dev Reverts unless `user` is the caller, or the caller is approved by the Authorizer to call the entry point\\n     * function (that is, it is a relayer for that function) and either:\\n     *  a) `user` approved the caller as a relayer (via `setRelayerApproval`), or\\n     *  b) a valid signature from them was appended to the calldata.\\n     */\\n    function _authenticateFor(address user) internal {\\n        if (msg.sender != user) {\\n            // In this context, 'permission to call a function' means 'being a relayer for a function'.\\n            _authenticateCaller();\\n\\n            // Being a relayer is not sufficient: `user` must have also approved the caller either via\\n            // `setRelayerApproval`, or by providing a signature appended to the calldata.\\n            if (!_hasApprovedRelayer(user, msg.sender)) {\\n                _validateSignature(user, Errors.USER_DOESNT_ALLOW_RELAYER);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `user` approved `relayer` to act as a relayer for them.\\n     */\\n    function _hasApprovedRelayer(address user, address relayer) internal view returns (bool) {\\n        return _approvedRelayers[user][relayer];\\n    }\\n\\n    function _canPerform(bytes32 actionId, address user) internal view override returns (bool) {\\n        // Access control is delegated to the Authorizer.\\n        return _authorizer.canPerform(actionId, user, address(this));\\n    }\\n\\n    function _typeHash() internal pure override returns (bytes32 hash) {\\n        // This is a simple switch-case statement, trivially written in Solidity by chaining else-if statements, but the\\n        // assembly implementation results in much denser bytecode.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // The function selector is located at the first 4 bytes of calldata. We copy the first full calldata\\n            // 256 word, and then perform a logical shift to the right, moving the selector to the least significant\\n            // 4 bytes.\\n            let selector := shr(224, calldataload(0))\\n\\n            // With the selector in the least significant 4 bytes, we can use 4 byte literals with leading zeros,\\n            // resulting in dense bytecode (PUSH4 opcodes).\\n            switch selector\\n                case 0xb95cac28 {\\n                    hash := _JOIN_TYPE_HASH\\n                }\\n                case 0x8bdb3913 {\\n                    hash := _EXIT_TYPE_HASH\\n                }\\n                case 0x52bbbe29 {\\n                    hash := _SWAP_TYPE_HASH\\n                }\\n                case 0x945bcec9 {\\n                    hash := _BATCH_SWAP_TYPE_HASH\\n                }\\n                case 0xfa6e671d {\\n                    hash := _SET_RELAYER_TYPE_HASH\\n                }\\n                default {\\n                    hash := 0x0000000000000000000000000000000000000000000000000000000000000000\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Common interface for Silo Price Providers\\ninterface IPriceProvider {\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset. Calculates TWAP price for quote/asset.\\n    /// It unifies all tokens decimal to 18, examples:\\n    /// - if asses == quote it returns 1e18\\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\\n    /// Some providers implementations need time to \\\"build\\\" buffer for TWAP price,\\n    /// so price may not be available yet but this method will return true.\\n    /// @param _asset asset in question\\n    /// @return TRUE if asset has been setup, otherwise false\\n    function assetSupported(address _asset) external view returns (bool);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\\n    /// @dev this can save us from simple human errors, in case we use invalid address\\n    /// but this should NOT be treated as security check\\n    /// @return always true\\n    function priceProviderPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvidersRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"./IPriceProvider.sol\\\";\\n\\ninterface IPriceProvidersRepository {\\n    /// @notice Emitted when price provider is added\\n    /// @param newPriceProvider new price provider address\\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\\n\\n    /// @notice Emitted when price provider is removed\\n    /// @param priceProvider removed price provider address\\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\\n\\n    /// @notice Emitted when asset is assigned to price provider\\n    /// @param asset assigned asset   address\\n    /// @param priceProvider price provider address\\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\\n\\n    /// @notice Register new price provider\\n    /// @param _priceProvider address of price provider\\n    function addPriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Unregister price provider\\n    /// @param _priceProvider address of price provider to be removed\\n    function removePriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Sets price provider for asset\\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\\n    /// @param _asset address of an asset for which price provider will be used\\n    /// @param _priceProvider address of price provider\\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\\n\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price TWAP price of a token with 18 decimals\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @notice Gets price provider assigned to an asset\\n    /// @param _asset address of an asset for which to get price provider\\n    /// @return priceProvider address of price provider\\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Gets manager role address\\n    /// @return manager role address\\n    function manager() external view returns (address);\\n\\n    /// @notice Checks if providers are available for an asset\\n    /// @param _asset asset address to check\\n    /// @return returns TRUE if price feed is ready, otherwise false\\n    function providersReadyForAsset(address _asset) external view returns (bool);\\n\\n    /// @notice Returns true if address is a registered price provider\\n    /// @param _provider address of price provider to be removed\\n    /// @return true if address is a registered price provider, otherwise false\\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\\n\\n    /// @notice Gets number of price providers registered\\n    /// @return number of price providers registered\\n    function providersCount() external view returns (uint256);\\n\\n    /// @notice Gets an array of price providers\\n    /// @return array of price providers\\n    function providerList() external view returns (address[] memory);\\n\\n    /// @notice Sanity check function\\n    /// @return returns always TRUE\\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n\\nlibrary Ping {\\n    function pong(function() external pure returns(bytes4) pingFunction) internal pure returns (bool) {\\n        return pingFunction.address != address(0) && pingFunction.selector == pingFunction();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/balancerV2/BalancerV2ForLiquidation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./BalancerV2PriceProviderV2.sol\\\";\\n\\n/// @title BalancerV2ForLiquidation\\n/// @notice This contract is used only for liquidation purposes\\ncontract BalancerV2ForLiquidation is BalancerV2PriceProviderV2 {\\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\\n    /// @param _vault main BalancerV2 contract, something like router for Uniswap but much more\\n    /// @param _periodForAvgPrice period in seconds for TWAP price, ie. 1800 means 30 min\\n    constructor(\\n        IPriceProvidersRepository _priceProvidersRepository,\\n        IVault _vault,\\n        uint32 _periodForAvgPrice\\n    ) BalancerV2PriceProviderV2(_priceProvidersRepository, _vault, _periodForAvgPrice) {\\n        // all configuration is in BalancerV2PriceProviderV2\\n    }\\n\\n    /// @dev Setup pool for asset. Use it also for update.\\n    /// @param _asset asset address\\n    /// @param _poolId BalancerV2 pool ID\\n    function setupAsset(address _asset, bytes32 _poolId) external virtual override onlyManager {\\n        IERC20[] memory tokens = verifyPool(_poolId, _asset);\\n\\n        assetsPools[_asset] = BalancerPool(_poolId, resolvePoolAddress(_poolId), address(tokens[0]) == _asset);\\n\\n        emit PoolForAsset(_asset, _poolId);\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function assetSupported(address _asset) external view virtual override returns (bool) {\\n        return assetsPools[_asset].priceOracle != address(0) || _asset == quoteToken;\\n    }\\n\\n    /// @notice Checks if provided `_poolId` is valid pool for `_asset`\\n    /// @dev NOTICE: keep in ming anyone can register pool in balancer Vault\\n    /// https://github.com/balancer-labs/balancer-v2-monorepo\\n    /// /blob/09c69ed5dc4715a0076c1dc87a81c0b6c2669b5a/pkg/vault/contracts/PoolRegistry.sol#L67\\n    /// @param _poolId balancer poolId\\n    /// @param _asset token address for which we want to check the pool\\n    /// @return tokens IERC20[] pool tokens in original order, vault throws `INVALID_POOL_ID` error when pool is invalid\\n    function verifyPool(bytes32 _poolId, address _asset) public view virtual override returns (IERC20[] memory tokens) {\\n        if (_asset == address(0)) revert(\\\"AssetIsZero\\\");\\n        if (_poolId == bytes32(0)) revert(\\\"PoolIdIsZero\\\");\\n\\n        address quote = quoteToken;\\n\\n        uint256[] memory balances;\\n        (tokens, balances,) = vault.getPoolTokens(_poolId);\\n\\n        (address tokenAsset, address tokenQuote) = address(tokens[0]) == quote\\n            ? (address(tokens[1]), address(tokens[0]))\\n            : (address(tokens[0]), address(tokens[1]));\\n\\n        if (tokenAsset != _asset) revert(\\\"InvalidPoolForAsset\\\");\\n\\n        if (tokenQuote != quote) revert(\\\"InvalidPoolForQuoteToken\\\");\\n\\n        uint256 quoteBalance = address(tokens[0]) == quote ? balances[0] : balances[1];\\n        if (quoteBalance == 0) revert(\\\"EmptyPool\\\");\\n    }\\n\\n    function getPrice(address) public pure virtual override returns (uint256) {\\n        revert(\\\"NotSupported\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/balancerV2/BalancerV2PriceProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@balancer-labs/v2-pool-utils/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@balancer-labs/v2-pool-utils/contracts/interfaces/IPoolPriceOracle.sol\\\";\\nimport \\\"@balancer-labs/v2-vault/contracts/interfaces/IVault.sol\\\";\\nimport \\\"@balancer-labs/v2-vault/contracts/PoolRegistry.sol\\\";\\n\\nimport \\\"../../utils/TwoStepOwnable.sol\\\";\\nimport \\\"../PriceProvider.sol\\\";\\nimport \\\"../IERC20Like.sol\\\";\\n\\n/// @title BalancerV2PriceProviderV2 is V1 + virtual methods\\n/// @notice Price provider contract that reads prices from BalancerV2\\ncontract BalancerV2PriceProviderV2 is PriceProvider, TwoStepOwnable {\\n    /// @notice Pool data for asset\\n    /// @param poolId balancer ID for a pool\\n    /// @param priceOracle address of the pool\\n    /// @param token0isAsset tell us if token0 in pool is equal asset, if not, then the token1 is asset\\n    /// this is an optimization, we can save 20% gas by caching this info\\n    struct BalancerPool {\\n        bytes32 poolId;\\n        address priceOracle;\\n        bool token0isAsset;\\n    }\\n\\n    /// @param secondsAgo Each query computes the average over a window of duration `secs` seconds that ended `ago`\\n    /// seconds ago.\\n    /// @param periodForAvgPrice Each query computes the average over a window of duration `secs` seconds that ended\\n    /// `ago` seconds ago. For example, the average over the past 30 minutes is computed by settings secs to 1800 and\\n    /// ago to 0. If secs is 1800 and ago is 1800 as well, the average between 60 and 30 minutes ago is computed\\n    /// instead.\\n    struct State {\\n        uint32 secondsAgo;\\n        uint32 periodForAvgPrice; \\n    }\\n\\n    /// @dev this is basically `PriceProvider.quoteToken.decimals()`\\n    uint256 private immutable _QUOTE_TOKEN_DECIMALS; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev The buffer that stores price samples has a size of 1024, so 1023 is the last index\\n    uint256 private constant _LAST_BUFFER_INDEX = 1024 - 1;\\n\\n    /// @dev Main BalancerV2 contract, something like router for Uniswap but much more\\n    IVault public immutable vault;\\n\\n    State private _state;\\n\\n    /// @notice Maps asset address to BalancerPool struct\\n    mapping(address => BalancerPool) public assetsPools;\\n\\n    /// @notice Emitted when TWAP period changes\\n    /// @param period new period in seconds, ie. 1800 means 30 min\\n    event NewPeriod(uint32 period);\\n    /// @notice Emitted when seconds ago changes\\n    /// @param ago new seconds ago value in seconds, ie. 1800 means 30 min\\n    event NewSecondsAgo(uint32 ago);\\n    /// @notice Emitted when BalancerV2 pool is set for asset\\n    /// @param asset asset address\\n    /// @param poolId BalancerV2 pool ID\\n    event PoolForAsset(address indexed asset, bytes32 indexed poolId);\\n\\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\\n    /// @param _vault main BalancerV2 contract, something like router for Uniswap but much more\\n    /// @param _periodForAvgPrice period in seconds for TWAP price, ie. 1800 means 30 min\\n    constructor(\\n        IPriceProvidersRepository _priceProvidersRepository,\\n        IVault _vault,\\n        uint32 _periodForAvgPrice\\n    ) PriceProvider(_priceProvidersRepository) {\\n        // Ping for _priceProvidersRepository is not needed here, because PriceProvider does it\\n        if (address(_vault.getProtocolFeesCollector()) == address(0)) revert(\\\"InvalidVault\\\");\\n        vault = _vault;\\n        _setPeriodForAvgPrice(_periodForAvgPrice);\\n        _QUOTE_TOKEN_DECIMALS = IERC20Like(_priceProvidersRepository.quoteToken()).decimals();\\n    }\\n\\n    /// @dev Setup pool for asset. Use it also for update.\\n    /// @param _asset asset address\\n    /// @param _poolId BalancerV2 pool ID\\n    function setupAsset(address _asset, bytes32 _poolId) external virtual onlyManager {\\n        IERC20[] memory tokens = verifyPool(_poolId, _asset);\\n\\n        assetsPools[_asset] = BalancerPool(_poolId, resolvePoolAddress(_poolId), address(tokens[0]) == _asset);\\n\\n        emit PoolForAsset(_asset, _poolId);\\n\\n        // make sure getPrice does not revert\\n        getPrice(_asset);\\n    }\\n\\n    /// @notice Change period for average price\\n    /// @param _period period in seconds for TWAP price, ie. 1800 means 30 min\\n    function changePeriodForAvgPrice(uint32 _period) external virtual onlyManager {\\n        _setPeriodForAvgPrice(_period);\\n    }\\n\\n    /// @notice Change number of seconds in the past when calculations start for average price\\n    /// @param _ago new seconds ago value in seconds, ie. 1800 means 30 min\\n    function changeSecondsAgo(uint32 _ago) external virtual onlyManager {\\n        _setSecondsAgo(_ago);\\n    }\\n\\n    /// @notice Change period for average price and number of seconds in the past when calculations start\\n    /// for average price\\n    /// @param _period period in seconds for TWAP price, ie. 1800 means 30 min\\n    /// @param _ago new seconds ago value in seconds, ie. 1800 means 30 min\\n    function changeSettings(uint32 _period, uint32 _ago) external virtual onlyManager {\\n        _setPeriodForAvgPrice(_period);\\n        _setSecondsAgo(_ago);\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function assetSupported(address _asset) external view virtual override returns (bool) {\\n        return assetsPools[_asset].priceOracle != address(0) || _asset == quoteToken;\\n    }\\n\\n    /// @notice Checks if price buffer is ready for a BalancerV2 pool assigned to an asset\\n    /// @param _asset asset address\\n    /// @return true if buffer ready, otherwise false\\n    function priceBufferReady(address _asset) external view virtual returns (bool) {\\n        bytes32 poolId = assetsPools[_asset].poolId;\\n        \\n        if (poolId == bytes32(0)) {\\n            return false;\\n        }\\n\\n        (,,,,,, uint256 timestamp) = IPoolPriceOracle(resolvePoolAddress(poolId)).getSample(_LAST_BUFFER_INDEX);\\n        return timestamp != 0;\\n    }\\n\\n    /// @notice Information for a Time Weighted Average query.\\n    function secondsAgo() external view virtual returns (uint32) {\\n        return _state.secondsAgo;\\n    }\\n\\n    /// @notice Information for a Time Weighted Average query.\\n    function periodForAvgPrice() external view virtual returns (uint32) {\\n        return _state.periodForAvgPrice;\\n    }\\n    \\n    /// @notice Returns price for a given asset\\n    /// @dev Balancer docs:\\n    ///     | Some pools (WeightedPool2Tokens and MetaStable Pools) have optional Oracle functionality.\\n    ///     | This means that they can be used as sources of on-chain price data.\\n    ///\\n    ///     | Note from balancer docs: that you can only call getWeightedTimeAverage after the buffer is full,\\n    ///     | or it will revert with ORACLE_NOT_INITIALIZED. If you call getSample(1023) and it returns 0's,\\n    ///     | that means the buffer's not full yet.\\n    ///\\n    /// We are using Resilient way (recommended by balancer for lending protocols),\\n    /// Less up-to-date but more resilient to manipulation\\n    /// @param _asset asset address\\n    /// @return price of asset in 18 decimals\\n    function getPrice(address _asset) public view virtual override returns (uint256 price) {\\n        if (_asset == quoteToken) {\\n            return 10 ** _QUOTE_TOKEN_DECIMALS;\\n        }\\n\\n        BalancerPool storage pool = assetsPools[_asset];\\n        address priceOracle = pool.priceOracle;\\n        if (priceOracle == address(0)) revert(\\\"PoolNotSet\\\");\\n\\n        State memory state = _state;\\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\\n        queries[0] = IPriceOracle.OracleAverageQuery(\\n            IPriceOracle.Variable.PAIR_PRICE,\\n            state.periodForAvgPrice,\\n            state.secondsAgo\\n        );\\n\\n        // `getTimeWeightedAverage` uses `getPastAccumulator`, that method returns the value of the accumulator\\n        // for `variable` `ago` seconds ago.\\n        //\\n        // Reverts under the following conditions:\\n        // - if the buffer is empty.\\n        // - if querying past information and the buffer has not been fully initialized.\\n        // - if querying older information than available in the buffer. Note that a full buffer guarantees queries\\n        //   for the past 34 hours will not revert.\\n        //\\n        // If requesting information for a timestamp later than the latest one, it is extrapolated using the latest\\n        // available data.\\n        //\\n        // When no exact information is available for the requested past timestamp (as usually happens,\\n        // since at most one timestamp is stored every two minutes), it is estimated by performing linear interpolation\\n        // using the closest values. This process is guaranteed to complete performing at most 10 storage reads.\\n        //\\n        // We have also option to use priceOracle.getLargestSafeQueryWindow() but it will not allow for custom period.\\n        uint256[] memory results = IPriceOracle(priceOracle).getTimeWeightedAverage(queries);\\n\\n        price = pool.token0isAsset ? 1e36 / results[0] : results[0];\\n    }\\n\\n    /// @notice Checks if provided `_poolId` is valid pool for `_asset`\\n    /// @dev NOTICE: keep in ming anyone can register pool in balancer Vault\\n    /// https://github.com/balancer-labs/balancer-v2-monorepo\\n    /// /blob/09c69ed5dc4715a0076c1dc87a81c0b6c2669b5a/pkg/vault/contracts/PoolRegistry.sol#L67\\n    /// Only some pools (WeightedPool2Tokens and MetaStable Pools) provides oracle functionality.\\n    /// To be 100% sure, if pool has build-in oracle, we need to do call for getLargestSafeQueryWindow()\\n    /// and see if it fails or not.\\n    /// @param _poolId balancer poolId\\n    /// @param _asset token address for which we want to check the pool\\n    /// @return tokens IERC20[] pool tokens in original order, vault throws `INVALID_POOL_ID` error when pool is invalid\\n    function verifyPool(bytes32 _poolId, address _asset) public view virtual returns (IERC20[] memory tokens) {\\n        if (_asset == address(0)) revert(\\\"AssetIsZero\\\");\\n        if (_poolId == bytes32(0)) revert(\\\"PoolIdIsZero\\\");\\n\\n        address quote = quoteToken;\\n\\n        uint256[] memory balances;\\n        (tokens, balances,) = vault.getPoolTokens(_poolId);\\n\\n        (address tokenAsset, address tokenQuote) = address(tokens[0]) == quote\\n            ? (address(tokens[1]), address(tokens[0]))\\n            : (address(tokens[0]), address(tokens[1]));\\n\\n        if (tokenAsset != _asset) revert(\\\"InvalidPoolForAsset\\\");\\n\\n        if (tokenQuote != quote) revert(\\\"InvalidPoolForQuoteToken\\\");\\n\\n        uint256 quoteBalance = address(tokens[0]) == quote ? balances[0] : balances[1];\\n        if (quoteBalance == 0) revert(\\\"EmptyPool\\\");\\n\\n        address pool = resolvePoolAddress(_poolId);\\n\\n        (bool success, bytes memory data) = pool.staticcall(\\n            abi.encodePacked(IPriceOracle.getLargestSafeQueryWindow.selector)\\n        );\\n\\n        if (!success || data.length == 0) revert(\\\"InvalidPool\\\");\\n    }\\n\\n    /// @notice Gets amount of quote token deposited in the pool\\n    /// @param _poolId must be valid pool for asset, balancer will throw BAL#500 if it's not\\n    /// @return amount of quote token in the pool, vault throws `INVALID_POOL_ID` error when pool is invalid\\n    function getPoolQuoteLiquidity(bytes32 _poolId) public view virtual returns (uint256) {\\n        if (_poolId == bytes32(0)) {\\n            return 0;\\n        }\\n\\n        (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            // uint256 lastChangeBlock\\n        ) = vault.getPoolTokens(_poolId);\\n\\n        return address(tokens[0]) == quoteToken ? balances[0] : balances[1];\\n    }\\n\\n    /// @notice Returns the address of a Pool's contract.\\n    /// This is exact copy from Balancer repo.\\n    /// @dev Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n    /// @param _poolId valid pool for asset\\n    /// @return pool address\\n    function resolvePoolAddress(bytes32 _poolId) public pure virtual returns (address) {\\n        // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\\n        // since the logical shift already sets the upper bits to zero.\\n        return address(uint256(_poolId) >> (12 * 8));\\n    }\\n\\n\\n    /// @dev Sets period for average price\\n    /// @param _period period in seconds for TWAP price, ie. 1800 means 30 min\\n    function _setPeriodForAvgPrice(uint32 _period) internal virtual {\\n        if (_period == 0) revert(\\\"InvalidPeriodForAvgPrice\\\");\\n        if (_state.periodForAvgPrice == _period) revert(\\\"PeriodForAvgPriceDidNotChange\\\");\\n\\n        _state.periodForAvgPrice = _period;\\n        emit NewPeriod(_period);\\n    }\\n\\n    /// @dev Sets number of seconds in the past when calculations start for average price\\n    /// @param _ago new seconds ago value in seconds, ie. 1800 means 30 min\\n    function _setSecondsAgo(uint32 _ago) internal virtual {\\n        if (_state.secondsAgo == _ago) revert(\\\"SecondsAgoDidNotChange\\\");\\n\\n        _state.secondsAgo = _ago;\\n        emit NewSecondsAgo(_ago);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/IERC20Like.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.6;\\n\\n/// @dev This is only meant to be used by price providers, which use a different\\n/// Solidity version than the rest of the codebase. This way de won't need to include\\n/// an additional version of OpenZeppelin's library.\\ninterface IERC20Like {\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/priceProviders/PriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"../lib/Ping.sol\\\";\\nimport \\\"../interfaces/IPriceProvider.sol\\\";\\nimport \\\"../interfaces/IPriceProvidersRepository.sol\\\";\\n\\n/// @title PriceProvider\\n/// @notice Abstract PriceProvider contract, parent of all PriceProviders\\n/// @dev Price provider is a contract that directly integrates with a price source, ie. a DEX or alternative system\\n/// like Chainlink to calculate TWAP prices for assets. Each price provider should support a single price source\\n/// and multiple assets.\\nabstract contract PriceProvider is IPriceProvider {\\n    /// @notice PriceProvidersRepository address\\n    IPriceProvidersRepository public immutable priceProvidersRepository;\\n\\n    /// @notice Token address which prices are quoted in. Must be the same as PriceProvidersRepository.quoteToken\\n    address public immutable override quoteToken;\\n\\n    modifier onlyManager() {\\n        if (priceProvidersRepository.manager() != msg.sender) revert(\\\"OnlyManager\\\");\\n        _;\\n    }\\n\\n    /// @param _priceProvidersRepository address of PriceProvidersRepository\\n    constructor(IPriceProvidersRepository _priceProvidersRepository) {\\n        if (\\n            !Ping.pong(_priceProvidersRepository.priceProvidersRepositoryPing)            \\n        ) {\\n            revert(\\\"InvalidPriceProviderRepository\\\");\\n        }\\n\\n        priceProvidersRepository = _priceProvidersRepository;\\n        quoteToken = _priceProvidersRepository.quoteToken();\\n    }\\n\\n    /// @inheritdoc IPriceProvider\\n    function priceProviderPing() external pure override returns (bytes4) {\\n        return this.priceProviderPing.selector;\\n    }\\n\\n    function _revertBytes(bytes memory _errMsg, string memory _customErr) internal pure {\\n        if (_errMsg.length > 0) {\\n            assembly { // solhint-disable-line no-inline-assembly\\n                revert(add(32, _errMsg), mload(_errMsg))\\n            }\\n        }\\n\\n        revert(_customErr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TwoStepOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title TwoStepOwnable\\n/// @notice Contract that implements the same functionality as popular Ownable contract from openzeppelin library.\\n/// The only difference is that it adds a possibility to transfer ownership in two steps. Single step ownership\\n/// transfer is still supported.\\n/// @dev Two step ownership transfer is meant to be used by humans to avoid human error. Single step ownership\\n/// transfer is meant to be used by smart contracts to avoid over-complicated two step integration. For that reason,\\n/// both ways are supported.\\nabstract contract TwoStepOwnable {\\n    /// @dev current owner\\n    address private _owner;\\n    /// @dev candidate to an owner\\n    address private _pendingOwner;\\n\\n    /// @notice Emitted when ownership is transferred on `transferOwnership` and `acceptOwnership`\\n    /// @param newOwner new owner\\n    event OwnershipTransferred(address indexed newOwner);\\n    /// @notice Emitted when ownership transfer is proposed, aka pending owner is set\\n    /// @param newPendingOwner new proposed/pending owner\\n    event OwnershipPending(address indexed newPendingOwner);\\n\\n    /**\\n     *  error OnlyOwner();\\n     *  error OnlyPendingOwner();\\n     *  error OwnerIsZero();\\n     */\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert(\\\"OnlyOwner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert(\\\"OwnerIsZero\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers pending ownership of the contract to a new account (`newPendingOwner`) and clears any existing\\n     * pending ownership.\\n     * Can only be called by the current owner.\\n     */\\n    function transferPendingOwnership(address newPendingOwner) public virtual onlyOwner {\\n        _setPendingOwner(newPendingOwner);\\n    }\\n\\n    /**\\n     * @dev Clears the pending ownership.\\n     * Can only be called by the current owner.\\n     */\\n    function removePendingOwnership() public virtual onlyOwner {\\n        _setPendingOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a pending owner\\n     * Can only be called by the pending owner.\\n     */\\n    function acceptOwnership() public virtual {\\n        if (msg.sender != pendingOwner()) revert(\\\"OnlyPendingOwner\\\");\\n        _setOwner(pendingOwner());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Sets the new owner and emits the corresponding event.\\n     */\\n    function _setOwner(address newOwner) private {\\n        if (_owner == newOwner) revert(\\\"OwnerDidNotChange\\\");\\n\\n        _owner = newOwner;\\n        emit OwnershipTransferred(newOwner);\\n\\n        if (_pendingOwner != address(0)) {\\n            _setPendingOwner(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the new pending owner and emits the corresponding event.\\n     */\\n    function _setPendingOwner(address newPendingOwner) private {\\n        if (_pendingOwner == newPendingOwner) revert(\\\"PendingOwnerDidNotChange\\\");\\n\\n        _pendingOwner = newPendingOwner;\\n        emit OwnershipPending(newPendingOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPriceProvidersRepository\",\"name\":\"_priceProvidersRepository\",\"type\":\"address\"},{\"internalType\":\"contract IVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_periodForAvgPrice\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"period\",\"type\":\"uint32\"}],\"name\":\"NewPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"ago\",\"type\":\"uint32\"}],\"name\":\"NewSecondsAgo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"PoolForAsset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"assetSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetsPools\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"token0isAsset\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_period\",\"type\":\"uint32\"}],\"name\":\"changePeriodForAvgPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_ago\",\"type\":\"uint32\"}],\"name\":\"changeSecondsAgo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_period\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_ago\",\"type\":\"uint32\"}],\"name\":\"changeSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"getPoolQuoteLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodForAvgPrice\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"priceBufferReady\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceProviderPing\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceProvidersRepository\",\"outputs\":[{\"internalType\":\"contract IPriceProvidersRepository\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removePendingOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"resolvePoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsAgo\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"setupAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"transferPendingOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"verifyPool\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BalancerV2ForLiquidation", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a40111994f44c8add82ef495269e19109c9a982a000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c80000000000000000000000000000000000000000000000000000000000000708", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}