{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SpoolLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces/ISpoolLens.sol\\\";\\nimport \\\"./interfaces/IAssetGroupRegistry.sol\\\";\\nimport \\\"./interfaces/IDepositManager.sol\\\";\\nimport \\\"./interfaces/IMasterWallet.sol\\\";\\nimport \\\"./interfaces/IRiskManager.sol\\\";\\nimport \\\"./interfaces/ISmartVaultManager.sol\\\";\\nimport \\\"./interfaces/IStrategy.sol\\\";\\nimport \\\"./interfaces/IStrategyRegistry.sol\\\";\\nimport \\\"./interfaces/IUsdPriceFeedManager.sol\\\";\\nimport \\\"./interfaces/IWithdrawalManager.sol\\\";\\nimport \\\"./interfaces/CommonErrors.sol\\\";\\nimport \\\"./interfaces/Constants.sol\\\";\\nimport \\\"./interfaces/IAllocationProvider.sol\\\";\\nimport \\\"./access/SpoolAccessControllable.sol\\\";\\n\\n/// @notice Used when strategies length is 0 or more than the cap.\\nerror BadStrategieslength(uint256 length);\\n\\ncontract SpoolLens is ISpoolLens, SpoolAccessControllable {\\n    /// @notice Spool access control manager.\\n    ISpoolAccessControl public immutable accessControl;\\n\\n    /// @notice Smart vault deposit manager\\n    IDepositManager public immutable depositManager;\\n\\n    /// @notice Smart vault withdrawal manager\\n    IWithdrawalManager public immutable withdrawalManager;\\n\\n    /// @notice Strategy registry\\n    IStrategyRegistry public immutable strategyRegistry;\\n\\n    /// @notice Asset Group registry\\n    IAssetGroupRegistry public immutable assetGroupRegistry;\\n\\n    /// @notice Risk manager\\n    IRiskManager public immutable riskManager;\\n\\n    /// @notice Master wallet\\n    IMasterWallet public immutable masterWallet;\\n\\n    /// @notice Price feed manager\\n    IUsdPriceFeedManager public immutable priceFeedManager;\\n\\n    /// @notice Smart vault manager\\n    ISmartVaultManager public immutable smartVaultManager;\\n\\n    address public immutable ghostStrategy;\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    constructor(\\n        ISpoolAccessControl accessControl_,\\n        IAssetGroupRegistry assetGroupRegistry_,\\n        IRiskManager riskManager_,\\n        IDepositManager depositManager_,\\n        IWithdrawalManager withdrawalManager_,\\n        IStrategyRegistry strategyRegistry_,\\n        IMasterWallet masterWallet_,\\n        IUsdPriceFeedManager priceFeedManager_,\\n        ISmartVaultManager smartVaultManager_,\\n        address ghostStrategy_\\n    ) SpoolAccessControllable(accessControl_) {\\n        if (address(assetGroupRegistry_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(riskManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(depositManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(withdrawalManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(strategyRegistry_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(masterWallet_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(priceFeedManager_) == address(0)) revert ConfigurationAddressZero();\\n        if (address(smartVaultManager_) == address(0)) revert ConfigurationAddressZero();\\n\\n        accessControl = accessControl_;\\n        assetGroupRegistry = assetGroupRegistry_;\\n        riskManager = riskManager_;\\n        depositManager = depositManager_;\\n        withdrawalManager = withdrawalManager_;\\n        strategyRegistry = strategyRegistry_;\\n        masterWallet = masterWallet_;\\n        priceFeedManager = priceFeedManager_;\\n        smartVaultManager = smartVaultManager_;\\n        ghostStrategy = ghostStrategy_;\\n    }\\n\\n    /**\\n     * @notice Retrieves a Smart Vault Token Balance for user. Including the predicted balance from all current D-NFTs\\n     * currently in holding.\\n     */\\n    function getUserSVTBalance(address smartVault, address user, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256 currentBalance)\\n    {\\n        currentBalance = ISmartVault(smartVault).balanceOf(user);\\n\\n        if (accessControl.smartVaultOwner(smartVault) == user) {\\n            (,, uint256 fees,) = smartVaultManager.simulateSync(smartVault);\\n            currentBalance += fees;\\n        }\\n\\n        if (nftIds.length > 0) {\\n            currentBalance += smartVaultManager.simulateSyncWithBurn(smartVault, user, nftIds);\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves user balances of smart vault tokens for each NFT.\\n     * @param smartVault Smart vault.\\n     * @param user User to check.\\n     * @param nftIds user's NFTs (only D-NFTs, system will ignore W-NFTs)\\n     * @return nftSvts SVT balance of each user D-NFT for smart vault.\\n     */\\n    function getUserSVTsfromNFTs(address smartVault, address user, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256[] memory nftSvts)\\n    {\\n        nftSvts = new uint256[](nftIds.length);\\n        for (uint256 i; i < nftSvts.length; ++i) {\\n            uint256[] memory nftId = new uint256[](1);\\n            nftId[0] = nftIds[i];\\n            nftSvts[i] = smartVaultManager.simulateSyncWithBurn(smartVault, user, nftId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves total supply of SVTs.\\n     * Includes deposits that were processed by DHW, but still need SVTs to be minted.\\n     * @param smartVault Smart Vault address.\\n     * @return totalSupply Simulated total supply.\\n     */\\n    function getSVTTotalSupply(address smartVault) external view returns (uint256) {\\n        (uint256 currentSupply, uint256 mintedSVTs, uint256 fees,) = smartVaultManager.simulateSync(smartVault);\\n        return currentSupply + mintedSVTs + fees;\\n    }\\n\\n    /**\\n     * @notice Calculate strategy allocations for a Smart Vault\\n     * @param strategies Array of strategies to calculate allocations for\\n     * @param riskProvider Address of the risk provider\\n     * @param allocationProvider Address of the allocation provider\\n     * @return allocations Array of allocations for each strategy\\n     */\\n    function getSmartVaultAllocations(address[] calldata strategies, address riskProvider, address allocationProvider)\\n        external\\n        view\\n        returns (uint256[][] memory allocations)\\n    {\\n        _checkRole(ROLE_ALLOCATION_PROVIDER, allocationProvider);\\n        _checkRole(ROLE_RISK_PROVIDER, riskProvider);\\n\\n        if (strategies.length == 0 || strategies.length > STRATEGY_COUNT_CAP) {\\n            revert BadStrategieslength(strategies.length);\\n        }\\n\\n        uint256 assetGroupId = IStrategy(strategies[0]).assetGroupId();\\n        for (uint256 i; i < strategies.length; ++i) {\\n            _checkRole(ROLE_STRATEGY, strategies[i]);\\n\\n            if (assetGroupId != IStrategy(strategies[i]).assetGroupId()) {\\n                revert NotSameAssetGroup();\\n            }\\n        }\\n\\n        allocations = new uint256[][](21);\\n\\n        int256[] memory apyList = strategyRegistry.strategyAPYs(strategies);\\n        uint8[] memory riskScores = riskManager.getRiskScores(riskProvider, strategies);\\n\\n        unchecked {\\n            for (uint8 i; i < allocations.length; ++i) {\\n                int8 riskTolerance = int8(i) - 10;\\n                allocations[i] = IAllocationProvider(allocationProvider).calculateAllocation(\\n                    AllocationCalculationInput({\\n                        strategies: strategies,\\n                        apys: apyList,\\n                        riskScores: riskScores,\\n                        riskTolerance: riskTolerance\\n                    })\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns smart vault balances in the underlying assets.\\n     * @dev Should be just used as a view to show balances.\\n     * @param smartVault Smart vault.\\n     * @param doFlush Flush vault before calculation.\\n     * @return balances Array of balances for each asset.\\n     */\\n    function getSmartVaultAssetBalances(address smartVault, bool doFlush)\\n        external\\n        returns (uint256[] memory balances)\\n    {\\n        if (doFlush) {\\n            smartVaultManager.flushSmartVault(smartVault);\\n        }\\n\\n        smartVaultManager.syncSmartVault(smartVault, false);\\n\\n        uint256 assetsLength = assetGroupRegistry.assetGroupLength(smartVaultManager.assetGroupId(smartVault));\\n        balances = new uint256[](assetsLength);\\n\\n        address[] memory smartVaultStrategies = smartVaultManager.strategies(smartVault);\\n\\n        for (uint256 i; i < smartVaultStrategies.length; ++i) {\\n            if (ghostStrategy == smartVaultStrategies[i]) {\\n                continue;\\n            }\\n\\n            IStrategy strategy = IStrategy(smartVaultStrategies[i]);\\n\\n            uint256 strategySupply = strategy.totalSupply();\\n            if (strategySupply == 0) {\\n                continue;\\n            }\\n\\n            uint256 smartVaultBalance = strategy.balanceOf(smartVault);\\n            uint256[] memory amounts = strategy.getUnderlyingAssetAmounts();\\n\\n            for (uint256 j; j < balances.length; ++j) {\\n                balances[j] += (amounts[j] * smartVaultBalance) / strategySupply;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISpoolLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\ninterface ISpoolLens {\\n    /**\\n     * @notice Retrieves user balance of smart vault tokens.\\n     * @param smartVault Smart vault.\\n     * @param user User to check.\\n     * @param nftIds user's NFTs (only D-NFTs, system will ignore W-NFTs)\\n     * @return currentBalance SVT balance of user for smart vault.\\n     */\\n    function getUserSVTBalance(address smartVault, address user, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256 currentBalance);\\n\\n    /**\\n     * @notice Retrieves user balances of smart vault tokens for each NFT.\\n     * @param smartVault Smart vault.\\n     * @param user User to check.\\n     * @param nftIds user's NFTs (only D-NFTs, system will ignore W-NFTs)\\n     * @return nftSvts SVT balance of each user D-NFT for smart vault.\\n     */\\n    function getUserSVTsfromNFTs(address smartVault, address user, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256[] memory nftSvts);\\n\\n    /**\\n     * @notice Retrieves total supply of SVTs.\\n     * Includes deposits that were processed by DHW, but still need SVTs to be minted.\\n     * @param smartVault Smart Vault address.\\n     * @return totalSupply Simulated total supply.\\n     */\\n    function getSVTTotalSupply(address smartVault) external view returns (uint256);\\n\\n    /**\\n     * @notice Calculate strategy allocations for a Smart Vault.\\n     * @param strategies Array of strategies to calculate allocations for.\\n     * @param riskProvider Address of the risk provider.\\n     * @param allocationProvider Address of the allocation provider.\\n     * @return allocations Array of allocations for each strategy.\\n     */\\n    function getSmartVaultAllocations(address[] calldata strategies, address riskProvider, address allocationProvider)\\n        external\\n        view\\n        returns (uint256[][] memory allocations);\\n\\n    /**\\n     * @notice Returns smart vault balances in the underlying assets.\\n     * @dev Should be just used as a view to show balances.\\n     * @param smartVault Smart vault.\\n     * @param doFlush Flush vault before calculation.\\n     * @return balances Array of balances for each asset.\\n     */\\n    function getSmartVaultAssetBalances(address smartVault, bool doFlush)\\n        external\\n        returns (uint256[] memory balances);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAssetGroupRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when invalid ID for asset group is provided.\\n * @param assetGroupId Invalid ID for asset group.\\n */\\nerror InvalidAssetGroup(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when no assets are provided for an asset group.\\n */\\nerror NoAssetsProvided();\\n\\n/**\\n * @notice Used when token is not allowed to be used as an asset.\\n * @param token Address of the token that is not allowed.\\n */\\nerror TokenNotAllowed(address token);\\n\\n/**\\n * @notice Used when asset group already exists.\\n * @param assetGroupId ID of the already existing asset group.\\n */\\nerror AssetGroupAlreadyExists(uint256 assetGroupId);\\n\\n/**\\n * @notice Used when given array is unsorted.\\n */\\nerror UnsortedArray();\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IAssetGroupRegistry {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when token is allowed to be used as an asset.\\n     * @param token Address of newly allowed token.\\n     */\\n    event TokenAllowed(address indexed token);\\n\\n    /**\\n     * @notice Emitted when asset group is registered.\\n     * @param assetGroupId ID of the newly registered asset group.\\n     */\\n    event AssetGroupRegistered(uint256 indexed assetGroupId);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if token is allowed to be used as an asset.\\n     * @param token Address of token to check.\\n     * @return isAllowed True if token is allowed, false otherwise.\\n     */\\n    function isTokenAllowed(address token) external view returns (bool isAllowed);\\n\\n    /**\\n     * @notice Gets number of registered asset groups.\\n     * @return count Number of registered asset groups.\\n     */\\n    function numberOfAssetGroups() external view returns (uint256 count);\\n\\n    /**\\n     * @notice Gets asset group by its ID.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return assets Array of assets in the asset group.\\n     */\\n    function listAssetGroup(uint256 assetGroupId) external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets asset group length.\\n     * @dev Requirements:\\n     * - must provide a valid ID for the asset group\\n     * @return length\\n     */\\n    function assetGroupLength(uint256 assetGroupId) external view returns (uint256 length);\\n\\n    /**\\n     * @notice Validates that provided ID represents an asset group.\\n     * @dev Function reverts when ID does not represent an asset group.\\n     * @param assetGroupId ID to validate.\\n     */\\n    function validateAssetGroup(uint256 assetGroupId) external view;\\n\\n    /**\\n     * @notice Checks if asset group composed of assets already exists.\\n     * Will revert if provided assets cannot form an asset group.\\n     * @param assets Assets composing the asset group.\\n     * @return Asset group ID if such asset group exists, 0 otherwise.\\n     */\\n    function checkAssetGroupExists(address[] calldata assets) external view returns (uint256);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Allows a token to be used as an asset.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param token Address of token to be allowed.\\n     */\\n    function allowToken(address token) external;\\n\\n    /**\\n     * @notice Allows tokens to be used as assets.\\n     * @dev Requirements:\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param tokens Addresses of tokens to be allowed.\\n     */\\n    function allowTokenBatch(address[] calldata tokens) external;\\n\\n    /**\\n     * @notice Registers a new asset group.\\n     * @dev Requirements:\\n     * - must provide at least one asset\\n     * - all assets must be allowed\\n     * - assets must be sorted\\n     * - such asset group should not exist yet\\n     * - can only be called by the ROLE_SPOOL_ADMIN\\n     * @param assets Array of assets in the asset group.\\n     * @return id Sequential ID assigned to the asset group.\\n     */\\n    function registerAssetGroup(address[] calldata assets) external returns (uint256 id);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDepositManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISmartVault.sol\\\";\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/**\\n * @notice Used when deposited assets are not the same length as underlying assets.\\n */\\nerror InvalidAssetLengths();\\n\\n/**\\n * @notice Used when lengths of NFT id and amount arrays when claiming NFTs don't match.\\n */\\nerror InvalidNftArrayLength();\\n\\n/**\\n * @notice Used when there are no pending deposits to recover.\\n * E.g., they were already recovered or flushed.\\n */\\nerror NoDepositsToRecover();\\n\\n/**\\n * @notice Used when trying to recover pending deposits from a smart vault that has non-ghost strategies.\\n */\\nerror NotGhostVault();\\n\\n/**\\n * @notice Gathers input for depositing assets.\\n * @custom:member smartVault Smart vault for which the deposit is made.\\n * @custom:member assets Amounts of assets being deposited.\\n * @custom:member receiver Receiver of the deposit NFT.\\n * @custom:member referral Referral address.\\n * @custom:member doFlush If true, the smart vault will be flushed after the deposit as part of same transaction.\\n */\\nstruct DepositBag {\\n    address smartVault;\\n    uint256[] assets;\\n    address receiver;\\n    address referral;\\n    bool doFlush;\\n}\\n\\n/**\\n * @notice Gathers extra input for depositing assets.\\n * @custom:member depositor Address making the deposit.\\n * @custom:member tokens Tokens of the smart vault.\\n * @custom:member strategies Strategies of the smart vault.\\n * @custom:member allocations Set allocation of funds between strategies.\\n * @custom:member flushIndex Current flush index of the smart vault.\\n */\\nstruct DepositExtras {\\n    address depositor;\\n    address[] tokens;\\n    address[] strategies;\\n    uint16a16 allocations;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Gathers minted SVTs for a specific fee type.\\n * @custom:member depositFees Minted SVTs for deposit fees.\\n * @custom:member performanceFees Minted SVTs for performance fees.\\n * @custom:member managementFees Minted SVTs for management fees.\\n */\\nstruct SmartVaultFeesCollected {\\n    uint256 depositFees;\\n    uint256 performanceFees;\\n    uint256 managementFees;\\n}\\n\\n/**\\n * @notice Gathers return values of syncing deposits.\\n * @custom:member mintedSVTs Amount of SVTs minted.\\n * @custom:member dhwTimestamp Timestamp of the last DHW synced.\\n * @custom:member feeSVTs Amount of SVTs minted as fees.\\n * @custom:member feesCollected Breakdown of amount of SVTs minted as fees.\\n * @custom:member initialLockedSVTs Amount of initial locked SVTs.\\n * @custom:member sstShares Amount of SSTs claimed for each strategy.\\n */\\nstruct DepositSyncResult {\\n    uint256 mintedSVTs;\\n    uint256 dhwTimestamp;\\n    uint256 feeSVTs;\\n    SmartVaultFeesCollected feesCollected;\\n    uint256 initialLockedSVTs;\\n    uint256[] sstShares;\\n}\\n\\n/**\\n * @custom:member smartVault Smart Vault address\\n * @custom:member bag flush index, lastDhwSyncedTimestamp\\n * @custom:member strategies strategy addresses\\n * @custom:member assetGroup vault asset group token addresses\\n * @custom:member dhwIndexes DHW Indexes for given flush index\\n * @custom:member dhwIndexesOld DHW Indexes for previous flush index\\n * @custom:member fees smart vault fee configuration\\n * @return syncResult Result of the smart vault sync.\\n */\\nstruct SimulateDepositParams {\\n    address smartVault;\\n    // bag[0]: flushIndex,\\n    // bag[1]: lastDhwSyncedTimestamp,\\n    uint256[2] bag;\\n    address[] strategies;\\n    address[] assetGroup;\\n    uint16a16 dhwIndexes;\\n    uint16a16 dhwIndexesOld;\\n    SmartVaultFees fees;\\n}\\n\\ninterface IDepositManager {\\n    /**\\n     * @notice User redeemed deposit NFTs for SVTs\\n     * @param smartVault Smart vault address\\n     * @param claimer Claimer address\\n     * @param claimedVaultTokens Amount of SVTs claimed\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     */\\n    event SmartVaultTokensClaimed(\\n        address indexed smartVault,\\n        address indexed claimer,\\n        uint256 claimedVaultTokens,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param receiver Beneficiary of the deposit\\n     * @param depositId Deposit NFT ID for this deposit\\n     * @param flushIndex Flush index the deposit was scheduled for\\n     * @param assets Amount of assets to deposit\\n     * @param depositor Address that initiated the deposit\\n     * @param referral Referral address\\n     */\\n    event DepositInitiated(\\n        address indexed smartVault,\\n        address indexed receiver,\\n        uint256 indexed depositId,\\n        uint256 flushIndex,\\n        uint256[] assets,\\n        address depositor,\\n        address referral\\n    );\\n\\n    /**\\n     * @notice Pending deposits were recovered.\\n     * @param smartVault Smart vault address.\\n     * @param recoveredAssets Amount of assets recovered.\\n     */\\n    event PendingDepositsRecovered(address indexed smartVault, uint256[] recoveredAssets);\\n\\n    /**\\n     * @notice Smart vault fees collected.\\n     * @param smartVault Smart vault address.\\n     * @param smartVaultFeesCollected Collected smart vault fee amounts.\\n     */\\n    event SmartVaultFeesMinted(address indexed smartVault, SmartVaultFeesCollected smartVaultFeesCollected);\\n\\n    /**\\n     * @notice Simulate vault synchronization (i.e. DHW was completed, but vault wasn't synced yet)\\n     */\\n    function syncDepositsSimulate(SimulateDepositParams calldata parameters)\\n        external\\n        view\\n        returns (DepositSyncResult memory syncResult);\\n\\n    /**\\n     * @notice Synchronize vault deposits for completed DHW runs\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param bag flushIndex, lastDhwSyncedTimestamp\\n     * @param strategies vault strategy addresses\\n     * @param dhwIndexes dhw indexes for given and previous flushIndex\\n     * @param assetGroup vault asset group token addresses\\n     * @param fees smart vault fee configuration\\n     * @return syncResult Result of the smart vault sync.\\n     */\\n    function syncDeposits(\\n        address smartVault,\\n        uint256[2] calldata bag,\\n        // uint256 flushIndex,\\n        // uint256 lastDhwSyncedTimestamp\\n        address[] calldata strategies,\\n        uint16a16[2] calldata dhwIndexes,\\n        address[] calldata assetGroup,\\n        SmartVaultFees calldata fees\\n    ) external returns (DepositSyncResult memory syncResult);\\n\\n    /**\\n     * @notice Adds deposits for the next flush cycle.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param bag Deposit parameters.\\n     * @param bag2 Extra parameters.\\n     * @return nftId ID of the deposit NFT.\\n     */\\n    function depositAssets(DepositBag calldata bag, DepositExtras calldata bag2) external returns (uint256 nftId);\\n\\n    /**\\n     * @notice Mark deposits ready to be processed in the next DHW cycle\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param flushIndex index to flush\\n     * @param strategies vault strategy addresses\\n     * @param allocations vault strategy allocations\\n     * @param tokens vault asset group token addresses\\n     * @return dhwIndexes DHW indexes in which the deposits will be included\\n     */\\n    function flushSmartVault(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        uint16a16 allocations,\\n        address[] calldata tokens\\n    ) external returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Get the number of SVTs that are available, but haven't been claimed yet, for the given NFT\\n     * @param smartVaultAddress Smart Vault address\\n     * @param data NFT deposit NFT metadata\\n     * @param nftShares amount of NFT shares to burn for SVTs\\n     * @param mintedSVTs amount of SVTs minted for this flush\\n     * @param tokens vault asset group addresses\\n     */\\n    function getClaimedVaultTokensPreview(\\n        address smartVaultAddress,\\n        DepositMetadata memory data,\\n        uint256 nftShares,\\n        uint256 mintedSVTs,\\n        address[] calldata tokens\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Fetch assets deposited in a given vault flush\\n     */\\n    function smartVaultDeposits(address smartVault, uint256 flushIdx, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice Claim SVTs by burning deposit NFTs.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart Vault address\\n     * @param nftIds NFT ids to burn\\n     * @param nftAmounts NFT amounts to burn (support for partial burn)\\n     * @param tokens vault asset group token addresses\\n     * @param owner address owning NFTs\\n     * @param executor address executing the claim transaction\\n     * @param flushIndexToSync next flush index to sync for the smart vault\\n     * @return claimedTokens Amount of smart vault tokens claimed.\\n     */\\n    function claimSmartVaultTokens(\\n        address smartVault,\\n        uint256[] calldata nftIds,\\n        uint256[] calldata nftAmounts,\\n        address[] calldata tokens,\\n        address owner,\\n        address executor,\\n        uint256 flushIndexToSync\\n    ) external returns (uint256 claimedTokens);\\n\\n    /**\\n     * @notice Recovers pending deposits from smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault from which to recover pending deposits.\\n     * @param flushIndex Flush index for which to recover pending deposits.\\n     * @param strategies Addresses of smart vault's strategies.\\n     * @param tokens Asset group token addresses.\\n     * @param emergencyWallet Address of emergency withdraw wallet.\\n     */\\n    function recoverPendingDeposits(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        address[] calldata tokens,\\n        address emergencyWallet\\n    ) external;\\n\\n    /**\\n     * @notice Gets current required deposit ratio of a smart vault.\\n     * @param tokens Asset tokens of the smart vault.\\n     * @param allocations Allocation between strategies of the smart vault.\\n     * @param strategies Strategies of the smart vault.\\n     * @return ratio Required deposit ratio of the smart vault.\\n     */\\n    function getDepositRatio(address[] memory tokens, uint16a16 allocations, address[] memory strategies)\\n        external\\n        view\\n        returns (uint256[] memory ratio);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMasterWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMasterWallet {\\n    /**\\n     * @notice Transfers amount of token to the recipient.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_MASTER_WALLET_MANAGER\\n     * @param token Token to transfer.\\n     * @param recipient Target of the transfer.\\n     * @param amount Amount to transfer.\\n     */\\n    function transfer(IERC20 token, address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRiskManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\nerror InvalidRiskInputLength();\\nerror RiskScoreValueOutOfBounds(uint8 value);\\nerror RiskToleranceValueOutOfBounds(int8 value);\\nerror CannotSetRiskScoreForGhostStrategy(uint8 riskScore);\\nerror InvalidAllocationSum(uint256 allocationsSum);\\nerror InvalidRiskScores(address riskProvider, address strategy);\\n\\ninterface IRiskManager {\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Calculates allocation between strategies based on\\n     * - risk scores of strategies\\n     * - risk appetite\\n     * @param smartVault Smart vault address.\\n     * @param strategies Strategies.\\n     * @return allocation Calculated allocation.\\n     */\\n    function calculateAllocation(address smartVault, address[] calldata strategies)\\n        external\\n        view\\n        returns (uint16a16 allocation);\\n\\n    /**\\n     * @notice Gets risk scores for strategies.\\n     * @param riskProvider Requested risk provider.\\n     * @param strategy Strategies.\\n     * @return riskScores Risk scores for strategies.\\n     */\\n    function getRiskScores(address riskProvider, address[] memory strategy)\\n        external\\n        view\\n        returns (uint8[] memory riskScores);\\n\\n    /**\\n     * @notice Gets configured risk provider for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return riskProvider Risk provider for the smart vault.\\n     */\\n    function getRiskProvider(address smartVault) external view returns (address riskProvider);\\n\\n    /**\\n     * @notice Gets configured allocation provider for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return allocationProvider Allocation provider for the smart vault.\\n     */\\n    function getAllocationProvider(address smartVault) external view returns (address allocationProvider);\\n\\n    /**\\n     * @notice Gets configured risk tolerance for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return riskTolerance Risk tolerance for the smart vault.\\n     */\\n    function getRiskTolerance(address smartVault) external view returns (int8 riskTolerance);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Sets risk provider for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - risk provider must have role ROLE_RISK_PROVIDER\\n     * @param smartVault Smart vault.\\n     * @param riskProvider_ Risk provider to set.\\n     */\\n    function setRiskProvider(address smartVault, address riskProvider_) external;\\n\\n    /**\\n     * @notice Sets allocation provider for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - allocation provider must have role ROLE_ALLOCATION_PROVIDER\\n     * @param smartVault Smart vault.\\n     * @param allocationProvider Allocation provider to set.\\n     */\\n    function setAllocationProvider(address smartVault, address allocationProvider) external;\\n\\n    /**\\n     * @notice Sets risk scores for strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_RISK_PROVIDER\\n     * @param riskScores Risk scores to set for strategies.\\n     * @param strategies Strategies for which to set risk scores.\\n     */\\n    function setRiskScores(uint8[] calldata riskScores, address[] calldata strategies) external;\\n\\n    /**\\n     * @notice Sets risk tolerance for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * - risk tolerance must be within valid bounds\\n     * @param smartVault Smart vault.\\n     * @param riskTolerance Risk tolerance to set.\\n     */\\n    function setRiskTolerance(address smartVault, int8 riskTolerance) external;\\n\\n    /**\\n     * @notice Risk scores updated\\n     * @param riskProvider risk provider address\\n     * @param strategies strategy addresses\\n     * @param riskScores risk score values\\n     */\\n    event RiskScoresUpdated(address indexed riskProvider, address[] strategies, uint8[] riskScores);\\n\\n    /**\\n     * @notice Smart vault risk provider set\\n     * @param smartVault Smart vault address\\n     * @param riskProvider New risk provider address\\n     */\\n    event RiskProviderSet(address indexed smartVault, address indexed riskProvider);\\n\\n    /**\\n     * @notice Smart vault allocation provider set\\n     * @param smartVault Smart vault address\\n     * @param allocationProvider New allocation provider address\\n     */\\n    event AllocationProviderSet(address indexed smartVault, address indexed allocationProvider);\\n\\n    /**\\n     * @notice Smart vault risk appetite\\n     * @param smartVault Smart vault address\\n     * @param riskTolerance risk appetite value\\n     */\\n    event RiskToleranceSet(address indexed smartVault, int8 riskTolerance);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISmartVaultManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./IDepositManager.sol\\\";\\nimport \\\"./ISmartVault.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IWithdrawalManager.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when user has insufficient balance for redeemal of shares.\\n */\\nerror InsufficientBalance(uint256 available, uint256 required);\\n\\n/**\\n * @notice Used when there is nothing to flush.\\n */\\nerror NothingToFlush();\\n\\n/**\\n * @notice Used when trying to register a smart vault that was already registered.\\n */\\nerror SmartVaultAlreadyRegistered();\\n\\n/**\\n * @notice Used when trying to perform an action for smart vault that was not registered yet.\\n */\\nerror SmartVaultNotRegisteredYet();\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large management fee.\\n */\\nerror ManagementFeeTooLarge(uint256 mgmtFeePct);\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large performance fee.\\n */\\nerror PerformanceFeeTooLarge(uint256 performanceFeePct);\\n\\n/**\\n * @notice Used when smart vault in reallocation has statically set allocation.\\n */\\nerror StaticAllocationSmartVault();\\n\\n/**\\n * @notice Used when user tries to configure a vault with too large deposit fee.\\n */\\nerror DepositFeeTooLarge(uint256 depositFeePct);\\n\\n/**\\n * @notice Used when user tries redeem on behalf of another user, but the vault does not support it\\n */\\nerror RedeemForNotAllowed();\\n\\n/**\\n * @notice Used when trying to flush a vault that still needs to be synced.\\n */\\nerror VaultNotSynced();\\n\\n/**\\n * @notice Used when trying to deposit into, redeem from, or flush a smart vault that has only ghost strategies.\\n */\\nerror GhostVault();\\n\\n/**\\n * @notice Used when reallocation is called with expired parameters.\\n */\\nerror ReallocationParametersExpired();\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Struct holding all data for registration of smart vault.\\n * @custom:member assetGroupId Underlying asset group of the smart vault.\\n * @custom:member strategies Strategies used by the smart vault.\\n * @custom:member strategyAllocation Optional. If empty array, values will be calculated on the spot.\\n * @custom:member managementFeePct Management fee of the smart vault.\\n * @custom:member depositFeePct Deposit fee of the smart vault.\\n * @custom:member performanceFeePct Performance fee of the smart vault.\\n */\\nstruct SmartVaultRegistrationForm {\\n    uint256 assetGroupId;\\n    address[] strategies;\\n    uint16a16 strategyAllocation;\\n    uint16 managementFeePct;\\n    uint16 depositFeePct;\\n    uint16 performanceFeePct;\\n}\\n\\n/**\\n * @notice Parameters for reallocation.\\n * @custom:member smartVaults Smart vaults to reallocate.\\n * @custom:member strategies Set of strategies involved in the reallocation. Should not include ghost strategy, even if some smart vault uses it.\\n * @custom:member swapInfo Information for swapping assets before depositing into the protocol.\\n * @custom:member depositSlippages Slippages used to constrain depositing into the protocol.\\n * @custom:member withdrawalSlippages Slippages used to contrain withdrawal from the protocol.\\n * @custom:member exchangeRateSlippages Slippages used to constratrain exchange rates for asset tokens.\\n * @custom:member validUntil Sets the maximum timestamp the user is willing to wait to start executing reallocation.\\n */\\nstruct ReallocateParamBag {\\n    address[] smartVaults;\\n    address[] strategies;\\n    SwapInfo[][] swapInfo;\\n    uint256[][] depositSlippages;\\n    uint256[][] withdrawalSlippages;\\n    uint256[2][] exchangeRateSlippages;\\n    uint256 validUntil;\\n}\\n\\nstruct FlushIndex {\\n    uint128 current;\\n    uint128 toSync;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISmartVaultRegistry {\\n    /**\\n     * @notice Registers smart vault into the Spool protocol.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_INTEGRATOR\\n     * @param smartVault Smart vault to register.\\n     * @param registrationForm Form with information for registration.\\n     */\\n    function registerSmartVault(address smartVault, SmartVaultRegistrationForm calldata registrationForm) external;\\n}\\n\\ninterface ISmartVaultManager is ISmartVaultRegistry {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets do-hard-work indexes.\\n     * @param smartVault Smart vault.\\n     * @param flushIndex Flush index.\\n     * @return dhwIndexes Do-hard-work indexes for flush index of the smart vault.\\n     */\\n    function dhwIndexes(address smartVault, uint256 flushIndex) external view returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Gets latest flush index for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return flushIndex Latest flush index for the smart vault.\\n     */\\n    function getLatestFlushIndex(address smartVault) external view returns (uint256 flushIndex);\\n\\n    /**\\n     * @notice Gets strategy allocation for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return allocation Strategy allocation for the smart vault.\\n     */\\n    function allocations(address smartVault) external view returns (uint16a16 allocation);\\n\\n    /**\\n     * @notice Gets strategies used by a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return strategies Strategies for the smart vault.\\n     */\\n    function strategies(address smartVault) external view returns (address[] memory strategies);\\n\\n    /**\\n     * @notice Gets asest group used by a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return assetGroupId ID of the asset group used by the smart vault.\\n     */\\n    function assetGroupId(address smartVault) external view returns (uint256 assetGroupId);\\n\\n    /**\\n     * @notice Gets required deposit ratio for a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return ratio Required deposit ratio for the smart vault.\\n     */\\n    function depositRatio(address smartVault) external view returns (uint256[] memory ratio);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Flushes deposits and withdrawal for the next do-hard-work.\\n     * @param smartVault Smart vault to flush.\\n     */\\n    function flushSmartVault(address smartVault) external;\\n\\n    /**\\n     * @notice Reallocates smart vaults.\\n     * @dev Requirements:\\n     * - caller must have a ROLE_REALLOCATOR role\\n     * - smart vaults must be registered\\n     * - smart vaults must use same asset group\\n     * - strategies must represent a set of strategies used by smart vaults\\n     * @param reallocateParams Paramaters for reallocation.\\n     */\\n    function reallocate(ReallocateParamBag calldata reallocateParams) external;\\n\\n    /**\\n     * @notice Removes strategy from vaults, and optionally removes it from the system as well.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * - the strategy has to be active (requires ROLE_STRATEGY)\\n     * @param strategy Strategy address to remove.\\n     * @param vaults Array of vaults from which to remove the strategy\\n     * @param disableStrategy Also disable the strategy across the system\\n     */\\n    function removeStrategyFromVaults(address strategy, address[] calldata vaults, bool disableStrategy) external;\\n\\n    /**\\n     * @notice Syncs smart vault with strategies.\\n     * @param smartVault Smart vault to sync.\\n     * @param revertIfError If true, sync will revert if every flush index cannot be synced; if false it will sync all flush indexes it can.\\n     */\\n    function syncSmartVault(address smartVault, bool revertIfError) external;\\n\\n    /**\\n     * @dev Calculate number of SVTs that haven't been synced yet after DHW runs\\n     * DHW has minted strategy shares, but vaults haven't claimed them yet.\\n     * Includes management fees (percentage of assets under management, distributed throughout a year) and deposit fees .\\n     * Invariants:\\n     * - There can't be more than once un-synced flush index per vault at any given time.\\n     * - Flush index can't be synced, if all DHWs haven't been completed yet.\\n     *\\n     * Can be used to retrieve the number of SSTs the vault would claim during sync.\\n     * @param smartVault SmartVault address\\n     * @return oldTotalSVTs Amount of SVTs before sync\\n     * @return mintedSVTs Amount of SVTs minted during sync\\n     * @return feeSVTs Amount of SVTs pertaining to fees\\n     * @return sstShares Amount of SSTs claimed per strategy\\n     */\\n    function simulateSync(address smartVault)\\n        external\\n        view\\n        returns (uint256 oldTotalSVTs, uint256 mintedSVTs, uint256 feeSVTs, uint256[] calldata sstShares);\\n\\n    /**\\n     * @dev Simulate sync when burning dNFTs and return their svts value.\\n     *\\n     * @param smartVault SmartVault address\\n     * @param userAddress User address that owns dNFTs\\n     * @param nftIds Ids of dNFTs\\n     * @return svts Amount of svts user would get if he burns dNFTs\\n     */\\n    function simulateSyncWithBurn(address smartVault, address userAddress, uint256[] calldata nftIds)\\n        external\\n        view\\n        returns (uint256 svts);\\n\\n    /**\\n     * @notice Instantly redeems smart vault shares for assets.\\n     * @param bag Parameters for fast redeemal.\\n     * @param withdrawalSlippages Slippages guarding redeemal.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemBag calldata bag, uint256[][] calldata withdrawalSlippages)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Simulates redeem fast of smart vault shares.\\n     * @dev Should only be run by address zero to simulate the redeemal and parse logs.\\n     * @param bag Parameters for fast redeemal.\\n     * @param withdrawalSlippages Slippages guarding redeemal.\\n     * @param redeemer Address of a user to simulate redeem for.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFastView(RedeemBag calldata bag, uint256[][] calldata withdrawalSlippages, address redeemer)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Claims withdrawal of assets by burning withdrawal NFT.\\n     * @dev Requirements:\\n     * - withdrawal NFT must be valid\\n     * @param smartVault Address of the smart vault that issued the withdrawal NFT.\\n     * @param nftIds ID of withdrawal NFT to burn.\\n     * @param nftAmounts amounts\\n     * @param receiver Receiver of claimed assets.\\n     * @return assetAmounts Amounts of assets claimed.\\n     * @return assetGroupId ID of the asset group.\\n     */\\n    function claimWithdrawal(\\n        address smartVault,\\n        uint256[] calldata nftIds,\\n        uint256[] calldata nftAmounts,\\n        address receiver\\n    ) external returns (uint256[] memory assetAmounts, uint256 assetGroupId);\\n\\n    /**\\n     * @notice Claims smart vault tokens by burning the deposit NFT.\\n     * @dev Requirements:\\n     * - deposit NFT must be valid\\n     * - flush must be synced\\n     * @param smartVaultAddress Address of the smart vault that issued the deposit NFT.\\n     * @param nftIds ID of the deposit NFT to burn.\\n     * @param nftAmounts amounts\\n     * @return claimedAmount Amount of smart vault tokens claimed.\\n     */\\n    function claimSmartVaultTokens(address smartVaultAddress, uint256[] calldata nftIds, uint256[] calldata nftAmounts)\\n        external\\n        returns (uint256 claimedAmount);\\n\\n    /**\\n     * @notice Initiates a withdrawal process and mints a withdrawal NFT. Once all DHWs are executed, user can\\n     * use the withdrawal NFT to claim the assets.\\n     * Optionally, caller can pass a list of deposit NFTs to unwrap.\\n     * @param bag smart vault address, amount of shares to redeem, nft ids and amounts to burn\\n     * @param receiver address that will receive the withdrawal NFT\\n     * @param doFlush optionally flush the smart vault\\n     * @return receipt ID of the receipt withdrawal NFT.\\n     */\\n    function redeem(RedeemBag calldata bag, address receiver, bool doFlush) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Initiates a withdrawal process and mints a withdrawal NFT. Once all DHWs are executed, user can\\n     * use the withdrawal NFT to claim the assets.\\n     * Optionally, caller can pass a list of deposit NFTs to unwrap.\\n     * @param bag smart vault address, amount of shares to redeem, nft ids and amounts to burn\\n     * @param owner address that owns the shares to be redeemed and will receive the withdrawal NFT\\n     * @param doFlush optionally flush the smart vault\\n     * @return receipt ID of the receipt withdrawal NFT.\\n     */\\n    function redeemFor(RedeemBag calldata bag, address owner, bool doFlush) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Initiated a deposit and mints a deposit NFT. Once all DHWs are executed, user can\\n     * unwrap the deposit NDF and claim his SVTs.\\n     * @param bag smartVault address, assets, NFT receiver address, referral address, doFlush\\n     * @return receipt ID of the receipt deposit NFT.\\n     */\\n    function deposit(DepositBag calldata bag) external returns (uint256 receipt);\\n\\n    /**\\n     * @notice Recovers pending deposits from smart vault to emergency wallet.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * - all strategies of the smart vault need to be ghost strategies\\n     * @param smartVault Smart vault from which to recover pending deposits.\\n     */\\n    function recoverPendingDeposits(address smartVault) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Smart vault has been flushed\\n     * @param smartVault Smart vault address\\n     * @param flushIndex Flush index\\n     */\\n    event SmartVaultFlushed(address indexed smartVault, uint256 flushIndex);\\n\\n    /**\\n     * @notice Smart vault has been synced\\n     * @param smartVault Smart vault address\\n     * @param flushIndex Flush index\\n     */\\n    event SmartVaultSynced(address indexed smartVault, uint256 flushIndex);\\n\\n    /**\\n     * @notice Smart vault has been registered\\n     * @param smartVault Smart vault address\\n     * @param registrationForm Smart vault configuration\\n     */\\n    event SmartVaultRegistered(address indexed smartVault, SmartVaultRegistrationForm registrationForm);\\n\\n    /**\\n     * @notice Strategy was removed from the vault\\n     * @param strategy Strategy address\\n     * @param vault Vault to remove the strategy from\\n     */\\n    event StrategyRemovedFromVault(address indexed strategy, address indexed vault);\\n\\n    /**\\n     * @notice Vault was reallocation executed\\n     * @param smartVault Smart vault address\\n     * @param newAllocations new vault strategy allocations\\n     */\\n    event SmartVaultReallocated(address indexed smartVault, uint16a16 newAllocations);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {PlatformFees} from \\\"./IStrategyRegistry.sol\\\";\\nimport \\\"./ISwapper.sol\\\";\\nimport \\\"./IUsdPriceFeedManager.sol\\\";\\n\\n/**\\n * @notice Struct holding information how to swap the assets.\\n * @custom:member slippage minumum output amount\\n * @custom:member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\n */\\nstruct SwapData {\\n    uint256 slippage; // min amount out\\n    bytes path; // 1st byte is action, then path\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work on strategy.\\n * @custom:member swapInfo Information for swapping assets before depositing into the protocol.\\n * @custom:member swapInfo Information for swapping rewards before depositing them back into the protocol.\\n * @custom:member slippages Slippages used to constrain depositing and withdrawing from the protocol.\\n * @custom:member assetGroup Asset group of the strategy.\\n * @custom:member exchangeRates Exchange rates for assets.\\n * @custom:member withdrawnShares Strategy shares withdrawn by smart vault.\\n * @custom:member masterWallet Master wallet.\\n * @custom:member priceFeedManager Price feed manager.\\n * @custom:member baseYield Base yield value, manual input for specific strategies.\\n * @custom:member platformFees Platform fees info.\\n */\\nstruct StrategyDhwParameterBag {\\n    SwapInfo[] swapInfo;\\n    SwapInfo[] compoundSwapInfo;\\n    uint256[] slippages;\\n    address[] assetGroup;\\n    uint256[] exchangeRates;\\n    uint256 withdrawnShares;\\n    address masterWallet;\\n    IUsdPriceFeedManager priceFeedManager;\\n    int256 baseYield;\\n    PlatformFees platformFees;\\n}\\n\\n/**\\n * @notice Information about results of the do hard work.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member assetsWithdrawn Amount of assets withdrawn.\\n * @custom:member yieldPercentage Yield percentage from the previous DHW.\\n * @custom:member valueAtDhw Value of the strategy at the end of DHW.\\n * @custom:member totalSstsAtDhw Total SSTs at the end of DHW.\\n */\\nstruct DhwInfo {\\n    uint256 sharesMinted;\\n    uint256[] assetsWithdrawn;\\n    int256 yieldPercentage;\\n    uint256 valueAtDhw;\\n    uint256 totalSstsAtDhw;\\n}\\n\\n/**\\n * @notice Used when ghost strategy is called.\\n */\\nerror IsGhostStrategy();\\n\\n/**\\n * @notice Used when user is not allowed to redeem fast.\\n * @param user User that tried to redeem fast.\\n */\\nerror NotFastRedeemer(address user);\\n\\n/**\\n * @notice Used when asset group ID is not correctly initialized.\\n */\\nerror InvalidAssetGroupIdInitialization();\\n\\ninterface IStrategy is IERC20Upgradeable {\\n    /* ========== EVENTS ========== */\\n\\n    event Deposited(\\n        uint256 mintedShares, uint256 usdWorthDeposited, uint256[] assetsBeforeSwap, uint256[] assetsDeposited\\n    );\\n\\n    event Withdrawn(uint256 withdrawnShares, uint256 usdWorthWithdrawn, uint256[] withdrawnAssets);\\n\\n    event PlatformFeesCollected(address indexed strategy, uint256 sharesMinted);\\n\\n    event Slippages(bool isDeposit, uint256 slippage, bytes data);\\n\\n    event BeforeDepositCheckSlippages(uint256[] amounts);\\n\\n    event BeforeRedeemalCheckSlippages(uint256 ssts);\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets strategy name.\\n     * @return name Name of the strategy.\\n     */\\n    function strategyName() external view returns (string memory name);\\n\\n    /**\\n     * @notice Gets required ratio between underlying assets.\\n     * @return ratio Required asset ratio for the strategy.\\n     */\\n    function assetRatio() external view returns (uint256[] memory ratio);\\n\\n    /**\\n     * @notice Gets asset group used by the strategy.\\n     * @return id ID of the asset group.\\n     */\\n    function assetGroupId() external view returns (uint256 id);\\n\\n    /**\\n     * @notice Gets underlying assets for the strategy.\\n     * @return assets Addresses of the underlying assets.\\n     */\\n    function assets() external view returns (address[] memory assets);\\n\\n    /**\\n     * @notice Gets underlying asset amounts for the strategy.\\n     * @return amounts Amounts of the underlying assets.\\n     */\\n    function getUnderlyingAssetAmounts() external view returns (uint256[] memory amounts);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Performs slippages check before depositing.\\n     * @param amounts Amounts to be deposited.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeDepositCheck(uint256[] memory amounts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @dev Performs slippages check before redeemal.\\n     * @param ssts Amount of strategy tokens to be redeemed.\\n     * @param slippages Slippages to check against.\\n     */\\n    function beforeRedeemalCheck(uint256 ssts, uint256[] calldata slippages) external;\\n\\n    /**\\n     * @notice Does hard work:\\n     * - compounds rewards\\n     * - deposits into the protocol\\n     * - withdraws from the protocol\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param dhwParams Parameters for the do hard work.\\n     * @return info Information about do the performed hard work.\\n     */\\n    function doHardWork(StrategyDhwParameterBag calldata dhwParams) external returns (DhwInfo memory info);\\n\\n    /**\\n     * @notice Claims strategy shares after do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault claiming shares.\\n     * @param amount Amount of strategy shares to claim.\\n     */\\n    function claimShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Releases shares back to strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault releasing shares.\\n     * @param amount Amount of strategy shares to release.\\n     */\\n    function releaseShares(address smartVault, uint256 amount) external;\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SMART_VAULT_MANAGER or role ROLE_STRATEGY_REGISTRY\\n     * @param shares Amount of shares to redeem.\\n     * @param masterWallet Address of the master wallet.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemFast(\\n        uint256 shares,\\n        address masterWallet,\\n        address[] calldata assetGroup,\\n        uint256[] calldata slippages\\n    ) external returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @param shares Amount of shares to redeem.\\n     * @param redeemer Address of he redeemer, owner of SSTs.\\n     * @param assetGroup Asset group of the strategy.\\n     * @param slippages Slippages to guard redeeming.\\n     * @return assetsWithdrawn Amount of assets withdrawn.\\n     */\\n    function redeemShares(uint256 shares, address redeemer, address[] calldata assetGroup, uint256[] calldata slippages)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Instantly deposits into the protocol.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param assetGroup Asset group of the strategy.\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     * @param slippages Slippages to guard depositing.\\n     * @param swapInfo Information for swapping assets before depositing into the protocol.\\n     * @return sstsMinted Amount of SSTs minted.\\n     */\\n    function depositFast(\\n        address[] calldata assetGroup,\\n        uint256[] calldata exchangeRates,\\n        IUsdPriceFeedManager priceFeedManager,\\n        uint256[] calldata slippages,\\n        SwapInfo[] calldata swapInfo\\n    ) external returns (uint256 sstsMinted);\\n\\n    /**\\n     * @notice Instantly withdraws assets, bypassing shares mechanism.\\n     * Transfers withdrawn assets to the emergency withdrawal wallet.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_STRATEGY_REGISTRY\\n     * @param slippages Slippages to guard redeeming.\\n     * @param recipient Recipient address\\n     */\\n    function emergencyWithdraw(uint256[] calldata slippages, address recipient) external;\\n\\n    /**\\n     * @notice Gets USD worth of the strategy.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param exchangeRates Asset to USD exchange rates.\\n     * @param priceFeedManager Price feed manager contract.\\n     */\\n    function getUsdWorth(uint256[] memory exchangeRates, IUsdPriceFeedManager priceFeedManager)\\n        external\\n        returns (uint256 usdWorth);\\n\\n    /**\\n     * @notice Gets protocol rewards.\\n     * @dev Requirements:\\n     * - can only be called in view-execution mode.\\n     * @return tokens Addresses of reward tokens.\\n     * @return amounts Amount of reward tokens available.\\n     */\\n    function getProtocolRewards() external returns (address[] memory tokens, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./ISwapper.sol\\\";\\nimport {DhwInfo} from \\\"./IStrategy.sol\\\";\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to register an already registered strategy.\\n * @param address_ Address of already registered strategy.\\n */\\nerror StrategyAlreadyRegistered(address address_);\\n\\n/**\\n * @notice Used when DHW was not run yet for a strategy index.\\n * @param strategy Address of the strategy.\\n * @param strategyIndex Index of the strategy.\\n */\\nerror DhwNotRunYetForIndex(address strategy, uint256 strategyIndex);\\n\\n/**\\n * @notice Used when provided token list is invalid.\\n */\\nerror InvalidTokenList();\\n\\n/**\\n * @notice Used when ghost strategy is used.\\n */\\nerror GhostStrategyUsed();\\n\\n/**\\n * @notice Used when syncing vault that is already fully synced.\\n */\\nerror NothingToSync();\\n\\n/**\\n * @notice Used when system tries to configure a too large ecosystem fee.\\n * @param ecosystemFeePct Requested ecosystem fee.\\n */\\nerror EcosystemFeeTooLarge(uint256 ecosystemFeePct);\\n\\n/**\\n * @notice Used when system tries to configure a too large treasury fee.\\n * @param treasuryFeePct Requested treasury fee.\\n */\\nerror TreasuryFeeTooLarge(uint256 treasuryFeePct);\\n\\n/**\\n * @notice Used when user tries to re-add a strategy that was previously removed from the system.\\n * @param strategy Strategy address\\n */\\nerror StrategyPreviouslyRemoved(address strategy);\\n\\n/**\\n * @notice Represents change of state for a strategy during a DHW.\\n * @custom:member exchangeRates Exchange rates between assets and USD.\\n * @custom:member assetsDeposited Amount of assets deposited into the strategy.\\n * @custom:member sharesMinted Amount of strategy shares minted.\\n * @custom:member totalSSTs Amount of strategy shares at the end of the DHW.\\n * @custom:member totalStrategyValue Total strategy value at the end of the DHW.\\n * @custom:member dhwYields DHW yield percentage from the previous DHW.\\n */\\nstruct StrategyAtIndex {\\n    uint256[] exchangeRates;\\n    uint256[] assetsDeposited;\\n    uint256 sharesMinted;\\n    uint256 totalSSTs;\\n    uint256 totalStrategyValue;\\n    int256 dhwYields;\\n}\\n\\n/**\\n * @notice Parameters for calling do hard work.\\n * @custom:member strategies Strategies to do-hard-worked upon, grouped by their asset group.\\n * @custom:member swapInfo Information for swapping assets before depositing into protocol. SwapInfo[] per each strategy.\\n * @custom:member compoundSwapInfo Information for swapping rewards before depositing them back into the protocol. SwapInfo[] per each strategy.\\n * @custom:member strategySlippages Slippages used to constrain depositing into and withdrawing from the protocol. uint256[] per strategy.\\n * @custom:member baseYields Base yield percentage the strategy created in the DHW period (applicable only for some strategies).\\n * @custom:member tokens List of all asset tokens involved in the do hard work.\\n * @custom:member exchangeRateSlippages Slippages used to constrain exchange rates for asset tokens. uint256[2] for each token.\\n * @custom:member validUntil Sets the maximum timestamp the user is willing to wait to start executing 'do hard work'.\\n */\\nstruct DoHardWorkParameterBag {\\n    address[][] strategies;\\n    SwapInfo[][][] swapInfo;\\n    SwapInfo[][][] compoundSwapInfo;\\n    uint256[][][] strategySlippages;\\n    int256[][] baseYields;\\n    address[] tokens;\\n    uint256[2][] exchangeRateSlippages;\\n    uint256 validUntil;\\n}\\n\\n/**\\n * @notice Parameters for calling redeem fast.\\n * @custom:member strategies Addresses of strategies.\\n * @custom:member strategyShares Amount of shares to redeem.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member slippages Slippages to guard withdrawal.\\n */\\nstruct RedeemFastParameterBag {\\n    address[] strategies;\\n    uint256[] strategyShares;\\n    address[] assetGroup;\\n    uint256[][] withdrawalSlippages;\\n}\\n\\n/**\\n * @notice Group of platform fees.\\n * @custom:member ecosystemFeeReciever Receiver of the ecosystem fees.\\n * @custom:member ecosystemFeePct Ecosystem fees. Expressed in FULL_PERCENT.\\n * @custom:member treasuryFeeReciever Receiver of the treasury fees.\\n * @custom:member treasuryFeePct Treasury fees. Expressed in FULL_PERCENT.\\n */\\nstruct PlatformFees {\\n    address ecosystemFeeReceiver;\\n    uint96 ecosystemFeePct;\\n    address treasuryFeeReceiver;\\n    uint96 treasuryFeePct;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface IStrategyRegistry {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Returns address of emergency withdrawal wallet.\\n     * @return emergencyWithdrawalWallet Address of the emergency withdrawal wallet.\\n     */\\n    function emergencyWithdrawalWallet() external view returns (address emergencyWithdrawalWallet);\\n\\n    /**\\n     * @notice Returns current do-hard-work indexes for strategies.\\n     * @param strategies Strategies.\\n     * @return dhwIndexes Current do-hard-work indexes for strategies.\\n     */\\n    function currentIndex(address[] calldata strategies) external view returns (uint256[] memory dhwIndexes);\\n\\n    /**\\n     * @notice Returns current strategy APYs.\\n     * @param strategies Strategies.\\n     */\\n    function strategyAPYs(address[] calldata strategies) external view returns (int256[] memory apys);\\n\\n    /**\\n     * @notice Returns assets deposited into a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return assets Assets deposited into the do-hard-work index for the strategy.\\n     */\\n    function depositedAssets(address strategy, uint256 dhwIndex) external view returns (uint256[] memory assets);\\n\\n    /**\\n     * @notice Returns shares redeemed in a do-hard-work index for a strategy.\\n     * @param strategy Strategy.\\n     * @param dhwIndex Do-hard-work index.\\n     * @return shares Shares redeemed in a do-hard-work index for the strategy.\\n     */\\n    function sharesRedeemed(address strategy, uint256 dhwIndex) external view returns (uint256 shares);\\n\\n    /**\\n     * @notice Gets timestamps when do-hard-works were performed.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return timestamps Timestamp for each pair of strategies and do-hard-work indexes.\\n     */\\n    function dhwTimestamps(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (uint256[] memory timestamps);\\n\\n    function getDhwYield(address[] calldata strategies, uint16a16 dhwIndexes)\\n        external\\n        view\\n        returns (int256[] memory yields);\\n\\n    /**\\n     * @notice Returns state of strategies at do-hard-work indexes.\\n     * @param strategies Strategies.\\n     * @param dhwIndexes Do-hard-work indexes.\\n     * @return states State of each strategy at corresponding do-hard-work index.\\n     */\\n    function strategyAtIndexBatch(address[] calldata strategies, uint16a16 dhwIndexes, uint256 assetGroupLength)\\n        external\\n        view\\n        returns (StrategyAtIndex[] memory states);\\n\\n    /**\\n     * @notice Gets required asset ratio for strategy at last DHW.\\n     * @param strategy Address of the strategy.\\n     * @return assetRatio Asset ratio.\\n     */\\n    function assetRatioAtLastDhw(address strategy) external view returns (uint256[] memory assetRatio);\\n\\n    /**\\n     * @notice Gets set platform fees.\\n     * @return fees Set platform fees.\\n     */\\n    function platformFees() external view returns (PlatformFees memory fees);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Registers a strategy into the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param strategy Address of strategy to register.\\n     * @param apy Apy of the strategy at the time of the registration.\\n     */\\n    function registerStrategy(address strategy, int256 apy) external;\\n\\n    /**\\n     * @notice Removes strategy from the system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategy Strategy to remove.\\n     */\\n    function removeStrategy(address strategy) external;\\n\\n    /**\\n     * @notice Sets ecosystem fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeePct Ecosystem fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setEcosystemFee(uint96 ecosystemFeePct) external;\\n\\n    /**\\n     * @notice Sets receiver of the ecosystem fees.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param ecosystemFeeReceiver Receiver to set.\\n     */\\n    function setEcosystemFeeReceiver(address ecosystemFeeReceiver) external;\\n\\n    /**\\n     * @notice Sets treasury fee.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeePct Treasury fee to set. Expressed in terms of FULL_PERCENT.\\n     */\\n    function setTreasuryFee(uint96 treasuryFeePct) external;\\n\\n    /**\\n     * @notice Sets treasury fee receiver.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param treasuryFeeReceiver Receiver to set.\\n     */\\n    function setTreasuryFeeReceiver(address treasuryFeeReceiver) external;\\n\\n    /**\\n     * @notice Does hard work on multiple strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_DO_HARD_WORKER\\n     * @param dhwParams Parameters for do hard work.\\n     */\\n    function doHardWork(DoHardWorkParameterBag calldata dhwParams) external;\\n\\n    /**\\n     * @notice Adds deposits to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add deposit.\\n     * @param amounts Amounts of assets to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addDeposits(address[] calldata strategies, uint256[][] calldata amounts)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Adds withdrawals to strategies to be processed at next do-hard-work.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param strategies Strategies to which to add withdrawal.\\n     * @param strategyShares Amounts of strategy shares to add to each strategy.\\n     * @return strategyIndexes Current do-hard-work indexes for the strategies.\\n     */\\n    function addWithdrawals(address[] calldata strategies, uint256[] calldata strategyShares)\\n        external\\n        returns (uint16a16 strategyIndexes);\\n\\n    /**\\n     * @notice Instantly redeems strategy shares for assets.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param redeemFastParams Parameters for fast redeem.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemFastParameterBag calldata redeemFastParams)\\n        external\\n        returns (uint256[] memory withdrawnAssets);\\n\\n    /**\\n     * @notice Claims withdrawals from the strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * - DHWs must be run for withdrawal indexes.\\n     * @param strategies Addresses if strategies from which to claim withdrawal.\\n     * @param dhwIndexes Indexes of strategies when withdrawal was made.\\n     * @param strategyShares Amount of strategy shares that was withdrawn.\\n     * @return assetsWithdrawn Amount of assets withdrawn from strategies.\\n     */\\n    function claimWithdrawals(address[] calldata strategies, uint16a16 dhwIndexes, uint256[] calldata strategyShares)\\n        external\\n        returns (uint256[] memory assetsWithdrawn);\\n\\n    /**\\n     * @notice Redeems strategy shares.\\n     * Used by recipients of platform fees.\\n     * @param strategies Strategies from which to redeem.\\n     * @param shares Amount of shares to redeem from each strategy.\\n     * @param withdrawalSlippages Slippages to guard redeemal process.\\n     */\\n    function redeemStrategyShares(\\n        address[] calldata strategies,\\n        uint256[] calldata shares,\\n        uint256[][] calldata withdrawalSlippages\\n    ) external;\\n\\n    /**\\n     * @notice Strategy was registered\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRegistered(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy was removed\\n     * @param strategy Strategy address\\n     */\\n    event StrategyRemoved(address indexed strategy);\\n\\n    /**\\n     * @notice Strategy DHW was executed\\n     * @param strategy Strategy address\\n     * @param dhwIndex DHW index\\n     * @param dhwInfo DHW info\\n     */\\n    event StrategyDhw(address indexed strategy, uint256 dhwIndex, DhwInfo dhwInfo);\\n\\n    /**\\n     * @notice Ecosystem fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event EcosystemFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Ecosystem fee receiver was changed\\n     * @param ecosystemFeeReceiver Receiver address\\n     */\\n    event EcosystemFeeReceiverSet(address indexed ecosystemFeeReceiver);\\n\\n    /**\\n     * @notice Treasury fee configuration was changed\\n     * @param feePct Fee percentage value\\n     */\\n    event TreasuryFeeSet(uint256 feePct);\\n\\n    /**\\n     * @notice Treasury fee receiver was changed\\n     * @param treasuryFeeReceiver Receiver address\\n     */\\n    event TreasuryFeeReceiverSet(address indexed treasuryFeeReceiver);\\n\\n    /**\\n     * @notice Emergency withdrawal wallet changed\\n     * @param wallet Emergency withdrawal wallet address\\n     */\\n    event EmergencyWithdrawalWalletSet(address indexed wallet);\\n\\n    /**\\n     * @notice Strategy shares have been redeemed\\n     * @param strategy Strategy address\\n     * @param owner Address that owns the shares\\n     * @param recipient Address that received the withdrawn funds\\n     * @param shares Amount of shares that were redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesRedeemed(\\n        address indexed strategy,\\n        address indexed owner,\\n        address indexed recipient,\\n        uint256 shares,\\n        uint256[] assetsWithdrawn\\n    );\\n\\n    /**\\n     * @notice Strategy shares were fast redeemed\\n     * @param strategy Strategy address\\n     * @param shares Amount of shares redeemed\\n     * @param assetsWithdrawn Amounts of withdrawn assets\\n     */\\n    event StrategySharesFastRedeemed(address indexed strategy, uint256 shares, uint256[] assetsWithdrawn);\\n\\n    /**\\n     * @notice Strategy APY value was updated\\n     * @param strategy Strategy address\\n     * @param apy New APY value\\n     */\\n    event StrategyApyUpdated(address indexed strategy, int256 apy);\\n}\\n\\ninterface IEmergencyWithdrawal {\\n    /**\\n     * @notice Emitted when a strategy is emergency withdrawn from.\\n     * @param strategy Strategy that was emergency withdrawn from.\\n     */\\n    event StrategyEmergencyWithdrawn(address indexed strategy);\\n\\n    /**\\n     * @notice Set a new address that will receive assets withdrawn if emergency withdrawal is executed.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SPOOL_ADMIN\\n     * @param wallet Address to set as the emergency withdrawal wallet.\\n     */\\n    function setEmergencyWithdrawalWallet(address wallet) external;\\n\\n    /**\\n     * @notice Instantly withdraws assets from a strategy, bypassing shares mechanism.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR\\n     * @param strategies Addresses of strategies.\\n     * @param withdrawalSlippages Slippages to guard withdrawal.\\n     * @param removeStrategies Whether to remove strategies from the system after withdrawal.\\n     */\\n    function emergencyWithdraw(\\n        address[] calldata strategies,\\n        uint256[][] calldata withdrawalSlippages,\\n        bool removeStrategies\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUsdPriceFeedManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of decimals used for USD values.\\nuint256 constant USD_DECIMALS = 18;\\n\\n/**\\n * @notice Emitted when asset is invalid.\\n * @param asset Invalid asset.\\n */\\nerror InvalidAsset(address asset);\\n\\n/**\\n * @notice Emitted when price returned by price aggregator is negative or zero.\\n * @param price Actual price returned by price aggregator.\\n */\\nerror NonPositivePrice(int256 price);\\n\\n/**\\n * @notice Emitted when pricing data returned by price aggregator is not from the current\\n * round or the round hasn't finished.\\n */\\nerror StalePriceData();\\n\\ninterface IUsdPriceFeedManager {\\n    /**\\n     * @notice Gets number of decimals for an asset.\\n     * @param asset Address of the asset.\\n     * @return assetDecimals Number of decimals for the asset.\\n     */\\n    function assetDecimals(address asset) external view returns (uint256 assetDecimals);\\n\\n    /**\\n     * @notice Gets number of decimals for USD.\\n     * @return usdDecimals Number of decimals for USD.\\n     */\\n    function usdDecimals() external view returns (uint256 usdDecimals);\\n\\n    /**\\n     * @notice Calculates asset value in USD using current price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsd(address asset, uint256 assetAmount) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using current price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAsset(address asset, uint256 usdAmount) external view returns (uint256 assetValue);\\n\\n    /**\\n     * @notice Calculates asset value in USD using provided price.\\n     * @param asset Address of asset.\\n     * @param assetAmount Amount of asset in asset decimals.\\n     * @param price Price of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPrice(address asset, uint256 assetAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates assets value in USD using provided prices.\\n     * @param assets Addresses of assets.\\n     * @param assetAmounts Amounts of assets in asset decimals.\\n     * @param prices Prices of asset in USD.\\n     * @return usdValue Value in USD in USD decimals.\\n     */\\n    function assetToUsdCustomPriceBulk(\\n        address[] calldata assets,\\n        uint256[] calldata assetAmounts,\\n        uint256[] calldata prices\\n    ) external view returns (uint256 usdValue);\\n\\n    /**\\n     * @notice Calculates USD value in asset using provided price.\\n     * @param asset Address of asset.\\n     * @param usdAmount Amount of USD in USD decimals.\\n     * @param price Price of asset in USD.\\n     * @return assetValue Value in asset in asset decimals.\\n     */\\n    function usdToAssetCustomPrice(address asset, uint256 usdAmount, uint256 price)\\n        external\\n        view\\n        returns (uint256 assetValue);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWithdrawalManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/uint16a16Lib.sol\\\";\\n\\n/**\\n * @notice Used when trying to burn withdrawal NFT that was not synced yet.\\n * @param id ID of the NFT.\\n */\\nerror WithdrawalNftNotSyncedYet(uint256 id);\\n\\n/**\\n * @notice Base information for redeemal.\\n * @custom:member smartVault Smart vault from which to redeem.\\n * @custom:member shares Amount of smart vault shares to redeem.\\n * @custom:member nftIds IDs of deposit NFTs to burn before redeemal.\\n * @custom:member nftAmounts Amounts of NFT shares to burn.\\n */\\nstruct RedeemBag {\\n    address smartVault;\\n    uint256 shares;\\n    uint256[] nftIds;\\n    uint256[] nftAmounts;\\n}\\n\\n/**\\n * @notice Extra information for fast redeemal.\\n * @custom:member strategies Strategies of the smart vault.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member assetGroupId ID of the asset group of the smart vault.\\n * @custom:member redeemer Address that initiated the redeemal.\\n * @custom:member withdrawalSlippages Slippages used to guard redeemal.\\n */\\nstruct RedeemFastExtras {\\n    address[] strategies;\\n    address[] assetGroup;\\n    uint256 assetGroupId;\\n    address redeemer;\\n    uint256[][] withdrawalSlippages;\\n}\\n\\n/**\\n * @notice Extra information for redeemal.\\n * @custom:member receiver Receiver of the withdraw NFT.\\n * @custom:member owner Address that owns the shares being redeemed.\\n * @custom:member executor Address that initiated the redeemal.\\n * @custom:member flushIndex Current flush index of the smart vault.\\n */\\nstruct RedeemExtras {\\n    address receiver;\\n    address owner;\\n    address executor;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Information used to claim withdrawal.\\n * @custom:member smartVault Smart vault from which to claim withdrawal.\\n * @custom:member nftIds Withdrawal NFTs to burn while claiming withdrawal.\\n * @custom:member nftAmounts Amounts of NFT shares to burn.\\n * @custom:member receiver Receiver of withdrawn assets.\\n * @custom:member executor Address that initiated the withdrawal claim.\\n * @custom:member assetGroupId ID of the asset group of the smart vault.\\n * @custom:member assetGroup Asset group of the smart vault.\\n * @custom:member flushIndexToSync Next flush index to sync for the smart vault.\\n */\\nstruct WithdrawalClaimBag {\\n    address smartVault;\\n    uint256[] nftIds;\\n    uint256[] nftAmounts;\\n    address receiver;\\n    address executor;\\n    uint256 assetGroupId;\\n    address[] assetGroup;\\n    uint256 flushIndexToSync;\\n}\\n\\ninterface IWithdrawalManager {\\n    /**\\n     * @notice User redeemed withdrawal NFTs for underlying assets\\n     * @param smartVault Smart vault address\\n     * @param claimer Claimer address\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     * @param withdrawnAssets Amount of underlying assets withdrawn\\n     */\\n    event WithdrawalClaimed(\\n        address indexed smartVault,\\n        address indexed claimer,\\n        uint256 assetGroupId,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts,\\n        uint256[] withdrawnAssets\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param owner Owner of shares to be redeemed\\n     * @param redeemId Withdrawal NFT ID for this redeemal\\n     * @param flushIndex Flush index the redeem was scheduled for\\n     * @param shares Amount of vault shares to redeem\\n     * @param receiver Beneficiary that will be able to claim the underlying assets\\n     */\\n    event RedeemInitiated(\\n        address indexed smartVault,\\n        address indexed owner,\\n        uint256 indexed redeemId,\\n        uint256 flushIndex,\\n        uint256 shares,\\n        address receiver\\n    );\\n\\n    /**\\n     * @notice A deposit has been initiated\\n     * @param smartVault Smart vault address\\n     * @param redeemer Redeem initiator and owner of shares\\n     * @param shares Amount of vault shares to redeem\\n     * @param nftIds NFTs to burn\\n     * @param nftAmounts NFT shares to burn\\n     * @param assetsWithdrawn Amount of underlying assets withdrawn\\n     */\\n    event FastRedeemInitiated(\\n        address indexed smartVault,\\n        address indexed redeemer,\\n        uint256 shares,\\n        uint256[] nftIds,\\n        uint256[] nftAmounts,\\n        uint256[] assetsWithdrawn\\n    );\\n\\n    /**\\n     * @notice Flushes smart vaults deposits and withdrawals to the strategies.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault to flush.\\n     * @param flushIndex Current flush index of the smart vault.\\n     * @param strategies Strategies of the smart vault.\\n     * @return dhwIndexes current do-hard-work indexes of the strategies.\\n     */\\n    function flushSmartVault(address smartVault, uint256 flushIndex, address[] calldata strategies)\\n        external\\n        returns (uint16a16 dhwIndexes);\\n\\n    /**\\n     * @notice Claims withdrawal.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Parameters for claiming withdrawal.\\n     * @return withdrawnAssets Amount of assets withdrawn.\\n     * @return assetGroupId ID of the asset group.\\n     */\\n    function claimWithdrawal(WithdrawalClaimBag calldata bag)\\n        external\\n        returns (uint256[] memory withdrawnAssets, uint256 assetGroupId);\\n\\n    /**\\n     * @notice Syncs withdrawals between strategies and smart vault after do-hard-works.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param smartVault Smart vault to sync.\\n     * @param flushIndex Smart vault's flush index to sync.\\n     * @param strategies Strategies of the smart vault.\\n     * @param dhwIndexes_ Strategies' do-hard-work indexes to sync.\\n     */\\n    function syncWithdrawals(\\n        address smartVault,\\n        uint256 flushIndex,\\n        address[] calldata strategies,\\n        uint16a16 dhwIndexes_\\n    ) external;\\n\\n    /**\\n     * @notice Redeems smart vault shares.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Base information for redeemal.\\n     * @param bag2 Extra information for redeemal.\\n     * @return nftId ID of the withdrawal NFT.\\n     */\\n    function redeem(RedeemBag calldata bag, RedeemExtras calldata bag2) external returns (uint256 nftId);\\n\\n    /**\\n     * @notice Instantly redeems smart vault shares.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SMART_VAULT_MANAGER\\n     * @param bag Base information for redeemal.\\n     * @param bag Extra information for fast redeemal.\\n     * @return assets Amount of assets withdrawn.\\n     */\\n    function redeemFast(RedeemBag calldata bag, RedeemFastExtras memory bag2)\\n        external\\n        returns (uint256[] memory assets);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/CommonErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Used when an array has invalid length.\\n */\\nerror InvalidArrayLength();\\n\\n/**\\n * @notice Used when group of smart vaults or strategies do not have same asset group.\\n */\\nerror NotSameAssetGroup();\\n\\n/**\\n * @notice Used when configuring an address with a zero address.\\n */\\nerror ConfigurationAddressZero();\\n\\n/**\\n * @notice Used when constructor or intializer parameters are invalid.\\n */\\nerror InvalidConfiguration();\\n\\n/**\\n * @notice Used when fetched exchange rate is out of slippage range.\\n */\\nerror ExchangeRateOutOfSlippages();\\n\\n/**\\n * @notice Used when an invalid strategy is provided.\\n * @param address_ Address of the invalid strategy.\\n */\\nerror InvalidStrategy(address address_);\\n\\n/**\\n * @notice Used when doing low-level call on an address that is not a contract.\\n * @param address_ Address of the contract\\n */\\nerror AddressNotContract(address address_);\\n\\n/**\\n * @notice Used when invoking an only view execution and tx.origin is not address zero.\\n * @param address_ Address of the tx.origin\\n */\\nerror OnlyViewExecution(address address_);\\n\"\r\n    },\r\n    \"src/interfaces/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @dev Number of seconds in an average year.\\nuint256 constant SECONDS_IN_YEAR = 31_556_926;\\n\\n/// @dev Number of seconds in an average year.\\nint256 constant SECONDS_IN_YEAR_INT = 31_556_926;\\n\\n/// @dev Represents 100%.\\nuint256 constant FULL_PERCENT = 100_00;\\n\\n/// @dev Represents 100%.\\nint256 constant FULL_PERCENT_INT = 100_00;\\n\\n/// @dev Represents 100% for yield.\\nint256 constant YIELD_FULL_PERCENT_INT = 10 ** 12;\\n\\n/// @dev Represents 100% for yield.\\nuint256 constant YIELD_FULL_PERCENT = uint256(YIELD_FULL_PERCENT_INT);\\n\\n/// @dev Maximal management fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant MANAGEMENT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal deposit fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant DEPOSIT_FEE_MAX = 5_00;\\n\\n/// @dev Maximal smart vault performance fee that can be set on a smart vault. Expressed in terms of FULL_PERCENT.\\nuint256 constant SV_PERFORMANCE_FEE_MAX = 20_00;\\n\\n/// @dev Maximal ecosystem fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant ECOSYSTEM_FEE_MAX = 20_00;\\n\\n/// @dev Maximal treasury fee that can be set on the system. Expressed in terms of FULL_PERCENT.\\nuint256 constant TREASURY_FEE_MAX = 10_00;\\n\\n/// @dev Maximal risk score a strategy can be assigned.\\nuint8 constant MAX_RISK_SCORE = 10_0;\\n\\n/// @dev Minimal risk score a strategy can be assigned.\\nuint8 constant MIN_RISK_SCORE = 1;\\n\\n/// @dev Maximal value for risk tolerance a smart vautl can have.\\nint8 constant MAX_RISK_TOLERANCE = 10;\\n\\n/// @dev Minimal value for risk tolerance a smart vault can have.\\nint8 constant MIN_RISK_TOLERANCE = -10;\\n\\n/// @dev If set as risk provider, system will return fixed risk score values\\naddress constant STATIC_RISK_PROVIDER = address(0xaaa);\\n\\n/// @dev Fixed values to use if risk provider is set to STATIC_RISK_PROVIDER\\nuint8 constant STATIC_RISK_SCORE = 1;\\n\\n/// @dev Maximal value of deposit NFT ID.\\nuint256 constant MAXIMAL_DEPOSIT_ID = 2 ** 255;\\n\\n/// @dev Maximal value of withdrawal NFT ID.\\nuint256 constant MAXIMAL_WITHDRAWAL_ID = 2 ** 256 - 1;\\n\\n/// @dev How many shares will be minted with a NFT\\nuint256 constant NFT_MINTED_SHARES = 10 ** 6;\\n\\n/// @dev Each smart vault can have up to STRATEGY_COUNT_CAP strategies.\\nuint256 constant STRATEGY_COUNT_CAP = 16;\\n\\n/// @dev Maximal DHW base yield. Expressed in terms of FULL_PERCENT.\\nuint256 constant MAX_DHW_BASE_YIELD_LIMIT = 10_00;\\n\\n/// @dev Smart vault and strategy share multiplier at first deposit.\\nuint256 constant INITIAL_SHARE_MULTIPLIER = 1000;\\n\\n/// @dev Strategy initial locked shares. These shares will never be unlocked.\\nuint256 constant INITIAL_LOCKED_SHARES = 10 ** 12;\\n\\n/// @dev Strategy initial locked shares address.\\naddress constant INITIAL_LOCKED_SHARES_ADDRESS = address(0xdead);\\n\\n/// @dev Maximum number of guards a smart vault can be configured with\\nuint256 constant MAX_GUARD_COUNT = 10;\\n\\n/// @dev Maximum number of actions a smart vault can be configured with\\nuint256 constant MAX_ACTION_COUNT = 10;\\n\\n/// @dev ID of null asset group. Should not be used by any strategy or smart vault.\\nuint256 constant NULL_ASSET_GROUP_ID = 0;\\n\"\r\n    },\r\n    \"src/interfaces/IAllocationProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Used when number of provided APYs or risk scores does not match number of provided strategies.\\n */\\nerror ApysOrRiskScoresLengthMismatch(uint256, uint256);\\n\\n/**\\n * @notice Input for calculating allocation.\\n * @custom:member strategies Strategies to allocate.\\n * @custom:member apys APYs for each strategy.\\n * @custom:member riskScores Risk scores for each strategy.\\n * @custom:member riskTolerance Risk tolerance of the smart vault.\\n */\\nstruct AllocationCalculationInput {\\n    address[] strategies;\\n    int256[] apys;\\n    uint8[] riskScores;\\n    int8 riskTolerance;\\n}\\n\\ninterface IAllocationProvider {\\n    /**\\n     * @notice Calculates allocation between strategies based on input parameters.\\n     * @param data Input data for allocation calculation.\\n     * @return allocation Calculated allocation.\\n     */\\n    function calculateAllocation(AllocationCalculationInput calldata data)\\n        external\\n        view\\n        returns (uint256[] memory allocation);\\n}\\n\"\r\n    },\r\n    \"src/access/SpoolAccessControllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/ISpoolAccessControl.sol\\\";\\nimport \\\"../interfaces/CommonErrors.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @notice Account access role verification middleware\\n */\\nabstract contract SpoolAccessControllable {\\n    /* ========== CONSTANTS ========== */\\n\\n    /**\\n     * @dev Spool access control manager.\\n     */\\n    ISpoolAccessControl internal immutable _accessControl;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    /**\\n     * @param accessControl_ Spool access control manager.\\n     */\\n    constructor(ISpoolAccessControl accessControl_) {\\n        if (address(accessControl_) == address(0)) revert ConfigurationAddressZero();\\n\\n        _accessControl = accessControl_;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Reverts if an account is missing a role.\\\\\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_accessControl.hasRole(role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revert if an account is missing a role for a smartVault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    function _checkSmartVaultRole(address smartVault, bytes32 role, address account) internal view {\\n        if (!_accessControl.hasSmartVaultRole(smartVault, role, account)) {\\n            revert MissingRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (_accessControl.paused()) {\\n            revert SystemPaused();\\n        }\\n    }\\n\\n    function _checkNonReentrant() internal view {\\n        _accessControl.checkNonReentrant();\\n    }\\n\\n    function _nonReentrantBefore() internal {\\n        _accessControl.nonReentrantBefore();\\n    }\\n\\n    function _nonReentrantAfter() internal {\\n        _accessControl.nonReentrantAfter();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /**\\n     * @notice Only allows accounts with granted role.\\n     * @dev Reverts when the account fails check.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlyRole(bytes32 role, address account) {\\n        _checkRole(role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts with granted role for a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to check for.\\n     * @param account Account to check.\\n     */\\n    modifier onlySmartVaultRole(address smartVault, bytes32 role, address account) {\\n        _checkSmartVaultRole(smartVault, role, account);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only allows accounts that are Spool admins or admins of a smart vault.\\n     * @dev Reverts when the account fails check.\\n     * @param smartVault Address of the smart vault.\\n     * @param account Account to check.\\n     */\\n    modifier onlyAdminOrVaultAdmin(address smartVault, address account) {\\n        _accessControl.checkIsAdminOrVaultAdmin(smartVault, account);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, or other contracts using this modifier.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    /**\\n     * @dev Check if a system has already entered in the non-reentrant state.\\n     */\\n    modifier checkNonReentrant() {\\n        _checkNonReentrant();\\n        _;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/ISmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./RequestType.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when the ID for deposit NFTs overflows.\\n * @dev Should never happen.\\n */\\nerror DepositIdOverflow();\\n\\n/**\\n * @notice Used when the ID for withdrawal NFTs overflows.\\n * @dev Should never happen.\\n */\\nerror WithdrawalIdOverflow();\\n\\n/**\\n * @notice Used when ID does not represent a deposit NFT.\\n * @param depositNftId Invalid ID for deposit NFT.\\n */\\nerror InvalidDepositNftId(uint256 depositNftId);\\n\\n/**\\n * @notice Used when ID does not represent a withdrawal NFT.\\n * @param withdrawalNftId Invalid ID for withdrawal NFT.\\n */\\nerror InvalidWithdrawalNftId(uint256 withdrawalNftId);\\n\\n/**\\n * @notice Used when balance of the NFT is invalid.\\n * @param balance Actual balance of the NFT.\\n */\\nerror InvalidNftBalance(uint256 balance);\\n\\n/**\\n * @notice Used when someone wants to transfer invalid NFT shares amount.\\n * @param transferAmount Amount of shares requested to be transferred.\\n */\\nerror InvalidNftTransferAmount(uint256 transferAmount);\\n\\n/**\\n * @notice Used when user tries to send tokens to himself.\\n */\\nerror SenderEqualsRecipient();\\n\\n/* ========== STRUCTS ========== */\\n\\nstruct DepositMetadata {\\n    uint256[] assets;\\n    uint256 initiated;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Holds metadata detailing the withdrawal behind the NFT.\\n * @custom:member vaultShares Vault shares withdrawn.\\n * @custom:member flushIndex Flush index into which withdrawal is included.\\n */\\nstruct WithdrawalMetadata {\\n    uint256 vaultShares;\\n    uint256 flushIndex;\\n}\\n\\n/**\\n * @notice Holds all smart vault fee percentages.\\n * @custom:member managementFeePct Management fee of the smart vault.\\n * @custom:member depositFeePct Deposit fee of the smart vault.\\n * @custom:member performanceFeePct Performance fee of the smart vault.\\n */\\nstruct SmartVaultFees {\\n    uint16 managementFeePct;\\n    uint16 depositFeePct;\\n    uint16 performanceFeePct;\\n}\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISmartVault is IERC20Upgradeable, IERC1155MetadataURIUpgradeable {\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Fractional balance of a NFT (0 - NFT_MINTED_SHARES).\\n     * @param account Account to check the balance for.\\n     * @param id ID of the NFT to check.\\n     * @return fractionalBalance Fractional balance of account for the NFT.\\n     */\\n    function balanceOfFractional(address account, uint256 id) external view returns (uint256 fractionalBalance);\\n\\n    /**\\n     * @notice Fractional balance of a NFTs (0 - NFT_MINTED_SHARES).\\n     * @param account Account to check the balance for.\\n     * @param ids IDs of the NFTs to check.\\n     * @return fractionalBalances Fractional balances of account for each requested NFT.\\n     */\\n    function balanceOfFractionalBatch(address account, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory fractionalBalances);\\n    /**\\n     * @notice Gets the asset group used by the smart vault.\\n     * @return id ID of the asset group.\\n     */\\n    function assetGroupId() external view returns (uint256 id);\\n\\n    /**\\n     * @notice Gets the name of the smart vault.\\n     * @return name Name of the vault.\\n     */\\n    function vaultName() external view returns (string memory name);\\n\\n    /**\\n     * @notice Gets metadata for NFTs.\\n     * @param nftIds IDs of NFTs.\\n     * @return metadata Metadata for each requested NFT.\\n     */\\n    function getMetadata(uint256[] calldata nftIds) external view returns (bytes[] memory metadata);\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Set a new base URI for ERC1155 metadata.\\n     * @param uri_ new base URI value\\n     */\\n    function setBaseURI(string memory uri_) external;\\n\\n    /**\\n     * @notice Mints smart vault tokens for receiver.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver REceiver of minted tokens.\\n     * @param vaultShares Amount of tokens to mint.\\n     */\\n    function mintVaultShares(address receiver, uint256 vaultShares) external;\\n\\n    /**\\n     * @notice Burns smart vault tokens and releases strategy shares back to strategies.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param owner Address for which to burn the tokens.\\n     * @param vaultShares Amount of tokens to burn.\\n     * @param strategies Strategies for which to release the strategy shares.\\n     * @param shares Amounts of strategy shares to release.\\n     */\\n    function burnVaultShares(\\n        address owner,\\n        uint256 vaultShares,\\n        address[] calldata strategies,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    /**\\n     * @notice Mints a new withdrawal NFT.\\n     * @dev Supply of minted NFT is NFT_MINTED_SHARES (for partial burning).\\n     * Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver Address that will receive the NFT.\\n     * @param metadata Metadata to store for minted NFT.\\n     * @return id ID of the minted NFT.\\n     */\\n    function mintWithdrawalNFT(address receiver, WithdrawalMetadata calldata metadata) external returns (uint256 id);\\n\\n    /**\\n     * @notice Mints a new deposit NFT.\\n     * @dev Supply of minted NFT is NFT_MINTED_SHARES (for partial burning).\\n     * Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param receiver Address that will receive the NFT.\\n     * @param metadata Metadata to store for minted NFT.\\n     * @return id ID of the minted NFT.\\n     */\\n    function mintDepositNFT(address receiver, DepositMetadata calldata metadata) external returns (uint256 id);\\n\\n    /**\\n     * @notice Burns NFTs and returns their metadata.\\n     * Allows for partial burning.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param owner Owner of NFTs to burn.\\n     * @param nftIds IDs of NFTs to burn.\\n     * @param nftAmounts NFT shares to burn (partial burn).\\n     * @return metadata Metadata for each burned NFT.\\n     */\\n    function burnNFTs(address owner, uint256[] calldata nftIds, uint256[] calldata nftAmounts)\\n        external\\n        returns (bytes[] memory metadata);\\n\\n    /**\\n     * @notice Transfers smart vault tokens.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param from Spender and owner of tokens.\\n     * @param to Address to which tokens will be transferred.\\n     * @param amount Amount of tokens to transfer.\\n     * @return success True if transfer was successful.\\n     */\\n    function transferFromSpender(address from, address to, uint256 amount) external returns (bool success);\\n\\n    /**\\n     * @notice Transfers unclaimed shares to claimer.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_SMART_VAULT_MANAGER\\n     * @param claimer Address that claims the shares.\\n     * @param amount Amount of shares to transfer.\\n     */\\n    function claimShares(address claimer, uint256 amount) external;\\n\\n    /// @notice Emitted when base URI is changed.\\n    event BaseURIChanged(string baseUri);\\n}\\n\"\r\n    },\r\n    \"src/libraries/uint16a16Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ntype uint16a16 is uint256;\\n\\n/**\\n * @notice This library enables packing of sixteen uint16 elements into one uint256 word.\\n */\\nlibrary uint16a16Lib {\\n    /// @notice Number of bits per stored element.\\n    uint256 constant bits = 16;\\n\\n    /// @notice Maximal number of elements stored.\\n    uint256 constant elements = 16;\\n\\n    // must ensure that bits * elements <= 256\\n\\n    /// @notice Range covered by stored element.\\n    uint256 constant range = 1 << bits;\\n\\n    /// @notice Maximal value of stored element.\\n    uint256 constant max = range - 1;\\n\\n    /**\\n     * @notice Gets element from packed array.\\n     * @param va Packed array.\\n     * @param index Index of element to get.\\n     * @return element Element of va stored in index index.\\n     */\\n    function get(uint16a16 va, uint256 index) internal pure returns (uint256) {\\n        require(index < elements);\\n        return (uint16a16.unwrap(va) >> (bits * index)) & max;\\n    }\\n\\n    /**\\n     * @notice Sets element to packed array.\\n     * @param va Packed array.\\n     * @param index Index under which to store the element\\n     * @param ev Element to store.\\n     * @return va Packed array with stored element.\\n     */\\n    function set(uint16a16 va, uint256 index, uint256 ev) internal pure returns (uint16a16) {\\n        require(index < elements);\\n        require(ev < range);\\n        index *= bits;\\n        return uint16a16.wrap((uint16a16.unwrap(va) & ~(max << index)) | (ev << index));\\n    }\\n\\n    /**\\n     * @notice Sets elements to packed array.\\n     * Elements are stored continuously from index 0 onwards.\\n     * @param va Packed array.\\n     * @param ev Elements to store.\\n     * @return va Packed array with stored elements.\\n     */\\n    function set(uint16a16 va, uint256[] memory ev) internal pure returns (uint16a16) {\\n        for (uint256 i; i < ev.length; ++i) {\\n            va = set(va, i, ev[i]);\\n        }\\n\\n        return va;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Information needed to make a swap of assets.\\n * @custom:member swapTarget Contract executing the swap.\\n * @custom:member token Token to be swapped.\\n * @custom:member swapCallData Calldata describing the swap itself.\\n */\\nstruct SwapInfo {\\n    address swapTarget;\\n    address token;\\n    bytes swapCallData;\\n}\\n\\n/* ========== ERRORS ========== */\\n\\n/**\\n * @notice Used when trying to do a swap via an exchange that is not allowed to execute a swap.\\n * @param exchange Exchange used.\\n */\\nerror ExchangeNotAllowed(address exchange);\\n\\n/**\\n * @notice Used when trying to execute a swap but are not authorized.\\n * @param caller Caller of the swap method.\\n */\\nerror NotSwapper(address caller);\\n\\n/* ========== INTERFACES ========== */\\n\\ninterface ISwapper {\\n    /* ========== EVENTS ========== */\\n\\n    /**\\n     * @notice Emitted when the exchange allowlist is updated.\\n     * @param exchange Exchange that was updated.\\n     * @param isAllowed Whether the exchange is allowed to be used in a swap or not after the update.\\n     */\\n    event ExchangeAllowlistUpdated(address indexed exchange, bool isAllowed);\\n\\n    event Swapped(\\n        address indexed receiver, address[] tokensIn, address[] tokensOut, uint256[] amountsIn, uint256[] amountsOut\\n    );\\n\\n    /* ========== EXTERNAL MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Performs a swap of tokens with external contracts.\\n     * - deposit tokens into the swapper contract\\n     * - swapper will swap tokens based on swap info provided\\n     * - swapper will return unswapped tokens to the receiver\\n     * @param tokensIn Addresses of tokens available for the swap.\\n     * @param swapInfo Information needed to perform the swap.\\n     * @param tokensOut Addresses of tokens to swap to.\\n     * @param receiver Receiver of unswapped tokens.\\n     * @return amountsOut Amounts of `tokensOut` sent from the swapper to the receiver.\\n     */\\n    function swap(\\n        address[] calldata tokensIn,\\n        SwapInfo[] calldata swapInfo,\\n        address[] calldata tokensOut,\\n        address receiver\\n    ) external returns (uint256[] memory amountsOut);\\n\\n    /**\\n     * @notice Updates list of exchanges that can be used in a swap.\\n     * @dev Requirements:\\n     *   - can only be called by user granted ROLE_SPOOL_ADMIN\\n     *   - exchanges and allowed arrays need to be of same length\\n     * @param exchanges Addresses of exchanges.\\n     * @param allowed Whether an exchange is allowed to be used in a swap.\\n     */\\n    function updateExchangeAllowlist(address[] calldata exchanges, bool[] calldata allowed) external;\\n\\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Checks if an exchange is allowed to be used in a swap.\\n     * @param exchange Exchange to check.\\n     * @return isAllowed True if the exchange is allowed to be used in a swap, false otherwise.\\n     */\\n    function isExchangeAllowed(address exchange) external view returns (bool isAllowed);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/ISpoolAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @notice Used when an account is missing a required role.\\n * @param role Required role.\\n * @param account Account missing the required role.\\n */\\nerror MissingRole(bytes32 role, address account);\\n\\n/**\\n * @notice Used when interacting with Spool when the system is paused.\\n */\\nerror SystemPaused();\\n\\n/**\\n * @notice Used when setting smart vault owner\\n */\\nerror SmartVaultOwnerAlreadySet(address smartVault);\\n\\n/**\\n * @notice Used when a contract tries to enter in a non-reentrant state.\\n */\\nerror ReentrantCall();\\n\\n/**\\n * @notice Used when a contract tries to call in a non-reentrant function and doesn't have the correct role.\\n */\\nerror NoReentrantRole();\\n\\ninterface ISpoolAccessControl is IAccessControlUpgradeable {\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets owner of a smart vault.\\n     * @param smartVault Smart vault.\\n     * @return owner Owner of the smart vault.\\n     */\\n    function smartVaultOwner(address smartVault) external view returns (address owner);\\n\\n    /**\\n     * @notice Looks if an account has a role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to look for.\\n     * @param account Account to check.\\n     * @return hasRole True if account has the role for the smart vault, false otherwise.\\n     */\\n    function hasSmartVaultRole(address smartVault, bytes32 role, address account)\\n        external\\n        view\\n        returns (bool hasRole);\\n\\n    /**\\n     * @notice Checks if an account is either Spool admin or admin for a smart vault.\\n     * @dev The function reverts if account is neither.\\n     * @param smartVault Address of the smart vault.\\n     * @param account to check.\\n     */\\n    function checkIsAdminOrVaultAdmin(address smartVault, address account) external view;\\n\\n    /**\\n     * @notice Checks if system is paused or not.\\n     * @return isPaused True if system is paused, false otherwise.\\n     */\\n    function paused() external view returns (bool isPaused);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Pauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_PAUSER\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Unpauses the whole system.\\n     * @dev Requirements:\\n     * - caller must have role ROLE_UNPAUSER\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @notice Grants role to an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to grant.\\n     * @param account Account to grant the role to.\\n     */\\n    function grantSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Revokes role from an account for a smart vault.\\n     * @dev Requirements:\\n     * - caller must have either role ROLE_SPOOL_ADMIN or role ROLE_SMART_VAULT_ADMIN for the smart vault\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to revoke.\\n     * @param account Account to revoke the role from.\\n     */\\n    function revokeSmartVaultRole(address smartVault, bytes32 role, address account) external;\\n\\n    /**\\n     * @notice Renounce role for a smart vault.\\n     * @param smartVault Address of the smart vault.\\n     * @param role Role to renounce.\\n     */\\n    function renounceSmartVaultRole(address smartVault, bytes32 role) external;\\n\\n    /**\\n     * @notice Grant ownership to smart vault and assigns admin role.\\n     * @dev Ownership can only be granted once and it should be done at vault creation time.\\n     * @param smartVault Address of the smart vault.\\n     * @param owner address to which grant ownership to\\n     */\\n    function grantSmartVaultOwnership(address smartVault, address owner) external;\\n\\n    /**\\n     * @notice Checks and reverts if a system has already entered in the non-reentrant state.\\n     */\\n    function checkNonReentrant() external view;\\n\\n    /**\\n     * @notice Sets the entered flag to true when entering for the first time.\\n     * @dev Reverts if a system has already entered before.\\n     */\\n    function nonReentrantBefore() external;\\n\\n    /**\\n     * @notice Resets the entered flag after the call is finished.\\n     */\\n    function nonReentrantAfter() external;\\n\\n    /**\\n     * @notice Emitted when ownership of a smart vault is granted to an address\\n     * @param smartVault Smart vault address\\n     * @param address_ Address of the new smart vault owner\\n     */\\n    event SmartVaultOwnershipGranted(address indexed smartVault, address indexed address_);\\n\\n    /**\\n     * @notice Smart vault specific role was granted\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account to which the role was granted\\n     */\\n    event SmartVaultRoleGranted(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was revoked\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account for which the role was revoked\\n     */\\n    event SmartVaultRoleRevoked(address indexed smartVault, bytes32 indexed role, address indexed account);\\n\\n    /**\\n     * @notice Smart vault specific role was renounced\\n     * @param smartVault Smart vault address\\n     * @param role Role ID\\n     * @param account Account that renounced the role\\n     */\\n    event SmartVaultRoleRenounced(address indexed smartVault, bytes32 indexed role, address indexed account);\\n}\\n\"\r\n    },\r\n    \"src/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Grants permission to:\\n * - acts as a default admin for other roles,\\n * - can whitelist an action with action manager,\\n * - can manage asset group registry.\\n *\\n * Is granted to the deployer of the SpoolAccessControl contract.\\n *\\n * Equals to the DEFAULT_ADMIN_ROLE of the OpenZeppelin AccessControl.\\n */\\nbytes32 constant ROLE_SPOOL_ADMIN = 0x00;\\n\\n/**\\n * @dev Grants permission to integrate a new smart vault into the Spool ecosystem.\\n *\\n * Should be granted to smart vault factory contracts.\\n */\\nbytes32 constant ROLE_SMART_VAULT_INTEGRATOR = keccak256(\\\"SMART_VAULT_INTEGRATOR\\\");\\n\\n/**\\n * @dev Grants permission to\\n * - manage rewards on smart vaults,\\n * - manage roles on smart vaults,\\n * - redeem for another user of a smart vault.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ADMIN = keccak256(\\\"SMART_VAULT_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to manage allowlists with AllowlistGuard for a smart vault.\\n *\\n * Should be granted to whoever is in charge of maintaining allowlists with AllowlistGuard for a smart vault.\\n */\\nbytes32 constant ROLE_GUARD_ALLOWLIST_MANAGER = keccak256(\\\"GUARD_ALLOWLIST_MANAGER\\\");\\n\\n/**\\n * @dev Grants permission to manage assets on master wallet.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the StrategyRegistry contract,\\n * - the DepositManager contract,\\n * - the WithdrawalManager contract.\\n */\\nbytes32 constant ROLE_MASTER_WALLET_MANAGER = keccak256(\\\"MASTER_WALLET_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a smart vault manager.\\n *\\n * Should be granted to:\\n * - the SmartVaultManager contract,\\n * - the DepositManager contract.\\n */\\nbytes32 constant ROLE_SMART_VAULT_MANAGER = keccak256(\\\"SMART_VAULT_MANAGER\\\");\\n\\n/**\\n * @dev Marks a contract as a strategy registry.\\n *\\n * Should be granted to the StrategyRegistry contract.\\n */\\nbytes32 constant ROLE_STRATEGY_REGISTRY = keccak256(\\\"STRATEGY_REGISTRY\\\");\\n\\n/**\\n * @dev Grants permission to act as a risk provider.\\n *\\n * Should be granted to whoever is allowed to provide risk scores.\\n */\\nbytes32 constant ROLE_RISK_PROVIDER = keccak256(\\\"RISK_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to act as an allocation provider.\\n *\\n * Should be granted to contracts that are allowed to calculate allocations.\\n */\\nbytes32 constant ROLE_ALLOCATION_PROVIDER = keccak256(\\\"ALLOCATION_PROVIDER\\\");\\n\\n/**\\n * @dev Grants permission to pause the system.\\n */\\nbytes32 constant ROLE_PAUSER = keccak256(\\\"SYSTEM_PAUSER\\\");\\n\\n/**\\n * @dev Grants permission to unpause the system.\\n */\\nbytes32 constant ROLE_UNPAUSER = keccak256(\\\"SYSTEM_UNPAUSER\\\");\\n\\n/**\\n * @dev Grants permission to manage rewards payment pool.\\n */\\nbytes32 constant ROLE_REWARD_POOL_ADMIN = keccak256(\\\"REWARD_POOL_ADMIN\\\");\\n\\n/**\\n * @dev Grants permission to reallocate smart vaults.\\n */\\nbytes32 constant ROLE_REALLOCATOR = keccak256(\\\"REALLOCATOR\\\");\\n\\n/**\\n * @dev Grants permission to be used as a strategy.\\n */\\nbytes32 constant ROLE_STRATEGY = keccak256(\\\"STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission to manually set strategy apy.\\n */\\nbytes32 constant ROLE_STRATEGY_APY_SETTER = keccak256(\\\"STRATEGY_APY_SETTER\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_STRATEGY.\\n */\\nbytes32 constant ADMIN_ROLE_STRATEGY = keccak256(\\\"ADMIN_STRATEGY\\\");\\n\\n/**\\n * @dev Grants permission vault admins to allow redeem on behalf of other users.\\n */\\nbytes32 constant ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to manage role ROLE_SMART_VAULT_ALLOW_REDEEM.\\n */\\nbytes32 constant ADMIN_ROLE_SMART_VAULT_ALLOW_REDEEM = keccak256(\\\"ADMIN_SMART_VAULT_ALLOW_REDEEM\\\");\\n\\n/**\\n * @dev Grants permission to run do hard work.\\n */\\nbytes32 constant ROLE_DO_HARD_WORKER = keccak256(\\\"DO_HARD_WORKER\\\");\\n\\n/**\\n * @dev Grants permission to immediately withdraw assets in case of emergency.\\n */\\nbytes32 constant ROLE_EMERGENCY_WITHDRAWAL_EXECUTOR = keccak256(\\\"EMERGENCY_WITHDRAWAL_EXECUTOR\\\");\\n\\n/**\\n * @dev Grants permission to swap with swapper.\\n *\\n * Should be granted to the DepositSwap contract.\\n */\\nbytes32 constant ROLE_SWAPPER = keccak256(\\\"SWAPPER\\\");\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/interfaces/RequestType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice Different request types for guards and actions.\\n * @custom:member Deposit User is depositing into a smart vault.\\n * @custom:member Withdrawal User is requesting withdrawal from a smart vault.\\n * @custom:member TransferNFT User is transfering deposit or withdrawal NFT.\\n * @custom:member BurnNFT User is burning deposit or withdrawal NFT.\\n * @custom:member TransferSVTs User is transferring smart vault tokens.\\n */\\nenum RequestType {\\n    Deposit,\\n    Withdrawal,\\n    TransferNFT,\\n    BurnNFT,\\n    TransferSVTs\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\r\\n */\\r\\ninterface IAccessControlUpgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"create3/=lib/create3/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts-upgradeable:ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts-upgradeable:forge-std/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/src/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISpoolAccessControl\",\"name\":\"accessControl_\",\"type\":\"address\"},{\"internalType\":\"contract IAssetGroupRegistry\",\"name\":\"assetGroupRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract IRiskManager\",\"name\":\"riskManager_\",\"type\":\"address\"},{\"internalType\":\"contract IDepositManager\",\"name\":\"depositManager_\",\"type\":\"address\"},{\"internalType\":\"contract IWithdrawalManager\",\"name\":\"withdrawalManager_\",\"type\":\"address\"},{\"internalType\":\"contract IStrategyRegistry\",\"name\":\"strategyRegistry_\",\"type\":\"address\"},{\"internalType\":\"contract IMasterWallet\",\"name\":\"masterWallet_\",\"type\":\"address\"},{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"priceFeedManager_\",\"type\":\"address\"},{\"internalType\":\"contract ISmartVaultManager\",\"name\":\"smartVaultManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ghostStrategy_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"BadStrategieslength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConfigurationAddressZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MissingRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSameAssetGroup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"accessControl\",\"outputs\":[{\"internalType\":\"contract ISpoolAccessControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetGroupRegistry\",\"outputs\":[{\"internalType\":\"contract IAssetGroupRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositManager\",\"outputs\":[{\"internalType\":\"contract IDepositManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"}],\"name\":\"getSVTTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allocationProvider\",\"type\":\"address\"}],\"name\":\"getSmartVaultAllocations\",\"outputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"allocations\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"doFlush\",\"type\":\"bool\"}],\"name\":\"getSmartVaultAssetBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"getUserSVTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"getUserSVTsfromNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftSvts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ghostStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterWallet\",\"outputs\":[{\"internalType\":\"contract IMasterWallet\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedManager\",\"outputs\":[{\"internalType\":\"contract IUsdPriceFeedManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskManager\",\"outputs\":[{\"internalType\":\"contract IRiskManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVaultManager\",\"outputs\":[{\"internalType\":\"contract ISmartVaultManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyRegistry\",\"outputs\":[{\"internalType\":\"contract IStrategyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalManager\",\"outputs\":[{\"internalType\":\"contract IWithdrawalManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SpoolLens", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000007b533e72e0cdc63aacd8cdb926ac402b846fbd130000000000000000000000001aa2a802ba25669531ffd2b1ff8ae94f3d87f41a000000000000000000000000c30018cbee9c8141f620e950cc9637c7a2ef2c9e000000000000000000000000823ba38992825ff37e72b6c3d669a09173b8f7bf000000000000000000000000c62ad2c374d6537e286a06f4d6301da6cd9c6d0a000000000000000000000000554c6bcb54656390aca0a0af38ca954dbe653f15000000000000000000000000f5dcf1f6e4c661cb28c27fff88adde3522cfbe9100000000000000000000000038f1a78ad8956b45b48837657bd0884ba7ab485a00000000000000000000000023daf34e2b9af02a74dc19cb52af727b19403874000000000000000000000000c65c1df280ac96535e56b0e7ac12fe0860b19411", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}