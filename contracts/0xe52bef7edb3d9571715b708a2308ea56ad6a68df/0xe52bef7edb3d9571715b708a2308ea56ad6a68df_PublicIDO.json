{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ido/PublicIDO.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"../libraries/SafeMath.sol\\\";\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../libraries/TransferHelper.sol\\\";\\r\\n\\r\\ncontract PublicIDO {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public immutable dev;\\r\\n    address public usdt;\\r\\n    address public plexus;\\r\\n    uint256 public price;\\r\\n    uint256 public priceP2;\\r\\n    uint256 public idoStartTime;\\r\\n    uint256 public idoEndTime;\\r\\n    uint256 public idoStartTimeP2;\\r\\n    uint256 public idoEndTimeP2;\\r\\n    uint256 public lockupBlock;\\r\\n    uint256 public claimDuringBlock;\\r\\n    uint256 public plexusTotalValue;\\r\\n    uint256 public plexusTotalValueP2;\\r\\n    uint256 public usdtHardCap;\\r\\n    uint256 public usdtSoftCap;\\r\\n    uint256 public userHardCap;\\r\\n    uint256 public userSoftCap;\\r\\n    uint256 public usdtHardCapP2;\\r\\n    uint256 public usdtSoftCapP2;\\r\\n    uint256 public userHardCapP2;\\r\\n    uint256 public userSoftCapP2;\\r\\n    uint256 public usdtTotalReciveAmount;\\r\\n    uint256 public usdtTotalReciveAmountP2;\\r\\n    address[] public userAddress;\\r\\n    address[] public userAddressP2;\\r\\n    uint256 public USDT_ACC_PRECESION = 1e6;\\r\\n    uint256 public PLX_ACC_PRECESION = 1e18;\\r\\n    struct UserInfo {\\r\\n        uint256 amount;\\r\\n        uint256 amountP2;\\r\\n        uint256 totalReward;\\r\\n        uint256 lastRewardBlock;\\r\\n        uint256 recivePLX;\\r\\n    }\\r\\n\\r\\n    mapping(address => UserInfo) public userInfo;\\r\\n    mapping(address => uint256) public userId;\\r\\n    mapping(address => uint256) public userIdP2;\\r\\n    event Deposit(address user, uint256 userDepositAmount, uint256 userPLXTotalReward);\\r\\n    event Claim(address user, uint256 userClaimAmount, uint256 userRecivePLX);\\r\\n    event refund(address user, uint256 refundAmount);\\r\\n\\r\\n    constructor(address _usdt, address _plexus) public {\\r\\n        usdt = _usdt;\\r\\n        plexus = _plexus;\\r\\n        claimDuringBlock = 518400;\\r\\n        dev = msg.sender;\\r\\n    }\\r\\n\\r\\n    function init(\\r\\n        uint256 _plxTotalValue,\\r\\n        uint256 _usdtHardCap,\\r\\n        uint256 _usdtSoftCap,\\r\\n        uint256 _userHardCap,\\r\\n        uint256 _userSoftCap\\r\\n    ) public {\\r\\n        require(msg.sender == dev);\\r\\n        plexusTotalValue = _plxTotalValue;\\r\\n        usdtHardCap = _usdtHardCap;\\r\\n        usdtSoftCap = _usdtSoftCap;\\r\\n        userHardCap = _userHardCap;\\r\\n        userSoftCap = _userSoftCap;\\r\\n        price = (usdtHardCap / (plexusTotalValue / PLX_ACC_PRECESION));\\r\\n        IERC20(plexus).transferFrom(msg.sender, address(this), plexusTotalValue);\\r\\n    }\\r\\n\\r\\n    function initP2(\\r\\n        uint256 _plxTotalValueP2,\\r\\n        uint256 _usdtHardCapP2,\\r\\n        uint256 _usdtSoftCapP2,\\r\\n        uint256 _userHardCapP2,\\r\\n        uint256 _userSoftCapP2\\r\\n    ) public {\\r\\n        require(msg.sender == dev);\\r\\n        plexusTotalValueP2 = _plxTotalValueP2;\\r\\n        usdtHardCapP2 = _usdtHardCapP2;\\r\\n        usdtSoftCapP2 = _usdtSoftCapP2;\\r\\n        userHardCapP2 = _userHardCapP2;\\r\\n        userSoftCapP2 = _userSoftCapP2;\\r\\n        priceP2 = (usdtHardCapP2 / (plexusTotalValueP2 / PLX_ACC_PRECESION));\\r\\n        IERC20(plexus).transferFrom(msg.sender, address(this), plexusTotalValueP2);\\r\\n    }\\r\\n\\r\\n    function userLength() public view returns (uint256 user) {\\r\\n        return userAddress.length;\\r\\n    }\\r\\n\\r\\n    function userP2Length() public view returns (uint256 user) {\\r\\n        return userAddressP2.length;\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _userDepositAmount) public {\\r\\n        require(block.timestamp >= idoStartTime && block.timestamp <= idoEndTime, \\\"PLEXUS : This is not IDO time.\\\");\\r\\n\\r\\n        uint256 userDepositAmountInt = (_userDepositAmount / price) * price;\\r\\n\\r\\n        address depositUser = msg.sender;\\r\\n\\r\\n        require(\\r\\n            usdtHardCap.sub(usdtTotalReciveAmount) >= userDepositAmountInt,\\r\\n            \\\"PLEXUS : The deposit amount exceeds the hardcap.\\\"\\r\\n        );\\r\\n\\r\\n        TransferHelper.safeTransferFrom(usdt, depositUser, address(this), userDepositAmountInt);\\r\\n        if (userAddress.length == 0) {\\r\\n            userAddress.push(depositUser);\\r\\n            userId[depositUser] = userAddress.length - 1;\\r\\n        } else if ((userId[depositUser] == 0 && userAddress[0] != depositUser)) {\\r\\n            userAddress.push(depositUser);\\r\\n            userId[depositUser] = userAddress.length - 1;\\r\\n        }\\r\\n        UserInfo memory user = userInfo[depositUser];\\r\\n        user.amount = user.amount.add(userDepositAmountInt);\\r\\n\\r\\n        require(\\r\\n            _userDepositAmount >= userSoftCap && user.amount <= userHardCap,\\r\\n            \\\"PLEXUS : The deposit amount exceeds the hardcap.\\\"\\r\\n        );\\r\\n\\r\\n        usdtTotalReciveAmount = usdtTotalReciveAmount.add(userDepositAmountInt);\\r\\n        user.totalReward = user.totalReward.add(userDepositAmountInt.mul(PLX_ACC_PRECESION) / price);\\r\\n        userInfo[depositUser] = user;\\r\\n\\r\\n        emit Deposit(depositUser, user.amount, user.totalReward);\\r\\n    }\\r\\n\\r\\n    function depositP2(uint256 _userDepositAmount) public {\\r\\n        require(block.timestamp >= idoStartTimeP2 && block.timestamp <= idoEndTimeP2, \\\"PLEXUS : This is not IDO time.\\\");\\r\\n\\r\\n        uint256 userDepositAmountInt = (_userDepositAmount / priceP2) * priceP2;\\r\\n        address depositUser = msg.sender;\\r\\n\\r\\n        require(\\r\\n            usdtHardCapP2.sub(usdtTotalReciveAmountP2) >= userDepositAmountInt,\\r\\n            \\\"PLEXUS : The deposit amount exceeds the hardcap.\\\"\\r\\n        );\\r\\n\\r\\n        IERC20(usdt).transferFrom(depositUser, address(this), userDepositAmountInt);\\r\\n        if (userAddressP2.length == 0) {\\r\\n            userAddressP2.push(depositUser);\\r\\n            userIdP2[depositUser] = userAddressP2.length - 1;\\r\\n        } else if ((userIdP2[depositUser] == 0 && userAddressP2[0] != depositUser)) {\\r\\n            userAddressP2.push(depositUser);\\r\\n            userIdP2[depositUser] = userAddressP2.length - 1;\\r\\n        }\\r\\n        UserInfo memory user = userInfo[depositUser];\\r\\n        user.amountP2 = user.amountP2.add(userDepositAmountInt);\\r\\n\\r\\n        require(\\r\\n            _userDepositAmount >= userSoftCapP2 && user.amountP2 <= userHardCapP2,\\r\\n            \\\"PLEXUS : The deposit amount exceeds the hardcap.\\\"\\r\\n        );\\r\\n        usdtTotalReciveAmountP2 = usdtTotalReciveAmountP2.add(userDepositAmountInt);\\r\\n        user.totalReward = user.totalReward.add(userDepositAmountInt.mul(PLX_ACC_PRECESION) / priceP2);\\r\\n        userInfo[depositUser] = user;\\r\\n\\r\\n        emit Deposit(depositUser, user.amountP2, user.totalReward);\\r\\n    }\\r\\n\\r\\n    function pendingClaim(address _user) public view returns (uint256 pendingAmount) {\\r\\n        UserInfo memory user = userInfo[_user];\\r\\n        if (block.number > lockupBlock && lockupBlock != 0) {\\r\\n            uint256 claimBlock;\\r\\n            if (block.number > lockupBlock.add(claimDuringBlock)) {\\r\\n                if (user.lastRewardBlock <= lockupBlock.add(claimDuringBlock)) {\\r\\n                    pendingAmount = user.totalReward.sub(user.recivePLX);\\r\\n                } else pendingAmount = 0;\\r\\n            } else {\\r\\n                if (userInfo[_user].lastRewardBlock < lockupBlock) {\\r\\n                    claimBlock = block.number.sub(lockupBlock);\\r\\n                } else {\\r\\n                    claimBlock = block.number.sub(user.lastRewardBlock);\\r\\n                }\\r\\n                uint256 perBlock = (user.totalReward.mul(PLX_ACC_PRECESION)) / claimDuringBlock;\\r\\n                pendingAmount = claimBlock.mul(perBlock) / PLX_ACC_PRECESION;\\r\\n            }\\r\\n        } else pendingAmount = 0;\\r\\n    }\\r\\n\\r\\n    function claim(address _user) public {\\r\\n        require(block.number >= lockupBlock && lockupBlock != 0, \\\"PLEXUS : lockupBlock not set.\\\");\\r\\n        UserInfo memory user = userInfo[_user];\\r\\n\\r\\n        uint256 claimAmount = pendingClaim(_user);\\r\\n        require(claimAmount != 0, \\\"PLEXUS : There is no claimable amount.\\\");\\r\\n        if (IERC20(plexus).balanceOf(address(this)) <= claimAmount) {\\r\\n            claimAmount = IERC20(plexus).balanceOf(address(this));\\r\\n        }\\r\\n        TransferHelper.safeTransfer(plexus, _user, claimAmount);\\r\\n        user.lastRewardBlock = block.number;\\r\\n        user.recivePLX += claimAmount;\\r\\n        userInfo[_user] = user;\\r\\n\\r\\n        emit Claim(_user, claimAmount, user.recivePLX);\\r\\n    }\\r\\n\\r\\n    function close(uint256 roopStart, uint256 roopEnd) public {\\r\\n        require(msg.sender == dev);\\r\\n        require(block.timestamp > idoEndTime);\\r\\n        uint256 usdtSoftCapInt = (usdtSoftCap / price) * price;\\r\\n        if (usdtTotalReciveAmount < usdtSoftCapInt) {\\r\\n            if (roopEnd >= userAddress.length) {\\r\\n                roopEnd = userAddress.length;\\r\\n            }\\r\\n            for (roopStart; roopStart < roopEnd; roopStart++) {\\r\\n                UserInfo memory user = userInfo[userAddress[roopStart]];\\r\\n                if (user.amount != 0) {\\r\\n                    TransferHelper.safeTransfer(usdt, userAddress[roopStart], user.amount);\\r\\n                    user.totalReward = user.totalReward.sub(user.amount.mul(PLX_ACC_PRECESION) / price);\\r\\n                    emit refund(userAddress[roopStart], user.amount);\\r\\n                    usdtTotalReciveAmount -= user.amount;\\r\\n                    user.amount = 0;\\r\\n                    userInfo[userAddress[roopStart]] = user;\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            TransferHelper.safeTransfer(usdt, dev, usdtTotalReciveAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function closeP2(uint256 roopStart, uint256 roopEnd) public {\\r\\n        require(msg.sender == dev);\\r\\n        require(block.timestamp > idoEndTime);\\r\\n        uint256 usdtSoftCapInt = (usdtSoftCapP2 / priceP2) * priceP2;\\r\\n        if (usdtTotalReciveAmountP2 < usdtSoftCapInt) {\\r\\n            if (roopEnd >= userAddressP2.length) {\\r\\n                roopEnd = userAddressP2.length;\\r\\n            }\\r\\n            for (roopStart; roopStart < roopEnd; roopStart++) {\\r\\n                UserInfo memory user = userInfo[userAddressP2[roopStart]];\\r\\n                if (user.amountP2 != 0) {\\r\\n                    TransferHelper.safeTransfer(usdt, userAddressP2[roopStart], user.amountP2);\\r\\n                    user.totalReward = user.totalReward.sub(user.amountP2.mul(PLX_ACC_PRECESION) / priceP2);\\r\\n                    emit refund(userAddressP2[roopStart], user.amountP2);\\r\\n                    usdtTotalReciveAmountP2 -= user.amountP2;\\r\\n                    user.amountP2 = 0;\\r\\n                    userInfo[userAddressP2[roopStart]] = user;\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            TransferHelper.safeTransfer(usdt, dev, usdtTotalReciveAmountP2);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function emergencyWithdraw() public {\\r\\n        require(msg.sender == dev);\\r\\n        TransferHelper.safeTransfer(plexus, dev, IERC20(plexus).balanceOf(address(this)));\\r\\n        TransferHelper.safeTransfer(usdt, dev, IERC20(usdt).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function setLockupBlock(uint256 _launchingBlock) public {\\r\\n        require(msg.sender == dev);\\r\\n        // ( lunchingBlock + 1month)\\r\\n        lockupBlock = _launchingBlock.add(172800);\\r\\n    }\\r\\n\\r\\n    function setIdoTime(uint256 _startTime, uint256 _endTime) public {\\r\\n        require(msg.sender == dev);\\r\\n        idoStartTime = _startTime;\\r\\n        idoEndTime = _endTime;\\r\\n    }\\r\\n\\r\\n    function setIdoTimeP2(uint256 _startTime, uint256 _endTime) public {\\r\\n        require(msg.sender == dev);\\r\\n        idoStartTimeP2 = _startTime;\\r\\n        idoEndTimeP2 = _endTime;\\r\\n    }\\r\\n\\r\\n    function idoClosePlxWithdraw() public {\\r\\n        require(msg.sender == dev);\\r\\n        uint256 plxWithdrawAmount = plexusTotalValue.sub((usdtTotalReciveAmount / price) * PLX_ACC_PRECESION);\\r\\n        TransferHelper.safeTransfer(plexus, dev, plxWithdrawAmount);\\r\\n    }\\r\\n\\r\\n    function idoClosePlxWithdrawP2() public {\\r\\n        require(msg.sender == dev);\\r\\n        uint256 plxWithdrawAmount = plexusTotalValueP2.sub((usdtTotalReciveAmountP2 / priceP2) * PLX_ACC_PRECESION);\\r\\n        TransferHelper.safeTransfer(plexus, dev, plxWithdrawAmount);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.12;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c < a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b > a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: APPROVE_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper: TRANSFER_FROM_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\r\\n        require(success, \\\"TransferHelper: KLAY_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_plexus\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userClaimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userRecivePLX\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userDepositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userPLXTotalReward\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PLX_ACC_PRECESION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT_ACC_PRECESION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDuringBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roopStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roopEnd\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roopStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roopEnd\",\"type\":\"uint256\"}],\"name\":\"closeP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userDepositAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userDepositAmount\",\"type\":\"uint256\"}],\"name\":\"depositP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoClosePlxWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoClosePlxWithdrawP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoEndTimeP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoStartTimeP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plxTotalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdtHardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdtSoftCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userHardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userSoftCap\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plxTotalValueP2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdtHardCapP2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdtSoftCapP2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userHardCapP2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userSoftCapP2\",\"type\":\"uint256\"}],\"name\":\"initP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plexus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plexusTotalValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plexusTotalValueP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setIdoTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setIdoTimeP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_launchingBlock\",\"type\":\"uint256\"}],\"name\":\"setLockupBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtHardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtHardCapP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtSoftCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtSoftCapP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtTotalReciveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtTotalReciveAmountP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressP2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userHardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userHardCapP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIdP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountP2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recivePLX\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"user\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userP2Length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"user\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userSoftCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userSoftCapP2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PublicIDO", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000060b9c9c167ba57cc376b0faafc68df5c9882328e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}