{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StaticPercentageFeeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"IFeeHandler.sol\\\";\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"FixedPoint.sol\\\";\\n\\nimport \\\"Governable.sol\\\";\\n\\ncontract StaticPercentageFeeHandler is IFeeHandler, Governable {\\n    using FixedPoint for uint256;\\n\\n    /// @notice Mint and redeem fees cannot be above 20%\\n    uint64 public constant MAX_FEE = 0.2e18;\\n\\n    /// @notice holds the mint and redeem fees for a single vault\\n    struct Fees {\\n        bool exists;\\n        uint64 mint;\\n        uint64 redeem;\\n    }\\n\\n    /// @notice mapping from vault to fees\\n    mapping(address => Fees) public vaultFees;\\n\\n    constructor(address _governor) Governable(_governor) {}\\n\\n    /// @notice set the fees for a vault\\n    function setVaultFees(\\n        address vault,\\n        uint64 mintFee,\\n        uint64 redeemFee\\n    ) external governanceOnly {\\n        require(vault != address(0), Errors.INVALID_ARGUMENT);\\n        require(mintFee <= MAX_FEE && redeemFee <= MAX_FEE, Errors.INVALID_ARGUMENT);\\n        vaultFees[vault] = Fees({exists: true, mint: mintFee, redeem: redeemFee});\\n    }\\n\\n    /// @inheritdoc IFeeHandler\\n    function isVaultSupported(address vaultAddress) external view override returns (bool) {\\n        return vaultFees[vaultAddress].exists;\\n    }\\n\\n    /// @inheritdoc IFeeHandler\\n    function applyFees(DataTypes.Order memory order)\\n        external\\n        view\\n        override\\n        returns (DataTypes.Order memory)\\n    {\\n        DataTypes.VaultWithAmount[] memory vaultsWithAmount = new DataTypes.VaultWithAmount[](\\n            order.vaultsWithAmount.length\\n        );\\n        for (uint256 i = 0; i < order.vaultsWithAmount.length; i++) {\\n            address vaultAddress = order.vaultsWithAmount[i].vaultInfo.vault;\\n            Fees memory fees = vaultFees[vaultAddress];\\n            require(fees.exists, Errors.INVALID_ARGUMENT);\\n            uint256 feeMultiplier = FixedPoint.ONE - (order.mint ? fees.mint : fees.redeem);\\n            uint256 amountAfterFees = order.vaultsWithAmount[i].amount.mulDown(feeMultiplier);\\n            vaultsWithAmount[i] = DataTypes.VaultWithAmount({\\n                vaultInfo: order.vaultsWithAmount[i].vaultInfo,\\n                amount: amountAfterFees\\n            });\\n        }\\n\\n        return DataTypes.Order(vaultsWithAmount, order.mint);\\n    }\\n}\\n\"\r\n    },\r\n    \"IFeeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface IFeeHandler {\\n    /// @return an order with the fees applied\\n    function applyFees(DataTypes.Order memory order) external view returns (DataTypes.Order memory);\\n\\n    /// @return if the given vault is supported\\n    function isVaultSupported(address vaultAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Contains the data structures to express token routing\\nlibrary DataTypes {\\n    /// @notice Contains a token and the amount associated with it\\n    struct MonetaryAmount {\\n        address tokenAddress;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Contains a token and the price associated with it\\n    /// @dev The price range is only relevant for stablecoins\\n    struct PricedToken {\\n        address tokenAddress;\\n        bool isStable;\\n        uint256 price;\\n        Range priceRange;\\n    }\\n\\n    /// @notice A route from/to a token to a vault\\n    /// This is used to determine in which vault the token should be deposited\\n    /// or from which vault it should be withdrawn\\n    struct TokenToVaultMapping {\\n        address inputToken;\\n        address vault;\\n    }\\n\\n    /// @notice Asset used to mint\\n    struct MintAsset {\\n        address inputToken;\\n        uint256 inputAmount;\\n        address destinationVault;\\n    }\\n\\n    /// @notice Asset to redeem\\n    struct RedeemAsset {\\n        address outputToken;\\n        uint256 minOutputAmount;\\n        uint256 valueRatio;\\n        address originVault;\\n    }\\n\\n    /// @notice Persisted metadata about the vault\\n    struct PersistedVaultMetadata {\\n        uint256 priceAtCalibration;\\n        uint256 weightAtCalibration;\\n        uint256 shortFlowMemory;\\n        uint256 shortFlowThreshold;\\n        uint64 weightTransitionDuration;\\n        uint64 weightAtPreviousCalibration;\\n        uint64 timeOfCalibration;\\n    }\\n\\n    /// @notice Directional (in or out) flow data for the vaults\\n    struct DirectionalFlowData {\\n        uint128 shortFlow;\\n        uint64 lastSafetyBlock;\\n        uint64 lastSeenBlock;\\n    }\\n\\n    /// @notice Bidirectional vault flow data\\n    struct FlowData {\\n        DirectionalFlowData inFlow;\\n        DirectionalFlowData outFlow;\\n    }\\n\\n    /// @notice Vault flow direction\\n    enum Direction {\\n        In,\\n        Out,\\n        Both\\n    }\\n\\n    /// @notice Vault address and direction for Oracle Guardian\\n    struct GuardedVaults {\\n        address vaultAddress;\\n        Direction direction;\\n    }\\n\\n    /// @notice Vault with metadata\\n    struct VaultInfo {\\n        address vault;\\n        uint8 decimals;\\n        address underlying;\\n        uint256 price;\\n        PersistedVaultMetadata persistedMetadata;\\n        uint256 reserveBalance;\\n        uint256 currentWeight;\\n        uint256 targetWeight;\\n        PricedToken[] pricedTokens;\\n    }\\n\\n    /// @notice Vault metadata\\n    struct VaultMetadata {\\n        address vault;\\n        uint256 targetWeight;\\n        uint256 currentWeight;\\n        uint256 resultingWeight;\\n        uint256 price;\\n        bool allStablecoinsOnPeg;\\n        bool atLeastOnePriceLargeEnough;\\n        bool vaultWithinEpsilon;\\n        PricedToken[] pricedTokens;\\n    }\\n\\n    /// @notice Metadata to contain vaults metadata\\n    struct Metadata {\\n        VaultMetadata[] vaultMetadata;\\n        bool allVaultsWithinEpsilon;\\n        bool allStablecoinsAllVaultsOnPeg;\\n        bool allVaultsUsingLargeEnoughPrices;\\n        bool mint;\\n    }\\n\\n    /// @notice Mint or redeem order struct\\n    struct Order {\\n        VaultWithAmount[] vaultsWithAmount;\\n        bool mint;\\n    }\\n\\n    /// @notice Vault info with associated amount for order operation\\n    struct VaultWithAmount {\\n        VaultInfo vaultInfo;\\n        uint256 amount;\\n    }\\n\\n    /// @notice state of the reserve (i.e., all the vaults)\\n    struct ReserveState {\\n        uint256 totalUSDValue;\\n        VaultInfo[] vaults;\\n    }\\n\\n    struct VaultConfiguration {\\n        address vaultAddress;\\n        DataTypes.PersistedVaultMetadata metadata;\\n    }\\n\\n    struct Range {\\n        uint256 floor;\\n        uint256 ceiling;\\n    }\\n\\n    /// @notice Action executed by calling `target` passing in `data`\\n    struct ExternalAction {\\n        address target;\\n        bytes data;\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Defines different errors emitted by Gyroscope contracts\\nlibrary Errors {\\n    string public constant TOKEN_AND_AMOUNTS_LENGTH_DIFFER = \\\"1\\\";\\n    string public constant TOO_MUCH_SLIPPAGE = \\\"2\\\";\\n    string public constant EXCHANGER_NOT_FOUND = \\\"3\\\";\\n    string public constant POOL_IDS_NOT_FOUND = \\\"4\\\";\\n    string public constant WOULD_UNBALANCE_GYROSCOPE = \\\"5\\\";\\n    string public constant VAULT_ALREADY_EXISTS = \\\"6\\\";\\n    string public constant VAULT_NOT_FOUND = \\\"7\\\";\\n\\n    string public constant X_OUT_OF_BOUNDS = \\\"20\\\";\\n    string public constant Y_OUT_OF_BOUNDS = \\\"21\\\";\\n    string public constant PRODUCT_OUT_OF_BOUNDS = \\\"22\\\";\\n    string public constant INVALID_EXPONENT = \\\"23\\\";\\n    string public constant OUT_OF_BOUNDS = \\\"24\\\";\\n    string public constant ZERO_DIVISION = \\\"25\\\";\\n    string public constant ADD_OVERFLOW = \\\"26\\\";\\n    string public constant SUB_OVERFLOW = \\\"27\\\";\\n    string public constant MUL_OVERFLOW = \\\"28\\\";\\n    string public constant DIV_INTERNAL = \\\"29\\\";\\n\\n    // User errors\\n    string public constant NOT_AUTHORIZED = \\\"30\\\";\\n    string public constant INVALID_ARGUMENT = \\\"31\\\";\\n    string public constant KEY_NOT_FOUND = \\\"32\\\";\\n    string public constant KEY_FROZEN = \\\"33\\\";\\n    string public constant INSUFFICIENT_BALANCE = \\\"34\\\";\\n    string public constant INVALID_ASSET = \\\"35\\\";\\n    string public constant FORBIDDEN_EXTERNAL_ACTION = \\\"35\\\";\\n\\n    // Oracle related errors\\n    string public constant ASSET_NOT_SUPPORTED = \\\"40\\\";\\n    string public constant STALE_PRICE = \\\"41\\\";\\n    string public constant NEGATIVE_PRICE = \\\"42\\\";\\n    string public constant INVALID_MESSAGE = \\\"43\\\";\\n    string public constant TOO_MUCH_VOLATILITY = \\\"44\\\";\\n    string public constant WETH_ADDRESS_NOT_FIRST = \\\"44\\\";\\n    string public constant ROOT_PRICE_NOT_GROUNDED = \\\"45\\\";\\n    string public constant NOT_ENOUGH_TWAPS = \\\"46\\\";\\n    string public constant ZERO_PRICE_TWAP = \\\"47\\\";\\n    string public constant INVALID_NUMBER_WEIGHTS = \\\"48\\\";\\n    string public constant NO_WETH_PRICE = \\\"49\\\";\\n\\n    //Vault safety check related errors\\n    string public constant A_VAULT_HAS_ALL_STABLECOINS_OFF_PEG = \\\"51\\\";\\n    string public constant NOT_SAFE_TO_MINT = \\\"52\\\";\\n    string public constant NOT_SAFE_TO_REDEEM = \\\"53\\\";\\n    string public constant AMOUNT_AND_PRICE_LENGTH_DIFFER = \\\"54\\\";\\n    string public constant TOKEN_PRICES_TOO_SMALL = \\\"55\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_VAULT_CONTAINS = \\\"56\\\";\\n    string public constant CALLER_NOT_MOTHERBOARD = \\\"57\\\";\\n    string public constant CALLER_NOT_RESERVE_MANAGER = \\\"58\\\";\\n    string public constant VAULT_CANNOT_BE_REMOVED = \\\"59\\\";\\n\\n    string public constant VAULT_FLOW_TOO_HIGH = \\\"60\\\";\\n    string public constant OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED = \\\"61\\\";\\n    string public constant ORACLE_GUARDIAN_TIME_LIMIT = \\\"62\\\";\\n    string public constant NOT_ENOUGH_FLOW_DATA = \\\"63\\\";\\n    string public constant SUPPLY_CAP_EXCEEDED = \\\"64\\\";\\n    string public constant SAFETY_MODE_ACTIVATED = \\\"65\\\";\\n\\n    // misc errors\\n    string public constant REDEEM_AMOUNT_BUG = \\\"100\\\";\\n    string public constant EXTERNAL_ACTION_FAILED = \\\"101\\\";\\n    string public constant TOKENS_NOT_SORTED = \\\"102\\\";\\n    string public constant NO_SHARES_MINTED = \\\"103\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_SUPPLY = \\\"104\\\";\\n}\\n\"\r\n    },\r\n    \"FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"LogExpMath.sol\\\";\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a - b : b - a;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function squareUp(uint256 a) internal pure returns (uint256) {\\n        return mulUp(a, a);\\n    }\\n\\n    function squareDown(uint256 a) internal pure returns (uint256) {\\n        return mulDown(a, a);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            unchecked {\\n                return ((aInflated - 1) / b) + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return raw - maxError;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        return raw + maxError;\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n\\n    /**\\n     * @dev returns the minimum between x and y\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /**\\n     * @dev returns the maximum between x and y\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @notice This is taken from the Balancer V1 code base.\\n     * Computes a**b where a is a scaled fixed-point number and b is an integer\\n     * The computation is performed in O(log n)\\n     */\\n    function intPowDown(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        uint256 result = FixedPoint.ONE;\\n        while (exp > 0) {\\n            if (exp % 2 == 1) {\\n                result = mulDown(result, base);\\n            }\\n            exp /= 2;\\n            base = mulDown(base, base);\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) *\\n                    y_int256 +\\n                    ((ln_36_x % ONE_18) * y_int256) /\\n                    ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n                Errors.PRODUCT_OUT_OF_BOUNDS\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n        unchecked {\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        unchecked {\\n            // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n            // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n            // upscaling.\\n\\n            int256 logBase;\\n            if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n                logBase = _ln_36(base);\\n            } else {\\n                logBase = _ln(base) * ONE_18;\\n            }\\n\\n            int256 logArg;\\n            if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n                logArg = _ln_36(arg);\\n            } else {\\n                logArg = _ln(arg) * ONE_18;\\n            }\\n\\n            // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n            return (logArg * ONE_18) / logBase;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, Errors.OUT_OF_BOUNDS);\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        return pow(x, uint256(ONE_18) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"GovernableBase.sol\\\";\\n\\ncontract Governable is GovernableBase {\\n    constructor(address _governor) {\\n        governor = _governor;\\n        emit GovernorChanged(address(0), _governor);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"IGovernable.sol\\\";\\n\\ncontract GovernableBase is IGovernable {\\n    address public override governor;\\n    address public override pendingGovernor;\\n\\n    modifier governanceOnly() {\\n        require(msg.sender == governor, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function changeGovernor(address newGovernor) external override governanceOnly {\\n        require(address(newGovernor) != address(0), Errors.INVALID_ARGUMENT);\\n        pendingGovernor = newGovernor;\\n        emit GovernorChangeRequested(newGovernor);\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function acceptGovernance() external override {\\n        require(msg.sender == pendingGovernor, Errors.NOT_AUTHORIZED);\\n        address currentGovernor = governor;\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n        emit GovernorChanged(currentGovernor, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IGovernable {\\n    /// @notice Emmited when the governor is changed\\n    event GovernorChanged(address oldGovernor, address newGovernor);\\n\\n    /// @notice Emmited when the governor is change is requested\\n    event GovernorChangeRequested(address newGovernor);\\n\\n    /// @notice Returns the current governor\\n    function governor() external view returns (address);\\n\\n    /// @notice Returns the pending governor\\n    function pendingGovernor() external view returns (address);\\n\\n    /// @notice Changes the governor\\n    /// can only be called by the current governor\\n    function changeGovernor(address newGovernor) external;\\n\\n    /// @notice Called by the pending governor to approve the change\\n    function acceptGovernance() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"StaticPercentageFeeHandler.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"applyFees\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"isVaultSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"mintFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"redeemFee\",\"type\":\"uint64\"}],\"name\":\"setVaultFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"mint\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"redeem\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StaticPercentageFeeHandler", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f244fcaff67a2f98eaec20a44caf079a7f7a1d4", "EVMVersion": "london", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}