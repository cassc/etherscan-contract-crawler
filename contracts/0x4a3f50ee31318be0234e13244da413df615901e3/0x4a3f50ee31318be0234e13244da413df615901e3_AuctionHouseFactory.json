{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/AuctionHouseFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.6.7;\\n\\nimport {IncreasingDiscountCollateralAuctionHouse} from \\\"geb/single/CollateralAuctionHouse.sol\\\";\\n\\ncontract AuctionHouseFactory {\\n    function deploy(\\n        address safeEngine,\\n        address liquidationEngine,\\n        bytes32 collateralType,\\n        address owner\\n    ) external returns (address) {\\n        IncreasingDiscountCollateralAuctionHouse auctionHouse = new IncreasingDiscountCollateralAuctionHouse(\\n                safeEngine,\\n                liquidationEngine,\\n                collateralType\\n            );\\n        auctionHouse.addAuthorization(owner);\\n        auctionHouse.removeAuthorization(address(this));\\n        return address(auctionHouse);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/geb/src/single/CollateralAuctionHouse.sol\": {\r\n      \"content\": \"/// EnglishCollateralAuctionHouse.sol\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity 0.6.7;\\r\\n\\r\\nabstract contract SAFEEngineLike {\\r\\n    function transferInternalCoins(address,address,uint256) virtual external;\\r\\n    function transferCollateral(bytes32,address,address,uint256) virtual external;\\r\\n}\\r\\nabstract contract OracleRelayerLike {\\r\\n    function redemptionPrice() virtual public returns (uint256);\\r\\n    function lastRedemptionPrice() virtual public view returns (uint256);\\r\\n}\\r\\nabstract contract OracleLike {\\r\\n    function priceSource() virtual public view returns (address);\\r\\n    function getResultWithValidity() virtual public view returns (uint256, bool);\\r\\n}\\r\\nabstract contract LiquidationEngineLike {\\r\\n    function removeCoinsFromAuction(uint256) virtual public;\\r\\n}\\r\\n\\r\\n/*\\r\\n   This thing lets you (English) auction some collateral for a given amount of system coins\\r\\n*/\\r\\n\\r\\ncontract EnglishCollateralAuctionHouse {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public authorizedAccounts;\\r\\n    /**\\r\\n     * @notice Add auth to an account\\r\\n     * @param account Account to add auth to\\r\\n     */\\r\\n    function addAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 1;\\r\\n        emit AddAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Remove auth from an account\\r\\n     * @param account Account to remove auth from\\r\\n     */\\r\\n    function removeAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 0;\\r\\n        emit RemoveAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Checks whether msg.sender can call an authed function\\r\\n    **/\\r\\n    modifier isAuthorized {\\r\\n        require(authorizedAccounts[msg.sender] == 1, \\\"EnglishCollateralAuctionHouse/account-not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        // Bid size (how many coins are offered per collateral sold)\\r\\n        uint256 bidAmount;                                                                                            // [rad]\\r\\n        // How much collateral is sold in an auction\\r\\n        uint256 amountToSell;                                                                                         // [wad]\\r\\n        // Who the high bidder is\\r\\n        address highBidder;\\r\\n        // When the latest bid expires and the auction can be settled\\r\\n        uint48  bidExpiry;                                                                                            // [unix epoch time]\\r\\n        // Hard deadline for the auction after which no more bids can be placed\\r\\n        uint48  auctionDeadline;                                                                                      // [unix epoch time]\\r\\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\\r\\n        address forgoneCollateralReceiver;\\r\\n        // Who receives the coins raised from the auction; usually the accounting engine\\r\\n        address auctionIncomeRecipient;\\r\\n        // Total/max amount of coins to raise\\r\\n        uint256 amountToRaise;                                                                                        // [rad]\\r\\n    }\\r\\n\\r\\n    // Bid data for each separate auction\\r\\n    mapping (uint256 => Bid) public bids;\\r\\n\\r\\n    // SAFE database\\r\\n    SAFEEngineLike public safeEngine;\\r\\n    // Collateral type name\\r\\n    bytes32       public collateralType;\\r\\n\\r\\n    uint256  constant ONE = 1.00E18;                                                                                  // [wad]\\r\\n    // Minimum bid increase compared to the last bid in order to take the new one in consideration\\r\\n    uint256  public   bidIncrease = 1.05E18;                                                                          // [wad]\\r\\n    // How long the auction lasts after a new bid is submitted\\r\\n    uint48   public   bidDuration = 3 hours;                                                                          // [seconds]\\r\\n    // Total length of the auction\\r\\n    uint48   public   totalAuctionLength = 2 days;                                                                    // [seconds]\\r\\n    // Number of auctions started up until now\\r\\n    uint256  public   auctionsStarted = 0;\\r\\n\\r\\n    LiquidationEngineLike public liquidationEngine;\\r\\n\\r\\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\\\"COLLATERAL\\\");\\r\\n    bytes32 public constant AUCTION_TYPE       = bytes32(\\\"ENGLISH\\\");\\r\\n\\r\\n    // --- Events ---\\r\\n    event AddAuthorization(address account);\\r\\n    event RemoveAuthorization(address account);\\r\\n    event StartAuction(\\r\\n        uint256 id,\\r\\n        uint256 auctionsStarted,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid,\\r\\n        uint256 indexed amountToRaise,\\r\\n        address indexed forgoneCollateralReceiver,\\r\\n        address indexed auctionIncomeRecipient,\\r\\n        uint256 auctionDeadline\\r\\n    );\\r\\n    event ModifyParameters(bytes32 parameter, uint256 data);\\r\\n    event ModifyParameters(bytes32 parameter, address data);\\r\\n    event RestartAuction(uint256 indexed id, uint256 auctionDeadline);\\r\\n    event IncreaseBidSize(uint256 indexed id, address highBidder, uint256 amountToBuy, uint256 rad, uint256 bidExpiry);\\r\\n    event DecreaseSoldAmount(uint256 indexed id, address highBidder, uint256 amountToBuy, uint256 rad, uint256 bidExpiry);\\r\\n    event SettleAuction(uint256 indexed id);\\r\\n    event TerminateAuctionPrematurely(uint256 indexed id, address sender, uint256 bidAmount, uint256 collateralAmount);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\\r\\n        safeEngine = SAFEEngineLike(safeEngine_);\\r\\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\\r\\n        collateralType = collateralType_;\\r\\n        authorizedAccounts[msg.sender] = 1;\\r\\n        emit AddAuthorization(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x, \\\"EnglishCollateralAuctionHouse/add-uint48-overflow\\\");\\r\\n    }\\r\\n    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"EnglishCollateralAuctionHouse/mul-overflow\\\");\\r\\n    }\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    function wmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = multiply(x, y) / WAD;\\r\\n    }\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function rdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y > 0, \\\"EnglishCollateralAuctionHouse/division-by-zero\\\");\\r\\n        z = multiply(x, RAY) / y;\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    /**\\r\\n     * @notice Modify an uint256 parameter\\r\\n     * @param parameter The name of the parameter modified\\r\\n     * @param data New value for the parameter\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\\r\\n        if (parameter == \\\"bidIncrease\\\") bidIncrease = data;\\r\\n        else if (parameter == \\\"bidDuration\\\") bidDuration = uint48(data);\\r\\n        else if (parameter == \\\"totalAuctionLength\\\") totalAuctionLength = uint48(data);\\r\\n        else revert(\\\"EnglishCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Modify an address parameter\\r\\n     * @param parameter The name of the contract whose address we modify\\r\\n     * @param data New contract address\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\\r\\n        if (parameter == \\\"liquidationEngine\\\") liquidationEngine = LiquidationEngineLike(data);\\r\\n        else revert(\\\"EnglishCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n    /**\\r\\n     * @notice Start a new collateral auction\\r\\n     * @param forgoneCollateralReceiver Address that receives leftover collateral that is not auctioned\\r\\n     * @param auctionIncomeRecipient Address that receives the amount of system coins raised by the auction\\r\\n     * @param amountToRaise Total amount of coins to raise (rad)\\r\\n     * @param amountToSell Total amount of collateral available to sell (wad)\\r\\n     * @param initialBid Initial bid size (usually zero in this implementation) (rad)\\r\\n     */\\r\\n    function startAuction(\\r\\n        address forgoneCollateralReceiver,\\r\\n        address auctionIncomeRecipient,\\r\\n        uint256 amountToRaise,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid\\r\\n    ) public isAuthorized returns (uint256 id)\\r\\n    {\\r\\n        require(auctionsStarted < uint256(-1), \\\"EnglishCollateralAuctionHouse/overflow\\\");\\r\\n        require(amountToSell > 0, \\\"EnglishCollateralAuctionHouse/null-amount-sold\\\");\\r\\n        id = ++auctionsStarted;\\r\\n\\r\\n        bids[id].bidAmount = initialBid;\\r\\n        bids[id].amountToSell = amountToSell;\\r\\n        bids[id].highBidder = msg.sender;\\r\\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\\r\\n        bids[id].forgoneCollateralReceiver = forgoneCollateralReceiver;\\r\\n        bids[id].auctionIncomeRecipient = auctionIncomeRecipient;\\r\\n        bids[id].amountToRaise = amountToRaise;\\r\\n\\r\\n        safeEngine.transferCollateral(collateralType, msg.sender, address(this), amountToSell);\\r\\n\\r\\n        emit StartAuction(\\r\\n          id,\\r\\n          auctionsStarted,\\r\\n          amountToSell,\\r\\n          initialBid,\\r\\n          amountToRaise,\\r\\n          forgoneCollateralReceiver,\\r\\n          auctionIncomeRecipient,\\r\\n          bids[id].auctionDeadline\\r\\n        );\\r\\n    }\\r\\n    /**\\r\\n     * @notice Restart an auction if no bids were submitted for it\\r\\n     * @param id ID of the auction to restart\\r\\n     */\\r\\n    function restartAuction(uint256 id) external {\\r\\n        require(bids[id].auctionDeadline < now, \\\"EnglishCollateralAuctionHouse/not-finished\\\");\\r\\n        require(bids[id].bidExpiry == 0, \\\"EnglishCollateralAuctionHouse/bid-already-placed\\\");\\r\\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\\r\\n        emit RestartAuction(id, bids[id].auctionDeadline);\\r\\n    }\\r\\n    /**\\r\\n     * @notice First auction phase: submit a higher bid for the same amount of collateral\\r\\n     * @param id ID of the auction you want to submit the bid for\\r\\n     * @param amountToBuy Amount of collateral to buy (wad)\\r\\n     * @param rad New bid submitted (rad)\\r\\n     */\\r\\n    function increaseBidSize(uint256 id, uint256 amountToBuy, uint256 rad) external {\\r\\n        require(bids[id].highBidder != address(0), \\\"EnglishCollateralAuctionHouse/high-bidder-not-set\\\");\\r\\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \\\"EnglishCollateralAuctionHouse/bid-already-expired\\\");\\r\\n        require(bids[id].auctionDeadline > now, \\\"EnglishCollateralAuctionHouse/auction-already-expired\\\");\\r\\n\\r\\n        require(amountToBuy == bids[id].amountToSell, \\\"EnglishCollateralAuctionHouse/amounts-not-matching\\\");\\r\\n        require(rad <= bids[id].amountToRaise, \\\"EnglishCollateralAuctionHouse/higher-than-amount-to-raise\\\");\\r\\n        require(rad >  bids[id].bidAmount, \\\"EnglishCollateralAuctionHouse/new-bid-not-higher\\\");\\r\\n        require(multiply(rad, ONE) >= multiply(bidIncrease, bids[id].bidAmount) || rad == bids[id].amountToRaise, \\\"EnglishCollateralAuctionHouse/insufficient-increase\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].highBidder) {\\r\\n            safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, bids[id].bidAmount);\\r\\n            bids[id].highBidder = msg.sender;\\r\\n        }\\r\\n        safeEngine.transferInternalCoins(msg.sender, bids[id].auctionIncomeRecipient, rad - bids[id].bidAmount);\\r\\n\\r\\n        bids[id].bidAmount = rad;\\r\\n        bids[id].bidExpiry = addUint48(uint48(now), bidDuration);\\r\\n\\r\\n        emit IncreaseBidSize(id, msg.sender, amountToBuy, rad, bids[id].bidExpiry);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Second auction phase: decrease the collateral amount you're willing to receive in\\r\\n     *         exchange for providing the same amount of coins as the winning bid\\r\\n     * @param id ID of the auction for which you want to submit a new amount of collateral to buy\\r\\n     * @param amountToBuy Amount of collateral to buy (must be smaller than the previous proposed amount) (wad)\\r\\n     * @param rad New bid submitted; must be equal to the winning bid from the increaseBidSize phase (rad)\\r\\n     */\\r\\n    function decreaseSoldAmount(uint256 id, uint256 amountToBuy, uint256 rad) external {\\r\\n        require(bids[id].highBidder != address(0), \\\"EnglishCollateralAuctionHouse/high-bidder-not-set\\\");\\r\\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \\\"EnglishCollateralAuctionHouse/bid-already-expired\\\");\\r\\n        require(bids[id].auctionDeadline > now, \\\"EnglishCollateralAuctionHouse/auction-already-expired\\\");\\r\\n\\r\\n        require(rad == bids[id].bidAmount, \\\"EnglishCollateralAuctionHouse/not-matching-bid\\\");\\r\\n        require(rad == bids[id].amountToRaise, \\\"EnglishCollateralAuctionHouse/bid-increase-not-finished\\\");\\r\\n        require(amountToBuy < bids[id].amountToSell, \\\"EnglishCollateralAuctionHouse/amount-bought-not-lower\\\");\\r\\n        require(multiply(bidIncrease, amountToBuy) <= multiply(bids[id].amountToSell, ONE), \\\"EnglishCollateralAuctionHouse/insufficient-decrease\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].highBidder) {\\r\\n            safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, rad);\\r\\n            bids[id].highBidder = msg.sender;\\r\\n        }\\r\\n        safeEngine.transferCollateral(\\r\\n          collateralType,\\r\\n          address(this),\\r\\n          bids[id].forgoneCollateralReceiver,\\r\\n          bids[id].amountToSell - amountToBuy\\r\\n        );\\r\\n\\r\\n        bids[id].amountToSell = amountToBuy;\\r\\n        bids[id].bidExpiry    = addUint48(uint48(now), bidDuration);\\r\\n\\r\\n        emit DecreaseSoldAmount(id, msg.sender, amountToBuy, rad, bids[id].bidExpiry);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Settle/finish an auction\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function settleAuction(uint256 id) external {\\r\\n        require(bids[id].bidExpiry != 0 && (bids[id].bidExpiry < now || bids[id].auctionDeadline < now), \\\"EnglishCollateralAuctionHouse/not-finished\\\");\\r\\n        safeEngine.transferCollateral(collateralType, address(this), bids[id].highBidder, bids[id].amountToSell);\\r\\n        liquidationEngine.removeCoinsFromAuction(bids[id].amountToRaise);\\r\\n        delete bids[id];\\r\\n        emit SettleAuction(id);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Terminate an auction prematurely (if it's still in the first phase).\\r\\n     *         Usually called by Global Settlement.\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function terminateAuctionPrematurely(uint256 id) external isAuthorized {\\r\\n        require(bids[id].highBidder != address(0), \\\"EnglishCollateralAuctionHouse/high-bidder-not-set\\\");\\r\\n        require(bids[id].bidAmount < bids[id].amountToRaise, \\\"EnglishCollateralAuctionHouse/already-decreasing-sold-amount\\\");\\r\\n        liquidationEngine.removeCoinsFromAuction(bids[id].amountToRaise);\\r\\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, bids[id].amountToSell);\\r\\n        safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, bids[id].bidAmount);\\r\\n        emit TerminateAuctionPrematurely(id, msg.sender, bids[id].bidAmount, bids[id].amountToSell);\\r\\n        delete bids[id];\\r\\n    }\\r\\n\\r\\n    // --- Getters ---\\r\\n    function bidAmount(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].bidAmount;\\r\\n    }\\r\\n    function remainingAmountToSell(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].amountToSell;\\r\\n    }\\r\\n    function forgoneCollateralReceiver(uint256 id) public view returns (address) {\\r\\n        return bids[id].forgoneCollateralReceiver;\\r\\n    }\\r\\n    function raisedAmount(uint256 id) public view returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n    function amountToRaise(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].amountToRaise;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// FixedDiscountCollateralAuctionHouse.sol\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>, 2020 Reflexer Labs, INC\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\n/*\\r\\n   This thing lets you sell some collateral at a fixed discount in order to instantly recapitalize the system\\r\\n*/\\r\\n\\r\\ncontract FixedDiscountCollateralAuctionHouse {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public authorizedAccounts;\\r\\n    /**\\r\\n     * @notice Add auth to an account\\r\\n     * @param account Account to add auth to\\r\\n     */\\r\\n    function addAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 1;\\r\\n        emit AddAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Remove auth from an account\\r\\n     * @param account Account to remove auth from\\r\\n     */\\r\\n    function removeAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 0;\\r\\n        emit RemoveAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Checks whether msg.sender can call an authed function\\r\\n    **/\\r\\n    modifier isAuthorized {\\r\\n        require(authorizedAccounts[msg.sender] == 1, \\\"FixedDiscountCollateralAuctionHouse/account-not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        // System coins raised up until now\\r\\n        uint256 raisedAmount;                                                                                         // [rad]\\r\\n        // Amount of collateral that has been sold up until now\\r\\n        uint256 soldAmount;                                                                                           // [wad]\\r\\n        // How much collateral is sold in an auction\\r\\n        uint256 amountToSell;                                                                                         // [wad]\\r\\n        // Total/max amount of coins to raise\\r\\n        uint256 amountToRaise;                                                                                        // [rad]\\r\\n        // Duration of time after which the auction can be settled\\r\\n        uint48  auctionDeadline;                                                                                      // [unix epoch time]\\r\\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\\r\\n        address forgoneCollateralReceiver;\\r\\n        // Who receives the coins raised by the auction; usually the accounting engine\\r\\n        address auctionIncomeRecipient;\\r\\n    }\\r\\n\\r\\n    // Bid data for each separate auction\\r\\n    mapping (uint256 => Bid) public bids;\\r\\n\\r\\n    // SAFE database\\r\\n    SAFEEngineLike public safeEngine;\\r\\n    // Collateral type name\\r\\n    bytes32       public collateralType;\\r\\n\\r\\n    // Minimum acceptable bid\\r\\n    uint256  public   minimumBid = 5 * WAD;                                                                           // [wad]\\r\\n    // Total length of the auction. Kept to adhere to the same interface as the English auction but redundant\\r\\n    uint48   public   totalAuctionLength = uint48(-1);                                                                // [seconds]\\r\\n    // Number of auctions started up until now\\r\\n    uint256  public   auctionsStarted = 0;\\r\\n    // The last read redemption price\\r\\n    uint256  public   lastReadRedemptionPrice;\\r\\n    // Discount (compared to the system coin's current redemption price) at which collateral is being sold\\r\\n    uint256  public   discount = 0.95E18;                         // 5% discount                                      // [wad]\\r\\n    // Max lower bound deviation that the collateral median can have compared to the FSM price\\r\\n    uint256  public   lowerCollateralMedianDeviation = 0.90E18;   // 10% deviation                                    // [wad]\\r\\n    // Max upper bound deviation that the collateral median can have compared to the FSM price\\r\\n    uint256  public   upperCollateralMedianDeviation = 0.95E18;   // 5% deviation                                     // [wad]\\r\\n    // Max lower bound deviation that the system coin oracle price feed can have compared to the systemCoinOracle price\\r\\n    uint256  public   lowerSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\\r\\n    // Max upper bound deviation that the system coin oracle price feed can have compared to the systemCoinOracle price\\r\\n    uint256  public   upperSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\\r\\n    // Min deviation for the system coin median result compared to the redemption price in order to take the median into account\\r\\n    uint256  public   minSystemCoinMedianDeviation   = 0.999E18;                                                      // [wad]\\r\\n\\r\\n    OracleRelayerLike     public oracleRelayer;\\r\\n    OracleLike            public collateralFSM;\\r\\n    OracleLike            public systemCoinOracle;\\r\\n    LiquidationEngineLike public liquidationEngine;\\r\\n\\r\\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\\\"COLLATERAL\\\");\\r\\n    bytes32 public constant AUCTION_TYPE       = bytes32(\\\"FIXED_DISCOUNT\\\");\\r\\n\\r\\n    // --- Events ---\\r\\n    event AddAuthorization(address account);\\r\\n    event RemoveAuthorization(address account);\\r\\n    event StartAuction(\\r\\n        uint256 id,\\r\\n        uint256 auctionsStarted,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid,\\r\\n        uint256 indexed amountToRaise,\\r\\n        address indexed forgoneCollateralReceiver,\\r\\n        address indexed auctionIncomeRecipient,\\r\\n        uint256 auctionDeadline\\r\\n    );\\r\\n    event ModifyParameters(bytes32 parameter, uint256 data);\\r\\n    event ModifyParameters(bytes32 parameter, address data);\\r\\n    event BuyCollateral(uint256 indexed id, uint256 wad, uint256 boughtCollateral);\\r\\n    event SettleAuction(uint256 indexed id, uint256 leftoverCollateral);\\r\\n    event TerminateAuctionPrematurely(uint256 indexed id, address sender, uint256 collateralAmount);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\\r\\n        safeEngine = SAFEEngineLike(safeEngine_);\\r\\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\\r\\n        collateralType = collateralType_;\\r\\n        authorizedAccounts[msg.sender] = 1;\\r\\n        emit AddAuthorization(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x, \\\"FixedDiscountCollateralAuctionHouse/add-uint48-overflow\\\");\\r\\n    }\\r\\n    function addUint256(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x, \\\"FixedDiscountCollateralAuctionHouse/add-uint256-overflow\\\");\\r\\n    }\\r\\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x, \\\"FixedDiscountCollateralAuctionHouse/sub-underflow\\\");\\r\\n    }\\r\\n    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"FixedDiscountCollateralAuctionHouse/mul-overflow\\\");\\r\\n    }\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    function wmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = multiply(x, y) / WAD;\\r\\n    }\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function rdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y > 0, \\\"FixedDiscountCollateralAuctionHouse/rdiv-by-zero\\\");\\r\\n        z = multiply(x, RAY) / y;\\r\\n    }\\r\\n    function wdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y > 0, \\\"FixedDiscountCollateralAuctionHouse/wdiv-by-zero\\\");\\r\\n        z = multiply(x, WAD) / y;\\r\\n    }\\r\\n    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = (x <= y) ? x : y;\\r\\n    }\\r\\n    function maximum(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = (x >= y) ? x : y;\\r\\n    }\\r\\n\\r\\n    // --- General Utils ---\\r\\n    function either(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := or(x, y)}\\r\\n    }\\r\\n    function both(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := and(x, y)}\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    /**\\r\\n     * @notice Modify an uint256 parameter\\r\\n     * @param parameter The name of the parameter modified\\r\\n     * @param data New value for the parameter\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\\r\\n        if (parameter == \\\"discount\\\") {\\r\\n            require(data < WAD, \\\"FixedDiscountCollateralAuctionHouse/no-discount-offered\\\");\\r\\n            discount = data;\\r\\n        }\\r\\n        else if (parameter == \\\"lowerCollateralMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"FixedDiscountCollateralAuctionHouse/invalid-lower-collateral-median-deviation\\\");\\r\\n            lowerCollateralMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"upperCollateralMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"FixedDiscountCollateralAuctionHouse/invalid-upper-collateral-median-deviation\\\");\\r\\n            upperCollateralMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"lowerSystemCoinMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"FixedDiscountCollateralAuctionHouse/invalid-lower-system-coin-median-deviation\\\");\\r\\n            lowerSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"upperSystemCoinMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"FixedDiscountCollateralAuctionHouse/invalid-upper-system-coin-median-deviation\\\");\\r\\n            upperSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"minSystemCoinMedianDeviation\\\") {\\r\\n            minSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"minimumBid\\\") {\\r\\n            minimumBid = data;\\r\\n        }\\r\\n        else revert(\\\"FixedDiscountCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Modify an address parameter\\r\\n     * @param parameter The name of the contract address being updated\\r\\n     * @param data New address for the oracle contract\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\\r\\n        if (parameter == \\\"oracleRelayer\\\") oracleRelayer = OracleRelayerLike(data);\\r\\n        else if (parameter == \\\"collateralFSM\\\") {\\r\\n          collateralFSM = OracleLike(data);\\r\\n          // Check that priceSource() is implemented\\r\\n          collateralFSM.priceSource();\\r\\n        }\\r\\n        else if (parameter == \\\"systemCoinOracle\\\") systemCoinOracle = OracleLike(data);\\r\\n        else if (parameter == \\\"liquidationEngine\\\") liquidationEngine = LiquidationEngineLike(data);\\r\\n        else revert(\\\"FixedDiscountCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n\\r\\n    // --- Private Auction Utils ---\\r\\n    /*\\r\\n    * @notify Get the amount of bought collateral from a specific auction using custom collateral price feeds and a system coin price feed\\r\\n    * @param id The ID of the auction to bid in and get collateral from\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the oracle median\\r\\n    * @param systemCoinPriceFeedValue The system coin market price fetched from the oracle\\r\\n    * @param adjustedBid The system coin bid\\r\\n    */\\r\\n    function getBoughtCollateral(\\r\\n        uint256 id,\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue,\\r\\n        uint256 systemCoinPriceFeedValue,\\r\\n        uint256 adjustedBid\\r\\n    ) private view returns (uint256) {\\r\\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\\r\\n        uint256 discountedCollateralPrice =\\r\\n          getDiscountedCollateralPrice(\\r\\n            collateralFsmPriceFeedValue,\\r\\n            collateralMedianPriceFeedValue,\\r\\n            systemCoinPriceFeedValue,\\r\\n            discount\\r\\n          );\\r\\n        // calculate the amount of collateral bought\\r\\n        uint256 boughtCollateral = wdivide(adjustedBid, discountedCollateralPrice);\\r\\n        // if the calculated collateral amount exceeds the amount still up for sale, adjust it to the remaining amount\\r\\n        boughtCollateral = (boughtCollateral > subtract(bids[id].amountToSell, bids[id].soldAmount)) ?\\r\\n                           subtract(bids[id].amountToSell, bids[id].soldAmount) : boughtCollateral;\\r\\n\\r\\n        return boughtCollateral;\\r\\n    }\\r\\n\\r\\n    // --- Public Auction Utils ---\\r\\n    /*\\r\\n    * @notice Fetch the collateral median price (from the oracle, not FSM)\\r\\n    * @returns The collateral price from the oracle median; zero if the address of the collateralMedian (as fetched from the FSM) is null\\r\\n    */\\r\\n    function getCollateralMedianPrice() public view returns (uint256 priceFeed) {\\r\\n        // Fetch the collateral median address from the collateral FSM\\r\\n        address collateralMedian;\\r\\n        try collateralFSM.priceSource() returns (address median) {\\r\\n          collateralMedian = median;\\r\\n        } catch (bytes memory revertReason) {}\\r\\n\\r\\n        if (collateralMedian == address(0)) return 0;\\r\\n\\r\\n        // wrapped call toward the collateral median\\r\\n        try OracleLike(collateralMedian).getResultWithValidity()\\r\\n          returns (uint256 price, bool valid) {\\r\\n          if (valid) {\\r\\n            priceFeed = uint256(price);\\r\\n          }\\r\\n        } catch (bytes memory revertReason) {\\r\\n          return 0;\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Fetch the system coin market price\\r\\n    * @returns The system coin market price fetch from the oracle\\r\\n    */\\r\\n    function getSystemCoinMarketPrice() public view returns (uint256 priceFeed) {\\r\\n        if (address(systemCoinOracle) == address(0)) return 0;\\r\\n\\r\\n        // wrapped call toward the system coin oracle\\r\\n        try systemCoinOracle.getResultWithValidity()\\r\\n          returns (uint256 price, bool valid) {\\r\\n          if (valid) {\\r\\n            priceFeed = uint256(price) * 10 ** 9; // scale to RAY\\r\\n          }\\r\\n        } catch (bytes memory revertReason) {\\r\\n          return 0;\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the smallest possible price that's at max lowerSystemCoinMedianDeviation deviated from the redemption price and at least\\r\\n    *         minSystemCoinMedianDeviation deviated\\r\\n    */\\r\\n    function getSystemCoinFloorDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 floorPrice) {\\r\\n        uint256 minFloorDeviatedPrice = wmultiply(redemptionPrice, minSystemCoinMedianDeviation);\\r\\n        floorPrice = wmultiply(redemptionPrice, lowerSystemCoinMedianDeviation);\\r\\n        floorPrice = (floorPrice <= minFloorDeviatedPrice) ? floorPrice : redemptionPrice;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the highest possible price that's at max upperSystemCoinMedianDeviation deviated from the redemption price and at least\\r\\n    *         minSystemCoinMedianDeviation deviated\\r\\n    */\\r\\n    function getSystemCoinCeilingDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 ceilingPrice) {\\r\\n        uint256 minCeilingDeviatedPrice = wmultiply(redemptionPrice, subtract(2 * WAD, minSystemCoinMedianDeviation));\\r\\n        ceilingPrice = wmultiply(redemptionPrice, subtract(2 * WAD, upperSystemCoinMedianDeviation));\\r\\n        ceilingPrice = (ceilingPrice >= minCeilingDeviatedPrice) ? ceilingPrice : redemptionPrice;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the collateral price from the FSM and the final system coin price that will be used when bidding in an auction\\r\\n    * @param systemCoinRedemptionPrice The system coin redemption price\\r\\n    * @returns The collateral price from the FSM and the final system coin price used for bidding (picking between redemption and market prices)\\r\\n    */\\r\\n    function getCollateralFSMAndFinalSystemCoinPrices(uint256 systemCoinRedemptionPrice) public view returns (uint256, uint256) {\\r\\n        require(systemCoinRedemptionPrice > 0, \\\"FixedDiscountCollateralAuctionHouse/invalid-redemption-price-provided\\\");\\r\\n        (uint256 collateralFsmPriceFeedValue, bool collateralFsmHasValidValue) = collateralFSM.getResultWithValidity();\\r\\n        if (!collateralFsmHasValidValue) {\\r\\n          return (0, 0);\\r\\n        }\\r\\n\\r\\n        uint256 systemCoinAdjustedPrice  = systemCoinRedemptionPrice;\\r\\n        uint256 systemCoinPriceFeedValue = getSystemCoinMarketPrice();\\r\\n\\r\\n        if (systemCoinPriceFeedValue > 0) {\\r\\n          uint256 floorPrice   = getSystemCoinFloorDeviatedPrice(systemCoinAdjustedPrice);\\r\\n          uint256 ceilingPrice = getSystemCoinCeilingDeviatedPrice(systemCoinAdjustedPrice);\\r\\n\\r\\n          if (uint(systemCoinPriceFeedValue) < systemCoinAdjustedPrice) {\\r\\n            systemCoinAdjustedPrice = maximum(uint256(systemCoinPriceFeedValue), floorPrice);\\r\\n          } else {\\r\\n            systemCoinAdjustedPrice = minimum(uint256(systemCoinPriceFeedValue), ceilingPrice);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        return (uint256(collateralFsmPriceFeedValue), systemCoinAdjustedPrice);\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the collateral price used in bidding by picking between the raw FSM and the oracle median price and taking into account\\r\\n    *         deviation limits\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the median attached to the FSM\\r\\n    */\\r\\n    function getFinalBaseCollateralPrice(\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 floorPrice   = wmultiply(collateralFsmPriceFeedValue, lowerCollateralMedianDeviation);\\r\\n        uint256 ceilingPrice = wmultiply(collateralFsmPriceFeedValue, subtract(2 * WAD, upperCollateralMedianDeviation));\\r\\n\\r\\n        uint256 adjustedMedianPrice = (collateralMedianPriceFeedValue == 0) ?\\r\\n          collateralFsmPriceFeedValue : collateralMedianPriceFeedValue;\\r\\n\\r\\n        if (adjustedMedianPrice < collateralFsmPriceFeedValue) {\\r\\n          return maximum(adjustedMedianPrice, floorPrice);\\r\\n        } else {\\r\\n          return minimum(adjustedMedianPrice, ceilingPrice);\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the discounted collateral price (using a custom discount)\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the oracle median\\r\\n    * @param systemCoinPriceFeedValue The system coin price fetched from the oracle\\r\\n    * @param customDiscount The custom discount used to calculate the collateral price offered\\r\\n    */\\r\\n    function getDiscountedCollateralPrice(\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue,\\r\\n        uint256 systemCoinPriceFeedValue,\\r\\n        uint256 customDiscount\\r\\n    ) public view returns (uint256) {\\r\\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\\r\\n        return wmultiply(\\r\\n          rdivide(getFinalBaseCollateralPrice(collateralFsmPriceFeedValue, collateralMedianPriceFeedValue), systemCoinPriceFeedValue),\\r\\n          customDiscount\\r\\n        );\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the actual bid that will be used in an auction (taking into account the bidder input)\\r\\n    * @param id The id of the auction to calculate the adjusted bid for\\r\\n    * @param wad The initial bid submitted\\r\\n    * @returns Whether the bid is valid or not and the adjusted bid\\r\\n    */\\r\\n    function getAdjustedBid(\\r\\n        uint256 id, uint256 wad\\r\\n    ) public view returns (bool, uint256) {\\r\\n        if (either(\\r\\n          either(bids[id].amountToSell == 0, bids[id].amountToRaise == 0),\\r\\n          either(wad == 0, wad < minimumBid)\\r\\n        )) {\\r\\n          return (false, wad);\\r\\n        }\\r\\n\\r\\n        uint256 remainingToRaise = subtract(bids[id].amountToRaise, bids[id].raisedAmount);\\r\\n\\r\\n        // bound max amount offered in exchange for collateral\\r\\n        uint256 adjustedBid = wad;\\r\\n        if (multiply(adjustedBid, RAY) > remainingToRaise) {\\r\\n            adjustedBid = addUint256(remainingToRaise / RAY, 1);\\r\\n        }\\r\\n\\r\\n        remainingToRaise = subtract(bids[id].amountToRaise, bids[id].raisedAmount);\\r\\n        if (both(remainingToRaise > 0, remainingToRaise < RAY)) {\\r\\n            return (false, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (true, adjustedBid);\\r\\n    }\\r\\n\\r\\n    // --- Core Auction Logic ---\\r\\n    /**\\r\\n     * @notice Start a new collateral auction\\r\\n     * @param forgoneCollateralReceiver Who receives leftover collateral that is not auctioned\\r\\n     * @param auctionIncomeRecipient Who receives the amount raised in the auction\\r\\n     * @param amountToRaise Total amount of coins to raise (rad)\\r\\n     * @param amountToSell Total amount of collateral available to sell (wad)\\r\\n     * @param initialBid Unused\\r\\n     */\\r\\n    function startAuction(\\r\\n        address forgoneCollateralReceiver,\\r\\n        address auctionIncomeRecipient,\\r\\n        uint256 amountToRaise,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid\\r\\n    ) public isAuthorized returns (uint256 id) {\\r\\n        require(auctionsStarted < uint256(-1), \\\"FixedDiscountCollateralAuctionHouse/overflow\\\");\\r\\n        require(amountToSell > 0, \\\"FixedDiscountCollateralAuctionHouse/no-collateral-for-sale\\\");\\r\\n        require(amountToRaise > 0, \\\"FixedDiscountCollateralAuctionHouse/nothing-to-raise\\\");\\r\\n        require(amountToRaise >= RAY, \\\"FixedDiscountCollateralAuctionHouse/dusty-auction\\\");\\r\\n        id = ++auctionsStarted;\\r\\n\\r\\n        bids[id].auctionDeadline = uint48(-1);\\r\\n        bids[id].amountToSell = amountToSell;\\r\\n        bids[id].forgoneCollateralReceiver = forgoneCollateralReceiver;\\r\\n        bids[id].auctionIncomeRecipient = auctionIncomeRecipient;\\r\\n        bids[id].amountToRaise = amountToRaise;\\r\\n\\r\\n        safeEngine.transferCollateral(collateralType, msg.sender, address(this), amountToSell);\\r\\n\\r\\n        emit StartAuction(\\r\\n          id,\\r\\n          auctionsStarted,\\r\\n          amountToSell,\\r\\n          initialBid,\\r\\n          amountToRaise,\\r\\n          forgoneCollateralReceiver,\\r\\n          auctionIncomeRecipient,\\r\\n          bids[id].auctionDeadline\\r\\n        );\\r\\n    }\\r\\n    /**\\r\\n     * @notice Calculate how much collateral someone would buy from an auction using the last read redemption price\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted\\r\\n     */\\r\\n    function getApproximateCollateralBought(uint256 id, uint256 wad) external view returns (uint256, uint256) {\\r\\n        if (lastReadRedemptionPrice == 0) return (0, wad);\\r\\n\\r\\n        (bool validAuctionAndBid, uint256 adjustedBid) = getAdjustedBid(id, wad);\\r\\n        if (!validAuctionAndBid) {\\r\\n            return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        // check that the oracle doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices(lastReadRedemptionPrice);\\r\\n        if (collateralFsmPriceFeedValue == 0) {\\r\\n          return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (getBoughtCollateral(\\r\\n          id,\\r\\n          collateralFsmPriceFeedValue,\\r\\n          getCollateralMedianPrice(),\\r\\n          systemCoinPriceFeedValue,\\r\\n          adjustedBid\\r\\n        ), adjustedBid);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Calculate how much collateral someone would buy from an auction using the latest redemption price fetched from the OracleRelayer\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted\\r\\n     */\\r\\n    function getCollateralBought(uint256 id, uint256 wad) external returns (uint256, uint256) {\\r\\n        (bool validAuctionAndBid, uint256 adjustedBid) = getAdjustedBid(id, wad);\\r\\n        if (!validAuctionAndBid) {\\r\\n            return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        // Read the redemption price\\r\\n        lastReadRedemptionPrice = oracleRelayer.redemptionPrice();\\r\\n\\r\\n        // check that the oracle doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices(lastReadRedemptionPrice);\\r\\n        if (collateralFsmPriceFeedValue == 0) {\\r\\n          return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (getBoughtCollateral(\\r\\n          id,\\r\\n          collateralFsmPriceFeedValue,\\r\\n          getCollateralMedianPrice(),\\r\\n          systemCoinPriceFeedValue,\\r\\n          adjustedBid\\r\\n        ), adjustedBid);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Buy collateral from an auction at a fixed discount\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted (as a WAD which has 18 decimals)\\r\\n     */\\r\\n    function buyCollateral(uint256 id, uint256 wad) external {\\r\\n        require(both(bids[id].amountToSell > 0, bids[id].amountToRaise > 0), \\\"FixedDiscountCollateralAuctionHouse/inexistent-auction\\\");\\r\\n\\r\\n        uint256 remainingToRaise = subtract(bids[id].amountToRaise, bids[id].raisedAmount);\\r\\n        require(both(wad > 0, wad >= minimumBid), \\\"FixedDiscountCollateralAuctionHouse/invalid-bid\\\");\\r\\n\\r\\n        // bound max amount offered in exchange for collateral (in case someone offers more than is necessary)\\r\\n        uint256 adjustedBid = wad;\\r\\n        if (multiply(adjustedBid, RAY) > remainingToRaise) {\\r\\n            adjustedBid = addUint256(remainingToRaise / RAY, 1);\\r\\n        }\\r\\n\\r\\n        // update amount raised\\r\\n        bids[id].raisedAmount = addUint256(bids[id].raisedAmount, multiply(adjustedBid, RAY));\\r\\n\\r\\n        // check that there's at least RAY left to raise if raisedAmount < amountToRaise\\r\\n        if (bids[id].raisedAmount < bids[id].amountToRaise) {\\r\\n            require(subtract(bids[id].amountToRaise, bids[id].raisedAmount) >= RAY, \\\"FixedDiscountCollateralAuctionHouse/invalid-left-to-raise\\\");\\r\\n        }\\r\\n\\r\\n        // Read the redemption price\\r\\n        lastReadRedemptionPrice = oracleRelayer.redemptionPrice();\\r\\n\\r\\n        // check that the collateral FSM doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices(lastReadRedemptionPrice);\\r\\n        require(collateralFsmPriceFeedValue > 0, \\\"FixedDiscountCollateralAuctionHouse/collateral-fsm-invalid-value\\\");\\r\\n\\r\\n        // get the amount of collateral bought\\r\\n        uint256 boughtCollateral = getBoughtCollateral(\\r\\n          id, collateralFsmPriceFeedValue, getCollateralMedianPrice(), systemCoinPriceFeedValue, adjustedBid\\r\\n        );\\r\\n        // check that the calculated amount is greater than zero\\r\\n        require(boughtCollateral > 0, \\\"FixedDiscountCollateralAuctionHouse/null-bought-amount\\\");\\r\\n        // update the amount of collateral already sold\\r\\n        bids[id].soldAmount = addUint256(bids[id].soldAmount, boughtCollateral);\\r\\n\\r\\n        // transfer the bid to the income recipient and the collateral to the bidder\\r\\n        safeEngine.transferInternalCoins(msg.sender, bids[id].auctionIncomeRecipient, multiply(adjustedBid, RAY));\\r\\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, boughtCollateral);\\r\\n\\r\\n        // Emit the buy event\\r\\n        emit BuyCollateral(id, adjustedBid, boughtCollateral);\\r\\n\\r\\n        // Remove coins from the liquidation buffer\\r\\n        bool soldAll = either(bids[id].amountToRaise <= bids[id].raisedAmount, bids[id].amountToSell == bids[id].soldAmount);\\r\\n        if (soldAll) {\\r\\n          liquidationEngine.removeCoinsFromAuction(remainingToRaise);\\r\\n        } else {\\r\\n          liquidationEngine.removeCoinsFromAuction(multiply(adjustedBid, RAY));\\r\\n        }\\r\\n\\r\\n        // If the auction raised the whole amount or all collateral was sold,\\r\\n        // send remaining collateral back to the forgone receiver\\r\\n        if (soldAll) {\\r\\n            uint256 leftoverCollateral = subtract(bids[id].amountToSell, bids[id].soldAmount);\\r\\n            safeEngine.transferCollateral(collateralType, address(this), bids[id].forgoneCollateralReceiver, leftoverCollateral);\\r\\n            delete bids[id];\\r\\n            emit SettleAuction(id, leftoverCollateral);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice Settle/finish an auction\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function settleAuction(uint256 id) external {\\r\\n        return;\\r\\n    }\\r\\n    /**\\r\\n     * @notice Terminate an auction prematurely. Usually called by Global Settlement.\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function terminateAuctionPrematurely(uint256 id) external isAuthorized {\\r\\n        require(both(bids[id].amountToSell > 0, bids[id].amountToRaise > 0), \\\"FixedDiscountCollateralAuctionHouse/inexistent-auction\\\");\\r\\n        uint256 leftoverCollateral = subtract(bids[id].amountToSell, bids[id].soldAmount);\\r\\n        liquidationEngine.removeCoinsFromAuction(subtract(bids[id].amountToRaise, bids[id].raisedAmount));\\r\\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, leftoverCollateral);\\r\\n        delete bids[id];\\r\\n        emit TerminateAuctionPrematurely(id, msg.sender, leftoverCollateral);\\r\\n    }\\r\\n\\r\\n    // --- Getters ---\\r\\n    function bidAmount(uint256 id) public view returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n    function remainingAmountToSell(uint256 id) public view returns (uint256) {\\r\\n        return subtract(bids[id].amountToSell, bids[id].soldAmount);\\r\\n    }\\r\\n    function forgoneCollateralReceiver(uint256 id) public view returns (address) {\\r\\n        return bids[id].forgoneCollateralReceiver;\\r\\n    }\\r\\n    function raisedAmount(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].raisedAmount;\\r\\n    }\\r\\n    function amountToRaise(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].amountToRaise;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// IncreasingDiscountCollateralAuctionHouse.sol\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>, 2020 Reflexer Labs, INC\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\n/*\\r\\n   This thing lets you sell some collateral at an increasing discount in order to instantly recapitalize the system\\r\\n*/\\r\\n\\r\\ncontract IncreasingDiscountCollateralAuctionHouse {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint256) public authorizedAccounts;\\r\\n    /**\\r\\n     * @notice Add auth to an account\\r\\n     * @param account Account to add auth to\\r\\n     */\\r\\n    function addAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 1;\\r\\n        emit AddAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Remove auth from an account\\r\\n     * @param account Account to remove auth from\\r\\n     */\\r\\n    function removeAuthorization(address account) external isAuthorized {\\r\\n        authorizedAccounts[account] = 0;\\r\\n        emit RemoveAuthorization(account);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Checks whether msg.sender can call an authed function\\r\\n    **/\\r\\n    modifier isAuthorized {\\r\\n        require(authorizedAccounts[msg.sender] == 1, \\\"IncreasingDiscountCollateralAuctionHouse/account-not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        // How much collateral is sold in an auction\\r\\n        uint256 amountToSell;                                                                                         // [wad]\\r\\n        // Total/max amount of coins to raise\\r\\n        uint256 amountToRaise;                                                                                        // [rad]\\r\\n        // Current discount\\r\\n        uint256 currentDiscount;                                                                                      // [wad]\\r\\n        // Max possibe discount\\r\\n        uint256 maxDiscount;                                                                                          // [wad]\\r\\n        // Rate at which the discount is updated every second\\r\\n        uint256 perSecondDiscountUpdateRate;                                                                          // [ray]\\r\\n        // Last time when the current discount was updated\\r\\n        uint256 latestDiscountUpdateTime;                                                                             // [unix timestamp]\\r\\n        // Deadline after which the discount cannot increase anymore\\r\\n        uint48  discountIncreaseDeadline;                                                                             // [unix epoch time]\\r\\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\\r\\n        address forgoneCollateralReceiver;\\r\\n        // Who receives the coins raised by the auction; usually the accounting engine\\r\\n        address auctionIncomeRecipient;\\r\\n    }\\r\\n\\r\\n    // Bid data for each separate auction\\r\\n    mapping (uint256 => Bid) public bids;\\r\\n\\r\\n    // SAFE database\\r\\n    SAFEEngineLike public safeEngine;\\r\\n    // Collateral type name\\r\\n    bytes32        public collateralType;\\r\\n\\r\\n    // Minimum acceptable bid\\r\\n    uint256  public   minimumBid = 5 * WAD;                                                                           // [wad]\\r\\n    // Total length of the auction. Kept to adhere to the same interface as the English auction but redundant\\r\\n    uint48   public   totalAuctionLength = uint48(-1);                                                                // [seconds]\\r\\n    // Number of auctions started up until now\\r\\n    uint256  public   auctionsStarted = 0;\\r\\n    // Minimum discount (compared to the system coin's current redemption price) at which collateral is being sold\\r\\n    uint256  public   minDiscount = 1E18;                      // 0% discount                                         // [wad]\\r\\n    // Maximum discount (compared to the system coin's current redemption price) at which collateral is being sold\\r\\n    uint256  public   maxDiscount = 0.80E18;                      // 20% discount                                     // [wad]\\r\\n    // Rate at which the discount will be updated in an auction\\r\\n    uint256  public   perSecondDiscountUpdateRate = RAY;                                                              // [ray]\\r\\n    // Max time over which the discount can be updated\\r\\n    uint256  public   maxDiscountUpdateRateTimeline  = 1 hours;                                                       // [seconds]\\r\\n    // Max lower bound deviation that the collateral median can have compared to the FSM price\\r\\n    uint256  public   lowerCollateralMedianDeviation = 0.90E18;   // 10% deviation                                    // [wad]\\r\\n    // Max upper bound deviation that the collateral median can have compared to the FSM price\\r\\n    uint256  public   upperCollateralMedianDeviation = 0.95E18;   // 5% deviation                                     // [wad]\\r\\n    // Max lower bound deviation that the system coin oracle price feed can have compared to the systemCoinOracle price\\r\\n    uint256  public   lowerSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\\r\\n    // Max upper bound deviation that the system coin oracle price feed can have compared to the systemCoinOracle price\\r\\n    uint256  public   upperSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\\r\\n    // Min deviation for the system coin median result compared to the redemption price in order to take the median into account\\r\\n    uint256  public   minSystemCoinMedianDeviation   = 0.999E18;                                                      // [wad]\\r\\n\\r\\n    OracleRelayerLike     public oracleRelayer;\\r\\n    OracleLike            public collateralFSM;\\r\\n    OracleLike            public systemCoinOracle;\\r\\n    LiquidationEngineLike public liquidationEngine;\\r\\n\\r\\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\\\"COLLATERAL\\\");\\r\\n    bytes32 public constant AUCTION_TYPE       = bytes32(\\\"INCREASING_DISCOUNT\\\");\\r\\n\\r\\n    // --- Events ---\\r\\n    event AddAuthorization(address account);\\r\\n    event RemoveAuthorization(address account);\\r\\n    event StartAuction(\\r\\n        uint256 id,\\r\\n        uint256 auctionsStarted,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid,\\r\\n        uint256 indexed amountToRaise,\\r\\n        uint256 startingDiscount,\\r\\n        uint256 maxDiscount,\\r\\n        uint256 perSecondDiscountUpdateRate,\\r\\n        uint48  discountIncreaseDeadline,\\r\\n        address indexed forgoneCollateralReceiver,\\r\\n        address indexed auctionIncomeRecipient\\r\\n    );\\r\\n    event ModifyParameters(bytes32 parameter, uint256 data);\\r\\n    event ModifyParameters(bytes32 parameter, address data);\\r\\n    event BuyCollateral(uint256 indexed id, uint256 wad, uint256 boughtCollateral);\\r\\n    event SettleAuction(uint256 indexed id, uint256 leftoverCollateral);\\r\\n    event TerminateAuctionPrematurely(uint256 indexed id, address sender, uint256 collateralAmount);\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\\r\\n        safeEngine = SAFEEngineLike(safeEngine_);\\r\\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\\r\\n        collateralType = collateralType_;\\r\\n        authorizedAccounts[msg.sender] = 1;\\r\\n        emit AddAuthorization(msg.sender);\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x, \\\"IncreasingDiscountCollateralAuctionHouse/add-uint48-overflow\\\");\\r\\n    }\\r\\n    function addUint256(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x + y) >= x, \\\"IncreasingDiscountCollateralAuctionHouse/add-uint256-overflow\\\");\\r\\n    }\\r\\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require((z = x - y) <= x, \\\"IncreasingDiscountCollateralAuctionHouse/sub-underflow\\\");\\r\\n    }\\r\\n    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y == 0 || (z = x * y) / y == x, \\\"IncreasingDiscountCollateralAuctionHouse/mul-overflow\\\");\\r\\n    }\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    function wmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = multiply(x, y) / WAD;\\r\\n    }\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n    function rdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y > 0, \\\"IncreasingDiscountCollateralAuctionHouse/rdiv-by-zero\\\");\\r\\n        z = multiply(x, RAY) / y;\\r\\n    }\\r\\n    function rmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = x * y;\\r\\n        require(y == 0 || z / y == x, \\\"IncreasingDiscountCollateralAuctionHouse/rmul-overflow\\\");\\r\\n        z = z / RAY;\\r\\n    }\\r\\n    function wdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        require(y > 0, \\\"IncreasingDiscountCollateralAuctionHouse/wdiv-by-zero\\\");\\r\\n        z = multiply(x, WAD) / y;\\r\\n    }\\r\\n    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = (x <= y) ? x : y;\\r\\n    }\\r\\n    function maximum(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        z = (x >= y) ? x : y;\\r\\n    }\\r\\n    function rpower(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\\r\\n      assembly {\\r\\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\\r\\n        default {\\r\\n          switch mod(n, 2) case 0 { z := b } default { z := x }\\r\\n          let half := div(b, 2)  // for rounding.\\r\\n          for { n := div(n, 2) } n { n := div(n,2) } {\\r\\n            let xx := mul(x, x)\\r\\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\\r\\n            let xxRound := add(xx, half)\\r\\n            if lt(xxRound, xx) { revert(0,0) }\\r\\n            x := div(xxRound, b)\\r\\n            if mod(n,2) {\\r\\n              let zx := mul(z, x)\\r\\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\\r\\n              let zxRound := add(zx, half)\\r\\n              if lt(zxRound, zx) { revert(0,0) }\\r\\n              z := div(zxRound, b)\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // --- General Utils ---\\r\\n    function either(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := or(x, y)}\\r\\n    }\\r\\n    function both(bool x, bool y) internal pure returns (bool z) {\\r\\n        assembly{ z := and(x, y)}\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    /**\\r\\n     * @notice Modify an uint256 parameter\\r\\n     * @param parameter The name of the parameter to modify\\r\\n     * @param data New value for the parameter\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\\r\\n        if (parameter == \\\"minDiscount\\\") {\\r\\n            require(both(data >= maxDiscount, data <= WAD), \\\"IncreasingDiscountCollateralAuctionHouse/invalid-min-discount\\\");\\r\\n            minDiscount = data;\\r\\n        }\\r\\n        else if (parameter == \\\"maxDiscount\\\") {\\r\\n            require(both(both(data <= minDiscount, data < WAD), data > 0), \\\"IncreasingDiscountCollateralAuctionHouse/invalid-max-discount\\\");\\r\\n            maxDiscount = data;\\r\\n        }\\r\\n        else if (parameter == \\\"perSecondDiscountUpdateRate\\\") {\\r\\n            require(data <= RAY, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-discount-update-rate\\\");\\r\\n            perSecondDiscountUpdateRate = data;\\r\\n        }\\r\\n        else if (parameter == \\\"maxDiscountUpdateRateTimeline\\\") {\\r\\n            require(both(data > 0, uint256(uint48(-1)) > addUint256(now, data)), \\\"IncreasingDiscountCollateralAuctionHouse/invalid-update-rate-time\\\");\\r\\n            maxDiscountUpdateRateTimeline = data;\\r\\n        }\\r\\n        else if (parameter == \\\"lowerCollateralMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-lower-collateral-median-deviation\\\");\\r\\n            lowerCollateralMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"upperCollateralMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-upper-collateral-median-deviation\\\");\\r\\n            upperCollateralMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"lowerSystemCoinMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-lower-system-coin-median-deviation\\\");\\r\\n            lowerSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"upperSystemCoinMedianDeviation\\\") {\\r\\n            require(data <= WAD, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-upper-system-coin-median-deviation\\\");\\r\\n            upperSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"minSystemCoinMedianDeviation\\\") {\\r\\n            minSystemCoinMedianDeviation = data;\\r\\n        }\\r\\n        else if (parameter == \\\"minimumBid\\\") {\\r\\n            minimumBid = data;\\r\\n        }\\r\\n        else revert(\\\"IncreasingDiscountCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Modify an address parameter\\r\\n     * @param parameter The parameter name\\r\\n     * @param data New address for the parameter\\r\\n     */\\r\\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\\r\\n        if (parameter == \\\"oracleRelayer\\\") oracleRelayer = OracleRelayerLike(data);\\r\\n        else if (parameter == \\\"collateralFSM\\\") {\\r\\n          collateralFSM = OracleLike(data);\\r\\n          // Check that priceSource() is implemented\\r\\n          collateralFSM.priceSource();\\r\\n        }\\r\\n        else if (parameter == \\\"systemCoinOracle\\\") systemCoinOracle = OracleLike(data);\\r\\n        else if (parameter == \\\"liquidationEngine\\\") liquidationEngine = LiquidationEngineLike(data);\\r\\n        else revert(\\\"IncreasingDiscountCollateralAuctionHouse/modify-unrecognized-param\\\");\\r\\n        emit ModifyParameters(parameter, data);\\r\\n    }\\r\\n\\r\\n    // --- Private Auction Utils ---\\r\\n    /*\\r\\n    * @notify Get the amount of bought collateral from a specific auction using custom collateral price feeds, a system\\r\\n    *         coin price feed and a custom discount\\r\\n    * @param id The ID of the auction to bid in and get collateral from\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the oracle median\\r\\n    * @param systemCoinPriceFeedValue The system coin market price fetched from the oracle\\r\\n    * @param adjustedBid The system coin bid\\r\\n    * @param customDiscount The discount offered\\r\\n    */\\r\\n    function getBoughtCollateral(\\r\\n        uint256 id,\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue,\\r\\n        uint256 systemCoinPriceFeedValue,\\r\\n        uint256 adjustedBid,\\r\\n        uint256 customDiscount\\r\\n    ) private view returns (uint256) {\\r\\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\\r\\n        uint256 discountedCollateralPrice =\\r\\n          getDiscountedCollateralPrice(\\r\\n            collateralFsmPriceFeedValue,\\r\\n            collateralMedianPriceFeedValue,\\r\\n            systemCoinPriceFeedValue,\\r\\n            customDiscount\\r\\n          );\\r\\n        // calculate the amount of collateral bought\\r\\n        uint256 boughtCollateral = wdivide(adjustedBid, discountedCollateralPrice);\\r\\n        // if the calculated collateral amount exceeds the amount still up for sale, adjust it to the remaining amount\\r\\n        boughtCollateral = (boughtCollateral > bids[id].amountToSell) ? bids[id].amountToSell : boughtCollateral;\\r\\n\\r\\n        return boughtCollateral;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Update the discount used in a particular auction\\r\\n    * @param id The id of the auction to update the discount for\\r\\n    * @returns The newly computed currentDiscount for the targeted auction\\r\\n    */\\r\\n    function updateCurrentDiscount(uint256 id) private returns (uint256) {\\r\\n        // Work directly with storage\\r\\n        Bid storage auctionBidData              = bids[id];\\r\\n        auctionBidData.currentDiscount          = getNextCurrentDiscount(id);\\r\\n        auctionBidData.latestDiscountUpdateTime = now;\\r\\n        return auctionBidData.currentDiscount;\\r\\n    }\\r\\n\\r\\n    // --- Public Auction Utils ---\\r\\n    /*\\r\\n    * @notice Fetch the collateral median price (from the oracle, not FSM)\\r\\n    * @returns The collateral price from the oracle median; zero if the address of the collateralMedian (as fetched from the FSM) is null\\r\\n    */\\r\\n    function getCollateralMedianPrice() public view returns (uint256 priceFeed) {\\r\\n        // Fetch the collateral median address from the collateral FSM\\r\\n        address collateralMedian;\\r\\n        try collateralFSM.priceSource() returns (address median) {\\r\\n          collateralMedian = median;\\r\\n        } catch (bytes memory revertReason) {}\\r\\n\\r\\n        if (collateralMedian == address(0)) return 0;\\r\\n\\r\\n        // wrapped call toward the collateral median\\r\\n        try OracleLike(collateralMedian).getResultWithValidity()\\r\\n          returns (uint256 price, bool valid) {\\r\\n          if (valid) {\\r\\n            priceFeed = uint256(price);\\r\\n          }\\r\\n        } catch (bytes memory revertReason) {\\r\\n          return 0;\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Fetch the system coin market price\\r\\n    * @returns The system coin market price fetch from the oracle\\r\\n    */\\r\\n    function getSystemCoinMarketPrice() public view returns (uint256 priceFeed) {\\r\\n        if (address(systemCoinOracle) == address(0)) return 0;\\r\\n\\r\\n        // wrapped call toward the system coin oracle\\r\\n        try systemCoinOracle.getResultWithValidity()\\r\\n          returns (uint256 price, bool valid) {\\r\\n          if (valid) {\\r\\n            priceFeed = uint256(price) * 10 ** 9; // scale to RAY\\r\\n          }\\r\\n        } catch (bytes memory revertReason) {\\r\\n          return 0;\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the smallest possible price that's at max lowerSystemCoinMedianDeviation deviated from the redemption price and at least\\r\\n    *         minSystemCoinMedianDeviation deviated\\r\\n    */\\r\\n    function getSystemCoinFloorDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 floorPrice) {\\r\\n        uint256 minFloorDeviatedPrice = wmultiply(redemptionPrice, minSystemCoinMedianDeviation);\\r\\n        floorPrice = wmultiply(redemptionPrice, lowerSystemCoinMedianDeviation);\\r\\n        floorPrice = (floorPrice <= minFloorDeviatedPrice) ? floorPrice : redemptionPrice;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the highest possible price that's at max upperSystemCoinMedianDeviation deviated from the redemption price and at least\\r\\n    *         minSystemCoinMedianDeviation deviated\\r\\n    */\\r\\n    function getSystemCoinCeilingDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 ceilingPrice) {\\r\\n        uint256 minCeilingDeviatedPrice = wmultiply(redemptionPrice, subtract(2 * WAD, minSystemCoinMedianDeviation));\\r\\n        ceilingPrice = wmultiply(redemptionPrice, subtract(2 * WAD, upperSystemCoinMedianDeviation));\\r\\n        ceilingPrice = (ceilingPrice >= minCeilingDeviatedPrice) ? ceilingPrice : redemptionPrice;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the collateral price from the FSM and the final system coin price that will be used when bidding in an auction\\r\\n    * @param systemCoinRedemptionPrice The system coin redemption price\\r\\n    * @returns The collateral price from the FSM and the final system coin price used for bidding (picking between redemption and market prices)\\r\\n    */\\r\\n    function getCollateralFSMAndFinalSystemCoinPrices(uint256 systemCoinRedemptionPrice) public view returns (uint256, uint256) {\\r\\n        require(systemCoinRedemptionPrice > 0, \\\"IncreasingDiscountCollateralAuctionHouse/invalid-redemption-price-provided\\\");\\r\\n        (uint256 collateralFsmPriceFeedValue, bool collateralFsmHasValidValue) = collateralFSM.getResultWithValidity();\\r\\n        if (!collateralFsmHasValidValue) {\\r\\n          return (0, 0);\\r\\n        }\\r\\n\\r\\n        uint256 systemCoinAdjustedPrice  = systemCoinRedemptionPrice;\\r\\n        uint256 systemCoinPriceFeedValue = getSystemCoinMarketPrice();\\r\\n\\r\\n        if (systemCoinPriceFeedValue > 0) {\\r\\n          uint256 floorPrice   = getSystemCoinFloorDeviatedPrice(systemCoinAdjustedPrice);\\r\\n          uint256 ceilingPrice = getSystemCoinCeilingDeviatedPrice(systemCoinAdjustedPrice);\\r\\n\\r\\n          if (uint(systemCoinPriceFeedValue) < systemCoinAdjustedPrice) {\\r\\n            systemCoinAdjustedPrice = maximum(uint256(systemCoinPriceFeedValue), floorPrice);\\r\\n          } else {\\r\\n            systemCoinAdjustedPrice = minimum(uint256(systemCoinPriceFeedValue), ceilingPrice);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        return (uint256(collateralFsmPriceFeedValue), systemCoinAdjustedPrice);\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the collateral price used in bidding by picking between the raw FSM and the oracle median price and taking into account\\r\\n    *         deviation limits\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the median attached to the FSM\\r\\n    */\\r\\n    function getFinalBaseCollateralPrice(\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 floorPrice   = wmultiply(collateralFsmPriceFeedValue, lowerCollateralMedianDeviation);\\r\\n        uint256 ceilingPrice = wmultiply(collateralFsmPriceFeedValue, subtract(2 * WAD, upperCollateralMedianDeviation));\\r\\n\\r\\n        uint256 adjustedMedianPrice = (collateralMedianPriceFeedValue == 0) ?\\r\\n          collateralFsmPriceFeedValue : collateralMedianPriceFeedValue;\\r\\n\\r\\n        if (adjustedMedianPrice < collateralFsmPriceFeedValue) {\\r\\n          return maximum(adjustedMedianPrice, floorPrice);\\r\\n        } else {\\r\\n          return minimum(adjustedMedianPrice, ceilingPrice);\\r\\n        }\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the discounted collateral price (using a custom discount)\\r\\n    * @param collateralFsmPriceFeedValue The collateral price fetched from the FSM\\r\\n    * @param collateralMedianPriceFeedValue The collateral price fetched from the oracle median\\r\\n    * @param systemCoinPriceFeedValue The system coin price fetched from the oracle\\r\\n    * @param customDiscount The custom discount used to calculate the collateral price offered\\r\\n    */\\r\\n    function getDiscountedCollateralPrice(\\r\\n        uint256 collateralFsmPriceFeedValue,\\r\\n        uint256 collateralMedianPriceFeedValue,\\r\\n        uint256 systemCoinPriceFeedValue,\\r\\n        uint256 customDiscount\\r\\n    ) public view returns (uint256) {\\r\\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\\r\\n        return wmultiply(\\r\\n          rdivide(getFinalBaseCollateralPrice(collateralFsmPriceFeedValue, collateralMedianPriceFeedValue), systemCoinPriceFeedValue),\\r\\n          customDiscount\\r\\n        );\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the upcoming discount that will be used in a specific auction\\r\\n    * @param id The ID of the auction to calculate the upcoming discount for\\r\\n    * @returns The upcoming discount that will be used in the targeted auction\\r\\n    */\\r\\n    function getNextCurrentDiscount(uint256 id) public view returns (uint256) {\\r\\n        if (bids[id].forgoneCollateralReceiver == address(0)) return RAY;\\r\\n        uint256 nextDiscount = bids[id].currentDiscount;\\r\\n\\r\\n        // If the increase deadline hasn't been passed yet and the current discount is not at or greater than max\\r\\n        if (both(uint48(now) < bids[id].discountIncreaseDeadline, bids[id].currentDiscount > bids[id].maxDiscount)) {\\r\\n            // Calculate the new current discount\\r\\n            nextDiscount = rmultiply(\\r\\n              rpower(bids[id].perSecondDiscountUpdateRate, subtract(now, bids[id].latestDiscountUpdateTime), RAY),\\r\\n              bids[id].currentDiscount\\r\\n            );\\r\\n\\r\\n            // If the new discount is greater than the max one\\r\\n            if (nextDiscount <= bids[id].maxDiscount) {\\r\\n              nextDiscount = bids[id].maxDiscount;\\r\\n            }\\r\\n        } else {\\r\\n            // Determine the conditions when we can instantly set the current discount to max\\r\\n            bool currentZeroMaxNonZero = both(bids[id].currentDiscount == 0, bids[id].maxDiscount > 0);\\r\\n            bool doneUpdating          = both(uint48(now) >= bids[id].discountIncreaseDeadline, bids[id].currentDiscount != bids[id].maxDiscount);\\r\\n\\r\\n            if (either(currentZeroMaxNonZero, doneUpdating)) {\\r\\n              nextDiscount = bids[id].maxDiscount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return nextDiscount;\\r\\n    }\\r\\n    /*\\r\\n    * @notice Get the actual bid that will be used in an auction (taking into account the bidder input)\\r\\n    * @param id The id of the auction to calculate the adjusted bid for\\r\\n    * @param wad The initial bid submitted\\r\\n    * @returns Whether the bid is valid or not and the adjusted bid\\r\\n    */\\r\\n    function getAdjustedBid(\\r\\n        uint256 id, uint256 wad\\r\\n    ) public view returns (bool, uint256) {\\r\\n        if (either(\\r\\n          either(bids[id].amountToSell == 0, bids[id].amountToRaise == 0),\\r\\n          either(wad == 0, wad < minimumBid)\\r\\n        )) {\\r\\n          return (false, wad);\\r\\n        }\\r\\n\\r\\n        uint256 remainingToRaise = bids[id].amountToRaise;\\r\\n\\r\\n        // bound max amount offered in exchange for collateral\\r\\n        uint256 adjustedBid = wad;\\r\\n        if (multiply(adjustedBid, RAY) > remainingToRaise) {\\r\\n            adjustedBid = addUint256(remainingToRaise / RAY, 1);\\r\\n        }\\r\\n\\r\\n        remainingToRaise = (multiply(adjustedBid, RAY) > remainingToRaise) ? 0 : subtract(bids[id].amountToRaise, multiply(adjustedBid, RAY));\\r\\n        if (both(remainingToRaise > 0, remainingToRaise < RAY)) {\\r\\n            return (false, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (true, adjustedBid);\\r\\n    }\\r\\n\\r\\n    // --- Core Auction Logic ---\\r\\n    /**\\r\\n     * @notice Start a new collateral auction\\r\\n     * @param forgoneCollateralReceiver Who receives leftover collateral that is not auctioned\\r\\n     * @param auctionIncomeRecipient Who receives the amount raised in the auction\\r\\n     * @param amountToRaise Total amount of coins to raise (rad)\\r\\n     * @param amountToSell Total amount of collateral available to sell (wad)\\r\\n     * @param initialBid Unused\\r\\n     */\\r\\n    function startAuction(\\r\\n        address forgoneCollateralReceiver,\\r\\n        address auctionIncomeRecipient,\\r\\n        uint256 amountToRaise,\\r\\n        uint256 amountToSell,\\r\\n        uint256 initialBid\\r\\n    ) public isAuthorized returns (uint256 id) {\\r\\n        require(auctionsStarted < uint256(-1), \\\"IncreasingDiscountCollateralAuctionHouse/overflow\\\");\\r\\n        require(amountToSell > 0, \\\"IncreasingDiscountCollateralAuctionHouse/no-collateral-for-sale\\\");\\r\\n        require(amountToRaise > 0, \\\"IncreasingDiscountCollateralAuctionHouse/nothing-to-raise\\\");\\r\\n        require(amountToRaise >= RAY, \\\"IncreasingDiscountCollateralAuctionHouse/dusty-auction\\\");\\r\\n        id = ++auctionsStarted;\\r\\n\\r\\n        uint48 discountIncreaseDeadline      = addUint48(uint48(now), uint48(maxDiscountUpdateRateTimeline));\\r\\n\\r\\n        bids[id].currentDiscount             = minDiscount;\\r\\n        bids[id].maxDiscount                 = maxDiscount;\\r\\n        bids[id].perSecondDiscountUpdateRate = perSecondDiscountUpdateRate;\\r\\n        bids[id].discountIncreaseDeadline    = discountIncreaseDeadline;\\r\\n        bids[id].latestDiscountUpdateTime    = now;\\r\\n        bids[id].amountToSell                = amountToSell;\\r\\n        bids[id].forgoneCollateralReceiver   = forgoneCollateralReceiver;\\r\\n        bids[id].auctionIncomeRecipient      = auctionIncomeRecipient;\\r\\n        bids[id].amountToRaise               = amountToRaise;\\r\\n\\r\\n        safeEngine.transferCollateral(collateralType, msg.sender, address(this), amountToSell);\\r\\n\\r\\n        emit StartAuction(\\r\\n          id,\\r\\n          auctionsStarted,\\r\\n          amountToSell,\\r\\n          initialBid,\\r\\n          amountToRaise,\\r\\n          minDiscount,\\r\\n          maxDiscount,\\r\\n          perSecondDiscountUpdateRate,\\r\\n          discountIncreaseDeadline,\\r\\n          forgoneCollateralReceiver,\\r\\n          auctionIncomeRecipient\\r\\n        );\\r\\n    }\\r\\n    /**\\r\\n     * @notice Calculate how much collateral someone would buy from an auction using the last read redemption price and the old current\\r\\n     *         discount associated with the auction\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted\\r\\n     */\\r\\n    function getApproximateCollateralBought(uint256 id, uint256 wad) external view returns (uint256, uint256) {\\r\\n        (bool validAuctionAndBid, uint256 adjustedBid) = getAdjustedBid(id, wad);\\r\\n        if (!validAuctionAndBid) {\\r\\n            return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        // check that the oracle doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices(oracleRelayer.lastRedemptionPrice());\\r\\n        if (collateralFsmPriceFeedValue == 0) {\\r\\n          return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (getBoughtCollateral(\\r\\n          id,\\r\\n          collateralFsmPriceFeedValue,\\r\\n          getCollateralMedianPrice(),\\r\\n          systemCoinPriceFeedValue,\\r\\n          adjustedBid,\\r\\n          bids[id].currentDiscount\\r\\n        ), adjustedBid);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Calculate how much collateral someone would buy from an auction using the latest redemption price fetched from the\\r\\n     *         OracleRelayer and the latest updated discount associated with the auction\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted\\r\\n     */\\r\\n    function getCollateralBought(uint256 id, uint256 wad) external returns (uint256, uint256) {\\r\\n        (bool validAuctionAndBid, uint256 adjustedBid) = getAdjustedBid(id, wad);\\r\\n        if (!validAuctionAndBid) {\\r\\n            return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        // check that the oracle doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices(oracleRelayer.redemptionPrice());\\r\\n        if (collateralFsmPriceFeedValue == 0) {\\r\\n          return (0, adjustedBid);\\r\\n        }\\r\\n\\r\\n        return (getBoughtCollateral(\\r\\n          id,\\r\\n          collateralFsmPriceFeedValue,\\r\\n          getCollateralMedianPrice(),\\r\\n          systemCoinPriceFeedValue,\\r\\n          adjustedBid,\\r\\n          updateCurrentDiscount(id)\\r\\n        ), adjustedBid);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Buy collateral from an auction at an increasing discount\\r\\n     * @param id ID of the auction to buy collateral from\\r\\n     * @param wad New bid submitted (as a WAD which has 18 decimals)\\r\\n     */\\r\\n    function buyCollateral(uint256 id, uint256 wad) external {\\r\\n        require(both(bids[id].amountToSell > 0, bids[id].amountToRaise > 0), \\\"IncreasingDiscountCollateralAuctionHouse/inexistent-auction\\\");\\r\\n        require(both(wad > 0, wad >= minimumBid), \\\"IncreasingDiscountCollateralAuctionHouse/invalid-bid\\\");\\r\\n\\r\\n        // bound max amount offered in exchange for collateral (in case someone offers more than it's necessary)\\r\\n        uint256 adjustedBid = wad;\\r\\n        if (multiply(adjustedBid, RAY) > bids[id].amountToRaise) {\\r\\n            adjustedBid = addUint256(bids[id].amountToRaise / RAY, 1);\\r\\n        }\\r\\n\\r\\n        // check that the collateral FSM doesn't return an invalid value\\r\\n        (uint256 collateralFsmPriceFeedValue, uint256 systemCoinPriceFeedValue) = getCollateralFSMAndFinalSystemCoinPrices( oracleRelayer.redemptionPrice());\\r\\n        require(collateralFsmPriceFeedValue > 0, \\\"IncreasingDiscountCollateralAuctionHouse/collateral-fsm-invalid-value\\\");\\r\\n\\r\\n        // get the amount of collateral bought\\r\\n        uint256 boughtCollateral = getBoughtCollateral(\\r\\n            id, collateralFsmPriceFeedValue, getCollateralMedianPrice(), systemCoinPriceFeedValue, adjustedBid, updateCurrentDiscount(id)\\r\\n        );\\r\\n        // check that the calculated amount is greater than zero\\r\\n        require(boughtCollateral > 0, \\\"IncreasingDiscountCollateralAuctionHouse/null-bought-amount\\\");\\r\\n        // update the amount of collateral to sell\\r\\n        bids[id].amountToSell = subtract(bids[id].amountToSell, boughtCollateral);\\r\\n\\r\\n        // update remainingToRaise in case amountToSell is zero (everything has been sold)\\r\\n        uint256 remainingToRaise = (either(multiply(wad, RAY) >= bids[id].amountToRaise, bids[id].amountToSell == 0)) ?\\r\\n            bids[id].amountToRaise : subtract(bids[id].amountToRaise, multiply(wad, RAY));\\r\\n\\r\\n        // update leftover amount to raise in the bid struct\\r\\n        bids[id].amountToRaise = (multiply(adjustedBid, RAY) > bids[id].amountToRaise) ?\\r\\n            0 : subtract(bids[id].amountToRaise, multiply(adjustedBid, RAY));\\r\\n\\r\\n        // check that the remaining amount to raise is either zero or higher than RAY\\r\\n        require(\\r\\n          either(bids[id].amountToRaise == 0, bids[id].amountToRaise >= RAY),\\r\\n          \\\"IncreasingDiscountCollateralAuctionHouse/invalid-left-to-raise\\\"\\r\\n        );\\r\\n\\r\\n        // transfer the bid to the income recipient and the collateral to the bidder\\r\\n        safeEngine.transferInternalCoins(msg.sender, bids[id].auctionIncomeRecipient, multiply(adjustedBid, RAY));\\r\\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, boughtCollateral);\\r\\n\\r\\n        // Emit the buy event\\r\\n        emit BuyCollateral(id, adjustedBid, boughtCollateral);\\r\\n\\r\\n        // Remove coins from the liquidation buffer\\r\\n        bool soldAll = either(bids[id].amountToRaise == 0, bids[id].amountToSell == 0);\\r\\n        if (soldAll) {\\r\\n            liquidationEngine.removeCoinsFromAuction(remainingToRaise);\\r\\n        } else {\\r\\n            liquidationEngine.removeCoinsFromAuction(multiply(adjustedBid, RAY));\\r\\n        }\\r\\n\\r\\n        // If the auction raised the whole amount or all collateral was sold,\\r\\n        // send remaining collateral to the forgone receiver\\r\\n        if (soldAll) {\\r\\n            safeEngine.transferCollateral(collateralType, address(this), bids[id].forgoneCollateralReceiver, bids[id].amountToSell);\\r\\n            delete bids[id];\\r\\n            emit SettleAuction(id, bids[id].amountToSell);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice Settle/finish an auction\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function settleAuction(uint256 id) external {\\r\\n        return;\\r\\n    }\\r\\n    /**\\r\\n     * @notice Terminate an auction prematurely. Usually called by Global Settlement.\\r\\n     * @param id ID of the auction to settle\\r\\n     */\\r\\n    function terminateAuctionPrematurely(uint256 id) external isAuthorized {\\r\\n        require(both(bids[id].amountToSell > 0, bids[id].amountToRaise > 0), \\\"IncreasingDiscountCollateralAuctionHouse/inexistent-auction\\\");\\r\\n        liquidationEngine.removeCoinsFromAuction(bids[id].amountToRaise);\\r\\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, bids[id].amountToSell);\\r\\n        delete bids[id];\\r\\n        emit TerminateAuctionPrematurely(id, msg.sender, bids[id].amountToSell);\\r\\n    }\\r\\n\\r\\n    // --- Getters ---\\r\\n    function bidAmount(uint256 id) public view returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n    function remainingAmountToSell(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].amountToSell;\\r\\n    }\\r\\n    function forgoneCollateralReceiver(uint256 id) public view returns (address) {\\r\\n        return bids[id].forgoneCollateralReceiver;\\r\\n    }\\r\\n    function raisedAmount(uint256 id) public view returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n    function amountToRaise(uint256 id) public view returns (uint256) {\\r\\n        return bids[id].amountToRaise;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-auth/=lib/geb-fsm/lib/ds-stop/lib/ds-auth/src/\",\r\n      \"ds-math/=lib/geb-fsm/lib/ds-token/lib/ds-math/src/\",\r\n      \"ds-note/=lib/geb-fsm/lib/ds-stop/lib/ds-note/src/\",\r\n      \"ds-stop/=lib/geb-fsm/lib/ds-stop/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"ds-thing/=lib/geb-fsm/lib/ds-value/lib/ds-thing/src/\",\r\n      \"ds-token/=lib/geb-fsm/lib/ds-token/src/\",\r\n      \"ds-value/=lib/geb-fsm/lib/ds-value/src/\",\r\n      \"erc20/=lib/geb-fsm/lib/ds-token/lib/erc20/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"geb-fsm/=lib/geb-fsm/src/\",\r\n      \"geb-treasury-reimbursement/=lib/geb-fsm/lib/geb-treasury-reimbursement/src/\",\r\n      \"geb/=lib/geb/src/\",\r\n      \"mgl-keeper-incentives/=lib/mgl-keeper-incentives/src/\",\r\n      \"solmate/=lib/mgl-keeper-incentives/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeEngine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationEngine\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"collateralType\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AuctionHouseFactory", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e66868823ec2f55bedd998a87b62ab1bc58536649c5c6e36214287cd6d0fbc4c"}