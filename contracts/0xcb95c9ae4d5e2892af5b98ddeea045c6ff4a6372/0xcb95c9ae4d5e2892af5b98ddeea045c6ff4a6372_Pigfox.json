{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Pigfox.sol\": {\r\n      \"content\": \"// File: Pigfox-Imports.sol\\n\\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\n// File: contracts/@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\n// File: @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\n// File: ../solc/Pigfox-Imports.sol\\n\\npragma solidity ^0.8.18;\\n\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract ERC20Basic is IERC20 {\\n    string public constant name = \\\"ERC20Basic\\\";\\n    string public constant symbol = \\\"ERC\\\";\\n    uint8 public constant decimals = 18;\\n    mapping(address => uint256) balances;\\n    mapping(address => mapping (address => uint256)) allowed;\\n    uint256 totalSupply_ = 10 ether;\\n\\n    constructor() {\\n        balances[msg.sender] = totalSupply_;\\n    }\\n\\n    function totalSupply() public override view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\\n        return balances[tokenOwner];\\n    }\\n\\n    function transfer(address receiver, uint256 numTokens) public override returns (bool) {\\n        require(numTokens <= balances[msg.sender]);\\n        balances[msg.sender] = balances[msg.sender]-numTokens;\\n        balances[receiver] = balances[receiver]+numTokens;\\n        emit Transfer(msg.sender, receiver, numTokens);\\n        return true;\\n    }\\n\\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\\n        allowed[msg.sender][delegate] = numTokens;\\n        emit Approval(msg.sender, delegate, numTokens);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address delegate) public override view returns (uint) {\\n        return allowed[owner][delegate];\\n    }\\n\\n    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {\\n        require(numTokens <= balances[owner]);\\n        require(numTokens <= allowed[owner][msg.sender]);\\n\\n        balances[owner] = balances[owner]-numTokens;\\n        allowed[owner][msg.sender] = allowed[owner][msg.sender]+numTokens;\\n        balances[buyer] = balances[buyer]+numTokens;\\n        emit Transfer(owner, buyer, numTokens);\\n        return true;\\n    }\\n}\\n\\ncontract Pigfox {\\n    event AssetSold(address sender, uint256 amount);\\n    event AssetBought(address sender, uint256 amount);\\n    event EtherReceived(address sender, uint amount);\\n    event LogMessage(string message);\\n    event LogMessages(string message, string message2);\\n    address private owner;\\n    address private _currentRouter0;\\n    address private _currentRouter1;\\n    address private _token;\\n\\n    constructor() {\\n        owner = msg.sender; // The wallet that deploys the contract becomes the owner\\n    }\\n\\n    //Enforce security everywhere\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only contract owner can call this function\\\");\\n        _;\\n    }\\n\\n    function _log(string memory message) private {\\n        emit LogMessage(message);\\n    }\\n\\n    function swap(address token, uint256 ethToBorrow,  address tokenPairedWithWeth, address routerAddress0, address routerAddress1) public payable onlyOwner {\\n        _currentRouter0 = routerAddress0;\\n        _currentRouter1 = routerAddress1;\\n        _token = token;\\n        require(token != tokenPairedWithWeth, \\\"Can't borrow ETH from the same pair as the one you're trading\\\");\\n        address weth = IUniswapV2Router02(routerAddress0).WETH();\\n        address pairWeth = IUniswapV2Factory(IUniswapV2Router02(routerAddress0).factory()).getPair(weth, tokenPairedWithWeth);\\n        require(pairWeth != address(0), \\\"This pool does not exist on router0\\\");\\n        // Make sure the pools exist on both routers\\n        address pairAddress0 = IUniswapV2Factory(IUniswapV2Router02(routerAddress0).factory()).getPair(token, weth);\\n        require(pairAddress0 != address(0), \\\"This pool does not exist on router0\\\");\\n        address pairAddress1 = IUniswapV2Factory(IUniswapV2Router02(routerAddress1).factory()).getPair(token, weth);\\n        require(pairAddress1 != address(0), \\\"This pool does not exist on router1\\\");\\n        address token0 = IUniswapV2Pair(pairWeth).token0();\\n        address token1 = IUniswapV2Pair(pairWeth).token1();\\n        uint256 amount0 = weth == token0 ? ethToBorrow : 0;\\n        uint256 amount1 = weth == token1 ? ethToBorrow : 0;\\n        IUniswapV2Pair(pairWeth).swap(amount0, amount1, address(this), bytes(\\\"not empty\\\"));\\n\\n        // Revert to zero\\n        _currentRouter0 = address(0);\\n        _currentRouter1 = address(0);\\n        _token = address(0);\\n    }\\n\\n    function uniswapV2Call(address, uint256 amount0, uint256 amount1, bytes calldata) external {\\n\\n        address[] memory path = new address[](2);\\n        address token0 = IUniswapV2Pair(msg.sender).token0();\\n        address token1 = IUniswapV2Pair(msg.sender).token1();\\n\\n        IUniswapV2Router02 router0 = IUniswapV2Router02(_currentRouter0);\\n        IUniswapV2Router02 router1 = IUniswapV2Router02(_currentRouter1);\\n\\n        require(msg.sender == IUniswapV2Factory(router0.factory()).getPair(token0, token1), \\\"Unauthorized\\\"); // ensure that msg.sender is a V2 pair\\n\\n        require(amount0 == 0 || amount1 == 0, \\\"Invalid amounts\\\");\\n\\n        path[0] = router1.WETH();\\n        path[1] = _token;\\n\\n        IERC20 wethContract = IERC20(path[0]);\\n        IERC20 tokenContract = IERC20(path[1]);\\n        uint256 wethBorrowed = wethContract.balanceOf(address(this));\\n        wethContract.approve(_currentRouter1, wethBorrowed);\\n\\n        // Buy Token with WETH on Router 1 (where it's cheaper)\\n        uint256 tokensReceived = router1.swapExactTokensForTokens(wethBorrowed, 0, path, address(this), block.timestamp)[1];\\n\\n        // Sell Token for WETH on Router 0 (where it's more expensive)\\n        tokenContract.approve(_currentRouter0, tokensReceived);\\n        address path1 = path[0];\\n        path[0] = path[1]; // Reverse path\\n        path[1] = path1;\\n        uint256 wethReceived = router0.swapExactTokensForTokens(tokensReceived, 0, path, address(this), block.timestamp)[1];\\n\\n        uint256 profit = wethReceived > wethBorrowed ? wethReceived - wethBorrowed : 0;\\n        require(wethReceived > wethBorrowed, \\\"Not enough to reimburse loan\\\");\\n\\n        wethContract.transfer(msg.sender, wethBorrowed);         \\n        wethContract.transfer(tx.origin, profit);\\n    }\\n\\n    function sendProfitToWallet() private {\\n        //send profit from swap back to wallet\\n    }\\n\\n    /**\\n    Only the current owner can transfer ownership to a new owner\\n     */\\n    function updateOwner(address _newOwner) public onlyOwner {\\n        owner = _newOwner;\\n    }\\n\\n    // Function to receive Ether\\n    receive() external payable {\\n        emit EtherReceived(msg.sender, msg.value);\\n    }\\n\\n    function getRemainingGas() public view returns (uint256) {\\n        return gasleft();\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"LogMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message2\",\"type\":\"string\"}],\"name\":\"LogMessages\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getRemainingGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethToBorrow\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenPairedWithWeth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"routerAddress0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"routerAddress1\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"uniswapV2Call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Pigfox", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}