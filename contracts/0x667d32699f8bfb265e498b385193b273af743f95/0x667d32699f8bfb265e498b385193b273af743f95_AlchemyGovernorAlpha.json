{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AlchGovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./interfaces/ITimelock.sol\\\";\\r\\n\\r\\n\\r\\ncontract AlchemyGovernorAlpha {\\r\\n    /// @dev The name of this contract\\r\\n    string public constant name = \\\"Alchemy Governor Alpha\\\";\\r\\n\\r\\n    /// @dev The voting period which will be set after setVotingPeriodAfter has passed.\\r\\n    uint256 public constant permanentVotingPeriod = 17_280; // ~3 days in blocks (assuming 15s blocks)\\r\\n\\r\\n    /**\\r\\n     * @dev The number of votes in support of a proposal required in order for a\\r\\n     * quorum to be reached and for a vote to succeed\\r\\n     */\\r\\n    function quorumVotes() public pure returns (uint256) {\\r\\n        return 400_000e18; // 4% of ALCH\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The number of votes required in order for a voter to become a proposer\\r\\n     */\\r\\n    function proposalThreshold() public pure returns (uint256) {\\r\\n        return 100_000e18; // 1% of ALCH\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The maximum number of actions that can be included in a proposal\\r\\n     */\\r\\n    function proposalMaxOperations() public pure returns (uint256) {\\r\\n        return 10;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The delay before voting on a proposal may take place, once proposed\\r\\n     */\\r\\n    function votingDelay() public pure returns (uint256) {\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The duration of voting on a proposal, in blocks\\r\\n     */\\r\\n    uint256 public votingPeriod = 2_880; // ~12 hours in blocks (assuming 15s blocks)\\r\\n\\r\\n    /**\\r\\n     * @dev The timestamp after which votingPeriod can be set to the permanent value.\\r\\n     */\\r\\n    uint256 public immutable setVotingPeriodAfter;\\r\\n\\r\\n    /**\\r\\n     * @dev The address of the Alchemy Protocol Timelock\\r\\n     */\\r\\n    ITimelock public immutable timelock;\\r\\n\\r\\n    /**\\r\\n     * @dev The address of the Alchemy governance token\\r\\n     */\\r\\n    AlchInterface public immutable alch;\\r\\n\\r\\n    /**\\r\\n     * @dev The total number of proposals\\r\\n     */\\r\\n    uint256 public proposalCount;\\r\\n\\r\\n    /**\\r\\n     * @param id Unique id for looking up a proposal\\r\\n     * @param proposer Creator of the proposal\\r\\n     * @param eta The timestamp that the proposal will be available for execution, set once the vote succeeds\\r\\n     * @param targets The ordered list of target addresses for calls to be made\\r\\n     * @param values The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\r\\n     * @param signatures The ordered list of function signatures to be called\\r\\n     * @param calldatas The ordered list of calldata to be passed to each call\\r\\n     * @param startBlock The block at which voting begins: holders must delegate their votes prior to this block\\r\\n     * @param endBlock The block at which voting ends: votes must be cast prior to this block\\r\\n     * @param forVotes Current number of votes in favor of this proposal\\r\\n     * @param againstVotes Current number of votes in opposition to this proposal\\r\\n     * @param canceled Flag marking whether the proposal has been canceled\\r\\n     * @param executed Flag marking whether the proposal has been executed\\r\\n     * @param receipts Receipts of ballots for the entire set of voters\\r\\n     */\\r\\n    struct Proposal {\\r\\n        uint256 id;\\r\\n        address proposer;\\r\\n        uint256 eta;\\r\\n        address[] targets;\\r\\n        uint256[] values;\\r\\n        string[] signatures;\\r\\n        bytes[] calldatas;\\r\\n        uint256 startBlock;\\r\\n        uint256 endBlock;\\r\\n        uint256 forVotes;\\r\\n        uint256 againstVotes;\\r\\n        bool canceled;\\r\\n        bool executed;\\r\\n        mapping(address => Receipt) receipts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Ballot receipt record for a voter\\r\\n     * @param hasVoted Whether or not a vote has been cast\\r\\n     * @param support Whether or not the voter supports the proposal\\r\\n     * @param votes The number of votes the voter had, which were cast\\r\\n     */\\r\\n    struct Receipt {\\r\\n        bool hasVoted;\\r\\n        bool support;\\r\\n        uint96 votes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Possible states that a proposal may be in\\r\\n     */\\r\\n    enum ProposalState {\\r\\n        Pending,\\r\\n        Active,\\r\\n        Canceled,\\r\\n        Defeated,\\r\\n        Succeeded,\\r\\n        Queued,\\r\\n        Expired,\\r\\n        Executed\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The official record of all proposals ever proposed\\r\\n     */\\r\\n    mapping(uint256 => Proposal) public proposals;\\r\\n\\r\\n    /**\\r\\n     * @dev The latest proposal for each proposer\\r\\n     */\\r\\n    mapping(address => uint256) public latestProposalIds;\\r\\n\\r\\n    /**\\r\\n     * @dev The EIP-712 typehash for the contract's domain\\r\\n     */\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\r\\n        \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev The EIP-712 typehash for the ballot struct used by the contract\\r\\n     */\\r\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\r\\n        \\\"Ballot(uint256 proposalId,bool support)\\\"\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev An event emitted when a new proposal is created\\r\\n     */\\r\\n    event ProposalCreated(\\r\\n        uint256 id,\\r\\n        address proposer,\\r\\n        address[] targets,\\r\\n        uint256[] values,\\r\\n        string[] signatures,\\r\\n        bytes[] calldatas,\\r\\n        uint256 startBlock,\\r\\n        uint256 endBlock,\\r\\n        string description\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev An event emitted when a vote has been cast on a proposal\\r\\n     */\\r\\n    event VoteCast(\\r\\n        address voter,\\r\\n        uint256 proposalId,\\r\\n        bool support,\\r\\n        uint256 votes\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev An event emitted when a proposal has been canceled\\r\\n     */\\r\\n    event ProposalCanceled(uint256 id);\\r\\n\\r\\n    /**\\r\\n     * @dev An event emitted when a proposal has been queued in the Timelock\\r\\n     */\\r\\n    event ProposalQueued(uint256 id, uint256 eta);\\r\\n\\r\\n    /**\\r\\n     * @dev An event emitted when a proposal has been executed in the Timelock\\r\\n     */\\r\\n    event ProposalExecuted(uint256 id);\\r\\n\\r\\n    constructor(address timelock_, address alch_, uint256 setVotingPeriodAfter_) public {\\r\\n        timelock = ITimelock(timelock_);\\r\\n        alch = AlchInterface(alch_);\\r\\n        setVotingPeriodAfter = setVotingPeriodAfter_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets votingPeriod to the permanent value.\\r\\n     * Can only be called after setVotingPeriodAfter\\r\\n     */\\r\\n    function setPermanentVotingPeriod() external {\\r\\n        require(\\r\\n            block.timestamp >= setVotingPeriodAfter,\\r\\n            \\\"GovernorAlpha::setPermanentVotingPeriod: setting permanent voting period not allowed yet\\\"\\r\\n        );\\r\\n        votingPeriod = permanentVotingPeriod;\\r\\n    }\\r\\n\\r\\n    function propose(\\r\\n        address[] memory targets,\\r\\n        uint256[] memory values,\\r\\n        string[] memory signatures,\\r\\n        bytes[] memory calldatas,\\r\\n        string memory description\\r\\n    ) public returns (uint256) {\\r\\n        require(\\r\\n            alch.getPriorVotes(msg.sender, sub256(block.number, 1)) >\\r\\n            proposalThreshold(),\\r\\n            \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\"\\r\\n        );\\r\\n        require(\\r\\n            targets.length == values.length &&\\r\\n            targets.length == signatures.length &&\\r\\n            targets.length == calldatas.length,\\r\\n            \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\"\\r\\n        );\\r\\n        require(\\r\\n            targets.length != 0,\\r\\n            \\\"GovernorAlpha::propose: must provide actions\\\"\\r\\n        );\\r\\n        require(\\r\\n            targets.length <= proposalMaxOperations(),\\r\\n            \\\"GovernorAlpha::propose: too many actions\\\"\\r\\n        );\\r\\n\\r\\n        uint256 latestProposalId = latestProposalIds[msg.sender];\\r\\n        if (latestProposalId != 0) {\\r\\n            ProposalState proposersLatestProposalState = state(latestProposalId);\\r\\n            require(\\r\\n                proposersLatestProposalState != ProposalState.Active,\\r\\n                \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\"\\r\\n            );\\r\\n            require(\\r\\n                proposersLatestProposalState != ProposalState.Pending,\\r\\n                \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 startBlock = add256(block.number, votingDelay());\\r\\n        uint256 endBlock = add256(startBlock, votingPeriod);\\r\\n\\r\\n        proposalCount++;\\r\\n        Proposal memory newProposal = Proposal({\\r\\n        id: proposalCount,\\r\\n        proposer: msg.sender,\\r\\n        eta: 0,\\r\\n        targets: targets,\\r\\n        values: values,\\r\\n        signatures: signatures,\\r\\n        calldatas: calldatas,\\r\\n        startBlock: startBlock,\\r\\n        endBlock: endBlock,\\r\\n        forVotes: 0,\\r\\n        againstVotes: 0,\\r\\n        canceled: false,\\r\\n        executed: false\\r\\n        });\\r\\n\\r\\n        proposals[newProposal.id] = newProposal;\\r\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\r\\n\\r\\n        emit ProposalCreated(\\r\\n            newProposal.id,\\r\\n            msg.sender,\\r\\n            targets,\\r\\n            values,\\r\\n            signatures,\\r\\n            calldatas,\\r\\n            startBlock,\\r\\n            endBlock,\\r\\n            description\\r\\n        );\\r\\n        return newProposal.id;\\r\\n    }\\r\\n\\r\\n    function queue(uint256 proposalId) public {\\r\\n        require(\\r\\n            state(proposalId) == ProposalState.Succeeded,\\r\\n            \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\"\\r\\n        );\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        uint256 eta = add256(block.timestamp, timelock.delay());\\r\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\r\\n            _queueOrRevert(\\r\\n                proposal.targets[i],\\r\\n                proposal.values[i],\\r\\n                proposal.signatures[i],\\r\\n                proposal.calldatas[i],\\r\\n                eta\\r\\n            );\\r\\n        }\\r\\n        proposal.eta = eta;\\r\\n        emit ProposalQueued(proposalId, eta);\\r\\n    }\\r\\n\\r\\n    function _queueOrRevert(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string memory signature,\\r\\n        bytes memory data,\\r\\n        uint256 eta\\r\\n    ) internal {\\r\\n        require(\\r\\n            !timelock.queuedTransactions(\\r\\n            keccak256(abi.encode(target, value, signature, data, eta))\\r\\n        ),\\r\\n            \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\"\\r\\n        );\\r\\n        timelock.queueTransaction(target, value, signature, data, eta);\\r\\n    }\\r\\n\\r\\n    function execute(uint256 proposalId) public payable {\\r\\n        require(\\r\\n            state(proposalId) == ProposalState.Queued,\\r\\n            \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\"\\r\\n        );\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        proposal.executed = true;\\r\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\r\\n            timelock.executeTransaction{value:proposal.values[i]}(\\r\\n                proposal.targets[i],\\r\\n                proposal.values[i],\\r\\n                proposal.signatures[i],\\r\\n                proposal.calldatas[i],\\r\\n                proposal.eta\\r\\n            );\\r\\n        }\\r\\n        emit ProposalExecuted(proposalId);\\r\\n    }\\r\\n\\r\\n    function cancel(uint256 proposalId) public {\\r\\n        ProposalState state = state(proposalId);\\r\\n        require(\\r\\n            state != ProposalState.Executed,\\r\\n            \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\"\\r\\n        );\\r\\n\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        require(\\r\\n            alch.getPriorVotes(proposal.proposer, sub256(block.number, 1)) <\\r\\n            proposalThreshold(),\\r\\n            \\\"GovernorAlpha::cancel: proposer above threshold\\\"\\r\\n        );\\r\\n\\r\\n        proposal.canceled = true;\\r\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\r\\n            timelock.cancelTransaction(\\r\\n                proposal.targets[i],\\r\\n                proposal.values[i],\\r\\n                proposal.signatures[i],\\r\\n                proposal.calldatas[i],\\r\\n                proposal.eta\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit ProposalCanceled(proposalId);\\r\\n    }\\r\\n\\r\\n    function getActions(uint256 proposalId)\\r\\n    public\\r\\n    view\\r\\n    returns (\\r\\n        address[] memory targets,\\r\\n        uint256[] memory values,\\r\\n        string[] memory signatures,\\r\\n        bytes[] memory calldatas\\r\\n    )\\r\\n    {\\r\\n        Proposal storage p = proposals[proposalId];\\r\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\r\\n    }\\r\\n\\r\\n    function getReceipt(uint256 proposalId, address voter)\\r\\n    public\\r\\n    view\\r\\n    returns (Receipt memory)\\r\\n    {\\r\\n        return proposals[proposalId].receipts[voter];\\r\\n    }\\r\\n\\r\\n    function state(uint256 proposalId) public view returns (ProposalState) {\\r\\n        require(\\r\\n            proposalCount >= proposalId && proposalId > 0,\\r\\n            \\\"GovernorAlpha::state: invalid proposal id\\\"\\r\\n        );\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        if (proposal.canceled) {\\r\\n            return ProposalState.Canceled;\\r\\n        } else if (block.number <= proposal.startBlock) {\\r\\n            return ProposalState.Pending;\\r\\n        } else if (block.number <= proposal.endBlock) {\\r\\n            return ProposalState.Active;\\r\\n        } else if (\\r\\n            proposal.forVotes <= proposal.againstVotes ||\\r\\n            proposal.forVotes < quorumVotes()\\r\\n        ) {\\r\\n            return ProposalState.Defeated;\\r\\n        } else if (proposal.eta == 0) {\\r\\n            return ProposalState.Succeeded;\\r\\n        } else if (proposal.executed) {\\r\\n            return ProposalState.Executed;\\r\\n        } else if (\\r\\n            block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())\\r\\n        ) {\\r\\n            return ProposalState.Expired;\\r\\n        } else {\\r\\n            return ProposalState.Queued;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function castVote(uint256 proposalId, bool support) public {\\r\\n        return _castVote(msg.sender, proposalId, support);\\r\\n    }\\r\\n\\r\\n    function castVoteBySig(\\r\\n        uint256 proposalId,\\r\\n        bool support,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public {\\r\\n        bytes32 domainSeparator = keccak256(\\r\\n            abi.encode(\\r\\n                DOMAIN_TYPEHASH,\\r\\n                keccak256(bytes(name)),\\r\\n                getChainId(),\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n        bytes32 structHash = keccak256(\\r\\n            abi.encode(BALLOT_TYPEHASH, proposalId, support)\\r\\n        );\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\r\\n        );\\r\\n        address signatory = ecrecover(digest, v, r, s);\\r\\n        require(\\r\\n            signatory != address(0),\\r\\n            \\\"GovernorAlpha::castVoteBySig: invalid signature\\\"\\r\\n        );\\r\\n        return _castVote(signatory, proposalId, support);\\r\\n    }\\r\\n\\r\\n    function _castVote(\\r\\n        address voter,\\r\\n        uint256 proposalId,\\r\\n        bool support\\r\\n    ) internal {\\r\\n        require(\\r\\n            state(proposalId) == ProposalState.Active,\\r\\n            \\\"GovernorAlpha::_castVote: voting is closed\\\"\\r\\n        );\\r\\n        Proposal storage proposal = proposals[proposalId];\\r\\n        Receipt storage receipt = proposal.receipts[voter];\\r\\n        require(\\r\\n            receipt.hasVoted == false,\\r\\n            \\\"GovernorAlpha::_castVote: voter already voted\\\"\\r\\n        );\\r\\n        uint96 votes = alch.getPriorVotes(voter, proposal.startBlock);\\r\\n\\r\\n        if (support) {\\r\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\r\\n        } else {\\r\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\r\\n        }\\r\\n\\r\\n        receipt.hasVoted = true;\\r\\n        receipt.support = support;\\r\\n        receipt.votes = votes;\\r\\n\\r\\n        emit VoteCast(voter, proposalId, support, votes);\\r\\n    }\\r\\n\\r\\n    function __acceptAdmin() public {\\r\\n        timelock.acceptAdmin();\\r\\n    }\\r\\n\\r\\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"subtraction underflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function getChainId() internal pure returns (uint256) {\\r\\n        uint256 chainId;\\r\\n        assembly {\\r\\n            chainId := chainid()\\r\\n        }\\r\\n        return chainId;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface AlchInterface {\\r\\n    function getPriorVotes(address account, uint256 blockNumber)\\r\\n    external\\r\\n    view\\r\\n    returns (uint96);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n\\r\\ninterface ITimelock {\\r\\n    event NewAdmin(address indexed newAdmin);\\r\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\r\\n    event NewDelay(uint256 indexed newDelay);\\r\\n    event CancelTransaction(\\r\\n        bytes32 indexed txHash,\\r\\n        address indexed target,\\r\\n        uint256 value,\\r\\n        string signature,\\r\\n        bytes data,\\r\\n        uint256 eta\\r\\n    );\\r\\n    event ExecuteTransaction(\\r\\n        bytes32 indexed txHash,\\r\\n        address indexed target,\\r\\n        uint256 value,\\r\\n        string signature,\\r\\n        bytes data,\\r\\n        uint256 eta\\r\\n    );\\r\\n    event QueueTransaction(\\r\\n        bytes32 indexed txHash,\\r\\n        address indexed target,\\r\\n        uint256 value,\\r\\n        string signature,\\r\\n        bytes data,\\r\\n        uint256 eta\\r\\n    );\\r\\n\\r\\n    function GRACE_PERIOD() external pure returns (uint256);\\r\\n\\r\\n    function MINIMUM_DELAY() external pure returns (uint256);\\r\\n\\r\\n    function MAXIMUM_DELAY() external pure returns (uint256);\\r\\n\\r\\n    function admin() external view returns (address);\\r\\n\\r\\n    function pendingAdmin() external view returns (address);\\r\\n\\r\\n    function delay() external view returns (uint256);\\r\\n\\r\\n    function queuedTransactions(bytes32) external view returns (bool);\\r\\n\\r\\n    function setDelay(uint256 delay_) external;\\r\\n\\r\\n    function acceptAdmin() external;\\r\\n\\r\\n    function setPendingAdmin(address pendingAdmin_) external;\\r\\n\\r\\n    function queueTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string calldata signature,\\r\\n        bytes calldata data,\\r\\n        uint256 eta\\r\\n    ) external returns (bytes32);\\r\\n\\r\\n    function cancelTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string calldata signature,\\r\\n        bytes calldata data,\\r\\n        uint256 eta\\r\\n    ) external;\\r\\n\\r\\n    function executeTransaction(\\r\\n        address target,\\r\\n        uint256 value,\\r\\n        string calldata signature,\\r\\n        bytes calldata data,\\r\\n        uint256 eta\\r\\n    ) external payable returns (bytes memory);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"alch_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setVotingPeriodAfter_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alch\",\"outputs\":[{\"internalType\":\"contract AlchInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"internalType\":\"struct AlchemyGovernorAlpha.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentVotingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPermanentVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setVotingPeriodAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum AlchemyGovernorAlpha.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract ITimelock\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AlchemyGovernorAlpha", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca2b3cf3989e70813719ac7703daf4b14f46b3770000000000000000000000000000a1c00009a619684135b824ba02f7fbf3a57200000000000000000000000000000000000000000000000000000000608a83a0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}