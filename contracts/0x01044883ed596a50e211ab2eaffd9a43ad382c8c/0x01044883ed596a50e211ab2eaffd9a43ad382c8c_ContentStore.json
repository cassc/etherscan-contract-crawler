{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ethfs/ContentStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.20;\\n\\nimport {SSTORE2} from \\\"./solady/utils/SSTORE2.sol\\\";\\nimport {IContentStore} from \\\"./IContentStore.sol\\\";\\n\\ncontract ContentStore is IContentStore {\\n    // content checksum => sstore2 pointer\\n    mapping(bytes32 => address) public pointers;\\n\\n    function checksumExists(bytes32 checksum) public view returns (bool) {\\n        return pointers[checksum] != address(0);\\n    }\\n\\n    function contentLength(bytes32 checksum)\\n        public\\n        view\\n        returns (uint256 size)\\n    {\\n        if (!checksumExists(checksum)) {\\n            revert ChecksumNotFound(checksum);\\n        }\\n        return SSTORE2.read(pointers[checksum]).length;\\n    }\\n\\n    function addPointer(address pointer) public returns (bytes32 checksum) {\\n        bytes memory content = SSTORE2.read(pointer);\\n        checksum = keccak256(content);\\n        if (pointers[checksum] != address(0)) {\\n            return checksum;\\n        }\\n        pointers[checksum] = pointer;\\n        emit NewChecksum(checksum, content.length);\\n        return checksum;\\n    }\\n\\n    function addContent(bytes memory content)\\n        public\\n        returns (bytes32 checksum, address pointer)\\n    {\\n        checksum = keccak256(content);\\n        if (pointers[checksum] != address(0)) {\\n            return (checksum, pointers[checksum]);\\n        }\\n        pointer = SSTORE2.write(content);\\n        pointers[checksum] = pointer;\\n        emit NewChecksum(checksum, content.length);\\n        return (checksum, pointer);\\n    }\\n\\n    function getPointer(bytes32 checksum)\\n        public\\n        view\\n        returns (address pointer)\\n    {\\n        if (!checksumExists(checksum)) {\\n            revert ChecksumNotFound(checksum);\\n        }\\n        return pointers[checksum];\\n    }\\n}\"\r\n    },\r\n    \"contracts/ethfs/IContentStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.20;\\n\\ninterface IContentStore {\\n    event NewChecksum(bytes32 indexed checksum, uint256 contentSize);\\n\\n    error ChecksumExists(bytes32 checksum);\\n    error ChecksumNotFound(bytes32 checksum);\\n\\n    function pointers(bytes32 checksum)\\n        external\\n        view\\n        returns (address pointer);\\n\\n    function checksumExists(bytes32 checksum) external view returns (bool);\\n\\n    function contentLength(bytes32 checksum)\\n        external\\n        view\\n        returns (uint256 size);\\n\\n    function addPointer(address pointer) external returns (bytes32 checksum);\\n\\n    function addContent(bytes memory content)\\n        external\\n        returns (bytes32 checksum, address pointer);\\n\\n    function getPointer(bytes32 checksum)\\n        external\\n        view\\n        returns (address pointer);\\n}\"\r\n    },\r\n    \"contracts/ethfs/solady/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error DeploymentFailed();\\n\\n    error InvalidPointer();\\n\\n    error ReadOutOfBounds();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         WRITE LOGIC                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Note: The assembly block below does not expand the memory.\\n        assembly {\\n            let originalDataLength := mload(data)\\n\\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\\n            let dataSize := add(originalDataLength, 1)\\n\\n            /**\\n             * ------------------------------------------------------------------------------+\\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\\n             * ------------------------------------------------------------------------------|\\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\\n             * 80          | DUP1            | codeSize codeSize       |                     |\\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\\n             * 3D          | RETURNDATASZIE  | 0 codeSize              | [0..codeSize): code |\\n             * F3          | RETURN          |                         | [0..codeSize): code |\\n             * 00          | STOP            |                         |                     |\\n             * ------------------------------------------------------------------------------+\\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\\n             */\\n            mstore(\\n                data,\\n                or(\\n                    0x61000080600a3d393df300,\\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\\n                    shl(0x40, dataSize)\\n                )\\n            )\\n\\n            // Deploy a new contract with the generated creation code.\\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\\n\\n            // If `pointer` is zero, revert.\\n            if iszero(pointer) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore original length of the variable size `data`.\\n            mstore(data, originalDataLength)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         READ LOGIC                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function read(address pointer) internal view returns (bytes memory data) {\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Offset all indices by 1 to skip the STOP opcode.\\n            let size := sub(pointerCodesize, 1)\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            extcodecopy(pointer, add(data, 0x20), 1, size)\\n        }\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // If `!(pointer.code.size > start)`, reverts.\\n            // This also handles the case where `start + 1` overflows.\\n            if iszero(gt(pointerCodesize, start)) {\\n                // Store the function selector of `ReadOutOfBounds()`.\\n                mstore(0x00, 0x84eb0dd1)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            let size := sub(pointerCodesize, add(start, 1))\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\\n        }\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory data) {\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\\n            // This also handles the cases where `end + 1` or `start + 1` overflow.\\n            if iszero(\\n                and(\\n                    gt(pointerCodesize, end), // Within bounds.\\n                    iszero(gt(start, end)) // Valid range.\\n                )\\n            ) {\\n                // Store the function selector of `ReadOutOfBounds()`.\\n                mstore(0x00, 0x84eb0dd1)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            let size := sub(end, start)\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"ChecksumExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"ChecksumNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contentSize\",\"type\":\"uint256\"}],\"name\":\"NewChecksum\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"content\",\"type\":\"bytes\"}],\"name\":\"addContent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"addPointer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"checksumExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"contentLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"getPointer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pointers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ContentStore", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}