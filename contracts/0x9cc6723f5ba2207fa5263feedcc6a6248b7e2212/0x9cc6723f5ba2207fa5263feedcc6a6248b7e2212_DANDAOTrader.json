{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.18;\r\nstruct ParamsCall {\r\n    address _pool;\r\n    address _router;\r\n    bytes _bytes;\r\n}\r\nstruct memberStruct {\r\n    address user;\r\n    uint256 times;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract DANDAOTrader {\r\n    string public name = \"DANDAOTraderV2\";\r\n    address private owner;\r\n    address private admin;\r\n    address public ETH;\r\n    uint256 public price = 0;\r\n    mapping(address => uint256) private members;\r\n\r\n    constructor(address _ETH) {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        ETH = _ETH;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyAdmin() {\r\n        require(admin == msg.sender || owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address newAddress) external onlyOwner {\r\n        require(newAddress != address(0), \"Invalid Address\");\r\n        admin = newAddress;\r\n    }\r\n\r\n    function transferOwnership(address newAddress) external onlyOwner {\r\n        require(newAddress != address(0), \"Invalid Address\");\r\n        owner = newAddress;\r\n    }\r\n\r\n    function setBaseData(uint256 _price) external onlyAdmin {\r\n        price = _price;\r\n    }\r\n\r\n    function batchSetMember(memberStruct[] memory users) external onlyAdmin {\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            memberStruct memory user = users[i];\r\n            members[user.user] = user.times;\r\n        }\r\n    }\r\n\r\n    function withdrawERC20(\r\n        address _recipient,\r\n        address erc20address\r\n    ) external onlyOwner {\r\n        IERC20 fountain = IERC20(erc20address);\r\n        uint256 balance = fountain.balanceOf(address(this));\r\n        fountain.transfer(_recipient, balance);\r\n    }\r\n\r\n    function withdrawETH(address _recipient) external onlyOwner {\r\n        (bool rt, ) = payable(_recipient).call{value: address(this).balance}(\r\n            \"\"\r\n        );\r\n        require(rt);\r\n    }\r\n\r\n    function FuckTuGouSell(\r\n        address target,\r\n        address router,\r\n        uint256 amountIn,\r\n        uint256 amountMinOut,\r\n        bytes memory _bytes\r\n    ) public payable {\r\n        require(msg.value == price, \"Price Error\");\r\n        require(\r\n            IERC20(target).allowance(msg.sender, address(this)) >= amountIn,\r\n            \"Approve Error\"\r\n        );\r\n        require(\r\n            IERC20(target).balanceOf(msg.sender) >= amountIn,\r\n            \"Balance Too Low\"\r\n        );\r\n        IERC20(target).transferFrom(msg.sender, address(this), amountIn);\r\n        (uint256 preETHBalance, uint256 preWETHBalance) = checkETHBalance(\r\n            msg.sender\r\n        );\r\n        if (IERC20(target).allowance(address(this), router) < amountIn) {\r\n            IERC20(target).approve(router, IERC20(target).totalSupply());\r\n        }\r\n        (bool rt, ) = payable(router).call{value: 0}(_bytes);\r\n        require(rt, \"Swap Error\");\r\n        if (amountMinOut > 0) {\r\n            (uint256 nextETHBalance, uint256 nextWETHBalance) = checkETHBalance(\r\n                msg.sender\r\n            );\r\n            if (nextETHBalance > preETHBalance) {\r\n                require(\r\n                    nextETHBalance - preETHBalance >= amountMinOut,\r\n                    \"Receive Too Low\"\r\n                );\r\n            }\r\n            if (nextWETHBalance > preWETHBalance) {\r\n                require(\r\n                    nextWETHBalance - preWETHBalance >= amountMinOut,\r\n                    \"Receive Too Low\"\r\n                );\r\n            }\r\n        }\r\n        if (members[msg.sender] > 0) {\r\n            (bool rts, bytes memory resons) = payable(msg.sender).call{\r\n                value: msg.value\r\n            }(\"\");\r\n            require(rts, string(resons));\r\n            members[msg.sender] = members[msg.sender] - 1;\r\n        }\r\n    }\r\n\r\n    function checkETHBalance(\r\n        address _sender\r\n    ) public view returns (uint256 preETHBalance, uint256 preWETHBalance) {\r\n        preETHBalance = address(_sender).balance;\r\n        preWETHBalance = IERC20(ETH).balanceOf(_sender);\r\n    }\r\n\r\n    function FuckTuGouBuy(\r\n        address target,\r\n        uint256 amountMinOut,\r\n        uint256 percent,\r\n        ParamsCall[] memory params\r\n    ) public payable {\r\n        (uint256 index, uint256 userPreBalance) = checkPoolBalance(\r\n            target,\r\n            msg.sender,\r\n            percent,\r\n            params\r\n        );\r\n        uint256 amount;\r\n        if (members[msg.sender] < 1) {\r\n            amount = msg.value - price;\r\n        } else {\r\n            amount = msg.value;\r\n            members[msg.sender] = members[msg.sender] - 1;\r\n        }\r\n        (bool rt, bytes memory reson) = payable(params[index]._router).call{\r\n            value: amount\r\n        }(params[index]._bytes);\r\n        require(rt, string(reson));\r\n        if (amountMinOut > 0) {\r\n            uint256 userNextBalance = IERC20(target).balanceOf(msg.sender);\r\n            uint256 userCurrentBalance = userNextBalance - userPreBalance;\r\n            require(userCurrentBalance >= amountMinOut, \"Receive Too Low\");\r\n        }\r\n    }\r\n\r\n    function checkPoolBalance(\r\n        address target,\r\n        address sender,\r\n        uint256 percent,\r\n        ParamsCall[] memory params\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 _coinBalance;\r\n        uint256 _index;\r\n        for (uint256 i = 0; i < params.length; i++) {\r\n            uint256 poolBalance = IERC20(target).balanceOf(params[i]._pool);\r\n            if (poolBalance > _coinBalance) {\r\n                _index = i;\r\n                _coinBalance = poolBalance;\r\n            }\r\n        }\r\n        require(_coinBalance > 0, \"Not Add Liquidity\");\r\n        if (percent > 0) {\r\n            checkPoolPercent(target, _coinBalance, percent);\r\n        }\r\n        uint256 _userPreBalance = IERC20(target).balanceOf(sender);\r\n        return (_index, _userPreBalance);\r\n    }\r\n\r\n    function checkPoolPercent(\r\n        address target,\r\n        uint256 _coinBalance,\r\n        uint256 percent\r\n    ) internal view {\r\n        uint256 totalSupply = IERC20(target).totalSupply();\r\n        uint256 poolpercent = (_coinBalance * 1000) / totalSupply;\r\n        require(poolpercent > percent, \"Pool Percent Low\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_bytes\",\"type\":\"bytes\"}],\"internalType\":\"struct ParamsCall[]\",\"name\":\"params\",\"type\":\"tuple[]\"}],\"name\":\"FuckTuGouBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountMinOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"FuckTuGouSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"internalType\":\"struct memberStruct[]\",\"name\":\"users\",\"type\":\"tuple[]\"}],\"name\":\"batchSetMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkETHBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"preETHBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preWETHBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setBaseData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20address\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DANDAOTrader", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d70c32ab7b335ed4fc1d3c28aacaf38077134233517643442fefccd0b144d924"}