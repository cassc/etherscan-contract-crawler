{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IMinter {\\n    function update_period() external returns (uint);\\n    function check() external view returns(bool);\\n    function period() external view returns(uint);\\n    function active_period() external view returns(uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IRewardsDistributor {\\n    function checkpoint_token() external;\\n    function voting_escrow() external view returns(address);\\n    function checkpoint_total_supply() external;\\n    function claim(uint _tokenId) external returns(uint);\\n    function claimable(uint _tokenId) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IVotingEscrow {\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n    }\\n\\n    struct LockedBalance {\\n        int128 amount;\\n        uint end;\\n    }\\n\\n    function create_lock(uint _value, uint _lock_duration) external returns (uint);\\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external returns (uint);\\n    function merge(uint _from, uint _to) external;\\n    function increase_amount(uint _tokenId, uint _value) external;\\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external;\\n    function split(uint[] memory amounts, uint _tokenId) external;\\n    function withdraw(uint _tokenId) external;\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    function locked(uint id) external view returns(LockedBalance memory);\\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint);\\n\\n    function token() external view returns (address);\\n    function team() external returns (address);\\n    function epoch() external view returns (uint);\\n    function point_history(uint loc) external view returns (Point memory);\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n    function optionToken() external view returns (address);\\n    function ownerOf(uint) external view returns (address);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function transferFrom(address, address, uint) external;\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint _tokenId\\n    ) external;\\n\\n    function voted(uint) external view returns (bool);\\n    function attachments(uint) external view returns (uint);\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n\\n    function checkpoint() external;\\n    function deposit_for(uint tokenId, uint value) external;\\n\\n    function balanceOfNFT(uint _id) external view returns (uint);\\n    function balanceOf(address _owner) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n    function supply() external view returns (uint);\\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint);\\n    function balanceOfAtNFT(uint _tokenId, uint _t) external view returns (uint);\\n\\n\\n\\n    function decimals() external view returns(uint8);\\n}\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n    function cbrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        uint256 x = 0;\\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\\n            x <<= 1;\\n            uint256 z = 3 * x * (x + 1) + 1;\\n            if (n / y >= z) {\\n                n -= y * z;\\n                x += 1;\\n            }\\n        }\\n        return x;\\n    }}\\n}\\n\"\r\n    },\r\n    \"contracts/RewardsDistributorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport './libraries/Math.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IRewardsDistributor.sol';\\nimport './interfaces/IVotingEscrow.sol';\\nimport './interfaces/IMinter.sol';\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n\\n/*\\n\\n@title Curve Fee Distribution modified for ve(3,3) emissions\\n@author Thena Finance, Prometheus\\n@license MIT\\n\\n*/\\n\\ncontract RewardsDistributorV2 is ReentrancyGuard, IRewardsDistributor {\\n\\n    event CheckpointToken(\\n        uint time,\\n        uint tokens\\n    );\\n\\n    event Claimed(\\n        uint tokenId,\\n        uint amount,\\n        uint claim_epoch, //timestamp\\n        uint max_epoch\\n    );\\n\\n    uint constant WEEK = 7 * 86400;\\n\\n    uint public start_time;\\n    uint public last_token_time;\\n    uint public last_week;\\n    uint public total_distributed;\\n    uint public token_claimed;\\n    uint public time_cursor;\\n\\n\\n    uint[1000000000000000] public tokens_per_week;\\n    uint[1000000000000000] public ve_supply;\\n\\n    address public owner;\\n    address public voting_escrow;\\n    address public token;\\n    address public depositor;\\n    bool public permissionedClaims = true;\\n\\n    \\n    mapping(uint => uint) public time_cursor_of;\\n    mapping(uint => uint) internal time_to_block;\\n\\n  \\n\\n    constructor(address _voting_escrow, address _minter) {\\n        uint _t = block.timestamp / WEEK * WEEK;\\n        last_token_time = _t;\\n        time_cursor = _t;\\n        \\n        address _token = IVotingEscrow(_voting_escrow).token();\\n        token = _token;\\n\\n        voting_escrow = _voting_escrow;\\n\\n        depositor = _minter; //0x86069FEb223EE303085a1A505892c9D4BdBEE996 bsc\\n        start_time = _t;\\n\\n        owner = msg.sender;\\n\\n        require(IERC20(_token).approve(_voting_escrow, type(uint).max));\\n    }\\n\\n    function timestamp() public view returns (uint) {\\n        return block.timestamp / WEEK * WEEK;\\n    }\\n\\n    // checkpoint the total supply at the current timestamp. Called by depositor\\n    function checkpoint_total_supply() external {\\n        assert(msg.sender == depositor || msg.sender == owner);\\n        _checkpoint_total_supply();\\n    }\\n    function _checkpoint_total_supply() internal {\\n        address ve = voting_escrow;\\n        uint t = time_cursor;\\n        uint rounded_timestamp = block.timestamp / WEEK * WEEK;\\n        IVotingEscrow(ve).checkpoint();\\n\\n        for (uint i = 0; i < 20; i++) {\\n            if (t > rounded_timestamp) {\\n                break;\\n            } else {\\n                uint epoch = _find_timestamp_epoch(ve, t);\\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(epoch);\\n                int128 dt = 0;\\n                if (t > pt.ts) {\\n                    dt = int128(int256(t - pt.ts));\\n                }\\n                ve_supply[t] = Math.max(uint(int256(pt.bias - pt.slope * dt)), 0);\\n            }\\n            t += WEEK;\\n        }\\n\\n        time_cursor = t;\\n    }\\n\\n    \\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\\n        uint _min = 0;\\n        uint _max = IVotingEscrow(ve).epoch();\\n        for (uint i = 0; i < 128; i++) {\\n            if (_min >= _max) break;\\n            uint _mid = (_min + _max + 2) / 2;\\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(_mid);\\n            if (pt.ts <= _timestamp) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n        return _min;\\n    }\\n\\n\\n\\n    // checkpoint the token to distribute for the last epoch\\n    function checkpoint_token() external {\\n        assert(msg.sender == depositor || msg.sender == owner);\\n        _checkpoint_token();\\n    }\\n\\n    function _checkpoint_token() internal {\\n\\n        last_week = block.timestamp / WEEK * WEEK;\\n        time_to_block[last_week] = block.number;\\n        last_token_time = block.timestamp;\\n        \\n        uint token_balance = IERC20(token).balanceOf(address(this));\\n        uint diff = total_distributed - token_claimed;\\n        uint to_distribute = token_balance - diff;\\n        \\n        tokens_per_week[last_week] += to_distribute;\\n        total_distributed += to_distribute;\\n\\n        emit CheckpointToken(block.timestamp, to_distribute);\\n    }\\n  \\n\\n    \\n    function claimable(uint _tokenId) external view returns(uint) {\\n        uint t = time_cursor_of[_tokenId];\\n        if(t == 0) t = start_time;\\n        uint _last_week = last_week;\\n        uint to_claim = 0;\\n        for(uint i = 0; i < 100; i++){\\n            if(t > _last_week) break;\\n            to_claim += _toClaim(_tokenId, t);\\n            t += WEEK;\\n        }        \\n        return to_claim;\\n    }\\n        \\n\\n    function claim_many(uint[] memory tokenIds) external nonReentrant returns(bool) {\\n        require(tokenIds.length <= 25);\\n        for(uint i = 0; i < tokenIds.length; i++){\\n            _claim(tokenIds[i]);\\n        }\\n        return true;\\n    }\\n\\n    function claim(uint _tokenId) external nonReentrant returns(uint){\\n        return _claim(_tokenId);\\n    }\\n\\n    function _claim(uint _tokenId) internal returns (uint) {\\n        if(permissionedClaims){\\n            require(IVotingEscrow(voting_escrow).isApprovedOrOwner(msg.sender, _tokenId), 'not approved');\\n        }\\n\\n        IVotingEscrow.LockedBalance memory _locked = IVotingEscrow(voting_escrow).locked(_tokenId);\\n        require(_locked.amount > 0, 'No existing lock found');\\n        require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\n\\n        uint t = time_cursor_of[_tokenId];\\n        if(t < start_time) t = start_time;\\n        uint _last_week = last_week;\\n        uint to_claim = 0;\\n\\n        for(uint i = 0; i < 100; i++){\\n            if(t > _last_week) break;\\n            to_claim += _toClaim(_tokenId, t);\\n            t += WEEK;\\n        }        \\n\\n        if(to_claim > 0) IVotingEscrow(voting_escrow).deposit_for(_tokenId, to_claim);\\n        time_cursor_of[_tokenId] = t;\\n        token_claimed += to_claim;\\n\\n        emit Claimed(_tokenId, to_claim, last_week, _find_timestamp_epoch(voting_escrow, last_week));\\n\\n        return to_claim;\\n    }\\n\\n    function _toClaim(uint id, uint t) internal view returns(uint to_claim) {\\n\\n        IVotingEscrow.Point memory userData = IVotingEscrow(voting_escrow).user_point_history(id,1);\\n\\n        if(ve_supply[t] == 0) return 0;\\n        if(tokens_per_week[t] == 0) return 0;\\n        if(userData.ts > t) return 0;\\n\\n        //uint id_bal = IVotingEscrow(voting_escrow).balanceOfNFTAt(id, t);\\n        uint id_bal = IVotingEscrow(voting_escrow).balanceOfAtNFT(id, time_to_block[t]);\\n        uint share =  id_bal * 1e18 / ve_supply[t];\\n        \\n        to_claim = share * tokens_per_week[t] / 1e18;\\n    }\\n\\n    /*  Owner Functions */\\n\\n    function setDepositor(address _depositor) external {\\n        require(msg.sender == owner);\\n        depositor = _depositor;\\n    }\\n\\n    function setPermissionedClaims(bool value) external {\\n        require(msg.sender == owner);\\n        permissionedClaims = value;\\n    }\\n\\n    function setOwner(address _owner) external {\\n        require(msg.sender == owner);\\n        owner = _owner;\\n    }\\n\\n    function increaseOrRemoveAllowances(bool what) external {\\n        require(msg.sender == owner);\\n        what == true ? IERC20(token).approve(voting_escrow, type(uint).max) : IERC20(token).approve(voting_escrow, 0);\\n    }\\n\\n    function withdrawERC20(address _token) external {\\n        require(msg.sender == owner);\\n        require(_token != address(0));\\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).transfer(msg.sender, _balance);\\n    }\\n\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voting_escrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"CheckpointToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claim_epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_epoch\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkpoint_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint_total_supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claim_many\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"what\",\"type\":\"bool\"}],\"name\":\"increaseOrRemoveAllowances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_token_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_week\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissionedClaims\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPermissionedClaims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time_cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time_cursor_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens_per_week\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_distributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ve_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting_escrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardsDistributorV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000a5c73c9257e9bb50acabcbb4c826505a97ae7c950000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}