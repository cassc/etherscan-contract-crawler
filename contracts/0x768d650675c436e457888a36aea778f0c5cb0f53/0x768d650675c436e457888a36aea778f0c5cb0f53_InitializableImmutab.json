{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0 AND MIT AND agpl-3.0\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.9.3\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t *\r\n\t * Furthermore, `isContract` will also return true if the target contract within\r\n\t * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n\t * which only has an effect at the end of a transaction.\r\n\t * ====\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n\t *\r\n\t * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n\t * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n\t * constructor.\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize/address.code.length, which returns 0\r\n\t\t// for contracts in construction, since the code is only stored at the end\r\n\t\t// of the constructor execution.\r\n\r\n\t\treturn account.code.length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n\t * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n\t *\r\n\t * _Available since v4.8._\r\n\t */\r\n\tfunction verifyCallResultFromTarget(\r\n\t\taddress target,\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\tif (returndata.length == 0) {\r\n\t\t\t\t// only check isContract if the call was successful and the return data is empty\r\n\t\t\t\t// otherwise we already know that it was a contract\r\n\t\t\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\t\t\t}\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t_revert(returndata, errorMessage);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n\t * revert reason or using the provided one.\r\n\t *\r\n\t * _Available since v4.3._\r\n\t */\r\n\tfunction verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t_revert(returndata, errorMessage);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n\t\t// Look for revert reason and bubble it up if present\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trevert(errorMessage);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/dependencies/openzeppelin/upgradeability/Proxy.sol\r\n\r\n// Original license: SPDX_License_Identifier: agpl-3.0\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n\t/**\r\n\t * @dev Fallback function.\r\n\t * Implemented entirely in `_fallback`.\r\n\t */\r\n\tfallback() external payable {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @return The Address of the implementation.\r\n\t */\r\n\tfunction _implementation() internal view virtual returns (address);\r\n\r\n\t/**\r\n\t * @dev Delegates execution to an implementation contract.\r\n\t * This is a low level function that doesn't return to its internal call site.\r\n\t * It will return to the external caller whatever the implementation returns.\r\n\t * @param implementation Address to delegate.\r\n\t */\r\n\tfunction _delegate(address implementation) internal {\r\n\t\t//solium-disable-next-line\r\n\t\tassembly {\r\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\r\n\t\t\t// block because it will not return to Solidity code. We overwrite the\r\n\t\t\t// Solidity scratch pad at memory position 0.\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\r\n\t\t\t// Call the implementation.\r\n\t\t\t// out and outsize are 0 because we don't know the size yet.\r\n\t\t\tlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n\t\t\t// Copy the returned data.\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\r\n\t\t\tswitch result\r\n\t\t\t// delegatecall returns 0 on error.\r\n\t\t\tcase 0 {\r\n\t\t\t\trevert(0, returndatasize())\r\n\t\t\t}\r\n\t\t\tdefault {\r\n\t\t\t\treturn(0, returndatasize())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is run as the first thing in the fallback function.\r\n\t * Can be redefined in derived contracts to add functionality.\r\n\t * Redefinitions must call super._willFallback().\r\n\t */\r\n\tfunction _willFallback() internal virtual {}\r\n\r\n\t/**\r\n\t * @dev fallback implementation.\r\n\t * Extracted to enable manual triggering.\r\n\t */\r\n\tfunction _fallback() internal {\r\n\t\t_willFallback();\r\n\t\t_delegate(_implementation());\r\n\t}\r\n}\r\n\r\n// File contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\r\n\r\n// Original license: SPDX_License_Identifier: agpl-3.0\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n\t/**\r\n\t * @dev Emitted when the implementation is upgraded.\r\n\t * @param implementation Address of the new implementation.\r\n\t */\r\n\tevent Upgraded(address indexed implementation);\r\n\r\n\t/**\r\n\t * @dev Storage slot with the address of the current implementation.\r\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n\t * validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n\t/**\r\n\t * @dev Returns the current implementation.\r\n\t * @return impl Address of the current implementation\r\n\t */\r\n\tfunction _implementation() internal view override returns (address impl) {\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\t\t//solium-disable-next-line\r\n\t\tassembly {\r\n\t\t\timpl := sload(slot)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrades the proxy to a new implementation.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t */\r\n\tfunction _upgradeTo(address newImplementation) internal {\r\n\t\t_setImplementation(newImplementation);\r\n\t\temit Upgraded(newImplementation);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the implementation address of the proxy.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t */\r\n\tfunction _setImplementation(address newImplementation) internal {\r\n\t\trequire(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n\t\t//solium-disable-next-line\r\n\t\tassembly {\r\n\t\t\tsstore(slot, newImplementation)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\r\n\r\n// Original license: SPDX_License_Identifier: agpl-3.0\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\t/**\r\n\t * @dev Contract initializer.\r\n\t * @param _logic Address of the initial implementation.\r\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n\t * It should include the signature and the parameters of the function to be called, as described in\r\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n\t */\r\n\tfunction initialize(address _logic, bytes memory _data) public payable {\r\n\t\trequire(_implementation() == address(0));\r\n\t\tassert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n\t\t_setImplementation(_logic);\r\n\t\tif (_data.length > 0) {\r\n\t\t\t(bool success, ) = _logic.delegatecall(_data);\r\n\t\t\trequire(success);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/lending/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @title BaseImmutableAdminUpgradeabilityProxy\r\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\r\n * helps saving transactions costs\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\taddress immutable ADMIN;\r\n\r\n\tconstructor(address _admin) {\r\n\t\tADMIN = _admin;\r\n\t}\r\n\r\n\tmodifier ifAdmin() {\r\n\t\tif (msg.sender == ADMIN) {\r\n\t\t\t_;\r\n\t\t} else {\r\n\t\t\t_fallback();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return _address The address of the proxy admin.\r\n\t */\r\n\tfunction admin() external ifAdmin returns (address _address) {\r\n\t\treturn ADMIN;\r\n\t}\r\n\r\n\t/**\r\n\t * @return _address The address of the implementation.\r\n\t */\r\n\tfunction implementation() external ifAdmin returns (address _address) {\r\n\t\treturn _implementation();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy.\r\n\t * Only the admin can call this function.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t */\r\n\tfunction upgradeTo(address newImplementation) external ifAdmin {\r\n\t\t_upgradeTo(newImplementation);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Upgrade the backing implementation of the proxy and call a function\r\n\t * on the new implementation.\r\n\t * This is useful to initialize the proxied contract.\r\n\t * @param newImplementation Address of the new implementation.\r\n\t * @param data Data to send as msg.data in the low level call.\r\n\t * It should include the signature and the parameters of the function to be called, as described in\r\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n\t */\r\n\tfunction upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\r\n\t\t_upgradeTo(newImplementation);\r\n\t\t(bool success, ) = newImplementation.delegatecall(data);\r\n\t\trequire(success);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Only fall back when the sender is not the admin.\r\n\t */\r\n\tfunction _willFallback() internal virtual override {\r\n\t\trequire(msg.sender != ADMIN, \"Cannot call fallback function from the proxy admin\");\r\n\t\tsuper._willFallback();\r\n\t}\r\n}\r\n\r\n// File contracts/lending/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\r\n */\r\ncontract InitializableImmutableAdminUpgradeabilityProxy is\r\n\tBaseImmutableAdminUpgradeabilityProxy,\r\n\tInitializableUpgradeabilityProxy\r\n{\r\n\tconstructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}\r\n\r\n\t/**\r\n\t * @dev Only fall back when the sender is not the admin.\r\n\t */\r\n\tfunction _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\r\n\t\tBaseImmutableAdminUpgradeabilityProxy._willFallback();\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "InitializableImmutableAdminUpgradeabilityProxy", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000768d650675c436e457888a36aea778f0c5cb0f53", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xbfb10946f555b0eba492193d4d1b011d3810b38f", "SwarmSource": "ipfs://b341a2955f497c626751626350ed7a4e674c76a846828e641fe7a2ed5226afd8"}