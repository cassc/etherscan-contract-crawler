{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FreeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n// import \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20Token is ERC20, Owned {\\n    using SafeMath for uint256;\\n\\n    uint public max_holding;\\n    uint public max_transfer;\\n    uint public sell_tax_threshold;\\n    uint public buy_tax;\\n    uint public sell_tax;\\n    uint public in_swap = 1; // 1 is false, 2 is true\\n    uint public is_trading_enabled = 1; // 1 is false, 2 is true\\n\\tuint public maxSupply;\\n\\n    address public tax_receiver;\\n\\n    mapping(address => bool) public lps;\\n    mapping(address => bool) public routers;\\n    mapping(address => bool) public anti_whale_exceptions;\\n    mapping(address => bool) public tax_exceptions;\\n\\n    address public weth;\\n    address public uni_router;\\n    address public uni_factory;\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimals,\\n        uint _totalSupply,\\n\\t\\tuint _maxSupply,\\n\\n        uint _max_holding,\\n        uint _max_transfer,\\n        uint _buy_tax,\\n        uint _sell_tax,\\n\\n        address _uni_router,\\n        address _weth\\n    ) ERC20(name, ticker, decimals) Owned(msg.sender) {\\n        require(_buy_tax <= 30, \\\"buy tax too high\\\");\\n        require(_sell_tax <= 30, \\\"sell tax too high\\\");\\n\\t\\trequire(_maxSupply >= _totalSupply, \\\"Invalid max supply provided\\\");\\n\\n        require(\\n            _max_holding >= _totalSupply.div(100),\\n            \\\"Max Holding Limit cannot be less than 1% of total supply\\\"\\n        );\\n        require(\\n            _max_transfer >= _totalSupply.div(100),\\n            \\\"Max Transfer Limit cannot be less than 1% of total supply\\\"\\n        );\\n\\n        max_holding = _max_holding;\\n        max_transfer = _max_transfer;\\n\\n        sell_tax_threshold = _totalSupply / 500; // 0.5%\\n        buy_tax = _buy_tax;\\n        sell_tax = _sell_tax;\\n\\t\\tmaxSupply = _maxSupply;\\n\\n        anti_whale_exceptions[address(this)] = true;\\n        anti_whale_exceptions[msg.sender] = true;\\n\\n        uni_router = _uni_router;\\n        uni_factory = IUniswapV2Router01(uni_router).factory();\\n        weth = _weth;\\n\\n        routers[_uni_router] = true;\\n        allowance[address(this)][_uni_router] = type(uint256).max;\\n        anti_whale_exceptions[_uni_router] = true;\\n        allowance[msg.sender][address(this)] = type(uint256).max;\\n\\n        tax_receiver = owner;\\n\\n        _mint(msg.sender, _totalSupply);\\n    }\\n\\n    modifier lockTheSwap() {\\n        in_swap = 2;\\n        _;\\n        in_swap = 1;\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) {\\n            require(allowed >= amount, \\\"FreeERC20: Not enough allowance\\\");\\n\\n            allowance[from][msg.sender] = allowed - amount;\\n        }\\n\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint amount) private {\\n        require(\\n            is_trading_enabled == 2 || tx.origin == owner,\\n            \\\"FreeERC20: Trading isnt live\\\"\\n        );\\n        require(from != address(0), \\\"FreeERC20: Transfer from the zero address\\\");\\n        require(to != address(0), \\\"FreeERC20: Transfer to the zero address\\\");\\n        require(amount > 0, \\\"FreeERC20: Transfer amount must be greater than zero\\\");\\n        uint256 taxAmount = 0;\\n        if (from != owner && to != owner && tx.origin != owner) {\\n            bool isSelling;\\n            if (lps[from] && !routers[to] && !tax_exceptions[to]) {\\n                require(\\n                    max_transfer >= amount || anti_whale_exceptions[to],\\n                    \\\"max tx limit\\\"\\n                );\\n\\n                taxAmount = amount.mul(buy_tax).div(100);\\n            }\\n\\n            if (lps[to] && from != address(this) && !tax_exceptions[from]) {\\n                isSelling = true;\\n                require(\\n                    max_transfer >= amount || anti_whale_exceptions[from],\\n                    \\\"FreeERC20: Max tx limit violation\\\"\\n                );\\n\\n                taxAmount = amount.mul(sell_tax).div(100);\\n            }\\n\\n            uint256 contractTokenBalance = balanceOf[address(this)];\\n            if (\\n                in_swap == 1 &&\\n                isSelling &&\\n                contractTokenBalance > sell_tax_threshold\\n            ) {\\n                swapTokensForEth(contractTokenBalance);\\n            }\\n        }\\n\\n        if (taxAmount > 0) {\\n            balanceOf[address(this)] = balanceOf[address(this)].add(taxAmount);\\n            emit Transfer(from, address(this), taxAmount);\\n        } else {\\n            require(\\n                max_transfer >= amount || anti_whale_exceptions[from],\\n                \\\"FreeERC20: Max tx limit violation\\\"\\n            );\\n        }\\n\\n        balanceOf[from] = balanceOf[from].sub(amount);\\n        balanceOf[to] = balanceOf[to].add(amount.sub(taxAmount));\\n\\n        require(\\n            balanceOf[to] <= max_holding ||\\n                anti_whale_exceptions[to] ||\\n                tx.origin == owner,\\n            \\\"FreeERC20: Max holding limit violation\\\"\\n        );\\n\\n        emit Transfer(from, to, amount.sub(taxAmount));\\n    }\\n\\n    function swapTokensForEth(uint amount) private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = weth;\\n\\n        try IUniswapV2Router01(uni_router).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            tax_receiver,\\n            type(uint).max\\n        ) {\\n            //\\n        } catch {\\n            // Ignore, to prevent calls from failing if owner sets invalid router\\n        }\\n    }\\n\\n    function isAntiWhaleEnabled() external view returns (bool) {\\n        return max_holding != 0 || max_transfer != 0;\\n    }\\n\\n\\tfunction mint(address receiver, uint amount) external onlyOwner {\\n\\t\\trequire(totalSupply + amount <= maxSupply, \\\"Mint amount too high\\\");\\n\\n\\t\\t_mint(receiver, amount);\\n\\t}\\n\\n    function setLimits(\\n        uint _max_holding,\\n        uint _max_transfer\\n    ) external onlyOwner {\\n        if (_max_holding == 0) {\\n            _max_holding = type(uint256).max;\\n        }\\n\\n        if (_max_transfer == 0) {\\n            _max_transfer = type(uint256).max;\\n        }\\n\\n        require(\\n            _max_holding >= totalSupply.div(100),\\n            \\\"FreeERC20: Max Holding Limit cannot be less than 1% of total supply\\\"\\n        );\\n        require(\\n            _max_transfer >= totalSupply.div(100),\\n            \\\"FreeERC20: Max Transfer Limit cannot be less than 1% of total supply\\\"\\n        );\\n\\n        max_holding = _max_holding;\\n        max_transfer = _max_transfer;\\n    }\\n\\n    function setAntiWhaleException(address user, bool val) external onlyOwner {\\n        anti_whale_exceptions[user] = val;\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        is_trading_enabled = 2;\\n    }\\n\\n    function setUniRouter(address newRouter, address newFactory) external onlyOwner {\\n        uni_factory = newFactory;\\n        uni_router = newRouter;\\n        routers[newRouter] = true;\\n        allowance[address(this)][newRouter] = type(uint256).max;\\n        anti_whale_exceptions[newRouter] = true;\\n    }\\n\\n    function setAmm(address lp) public onlyOwner {\\n        lps[lp] = true;\\n        anti_whale_exceptions[lp] = true;\\n    }\\n\\n    function addRouter(address router) external onlyOwner {\\n        routers[router] = true;\\n        allowance[address(this)][router] = type(uint256).max;\\n        anti_whale_exceptions[router] = true;\\n    }\\n\\n    function setExcludeFromFee(address addy, bool val) external onlyOwner {\\n        tax_exceptions[addy] = val;\\n    }\\n\\n    function setSwapThreshold(uint newThreshold) external onlyOwner {\\n        sell_tax_threshold = newThreshold;\\n    }\\n\\n    function setTaxes(uint _buy_tax, uint _sell_tax) external onlyOwner {\\n        require(_buy_tax <= 30, \\\"FreeERC20: Buy tax too high\\\");\\n        require(_sell_tax <= 30, \\\"FreeERC20: Sell tax too high\\\");\\n\\n        buy_tax = _buy_tax;\\n        sell_tax = _sell_tax;\\n    }\\n\\n    function setTaxReceiver(address _tax_receiver) external onlyOwner {\\n        tax_receiver = _tax_receiver;\\n    }\\n\\n    function addLp(uint amount) external payable onlyOwner {\\n        is_trading_enabled = 2;\\n        _transfer(owner, address(this), amount);\\n        uint balance = address(this).balance;\\n        address pair = uniV2Pair();\\n        IUniswapV2Router01(uni_router).addLiquidityETH{value: balance}(\\n            address(this),\\n            amount,\\n            amount,\\n            balance,\\n            owner,\\n            block.timestamp\\n        );\\n        setAmm(pair);\\n        is_trading_enabled = 1;\\n    }\\n\\n    function uniV2Pair() public view returns (address pair) {\\n        pair = pairFor(weth, address(this));\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint160(\\n                uint(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            uni_factory,\\n                            keccak256(abi.encodePacked(token0, token1)),\\n                            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function sortTokens(\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address token0, address token1) {\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n    }\\n\\n    receive() external payable {}\\n\\n    function withdraw() external onlyOwner {\\n        (bool sent, ) = owner.call{value: address(this).balance}(\\\"\\\");\\n        require(sent, \\\"FreeERC20: Failed to send Ether\\\");\\n    }\\n\\n    function version() public pure returns (uint) {\\n        return 2;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n// https://uniswap.org/docs/v2/smart-contracts/router01/\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol implementation\\n// UniswapV2Router01 is deployed at 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a on the Ethereum mainnet, and the Ropsten, Rinkeby, G\u00f6rli, and Kovan testnets\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_holding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_transfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell_tax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_uni_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"addRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anti_whale_exceptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"in_swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAntiWhaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"is_trading_enabled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_holding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_transfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"setAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setAntiWhaleException\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_holding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_transfer\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tax_receiver\",\"type\":\"address\"}],\"name\":\"setTaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell_tax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newFactory\",\"type\":\"address\"}],\"name\":\"setUniRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tax_exceptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax_receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC20Token", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000115eec47f6cf7e35000000000000000000000000000000000000000000000000115eec47f6cf7e35000000000000000000000000000000000000000000000000115eec47f6cf7e35000000000000000000000000000000000000000000000000115eec47f6cf7e35000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000000000008415050524f56414c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044741525900000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://18ac8536fb8b8235d0b9cfe53a5545cca6c1f91da0ec57db85ccefdba2191b79"}