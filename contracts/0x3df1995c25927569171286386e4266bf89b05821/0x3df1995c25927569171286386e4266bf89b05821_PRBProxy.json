{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.18;\\n\\nimport { IPRBProxy } from \\\"./interfaces/IPRBProxy.sol\\\";\\nimport { IPRBProxyPlugin } from \\\"./interfaces/IPRBProxyPlugin.sol\\\";\\nimport { IPRBProxyRegistry } from \\\"./interfaces/IPRBProxyRegistry.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d  \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557   \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557   \u2588\u2588\u2551\\n\u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n\\n*/\\n\\n/// @title PRBProxy\\n/// @dev See the documentation in {IPRBProxy}.\\ncontract PRBProxy is IPRBProxy {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxy\\n    address public immutable override owner;\\n\\n    /// @inheritdoc IPRBProxy\\n    IPRBProxyRegistry public immutable override registry;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Creates the proxy by fetching the constructor params from the registry, optionally delegate calling\\n    /// to a target contract if one is provided.\\n    /// @dev The rationale of this approach is to have the proxy's CREATE2 address not depend on any constructor params.\\n    constructor() {\\n        registry = IPRBProxyRegistry(msg.sender);\\n        (address owner_, address target, bytes memory data) = registry.constructorParams();\\n        owner = owner_;\\n        if (target != address(0)) {\\n            _execute(target, data);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FALLBACK FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Fallback function used to run plugins.\\n    /// @dev WARNING: anyone can call this function and thus run any installed plugin.\\n    fallback(bytes calldata data) external payable returns (bytes memory response) {\\n        // Check if the function selector points to a known installed plugin.\\n        IPRBProxyPlugin plugin = registry.getPluginByOwner({ owner: owner, method: msg.sig });\\n        if (address(plugin) == address(0)) {\\n            revert PRBProxy_PluginNotInstalledForMethod({ caller: msg.sender, owner: owner, method: msg.sig });\\n        }\\n\\n        // Delegate call to the plugin.\\n        bool success;\\n        (success, response) = address(plugin).delegatecall(data);\\n\\n        // Log the plugin run.\\n        emit RunPlugin(plugin, data, response);\\n\\n        // Check if the call was successful or not.\\n        if (!success) {\\n            // If there is return data, the delegate call reverted with a reason or a custom error, which we bubble up.\\n            if (response.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(response)\\n                    revert(add(32, response), returndata_size)\\n                }\\n            } else {\\n                revert PRBProxy_PluginReverted(plugin);\\n            }\\n        }\\n    }\\n\\n    /// @dev Called when `msg.value` is not zero and the call data is empty.\\n    receive() external payable { }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                         USER-FACING NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @inheritdoc IPRBProxy\\n    function execute(address target, bytes calldata data) external payable override returns (bytes memory response) {\\n        // Check that the caller is either the owner or an envoy with permission.\\n        if (owner != msg.sender) {\\n            bool permission = registry.getPermissionByOwner({ owner: owner, envoy: msg.sender, target: target });\\n            if (!permission) {\\n                revert PRBProxy_ExecutionUnauthorized({ owner: owner, caller: msg.sender, target: target });\\n            }\\n        }\\n\\n        // Delegate call to the target contract, and handle the response.\\n        response = _execute(target, data);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                          INTERNAL NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Executes a DELEGATECALL to the provided target with the provided data.\\n    /// @dev Shared logic between the constructor and the `execute` function.\\n    function _execute(address target, bytes memory data) internal returns (bytes memory response) {\\n        // Check that the target is a contract.\\n        if (target.code.length == 0) {\\n            revert PRBProxy_TargetNotContract(target);\\n        }\\n\\n        // Delegate call to the target contract.\\n        bool success;\\n        (success, response) = target.delegatecall(data);\\n\\n        // Log the execution.\\n        emit Execute(target, data, response);\\n\\n        // Check if the call was successful or not.\\n        if (!success) {\\n            // If there is return data, the delegate call reverted with a reason or a custom error, which we bubble up.\\n            if (response.length > 0) {\\n                assembly {\\n                    // The length of the data is at `response`, while the actual data is at `response + 32`.\\n                    let returndata_size := mload(response)\\n                    revert(add(response, 32), returndata_size)\\n                }\\n            } else {\\n                revert PRBProxy_ExecutionReverted();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport { IPRBProxyPlugin } from \\\"./IPRBProxyPlugin.sol\\\";\\nimport { IPRBProxyRegistry } from \\\"./IPRBProxyRegistry.sol\\\";\\n\\n/// @title IPRBProxy\\n/// @notice Proxy contract to compose transactions on behalf of the owner.\\ninterface IPRBProxy {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when a target contract reverts without a specified reason.\\n    error PRBProxy_ExecutionReverted();\\n\\n    /// @notice Thrown when an unauthorized account tries to execute a delegate call.\\n    error PRBProxy_ExecutionUnauthorized(address owner, address caller, address target);\\n\\n    /// @notice Thrown when the fallback function fails to find an installed plugin for the method selector.\\n    error PRBProxy_PluginNotInstalledForMethod(address caller, address owner, bytes4 method);\\n\\n    /// @notice Thrown when a plugin execution reverts without a specified reason.\\n    error PRBProxy_PluginReverted(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when a non-contract address is passed as the target.\\n    error PRBProxy_TargetNotContract(address target);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when a target contract is delegate called.\\n    event Execute(address indexed target, bytes data, bytes response);\\n\\n    /// @notice Emitted when a plugin is run for a provided method.\\n    event RunPlugin(IPRBProxyPlugin indexed plugin, bytes data, bytes response);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the owner account or contract, which controls the proxy.\\n    function owner() external view returns (address);\\n\\n    /// @notice The address of the registry that has deployed this proxy.\\n    function registry() external view returns (IPRBProxyRegistry);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Delegate calls to the provided target contract by forwarding the data. It returns the data it\\n    /// gets back, and bubbles up any potential revert.\\n    ///\\n    /// @dev Emits an {Execute} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must be either the owner or an envoy with permission.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target contract.\\n    /// @param data Function selector plus ABI encoded data.\\n    /// @return response The response received from the target contract, if any.\\n    function execute(address target, bytes calldata data) external payable returns (bytes memory response);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxyPlugin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// @title IPRBProxyPlugin\\n/// @notice Interface for plugin contracts that can be installed on a proxy.\\n/// @dev Plugins are contracts that enable the proxy to interact with and respond to calls from other contracts. These\\n/// plugins are run via the proxy's fallback function.\\n///\\n/// This interface is meant to be directly inherited by plugin implementations.\\ninterface IPRBProxyPlugin {\\n    /// @notice Retrieves the methods implemented by the plugin.\\n    /// @dev The registry pulls these methods when installing the plugin.\\n    ///\\n    /// Requirements:\\n    /// - The plugin must implement at least one method.\\n    ///\\n    /// @return methods The array of the methods implemented by the plugin.\\n    function getMethods() external returns (bytes4[] memory methods);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPRBProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport { IPRBProxy } from \\\"./IPRBProxy.sol\\\";\\nimport { IPRBProxyPlugin } from \\\"./IPRBProxyPlugin.sol\\\";\\n\\n/// @title IPRBProxyRegistry\\n/// @notice Deploys new proxies via CREATE2 and keeps a registry of owners to proxies. Proxies can only be deployed\\n/// once per owner, and they cannot be transferred. The registry also supports installing plugins, which are used\\n/// for extending the functionality of the proxy.\\ninterface IPRBProxyRegistry {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when trying to install a plugin that implements a method already implemented by another\\n    /// installed plugin.\\n    error PRBProxyRegistry_PluginMethodCollision(\\n        IPRBProxyPlugin currentPlugin, IPRBProxyPlugin newPlugin, bytes4 method\\n    );\\n\\n    /// @notice Thrown when trying to uninstall an unknown plugin.\\n    error PRBProxyRegistry_PluginUnknown(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when trying to install a plugin that doesn't implement any method.\\n    error PRBProxyRegistry_PluginWithZeroMethods(IPRBProxyPlugin plugin);\\n\\n    /// @notice Thrown when a function requires the user to have a proxy.\\n    error PRBProxyRegistry_UserDoesNotHaveProxy(address user);\\n\\n    /// @notice Thrown when a function requires the user to not have a proxy.\\n    error PRBProxyRegistry_UserHasProxy(address user, IPRBProxy proxy);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when a new proxy is deployed.\\n    event DeployProxy(address indexed operator, address indexed owner, IPRBProxy proxy);\\n\\n    /// @notice Emitted when a plugin is installed.\\n    event InstallPlugin(\\n        address indexed owner, IPRBProxy indexed proxy, IPRBProxyPlugin indexed plugin, bytes4[] methods\\n    );\\n\\n    /// @notice Emitted when an envoy's permission is updated.\\n    event SetPermission(\\n        address indexed owner, IPRBProxy indexed proxy, address indexed envoy, address target, bool newPermission\\n    );\\n\\n    /// @notice Emitted when a plugin is uninstalled.\\n    event UninstallPlugin(\\n        address indexed owner, IPRBProxy indexed proxy, IPRBProxyPlugin indexed plugin, bytes4[] methods\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      STRUCTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @param owner The address of the user who will own the proxy.\\n    /// @param target The address of the target to delegate call to. Can be set to zero.\\n    /// @param data The call data to be passed to the target. Can be set to zero.\\n    struct ConstructorParams {\\n        address owner;\\n        address target;\\n        bytes data;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The release version of the proxy system, which applies to both the registry and deployed proxies.\\n    /// @dev This is stored in the registry rather than the proxy to save gas for end users.\\n    function VERSION() external view returns (string memory);\\n\\n    /// @notice The parameters used in constructing the proxy, which the registry sets transiently during proxy\\n    /// deployment.\\n    /// @dev The proxy constructor fetches these parameters.\\n    function constructorParams() external view returns (address owner, address target, bytes memory data);\\n\\n    /// @notice Retrieves the list of installed methods for the provided plugin.\\n    /// @dev An empty array is returned if the plugin is unknown.\\n    /// @param owner The proxy owner for the query.\\n    /// @param plugin The plugin for the query.\\n    function getMethodsByOwner(address owner, IPRBProxyPlugin plugin) external view returns (bytes4[] memory methods);\\n\\n    /// @notice Retrieves the list of installed methods for the provided plugin.\\n    /// @dev An empty array is returned if the plugin is unknown.\\n    /// @param proxy The proxy for the query.\\n    /// @param plugin The plugin for the query.\\n    function getMethodsByProxy(\\n        IPRBProxy proxy,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        view\\n        returns (bytes4[] memory methods);\\n\\n    /// @notice Retrieves a boolean flag that indicates whether the provided envoy has permission to call the provided\\n    /// target.\\n    /// @param owner The proxy owner for the query.\\n    /// @param envoy The address checked for permission to call the target.\\n    /// @param target The address of the target.\\n    function getPermissionByOwner(\\n        address owner,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission);\\n\\n    /// @notice Retrieves a boolean flag that indicates whether the provided envoy has permission to call the provided\\n    /// target.\\n    /// @param proxy The proxy for the query.\\n    /// @param envoy The address checked for permission to call the target.\\n    /// @param target The address of the target.\\n    function getPermissionByProxy(\\n        IPRBProxy proxy,\\n        address envoy,\\n        address target\\n    )\\n        external\\n        view\\n        returns (bool permission);\\n\\n    /// @notice Retrieves the address of the plugin installed for the provided method selector.\\n    /// @dev The zero address is returned if no plugin is installed.\\n    /// @param owner The proxy owner for the query.\\n    /// @param method The method selector for the query.\\n    function getPluginByOwner(address owner, bytes4 method) external view returns (IPRBProxyPlugin plugin);\\n\\n    /// @notice Retrieves the address of the plugin installed for the provided method selector.\\n    /// @dev The zero address is returned if no plugin is installed.\\n    /// @param proxy The proxy for the query.\\n    /// @param method The method selector for the query.\\n    function getPluginByProxy(IPRBProxy proxy, bytes4 method) external view returns (IPRBProxyPlugin plugin);\\n\\n    /// @notice Retrieves the proxy for the provided user.\\n    /// @param user The user address for the query.\\n    function getProxy(address user) external view returns (IPRBProxy proxy);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                               NON-CONSTANT FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Deploys a new proxy for the caller.\\n    ///\\n    /// @dev Emits a {DeployProxy} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    ///\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deploy() external returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs two actions:\\n    /// 1. Deploys a new proxy for the caller\\n    /// 2. Delegate calls to the provided target, returning the data it gets back, and bubbling up any potential revert.\\n    ///\\n    /// @dev Emits a {DeployProxy} and {Execute} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target.\\n    /// @param data Function selector plus ABI-encoded data.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndExecute(address target, bytes calldata data) external returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs three actions:\\n    /// 1. Deploys a new proxy for the caller\\n    /// 2. Delegate calls to the provided target, returning the data it gets back, and bubbling up any potential revert.\\n    /// 3. Installs the provided plugin on the newly deployed proxy.\\n    ///\\n    /// @dev Emits a {DeployProxy}, {Execute}, and {InstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - See the requirements in `installPlugin`.\\n    /// - See the requirements in `execute`.\\n    ///\\n    /// @param target The address of the target.\\n    /// @param data Function selector plus ABI-encoded data.\\n    /// @param plugin The address of the plugin to install.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndExecuteAndInstallPlugin(\\n        address target,\\n        bytes calldata data,\\n        IPRBProxyPlugin plugin\\n    )\\n        external\\n        returns (IPRBProxy proxy);\\n\\n    /// @notice This function performs two actions:\\n    /// 1. Deploys a new proxy for the caller.\\n    /// 2. Installs the provided plugin on the newly deployed proxy.\\n    ///\\n    /// @dev Emits a {DeployProxy} and {InstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must not have a proxy.\\n    /// - See the requirements in `installPlugin`.\\n    ///\\n    /// @param plugin The address of the plugin to install.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployAndInstallPlugin(IPRBProxyPlugin plugin) external returns (IPRBProxy proxy);\\n\\n    /// @notice Deploys a new proxy for the provided user.\\n    ///\\n    /// @dev Emits a {DeployProxy} event.\\n    ///\\n    /// Requirements:\\n    /// - The user must not have a proxy already.\\n    ///\\n    /// @param user The address that will own the proxy.\\n    /// @return proxy The address of the newly deployed proxy.\\n    function deployFor(address user) external returns (IPRBProxy proxy);\\n\\n    /// @notice Installs the provided plugin on the caller's proxy, and saves the list of methods implemented by the\\n    /// plugin so that they can be referenced later.\\n    ///\\n    /// @dev Emits an {InstallPlugin} event.\\n    ///\\n    /// Notes:\\n    /// - Installing a plugin is a potentially dangerous operation, because anyone can run the plugin.\\n    /// - Plugin methods that have the same selectors as {IPRBProxy.execute}, {IPRBProxy.owner}, and\\n    /// {IPRBProxy.registry} can be installed, but they can never be run.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    /// - The plugin must have at least one implemented method.\\n    /// - There must be no method collision with any other plugin installed by the caller.\\n    ///\\n    /// @param plugin The address of the plugin to install.\\n    function installPlugin(IPRBProxyPlugin plugin) external;\\n\\n    /// @notice Gives or takes a permission from an envoy to call the provided target and function selector\\n    /// on behalf of the caller's proxy.\\n    ///\\n    /// @dev Emits a {SetPermission} event.\\n    ///\\n    /// Notes:\\n    /// - It is not an error to set the same permission.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    ///\\n    /// @param envoy The address of the account the caller is giving or taking permission from.\\n    /// @param target The address of the target.\\n    /// @param permission The boolean permission to set.\\n    function setPermission(address envoy, address target, bool permission) external;\\n\\n    /// @notice Uninstalls the plugin from the caller's proxy, and removes the list of methods originally implemented by\\n    /// the plugin.\\n    ///\\n    /// @dev Emits an {UninstallPlugin} event.\\n    ///\\n    /// Requirements:\\n    /// - The caller must have a proxy.\\n    /// - The plugin must be a known, previously installed plugin.\\n    ///\\n    /// @param plugin The address of the plugin to uninstall.\\n    function uninstallPlugin(IPRBProxyPlugin plugin) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"prb-test/=lib/prb-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PRBProxy_ExecutionReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"PRBProxy_ExecutionUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"method\",\"type\":\"bytes4\"}],\"name\":\"PRBProxy_PluginNotInstalledForMethod\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"}],\"name\":\"PRBProxy_PluginReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"PRBProxy_TargetNotContract\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IPRBProxyPlugin\",\"name\":\"plugin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"name\":\"RunPlugin\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IPRBProxyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PRBProxy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}