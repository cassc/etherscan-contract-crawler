{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Dungeon3Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"./Relic.sol\\\";\\n\\ninterface LootOwner\\n{\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n}\\n\\ninterface GenesisLootOwner\\n{\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n    function getLootTokenIds(uint256 tokenId) external view returns(uint256[8] memory);\\n    function getOrder(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IRiftData {\\n    function addXP(uint256 xp, uint256 bagId) external;\\n}\\n\\ncontract Dungeon3Minter is Ownable, IRelicMinter\\n{\\n    LootOwner internal _oloot;\\n    LootOwner internal _mloot;\\n    GenesisLootOwner internal _gloot;\\n    Relic internal _relic;\\n    string public _imageBaseURL;\\n    mapping(uint256 => bool) public _claims;\\n    mapping(address => bool) public _relayAddresses;\\n    address public _riftAddress;\\n    bool public _isXpRewardsEnabled;\\n\\n    uint256[16] public _bestRaiderRelicNextIdsByRank = [\\n        252,\\n        840,\\n        924,\\n        2016,\\n        2100,\\n        2184,\\n        2268,\\n        4368,\\n        4452,\\n        4536,\\n        4620,\\n        4704,\\n        4788,\\n        4872,\\n        4956,\\n        37296\\n    ];\\n\\n    uint256[16] public _bestRaiderLastIdsByRank = [\\n        335,\\n        923,\\n        1007,\\n        2099,\\n        2183,\\n        2267,\\n        2351,\\n        4451,\\n        4535,\\n        4619,\\n        4703,\\n        4787,\\n        4871,\\n        4955,\\n        5039,\\n        37379\\n    ];\\n\\n    uint256[16] public _runnerUpRelicNextIdsByRank = [\\n        37380,\\n        37710,\\n        38040,\\n        38370,\\n        38700,\\n        39030,\\n        39360,\\n        39690,\\n        40020,\\n        40350,\\n        40680,\\n        41010,\\n        41340,\\n        41670,\\n        42000,\\n        42330\\n    ];\\n\\n    uint256[16] public _runnerUpRelicLastIdsByRank = [\\n        37709,\\n        38039,\\n        38369,\\n        38699,\\n        39029,\\n        39359,\\n        39689,\\n        40019,\\n        40349,\\n        40679,\\n        41009,\\n        41339,\\n        41669,\\n        41999,\\n        42329,\\n        42659\\n    ];\\n\\n    constructor(\\n        address olootAddress,\\n        address mlootAddress,\\n        address glootAddress,\\n        address relicAddress,\\n        address riftAddress,\\n        string memory imageBaseURL\\n    )\\n    {\\n        _oloot = LootOwner(olootAddress);\\n        _mloot = LootOwner(mlootAddress);\\n        _gloot = GenesisLootOwner(glootAddress);\\n        _relic = Relic(relicAddress);\\n        _riftAddress = riftAddress;\\n        _imageBaseURL = imageBaseURL;\\n    }\\n\\n    function getRaidId(uint256 tokenId, uint8 raiderType)\\n        public pure returns (uint256)\\n    {\\n        return (raiderType) | (tokenId << 8);\\n    }\\n\\n    function getRaidDungeonRequest(\\n        uint dungeonId,\\n        uint256 raidTokenId,\\n        uint256 raidTokenType,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public view returns (\\n        bool isOwner,\\n        uint256[8] memory itemIds,\\n        string memory order,\\n        address signer\\n    ) {\\n        bytes32 requestHash = keccak256(abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n            keccak256(abi.encode(\\n                \\\"raidDungeon\\\",\\n                dungeonId,\\n                raidTokenId,\\n                raidTokenType\\n            ))\\n        ));\\n        signer = ecrecover(requestHash, v, r, s);\\n\\n        isOwner = isOwnerOf(raidTokenId, raidTokenType, signer);\\n\\n        if (raidTokenType == 0) {\\n            itemIds = [ raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId ];\\n            order = \\\"no order\\\";\\n        } else if (raidTokenType == 1) {\\n            itemIds = [ raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId, raidTokenId ];\\n            order = \\\"no order\\\";\\n        } else if (raidTokenType == 2) {\\n            itemIds = _gloot.getLootTokenIds(raidTokenId);\\n            order = _gloot.getOrder(raidTokenId);\\n        } else {\\n            require(false, \\\"invalid raid token type\\\");\\n        }\\n\\n        return (isOwner, itemIds, order, signer);\\n    }\\n\\n    function isOwnerOf(uint256 raidTokenId, uint raidTokenType, address addr) public view returns (bool)\\n    {\\n        if (raidTokenType == 0) {\\n            return addr == _oloot.ownerOf(raidTokenId);\\n        } else if (raidTokenType == 1) {\\n            return addr == _mloot.ownerOf(raidTokenId);\\n        } else if (raidTokenType == 2) {\\n            return addr == _gloot.ownerOf(raidTokenId);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function isVerifiedClaimRequest(\\n        uint dungeonId,\\n        uint dungeonRank,\\n        uint256 raidTokenId,\\n        uint8 raidTokenType,\\n        uint8 raidRank,\\n        bytes memory claimCoupon\\n    ) public view returns (\\n        bool\\n    ) {\\n        // extract signature parts from coupon\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(claimCoupon);\\n        // extract signer from signature and request\\n        address signer = ecrecover(keccak256(abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n            keccak256(abi.encode(\\n                dungeonId,\\n                dungeonRank,\\n                raidTokenId,\\n                raidTokenType,\\n                raidRank\\n            ))\\n        )), v, r, s);\\n        // never trust 0x0\\n        require(signer != address(0x0), \\\"invalid signer\\\");\\n        // return true if signed by the relay/oracle\\n        return _relayAddresses[signer];\\n    }\\n\\n    function claimRewards(\\n        uint8[] calldata dungeonIds,\\n        uint8[] calldata dungeonRanks,\\n        uint64[] calldata raidTokenIds,\\n        uint8[] calldata raidTokenTypes,\\n        uint8[] calldata raidRanks,\\n        bytes[] calldata claimCoupons\\n    ) public {\\n        // claim each request\\n        for (uint256 i = 0; i < raidTokenIds.length; i++) {\\n            claimReward(\\n                dungeonIds[i],\\n                dungeonRanks[i],\\n                raidTokenIds[i],\\n                raidTokenTypes[i],\\n                raidRanks[i],\\n                claimCoupons[i]\\n            );\\n        }\\n    }\\n\\n    function claimReward(\\n        uint8 dungeonId,\\n        uint8 dungeonRank,\\n        uint64 raidTokenId,\\n        uint8 raidTokenType,\\n        uint8 raidRank,\\n        bytes calldata claimCoupon\\n    ) public {\\n\\n        // verify that the request is signed by the relay which is acting as an oracle for raids\\n        require(isVerifiedClaimRequest(\\n            dungeonId,\\n            dungeonRank,\\n            raidTokenId,\\n            raidTokenType,\\n            raidRank,\\n            claimCoupon\\n        ), \\\"claim verification fail\\\");\\n\\n        // get unique raid id\\n        uint256 raidId = getRaidId(raidTokenId, raidTokenType);\\n        \\n        // check not already claimed\\n        require(!_claims[raidId], \\\"already claimed\\\");\\n\\n        // verify that the sender is the owner of the given raidTokenId\\n        require(isOwnerOf(raidTokenId, raidTokenType, msg.sender), \\\"raider does not own loot\\\");\\n\\n        // Rift XP: gLoot bag IDs must be offset by adding \u20189997460\u2019 to their value\\n        uint256 lootIdOffset;\\n        if (raidTokenType == 2) {\\n            lootIdOffset = 9997460;\\n        }\\n\\n        // find and consume the relicId for the raidRank\\n        uint256 relicId;\\n        if (raidRank == 0) {\\n            relicId = _bestRaiderRelicNextIdsByRank[dungeonRank];\\n            require(relicId <= _bestRaiderLastIdsByRank[dungeonRank], \\\"no more relics available for rank\\\");\\n            _bestRaiderRelicNextIdsByRank[dungeonRank]++;\\n\\n            if (_isXpRewardsEnabled) {\\n                IRiftData(_riftAddress).addXP((uint256(16 - dungeonRank) * 20) + 200, uint256(raidTokenId) + lootIdOffset);\\n            }\\n        } else {\\n            relicId = _runnerUpRelicNextIdsByRank[dungeonRank];\\n            require(relicId <= _runnerUpRelicLastIdsByRank[dungeonRank], \\\"no more relics available for rank\\\");\\n            _runnerUpRelicNextIdsByRank[dungeonRank]++;\\n            \\n            if (_isXpRewardsEnabled) {\\n                IRiftData(_riftAddress).addXP((uint256(16 - dungeonRank) * 10) + 200, uint256(raidTokenId) + lootIdOffset);\\n            }\\n        }\\n\\n        // mark this raidToken as claimed\\n        _claims[raidId] = true;\\n\\n        // set relic data\\n        bytes12 data = bytes12(uint96(dungeonId & 0xffffffffffffffffffffffff));\\n\\n        // mint it\\n        _relic.mint(msg.sender, relicId, data);\\n    }\\n\\n    function isClaimed(\\n        uint8 raidTokenType,\\n        uint256 raidTokenId\\n    ) public view returns (\\n        bool\\n    ) {\\n        uint256 raidId = getRaidId(raidTokenId, raidTokenType);\\n        return _claims[raidId];\\n    }\\n\\n    function splitSignature(bytes memory sig) public pure returns ( bytes32 r, bytes32 s, uint8 v)\\n    {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n        require(v == 27 || v == 28, \\\"invalid signature version\\\");\\n        // implicitly return (r, s, v)\\n    }\\n\\n    function setRelayAddress(address relayAddress, bool active) external onlyOwner\\n    {\\n        _relayAddresses[relayAddress] = active;\\n    }\\n\\n    //\\n    // *** IRelicMinter Interface ***\\n    //\\n\\n    function setImageBaseURL(string memory newImageBaseURL) public onlyOwner\\n    {\\n        _imageBaseURL = newImageBaseURL;\\n    }\\n\\n    function getTokenOrderIndex(uint256 /*tokenId*/, bytes12 data)\\n        external override pure returns(uint)\\n    {\\n        uint96 dungeonId = uint96(data);\\n        return dungeonId % 16;\\n    }\\n\\n    function getTokenProvenance(uint256 /*tokenId*/, bytes12 /*data*/)\\n        external override pure returns(string memory)\\n    {\\n        return \\\"The Crypt: Chapter Three\\\";\\n    }\\n\\n    function getAdditionalAttributes(uint256 /*tokenId*/, bytes12 /*data*/)\\n        external override pure returns(string memory)\\n    {\\n        return \\\"\\\";\\n    }\\n\\n    function getImageBaseURL() external override view returns(string memory)\\n    {\\n        return _imageBaseURL;\\n    }\\n\\n    function enableXpRewards(bool enabled) external onlyOwner\\n    {\\n        _isXpRewardsEnabled = enabled;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Relic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1967/ERC1967ProxyImplementation.sol\\\";\\nimport \\\"./OpenSea/ERC721TradableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n\\nstruct RelicProperties\\n{\\n    uint256 relicTypeId;\\n    uint256 materialId;\\n    uint256 materialOffset; // this relic's number relative to material, e.g. Gold Skull #42\\n    uint256 poleId;\\n    uint256 astralId;\\n    uint256 elementId;\\n    uint256 alignmentId;\\n    uint256 greatness;\\n}\\n\\ninterface IRelicMinter\\n{\\n    // The relic minter can inject attributes into the metadata attributes array,\\n    // they will be added after the standard ones so should begin with a comma.\\n    // e.g. ,{\\\"trait_type\\\": \\\"Extra Field\\\", \\\"value\\\": \\\"The Value\\\"}\\n    function getAdditionalAttributes(uint256 tokenId, bytes12 data)\\n        external view returns(string memory);\\n\\n    function getTokenOrderIndex(uint256 tokenId, bytes12 data)\\n        external view returns(uint);\\n\\n    function getTokenProvenance(uint256 tokenId, bytes12 data)\\n        external view returns(string memory);\\n\\n    function getImageBaseURL()\\n        external view returns(string memory);\\n}\\n\\n\\ncontract Relic is ProxyImplementation, ERC721TradableUpgradeable\\n{\\n    mapping(address => bool) private _whitelistedMinters;\\n    mapping(uint256 => uint256) public _tokenMintInfo;\\n    string public _placeholderImageURL;\\n    string public _animationBaseURL;\\n    string public _collectionName;\\n    string public _collectionDesc;\\n    string public _collectionImgURL;\\n    string public _collectionExtURL;\\n    uint256 public _feeBasisPoints;\\n    address public _feeRecipient;\\n\\n    function init(\\n        string memory name,\\n        string memory symbol,\\n        address proxyRegistryAddress,\\n        string memory placeholderImageURL,\\n        string memory animationBaseURL,\\n        string memory collectionName,\\n        string memory collectionDesc,\\n        string memory collectionImgURL,\\n        string memory collectionExtURL,\\n        uint256 feeBasisPoints,\\n        address feeRecipient)\\n        public onlyOwner initializer\\n    {\\n        _initializeEIP712(name);\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name, symbol);\\n        __ERC721TradableUpgradeable_init_unchained(proxyRegistryAddress);\\n\\n        _placeholderImageURL = placeholderImageURL;\\n        _animationBaseURL = animationBaseURL;\\n        _collectionName = collectionName;\\n        _collectionDesc = collectionDesc;\\n        _collectionImgURL = collectionImgURL;\\n        _collectionExtURL = collectionExtURL;\\n        _feeBasisPoints = feeBasisPoints;\\n        _feeRecipient = feeRecipient;\\n    }\\n\\n    function exists(uint256 tokenId) public view returns(bool)\\n    {\\n        return _exists(tokenId);\\n    }\\n\\n    function mint(address to, uint256 tokenId, bytes12 data) public\\n    {\\n        require(isMinterWhitelisted(_msgSender()), \\\"minter not whitelisted\\\");\\n\\n        // only need 20 bytes for the minter address, so might as well use the\\n        // other 12 bytes of the slot for something. The minter can pass\\n        // whatever they want, I'm thinking some kind of useful context, e.g. a\\n        // minter which manages multiple dungeons could use this field for\\n        // dungeon Id\\n        _tokenMintInfo[tokenId] = packTokenMintInfo(IRelicMinter(_msgSender()), data);\\n\\n        _safeMint(to, tokenId);\\n    }\\n\\n    function tokenURI(uint256 tokenId) public override view returns (string memory)\\n    {\\n        require(_exists(tokenId), \\\"token doesn't exist\\\");\\n\\n        RelicProperties memory relicProps = getRelicProperties(tokenId);\\n\\n        (IRelicMinter relicMinter, bytes12 data) = unpackTokenMintInfo(_tokenMintInfo[tokenId]);\\n        uint orderIndex = relicMinter.getTokenOrderIndex(tokenId, data);\\n        string memory provenance = relicMinter.getTokenProvenance(tokenId, data);\\n        string memory baseImageURL = relicMinter.getImageBaseURL();\\n        if (bytes(baseImageURL).length == 0)\\n        {\\n            baseImageURL = _placeholderImageURL;\\n        }\\n        string memory imageURL = getImageURLForToken(tokenId, baseImageURL, orderIndex, provenance);\\n\\n        string memory attrs = string(abi.encodePacked(\\n           _getAttributes(relicProps),\\n            \\\",{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Order\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getOrderSuffix(orderIndex), \\\"\\\\\\\"}\\\",\\n            \\\",{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Provenance\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", provenance, \\\"\\\\\\\"}\\\",\\n            relicMinter.getAdditionalAttributes(tokenId, data)\\n        ));\\n\\n        return string(abi.encodePacked(\\n            \\\"data:application/json;utf8,{\\\"\\n            \\\"\\\\\\\"name\\\\\\\": \\\\\\\"\\\", getName(relicProps.relicTypeId, relicProps.materialId, relicProps.materialOffset), \\\"\\\\\\\",\\\"\\n            \\\"\\\\\\\"description\\\\\\\": \\\\\\\"Loot dungeon relic\\\\\\\",\\\"\\n            \\\"\\\\\\\"image\\\\\\\": \\\\\\\"\\\", imageURL, \\\"\\\\\\\",\\\",\\n            \\\"\\\\\\\"external_url\\\\\\\": \\\\\\\"\\\", imageURL,\\\"\\\\\\\",\\\", // TODO: this should be link to asset on TheCrupt\\n            \\\"\\\\\\\"attributes\\\\\\\": [\\\", attrs, \\\"]}\\\"\\n        ));\\n    }\\n\\n    function contractURI() public view returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            \\\"data:application/json;utf8,{\\\"\\n            \\\"\\\\\\\"name\\\\\\\": \\\\\\\"\\\", _collectionName, \\\"\\\\\\\",\\\"\\n            \\\"\\\\\\\"description\\\\\\\": \\\\\\\"\\\", _collectionDesc, \\\"\\\\\\\",\\\"\\n            \\\"\\\\\\\"image\\\\\\\": \\\\\\\"\\\", _collectionImgURL, \\\"\\\\\\\",\\\",\\n            \\\"\\\\\\\"external_link\\\\\\\": \\\\\\\"\\\", _collectionExtURL,\\\"\\\\\\\",\\\",\\n            \\\"\\\\\\\"seller_fee_basis_points\\\\\\\": \\\\\\\"\\\", StringsUpgradeable.toString(_feeBasisPoints),\\\"\\\\\\\",\\\",\\n            \\\"\\\\\\\"fee_recipient\\\\\\\": \\\\\\\"\\\", StringsUpgradeable.toHexString(uint256(uint160(_feeRecipient)), 20),\\\"\\\\\\\"\\\",\\n            \\\"}\\\"\\n        ));\\n    }\\n\\n    function getRelicProperties(uint256 tokenId)\\n        public pure returns(RelicProperties memory)\\n    {\\n        RelicProperties memory props;\\n\\n        uint256 relicsPerMaterialForCurrentType = 84;\\n        uint256 totalRelicsOfCurrentType;\\n        uint256 tokenIdStartForCurrentType;\\n        uint256 tokenIdEndForCurrentType; // exclusive\\n\\n        while (true)\\n        {\\n            totalRelicsOfCurrentType = relicsPerMaterialForCurrentType << 2;\\n            tokenIdEndForCurrentType = tokenIdStartForCurrentType + totalRelicsOfCurrentType;\\n\\n            if (tokenId < tokenIdEndForCurrentType)\\n            {\\n                break;\\n            }\\n\\n            ++props.relicTypeId;\\n            tokenIdStartForCurrentType = tokenIdEndForCurrentType;\\n            relicsPerMaterialForCurrentType <<= 1;\\n        }\\n\\n        // find out the offset of this token Id into its relic type, that is to\\n        // say if it's the Nth Skull, what is the value of N\\n        uint256 relicOffset = tokenId - tokenIdStartForCurrentType;\\n\\n        // we want materials to be allocated in order from smallest to largest\\n        // token Id, so derive material from relic offset\\n        props.materialId = relicOffset / relicsPerMaterialForCurrentType;\\n\\n        // we want to know that this is the Nth relic of type x material y, for\\n        // the token name e.g. Golden Skull #42\\n        props.materialOffset = relicOffset % relicsPerMaterialForCurrentType;\\n\\n         // First relic of each material set is greatness 20 then it is decremented per token until it loops at the minimum for its type\\n        uint256 minGreatness = getMiniumGreatness(props.relicTypeId); \\n        uint256 greatnessRange = 21 - minGreatness;\\n        props.greatness = 20 - (props.materialOffset % greatnessRange); \\n\\n       \\n        // offset the attributes Id with a \\\"random\\\" number per relic + material\\n        // combination, so that all relics of a certain material don't start on\\n        // N Sun Earth Good Greatness 0 etc\\n        uint256 attributesId = relicOffset + uint256(keccak256(abi.encodePacked(props.relicTypeId, props.materialId)));\\n\\n        props.alignmentId = (attributesId / greatnessRange) & 3;\\n        props.elementId = (attributesId / (greatnessRange * 4)) & 3;\\n        props.astralId = (attributesId / (greatnessRange * 16)) & 3;\\n        props.poleId = (attributesId / (greatnessRange * 64)) & 3;\\n\\n        return props;\\n    }\\n\\n    function packTokenMintInfo(IRelicMinter relicMinter, bytes12 data)\\n        public pure returns(uint256)\\n    {\\n        return (uint256(uint160(address(relicMinter))) << 96) | uint96(data);\\n    }\\n\\n    function unpackTokenMintInfo(uint256 mintInfo)\\n        public pure returns(IRelicMinter relicMinter, bytes12 data)\\n    {\\n        relicMinter = IRelicMinter(address(uint160(mintInfo >> 96)));\\n        data = bytes12(uint96(mintInfo & 0xffffffffffffffffffffffff));\\n    }\\n\\n    function getRelicType(uint256 relicId) public pure returns(string memory)\\n    {\\n        string[7] memory relics = [\\\"Skull\\\", \\\"Crown\\\", \\\"Medal\\\", \\\"Key\\\", \\\"Dagger\\\", \\\"Gem\\\", \\\"Coin\\\"];\\n        return relics[relicId];\\n    }\\n\\n    function getMaterial(uint256 materialId) public pure returns(string memory)\\n    {\\n        string[4] memory materials = [\\\"Gold\\\", \\\"Ice\\\", \\\"Fire\\\", \\\"Jade\\\"];\\n        return materials[materialId];\\n    }\\n\\n    function getName(uint256 relicId, uint256 materialId, uint256 materialOffset)\\n        public pure returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            getMaterial(materialId), \\\" \\\",\\n            getRelicType(relicId),\\n            \\\" #\\\", StringsUpgradeable.toString(materialOffset + 1)));\\n    }\\n\\n    function getAlignment(uint256 alignmentId) public pure returns(string memory)\\n    {\\n        string[4] memory alignment = [\\\"Good\\\", \\\"Evil\\\", \\\"Lawful\\\", \\\"Chaos\\\"];\\n        return alignment[alignmentId];\\n    }\\n\\n    function getElement(uint256 elementId) public pure returns(string memory)\\n    {\\n        string[4] memory element = [\\\"Earth\\\", \\\"Wind\\\", \\\"Fire\\\", \\\"Water\\\"];\\n        return element[elementId];\\n    }\\n\\n    function getAstral(uint256 astralId) public pure returns(string memory)\\n    {\\n        string[4] memory astral = [\\\"Earth\\\", \\\"Sun\\\", \\\"Moon\\\", \\\"Stars\\\"];\\n        return astral[astralId];\\n    }\\n\\n    function getPole(uint256 poleId) public pure returns(string memory)\\n    {\\n        string[4] memory pole = [\\\"North\\\", \\\"South\\\", \\\"East\\\", \\\"West\\\"];\\n        return pole[poleId];\\n    }\\n\\n    function getMiniumGreatness(uint256 relicId) public pure returns(uint256)\\n    {\\n        uint256[7] memory greatnesses = [(uint256)(20), 19, 18,17,15,10,0];\\n        return greatnesses[relicId];\\n    }\\n\\n    function getOrderSuffix(uint orderId) public pure returns(string memory)\\n    {\\n        string[16] memory suffixes = [\\n            \\\"of Power\\\",\\n            \\\"of Giants\\\",\\n            \\\"of Titans\\\",\\n            \\\"of Skill\\\",\\n            \\\"of Perfection\\\",\\n            \\\"of Brilliance\\\",\\n            \\\"of Enlightenment\\\",\\n            \\\"of Protection\\\",\\n            \\\"of Anger\\\",\\n            \\\"of Rage\\\",\\n            \\\"of Fury\\\",\\n            \\\"of Vitriol\\\",\\n            \\\"of the Fox\\\",\\n            \\\"of Detection\\\",\\n            \\\"of Reflection\\\",\\n            \\\"of the Twins\\\"\\n        ];\\n        return suffixes[orderId];\\n    }\\n\\n    // encodes properties in relicProps for use in a URL, such as for animation_url\\n    function _getURLParams(RelicProperties memory relicProps) public pure returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            \\\"relicType=\\\", getRelicType(relicProps.relicTypeId),\\n            \\\"&material=\\\", getMaterial(relicProps.materialId),\\n            \\\"&pole=\\\", getPole(relicProps.poleId),\\n            \\\"&astral=\\\", getAstral(relicProps.astralId),\\n            \\\"&element=\\\", getElement(relicProps.elementId),\\n            \\\"&alignment=\\\", getAlignment(relicProps.alignmentId),\\n            \\\"&greatness=\\\", StringsUpgradeable.toString(relicProps.greatness)\\n        ));\\n    }\\n\\n    // encodes properties in relicProps for use in the attributes array of token\\n    // metadata\\n    function _getAttributes(RelicProperties memory relicProps) public pure returns(string memory)\\n    {\\n        bytes memory str = abi.encodePacked(\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Relic Type\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getRelicType(relicProps.relicTypeId),\\\"\\\\\\\"},\\\"\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Material\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getMaterial(relicProps.materialId),\\\"\\\\\\\"},\\\"\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Pole\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getPole(relicProps.poleId),\\\"\\\\\\\"},\\\"\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Astral\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getAstral(relicProps.astralId),\\\"\\\\\\\"},\\\"\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Element\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getElement(relicProps.elementId),\\\"\\\\\\\"},\\\"\\n            \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Alignment\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", getAlignment(relicProps.alignmentId),\\\"\\\\\\\"},\\\"\\n        );\\n\\n        // had to break this into two calls to encodePacked as it runs out of stack otherwise\\n        str = abi.encodePacked(str, \\\"{\\\\\\\"trait_type\\\\\\\": \\\\\\\"Greatness\\\\\\\", \\\\\\\"value\\\\\\\": \\\\\\\"\\\", StringsUpgradeable.toString(relicProps.greatness),\\\"\\\\\\\"}\\\");\\n\\n        return string(str);\\n    }\\n\\n    function getImageURLPart1(RelicProperties memory props)\\n        internal pure returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            Strings.toString(props.materialId),\\n            \\\"-\\\",\\n            Strings.toString(props.relicTypeId),\\n            \\\"-\\\"\\n        ));\\n    }\\n\\n    function getImageURLPart2(RelicProperties memory props)\\n        internal pure returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            Strings.toString(props.astralId),\\n            \\\"-\\\",\\n            Strings.toString(props.elementId),\\n            \\\"-\\\",\\n            Strings.toString(props.poleId),\\n            \\\"-\\\"\\n        ));\\n    }\\n\\n    function getImageURLPart3(RelicProperties memory props)\\n        internal pure returns(string memory)\\n    {\\n        return string(abi.encodePacked(\\n            Strings.toString(props.alignmentId),\\n            \\\"-\\\",\\n            Strings.toString(props.greatness),\\n            \\\"-\\\"\\n        ));\\n    }\\n\\n    function getImageURLForToken(uint256 tokenId, string memory baseURL, uint orderIndex, string memory provenance)\\n        internal pure returns(string memory)\\n    {\\n        RelicProperties memory props = getRelicProperties(tokenId);\\n        return string(abi.encodePacked(\\n            baseURL,\\n            getImageURLPart1(props),\\n            Strings.toString(orderIndex),\\n            \\\"-\\\",\\n            getImageURLPart2(props),\\n            getImageURLPart3(props),\\n            provenance,\\n            \\\".png\\\"\\n        ));\\n    }\\n\\n    function isMinterWhitelisted(address minter) public view returns(bool)\\n    {\\n        return _whitelistedMinters[minter];\\n    }\\n\\n    function addWhitelistedMinter(address minter) public onlyOwner\\n    {\\n        require(AddressUpgradeable.isContract(minter), \\\"minter is not a contract\\\");\\n        require(!isMinterWhitelisted(minter), \\\"already whitelisted\\\");\\n        _whitelistedMinters[minter] = true;\\n    }\\n\\n    function removeWhitelistedMinter(address minter) public onlyOwner\\n    {\\n        require(isMinterWhitelisted(minter), \\\"not whitelisted\\\");\\n        _whitelistedMinters[minter] = false;\\n    }\\n\\n    function setPlaceholderImageURL(string memory placeholderImageURL) public onlyOwner\\n    {\\n        _placeholderImageURL = placeholderImageURL;\\n    }\\n\\n    function setAnimationBaseURL(string memory animationBaseURL) public onlyOwner\\n    {\\n        _animationBaseURL = animationBaseURL;\\n    }\\n\\n    function setCollectionName(string memory collectionName) public onlyOwner\\n    {\\n        _collectionName = collectionName;\\n    }\\n\\n    function setCollectionDesc(string memory collectionDesc) public onlyOwner\\n    {\\n        _collectionDesc = collectionDesc;\\n    }\\n\\n    function setCollectionImgURL(string memory collectionImgURL) public onlyOwner\\n    {\\n        _collectionImgURL = collectionImgURL;\\n    }\\n\\n    function setCollectionExtURL(string memory collectionExtURL) public onlyOwner\\n    {\\n        _collectionExtURL = collectionExtURL;\\n    }\\n\\n    function setFeeBasisPoints(uint256 feeBasisPoints) public onlyOwner\\n    {\\n        _feeBasisPoints = feeBasisPoints;\\n    }\\n\\n    function setFeeRecipient(address feeRecipient) public onlyOwner\\n    {\\n        _feeRecipient = feeRecipient;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC1967/ERC1967ProxyImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./ERC1967Proxy.sol\\\";\\n\\n\\n\\ncontract ProxyImplementation is Initializable\\n{\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    modifier onlyAdmin() \\n    {\\n        require(admin() == msg.sender, \\\"Implementation: caller is not admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() \\n    {\\n        require(owner() == msg.sender, \\\"Implementation: caller is not owner\\\");\\n        _;\\n    }\\n\\n    function getImplementation() public view returns(address)\\n    {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    function setImplementation(address implementation) public virtual onlyAdmin\\n    {\\n        require(AddressUpgradeable.isContract(implementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = implementation;\\n    }\\n\\n    function admin() public view returns(address)\\n    {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    function owner() public view returns(address)\\n    {\\n        return admin();\\n    }\\n\\n    function setAdmin(address newAdmin) public virtual onlyAdmin\\n    {\\n        require(newAdmin != address(0), \\\"invalid newAdmin address\\\");\\n        _setAdmin(newAdmin);\\n    }\\n\\n    function renounceAdminPowers() public virtual onlyAdmin\\n    {\\n        _setAdmin(address(0));\\n    }\\n\\n    function _setAdmin(address newAdmin) private\\n    {\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n}\"\r\n    },\r\n    \"contracts/OpenSea/ERC721TradableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport \\\"./ContextMixin.sol\\\";\\nimport \\\"./NativeMetaTransactionUpgradeable.sol\\\";\\n\\n\\ncontract OwnableDelegateProxy {}\\n\\ncontract ProxyRegistry {\\n    mapping(address => OwnableDelegateProxy) public proxies;\\n}\\n\\n/**\\n * @title ERC721Tradable\\n * ERC721Tradable - ERC721 contract that whitelists a trading address, and has minting functionality.\\n */\\nabstract contract ERC721TradableUpgradeable is ContextMixin, ERC721Upgradeable, NativeMetaTransactionUpgradeable\\n{\\n    using SafeMathUpgradeable for uint256;\\n\\n    address proxyRegistryAddress;\\n    uint256 private _currentTokenId = 0;\\n\\n    function __ERC721TradableUpgradeable_init_unchained(address _proxyRegistryAddress) internal initializer\\n    {\\n        proxyRegistryAddress = _proxyRegistryAddress;\\n    }\\n\\n    /**\\n     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        override\\n        public\\n        view\\n        returns (bool)\\n    {\\n        // Whitelist OpenSea proxy contract for easy trading.\\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\n        if (address(proxyRegistry.proxies(owner)) == operator) {\\n            return true;\\n        }\\n\\n        return super.isApprovedForAll(owner, operator);\\n    }\\n\\n    /**\\n     * This is used instead of msg.sender as transactions won't be sent by the original token owner, but by OpenSea.\\n     */\\n    function _msgSender()\\n        internal\\n        override\\n        view\\n        returns (address sender)\\n    {\\n        return ContextMixin.msgSender();\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n\\n\\ncontract Proxy\\n{\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    constructor(address implementation, bytes memory data) payable\\n    {\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = implementation;\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = msg.sender;\\n\\n        if (data.length > 0)\\n        {\\n            Address.functionDelegateCall(implementation, data, /*errorMessage*/ \\\"init failed\\\");\\n        }\\n    }\\n\\n    fallback() external payable\\n    {\\n        _fallback();\\n    }\\n\\n    receive() external payable \\n    {\\n        _fallback();\\n    }\\n\\n    function _fallback() private\\n    {\\n        address implementation = StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n\\n        // from OpenZeppelin/contracts\\n        assembly \\n        {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/OpenSea/ContextMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\n\\nabstract contract ContextMixin \\n{\\n    function msgSender() internal view returns (address payable sender)\\n    {\\n        if (msg.sender == address(this)) \\n        {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly \\n            {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } \\n        else \\n        {\\n            sender = payable(msg.sender);\\n        }\\n        return sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenSea/NativeMetaTransactionUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {SafeMathUpgradeable} from  \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\\\";\\nimport {EIP712BaseUpgradeable} from \\\"./EIP712BaseUpgradeable.sol\\\";\\n\\ncontract NativeMetaTransactionUpgradeable is EIP712BaseUpgradeable {\\n    using SafeMathUpgradeable for uint256;\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n        )\\n    );\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address payable relayerAddress,\\n        bytes functionSignature\\n    );\\n    mapping(address => uint256) nonces;\\n\\n    /*\\n     * Meta transaction structure.\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\n     * He should call the desired function directly in that case.\\n     */\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes memory functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) public payable returns (bytes memory) {\\n        MetaTransaction memory metaTx = MetaTransaction({\\n            nonce: nonces[userAddress],\\n            from: userAddress,\\n            functionSignature: functionSignature\\n        });\\n\\n        require(\\n            verify(userAddress, metaTx, sigR, sigS, sigV),\\n            \\\"Signer and signature do not match\\\"\\n        );\\n\\n        // increase nonce for user (to avoid re-use)\\n        nonces[userAddress] = nonces[userAddress].add(1);\\n\\n        emit MetaTransactionExecuted(\\n            userAddress,\\n            payable(msg.sender),\\n            functionSignature\\n        );\\n\\n        // Append userAddress and relayer address at the end to extract it from calling context\\n        (bool success, bytes memory returnData) = address(this).call(\\n            abi.encodePacked(functionSignature, userAddress)\\n        );\\n        require(success, \\\"Function call not successful\\\");\\n\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(MetaTransaction memory metaTx)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    META_TRANSACTION_TYPEHASH,\\n                    metaTx.nonce,\\n                    metaTx.from,\\n                    keccak256(metaTx.functionSignature)\\n                )\\n            );\\n    }\\n\\n    function getNonce(address user) public view returns (uint256 nonce) {\\n        nonce = nonces[user];\\n    }\\n\\n    function verify(\\n        address signer,\\n        MetaTransaction memory metaTx,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) internal view returns (bool) {\\n        require(signer != address(0), \\\"NativeMetaTransaction: INVALID_SIGNER\\\");\\n        return\\n            signer ==\\n            ecrecover(\\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\\n                sigV,\\n                sigR,\\n                sigS\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OpenSea/EIP712BaseUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\ncontract EIP712BaseUpgradeable is Initializable {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        address verifyingContract;\\n        bytes32 salt;\\n    }\\n\\n    string constant public ERC712_VERSION = \\\"1\\\";\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\"\\n        )\\n    );\\n    bytes32 internal domainSeperator;\\n\\n    // supposed to be called once while initializing.\\n    // one of the contracts that inherits this contract follows proxy pattern\\n    // so it is not possible to do this in a constructor\\n    function _initializeEIP712(\\n        string memory name\\n    )\\n        internal\\n        initializer\\n    {\\n        _setDomainSeperator(name);\\n    }\\n\\n    function _setDomainSeperator(string memory name) internal {\\n        domainSeperator = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(ERC712_VERSION)),\\n                address(this),\\n                bytes32(getChainId())\\n            )\\n        );\\n    }\\n\\n    function getDomainSeperator() public view returns (bytes32) {\\n        return domainSeperator;\\n    }\\n\\n    function getChainId() public view returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * Accept message hash and returns hash message in EIP712 compatible form\\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n     * https://eips.ethereum.org/EIPS/eip-712\\n     * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n     * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n     */\\n    function toTypedMessageHash(bytes32 messageHash)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash)\\n            );\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"olootAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mlootAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"glootAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relicAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"riftAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"imageBaseURL\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_bestRaiderLastIdsByRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_bestRaiderRelicNextIdsByRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_claims\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_imageBaseURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isXpRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_relayAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_riftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_runnerUpRelicLastIdsByRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_runnerUpRelicNextIdsByRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"dungeonId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dungeonRank\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"raidTokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"raidTokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"raidRank\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"claimCoupon\",\"type\":\"bytes\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"dungeonIds\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"dungeonRanks\",\"type\":\"uint8[]\"},{\"internalType\":\"uint64[]\",\"name\":\"raidTokenIds\",\"type\":\"uint64[]\"},{\"internalType\":\"uint8[]\",\"name\":\"raidTokenTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"raidRanks\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"claimCoupons\",\"type\":\"bytes[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableXpRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes12\",\"name\":\"\",\"type\":\"bytes12\"}],\"name\":\"getAdditionalAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImageBaseURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raidTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raidTokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"getRaidDungeonRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOwner\",\"type\":\"bool\"},{\"internalType\":\"uint256[8]\",\"name\":\"itemIds\",\"type\":\"uint256[8]\"},{\"internalType\":\"string\",\"name\":\"order\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"raiderType\",\"type\":\"uint8\"}],\"name\":\"getRaidId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes12\",\"name\":\"data\",\"type\":\"bytes12\"}],\"name\":\"getTokenOrderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes12\",\"name\":\"\",\"type\":\"bytes12\"}],\"name\":\"getTokenProvenance\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"raidTokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"raidTokenId\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raidTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raidTokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwnerOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dungeonRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raidTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"raidTokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"raidRank\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"claimCoupon\",\"type\":\"bytes\"}],\"name\":\"isVerifiedClaimRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newImageBaseURL\",\"type\":\"string\"}],\"name\":\"setImageBaseURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setRelayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Dungeon3Minter", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ff9c1b15b16263c61d017ee9f65c50e4ae0113d70000000000000000000000001dfe7ca09e99d10835bf73044a23b73fc20623df0000000000000000000000008db687aceb92c66f013e1d614137238cc698fedb00000000000000000000000038065291fdce1a752afd725e96ff75e1c38ad6aa000000000000000000000000632678bba8a4dd16255f164e9d74853bea9856e700000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001d68747470733a2f2f72656c6963732e74686563727970742e67616d652f000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}