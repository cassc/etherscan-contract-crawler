{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserves.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IReserves {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapDelay.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n\\nimport '../libraries/Orders.sol';\\n\\ninterface ITwapDelay {\\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\\n    event OwnerSet(address owner);\\n    event FactoryGovernorSet(address factoryGovernor);\\n    event BotSet(address bot, bool isBot);\\n    event DelaySet(uint256 delay);\\n    event RelayerSet(address relayer);\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n    event ToleranceSet(address pair, uint16 amount);\\n    event NonRebasingTokenSet(address token, bool isNonRebasing);\\n\\n    function factory() external view returns (address);\\n\\n    function factoryGovernor() external view returns (address);\\n\\n    function relayer() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function isBot(address bot) external view returns (bool);\\n\\n    function getTolerance(address pair) external view returns (uint16);\\n\\n    function isNonRebasingToken(address token) external view returns (bool);\\n\\n    function gasPriceInertia() external view returns (uint256);\\n\\n    function gasPrice() external view returns (uint256);\\n\\n    function maxGasPriceImpact() external view returns (uint256);\\n\\n    function maxGasLimit() external view returns (uint256);\\n\\n    function delay() external view returns (uint256);\\n\\n    function totalShares(address token) external view returns (uint256);\\n\\n    function weth() external view returns (address);\\n\\n    function getTransferGasCost(address token) external pure returns (uint256);\\n\\n    function getDepositDisabled(address pair) external view returns (bool);\\n\\n    function getWithdrawDisabled(address pair) external view returns (bool);\\n\\n    function getBuyDisabled(address pair) external view returns (bool);\\n\\n    function getSellDisabled(address pair) external view returns (bool);\\n\\n    function getOrderStatus(uint256 orderId, uint256 validAfterTimestamp) external view returns (Orders.OrderStatus);\\n\\n    function setOrderTypesDisabled(\\n        address pair,\\n        Orders.OrderType[] calldata orderTypes,\\n        bool disabled\\n    ) external;\\n\\n    function setOwner(address _owner) external;\\n\\n    function setFactoryGovernor(address _factoryGovernor) external;\\n\\n    function setBot(address _bot, bool _isBot) external;\\n\\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\\n\\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\\n\\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\\n\\n    function relayerSell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\\n\\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\\n\\n    function execute(Orders.Order[] calldata orders) external payable;\\n\\n    function retryRefund(Orders.Order calldata order) external;\\n\\n    function cancelOrder(Orders.Order calldata order) external;\\n\\n    function syncPair(address token0, address token1) external returns (address pairAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './IERC20.sol';\\n\\ninterface ITwapERC20 is IERC20 {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface ITwapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event OwnerSet(address owner);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapFactoryGovernor.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface ITwapFactoryGovernor {\\n    event FactorySet(address factory);\\n    event DelaySet(address delay);\\n    event ProtocolFeeRatioSet(uint256 protocolFeeRatio);\\n    event EthTransferCostSet(uint256 ethTransferCost);\\n    event FeeDistributed(address indexed token, address indexed pair, uint256 lpAmount, uint256 protocolAmount);\\n    event OwnerSet(address owner);\\n    event WithdrawToken(address token, address to, uint256 amount);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function delay() external view returns (address);\\n\\n    function protocolFeeRatio() external view returns (uint256);\\n\\n    function ethTransferCost() external view returns (uint256);\\n\\n    function setFactoryOwner(address) external;\\n\\n    function setFactory(address) external;\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function setDelay(address) external;\\n\\n    function setProtocolFeeRatio(uint256 _protocolFeeRatio) external;\\n\\n    function setEthTransferCost(uint256 _ethTransferCost) external;\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function collectFees(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdrawLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    function withdrawToken(\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    function distributeFees(address tokenA, address tokenB) external;\\n\\n    function distributeFees(\\n        address tokenA,\\n        address tokenB,\\n        address pairAddress\\n    ) external;\\n\\n    function feesToDistribute(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (uint256 fee0ToDistribute, uint256 fee1ToDistribute);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface ITwapOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n\\n    function decimalsConverter() external view returns (int256);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function owner() external view returns (address);\\n\\n    function uniswapPair() external view returns (address);\\n\\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint256 priceTimestamp);\\n\\n    function getSpotPrice() external view returns (uint256);\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint256 priceTimestamp) external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setUniswapPair(address _uniswapPair) external;\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xAfter);\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xIn);\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yIn);\\n\\n    function getSwapAmount0Out(\\n        uint256 swapFee,\\n        uint256 amount1In,\\n        bytes calldata data\\n    ) external view returns (uint256 amount0Out);\\n\\n    function getSwapAmount1Out(\\n        uint256 swapFee,\\n        uint256 amount0In,\\n        bytes calldata data\\n    ) external view returns (uint256 amount1Out);\\n\\n    function getSwapAmountInMaxOut(\\n        bool inverse,\\n        uint256 swapFee,\\n        uint256 _amountOut,\\n        bytes calldata data\\n    ) external view returns (uint256 amountIn, uint256 amountOut);\\n\\n    function getSwapAmountInMinOut(\\n        bool inverse,\\n        uint256 swapFee,\\n        uint256 _amountOut,\\n        bytes calldata data\\n    ) external view returns (uint256 amountIn, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapPair.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './ITwapERC20.sol';\\nimport './IReserves.sol';\\n\\ninterface ITwapPair is ITwapERC20, IReserves {\\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AddLiquidity.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport './TransferHelper.sol';\\nimport './SafeMath.sol';\\nimport './Math.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\n\\nlibrary AddLiquidity {\\n    using SafeMath for uint256;\\n\\n    function addLiquidity(\\n        address pair,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1,\\n            uint256 swapToken\\n        )\\n    {\\n        if (amount0Desired == 0 || amount1Desired == 0) {\\n            if (amount0Desired > 0) {\\n                swapToken = 1;\\n            } else if (amount1Desired > 0) {\\n                swapToken = 2;\\n            }\\n            return (0, 0, swapToken);\\n        }\\n        (uint256 reserve0, uint256 reserve1) = ITwapPair(pair).getReserves();\\n        if (reserve0 == 0 && reserve1 == 0) {\\n            (amount0, amount1) = (amount0Desired, amount1Desired);\\n        } else {\\n            require(reserve0 > 0 && reserve1 > 0, 'AL07');\\n            uint256 amount1Optimal = amount0Desired.mul(reserve1) / reserve0;\\n            if (amount1Optimal <= amount1Desired) {\\n                swapToken = 2;\\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\\n            } else {\\n                uint256 amount0Optimal = amount1Desired.mul(reserve0) / reserve1;\\n                assert(amount0Optimal <= amount0Desired);\\n                swapToken = 1;\\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\\n            }\\n\\n            uint256 totalSupply = ITwapPair(pair).totalSupply();\\n            uint256 liquidityOut = Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);\\n            if (liquidityOut == 0) {\\n                amount0 = 0;\\n                amount1 = 0;\\n            }\\n        }\\n    }\\n\\n    function addLiquidityAndMint(\\n        address pair,\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    )\\n        external\\n        returns (\\n            uint256 amount0Left,\\n            uint256 amount1Left,\\n            uint256 swapToken\\n        )\\n    {\\n        uint256 amount0;\\n        uint256 amount1;\\n        (amount0, amount1, swapToken) = addLiquidity(pair, amount0Desired, amount1Desired);\\n        if (amount0 == 0 || amount1 == 0) {\\n            return (amount0Desired, amount1Desired, swapToken);\\n        }\\n        TransferHelper.safeTransfer(token0, pair, amount0);\\n        TransferHelper.safeTransfer(token1, pair, amount1);\\n        ITwapPair(pair).mint(to);\\n\\n        amount0Left = amount0Desired.sub(amount0);\\n        amount1Left = amount1Desired.sub(amount1);\\n    }\\n\\n    function swapDeposit0(\\n        address pair,\\n        address token0,\\n        uint256 amount0,\\n        uint256 minSwapPrice,\\n        uint16 tolerance,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount0In = ITwapPair(pair).getDepositAmount0In(amount0, data);\\n        amount1Left = ITwapPair(pair).getSwapAmount1Out(amount0In, data).sub(tolerance);\\n        if (amount1Left == 0) {\\n            return (amount0, amount1Left);\\n        }\\n        uint256 price = getPrice(amount0In, amount1Left, pair);\\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL15');\\n        TransferHelper.safeTransfer(token0, pair, amount0In);\\n        ITwapPair(pair).swap(0, amount1Left, address(this), data);\\n        amount0Left = amount0.sub(amount0In);\\n    }\\n\\n    function swapDeposit1(\\n        address pair,\\n        address token1,\\n        uint256 amount1,\\n        uint256 maxSwapPrice,\\n        uint16 tolerance,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount1In = ITwapPair(pair).getDepositAmount1In(amount1, data);\\n        amount0Left = ITwapPair(pair).getSwapAmount0Out(amount1In, data).sub(tolerance);\\n        if (amount0Left == 0) {\\n            return (amount0Left, amount1);\\n        }\\n        uint256 price = getPrice(amount0Left, amount1In, pair);\\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL16');\\n        TransferHelper.safeTransfer(token1, pair, amount1In);\\n        ITwapPair(pair).swap(amount0Left, 0, address(this), data);\\n        amount1Left = amount1.sub(amount1In);\\n    }\\n\\n    function getPrice(\\n        uint256 amount0,\\n        uint256 amount1,\\n        address pair\\n    ) internal view returns (uint256) {\\n        ITwapOracle oracle = ITwapOracle(ITwapPair(pair).oracle());\\n        return amount1.mul(uint256(oracle.decimalsConverter())).div(amount0);\\n    }\\n\\n    function _refundDeposit(\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal {\\n        if (amount0 > 0) {\\n            TransferHelper.safeTransfer(token0, to, amount0);\\n        }\\n        if (amount1 > 0) {\\n            TransferHelper.safeTransfer(token1, to, amount1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ExecutionHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n\\nimport '../interfaces/ITwapOracle.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/IWETH.sol';\\nimport '../libraries/SafeMath.sol';\\nimport '../libraries/Orders.sol';\\nimport '../libraries/TokenShares.sol';\\nimport '../libraries/AddLiquidity.sol';\\nimport '../libraries/WithdrawHelper.sol';\\n\\nlibrary ExecutionHelper {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    using Orders for Orders.Data;\\n    using TokenShares for TokenShares.Data;\\n\\n    uint256 private constant ORDER_LIFESPAN = 48 hours;\\n\\n    struct ExecuteBuySellParams {\\n        Orders.Order order;\\n        address pairAddress;\\n        uint16 pairTolerance;\\n    }\\n\\n    function executeDeposit(\\n        Orders.Order calldata order,\\n        address pairAddress,\\n        uint16 pairTolerance,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        require(order.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'EH04');\\n\\n        (uint256 amount0Left, uint256 amount1Left, uint256 swapToken) = _initialDeposit(\\n            order,\\n            pairAddress,\\n            tokenShares\\n        );\\n\\n        if (order.swap && swapToken != 0) {\\n            bytes memory data = encodePriceInfo(pairAddress, order.priceAccumulator, order.timestamp);\\n            if (amount0Left != 0 && swapToken == 1) {\\n                uint256 extraAmount1;\\n                (amount0Left, extraAmount1) = AddLiquidity.swapDeposit0(\\n                    pairAddress,\\n                    order.token0,\\n                    amount0Left,\\n                    order.minSwapPrice,\\n                    pairTolerance,\\n                    data\\n                );\\n                amount1Left = amount1Left.add(extraAmount1);\\n            } else if (amount1Left != 0 && swapToken == 2) {\\n                uint256 extraAmount0;\\n                (extraAmount0, amount1Left) = AddLiquidity.swapDeposit1(\\n                    pairAddress,\\n                    order.token1,\\n                    amount1Left,\\n                    order.maxSwapPrice,\\n                    pairTolerance,\\n                    data\\n                );\\n                amount0Left = amount0Left.add(extraAmount0);\\n            }\\n        }\\n\\n        if (amount0Left != 0 && amount1Left != 0) {\\n            (amount0Left, amount1Left, ) = AddLiquidity.addLiquidityAndMint(\\n                pairAddress,\\n                order.to,\\n                order.token0,\\n                order.token1,\\n                amount0Left,\\n                amount1Left\\n            );\\n        }\\n\\n        AddLiquidity._refundDeposit(order.to, order.token0, order.token1, amount0Left, amount1Left);\\n    }\\n\\n    function _initialDeposit(\\n        Orders.Order calldata order,\\n        address pairAddress,\\n        TokenShares.Data storage tokenShares\\n    )\\n        private\\n        returns (\\n            uint256 amount0Left,\\n            uint256 amount1Left,\\n            uint256 swapToken\\n        )\\n    {\\n        uint256 amount0Desired = tokenShares.sharesToAmount(order.token0, order.value0, order.amountLimit0, order.to);\\n        uint256 amount1Desired = tokenShares.sharesToAmount(order.token1, order.value1, order.amountLimit1, order.to);\\n        (amount0Left, amount1Left, swapToken) = AddLiquidity.addLiquidityAndMint(\\n            pairAddress,\\n            order.to,\\n            order.token0,\\n            order.token1,\\n            amount0Desired,\\n            amount1Desired\\n        );\\n    }\\n\\n    function executeWithdraw(Orders.Order calldata order) external {\\n        require(order.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'EH04');\\n        (address pairAddress, ) = Orders.getPair(order.token0, order.token1);\\n        TransferHelper.safeTransfer(pairAddress, pairAddress, order.liquidity);\\n        uint256 wethAmount;\\n        uint256 amount0;\\n        uint256 amount1;\\n        if (order.unwrap && (order.token0 == TokenShares.WETH_ADDRESS || order.token1 == TokenShares.WETH_ADDRESS)) {\\n            bool success;\\n            (success, wethAmount, amount0, amount1) = WithdrawHelper.withdrawAndUnwrap(\\n                order.token0,\\n                order.token1,\\n                pairAddress,\\n                TokenShares.WETH_ADDRESS,\\n                order.to,\\n                Orders.getTransferGasCost(Orders.NATIVE_CURRENCY_SENTINEL)\\n            );\\n            if (!success) {\\n                TokenShares.onUnwrapFailed(order.to, wethAmount);\\n            }\\n        } else {\\n            (amount0, amount1) = ITwapPair(pairAddress).burn(order.to);\\n        }\\n        require(amount0 >= order.value0 && amount1 >= order.value1, 'EH03');\\n    }\\n\\n    function executeBuy(ExecuteBuySellParams memory orderParams, TokenShares.Data storage tokenShares) external {\\n        require(orderParams.order.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'EH04');\\n\\n        uint256 amountInMax = tokenShares.sharesToAmount(\\n            orderParams.order.token0,\\n            orderParams.order.value0,\\n            orderParams.order.amountLimit0,\\n            orderParams.order.to\\n        );\\n        bytes memory priceInfo = encodePriceInfo(\\n            orderParams.pairAddress,\\n            orderParams.order.priceAccumulator,\\n            orderParams.order.timestamp\\n        );\\n        uint256 amountIn;\\n        uint256 amountOut;\\n        uint256 reserveOut;\\n        bool inverted = orderParams.order.inverted;\\n        {\\n            // scope for reserve out logic, avoids stack too deep errors\\n            (uint112 reserve0, uint112 reserve1) = ITwapPair(orderParams.pairAddress).getReserves();\\n            // subtract 1 to prevent reserve going to 0\\n            reserveOut = uint256(inverted ? reserve0 : reserve1).sub(1);\\n        }\\n        {\\n            // scope for partial fill logic, avoids stack too deep errors\\n            address oracle = ITwapPair(orderParams.pairAddress).oracle();\\n            uint256 swapFee = ITwapPair(orderParams.pairAddress).swapFee();\\n            (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMaxOut(\\n                inverted,\\n                swapFee,\\n                orderParams.order.value1,\\n                priceInfo\\n            );\\n            uint256 amountInMaxScaled;\\n            if (amountOut > reserveOut) {\\n                amountInMaxScaled = amountInMax.mul(reserveOut).ceil_div(orderParams.order.value1);\\n                (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMinOut(\\n                    inverted,\\n                    swapFee,\\n                    reserveOut,\\n                    priceInfo\\n                );\\n            } else {\\n                amountInMaxScaled = amountInMax;\\n                amountOut = orderParams.order.value1; // Truncate to desired out\\n            }\\n            require(amountInMaxScaled >= amountIn, 'EH08');\\n            if (amountInMax > amountIn) {\\n                if (orderParams.order.token0 == TokenShares.WETH_ADDRESS && orderParams.order.unwrap) {\\n                    forceEtherTransfer(orderParams.order.to, amountInMax.sub(amountIn));\\n                } else {\\n                    TransferHelper.safeTransfer(\\n                        orderParams.order.token0,\\n                        orderParams.order.to,\\n                        amountInMax.sub(amountIn)\\n                    );\\n                }\\n            }\\n            TransferHelper.safeTransfer(orderParams.order.token0, orderParams.pairAddress, amountIn);\\n        }\\n        amountOut = amountOut.sub(orderParams.pairTolerance);\\n        uint256 amount0Out;\\n        uint256 amount1Out;\\n        if (inverted) {\\n            amount0Out = amountOut;\\n        } else {\\n            amount1Out = amountOut;\\n        }\\n        if (orderParams.order.token1 == TokenShares.WETH_ADDRESS && orderParams.order.unwrap) {\\n            ITwapPair(orderParams.pairAddress).swap(amount0Out, amount1Out, address(this), priceInfo);\\n            forceEtherTransfer(orderParams.order.to, amountOut);\\n        } else {\\n            ITwapPair(orderParams.pairAddress).swap(amount0Out, amount1Out, orderParams.order.to, priceInfo);\\n        }\\n    }\\n\\n    function executeSell(ExecuteBuySellParams memory orderParams, TokenShares.Data storage tokenShares) external {\\n        require(orderParams.order.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'EH04');\\n\\n        bytes memory priceInfo = encodePriceInfo(\\n            orderParams.pairAddress,\\n            orderParams.order.priceAccumulator,\\n            orderParams.order.timestamp\\n        );\\n\\n        uint256 amountOut = _executeSellHelper(orderParams, priceInfo, tokenShares);\\n\\n        (uint256 amount0Out, uint256 amount1Out) = orderParams.order.inverted\\n            ? (amountOut, uint256(0))\\n            : (uint256(0), amountOut);\\n        if (orderParams.order.token1 == TokenShares.WETH_ADDRESS && orderParams.order.unwrap) {\\n            ITwapPair(orderParams.pairAddress).swap(amount0Out, amount1Out, address(this), priceInfo);\\n            forceEtherTransfer(orderParams.order.to, amountOut);\\n        } else {\\n            ITwapPair(orderParams.pairAddress).swap(amount0Out, amount1Out, orderParams.order.to, priceInfo);\\n        }\\n    }\\n\\n    function _executeSellHelper(\\n        ExecuteBuySellParams memory orderParams,\\n        bytes memory priceInfo,\\n        TokenShares.Data storage tokenShares\\n    ) internal returns (uint256 amountOut) {\\n        uint256 reserveOut;\\n        {\\n            // scope for determining reserve out, avoids stack too deep errors\\n            (uint112 reserve0, uint112 reserve1) = ITwapPair(orderParams.pairAddress).getReserves();\\n            // subtract 1 to prevent reserve going to 0\\n            reserveOut = uint256(orderParams.order.inverted ? reserve0 : reserve1).sub(1);\\n        }\\n        {\\n            // scope for calculations, avoids stack too deep errors\\n            address oracle = ITwapPair(orderParams.pairAddress).oracle();\\n            uint256 swapFee = ITwapPair(orderParams.pairAddress).swapFee();\\n            uint256 amountIn = tokenShares.sharesToAmount(\\n                orderParams.order.token0,\\n                orderParams.order.value0,\\n                orderParams.order.amountLimit0,\\n                orderParams.order.to\\n            );\\n            amountOut = orderParams.order.inverted\\n                ? ITwapOracle(oracle).getSwapAmount0Out(swapFee, amountIn, priceInfo)\\n                : ITwapOracle(oracle).getSwapAmount1Out(swapFee, amountIn, priceInfo);\\n\\n            uint256 amountOutMinScaled;\\n            if (amountOut > reserveOut) {\\n                amountOutMinScaled = orderParams.order.value1.mul(reserveOut).div(amountOut);\\n                uint256 _amountIn = amountIn;\\n                (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMinOut(\\n                    orderParams.order.inverted,\\n                    swapFee,\\n                    reserveOut,\\n                    priceInfo\\n                );\\n                if (orderParams.order.token0 == TokenShares.WETH_ADDRESS && orderParams.order.unwrap) {\\n                    forceEtherTransfer(orderParams.order.to, _amountIn.sub(amountIn));\\n                } else {\\n                    TransferHelper.safeTransfer(\\n                        orderParams.order.token0,\\n                        orderParams.order.to,\\n                        _amountIn.sub(amountIn)\\n                    );\\n                }\\n            } else {\\n                amountOutMinScaled = orderParams.order.value1;\\n            }\\n            amountOut = amountOut.sub(orderParams.pairTolerance);\\n            require(amountOut >= amountOutMinScaled, 'EH37');\\n            TransferHelper.safeTransfer(orderParams.order.token0, orderParams.pairAddress, amountIn);\\n        }\\n    }\\n\\n    function encodePriceInfo(\\n        address pairAddress,\\n        uint256 priceAccumulator,\\n        uint256 priceTimestamp\\n    ) internal view returns (bytes memory data) {\\n        uint256 price = ITwapOracle(ITwapPair(pairAddress).oracle()).getAveragePrice(priceAccumulator, priceTimestamp);\\n        // Pack everything as 32 bytes / uint256 to simplify decoding\\n        data = abi.encode(price);\\n    }\\n\\n    function forceEtherTransfer(address to, uint256 amount) internal {\\n        IWETH(TokenShares.WETH_ADDRESS).withdraw(amount);\\n        (bool success, ) = to.call{ value: amount, gas: Orders.getTransferGasCost(Orders.NATIVE_CURRENCY_SENTINEL) }(\\n            ''\\n        );\\n        if (!success) {\\n            TokenShares.onUnwrapFailed(to, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Orders.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n\\nimport './SafeMath.sol';\\nimport '../libraries/Math.sol';\\nimport '../interfaces/ITwapFactory.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\nimport '../libraries/TokenShares.sol';\\n\\n\\nlibrary Orders {\\n    using SafeMath for uint256;\\n    using TokenShares for TokenShares.Data;\\n    using TransferHelper for address;\\n\\n    enum OrderType {\\n        Empty,\\n        Deposit,\\n        Withdraw,\\n        Sell,\\n        Buy\\n    }\\n    enum OrderStatus {\\n        NonExistent,\\n        EnqueuedWaiting,\\n        EnqueuedReady,\\n        ExecutedSucceeded,\\n        ExecutedFailed,\\n        Canceled\\n    }\\n\\n    event DepositEnqueued(uint256 indexed orderId, Order order);\\n    event WithdrawEnqueued(uint256 indexed orderId, Order order);\\n    event SellEnqueued(uint256 indexed orderId, Order order);\\n    event BuyEnqueued(uint256 indexed orderId, Order order);\\n\\n    event OrderTypesDisabled(address pair, Orders.OrderType[] orderTypes, bool disabled);\\n\\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\\n\\n    // Note on gas estimation for the full order execution in the UI:\\n    // Add (ORDER_BASE_COST + token transfer costs) to the actual gas usage\\n    // of the TwapDelay._execute* functions when updating gas cost in the UI.\\n    // Remember that ETH unwrap is part of those functions. It is optional,\\n    // but also needs to be included in the estimate.\\n\\n    uint256 public constant ETHER_TRANSFER_COST = ETHER_TRANSFER_CALL_COST + 2600 + 1504; // Std cost + EIP-2929 acct access cost + Gnosis Safe receive ETH cost\\n    uint256 private constant BOT_ETHER_TRANSFER_COST = 10_000;\\n    uint256 private constant BUFFER_COST = 10_000;\\n    uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;\\n    uint256 private constant EXECUTE_PREPARATION_COST = 30_000; // dequeue + gas calculation before calls to _execute* functions\\n\\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10_000;\\n    uint256 public constant PAIR_TRANSFER_COST = 55_000;\\n    uint256 public constant REFUND_BASE_COST =\\n        BOT_ETHER_TRANSFER_COST + ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;\\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;\\n\\n    // Masks used for setting order disabled\\n    // Different bits represent different order types\\n    uint8 private constant DEPOSIT_MASK = uint8(1 << uint8(OrderType.Deposit)); //   00000010\\n    uint8 private constant WITHDRAW_MASK = uint8(1 << uint8(OrderType.Withdraw)); // 00000100\\n    uint8 private constant SELL_MASK = uint8(1 << uint8(OrderType.Sell)); //         00001000\\n    uint8 private constant BUY_MASK = uint8(1 << uint8(OrderType.Buy)); //           00010000\\n\\n    address public constant FACTORY_ADDRESS = 0xC480b33eE5229DE3FbDFAD1D2DCD3F3BAD0C56c6; \\n    uint256 public constant MAX_GAS_LIMIT = 5000000; \\n    uint256 public constant GAS_PRICE_INERTIA = 20000000; \\n    uint256 public constant MAX_GAS_PRICE_IMPACT = 1000000; \\n    uint256 public constant DELAY = 1800; \\n\\n    address public constant NATIVE_CURRENCY_SENTINEL = address(0); // A sentinel value for the native currency to distinguish it from ERC20 tokens\\n\\n    struct Data {\\n        uint256 newestOrderId;\\n        uint256 lastProcessedOrderId;\\n        mapping(uint256 => bytes32) orderQueue;\\n        uint256 gasPrice;\\n        mapping(uint256 => bool) canceled;\\n        // Bit on specific positions indicates whether order type is disabled (1) or enabled (0) on specific pair\\n        mapping(address => uint8) orderTypesDisabled;\\n        mapping(uint256 => bool) refundFailed;\\n    }\\n\\n    struct Order {\\n        uint256 orderId;\\n        OrderType orderType;\\n        bool inverted;\\n        uint256 validAfterTimestamp;\\n        bool unwrap;\\n        uint256 timestamp;\\n        uint256 gasLimit;\\n        uint256 gasPrice;\\n        uint256 liquidity;\\n        uint256 value0; // Deposit: share0, Withdraw: amount0Min, Sell: shareIn, Buy: shareInMax\\n        uint256 value1; // Deposit: share1, Withdraw: amount1Min, Sell: amountOutMin, Buy: amountOut\\n        address token0; // Sell: tokenIn, Buy: tokenIn\\n        address token1; // Sell: tokenOut, Buy: tokenOut\\n        address to;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool swap;\\n        uint256 priceAccumulator;\\n        uint256 amountLimit0;\\n        uint256 amountLimit1;\\n    }\\n\\n    function getOrderStatus(\\n        Data storage data,\\n        uint256 orderId,\\n        uint256 validAfterTimestamp\\n    ) internal view returns (OrderStatus) {\\n        if (orderId > data.newestOrderId) {\\n            return OrderStatus.NonExistent;\\n        }\\n        if (data.canceled[orderId]) {\\n            return OrderStatus.Canceled;\\n        }\\n        if (data.refundFailed[orderId]) {\\n            return OrderStatus.ExecutedFailed;\\n        }\\n        if (data.orderQueue[orderId] == bytes32(0)) {\\n            return OrderStatus.ExecutedSucceeded;\\n        }\\n        if (validAfterTimestamp >= block.timestamp) {\\n            return OrderStatus.EnqueuedWaiting;\\n        }\\n        return OrderStatus.EnqueuedReady;\\n    }\\n\\n    function getPair(address tokenA, address tokenB) internal view returns (address pair, bool inverted) {\\n        pair = ITwapFactory(FACTORY_ADDRESS).getPair(tokenA, tokenB);\\n        require(pair != address(0), 'OS17');\\n        inverted = tokenA > tokenB;\\n    }\\n\\n    function getDepositDisabled(Data storage data, address pair) internal view returns (bool) {\\n        return data.orderTypesDisabled[pair] & DEPOSIT_MASK != 0;\\n    }\\n\\n    function getWithdrawDisabled(Data storage data, address pair) internal view returns (bool) {\\n        return data.orderTypesDisabled[pair] & WITHDRAW_MASK != 0;\\n    }\\n\\n    function getSellDisabled(Data storage data, address pair) internal view returns (bool) {\\n        return data.orderTypesDisabled[pair] & SELL_MASK != 0;\\n    }\\n\\n    function getBuyDisabled(Data storage data, address pair) internal view returns (bool) {\\n        return data.orderTypesDisabled[pair] & BUY_MASK != 0;\\n    }\\n\\n    function setOrderTypesDisabled(\\n        Data storage data,\\n        address pair,\\n        Orders.OrderType[] calldata orderTypes,\\n        bool disabled\\n    ) external {\\n        uint256 orderTypesLength = orderTypes.length;\\n        uint8 currentSettings = data.orderTypesDisabled[pair];\\n\\n        uint8 combinedMask;\\n        for (uint256 i; i < orderTypesLength; ++i) {\\n            Orders.OrderType orderType = orderTypes[i];\\n            require(orderType != Orders.OrderType.Empty, 'OS32');\\n            // zeros with 1 bit set at position specified by orderType\\n            // e.g. for SELL order type\\n            // mask for SELL    = 00001000\\n            // combinedMask     = 00000110 (DEPOSIT and WITHDRAW masks set in previous iterations)\\n            // the result of OR = 00001110 (DEPOSIT, WITHDRAW and SELL combined mask)\\n            combinedMask = combinedMask | uint8(1 << uint8(orderType));\\n        }\\n\\n        // set/unset a bit accordingly to 'disabled' value\\n        if (disabled) {\\n            // OR operation to disable order\\n            // e.g. for disable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // mask for DEPOSIT  = 00000010\\n            // the result of OR  = 00010110\\n            currentSettings = currentSettings | combinedMask;\\n        } else {\\n            // AND operation with a mask negation to enable order\\n            // e.g. for enable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // 0xff              = 11111111\\n            // mask for Deposit  = 00000010\\n            // mask negation     = 11111101\\n            // the result of AND = 00010100\\n            currentSettings = currentSettings & (combinedMask ^ 0xff);\\n        }\\n        require(currentSettings != data.orderTypesDisabled[pair], 'OS01');\\n        data.orderTypesDisabled[pair] = currentSettings;\\n\\n        emit OrderTypesDisabled(pair, orderTypes, disabled);\\n    }\\n\\n    function markRefundFailed(Data storage data) internal {\\n        data.refundFailed[data.lastProcessedOrderId] = true;\\n    }\\n\\n    /// @dev The passed in order.oderId is ignored and overwritten with the correct value, i.e. an updated data.newestOrderId.\\n    /// This is done to ensure atomicity of these two actions while optimizing gas usage - adding an order to the queue and incrementing\\n    /// data.newestOrderId (which should not be done anywhere else in the contract).\\n    /// Must only be called on verified orders.\\n    function enqueueOrder(Data storage data, Order memory order) internal {\\n        order.orderId = ++data.newestOrderId;\\n        data.orderQueue[order.orderId] = getOrderDigest(order);\\n    }\\n\\n    struct DepositParams {\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool wrap;\\n        bool swap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function deposit(\\n        Data storage data,\\n        DepositParams calldata depositParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        {\\n            // scope for checks, avoids stack too deep errors\\n            uint256 token0TransferCost = getTransferGasCost(depositParams.token0);\\n            uint256 token1TransferCost = getTransferGasCost(depositParams.token1);\\n            checkOrderParams(\\n                depositParams.to,\\n                depositParams.gasLimit,\\n                depositParams.submitDeadline,\\n                ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost)\\n            );\\n        }\\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');\\n        (address pairAddress, bool inverted) = getPair(depositParams.token0, depositParams.token1);\\n        require(!getDepositDisabled(data, pairAddress), 'OS46');\\n        {\\n            // scope for value, avoids stack too deep errors\\n            uint256 value = msg.value;\\n\\n            // allocate gas refund\\n            if (depositParams.wrap) {\\n                if (depositParams.token0 == TokenShares.WETH_ADDRESS) {\\n                    value = msg.value.sub(depositParams.amount0, 'OS1E');\\n                } else if (depositParams.token1 == TokenShares.WETH_ADDRESS) {\\n                    value = msg.value.sub(depositParams.amount1, 'OS1E');\\n                }\\n            }\\n            allocateGasRefund(data, value, depositParams.gasLimit);\\n        }\\n\\n        uint256 shares0 = tokenShares.amountToShares(\\n            inverted ? depositParams.token1 : depositParams.token0,\\n            inverted ? depositParams.amount1 : depositParams.amount0,\\n            depositParams.wrap\\n        );\\n        uint256 shares1 = tokenShares.amountToShares(\\n            inverted ? depositParams.token0 : depositParams.token1,\\n            inverted ? depositParams.amount0 : depositParams.amount1,\\n            depositParams.wrap\\n        );\\n\\n        (uint256 priceAccumulator, uint256 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n\\n        Order memory order = Order(\\n            0,\\n            OrderType.Deposit,\\n            inverted,\\n            timestamp + DELAY, // validAfterTimestamp\\n            depositParams.wrap,\\n            timestamp,\\n            depositParams.gasLimit,\\n            data.gasPrice,\\n            0, // liquidity\\n            shares0,\\n            shares1,\\n            inverted ? depositParams.token1 : depositParams.token0,\\n            inverted ? depositParams.token0 : depositParams.token1,\\n            depositParams.to,\\n            depositParams.minSwapPrice,\\n            depositParams.maxSwapPrice,\\n            depositParams.swap,\\n            priceAccumulator,\\n            inverted ? depositParams.amount1 : depositParams.amount0,\\n            inverted ? depositParams.amount0 : depositParams.amount1\\n        );\\n        enqueueOrder(data, order);\\n\\n        emit DepositEnqueued(order.orderId, order);\\n    }\\n\\n    struct WithdrawParams {\\n        address token0;\\n        address token1;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\\n        (address pair, bool inverted) = getPair(withdrawParams.token0, withdrawParams.token1);\\n        require(!getWithdrawDisabled(data, pair), 'OS0A');\\n        checkOrderParams(\\n            withdrawParams.to,\\n            withdrawParams.gasLimit,\\n            withdrawParams.submitDeadline,\\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\\n        );\\n        require(withdrawParams.liquidity != 0, 'OS22');\\n\\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\\n\\n        Order memory order = Order(\\n            0,\\n            OrderType.Withdraw,\\n            inverted,\\n            block.timestamp + DELAY, // validAfterTimestamp\\n            withdrawParams.unwrap,\\n            0, // timestamp\\n            withdrawParams.gasLimit,\\n            data.gasPrice,\\n            withdrawParams.liquidity,\\n            inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\\n            inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\\n            inverted ? withdrawParams.token1 : withdrawParams.token0,\\n            inverted ? withdrawParams.token0 : withdrawParams.token1,\\n            withdrawParams.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            0, // priceAccumulator\\n            0, // amountLimit0\\n            0 // amountLimit1\\n        );\\n        enqueueOrder(data, order);\\n\\n        emit WithdrawEnqueued(order.orderId, order);\\n    }\\n\\n    struct SellParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function sell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = getTransferGasCost(sellParams.tokenIn);\\n        checkOrderParams(\\n            sellParams.to,\\n            sellParams.gasLimit,\\n            sellParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n\\n        (address pairAddress, bool inverted) = sellHelper(data, sellParams);\\n\\n        (uint256 priceAccumulator, uint256 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n\\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\\n\\n        Order memory order = Order(\\n            0,\\n            OrderType.Sell,\\n            inverted,\\n            timestamp + DELAY, // validAfterTimestamp\\n            sellParams.wrapUnwrap,\\n            timestamp,\\n            sellParams.gasLimit,\\n            data.gasPrice,\\n            0, // liquidity\\n            shares,\\n            sellParams.amountOutMin,\\n            sellParams.tokenIn,\\n            sellParams.tokenOut,\\n            sellParams.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            priceAccumulator,\\n            sellParams.amountIn,\\n            0 // amountLimit1\\n        );\\n        enqueueOrder(data, order);\\n\\n        emit SellEnqueued(order.orderId, order);\\n    }\\n\\n    function relayerSell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        checkOrderParams(sellParams.to, sellParams.gasLimit, sellParams.submitDeadline, ORDER_BASE_COST);\\n\\n        (, bool inverted) = sellHelper(data, sellParams);\\n\\n        uint256 shares = tokenShares.amountToSharesWithoutTransfer(\\n            sellParams.tokenIn,\\n            sellParams.amountIn,\\n            sellParams.wrapUnwrap\\n        );\\n\\n        Order memory order = Order(\\n            0,\\n            OrderType.Sell,\\n            inverted,\\n            block.timestamp + DELAY, // validAfterTimestamp\\n            false, // Never wrap/unwrap\\n            block.timestamp,\\n            sellParams.gasLimit,\\n            data.gasPrice,\\n            0, // liquidity\\n            shares,\\n            sellParams.amountOutMin,\\n            sellParams.tokenIn,\\n            sellParams.tokenOut,\\n            sellParams.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            0, // priceAccumulator - oracleV3 pairs don't need priceAccumulator\\n            sellParams.amountIn,\\n            0 // amountLimit1\\n        );\\n        enqueueOrder(data, order);\\n\\n        emit SellEnqueued(order.orderId, order);\\n    }\\n\\n    function sellHelper(Data storage data, SellParams calldata sellParams)\\n        internal\\n        returns (address pairAddress, bool inverted)\\n    {\\n        require(sellParams.amountIn != 0, 'OS24');\\n        (pairAddress, inverted) = getPair(sellParams.tokenIn, sellParams.tokenOut);\\n        require(!getSellDisabled(data, pairAddress), 'OS13');\\n\\n        // allocate gas refund\\n        uint256 value = msg.value;\\n        if (sellParams.wrapUnwrap && sellParams.tokenIn == TokenShares.WETH_ADDRESS) {\\n            value = msg.value.sub(sellParams.amountIn, 'OS1E');\\n        }\\n        allocateGasRefund(data, value, sellParams.gasLimit);\\n    }\\n\\n    struct BuyParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountInMax;\\n        uint256 amountOut;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function buy(\\n        Data storage data,\\n        BuyParams calldata buyParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = getTransferGasCost(buyParams.tokenIn);\\n        checkOrderParams(\\n            buyParams.to,\\n            buyParams.gasLimit,\\n            buyParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n        require(buyParams.amountOut != 0, 'OS23');\\n        (address pairAddress, bool inverted) = getPair(buyParams.tokenIn, buyParams.tokenOut);\\n        require(!getBuyDisabled(data, pairAddress), 'OS49');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (buyParams.tokenIn == TokenShares.WETH_ADDRESS && buyParams.wrapUnwrap) {\\n            value = msg.value.sub(buyParams.amountInMax, 'OS1E');\\n        }\\n\\n        allocateGasRefund(data, value, buyParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\\n\\n        (uint256 priceAccumulator, uint256 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n\\n        Order memory order = Order(\\n            0,\\n            OrderType.Buy,\\n            inverted,\\n            timestamp + DELAY, // validAfterTimestamp\\n            buyParams.wrapUnwrap,\\n            timestamp,\\n            buyParams.gasLimit,\\n            data.gasPrice,\\n            0, // liquidity\\n            shares,\\n            buyParams.amountOut,\\n            buyParams.tokenIn,\\n            buyParams.tokenOut,\\n            buyParams.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            priceAccumulator,\\n            buyParams.amountInMax,\\n            0 // amountLimit1\\n        );\\n        enqueueOrder(data, order);\\n\\n        emit BuyEnqueued(order.orderId, order);\\n    }\\n\\n    function checkOrderParams(\\n        address to,\\n        uint256 gasLimit,\\n        uint32 submitDeadline,\\n        uint256 minGasLimit\\n    ) private view {\\n        require(submitDeadline >= block.timestamp, 'OS04');\\n        require(gasLimit <= MAX_GAS_LIMIT, 'OS3E');\\n        require(gasLimit >= minGasLimit, 'OS3D');\\n        require(to != address(0), 'OS26');\\n    }\\n\\n    function allocateGasRefund(\\n        Data storage data,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) private returns (uint256 futureFee) {\\n        futureFee = data.gasPrice.mul(gasLimit);\\n        require(value >= futureFee, 'OS1E');\\n        if (value > futureFee) {\\n            TransferHelper.safeTransferETH(\\n                msg.sender,\\n                value.sub(futureFee),\\n                getTransferGasCost(NATIVE_CURRENCY_SENTINEL)\\n            );\\n        }\\n    }\\n\\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\\n        uint256 scale = Math.min(gasUsed, MAX_GAS_PRICE_IMPACT);\\n        data.gasPrice = data.gasPrice.mul(GAS_PRICE_INERTIA.sub(scale)).add(tx.gasprice.mul(scale)).div(\\n            GAS_PRICE_INERTIA\\n        );\\n    }\\n\\n    function refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity,\\n        bytes4 selector\\n    ) internal returns (bool) {\\n        if (liquidity == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: PAIR_TRANSFER_COST }(\\n            abi.encodeWithSelector(selector, pair, to, liquidity, false)\\n        );\\n        if (!success) {\\n            emit RefundFailed(to, pair, liquidity, data);\\n        }\\n        return success;\\n    }\\n\\n    function dequeueOrder(Data storage data, uint256 orderId) internal {\\n        ++data.lastProcessedOrderId;\\n        require(orderId == data.lastProcessedOrderId, 'OS72');\\n    }\\n\\n    function forgetOrder(Data storage data, uint256 orderId) internal {\\n        delete data.orderQueue[orderId];\\n    }\\n\\n    function forgetLastProcessedOrder(Data storage data) internal {\\n        delete data.orderQueue[data.lastProcessedOrderId];\\n    }\\n\\n    function getOrderDigest(Order memory order) internal pure returns (bytes32) {\\n        // Used to avoid the 'stack too deep' error.\\n        bytes memory partialOrderData = abi.encodePacked(\\n            order.orderId,\\n            order.orderType,\\n            order.inverted,\\n            order.validAfterTimestamp,\\n            order.unwrap,\\n            order.timestamp,\\n            order.gasLimit,\\n            order.gasPrice,\\n            order.liquidity,\\n            order.value0,\\n            order.value1,\\n            order.token0,\\n            order.token1,\\n            order.to\\n        );\\n\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    partialOrderData,\\n                    order.minSwapPrice,\\n                    order.maxSwapPrice,\\n                    order.swap,\\n                    order.priceAccumulator,\\n                    order.amountLimit0,\\n                    order.amountLimit1\\n                )\\n            );\\n    }\\n\\n    function verifyOrder(Data storage data, Order memory order) external view {\\n        require(getOrderDigest(order) == data.orderQueue[order.orderId], 'OS71');\\n    }\\n\\n    \\n    // constant mapping for transferGasCost\\n    /**\\n     * @dev This function should either return a default value != 0 or revert.\\n     */\\n    function getTransferGasCost(address token) internal pure returns (uint256) {\\n        if (token == NATIVE_CURRENCY_SENTINEL) return ETHER_TRANSFER_CALL_COST;\\n        if (token == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) return 70000;\\n        return 60000;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        return a / b;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (a != mul(b, c)) {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint64(uint256 n) internal pure returns (uint64) {\\n        require(n <= type(uint64).max, 'SM54');\\n        return uint64(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        c = a * b;\\n        require(c / a == b, 'SM29');\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        return a / b;\\n    }\\n\\n    function neg_floor_div(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = div(a, b);\\n        if ((a < 0 && b > 0) || (a >= 0 && b < 0)) {\\n            if (a != mul(b, c)) {\\n                c = sub(c, 1);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenShares.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './SafeMath.sol';\\nimport './TransferHelper.sol';\\n\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    uint256 private constant PRECISION = 10**18;\\n    uint256 private constant TOLERANCE = 10**18 + 10**16;\\n    uint256 private constant TOTAL_SHARES_PRECISION = 10**18;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    // represents wrapped native currency (WETH or WMATIC)\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share,\\n        uint256 amountLimit,\\n        address refundTo\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == WETH_ADDRESS || isNonRebasing(token)) {\\n            return share;\\n        }\\n\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(totalTokenShares >= share, 'TS3A');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(totalTokenShares);\\n        data.totalShares[token] = totalTokenShares.sub(share);\\n\\n        if (amountLimit > 0) {\\n            uint256 amountLimitWithTolerance = amountLimit.mul(TOLERANCE).div(PRECISION);\\n            if (value > amountLimitWithTolerance) {\\n                TransferHelper.safeTransfer(token, refundTo, value.sub(amountLimitWithTolerance));\\n                return amountLimitWithTolerance;\\n            }\\n        }\\n\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == WETH_ADDRESS) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS03');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else if (isNonRebasing(token)) {\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n\\n            return amountToSharesHelper(data, token, balanceBefore, balanceAfter);\\n        }\\n    }\\n\\n    function amountToSharesWithoutTransfer(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (token == WETH_ADDRESS) {\\n            if (wrap) {\\n                // require(msg.value >= amount, 'TS03'); // Duplicate check in TwapRelayer.sell\\n                IWETH(token).deposit{ value: amount }();\\n            }\\n            return amount;\\n        } else if (isNonRebasing(token)) {\\n            return amount;\\n        } else {\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            uint256 balanceBefore = balanceAfter.sub(amount);\\n            return amountToSharesHelper(data, token, balanceBefore, balanceAfter);\\n        }\\n    }\\n\\n    function amountToSharesHelper(\\n        Data storage data,\\n        address token,\\n        uint256 balanceBefore,\\n        uint256 balanceAfter\\n    ) internal returns (uint256) {\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\\n        require(balanceAfter > balanceBefore, 'TS2C');\\n\\n        if (balanceBefore > 0) {\\n            if (totalTokenShares == 0) {\\n                totalTokenShares = balanceBefore.mul(TOTAL_SHARES_PRECISION);\\n            }\\n            uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\\n            require(balanceAfter < type(uint256).max.div(newShares), 'TS73'); // to prevent overflow at execution\\n            data.totalShares[token] = newShares;\\n            return newShares - totalTokenShares;\\n        } else {\\n            totalTokenShares = balanceAfter.mul(TOTAL_SHARES_PRECISION);\\n            require(totalTokenShares < type(uint256).max.div(totalTokenShares), 'TS73'); // to prevent overflow at execution\\n            data.totalShares[token] = totalTokenShares;\\n            return totalTokenShares;\\n        }\\n    }\\n\\n    function onUnwrapFailed(address to, uint256 amount) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(WETH_ADDRESS).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(WETH_ADDRESS, to, amount);\\n    }\\n\\n    \\n    // constant mapping for nonRebasingToken\\n    function isNonRebasing(address token) internal pure returns (bool) {\\n        if (token == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return true;\\n        if (token == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) return true;\\n        if (token == 0xdAC17F958D2ee523a2206206994597C13D831ec7) return true;\\n        if (token == 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599) return true;\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\\n    }\\n\\n    function safeTransferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal {\\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\\n        require(success, 'TH3F');\\n    }\\n\\n    function transferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal returns (bool success) {\\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WithdrawHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './Orders.sol';\\n\\nlibrary WithdrawHelper {\\n    using SafeMath for uint256;\\n\\n    function _transferToken(\\n        uint256 balanceBefore,\\n        address token,\\n        address to\\n    ) internal {\\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\\n        TransferHelper.safeTransfer(token, to, tokenAmount);\\n    }\\n\\n    // unwraps wrapped native currency\\n    function _unwrapWeth(\\n        uint256 ethAmount,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    ) internal returns (bool) {\\n        IWETH(weth).withdraw(ethAmount);\\n        (bool success, ) = to.call{ value: ethAmount, gas: gasLimit }('');\\n        return success;\\n    }\\n\\n    function withdrawAndUnwrap(\\n        address token0,\\n        address token1,\\n        address pair,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    )\\n        external\\n        returns (\\n            bool,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        bool isToken0Weth = token0 == weth;\\n        address otherToken = isToken0Weth ? token1 : token0;\\n\\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\\n        (uint256 amount0, uint256 amount1) = ITwapPair(pair).burn(address(this));\\n        _transferToken(balanceBefore, otherToken, to);\\n\\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to, gasLimit);\\n\\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TwapDelay.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n\\nimport './interfaces/ITwapPair.sol';\\nimport './interfaces/ITwapDelay.sol';\\nimport './interfaces/IWETH.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/Orders.sol';\\nimport './libraries/TokenShares.sol';\\nimport './libraries/AddLiquidity.sol';\\nimport './libraries/WithdrawHelper.sol';\\nimport './libraries/ExecutionHelper.sol';\\nimport './interfaces/ITwapFactoryGovernor.sol';\\n\\n\\ncontract TwapDelay is ITwapDelay {\\n    using SafeMath for uint256;\\n    using Orders for Orders.Data;\\n    using TokenShares for TokenShares.Data;\\n\\n    Orders.Data internal orders;\\n    TokenShares.Data internal tokenShares;\\n\\n    uint256 private constant ORDER_CANCEL_TIME = 24 hours;\\n    uint256 private constant BOT_EXECUTION_TIME = 20 minutes;\\n\\n    address public override owner;\\n    address public override factoryGovernor;\\n    address public constant RELAYER_ADDRESS = 0xd17b3c9784510E33cD5B87b490E79253BcD81e2E; \\n    mapping(address => bool) public override isBot;\\n\\n    constructor(address _factoryGovernor, address _bot) {\\n        _setOwner(msg.sender);\\n        _setFactoryGovernor(_factoryGovernor);\\n        _setBot(_bot, true);\\n\\n        orders.gasPrice = tx.gasprice;\\n        _emitEventWithDefaults();\\n    }\\n\\n    function getTransferGasCost(address token) external pure override returns (uint256 gasCost) {\\n        return Orders.getTransferGasCost(token);\\n    }\\n\\n    function getDepositDisabled(address pair) external view override returns (bool) {\\n        return orders.getDepositDisabled(pair);\\n    }\\n\\n    function getWithdrawDisabled(address pair) external view override returns (bool) {\\n        return orders.getWithdrawDisabled(pair);\\n    }\\n\\n    function getBuyDisabled(address pair) external view override returns (bool) {\\n        return orders.getBuyDisabled(pair);\\n    }\\n\\n    function getSellDisabled(address pair) external view override returns (bool) {\\n        return orders.getSellDisabled(pair);\\n    }\\n\\n    function getOrderStatus(uint256 orderId, uint256 validAfterTimestamp)\\n        external\\n        view\\n        override\\n        returns (Orders.OrderStatus)\\n    {\\n        return orders.getOrderStatus(orderId, validAfterTimestamp);\\n    }\\n\\n    uint256 private locked;\\n    modifier lock() {\\n        require(locked == 0, 'TD06');\\n        locked = 1;\\n        _;\\n        locked = 0;\\n    }\\n\\n    function factory() external pure override returns (address) {\\n        return Orders.FACTORY_ADDRESS;\\n    }\\n\\n    function totalShares(address token) external view override returns (uint256) {\\n        return tokenShares.totalShares[token];\\n    }\\n\\n    // returns wrapped native currency for particular blockchain (WETH or WMATIC)\\n    function weth() external pure override returns (address) {\\n        return TokenShares.WETH_ADDRESS;\\n    }\\n\\n    function relayer() external pure override returns (address) {\\n        return RELAYER_ADDRESS;\\n    }\\n\\n    function isNonRebasingToken(address token) external pure override returns (bool) {\\n        return TokenShares.isNonRebasing(token);\\n    }\\n\\n    function delay() external pure override returns (uint256) {\\n        return Orders.DELAY;\\n    }\\n\\n    function lastProcessedOrderId() external view returns (uint256) {\\n        return orders.lastProcessedOrderId;\\n    }\\n\\n    function newestOrderId() external view returns (uint256) {\\n        return orders.newestOrderId;\\n    }\\n\\n    function isOrderCanceled(uint256 orderId) external view returns (bool) {\\n        return orders.canceled[orderId];\\n    }\\n\\n    function maxGasLimit() external pure override returns (uint256) {\\n        return Orders.MAX_GAS_LIMIT;\\n    }\\n\\n    function maxGasPriceImpact() external pure override returns (uint256) {\\n        return Orders.MAX_GAS_PRICE_IMPACT;\\n    }\\n\\n    function gasPriceInertia() external pure override returns (uint256) {\\n        return Orders.GAS_PRICE_INERTIA;\\n    }\\n\\n    function gasPrice() external view override returns (uint256) {\\n        return orders.gasPrice;\\n    }\\n\\n    function setOrderTypesDisabled(\\n        address pair,\\n        Orders.OrderType[] calldata orderTypes,\\n        bool disabled\\n    ) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setOrderTypesDisabled(pair, orderTypes, disabled);\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'TD00');\\n        _setOwner(_owner);\\n    }\\n\\n    function _setOwner(address _owner) internal {\\n        require(_owner != owner, 'TD01');\\n        require(_owner != address(0), 'TD02');\\n        owner = _owner;\\n        emit OwnerSet(_owner);\\n    }\\n\\n    function setFactoryGovernor(address _factoryGovernor) external override {\\n        require(msg.sender == owner, 'TD00');\\n        _setFactoryGovernor(_factoryGovernor);\\n    }\\n\\n    function _setFactoryGovernor(address _factoryGovernor) internal {\\n        require(_factoryGovernor != factoryGovernor, 'TD01');\\n        require(_factoryGovernor != address(0), 'TD02');\\n        factoryGovernor = _factoryGovernor;\\n        emit FactoryGovernorSet(_factoryGovernor);\\n    }\\n\\n    function setBot(address _bot, bool _isBot) external override {\\n        require(msg.sender == owner, 'TD00');\\n        _setBot(_bot, _isBot);\\n    }\\n\\n    function _setBot(address _bot, bool _isBot) internal {\\n        require(_isBot != isBot[_bot], 'TD01');\\n        isBot[_bot] = _isBot;\\n        emit BotSet(_bot, _isBot);\\n    }\\n\\n    function deposit(Orders.DepositParams calldata depositParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.deposit(depositParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.withdraw(withdrawParams);\\n        return orders.newestOrderId;\\n    }\\n\\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\\n        orders.sell(sellParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function relayerSell(Orders.SellParams calldata sellParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        require(msg.sender == RELAYER_ADDRESS, 'TD00');\\n        orders.relayerSell(sellParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\\n        orders.buy(buyParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    /// @dev This implementation processes orders sequentially and skips orders that have already been executed.\\n    /// If it encounters an order that is not yet valid, it stops execution since subsequent orders will also be invalid\\n    /// at the time.\\n    function execute(Orders.Order[] calldata _orders) external payable override lock {\\n        uint256 ordersLength = _orders.length;\\n        uint256 gasBefore = gasleft();\\n        bool orderExecuted;\\n        bool senderCanExecute = isBot[msg.sender] || isBot[address(0)];\\n        for (uint256 i; i < ordersLength; ++i) {\\n            if (_orders[i].orderId <= orders.lastProcessedOrderId) {\\n                continue;\\n            }\\n            if (orders.canceled[_orders[i].orderId]) {\\n                orders.dequeueOrder(_orders[i].orderId);\\n                continue;\\n            }\\n            orders.verifyOrder(_orders[i]);\\n            uint256 validAfterTimestamp = _orders[i].validAfterTimestamp;\\n            if (validAfterTimestamp >= block.timestamp) {\\n                break;\\n            }\\n            require(senderCanExecute || block.timestamp >= validAfterTimestamp + BOT_EXECUTION_TIME, 'TD00');\\n            orderExecuted = true;\\n            if (_orders[i].orderType == Orders.OrderType.Deposit) {\\n                executeDeposit(_orders[i]);\\n            } else if (_orders[i].orderType == Orders.OrderType.Withdraw) {\\n                executeWithdraw(_orders[i]);\\n            } else if (_orders[i].orderType == Orders.OrderType.Sell) {\\n                executeSell(_orders[i]);\\n            } else if (_orders[i].orderType == Orders.OrderType.Buy) {\\n                executeBuy(_orders[i]);\\n            }\\n        }\\n        if (orderExecuted) {\\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\\n        }\\n    }\\n\\n    /// @dev The `order` must be verified by calling `Orders.verifyOrder` before calling this function.\\n    function executeDeposit(Orders.Order calldata order) internal {\\n        uint256 gasStart = gasleft();\\n        orders.dequeueOrder(order.orderId);\\n\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: order.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(Orders.getTransferGasCost(order.token0)).add(\\n                    Orders.getTransferGasCost(order.token1)\\n                )\\n            )\\n        }(abi.encodeWithSelector(this._executeDeposit.selector, order));\\n\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundTokens(\\n                order.to,\\n                order.token0,\\n                order.value0,\\n                order.token1,\\n                order.value1,\\n                order.unwrap\\n            );\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(order.gasLimit, order.gasPrice, gasStart, order.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    /// @dev The `order` must be verified by calling `Orders.verifyOrder` before calling this function.\\n    function executeWithdraw(Orders.Order calldata order) internal {\\n        uint256 gasStart = gasleft();\\n        orders.dequeueOrder(order.orderId);\\n\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: order.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, order));\\n\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            (address pair, ) = Orders.getPair(order.token0, order.token1);\\n            refundSuccess = Orders.refundLiquidity(pair, order.to, order.liquidity, this._refundLiquidity.selector);\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(order.gasLimit, order.gasPrice, gasStart, order.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    /// @dev The `order` must be verified by calling `Orders.verifyOrder` before calling this function.\\n    function executeSell(Orders.Order calldata order) internal {\\n        uint256 gasStart = gasleft();\\n        orders.dequeueOrder(order.orderId);\\n\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: order.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.getTransferGasCost(order.token0)))\\n        }(abi.encodeWithSelector(this._executeSell.selector, order));\\n\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(order.token0, order.to, order.value0, order.unwrap);\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(order.gasLimit, order.gasPrice, gasStart, order.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    /// @dev The `order` must be verified by calling `Orders.verifyOrder` before calling this function.\\n    function executeBuy(Orders.Order calldata order) internal {\\n        uint256 gasStart = gasleft();\\n        orders.dequeueOrder(order.orderId);\\n\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: order.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.getTransferGasCost(order.token0)))\\n        }(abi.encodeWithSelector(this._executeBuy.selector, order));\\n\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(order.token0, order.to, order.value0, order.unwrap);\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(order.gasLimit, order.gasPrice, gasStart, order.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function finalizeOrder(bool refundSuccess) private {\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n    }\\n\\n    function refund(\\n        uint256 gasLimit,\\n        uint256 gasPriceInOrder,\\n        uint256 gasStart,\\n        address to\\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_BASE_COST);\\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\\n        leftOver = feeCollected.sub(actualRefund);\\n        require(refundEth(msg.sender, actualRefund), 'TD40');\\n        refundEth(payable(to), leftOver);\\n    }\\n\\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\\n        if (value == 0) {\\n            return true;\\n        }\\n        success = TransferHelper.transferETH(to, value, Orders.getTransferGasCost(Orders.NATIVE_CURRENCY_SENTINEL));\\n        emit EthRefund(to, success, value);\\n    }\\n\\n    function refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) private returns (bool) {\\n        if (share == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: Orders.getTransferGasCost(token) }(\\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\\n        );\\n        if (!success) {\\n            emit Orders.RefundFailed(to, token, share, data);\\n        }\\n        return success;\\n    }\\n\\n    function refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) private returns (bool) {\\n        (bool success, bytes memory data) = address(this).call{\\n            gas: Orders.getTransferGasCost(token0).add(Orders.getTransferGasCost(token1))\\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\\n        if (!success) {\\n            emit Orders.RefundFailed(to, token0, share0, data);\\n            emit Orders.RefundFailed(to, token1, share1, data);\\n        }\\n        return success;\\n    }\\n\\n    function _refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) external payable {\\n        // no need to check sender, because it is checked in _refundToken\\n        _refundToken(token0, to, share0, unwrap);\\n        _refundToken(token1, to, share1, unwrap);\\n    }\\n\\n    function _refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) public payable {\\n        require(msg.sender == address(this), 'TD00');\\n        if (token == TokenShares.WETH_ADDRESS && unwrap) {\\n            uint256 amount = tokenShares.sharesToAmount(token, share, 0, to);\\n            IWETH(TokenShares.WETH_ADDRESS).withdraw(amount);\\n            TransferHelper.safeTransferETH(to, amount, Orders.getTransferGasCost(Orders.NATIVE_CURRENCY_SENTINEL));\\n        } else {\\n            TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share, 0, to));\\n        }\\n    }\\n\\n    function _refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity\\n    ) external payable {\\n        require(msg.sender == address(this), 'TD00');\\n        return TransferHelper.safeTransfer(pair, to, liquidity);\\n    }\\n\\n    function _executeDeposit(Orders.Order calldata order) external payable {\\n        require(msg.sender == address(this), 'TD00');\\n\\n        (address pairAddress, ) = Orders.getPair(order.token0, order.token1);\\n\\n        ITwapPair(pairAddress).sync();\\n        ITwapFactoryGovernor(factoryGovernor).distributeFees(order.token0, order.token1, pairAddress);\\n        ITwapPair(pairAddress).sync();\\n        ExecutionHelper.executeDeposit(order, pairAddress, getTolerance(pairAddress), tokenShares);\\n    }\\n\\n    function _executeWithdraw(Orders.Order calldata order) external payable {\\n        require(msg.sender == address(this), 'TD00');\\n\\n        (address pairAddress, ) = Orders.getPair(order.token0, order.token1);\\n\\n        ITwapPair(pairAddress).sync();\\n        ITwapFactoryGovernor(factoryGovernor).distributeFees(order.token0, order.token1, pairAddress);\\n        ITwapPair(pairAddress).sync();\\n        ExecutionHelper.executeWithdraw(order);\\n    }\\n\\n    function _executeBuy(Orders.Order calldata order) external payable {\\n        require(msg.sender == address(this), 'TD00');\\n\\n        (address pairAddress, ) = Orders.getPair(order.token0, order.token1);\\n        ExecutionHelper.ExecuteBuySellParams memory orderParams;\\n        orderParams.order = order;\\n        orderParams.pairAddress = pairAddress;\\n        orderParams.pairTolerance = getTolerance(pairAddress);\\n\\n        ITwapPair(pairAddress).sync();\\n        ExecutionHelper.executeBuy(orderParams, tokenShares);\\n    }\\n\\n    function _executeSell(Orders.Order calldata order) external payable {\\n        require(msg.sender == address(this), 'TD00');\\n\\n        (address pairAddress, ) = Orders.getPair(order.token0, order.token1);\\n        ExecutionHelper.ExecuteBuySellParams memory orderParams;\\n        orderParams.order = order;\\n        orderParams.pairAddress = pairAddress;\\n        orderParams.pairTolerance = getTolerance(pairAddress);\\n\\n        ITwapPair(pairAddress).sync();\\n        ExecutionHelper.executeSell(orderParams, tokenShares);\\n    }\\n\\n    /// @dev The `order` must be verified by calling `Orders.verifyOrder` before calling this function.\\n    function performRefund(Orders.Order calldata order, bool shouldRefundEth) internal {\\n        bool canOwnerRefund = order.validAfterTimestamp.add(365 days) < block.timestamp;\\n\\n        if (order.orderType == Orders.OrderType.Deposit) {\\n            address to = canOwnerRefund ? owner : order.to;\\n            require(refundTokens(to, order.token0, order.value0, order.token1, order.value1, order.unwrap), 'TD14');\\n            if (shouldRefundEth) {\\n                require(refundEth(payable(to), order.gasPrice.mul(order.gasLimit)), 'TD40');\\n            }\\n        } else if (order.orderType == Orders.OrderType.Withdraw) {\\n            (address pair, ) = Orders.getPair(order.token0, order.token1);\\n            address to = canOwnerRefund ? owner : order.to;\\n            require(Orders.refundLiquidity(pair, to, order.liquidity, this._refundLiquidity.selector), 'TD14');\\n            if (shouldRefundEth) {\\n                require(refundEth(payable(to), order.gasPrice.mul(order.gasLimit)), 'TD40');\\n            }\\n        } else if (order.orderType == Orders.OrderType.Sell) {\\n            address to = canOwnerRefund ? owner : order.to;\\n            require(refundToken(order.token0, to, order.value0, order.unwrap), 'TD14');\\n            if (shouldRefundEth) {\\n                require(refundEth(payable(to), order.gasPrice.mul(order.gasLimit)), 'TD40');\\n            }\\n        } else if (order.orderType == Orders.OrderType.Buy) {\\n            address to = canOwnerRefund ? owner : order.to;\\n            require(refundToken(order.token0, to, order.value0, order.unwrap), 'TD14');\\n            if (shouldRefundEth) {\\n                require(refundEth(payable(to), order.gasPrice.mul(order.gasLimit)), 'TD40');\\n            }\\n        } else {\\n            return;\\n        }\\n        orders.forgetOrder(order.orderId);\\n    }\\n\\n    function retryRefund(Orders.Order calldata order) external override lock {\\n        orders.verifyOrder(order);\\n        require(orders.refundFailed[order.orderId], 'TD21');\\n        performRefund(order, false);\\n    }\\n\\n    function cancelOrder(Orders.Order calldata order) external override lock {\\n        orders.verifyOrder(order);\\n        require(\\n            orders.getOrderStatus(order.orderId, order.validAfterTimestamp) == Orders.OrderStatus.EnqueuedReady,\\n            'TD52'\\n        );\\n        require(order.validAfterTimestamp.sub(Orders.DELAY).add(ORDER_CANCEL_TIME) < block.timestamp, 'TD1C');\\n        orders.canceled[order.orderId] = true;\\n        performRefund(order, true);\\n    }\\n\\n    function syncPair(address token0, address token1) external override returns (address pairAddress) {\\n        require(msg.sender == factoryGovernor, 'TD00');\\n\\n        (pairAddress, ) = Orders.getPair(token0, token1);\\n        ITwapPair(pairAddress).sync();\\n    }\\n\\n    \\n    function _emitEventWithDefaults() internal {\\n        emit MaxGasLimitSet(Orders.MAX_GAS_LIMIT);\\n        emit GasPriceInertiaSet(Orders.GAS_PRICE_INERTIA);\\n        emit MaxGasPriceImpactSet(Orders.MAX_GAS_PRICE_IMPACT);\\n        emit DelaySet(Orders.DELAY);\\n        emit RelayerSet(RELAYER_ADDRESS);\\n\\n        emit ToleranceSet(0x2fe16Dd18bba26e457B7dD2080d5674312b026a2, 0);\\n        emit ToleranceSet(0x048f0e7ea2CFD522a4a058D1b1bDd574A0486c46, 0);\\n        emit ToleranceSet(0x37F6dF71b40c50b2038329CaBf5FDa3682Df1ebF, 0);\\n        emit ToleranceSet(0x6ec472b613012a492693697FA551420E60567eA7, 0);\\n        emit ToleranceSet(0x43f0E5f2304F261DfA5359a0b74Ff030E498D904, 0);\\n        emit ToleranceSet(0xD66f214fB49f81Ac5610e0339A351D7e1c67c35e, 0);\\n        emit ToleranceSet(0xD4d2140eD70DCF8794A986F0CFD07560ee738C71, 4);\\n\\n        emit TransferGasCostSet(Orders.NATIVE_CURRENCY_SENTINEL, Orders.ETHER_TRANSFER_CALL_COST);\\n        emit TransferGasCostSet(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 60000);\\n        emit TransferGasCostSet(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 70000);\\n        emit TransferGasCostSet(0xdAC17F958D2ee523a2206206994597C13D831ec7, 60000);\\n        emit TransferGasCostSet(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, 60000);\\n        emit TransferGasCostSet(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, 60000);\\n        emit TransferGasCostSet(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, 60000);\\n\\n        emit NonRebasingTokenSet(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, true);\\n        emit NonRebasingTokenSet(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, true);\\n        emit NonRebasingTokenSet(0xdAC17F958D2ee523a2206206994597C13D831ec7, true);\\n        emit NonRebasingTokenSet(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, true);\\n        emit NonRebasingTokenSet(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B, false);\\n        emit NonRebasingTokenSet(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2, false);\\n    }\\n\\n    \\n    // constant mapping for tolerance\\n    function getTolerance(address pair) public virtual view override returns (uint16 tolerance) {\\n        if (pair == 0xD4d2140eD70DCF8794A986F0CFD07560ee738C71) return 4;\\n        return 0;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/ExecutionHelper.sol\": {\r\n        \"ExecutionHelper\": \"0xeb244fb424b56ccb96d42bd1983fb0d67037b27e\"\r\n      },\r\n      \"contracts/libraries/Orders.sol\": {\r\n        \"Orders\": \"0x6b225b3797892c6582a06d17bcfe0a96f0b9087c\"\r\n      },\r\n      \"contracts/libraries/TokenShares.sol\": {\r\n        \"TokenShares\": \"0xff407b033077b5cabdef809e953cadbe4b322126\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryGovernor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBot\",\"type\":\"bool\"}],\"name\":\"BotSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"DelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EthRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factoryGovernor\",\"type\":\"address\"}],\"name\":\"FactoryGovernorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"GasPriceInertiaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"MaxGasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"MaxGasPriceImpactSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNonRebasing\",\"type\":\"bool\"}],\"name\":\"NonRebasingTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRefunded\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"ToleranceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"TransferGasCostSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RELAYER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"_executeBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"_executeDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"_executeSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"_executeWithdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"_refundLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.BuyParams\",\"name\":\"buyParams\",\"type\":\"tuple\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.DepositParams\",\"name\":\"depositParams\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order[]\",\"name\":\"_orders\",\"type\":\"tuple[]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceInertia\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getBuyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getDepositDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"enum Orders.OrderStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getSellDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getTolerance\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"tolerance\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTransferGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getWithdrawDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isNonRebasingToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"isOrderCanceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasPriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newestOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.SellParams\",\"name\":\"sellParams\",\"type\":\"tuple\"}],\"name\":\"relayerSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"inverted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validAfterTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLimit1\",\"type\":\"uint256\"}],\"internalType\":\"struct Orders.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"retryRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.SellParams\",\"name\":\"sellParams\",\"type\":\"tuple\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBot\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryGovernor\",\"type\":\"address\"}],\"name\":\"setFactoryGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"enum Orders.OrderType[]\",\"name\":\"orderTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setOrderTypesDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"syncPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.WithdrawParams\",\"name\":\"withdrawParams\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TwapDelay", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f4418d9fe76a788f2868a558dd216549ad2d869b0000000000000000000000003a1d749fa4a9e650fce844ff1c58c5faf7e2a9d1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}