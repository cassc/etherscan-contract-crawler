{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/QuestionExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { Owned } from \\\"solmate/auth/Owned.sol\\\";\\nimport { ReentrancyGuard } from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\n\\n/// @title QuestionExchange\\n/// @notice A contract allowing users to pay to have questions answered by other users\\ncontract QuestionExchange is Owned, ReentrancyGuard {\\n    /// fee percentage up to 2 decimal places (1% = 100, 0.1% = 10, 0.01% = 1)\\n    uint8 public feePercentage;\\n    address public feeReceiver;\\n\\n    struct Question {\\n        uint256 replyTo;\\n        string questionUrl;\\n        string answerUrl;\\n        address bidToken;\\n        uint256 bidAmount;\\n        uint256 expiresAt;\\n        uint256 askedAt;\\n        address asker;\\n        uint256 expiryClaimedAt;\\n        uint256 answeredAt;\\n        bool isPrivate;\\n    }\\n\\n    mapping(address => mapping(uint256 => Question)) public questions;\\n    mapping(address => uint256) public questionCounts;\\n    mapping(address => string) public profileUrls;\\n\\n    mapping(address => uint256) public lockedAmounts;\\n    /// @notice emitted when a question is asked\\n    event Asked(\\n        address indexed answerer,\\n        address indexed asker,\\n        uint256 indexed questionId\\n    );\\n\\n    /// @notice emitted when a question is answered\\n    event Answered(\\n        address indexed answerer,\\n        address indexed asker,\\n        uint256 indexed questionId\\n    );\\n\\n    /// @notice emitted when a question is expired\\n    event Expired(\\n        address indexed answerer,\\n        address indexed asker,\\n        uint256 indexed questionId\\n    );\\n\\n    /// @notice thrown when providing an empty question\\n    error EmptyQuestion();\\n\\n    /// @notice thrown when answering a question that is already answered\\n    error AlreadyAnswered();\\n\\n    /// @notice thrown when attempting to expire a question is answered or not yet expired\\n    error NotExpired();\\n\\n    /// @notice thrown when attempting to claim an expired question that is already claimed\\n    error ExpiryClaimed();\\n\\n    /// @notice thrown when answering a question that is expired\\n    error QuestionExpired();\\n\\n    /// @notice thrown when providing an empty answer\\n    error EmptyAnswer();\\n\\n    /// @notice thrown when attempting to expire a question that sender did not ask\\n    error NotAsker();\\n\\n    /// @notice thrown when attempting to send ETH to this contract via fallback method\\n    error FallbackNotPayable();\\n    \\n    /// @notice thrown when attempting to send ETH to this contract via receive method\\n    error ReceiveNotPayable();\\n\\n    constructor(uint8 _feePercentage) Owned(msg.sender) {\\n        feePercentage = _feePercentage;\\n        feeReceiver = owner;\\n    }\\n\\n    function ask(\\n        address answerer, \\n        string memory questionUrl, \\n        address bidToken, \\n        uint256 bidAmount,\\n        uint256 replyTo,\\n        uint256 expiresAt,\\n        bool isPrivate\\n    ) public nonReentrant {\\n        uint256 nextQuestionId = questionCounts[answerer];\\n        questionCounts[answerer] = nextQuestionId + 1;\\n\\n        questions[answerer][nextQuestionId] = Question({\\n            replyTo: replyTo,\\n            questionUrl: questionUrl,\\n            bidToken: bidToken,\\n            bidAmount: bidAmount,\\n            expiresAt: expiresAt,\\n            askedAt: block.timestamp,\\n            asker: msg.sender,\\n            isPrivate: isPrivate,\\n            expiryClaimedAt: 0,\\n            answeredAt: 0,\\n            answerUrl: ''\\n        });\\n\\n        emit Asked(answerer, msg.sender, nextQuestionId);\\n\\n        if(bidAmount != 0) {\\n            lockedAmounts[bidToken] += bidAmount;\\n\\n            ERC20(bidToken).transferFrom(msg.sender, address(this), bidAmount);\\n        }\\n    }\\n\\n    function expire(\\n        address answerer,\\n        uint256 questionId\\n    ) public nonReentrant {\\n        Question storage question = questions[answerer][questionId];\\n        if(question.askedAt == 0) revert EmptyQuestion();\\n        if(question.answeredAt != 0) revert AlreadyAnswered();\\n        if(question.expiresAt > block.timestamp) revert NotExpired();\\n        if(question.expiryClaimedAt != 0) revert ExpiryClaimed();\\n        if(question.asker != msg.sender) revert NotAsker();\\n\\n        question.expiryClaimedAt = block.timestamp;\\n        emit Expired(answerer, msg.sender, questionId);\\n        \\n        if(question.bidAmount != 0) {\\n            lockedAmounts[question.bidToken] -= question.bidAmount;\\n\\n            uint256 feeAmount = question.bidAmount * feePercentage / 10000; // feePercentage is normalised to 2 decimals\\n            ERC20(question.bidToken).transfer(question.asker, question.bidAmount - feeAmount);\\n            ERC20(question.bidToken).transfer(feeReceiver, feeAmount);\\n        }\\n    }\\n\\n    function answer(\\n        uint256 questionId,\\n        string memory answerUrl\\n    ) public nonReentrant {\\n        Question storage question = questions[msg.sender][questionId];\\n        if(question.askedAt == 0) revert EmptyQuestion();\\n        if(question.answeredAt != 0) revert AlreadyAnswered();\\n        if(question.expiresAt <= block.timestamp) revert QuestionExpired();\\n\\n        question.answerUrl = answerUrl;\\n        question.answeredAt = block.timestamp;\\n\\n        emit Answered(msg.sender, question.asker, questionId);\\n\\n        if(question.bidAmount != 0) {\\n            lockedAmounts[question.bidToken] -= question.bidAmount;\\n\\n            uint256 feeAmount = question.bidAmount * feePercentage / 10000; // feePercentage is normalised to 2 decimals\\n            ERC20(question.bidToken).transfer(msg.sender, question.bidAmount - feeAmount);\\n            ERC20(question.bidToken).transfer(feeReceiver, feeAmount);\\n        }\\n    }\\n\\n    function setFeePercentage(uint8 newFeePercentage) public onlyOwner {\\n        feePercentage = newFeePercentage;\\n    }\\n\\n    function setFeeReceiver(address newFeeReceiver) public onlyOwner {\\n        feeReceiver = newFeeReceiver;\\n    }\\n\\n    function setProfileUrl(string memory newProfileUrl) public {\\n        profileUrls[msg.sender] = newProfileUrl;\\n    }\\n\\n    function rescueTokens(address tokenAddress) public {\\n        uint256 totalBalance = ERC20(tokenAddress).balanceOf(address(this));\\n\\n        ERC20(tokenAddress).transfer(owner, totalBalance - lockedAmounts[tokenAddress]);\\n    }\\n\\n    /// @notice prevents ETH being sent directly to this contract\\n    fallback() external {\\n        // ETH received with no msg.data\\n        revert FallbackNotPayable();\\n    }\\n\\n    /// @notice prevents ETH being sent directly to this contract\\n    receive() external payable {\\n        // ETH received with msg.data that does not match any contract function\\n        revert ReceiveNotPayable();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_feePercentage\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyAnswered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyAnswer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyQuestion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiryClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FallbackNotPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAsker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuestionExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiveNotPayable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"Answered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"Asked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"Expired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"questionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"answerUrl\",\"type\":\"string\"}],\"name\":\"answer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"questionUrl\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"bidToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replyTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"}],\"name\":\"ask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"expire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"profileUrls\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"questionCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"questions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"replyTo\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"questionUrl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"answerUrl\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"bidToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"askedAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiryClaimedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answeredAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFeePercentage\",\"type\":\"uint8\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newProfileUrl\",\"type\":\"string\"}],\"name\":\"setProfileUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QuestionExchange", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000032", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}