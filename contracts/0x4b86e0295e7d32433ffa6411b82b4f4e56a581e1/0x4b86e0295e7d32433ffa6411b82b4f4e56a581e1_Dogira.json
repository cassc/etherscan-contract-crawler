{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Owned is Context {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier ownerOnly {\r\n        require(_owner == _msgSender(), \"Owner only\");\r\n        _;\r\n    }\r\n    modifier pendingOnly {\r\n        require (_pendingOwner == msg.sender, \"cannot claim\");\r\n        _;\r\n    }\r\n\r\n    function pendingOwner() public view returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual ownerOnly {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public ownerOnly {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function cancelTransfer() public ownerOnly {\r\n        require(_pendingOwner != address(0), \"no pending owner\");\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    function claimOwnership() public pendingOnly {\r\n        _pendingOwner = address(0);\r\n        emit OwnershipTransferred(_owner, _msgSender());\r\n        _owner = _msgSender();\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Pool {}\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\ncontract Storage {\r\n\r\n    struct Addresses {\r\n        address pool;\r\n        address router;\r\n        address pair;\r\n        address protocol;\r\n        address dogecity;\r\n        address prizePool;\r\n        address buyBonusPool;\r\n        address presale;\r\n        address rng;\r\n        address farm;\r\n    }\r\n\r\n    struct Balance {\r\n        uint256 tokenSupply;\r\n        uint256 networkSupply;\r\n        uint256 targetSupply;\r\n        uint256 pairSupply;\r\n        uint256 lpSupply;\r\n        uint256 fees;\r\n        uint256 burned;\r\n    }\r\n\r\n    struct Account {\r\n        bool feeless;\r\n        bool transferPair;\r\n        bool excluded;\r\n        uint256 lastDogeIt;\r\n        uint256 tTotal;\r\n        uint256 rTotal;\r\n        uint256 lastShill;\r\n        uint256 communityPoints;\r\n        uint256 lastAward;\r\n    }\r\n\r\n    struct Divisors {\r\n        uint8 buy;\r\n        uint8 sell;\r\n        // multiplied by 10000\r\n        uint8 dogecity;\r\n        uint8 bonus;\r\n        uint8 tokenLPBurn;\r\n        uint8 inflate;\r\n        uint8 buyCounter;\r\n        uint8 tx;\r\n        uint8 dogeitpayout;\r\n        uint256 dogeify;\r\n    }\r\n\r\n    struct S {\r\n        bool initialized;\r\n        bool paused;\r\n        uint8 decimals;\r\n        uint8 odds;\r\n        Addresses addresses;\r\n        Balance balances;\r\n        Divisors divisors;\r\n        uint256 random;\r\n        uint256 buyFee;\r\n        uint256 sellFee;\r\n        uint256 minBuyForBonus;\r\n        uint256 buys;\r\n        uint256 sells;\r\n        uint256 lastAttack;\r\n        uint256 attackCooldown;\r\n        mapping(address => Account) accounts;\r\n        mapping(address => mapping(address => uint256)) allowances;\r\n\r\n        address[] entries;\r\n        string symbol;\r\n        string name;\r\n        EnumerableSet.AddressSet excludedAccounts;\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract State {\r\n    Storage.S state;\r\n    TState lastTState;\r\n\r\n    enum TxType { FromExcluded, ToExcluded, BothExcluded, Standard }\r\n    enum TState { Buy, Sell, Normal }\r\n}\r\n\r\ncontract Getters is State {\r\n\r\n    function canIDogeIt() public view returns(bool) {\r\n        return state.accounts[msg.sender].lastDogeIt + state.divisors.dogeify < block.timestamp;\r\n    }\r\n\r\n    function isMinBuyForBonus(uint256 amount) public view returns(bool) {\r\n        return amount > state.minBuyForBonus * (10 ** state.decimals);\r\n    }\r\n\r\n    function isFeelessTx(address sender, address recipient) public view returns(bool) {\r\n        if(sender == state.addresses.presale) {\r\n            return true;\r\n        }\r\n        return state.accounts[sender].feeless || state.accounts[recipient].feeless;\r\n    }\r\n\r\n    function getAccount(address account) public view returns(Storage.Account memory) {\r\n        return state.accounts[account];\r\n    }\r\n\r\n    function getDivisors() external view returns(Storage.Divisors memory) {\r\n        return state.divisors;\r\n    }\r\n\r\n    function getBurned() external view returns(uint256) {\r\n        return state.balances.burned;\r\n    }\r\n\r\n    function getFees() external view returns(uint256) {\r\n        return state.balances.fees;\r\n    }\r\n\r\n    function getExcluded(address account) public view returns(bool) {\r\n        return state.accounts[account].excluded;\r\n    }\r\n\r\n    function getCurrentLPBal() public view returns(uint256) {\r\n        return IERC20(state.addresses.pool).totalSupply();\r\n    }\r\n\r\n    function getLPBalanceOf(address account) external view returns(uint256) {\r\n        return IERC20(state.addresses.pool).balanceOf(account);\r\n    }\r\n\r\n    function getFeeless(address account) external view returns (bool) {\r\n        return state.accounts[account].feeless;\r\n    }\r\n\r\n    function getTState(address sender, address recipient, uint256 lpAmount) public view returns(TState t) {\r\n        if(state.accounts[sender].transferPair) {\r\n            if(state.balances.lpSupply != lpAmount) { // withdraw vs buy\r\n                t = TState.Normal;\r\n            } else {\r\n                t = TState.Buy;\r\n            }\r\n        } else if(state.accounts[recipient].transferPair) {\r\n            t = TState.Sell;\r\n        } else {\r\n            t = TState.Normal;\r\n        }\r\n        return t;\r\n    }\r\n\r\n    function getRouter() external view returns(address) {\r\n        return state.addresses.router;\r\n    }\r\n\r\n    function getPair() external view returns(address) {\r\n        return state.addresses.pair;\r\n    }\r\n\r\n    function getPool() external view returns(address) {\r\n        return state.addresses.pool;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns(uint256, uint256) {\r\n        uint256 rSupply = state.balances.networkSupply;\r\n        uint256 tSupply = state.balances.tokenSupply;\r\n        for (uint256 i = 0; i < EnumerableSet.length(state.excludedAccounts); i++) {\r\n            address account = EnumerableSet.at(state.excludedAccounts, i);\r\n            uint256 rBalance = state.accounts[account].rTotal;\r\n            uint256 tBalance = state.accounts[account].tTotal;\r\n            if (rBalance > rSupply || tBalance > tSupply) return (state.balances.networkSupply, state.balances.tokenSupply);\r\n            rSupply -= rBalance;\r\n            tSupply -= tBalance;\r\n        }\r\n        if (rSupply < state.balances.networkSupply / state.balances.tokenSupply) return (state.balances.networkSupply, state.balances.tokenSupply);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function getTxType(address sender, address recipient) public view returns(TxType t) {\r\n        bool isSenderExcluded = state.accounts[sender].excluded;\r\n        bool isRecipientExcluded = state.accounts[recipient].excluded;\r\n        if (isSenderExcluded && !isRecipientExcluded) {\r\n            t = TxType.FromExcluded;\r\n        } else if (!isSenderExcluded && isRecipientExcluded) {\r\n            t = TxType.ToExcluded;\r\n        } else if (!isSenderExcluded && !isRecipientExcluded) {\r\n            t = TxType.Standard;\r\n        } else if (isSenderExcluded && isRecipientExcluded) {\r\n            t = TxType.BothExcluded;\r\n        } else {\r\n            t = TxType.Standard;\r\n        }\r\n    }\r\n\r\n    function getFee(uint256 amount, uint256 divisor) public pure returns (uint256) {\r\n        return amount / divisor;\r\n    }\r\n\r\n    function getPrizePoolAddress() public view returns(address) {\r\n        return state.addresses.prizePool;\r\n    }\r\n\r\n    function getPrizePoolAmount() public view returns(uint256) {\r\n        return state.accounts[getPrizePoolAddress()].rTotal / ratio();\r\n    }\r\n\r\n    function getBuyPoolAmount() public view returns(uint256) {\r\n        return state.accounts[getBuyBonusPoolAddress()].rTotal / ratio();\r\n    }\r\n\r\n    function getBuyBonusPoolAddress() public view returns(address) {\r\n        return state.addresses.buyBonusPool;\r\n    }\r\n\r\n    function getAmountForMinBuyTax() public view returns(uint256) {\r\n        return (state.balances.tokenSupply / 100);\r\n    }\r\n\r\n    function getBuyTax(uint256 amount) public view returns(uint256) {\r\n        uint256 _ratio = amount * 100000 / state.balances.tokenSupply;\r\n        if(_ratio < 1) { // .001%\r\n            return state.divisors.buy; // charges whatever max buy fee is at, to discourage gaming the prizepool.\r\n        } else if (_ratio >= 1000) { // 1%\r\n            return state.divisors.buy * 5; // charges 1/5th of buy fee, from default is 1%\r\n        } else if (_ratio >= 10 && _ratio < 100){\r\n            return state.divisors.buy * 2; // and so on.\r\n        } else if (_ratio >= 100 && _ratio < 500) {\r\n            return state.divisors.buy * 3;\r\n        } else if (_ratio >= 500 && _ratio < 1000) {\r\n            return state.divisors.buy * 4;\r\n        } else { // shouldn't hit this\r\n            return state.divisors.buy;\r\n        }\r\n    }\r\n\r\n    function getTimeTillNextAttack() public view returns(uint256) {\r\n        uint256 time = (state.lastAttack + state.attackCooldown);\r\n        return block.timestamp > time ? block.timestamp - time : 0;\r\n    }\r\n\r\n    function getMaxBetAmount() public view returns(uint256) {\r\n        return state.accounts[state.addresses.buyBonusPool].tTotal / state.divisors.dogeitpayout;\r\n    }\r\n\r\n    function getLastTState() public view returns(TState) {\r\n        return lastTState;\r\n    }\r\n\r\n    function getLevel(address account) public view returns(uint256 level) {\r\n        level = state.accounts[account].communityPoints % 1000;\r\n        return level == 0 ? 1 : level;\r\n    }\r\n\r\n    function getXP(address account) public view returns(uint256) {\r\n        return state.accounts[account].communityPoints;\r\n    }\r\n\r\n    function getBuyAfterSellBonus(uint256 amount) public view returns(uint256 bonus) {\r\n        uint256 total = state.accounts[state.addresses.buyBonusPool].tTotal;\r\n        if(amount >= total / 100) { // 1% of the pool\r\n            bonus = total / state.divisors.bonus;\r\n        } else if(amount >= total / 200) { // .5% of the pool\r\n            bonus = total / (state.divisors.bonus * 2);\r\n        } else if(amount >= total / 500) {\r\n            bonus = total / (state.divisors.bonus * 3);\r\n        } else if(amount >= total / 1000) {\r\n            bonus = total / (state.divisors.bonus * 4);\r\n        } else {\r\n            bonus = total / (state.divisors.bonus * 5);\r\n        }\r\n    }\r\n\r\n    function getBuyAfterBuyBonus() public view returns(uint256 bonus) {\r\n        bonus = state.accounts[state.addresses.buyBonusPool].tTotal / 500;\r\n    }\r\n\r\n    function getBuyBonus(uint256 amount) public view returns(uint256) {\r\n        uint256 bonus;\r\n        if(lastTState == TState.Sell && amount > state.minBuyForBonus) {\r\n            bonus = getBuyAfterSellBonus(amount);\r\n        } else if(lastTState == TState.Buy && amount > state.minBuyForBonus) {\r\n            bonus = getBuyAfterBuyBonus();\r\n        } else {\r\n            bonus = 0;\r\n        }\r\n        return bonus > state.accounts[state.addresses.buyBonusPool].tTotal ? 0 : bonus;\r\n    }\r\n\r\n    function ratio() public view returns(uint256) {\r\n        return state.balances.networkSupply / state.balances.tokenSupply;\r\n    }\r\n\r\n}\r\n\r\ninterface IDogira {\r\n    function setRandomSeed(uint256 amount) external;\r\n}\r\n\r\ncontract Dogira is IDogira, IERC20, Getters, Owned {\r\n\r\n    struct TxValue {\r\n        uint256 amount;\r\n        uint256 transferAmount;\r\n        uint256 fee;\r\n        uint256 buyFee;\r\n        uint256 sellFee;\r\n        uint256 buyBonus;\r\n        uint256 operationalFee;\r\n    }\r\n    event BonusAwarded(address account, uint256 amount);\r\n    event Kek(address account, uint256 amount);\r\n    event Doge(address account, uint256 amount);\r\n    event Winner(address account, uint256 amount);\r\n    event Smashed(uint256 amount);\r\n    event Atomacized(uint256 amount);\r\n    event Blazed(uint256 amount);\r\n    mapping(address => bool) admins;\r\n\r\n    event FarmAdded(address farm);\r\n    event XPAdded(address awardee, uint256 points);\r\n    event Hooray(address awardee, uint256 points);\r\n    event TransferredToFarm(uint256 amount);\r\n\r\n    uint256 timeLock;\r\n    uint256 dogeCityInitial;\r\n    uint256 public lastTeamSell;\r\n    uint256 levelCap;\r\n    bool rngSet;\r\n    bool presaleSet;\r\n\r\n    modifier onlyAdminOrOwner {\r\n        require(admins[msg.sender] || msg.sender == owner(), \"invalid caller\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        initialize();\r\n    }\r\n\r\n    uint256 constant private TOKEN_SUPPLY = 100_000_000;\r\n\r\n    function name() public view returns(string memory) {\r\n        return state.name;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return state.decimals;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return state.symbol;\r\n    }\r\n\r\n    function initialize() public {\r\n        require(!state.initialized, \"Contract instance has already been initialized\");\r\n        state.initialized = true;\r\n        state.decimals = 18;\r\n        state.symbol = \"DOGIRA\";\r\n        state.name = \"dogira.lol || dogira.eth.link\";\r\n        state.balances.tokenSupply = TOKEN_SUPPLY * (10 ** state.decimals);\r\n        state.balances.networkSupply = (~uint256(0) - (~uint256(0) % TOKEN_SUPPLY));\r\n        state.divisors.buy = 20; // 5% max - 1% depending on buy size.\r\n        state.divisors.sell = 20; // 5%\r\n        state.divisors.bonus = 50;\r\n        state.divisors.dogecity = 100;\r\n        state.divisors.inflate = 50;\r\n        state.divisors.tokenLPBurn = 50;\r\n        state.divisors.tx = 100;\r\n        state.divisors.dogeitpayout = 100;\r\n        state.divisors.dogeify = 1 hours; // 3600 seconds\r\n        state.divisors.buyCounter = 10;\r\n        state.odds = 4; // 1 / 4\r\n        state.minBuyForBonus = 35000e18;\r\n        state.addresses.prizePool = address(new Pool());\r\n        state.addresses.buyBonusPool = address(new Pool());\r\n        state.addresses.router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        state.addresses.dogecity = address(0xfEDD9544b47a6D4A1967D385575866BD6f7A2b37);\r\n        state.addresses.pair = IUniswapV2Router02(state.addresses.router).WETH();\r\n        state.addresses.pool =\r\n            IUniswapV2Factory(IUniswapV2Router02(state.addresses.router).factory()).createPair(address(this), state.addresses.pair);\r\n        state.accounts[address(0)].feeless = true;\r\n        state.accounts[msg.sender].feeless = true;\r\n        //state.accounts[state.addresses.pool].feeless = true;\r\n        state.accounts[state.addresses.pool].transferPair = true;\r\n        uint256 locked = state.balances.networkSupply / 5; // 20%\r\n        uint256 amount = state.balances.networkSupply - locked;\r\n        state.accounts[msg.sender].rTotal = amount; // 80%\r\n        dogeCityInitial = locked - (locked / 4);\r\n        state.accounts[state.addresses.dogecity].feeless = true;\r\n        state.accounts[state.addresses.dogecity].rTotal = dogeCityInitial; // 15%\r\n        state.accounts[state.addresses.buyBonusPool].rTotal = locked / 4; // 5%\r\n        state.accounts[state.addresses.buyBonusPool].tTotal = state.balances.tokenSupply / 20; // 5%\r\n        state.paused = true;\r\n        state.attackCooldown = 10 minutes;\r\n        levelCap = 10;\r\n        timeLock = block.timestamp + 3 days;\r\n\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return state.allowances[owner][spender];\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return getExcluded(account) ? state.accounts[account].tTotal : state.accounts[account].rTotal / ratio();\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        state.allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, state.allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, state.allowances[_msgSender()][spender] - (subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return state.balances.tokenSupply;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), state.allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal returns(bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if(sender == state.addresses.pool) { // for presales\r\n            require(state.paused == false, \"Transfers are paused\");\r\n        }\r\n        // removed setter for dogecity to prevent changing the address and making this branch useless.\r\n        if(sender == state.addresses.dogecity) {\r\n            require(amount <= dogeCityInitial / 20, \"too much\"); // 5% per day\r\n            require(lastTeamSell + 1 days < block.timestamp, \"too soon\");\r\n            require(recipient == state.addresses.pool, \"can only sell to uniswap pool\");\r\n            lastTeamSell = block.timestamp;\r\n        }\r\n        bool noFee = isFeelessTx(sender, recipient);\r\n        uint256 rate = ratio();\r\n        uint256 lpAmount = getCurrentLPBal();\r\n        (TxValue memory t, TState ts, TxType txType) = tValues(sender, recipient, amount, noFee, lpAmount);\r\n        state.balances.lpSupply = lpAmount;\r\n        handleTRV(recipient, rate, ts, t);\r\n        rTransfer(sender, recipient, rate, t, txType);\r\n        state.balances.fees += t.fee;\r\n        state.balances.networkSupply -= (t.fee * rate);\r\n        lastTState = ts;\r\n        emit Transfer(msg.sender, recipient, t.transferAmount);\r\n        return true;\r\n    }\r\n\r\n    function transferToFarm(uint256 amount) external ownerOnly {\r\n        require(timeLock < block.timestamp, \"too soon\");\r\n        uint256 r = amount * ratio();\r\n        state.accounts[state.addresses.dogecity].rTotal -= r;\r\n        state.accounts[state.addresses.farm].rTotal += r;\r\n        emit TransferredToFarm(amount);\r\n    }\r\n\r\n    function rTransfer(address sender, address recipient, uint256 rate, TxValue memory t, TxType txType) internal {\r\n        if (txType == TxType.ToExcluded) {\r\n            state.accounts[sender].rTotal         -= t.amount * rate;\r\n            state.accounts[recipient].tTotal      += (t.transferAmount);\r\n            state.accounts[recipient].rTotal      += t.transferAmount * rate;\r\n        } else if (txType == TxType.FromExcluded) {\r\n            state.accounts[sender].tTotal         -= t.amount;\r\n            state.accounts[sender].rTotal         -= t.amount * rate;\r\n            state.accounts[recipient].rTotal      += t.transferAmount * rate;\r\n        } else if (txType == TxType.BothExcluded) {\r\n            state.accounts[sender].tTotal         -= t.amount;\r\n            state.accounts[sender].rTotal         -= (t.amount * rate);\r\n            state.accounts[recipient].tTotal      += t.transferAmount;\r\n            state.accounts[recipient].rTotal      += (t.transferAmount * rate);\r\n        } else {\r\n            state.accounts[sender].rTotal         -= (t.amount * rate);\r\n            state.accounts[recipient].rTotal      += (t.transferAmount * rate);\r\n        }\r\n    }\r\n\r\n    // burn supply, not negative rebase\r\n    function verysmashed() external  {\r\n        require(!state.paused, \"still paused\");\r\n        require(state.lastAttack + state.attackCooldown < block.timestamp, \"Dogira coolingdown\");\r\n        uint256 rLp = state.accounts[state.addresses.pool].rTotal;\r\n        uint256 amountToDeflate = (rLp / (state.divisors.tokenLPBurn));\r\n        uint256 burned = amountToDeflate / ratio();\r\n        state.accounts[state.addresses.pool].rTotal -= amountToDeflate;\r\n        state.accounts[address(0)].rTotal += amountToDeflate;\r\n        state.accounts[address(0)].tTotal += burned;\r\n        state.balances.burned += burned;\r\n        state.lastAttack = block.timestamp;\r\n        syncPool();\r\n        emit Smashed(burned);\r\n    }\r\n\r\n    // positive rebase\r\n    function dogebreath() external {\r\n        require(!state.paused, \"still paused\");\r\n        require(state.lastAttack + state.attackCooldown < block.timestamp, \"Dogira coolingdown\");\r\n        uint256 rate = ratio();\r\n        uint256 target = state.balances.burned == 0 ? state.balances.tokenSupply : state.balances.burned;\r\n        uint256 amountToInflate = target / state.divisors.inflate;\r\n        if(state.balances.burned > amountToInflate) {\r\n            state.balances.burned -= amountToInflate;\r\n            state.accounts[address(0)].rTotal -= amountToInflate * rate;\r\n            state.accounts[address(0)].tTotal -= amountToInflate;\r\n        }\r\n        // positive rebase\r\n        state.balances.networkSupply -= amountToInflate * rate;\r\n        state.lastAttack = block.timestamp;\r\n        syncPool();\r\n        emit Atomacized(amountToInflate);\r\n    }\r\n\r\n    // disperse amount to all holders\r\n    function wow(uint256 amount) external {\r\n        address sender = msg.sender;\r\n        uint256 rate = ratio();\r\n        require(!getExcluded(sender), \"Excluded addresses can't call this function\");\r\n        require(amount * rate < state.accounts[sender].rTotal, \"too much\");\r\n        state.accounts[sender].rTotal -= (amount * rate);\r\n        state.balances.networkSupply -= amount * rate;\r\n        state.balances.fees += amount;\r\n    }\r\n\r\n    // award community members from the treasury\r\n    function muchSupport(address awardee, uint256 multiplier) external onlyAdminOrOwner {\r\n        uint256 n = block.timestamp;\r\n        require(!state.paused, \"still paused\");\r\n        require(state.accounts[awardee].lastShill + 1 days < n, \"nice shill but need to wait\");\r\n        require(!getExcluded(awardee), \"excluded addresses can't be awarded\");\r\n        require(multiplier <= 100 && multiplier > 0, \"can't be more than .1% of dogecity reward\");\r\n        uint256 level = getLevel(awardee);\r\n        if(level > levelCap) {\r\n            level = levelCap; // capped at 10\r\n        } else if (level <= 0) {\r\n            level = 1;\r\n        }\r\n        uint256 p = ((state.accounts[state.addresses.dogecity].rTotal / 100000) * multiplier) * level; // .001% * m of dogecity * level\r\n        state.accounts[state.addresses.dogecity].rTotal -= p;\r\n        state.accounts[awardee].rTotal += p;\r\n        state.accounts[awardee].lastShill = block.timestamp;\r\n        state.accounts[awardee].communityPoints += multiplier;\r\n        emit Hooray(awardee, p);\r\n    }\r\n\r\n\r\n    function yayCommunity(address awardee, uint256 points) external onlyAdminOrOwner {\r\n        uint256 n = block.timestamp;\r\n        require(!state.paused, \"still paused\");\r\n        require(state.accounts[awardee].lastAward + 1 days < n, \"nice help but need to wait\");\r\n        require(!getExcluded(awardee), \"excluded addresses can't be awarded\");\r\n        require(points <= 1000 && points > 0, \"can't be more than a full level\");\r\n        state.accounts[awardee].communityPoints += points;\r\n        state.accounts[awardee].lastAward = block.timestamp;\r\n        emit XPAdded(awardee, points);\r\n    }\r\n\r\n    // burn amount, for cex integration?\r\n    function suchburn(uint256 amount) external {\r\n        address sender = msg.sender;\r\n        uint256 rate = ratio();\r\n        require(!getExcluded(sender), \"Excluded addresses can't call this function\");\r\n        require(amount * rate < state.accounts[sender].rTotal, \"too much\");\r\n        state.accounts[sender].rTotal -= (amount * rate);\r\n        state.accounts[address(0)].rTotal += (amount * rate);\r\n        state.accounts[address(0)].tTotal += (amount);\r\n        state.balances.burned += amount;\r\n        syncPool();\r\n        emit Blazed(amount);\r\n    }\r\n\r\n    function dogeit(uint256 amount) external {\r\n        require(!state.paused, \"still paused\");\r\n        require(!getExcluded(msg.sender), \"excluded can't call\");\r\n        uint256 rAmount = amount * ratio();\r\n        require(state.accounts[msg.sender].lastDogeIt + state.divisors.dogeify < block.timestamp, \"you need to wait to doge\");\r\n        require(amount > 0, \"don't waste your gas\");\r\n        require(rAmount <= state.accounts[state.addresses.buyBonusPool].rTotal / state.divisors.dogeitpayout, \"can't kek too much\");\r\n        state.accounts[msg.sender].lastDogeIt = block.timestamp;\r\n        if((state.random + block.timestamp + block.number) % state.odds == 0) {\r\n            state.accounts[state.addresses.buyBonusPool].rTotal -= rAmount;\r\n            state.accounts[msg.sender].rTotal += rAmount;\r\n            emit Doge(msg.sender, amount);\r\n        } else {\r\n            state.accounts[msg.sender].rTotal -= rAmount;\r\n            state.accounts[state.addresses.buyBonusPool].rTotal += rAmount;\r\n            emit Kek(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function handleTRV(address recipient, uint256 rate, TState ts, TxValue memory t) internal {\r\n        state.accounts[state.addresses.dogecity].rTotal += (t.operationalFee * rate);\r\n        if(ts == TState.Sell) {\r\n            state.accounts[state.addresses.buyBonusPool].rTotal += t.sellFee * rate;\r\n            state.accounts[state.addresses.buyBonusPool].tTotal += t.sellFee;\r\n        }\r\n        if(ts == TState.Buy) {\r\n            state.buys++;\r\n            uint256 br = t.buyFee * rate;\r\n            if(state.buys % state.divisors.buyCounter == 0) {\r\n                uint256 a = state.accounts[state.addresses.prizePool].rTotal + (br);\r\n                state.accounts[state.addresses.prizePool].rTotal = 0;\r\n                state.accounts[state.addresses.prizePool].tTotal = 0;\r\n                state.accounts[recipient].rTotal += a;\r\n                emit Winner(recipient, a);\r\n            } else {\r\n                state.accounts[state.addresses.prizePool].rTotal += br;\r\n                state.accounts[state.addresses.prizePool].tTotal += t.buyFee;\r\n            }\r\n            uint256 r = t.buyBonus * rate;\r\n            state.accounts[state.addresses.buyBonusPool].rTotal -= r;\r\n            state.accounts[state.addresses.buyBonusPool].tTotal -= t.buyBonus;\r\n            state.accounts[recipient].rTotal += r;\r\n            emit BonusAwarded(recipient, t.buyBonus);\r\n        }\r\n    }\r\n\r\n    function tValues(address sender, address recipient, uint256 amount, bool noFee, uint256 lpAmount) public view returns (TxValue memory t, TState ts, TxType txType) {\r\n        ts = getTState(sender, recipient, lpAmount);\r\n        txType = getTxType(sender, recipient);\r\n        t.amount = amount;\r\n        if(!noFee) {\r\n            t.fee = getFee(amount, state.divisors.tx);\r\n            t.operationalFee = getFee(amount, state.divisors.dogecity);\r\n            if(ts == TState.Sell) {\r\n                uint256 sellFee = getFee(amount, state.divisors.sell);\r\n                uint256 sellLevel = sellFee == 0 ? 0 : ((sellFee * getLevel(sender)) / levelCap);\r\n                t.sellFee = sellFee - sellLevel;\r\n            }\r\n            if(ts == TState.Buy) {\r\n                t.buyFee = getFee(amount, getBuyTax(amount));\r\n                uint256 bonus = getBuyBonus(amount);\r\n                uint256 levelBonus = bonus == 0 ? 0 : ((bonus * getLevel(recipient)) / levelCap);\r\n                t.buyBonus = bonus + levelBonus;\r\n            }\r\n        }\r\n        t.transferAmount = t.amount - t.fee - t.sellFee - t.buyFee - t.operationalFee;\r\n        return (t, ts, txType);\r\n    }\r\n\r\n    function include(address account) external ownerOnly {\r\n        require(state.accounts[account].excluded, \"Account is already excluded\");\r\n        state.accounts[account].tTotal = 0;\r\n        EnumerableSet.remove(state.excludedAccounts, account);\r\n    }\r\n\r\n    function exclude(address account) external ownerOnly {\r\n        require(!state.accounts[account].excluded, \"Account is already excluded\");\r\n        state.accounts[account].excluded = true;\r\n        if(state.accounts[account].rTotal > 0) {\r\n            state.accounts[account].tTotal = state.accounts[account].rTotal / ratio();\r\n        }\r\n        state.accounts[account].excluded = true;\r\n        EnumerableSet.add(state.excludedAccounts, account);\r\n    }\r\n\r\n    function syncPool() public  {\r\n        IUniswapV2Pair(state.addresses.pool).sync();\r\n    }\r\n\r\n    function enableTrading() external ownerOnly {\r\n        state.paused = false;\r\n    }\r\n\r\n    function adjustOdds(uint8 odds) external ownerOnly {\r\n        require(odds >= 2, \"can't be more than 50/50\");\r\n        state.odds = odds;\r\n    }\r\n\r\n    function setPresale(address account) external ownerOnly {\r\n        if(!presaleSet) {\r\n            state.addresses.presale = account;\r\n            state.accounts[account].feeless = true;\r\n            presaleSet = true;\r\n        }\r\n    }\r\n\r\n    function setBuyBonusDivisor(uint8 fd) external ownerOnly {\r\n        require(fd >= 20, \"can't be more than 5%\");\r\n        state.divisors.bonus = fd;\r\n    }\r\n\r\n    function setMinBuyForBuyBonus(uint256 amount) external ownerOnly {\r\n        require(amount > 10000e18, \"can't be less than 10k tokens\");\r\n        state.minBuyForBonus = amount * (10 ** state.decimals); \r\n    }\r\n\r\n    function setFeeless(address account, bool value) external ownerOnly {\r\n        state.accounts[account].feeless = value;\r\n    }\r\n\r\n    function setBuyFee(uint8 fd) external ownerOnly {\r\n        require(fd >= 20, \"can't be more than 5%\");\r\n        state.divisors.buy = fd;\r\n    }\r\n\r\n    function setSellFee(uint8 fd) external ownerOnly {\r\n        require(fd >= 10, \"can't be more than 10%\");\r\n        state.divisors.sell = fd;\r\n    }\r\n\r\n    function setFarm(address farm) external ownerOnly {\r\n        require(state.addresses.farm == address(0), \"farm already set\");\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(farm)}\r\n        require(_codeLength > 0, \"must be a contract\");\r\n        state.addresses.farm = farm;\r\n        emit FarmAdded(farm);\r\n    }\r\n\r\n    function setRandomSeed(uint256 random) override external {\r\n        if(!rngSet){\r\n            require(msg.sender == owner(), \"not valid caller\"); // once chainlink is set random can't be called by owner\r\n        } else {\r\n            require(msg.sender == state.addresses.rng, \"not valid caller\"); // for chainlink VRF\r\n        }\r\n        require(state.random != random, \"can't use the same one twice\");\r\n        state.random = random;\r\n    }\r\n\r\n    function setRngAddr(address addr) external ownerOnly {\r\n        state.addresses.rng = addr;\r\n        rngSet = true;\r\n    }\r\n\r\n    function setLevelCap(uint256 l) external ownerOnly {\r\n        require(l >= 10 && l <= 100, \"can't be lower than 10 or greater than 100\");\r\n        levelCap = l;\r\n    }\r\n\r\n    function setCooldown(uint256 timeInSeconds) external ownerOnly {\r\n        require(timeInSeconds > 1 minutes, \"too short a time\");\r\n        state.attackCooldown = timeInSeconds;\r\n    }\r\n\r\n    function setBuyCounter(uint8 counter) external ownerOnly {\r\n        require(counter > 5, \"too few people\");\r\n        state.divisors.buyCounter = counter;\r\n    }\r\n\r\n    function setDogeItCooldown(uint256 time) external ownerOnly {\r\n        require(time > 5 minutes, \"too quick\");\r\n        state.divisors.dogeify = time;\r\n    }\r\n\r\n    function setTokenLPBurn(uint8 fd) external ownerOnly {\r\n        require(fd > 20, \"can't be more than 5%\");\r\n        state.divisors.tokenLPBurn = fd;\r\n    }\r\n\r\n    function setInflation(uint8 fd) external ownerOnly {\r\n        require(fd > 20, \"can't be more than 5%\");\r\n        state.divisors.inflate = fd;\r\n    }\r\n\r\n    function setDogeItPayoutLimit(uint8 fd) external ownerOnly {\r\n        require(fd >= 50, \"can't be more than 2% of the buy bonus supply\");\r\n        state.divisors.dogeitpayout = fd;\r\n    }\r\n\r\n    function setAdmin(address account, bool value) external ownerOnly {\r\n        admins[account] = value;\r\n    }\r\n\r\n    function setDogeCityDivisor(uint8 fd) external ownerOnly {\r\n        require(fd >= 50, \"can't be more than 2%\");\r\n        state.divisors.dogecity = fd;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Atomacized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Blazed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BonusAwarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Doge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"FarmAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"awardee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"Hooray\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Kek\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Smashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferredToFarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"awardee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"XPAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"odds\",\"type\":\"uint8\"}],\"name\":\"adjustOdds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canIDogeIt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dogebreath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"dogeit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"exclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"feeless\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferPair\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastDogeIt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastShill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"communityPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAward\",\"type\":\"uint256\"}],\"internalType\":\"struct Storage.Account\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmountForMinBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyAfterBuyBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyAfterSellBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyBonusPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentLPBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDivisors\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"buy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dogecity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bonus\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenLPBurn\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"inflate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"buyCounter\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tx\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dogeitpayout\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dogeify\",\"type\":\"uint256\"}],\"internalType\":\"struct Storage.Divisors\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFeeless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLPBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastTState\",\"outputs\":[{\"internalType\":\"enum State.TState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizePoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizePoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"getTState\",\"outputs\":[{\"internalType\":\"enum State.TState\",\"name\":\"t\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeTillNextAttack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getTxType\",\"outputs\":[{\"internalType\":\"enum State.TxType\",\"name\":\"t\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getXP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"include\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"isFeelessTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isMinBuyForBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTeamSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"awardee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"muchSupport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setBuyBonusDivisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"counter\",\"type\":\"uint8\"}],\"name\":\"setBuyCounter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeInSeconds\",\"type\":\"uint256\"}],\"name\":\"setCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setDogeCityDivisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setDogeItCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setDogeItPayoutLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"setFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setFeeless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setInflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"l\",\"type\":\"uint256\"}],\"name\":\"setLevelCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinBuyForBuyBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"random\",\"type\":\"uint256\"}],\"name\":\"setRandomSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRngAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fd\",\"type\":\"uint8\"}],\"name\":\"setTokenLPBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"suchburn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"noFee\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"tValues\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operationalFee\",\"type\":\"uint256\"}],\"internalType\":\"struct Dogira.TxValue\",\"name\":\"t\",\"type\":\"tuple\"},{\"internalType\":\"enum State.TState\",\"name\":\"ts\",\"type\":\"uint8\"},{\"internalType\":\"enum State.TxType\",\"name\":\"txType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verysmashed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"awardee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"yayCommunity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Dogira", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "420", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}