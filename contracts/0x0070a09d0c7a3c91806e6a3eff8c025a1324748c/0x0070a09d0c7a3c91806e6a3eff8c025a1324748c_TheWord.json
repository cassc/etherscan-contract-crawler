{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TheWord.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./Verifier.sol\\\";\\n\\n/* Reference Poseidon hasher library contract using 6 inputs */\\nlibrary Poseidon {\\n    function poseidon(uint256[6] memory) public pure returns (uint256) {}\\n}\\n\\ncontract TheWord {\\n    /// STRUCTS ///\\n    struct Round {\\n        uint256 commitment; // the hash of the secret phrase\\n        uint256 prize; // the value of locked up ether to burn when when round is over\\n        string shoutedBy; // the address of the user who shouted the secret phrase\\n        bool active; // true if round can be shouted, false if over or doesn't exist\\n    }\\n\\n    // Standard Groth16 proof elements\\n    struct Groth16Proof {\\n        uint256[2] a;\\n        uint256[2][2] b;\\n        uint256[2] c;\\n    }\\n\\n    /// VARIABLES ///\\n\\n    // Circom R1CS Verifier contract\\n    Groth16Verifier verifier;\\n\\n    // Address to burn ether to\\n    address payable public burnLocation = payable(0x00);\\n\\n    // index of rounds\\n    uint256 public round;\\n\\n    // map round index to round storage\\n    mapping(uint256 => Round) public rounds;\\n\\n    /// EVENTS ///\\n    event NewRound(\\n        uint256 round,\\n        uint256 commitment,\\n        string username,\\n        uint256 prize\\n    );\\n    event Shouted(uint256 round, string shoutedBy);\\n    event PrizeAdded(uint256 round, uint256 added);\\n\\n    /// MODIFIERS ///\\n\\n    /**\\n     * Prevent function from being called if given index does not point to active round\\n     * @param _round - the round index to check for activity status\\n     */\\n    modifier active(uint256 _round) {\\n        require(rounds[_round].active, \\\"Round is not active\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Constructs new TheWord contract\\n     * @param _verifier - the address of the deployed circom r1cs verifier for the word proofs\\n     */\\n    constructor(address _verifier) {\\n        verifier = Groth16Verifier(_verifier);\\n    }\\n\\n    /// EXTERNAL FUNCTIONS ///\\n\\n    /**\\n     * Create a new round, optionally funding a prize for shouting\\n     * @dev cannot guarantee the secret phrase is within length requirement (could solve in circuit)\\n     *\\n     * @param _commitment - the hash of the secret phrase for which knowledge must be proven\\n     * @param _username - the username of the user proving their knowledge of the secret phrase\\n     * @param _proof - the groth16 proof that demonstrates the creator knows the secret phrase\\n     */\\n    function newRound(\\n        uint256 _commitment,\\n        string memory _username,\\n        Groth16Proof calldata _proof\\n    ) external payable {\\n        // convert username to uint256\\n        uint256 username = stringToUint(_username);\\n\\n        // check that the proof is valid\\n        require(\\n            verifier.verifyProof(\\n                _proof.a,\\n                _proof.b,\\n                _proof.c,\\n                [_commitment, username]\\n            ),\\n            \\\"Invalid proof\\\"\\n        );\\n\\n        // create a new round\\n        round++;\\n        rounds[round].commitment = _commitment;\\n        rounds[round].prize = msg.value;\\n        rounds[round].active = true;\\n\\n        // emit event announcing new round\\n        emit NewRound(round, _commitment, _username, msg.value);\\n    }\\n\\n    /**\\n     * End a round by shouting the secret phrase\\n     * @dev todo: maybe ecrecover a signature on secret for shoutedBy\\n     *\\n     * @param _round - the round index\\n     * @param _secret - the secret phrase that hashes to the round commitment\\n     * @param _username - the username of the user proving their knowledge of the secret phrase\\n     */\\n    function shout(\\n        uint256 _round,\\n        string calldata _secret,\\n        string memory _username\\n    ) external active(_round) {\\n        // convert the secret phrase to field elements\\n        uint256[6] memory felts = secretToFelts(_secret);\\n\\n        // compute the hash of the phrase\\n        uint256 hash = hashPhrase(felts);\\n\\n        // compare the hash to the commitment\\n        require(hash == rounds[_round].commitment, \\\"Invalid secret phrase\\\");\\n\\n        // burn ether if prize exists for round and mark round as inactive\\n        endRound(_round, _username);\\n\\n        // emit event announcing round end\\n        emit Shouted(_round, _username);\\n    }\\n\\n    /**\\n     * Adds a prize to a round that has already been created\\n     * @param _round - the round to add a prize to\\n     */\\n    function fundPrize(uint256 _round) external payable active(_round) {\\n        rounds[_round].prize += msg.value;\\n        emit PrizeAdded(_round, msg.value);\\n    }\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n    /**\\n     * Send ether from the contract to the burn address, and mark as inactive\\n     * @dev this function is only ever called by shout which provides the `active` modifier check\\n     *\\n     * @param _round - the round to burn ether from\\n     * @param _shoutedBy - the username of the user who shouted the secret phrase\\n     */\\n    function endRound(uint256 _round, string memory _shoutedBy) internal {\\n        rounds[_round].active = false;\\n        rounds[_round].shoutedBy = _shoutedBy;\\n        if (rounds[_round].prize > 0) {\\n            burnLocation.transfer(rounds[_round].prize);\\n        }\\n    }\\n\\n    /// VIEW/ PURE FUNCTIONS ///\\n\\n    /**\\n     * Converts a secret phrase as utf8 bytes into 6 serialized bn254 field elements\\n     *\\n     * @param _secret - the secret phrase, utf8 encoded, to convert to field elements\\n     * @return felts - the 6 field elements representing the secret phrase\\n     */\\n    function secretToFelts(\\n        string calldata _secret\\n    ) public pure returns (uint256[6] memory felts) {\\n        bytes memory secret = bytes(_secret);\\n        require(\\n            secret.length <= 180,\\n            \\\"secret too long: must be <= 200 characters\\\"\\n        );\\n\\n        for (uint256 i = 0; i < 6; i++) {\\n            uint256 start = i * 31;\\n            uint256 end = (i + 1) * 31;\\n\\n            bytes memory chunk = new bytes(32);\\n\\n            for (uint256 j = start; j < end && j < secret.length; j++) {\\n                chunk[j - start + 1] = secret[j];\\n            }\\n\\n            bytes32 chunk32;\\n            assembly {\\n                chunk32 := mload(add(chunk, 32))\\n            }\\n\\n            felts[i] = uint256(chunk32);\\n        }\\n    }\\n\\n    /**\\n     * Hashes the 6 field elements representing secret phrase into the public commitment\\n     *\\n     * @param _felts - the preimage to hash\\n     * @return - the poseidon hash commiting to the secret phrase\\n     */\\n    function hashPhrase(\\n        uint256[6] memory _felts\\n    ) public pure returns (uint256) {\\n        return Poseidon.poseidon(_felts);\\n    }\\n\\n    function stringToUint(string memory source) public pure returns (uint256 result) {\\n        bytes memory tempString = bytes(source);\\n        if (tempString.length == 0) {\\n            return 0x0;\\n        }\\n        \\n        // For each byte, shift result and insert the byte\\n        for (uint256 i = 0; i < tempString.length; i++) {\\n            result = (result << 8) | uint256(uint8(tempString[i]));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Verifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n/*\\n    Copyright 2021 0KIMS association.\\n\\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\\n\\n    snarkJS is a free software: you can redistribute it and/or modify it\\n    under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\\n    License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract Groth16Verifier {\\n    // Scalar field size\\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    // Base field size\\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n    // Verification Key data\\n    uint256 constant alphax  = 9526385790532871687215529217220873884227928931149809248336571282923313396106;\\n    uint256 constant alphay  = 21514950079872959705810978772756325328244854949685521730808737769175706105020;\\n    uint256 constant betax1  = 2716993543496060298796733064727635793292506509085152491379209538220117158382;\\n    uint256 constant betax2  = 20390368492886277093479380604774182574397340921248780260205596793295696674689;\\n    uint256 constant betay1  = 21764382463394824083591075546883615515682120102557591645420831661367465193367;\\n    uint256 constant betay2  = 12682167178280460625448986307109874161659067512125256426557601527559613505029;\\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\\n    uint256 constant deltax1 = 4101997915818703989480745681395641243754430031549478442656633631473459377754;\\n    uint256 constant deltax2 = 10906997380511376953049043930596140484928975373929750469282752765580878567599;\\n    uint256 constant deltay1 = 21467614705199245308953952438252223903556487680113609709431051398494080793017;\\n    uint256 constant deltay2 = 14148267251354792026140554064990543520838005031627642915066139480082886598994;\\n\\n    \\n    uint256 constant IC0x = 1481576207721992903324306469202784205263698883633483801846749476639749907908;\\n    uint256 constant IC0y = 14079879823088619349409019686751314160916086276213976861320608433134023444236;\\n    \\n    uint256 constant IC1x = 7383731686009945241890027660424753486806019510710608577959624978038477330556;\\n    uint256 constant IC1y = 15989552492341906507948596904664651598249821034965897193817841304269401419658;\\n    \\n    uint256 constant IC2x = 14560868027354574229864667972499776606845480756169309217438610379539610036620;\\n    uint256 constant IC2y = 2229063762005447500484823201700247299911184494037799604681263211101013646192;\\n    \\n \\n    // Memory data\\n    uint16 constant pVk = 0;\\n    uint16 constant pPairing = 128;\\n\\n    uint16 constant pLastMem = 896;\\n\\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[2] calldata _pubSignals) public view returns (bool) {\\n        assembly {\\n            function checkField(v) {\\n                if iszero(lt(v, q)) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n            \\n            // G1 function to multiply a G1 value(x,y) to value in an address\\n            function g1_mulAccC(pR, x, y, s) {\\n                let success\\n                let mIn := mload(0x40)\\n                mstore(mIn, x)\\n                mstore(add(mIn, 32), y)\\n                mstore(add(mIn, 64), s)\\n\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n\\n                mstore(add(mIn, 64), mload(pR))\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\n\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\n\\n                if iszero(success) {\\n                    mstore(0, 0)\\n                    return(0, 0x20)\\n                }\\n            }\\n\\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\\n                let _pPairing := add(pMem, pPairing)\\n                let _pVk := add(pMem, pVk)\\n\\n                mstore(_pVk, IC0x)\\n                mstore(add(_pVk, 32), IC0y)\\n\\n                // Compute the linear combination vk_x\\n                \\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\\n                \\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\\n                \\n\\n                // -A\\n                mstore(_pPairing, calldataload(pA))\\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\\n\\n                // B\\n                mstore(add(_pPairing, 64), calldataload(pB))\\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\\n\\n                // alpha1\\n                mstore(add(_pPairing, 192), alphax)\\n                mstore(add(_pPairing, 224), alphay)\\n\\n                // beta2\\n                mstore(add(_pPairing, 256), betax1)\\n                mstore(add(_pPairing, 288), betax2)\\n                mstore(add(_pPairing, 320), betay1)\\n                mstore(add(_pPairing, 352), betay2)\\n\\n                // vk_x\\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\\n\\n\\n                // gamma2\\n                mstore(add(_pPairing, 448), gammax1)\\n                mstore(add(_pPairing, 480), gammax2)\\n                mstore(add(_pPairing, 512), gammay1)\\n                mstore(add(_pPairing, 544), gammay2)\\n\\n                // C\\n                mstore(add(_pPairing, 576), calldataload(pC))\\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\\n\\n                // delta2\\n                mstore(add(_pPairing, 640), deltax1)\\n                mstore(add(_pPairing, 672), deltax2)\\n                mstore(add(_pPairing, 704), deltay1)\\n                mstore(add(_pPairing, 736), deltay2)\\n\\n\\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\\n\\n                isOk := and(success, mload(_pPairing))\\n            }\\n\\n            let pMem := mload(0x40)\\n            mstore(0x40, add(pMem, pLastMem))\\n\\n            // Validate that all evaluations \u2208 F\\n            \\n            checkField(calldataload(add(_pubSignals, 0)))\\n            \\n            checkField(calldataload(add(_pubSignals, 32)))\\n            \\n            checkField(calldataload(add(_pubSignals, 64)))\\n            \\n\\n            // Validate all evaluations\\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\\n\\n            mstore(0, isValid)\\n             return(0, 0x20)\\n         }\\n     }\\n }\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/TheWord.sol\": {\r\n        \"Poseidon\": \"0x296f81b01d089108cf7d20d2e1cf85ec1e3e0994\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"username\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"added\",\"type\":\"uint256\"}],\"name\":\"PrizeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"shoutedBy\",\"type\":\"string\"}],\"name\":\"Shouted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"burnLocation\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"fundPrize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"_felts\",\"type\":\"uint256[6]\"}],\"name\":\"hashPhrase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct TheWord.Groth16Proof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"newRound\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"commitment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"shoutedBy\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"secretToFelts\",\"outputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"felts\",\"type\":\"uint256[6]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"shout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TheWord", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b515e8a108a888550e6b0c5515719ae25b006ce4", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}