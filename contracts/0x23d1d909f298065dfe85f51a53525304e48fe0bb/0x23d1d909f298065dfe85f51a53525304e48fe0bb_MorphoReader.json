{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.4.22 <0.9.0;\\r\\n\\r\\nlibrary console {\\r\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\r\\n\\r\\n    function _sendLogPayload(bytes memory payload) private view {\\r\\n        uint256 payloadLength = payload.length;\\r\\n        address consoleAddress = CONSOLE_ADDRESS;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let payloadStart := add(payload, 32)\\r\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function log() internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\r\\n    }\\r\\n\\r\\n    function logInt(int p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logUint(uint p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logString(string memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBool(bool p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logAddress(address p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes(bytes memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes1(bytes1 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes2(bytes2 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes3(bytes3 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes4(bytes4 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes5(bytes5 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes6(bytes6 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes7(bytes7 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes8(bytes8 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes9(bytes9 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes10(bytes10 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes11(bytes11 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes12(bytes12 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes13(bytes13 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes14(bytes14 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes15(bytes15 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes16(bytes16 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes17(bytes17 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes18(bytes18 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes19(bytes19 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes20(bytes20 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes21(bytes21 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes22(bytes22 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes23(bytes23 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes24(bytes24 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes25(bytes25 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes26(bytes26 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes27(bytes27 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes28(bytes28 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes29(bytes29 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes30(bytes30 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes31(bytes31 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function logBytes32(bytes32 p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(uint p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(bool p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(address p0) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n    function log(address p0, address p1, address p2, address p3) internal view {\\r\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IIrm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport {MarketParams, Market} from \\\"./IMorpho.sol\\\";\\r\\n\\r\\n/// @title IIrm\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Interface that Interest Rate Models (IRMs) used by Morpho must implement.\\r\\ninterface IIrm {\\r\\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams`.\\r\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\r\\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256);\\r\\n\\r\\n    /// @notice Returns the borrow rate per second (scaled by WAD) of the market `marketParams` without modifying any\\r\\n    /// storage.\\r\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\r\\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IMorpho.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ntype Id is bytes32;\\r\\n\\r\\nstruct MarketParams {\\r\\n    address loanToken;\\r\\n    address collateralToken;\\r\\n    address oracle;\\r\\n    address irm;\\r\\n    uint256 lltv;\\r\\n}\\r\\n\\r\\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\r\\n/// accrual.\\r\\nstruct Position {\\r\\n    uint256 supplyShares;\\r\\n    uint128 borrowShares;\\r\\n    uint128 collateral;\\r\\n}\\r\\n\\r\\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\r\\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\r\\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\\r\\n/// interest accrual.\\r\\nstruct Market {\\r\\n    uint128 totalSupplyAssets;\\r\\n    uint128 totalSupplyShares;\\r\\n    uint128 totalBorrowAssets;\\r\\n    uint128 totalBorrowShares;\\r\\n    uint128 lastUpdate;\\r\\n    uint128 fee;\\r\\n}\\r\\n\\r\\nstruct Authorization {\\r\\n    address authorizer;\\r\\n    address authorized;\\r\\n    bool isAuthorized;\\r\\n    uint256 nonce;\\r\\n    uint256 deadline;\\r\\n}\\r\\n\\r\\nstruct Signature {\\r\\n    uint8 v;\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n}\\r\\n\\r\\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\\r\\n/// @dev Consider using the IMorpho interface instead of this one.\\r\\ninterface IMorphoBase {\\r\\n    /// @notice The EIP-712 domain separator.\\r\\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\\r\\n    /// the same chain id because the domain separator would be the same.\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    /// @notice The owner of the contract.\\r\\n    /// @dev It has the power to change the owner.\\r\\n    /// @dev It has the power to set fees on markets and set the fee recipient.\\r\\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    /// @notice The fee recipient of all markets.\\r\\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\\r\\n    function feeRecipient() external view returns (address);\\r\\n\\r\\n    /// @notice Whether the `irm` is enabled.\\r\\n    function isIrmEnabled(address irm) external view returns (bool);\\r\\n\\r\\n    /// @notice Whether the `lltv` is enabled.\\r\\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\\r\\n\\r\\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s position on all markets.\\r\\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\\r\\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\\r\\n\\r\\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\\r\\n    function nonce(address authorizer) external view returns (uint256);\\r\\n\\r\\n    /// @notice Sets `newOwner` as `owner` of the contract.\\r\\n    /// @dev Warning: No two-step transfer ownership.\\r\\n    /// @dev Warning: The owner can be set to the zero address.\\r\\n    function setOwner(address newOwner) external;\\r\\n\\r\\n    /// @notice Enables `irm` as a possible IRM for market creation.\\r\\n    /// @dev Warning: It is not possible to disable an IRM.\\r\\n    function enableIrm(address irm) external;\\r\\n\\r\\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\\r\\n    /// @dev Warning: It is not possible to disable a LLTV.\\r\\n    function enableLltv(uint256 lltv) external;\\r\\n\\r\\n    /// @notice Sets the `newFee` for the given market `marketParams`.\\r\\n    /// @param newFee The new fee, scaled by WAD.\\r\\n    /// @dev Warning: The recipient can be the zero address.\\r\\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\\r\\n\\r\\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\\r\\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\\r\\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\\r\\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\\r\\n    function setFeeRecipient(address newFeeRecipient) external;\\r\\n\\r\\n    /// @notice Creates the market `marketParams`.\\r\\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\\r\\n    /// Morpho behaves as expected:\\r\\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\\r\\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\\r\\n    /// burn functions are not supported.\\r\\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\\r\\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\\r\\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\\r\\n    /// - The IRM should not re-enter Morpho.\\r\\n    /// - The oracle should return a price with the correct scaling.\\r\\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\\r\\n    /// (funds could get stuck):\\r\\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\\r\\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\\r\\n    /// `toSharesDown` overflow.\\r\\n    /// - The IRM can revert on `borrowRate`.\\r\\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\\r\\n    /// overflow.\\r\\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\\r\\n    /// `liquidate` from being used under certain market conditions.\\r\\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\\r\\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\\r\\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\\r\\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\\r\\n    function createMarket(MarketParams memory marketParams) external;\\r\\n\\r\\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\r\\n    /// `onMorphoSupply` function with the given `data`.\\r\\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\r\\n    /// caller is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific\\r\\n    /// amount of shares is given for full compatibility and precision.\\r\\n    /// @dev Supplying a large amount can revert for overflow.\\r\\n    /// @dev Supplying an amount of shares may lead to supply more or fewer assets than expected due to slippage.\\r\\n    /// Consider using the `assets` parameter to avoid this.\\r\\n    /// @param marketParams The market to supply assets to.\\r\\n    /// @param assets The amount of assets to supply.\\r\\n    /// @param shares The amount of shares to mint.\\r\\n    /// @param onBehalf The address that will own the increased supply position.\\r\\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\\r\\n    /// @return assetsSupplied The amount of assets supplied.\\r\\n    /// @return sharesSupplied The amount of shares minted.\\r\\n    function supply(\\r\\n        MarketParams memory marketParams,\\r\\n        uint256 assets,\\r\\n        uint256 shares,\\r\\n        address onBehalf,\\r\\n        bytes memory data\\r\\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\\r\\n\\r\\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\r\\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\\r\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\r\\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\\r\\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\\r\\n    /// conversion roundings between shares and assets.\\r\\n    /// @param marketParams The market to withdraw assets from.\\r\\n    /// @param assets The amount of assets to withdraw.\\r\\n    /// @param shares The amount of shares to burn.\\r\\n    /// @param onBehalf The address of the owner of the supply position.\\r\\n    /// @param receiver The address that will receive the withdrawn assets.\\r\\n    /// @return assetsWithdrawn The amount of assets withdrawn.\\r\\n    /// @return sharesWithdrawn The amount of shares burned.\\r\\n    function withdraw(\\r\\n        MarketParams memory marketParams,\\r\\n        uint256 assets,\\r\\n        uint256 shares,\\r\\n        address onBehalf,\\r\\n        address receiver\\r\\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\\r\\n\\r\\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` and sends the assets to `receiver`.\\r\\n    /// @dev Either `assets` or `shares` should be zero. Most use cases should rely on `assets` as an input so the\\r\\n    /// caller is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is\\r\\n    /// given for full compatibility and precision.\\r\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\r\\n    /// @dev Borrowing a large amount can revert for overflow.\\r\\n    /// @dev Borrowing an amount of shares may lead to borrow fewer assets than expected due to slippage.\\r\\n    /// Consider using the `assets` parameter to avoid this.\\r\\n    /// @param marketParams The market to borrow assets from.\\r\\n    /// @param assets The amount of assets to borrow.\\r\\n    /// @param shares The amount of shares to mint.\\r\\n    /// @param onBehalf The address that will own the increased borrow position.\\r\\n    /// @param receiver The address that will receive the borrowed assets.\\r\\n    /// @return assetsBorrowed The amount of assets borrowed.\\r\\n    /// @return sharesBorrowed The amount of shares minted.\\r\\n    function borrow(\\r\\n        MarketParams memory marketParams,\\r\\n        uint256 assets,\\r\\n        uint256 shares,\\r\\n        address onBehalf,\\r\\n        address receiver\\r\\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\\r\\n\\r\\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\r\\n    /// `onMorphoReplay` function with the given `data`.\\r\\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\\r\\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\\r\\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\\r\\n    /// roundings between shares and assets.\\r\\n    /// @dev An attacker can front-run a repay with a small repay making the transaction revert for underflow.\\r\\n    /// @param marketParams The market to repay assets to.\\r\\n    /// @param assets The amount of assets to repay.\\r\\n    /// @param shares The amount of shares to burn.\\r\\n    /// @param onBehalf The address of the owner of the debt position.\\r\\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\\r\\n    /// @return assetsRepaid The amount of assets repaid.\\r\\n    /// @return sharesRepaid The amount of shares burned.\\r\\n    function repay(\\r\\n        MarketParams memory marketParams,\\r\\n        uint256 assets,\\r\\n        uint256 shares,\\r\\n        address onBehalf,\\r\\n        bytes memory data\\r\\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\\r\\n\\r\\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\\r\\n    /// `onMorphoSupplyCollateral` function with the given `data`.\\r\\n    /// @dev Interest are not accrued since it's not required and it saves gas.\\r\\n    /// @dev Supplying a large amount can revert for overflow.\\r\\n    /// @param marketParams The market to supply collateral to.\\r\\n    /// @param assets The amount of collateral to supply.\\r\\n    /// @param onBehalf The address that will own the increased collateral position.\\r\\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\\r\\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\\r\\n        external;\\r\\n\\r\\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` and sends the assets to `receiver`.\\r\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\r\\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\\r\\n    /// @param marketParams The market to withdraw collateral from.\\r\\n    /// @param assets The amount of collateral to withdraw.\\r\\n    /// @param onBehalf The address of the owner of the collateral position.\\r\\n    /// @param receiver The address that will receive the collateral assets.\\r\\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\\r\\n        external;\\r\\n\\r\\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\\r\\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\\r\\n    /// `onMorphoLiquidate` function with the given `data`.\\r\\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\\r\\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\\r\\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\\r\\n    /// @dev An attacker can front-run a liquidation with a small repay making the transaction revert for underflow.\\r\\n    /// @param marketParams The market of the position.\\r\\n    /// @param borrower The owner of the position.\\r\\n    /// @param seizedAssets The amount of collateral to seize.\\r\\n    /// @param repaidShares The amount of shares to repay.\\r\\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\\r\\n    /// @return The amount of assets seized.\\r\\n    /// @return The amount of assets repaid.\\r\\n    function liquidate(\\r\\n        MarketParams memory marketParams,\\r\\n        address borrower,\\r\\n        uint256 seizedAssets,\\r\\n        uint256 repaidShares,\\r\\n        bytes memory data\\r\\n    ) external returns (uint256, uint256);\\r\\n\\r\\n    /// @notice Executes a flash loan.\\r\\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\\r\\n    /// markets combined, plus donations).\\r\\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\\r\\n    /// - `flashFee` is zero.\\r\\n    /// - `maxFlashLoan` is the token's balance of this contract.\\r\\n    /// - The receiver of `assets` is the caller.\\r\\n    /// @param token The token to flash loan.\\r\\n    /// @param assets The amount of assets to flash loan.\\r\\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\\r\\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\\r\\n\\r\\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\\r\\n    /// @param authorized The authorized address.\\r\\n    /// @param newIsAuthorized The new authorization status.\\r\\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\\r\\n\\r\\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\\r\\n    /// @dev Warning: Reverts if the signature has already been submitted.\\r\\n    /// @dev The signature is malleable, but it has no impact on the security here.\\r\\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\\r\\n    /// @param authorization The `Authorization` struct.\\r\\n    /// @param signature The signature.\\r\\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\\r\\n\\r\\n    /// @notice Accrues interest for the given market `marketParams`.\\r\\n    function accrueInterest(MarketParams memory marketParams) external;\\r\\n\\r\\n    /// @notice Returns the data stored on the different `slots`.\\r\\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\\r\\n}\\r\\n\\r\\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\\r\\n/// @dev Consider using the IMorpho interface instead of this one.\\r\\ninterface IMorphoStaticTyping is IMorphoBase {\\r\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\r\\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\r\\n    /// accrual.\\r\\n    function position(Id id, address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\\r\\n\\r\\n    /// @notice The state of the market corresponding to `id`.\\r\\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\r\\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\r\\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\\r\\n    /// accrual.\\r\\n    function market(Id id)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 totalSupplyAssets,\\r\\n            uint128 totalSupplyShares,\\r\\n            uint128 totalBorrowAssets,\\r\\n            uint128 totalBorrowShares,\\r\\n            uint128 lastUpdate,\\r\\n            uint128 fee\\r\\n        );\\r\\n\\r\\n    /// @notice The market params corresponding to `id`.\\r\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\r\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\r\\n    function idToMarketParams(Id id)\\r\\n        external\\r\\n        view\\r\\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\\r\\n}\\r\\n\\r\\n/// @title IMorpho\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\\r\\ninterface IMorpho is IMorphoBase {\\r\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\r\\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\\r\\n    /// accrual.\\r\\n    function position(Id id, address user) external view returns (Position memory p);\\r\\n\\r\\n    /// @notice The state of the market corresponding to `id`.\\r\\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\r\\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\r\\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\\r\\n    /// interest accrual.\\r\\n    function market(Id id) external view returns (Market memory m);\\r\\n\\r\\n    /// @notice The market params corresponding to `id`.\\r\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\r\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\r\\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title IOracle\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Interface that oracles used by Morpho must implement.\\r\\n/// @dev It is the user's responsibility to select markets with safe oracles.\\r\\ninterface IOracle {\\r\\n    /// @notice Returns the price of 1 asset of collateral token quoted in 1 asset of loan token, scaled by 1e36.\\r\\n    /// @dev It corresponds to the price of 10**(collateral token decimals) assets of collateral token quoted in\\r\\n    /// 10**(loan token decimals) assets of loan token with `36 + loan token decimals - collateral token decimals`\\r\\n    /// decimals of precision.\\r\\n    function price() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/ConstantsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @dev The maximum fee a market can have (25%).\\r\\nuint256 constant MAX_FEE = 0.25e18;\\r\\n\\r\\n/// @dev Oracle price scale.\\r\\nuint256 constant ORACLE_PRICE_SCALE = 1e36;\\r\\n\\r\\n/// @dev Liquidation cursor.\\r\\nuint256 constant LIQUIDATION_CURSOR = 0.3e18;\\r\\n\\r\\n/// @dev Max liquidation incentive factor.\\r\\nuint256 constant MAX_LIQUIDATION_INCENTIVE_FACTOR = 1.15e18;\\r\\n\\r\\n/// @dev The EIP-712 typeHash for EIP712Domain.\\r\\nbytes32 constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\");\\r\\n\\r\\n/// @dev The EIP-712 typeHash for Authorization.\\r\\nbytes32 constant AUTHORIZATION_TYPEHASH =\\r\\n    keccak256(\\\"Authorization(address authorizer,address authorized,bool isAuthorized,uint256 nonce,uint256 deadline)\\\");\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/ErrorsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title ErrorsLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Library exposing error messages.\\r\\nlibrary ErrorsLib {\\r\\n    /// @notice Thrown when the caller is not the owner.\\r\\n    string internal constant NOT_OWNER = \\\"not owner\\\";\\r\\n\\r\\n    /// @notice Thrown when the LLTV to enable exceeds the maximum LLTV.\\r\\n    string internal constant MAX_LLTV_EXCEEDED = \\\"max LLTV exceeded\\\";\\r\\n\\r\\n    /// @notice Thrown when the fee to set exceeds the maximum fee.\\r\\n    string internal constant MAX_FEE_EXCEEDED = \\\"max fee exceeded\\\";\\r\\n\\r\\n    /// @notice Thrown when the value is already set.\\r\\n    string internal constant ALREADY_SET = \\\"already set\\\";\\r\\n\\r\\n    /// @notice Thrown when the IRM is not enabled at market creation.\\r\\n    string internal constant IRM_NOT_ENABLED = \\\"IRM not enabled\\\";\\r\\n\\r\\n    /// @notice Thrown when the LLTV is not enabled at market creation.\\r\\n    string internal constant LLTV_NOT_ENABLED = \\\"LLTV not enabled\\\";\\r\\n\\r\\n    /// @notice Thrown when the market is already created.\\r\\n    string internal constant MARKET_ALREADY_CREATED = \\\"market already created\\\";\\r\\n\\r\\n    /// @notice Thrown when a token to transfer doesn't have code.\\r\\n    string internal constant NO_CODE = \\\"no code\\\";\\r\\n\\r\\n    /// @notice Thrown when the market is not created.\\r\\n    string internal constant MARKET_NOT_CREATED = \\\"market not created\\\";\\r\\n\\r\\n    /// @notice Thrown when not exactly one of the input amount is zero.\\r\\n    string internal constant INCONSISTENT_INPUT = \\\"inconsistent input\\\";\\r\\n\\r\\n    /// @notice Thrown when zero assets is passed as input.\\r\\n    string internal constant ZERO_ASSETS = \\\"zero assets\\\";\\r\\n\\r\\n    /// @notice Thrown when a zero address is passed as input.\\r\\n    string internal constant ZERO_ADDRESS = \\\"zero address\\\";\\r\\n\\r\\n    /// @notice Thrown when the caller is not authorized to conduct an action.\\r\\n    string internal constant UNAUTHORIZED = \\\"unauthorized\\\";\\r\\n\\r\\n    /// @notice Thrown when the collateral is insufficient to `borrow` or `withdrawCollateral`.\\r\\n    string internal constant INSUFFICIENT_COLLATERAL = \\\"insufficient collateral\\\";\\r\\n\\r\\n    /// @notice Thrown when the liquidity is insufficient to `withdraw` or `borrow`.\\r\\n    string internal constant INSUFFICIENT_LIQUIDITY = \\\"insufficient liquidity\\\";\\r\\n\\r\\n    /// @notice Thrown when the position to liquidate is healthy.\\r\\n    string internal constant HEALTHY_POSITION = \\\"position is healthy\\\";\\r\\n\\r\\n    /// @notice Thrown when the authorization signature is invalid.\\r\\n    string internal constant INVALID_SIGNATURE = \\\"invalid signature\\\";\\r\\n\\r\\n    /// @notice Thrown when the authorization signature is expired.\\r\\n    string internal constant SIGNATURE_EXPIRED = \\\"signature expired\\\";\\r\\n\\r\\n    /// @notice Thrown when the nonce is invalid.\\r\\n    string internal constant INVALID_NONCE = \\\"invalid nonce\\\";\\r\\n\\r\\n    /// @notice Thrown when a token transfer reverted.\\r\\n    string internal constant TRANSFER_REVERTED = \\\"transfer reverted\\\";\\r\\n\\r\\n    /// @notice Thrown when a token transfer returned false.\\r\\n    string internal constant TRANSFER_RETURNED_FALSE = \\\"transfer returned false\\\";\\r\\n\\r\\n    /// @notice Thrown when a token transferFrom reverted.\\r\\n    string internal constant TRANSFER_FROM_REVERTED = \\\"transferFrom reverted\\\";\\r\\n\\r\\n    /// @notice Thrown when a token transferFrom returned false\\r\\n    string internal constant TRANSFER_FROM_RETURNED_FALSE = \\\"transferFrom returned false\\\";\\r\\n\\r\\n    /// @notice Thrown when the maximum uint128 is exceeded.\\r\\n    string internal constant MAX_UINT128_EXCEEDED = \\\"max uint128 exceeded\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/MarketParamsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {Id, MarketParams} from \\\"../interfaces/IMorpho.sol\\\";\\r\\n\\r\\n/// @title MarketParamsLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Library to convert a market to its id.\\r\\nlibrary MarketParamsLib {\\r\\n    /// @notice The length of the data used to compute the id of a market.\\r\\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\\r\\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\\r\\n\\r\\n    /// @notice Returns the id of the market `marketParams`.\\r\\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/MathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nuint256 constant WAD = 1e18;\\r\\n\\r\\n/// @title MathLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Library to manage fixed-point arithmetic.\\r\\nlibrary MathLib {\\r\\n    /// @dev Returns (`x` * `y`) / `WAD` rounded down.\\r\\n    function wMulDown(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        return mulDivDown(x, y, WAD);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded down.\\r\\n    function wDivDown(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        return mulDivDown(x, WAD, y);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded up.\\r\\n    function wDivUp(uint256 x, uint256 y) internal pure returns (uint256) {\\r\\n        return mulDivUp(x, WAD, y);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns (`x` * `y`) / `d` rounded down.\\r\\n    function mulDivDown(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\r\\n        return (x * y) / d;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns (`x` * `y`) / `d` rounded up.\\r\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\r\\n        return (x * y + (d - 1)) / d;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1, to approximate a\\r\\n    /// continuous compound interest rate.\\r\\n    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {\\r\\n        uint256 firstTerm = x * n;\\r\\n        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD);\\r\\n        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);\\r\\n\\r\\n        return firstTerm + secondTerm + thirdTerm;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/SharesMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {MathLib} from \\\"./MathLib.sol\\\";\\r\\n\\r\\n/// @title SharesMathLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Shares management library.\\r\\n/// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\\r\\n/// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\\r\\nlibrary SharesMathLib {\\r\\n    using MathLib for uint256;\\r\\n\\r\\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\\r\\n    /// high precision computations.\\r\\n    /// @dev Virtual shares can never be redeemed for the assets they are entitled to, but it is assumed the share price\\r\\n    /// stays low enough not to inflate these assets to a significant value.\\r\\n    /// @dev Warning: The assets to which virtual borrow shares are entitled behave like unrealizable bad debt.\\r\\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\\r\\n\\r\\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\\r\\n    /// empty.\\r\\n    uint256 internal constant VIRTUAL_ASSETS = 1;\\r\\n\\r\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding down.\\r\\n    function toSharesDown(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\r\\n        return assets.mulDivDown(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding down.\\r\\n    function toAssetsDown(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\r\\n        return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding up.\\r\\n    function toSharesUp(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\r\\n        return assets.mulDivUp(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding up.\\r\\n    function toAssetsUp(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\r\\n        return shares.mulDivUp(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/UtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {ErrorsLib} from \\\"../libraries/ErrorsLib.sol\\\";\\r\\n\\r\\n/// @title UtilsLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Library exposing helpers.\\r\\n/// @dev Inspired by https://github.com/morpho-org/morpho-utils.\\r\\nlibrary UtilsLib {\\r\\n    /// @dev Returns true if there is exactly one zero among `x` and `y`.\\r\\n    function exactlyOneZero(uint256 x, uint256 y) internal pure returns (bool z) {\\r\\n        assembly {\\r\\n            z := xor(iszero(x), iszero(y))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the min of `x` and `y`.\\r\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        assembly {\\r\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `x` safely cast to uint128.\\r\\n    function toUint128(uint256 x) internal pure returns (uint128) {\\r\\n        require(x <= type(uint128).max, ErrorsLib.MAX_UINT128_EXCEEDED);\\r\\n        return uint128(x);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns max(0, x - y).\\r\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\r\\n        assembly {\\r\\n            z := mul(gt(x, y), sub(x, y))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {Id, MarketParams, Market, IMorpho} from \\\"../../interfaces/IMorpho.sol\\\";\\r\\nimport {IIrm} from \\\"../../interfaces/IIrm.sol\\\";\\r\\n\\r\\nimport {MathLib} from \\\"../MathLib.sol\\\";\\r\\nimport {UtilsLib} from \\\"../UtilsLib.sol\\\";\\r\\nimport {MorphoLib} from \\\"./MorphoLib.sol\\\";\\r\\nimport {SharesMathLib} from \\\"../SharesMathLib.sol\\\";\\r\\nimport {MarketParamsLib} from \\\"../MarketParamsLib.sol\\\";\\r\\n\\r\\n/// @title MorphoBalancesLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Helper library exposing getters with the expected value after interest accrual.\\r\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\r\\n/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply\\r\\n/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.\\r\\nlibrary MorphoBalancesLib {\\r\\n    using MathLib for uint256;\\r\\n    using MathLib for uint128;\\r\\n    using UtilsLib for uint256;\\r\\n    using MorphoLib for IMorpho;\\r\\n    using SharesMathLib for uint256;\\r\\n    using MarketParamsLib for MarketParams;\\r\\n\\r\\n    /// @notice Returns the expected market balances of a market after having accrued interest.\\r\\n    /// @return The expected total supply assets.\\r\\n    /// @return The expected total supply shares.\\r\\n    /// @return The expected total borrow assets.\\r\\n    /// @return The expected total borrow shares.\\r\\n    function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256, uint256, uint256, uint256)\\r\\n    {\\r\\n        Id id = marketParams.id();\\r\\n        Market memory market = morpho.market(id);\\r\\n\\r\\n        uint256 elapsed = block.timestamp - market.lastUpdate;\\r\\n\\r\\n        // Skipped if elapsed == 0 or totalBorrowAssets == 0 because interest would be null, or if irm == address(0).\\r\\n        if (elapsed != 0 && market.totalBorrowAssets != 0 && marketParams.irm != address(0)) {\\r\\n            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\\r\\n            uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\\r\\n            market.totalBorrowAssets += interest.toUint128();\\r\\n            market.totalSupplyAssets += interest.toUint128();\\r\\n\\r\\n            if (market.fee != 0) {\\r\\n                uint256 feeAmount = interest.wMulDown(market.fee);\\r\\n                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact\\r\\n                // that total supply is already updated.\\r\\n                uint256 feeShares =\\r\\n                    feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);\\r\\n                market.totalSupplyShares += feeShares.toUint128();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the expected total supply assets of a market after having accrued interest.\\r\\n    function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 totalSupplyAssets)\\r\\n    {\\r\\n        (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the expected total borrow assets of a market after having accrued interest.\\r\\n    function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 totalBorrowAssets)\\r\\n    {\\r\\n        (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the expected total supply shares of a market after having accrued interest.\\r\\n    function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 totalSupplyShares)\\r\\n    {\\r\\n        (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.\\r\\n    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.\\r\\n    /// @dev Warning: Withdrawing using the expected supply assets can lead to a revert due to conversion roundings from\\r\\n    /// assets to shares.\\r\\n    function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        Id id = marketParams.id();\\r\\n        uint256 supplyShares = morpho.supplyShares(id, user);\\r\\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\r\\n\\r\\n        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.\\r\\n    /// @dev Warning: The expected balance is rounded up, so it may be greater than the market's expected total borrow\\r\\n    /// assets.\\r\\n    function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        Id id = marketParams.id();\\r\\n        uint256 borrowShares = morpho.borrowShares(id, user);\\r\\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);\\r\\n\\r\\n        return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IMorpho, Id} from \\\"../../interfaces/IMorpho.sol\\\";\\r\\nimport {MorphoStorageLib} from \\\"./MorphoStorageLib.sol\\\";\\r\\n\\r\\n/// @title MorphoLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Helper library to access Morpho storage variables.\\r\\n/// @dev Warning: Supply and borrow getters may return outdated values that do not include accrued interest.\\r\\nlibrary MorphoLib {\\r\\n    function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));\\r\\n        return uint256(morpho.extSloads(slot)[0]);\\r\\n    }\\r\\n\\r\\n    function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\r\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\r\\n    }\\r\\n\\r\\n    function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\r\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\r\\n    }\\r\\n\\r\\n    function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\r\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\r\\n    }\\r\\n\\r\\n    function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\r\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\r\\n    }\\r\\n\\r\\n    function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\r\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\r\\n    }\\r\\n\\r\\n    function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\r\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\r\\n    }\\r\\n\\r\\n    function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\r\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\r\\n    }\\r\\n\\r\\n    function fee(IMorpho morpho, Id id) internal view returns (uint256) {\\r\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\r\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\r\\n    }\\r\\n\\r\\n    function _array(bytes32 x) private pure returns (bytes32[] memory) {\\r\\n        bytes32[] memory res = new bytes32[](1);\\r\\n        res[0] = x;\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/morpho-blue/src/libraries/periphery/MorphoStorageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {Id} from \\\"../../interfaces/IMorpho.sol\\\";\\r\\n\\r\\n/// @title MorphoStorageLib\\r\\n/// @author Morpho Labs\\r\\n/// @custom:contact security@morpho.org\\r\\n/// @notice Helper library exposing getters to access Morpho storage variables' slot.\\r\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\r\\nlibrary MorphoStorageLib {\\r\\n    /* SLOTS */\\r\\n\\r\\n    uint256 internal constant OWNER_SLOT = 0;\\r\\n    uint256 internal constant FEE_RECIPIENT_SLOT = 1;\\r\\n    uint256 internal constant POSITION_SLOT = 2;\\r\\n    uint256 internal constant MARKET_SLOT = 3;\\r\\n    uint256 internal constant IS_IRM_ENABLED_SLOT = 4;\\r\\n    uint256 internal constant IS_LLTV_ENABLED_SLOT = 5;\\r\\n    uint256 internal constant IS_AUTHORIZED_SLOT = 6;\\r\\n    uint256 internal constant NONCE_SLOT = 7;\\r\\n    uint256 internal constant ID_TO_MARKET_PARAMS_SLOT = 8;\\r\\n\\r\\n    /* SLOT OFFSETS */\\r\\n\\r\\n    uint256 internal constant LOAN_TOKEN_OFFSET = 0;\\r\\n    uint256 internal constant COLLATERAL_TOKEN_OFFSET = 1;\\r\\n    uint256 internal constant ORACLE_OFFSET = 2;\\r\\n    uint256 internal constant IRM_OFFSET = 3;\\r\\n    uint256 internal constant LLTV_OFFSET = 4;\\r\\n\\r\\n    uint256 internal constant SUPPLY_SHARES_OFFSET = 0;\\r\\n    uint256 internal constant BORROW_SHARES_AND_COLLATERAL_OFFSET = 1;\\r\\n\\r\\n    uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;\\r\\n    uint256 internal constant TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1;\\r\\n    uint256 internal constant LAST_UPDATE_AND_FEE_OFFSET = 2;\\r\\n\\r\\n    /* GETTERS */\\r\\n\\r\\n    function ownerSlot() internal pure returns (bytes32) {\\r\\n        return bytes32(OWNER_SLOT);\\r\\n    }\\r\\n\\r\\n    function feeRecipientSlot() internal pure returns (bytes32) {\\r\\n        return bytes32(FEE_RECIPIENT_SLOT);\\r\\n    }\\r\\n\\r\\n    function positionSupplySharesSlot(Id id, address user) internal pure returns (bytes32) {\\r\\n        return bytes32(\\r\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function positionBorrowSharesAndCollateralSlot(Id id, address user) internal pure returns (bytes32) {\\r\\n        return bytes32(\\r\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT)))))\\r\\n                + BORROW_SHARES_AND_COLLATERAL_OFFSET\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function marketTotalSupplyAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET);\\r\\n    }\\r\\n\\r\\n    function marketTotalBorrowAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET);\\r\\n    }\\r\\n\\r\\n    function marketLastUpdateAndFeeSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET);\\r\\n    }\\r\\n\\r\\n    function isIrmEnabledSlot(address irm) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(irm, IS_IRM_ENABLED_SLOT));\\r\\n    }\\r\\n\\r\\n    function isLltvEnabledSlot(uint256 lltv) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(lltv, IS_LLTV_ENABLED_SLOT));\\r\\n    }\\r\\n\\r\\n    function isAuthorizedSlot(address authorizer, address authorizee) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(authorizee, keccak256(abi.encode(authorizer, IS_AUTHORIZED_SLOT))));\\r\\n    }\\r\\n\\r\\n    function nonceSlot(address authorizer) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(authorizer, NONCE_SLOT));\\r\\n    }\\r\\n\\r\\n    function idToLoanTokenSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET);\\r\\n    }\\r\\n\\r\\n    function idToCollateralTokenSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET);\\r\\n    }\\r\\n\\r\\n    function idToOracleSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET);\\r\\n    }\\r\\n\\r\\n    function idToIrmSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET);\\r\\n    }\\r\\n\\r\\n    function idToLltvSlot(Id id) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/MorphoReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT \\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {Id, IMorpho, MarketParams, Market, Position} from \\\"../lib/morpho-blue/src/interfaces/IMorpho.sol\\\";\\r\\nimport {IOracle} from \\\"../lib/morpho-blue/src/interfaces/IOracle.sol\\\";\\r\\nimport {IIrm} from \\\"../lib/morpho-blue/src/interfaces/IIrm.sol\\\";\\r\\nimport {MorphoBalancesLib} from \\\"../lib/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol\\\";\\r\\nimport {MorphoStorageLib} from \\\"../lib/morpho-blue/src/libraries/periphery/MorphoStorageLib.sol\\\";\\r\\nimport {MorphoLib} from \\\"../lib/morpho-blue/src/libraries/periphery/MorphoLib.sol\\\";\\r\\nimport {MathLib} from \\\"../lib/morpho-blue/src/libraries/MathLib.sol\\\";\\r\\nimport \\\"../lib/morpho-blue/src/libraries/ConstantsLib.sol\\\";\\r\\n\\r\\nimport \\\"../lib/forge-std/src/console.sol\\\";\\r\\n\\r\\n\\r\\n/// @title Morpho Steakhouse Reader\\r\\n/// @notice Why wasn't it alraedy in Morpho???\\r\\ncontract MorphoReader {\\r\\n    using MathLib for uint256;\\r\\n    using MorphoBalancesLib for IMorpho;\\r\\n    using MorphoStorageLib for IMorpho;\\r\\n    using MorphoLib for IMorpho;\\r\\n\\r\\n    IMorpho public immutable morpho;\\r\\n\\r\\n\\r\\n    constructor(IMorpho morphoAddress) {\\r\\n        morpho = morphoAddress;\\r\\n    }\\r\\n\\r\\n    function getMarketData(Id id) public view \\r\\n        returns (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets, uint256 totalBorrowShares, \\r\\n            uint256 fee, uint256 utilization, uint256 supplyRate, uint256 borrowRate){\\r\\n\\r\\n        Market memory market = morpho.market(id);\\r\\n        MarketParams memory marketParams = morpho.idToMarketParams(id);\\r\\n\\r\\n        (totalSupplyAssets, totalSupplyShares, totalBorrowAssets, totalBorrowShares) = morpho.expectedMarketBalances(marketParams);\\r\\n\\r\\n        fee = morpho.fee(id);\\r\\n\\r\\n        // Get the borrow rate\\r\\n        borrowRate = 0;\\r\\n        if (marketParams.irm != address(0)) {\\r\\n            borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market).wTaylorCompounded(1);\\r\\n        }\\r\\n\\r\\n        // Get the supply rate\\r\\n        utilization = totalSupplyAssets == 0 ? 0 : totalBorrowAssets.wDivUp(totalSupplyAssets);\\r\\n\\r\\n        supplyRate = borrowRate.wMulDown(1 ether - market.fee).wMulDown(utilization);\\r\\n\\r\\n        return (totalSupplyAssets, totalSupplyShares, totalBorrowAssets, totalBorrowShares, fee, utilization, supplyRate, borrowRate);\\r\\n    }\\r\\n\\r\\n    function getPosition(Id id, address user) public view \\r\\n        returns (uint256 suppliedShares, uint256 suppliedAssets, uint256 borrowedShares, uint256 borrowedAssets, \\r\\n            uint256 collateral, uint256 collateralValue, uint256 ltv, uint256 healthFactor){\\r\\n\\r\\n        MarketParams memory marketParams = morpho.idToMarketParams(id);\\r\\n\\r\\n        Position memory position = morpho.position(id, user);\\r\\n\\r\\n        uint256 collateralPrice = (marketParams.oracle == address(0)) ? 0 : IOracle(marketParams.oracle).price();\\r\\n        collateral = position.collateral;\\r\\n        collateralValue = collateral.mulDivDown(collateralPrice, ORACLE_PRICE_SCALE);\\r\\n        borrowedAssets = morpho.expectedBorrowAssets(marketParams, user);\\r\\n        borrowedShares = morpho.supplyShares(id, user);\\r\\n        suppliedAssets = morpho.expectedSupplyAssets(marketParams, user);\\r\\n        suppliedShares = morpho.supplyShares(id, user);\\r\\n        ltv = (collateralValue == 0) ? 0 : borrowedAssets.wDivUp(collateralValue);\\r\\n            \\r\\n        uint256 maxBorrow = collateral.mulDivDown(collateralPrice, ORACLE_PRICE_SCALE).wMulDown(marketParams.lltv);\\r\\n\\r\\n        healthFactor = (borrowedAssets == 0) ? type(uint256).max : maxBorrow.wDivDown(borrowedAssets);\\r\\n\\r\\n        return (suppliedShares, suppliedAssets, borrowedShares, borrowedAssets, collateral, collateralValue, ltv, healthFactor);\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@morpho-blue-oracles/=lib/morpho-blue-oracles/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"ds-auth/=lib/dss-psm/lib/dss/lib/ds-token/lib/ds-auth/src/\",\r\n      \"ds-math/=lib/dss-psm/lib/dss/lib/ds-token/lib/ds-math/src/\",\r\n      \"ds-note/=lib/dss-psm/lib/dss/lib/ds-value/lib/ds-thing/lib/ds-note/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"ds-thing/=lib/dss-psm/lib/dss/lib/ds-value/lib/ds-thing/src/\",\r\n      \"ds-token/=lib/dss-psm/lib/dss/lib/ds-token/src/\",\r\n      \"ds-value/=lib/dss-psm/lib/dss/lib/ds-value/src/\",\r\n      \"dss-interfaces/=lib/dss-psm/lib/dss-interfaces/src/\",\r\n      \"dss-psm/=lib/dss-psm/src/\",\r\n      \"dss/=lib/dss-psm/lib/dss/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"morpho-blue-oracles/=lib/morpho-blue-oracles/src/\",\r\n      \"morpho-blue/=lib/morpho-blue/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"v3-core/=lib/v3-core/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"morphoAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getMarketData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupplyShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Id\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"suppliedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"morpho\",\"outputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MorphoReader", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bbbbbbbbbb9cc5e90e3b3af64bdaf62c37eeffcb", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}