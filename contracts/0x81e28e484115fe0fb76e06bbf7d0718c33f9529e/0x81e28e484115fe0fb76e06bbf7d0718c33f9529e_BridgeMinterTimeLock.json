{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bridge/BridgeMinterTimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface ERC20 {\\n    function transferOwnership(address _newOwner) external;\\n    function acceptOwnership() external;\\n    function totalSupply() external view returns (uint);\\n    function mint(address to, uint256 value) external;\\n}\\n\\ncontract BridgeMinterTimeLock {\\n\\n    // Declare the immutable variables at the contract level\\n    address public immutable approver;\\n    address public immutable notary;\\n    ERC20 public immutable tokenAddress;\\n    uint256 public immutable chainId;\\n    bytes32 public immutable domainSeparator;\\n\\n    address public owner;\\n    bool private bridging;\\n    address public pendingOwner;\\n    address public erc20PendingOwner;\\n    uint public ownershipTransferInitiatedAt;\\n    uint public erc20OwnershipTransferInitiatedAt;\\n    uint constant TRANSFER_DELAY = 48 hours;\\n    bool public notaryApprove;\\n    bool public approverApprove;\\n\\n    mapping(bytes32 => bool) private nonces;\\n\\n    event Bridged(address  receiver, uint256 amount);\\n    event TransferOwnership(address indexed owner, bool indexed confirmed);\\n\\n\\n    constructor(\\n        address _owner,\\n        address _approver,\\n        address _notary,\\n        address _tokenContractAddress,\\n        uint256 _chainId\\n    ) {\\n        require(_owner != address(0), \\\"Invalid owner\\\");\\n        require(_approver != address(0), \\\"Invalid approver\\\");\\n        require(_notary != address(0), \\\"Invalid notary\\\");\\n        require(_tokenContractAddress != address(0), \\\"Invalid token contract address\\\");\\n\\n        owner = _owner;\\n        approver = _approver;\\n        notary = _notary;\\n        tokenAddress = ERC20(_tokenContractAddress);\\n        chainId = _chainId;\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId)\\\"),\\n                keccak256(\\\"Neptune Bridge\\\"),\\n                keccak256(\\\"0.0.1\\\"),\\n                _chainId\\n            )\\n        );\\n    }\\n\\n    // Function to initiate ownership transfer\\n    function initiateTransferOwnership(address _newOwner) public onlyOwner {\\n        require(_newOwner != address(0), \\\"New owner cannot be zero address\\\");\\n        require(_newOwner != owner, \\\"New owner is already the current owner\\\");\\n        pendingOwner = _newOwner;\\n        ownershipTransferInitiatedAt = block.timestamp;\\n    }\\n\\n    // Function to finalize ownership transfer after 48 hours\\n    function finalizeTransferOwnership() public {\\n        require(msg.sender == pendingOwner, \\\"Only pending owner can finalize ownership transfer\\\");\\n        require(block.timestamp >= ownershipTransferInitiatedAt + TRANSFER_DELAY, \\\"Must wait 48 hours to confirm transfer.\\\");\\n        owner = pendingOwner;\\n        pendingOwner = address(0);\\n        emit TransferOwnership(owner, true); // Emit an event to log the ownership transfer\\n}\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner can call this function\\\");\\n        _;\\n    }\\n\\n    // Function to initiate token ownership transfer\\n    function initiateTransferTokenOwnership(address _newOwner) public onlyOwner {\\n        require(_newOwner != address(0), \\\"New owner cannot be zero address\\\");\\n        erc20OwnershipTransferInitiatedAt = block.timestamp;\\n        erc20PendingOwner = _newOwner;\\n    }\\n\\n    // Function to finalize token ownership transfer after 48 hours\\n    function completeTransferTokenOwnership() public onlyOwner { \\n        require(block.timestamp >= erc20OwnershipTransferInitiatedAt + TRANSFER_DELAY, \\\"Must wait 48 hours to confirm transfer.\\\");\\n        tokenAddress.transferOwnership(erc20PendingOwner);\\n        emit TransferOwnership(erc20PendingOwner, true); // Emit an event to log the token ownership transfer\\n    }\\n\\n    function acceptTokenOwnership() public {\\n        tokenAddress.acceptOwnership();\\n    }\\n\\n    modifier checkNonce(bytes32 nonce) {\\n        require(nonces[nonce]==false); // dev: already processed\\n        _;\\n    }\\n\\n    function bridge(address sender, uint256 bridgedAmount, bytes32 nonce, bytes32 messageHash, bytes calldata approvedMessage, bytes calldata notarizedMessage)\\n    external checkNonce(nonce) {\\n        require(bridging == false, \\\"Re-entrancy guard triggered: bridging already in progress\\\"); // Re-entrancy guard\\n        bridging = true;\\n\\n        bytes32 hashToVerify = keccak256(\\n            abi.encode(keccak256(\\\"SignedMessage(bytes32 key,address sender,uint256 amount)\\\"), nonce, sender, bridgedAmount)\\n        );\\n\\n        require(checkEncoding(approvedMessage, messageHash, hashToVerify, approver), \\\"Invalid signature from approver\\\"); // Check approver's signature\\n        require(checkEncoding(notarizedMessage, messageHash, hashToVerify, notary), \\\"Invalid signature from notary\\\"); // Check notary's signature\\n        nonces[nonce]=true;\\n\\n        ERC20(tokenAddress).mint(sender, bridgedAmount);\\n\\n        emit Bridged(sender, bridgedAmount);\\n        bridging = false;\\n    }\\n\\n\\n    function checkEncoding(bytes memory signedMessage,bytes32 messageHash, bytes32 hashToVerify, address signer) \\n    internal view returns(bool){\\n\\n        bytes32 domainSeparatorHash = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, hashToVerify));\\n        require(messageHash == domainSeparatorHash); //dev: values do not match\\n\\n        return signer == recoverSigner(messageHash, signedMessage);\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n    internal pure returns (uint8 v, bytes32 r, bytes32 s){\\n        require(sig.length == 65); // dev: signature invalid\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix.\\n            r := mload(add(sig, 32))\\n            // second 32 bytes.\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes).\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n\\n    function recoverSigner(bytes32 message, bytes memory sig)\\n    internal pure returns (address){\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        (v, r, s) = splitSignature(sig);\\n\\n        return tryRecover(message, v, r, s);\\n    }\\n\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n    internal \\n    pure \\n    returns (address) {\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        } else if (v != 27 && v != 28) {\\n            return address(0);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return address(0);\\n        }\\n\\n        return signer;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_notary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approverApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"approvedMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"notarizedMessage\",\"type\":\"bytes\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeTransferTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20OwnershipTransferInitiatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20PendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initiateTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initiateTransferTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notaryApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipTransferInitiatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BridgeMinterTimeLock", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000411345716f8d510de74e1fa3b98dd5d729f0f5c10000000000000000000000004c2949f6589c12662aa27ba5e0b0f84b351b28fc000000000000000000000000935711c2f34078a833c9465ef2fc77194b97de5e00000000000000000000000060158131416f5e53d55d73a11be2e203cb26abcc00000000000000000000000000000000000000000000000000000000009a7257", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}