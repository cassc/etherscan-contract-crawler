{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Root Liquidity Gauge Implementation\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\n\r\ninterface Bridger:\r\n    def cost() -> uint256: view\r\n    def bridge(_token: address, _destination: address, _amount: uint256): payable\r\n\r\ninterface CRV20:\r\n    def rate() -> uint256: view\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n\r\ninterface ERC20:\r\n    def balanceOf(_account: address) -> uint256: view\r\n    def approve(_account: address, _value: uint256): nonpayable\r\n    def transfer(_to: address, _amount: uint256): nonpayable\r\n\r\ninterface GaugeController:\r\n    def checkpoint_gauge(addr: address): nonpayable\r\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\r\n\r\ninterface Factory:\r\n    def get_bridger(_chain_id: uint256) -> address: view\r\n    def owner() -> address: view\r\n\r\ninterface Minter:\r\n    def mint(_gauge: address): nonpayable\r\n\r\n\r\nstruct InflationParams:\r\n    rate: uint256\r\n    finish_time: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 604800\r\nYEAR: constant(uint256) = 86400 * 365\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\n\r\nCRV: immutable(address)\r\nGAUGE_CONTROLLER: immutable(address)\r\nMINTER: immutable(address)\r\n\r\n\r\nchain_id: public(uint256)\r\nbridger: public(address)\r\nfactory: public(address)\r\ninflation_params: public(InflationParams)\r\n\r\nlast_period: public(uint256)\r\ntotal_emissions: public(uint256)\r\n\r\nis_killed: public(bool)\r\n\r\n\r\n@external\r\ndef __init__(_crv_token: address, _gauge_controller: address, _minter: address):\r\n    self.factory = 0x000000000000000000000000000000000000dEaD\r\n\r\n    # assign immutable variables\r\n    CRV = _crv_token\r\n    GAUGE_CONTROLLER = _gauge_controller\r\n    MINTER = _minter\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@external\r\ndef transmit_emissions():\r\n    \"\"\"\r\n    @notice Mint any new emissions and transmit across to child gauge\r\n    \"\"\"\r\n    assert msg.sender == self.factory  # dev: call via factory\r\n\r\n    Minter(MINTER).mint(self)\r\n    minted: uint256 = ERC20(CRV).balanceOf(self)\r\n\r\n    assert minted != 0  # dev: nothing minted\r\n    bridger: address = self.bridger\r\n\r\n    Bridger(bridger).bridge(CRV, self, minted, value=Bridger(bridger).cost())\r\n\r\n\r\n@view\r\n@external\r\ndef integrate_fraction(_user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the total emissions `_user` is entitled to\r\n    @dev Any value of `_user` other than the gauge address will return 0\r\n    \"\"\"\r\n    if _user == self:\r\n        return self.total_emissions\r\n    return 0\r\n\r\n\r\n@external\r\ndef user_checkpoint(_user: address) -> bool:\r\n    \"\"\"\r\n    @notice Checkpoint the gauge updating total emissions\r\n    @param _user Vestigal parameter with no impact on the function\r\n    \"\"\"\r\n    # the last period we calculated emissions up to (but not including)\r\n    last_period: uint256 = self.last_period\r\n    # our current period (which we will calculate emissions up to)\r\n    current_period: uint256 = block.timestamp / WEEK\r\n\r\n    # only checkpoint if the current period is greater than the last period\r\n    # last period is always less than or equal to current period and we only calculate\r\n    # emissions up to current period (not including it)\r\n    if last_period != current_period:\r\n        # checkpoint the gauge filling in any missing weight data\r\n        GaugeController(GAUGE_CONTROLLER).checkpoint_gauge(self)\r\n\r\n        params: InflationParams = self.inflation_params\r\n        emissions: uint256 = 0\r\n\r\n        # only calculate emissions for at most 256 periods since the last checkpoint\r\n        for i in range(last_period, last_period + 256):\r\n            if i == current_period:\r\n                # don't calculate emissions for the current period\r\n                break\r\n            period_time: uint256 = i * WEEK\r\n            weight: uint256 = GaugeController(GAUGE_CONTROLLER).gauge_relative_weight(self, period_time)\r\n\r\n            if period_time <= params.finish_time and params.finish_time < period_time + WEEK:\r\n                # calculate with old rate\r\n                emissions += weight * params.rate * (params.finish_time - period_time) / 10 ** 18\r\n                # update rate\r\n                params.rate = params.rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n                # calculate with new rate\r\n                emissions += weight * params.rate * (period_time + WEEK - params.finish_time) / 10 ** 18\r\n                # update finish time\r\n                params.finish_time += RATE_REDUCTION_TIME\r\n                # update storage\r\n                self.inflation_params = params\r\n            else:\r\n                emissions += weight * params.rate * WEEK / 10 ** 18\r\n\r\n        self.last_period = current_period\r\n        self.total_emissions += emissions\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the gauge kill status\r\n    @dev Inflation params are modified accordingly to disable/enable emissions\r\n    \"\"\"\r\n    assert msg.sender == Factory(self.factory).owner()\r\n\r\n    if _is_killed:\r\n        self.inflation_params.rate = 0\r\n    else:\r\n        self.inflation_params = InflationParams({\r\n            rate: CRV20(CRV).rate(),\r\n            finish_time: CRV20(CRV).future_epoch_time_write()\r\n        })\r\n        self.last_period = block.timestamp / WEEK\r\n    self.is_killed = _is_killed\r\n\r\n\r\n@external\r\ndef update_bridger():\r\n    \"\"\"\r\n    @notice Update the bridger used by this contract\r\n    @dev Bridger contracts should prevent briding if ever updated\r\n    \"\"\"\r\n    # reset approval\r\n    bridger: address = Factory(self.factory).get_bridger(self.chain_id)\r\n    ERC20(CRV).approve(self.bridger, 0)\r\n    ERC20(CRV).approve(bridger, MAX_UINT256)\r\n    self.bridger = bridger\r\n\r\n\r\n@external\r\ndef initialize(_bridger: address, _chain_id: uint256):\r\n    \"\"\"\r\n    @notice Proxy initialization method\r\n    \"\"\"\r\n    assert self.factory == ZERO_ADDRESS  # dev: already initialized\r\n\r\n    self.chain_id = _chain_id\r\n    self.bridger = _bridger\r\n    self.factory = msg.sender\r\n\r\n    inflation_params: InflationParams = InflationParams({\r\n        rate: CRV20(CRV).rate(),\r\n        finish_time: CRV20(CRV).future_epoch_time_write()\r\n    })\r\n    assert inflation_params.rate != 0\r\n\r\n    self.inflation_params = inflation_params\r\n    self.last_period = block.timestamp / WEEK\r\n\r\n    ERC20(CRV).approve(_bridger, MAX_UINT256)", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_crv_token\",\"type\":\"address\"},{\"name\":\"_gauge_controller\",\"type\":\"address\"},{\"name\":\"_minter\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transmit_emissions\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_bridger\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_bridger\",\"type\":\"address\"},{\"name\":\"_chain_id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"chain_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bridger\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"finish_time\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_emissions\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd520000000000000000000000002f50d538606fa9edd2b11e2446beb18c9d5846bb000000000000000000000000d061d61a4d941c39e5453435b6345dc261c2fce0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}