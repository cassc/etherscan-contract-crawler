{"SourceCode": "pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n*\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT v 1.0\r\n* \r\n* GitHub           - https://github.com/fortune333/Fortune333\r\n* \r\n* \r\n* \r\n*  - GAIN 8% - PER 1 MONTH (interest is charges in equal parts every 1 sec)\r\n*         0.26 - PER 1 DAY\r\n*         0.011 - PER 1 HOUR\r\n*         0.00018 - PER 1 MIN\r\n*         0.000003 - PER 1 SEC\r\n*  - Life-long payments\r\n*  - Unprecedentedly reliable\r\n*  - Bringer Fortune\r\n*  - Minimal contribution 0.01 eth\r\n*  - Currency and payment - ETH\r\n*  - Contribution allocation schemes:\r\n*    -- 100 % payments\r\n\r\n*\r\n*  --- About the project\r\n* Smart contracts with support for blockchains have opened a new era in a relationship without trust\r\n* intermediaries. This technology opens up incredible financial opportunities.\r\n* The distribution model is recorded in a smart contract, loaded into the Ethereum blockchain, and can no longer be changed.\r\n* The contract is recorded on the blockchain with a WAY TO REFIT OWNERSHIP!\r\n* free access online.\r\n* Continuous autonomous functioning of the system.\r\n*\r\n* ---How to use:\r\n* 1. Send from your ETH wallet to the address of the smart contract\r\n* Any amount from 0.01 ETH.\r\n* 2. Confirm your transaction in the history of your application or etherscan.io, specifying the address of your wallet.\r\n* Profit by sending 0 live transactions\r\n(profit is calculated every second).\r\n*  OR\r\n* To reinvest, you need to deposit the amount you want to reinvest, and the interest accrued is automatically added to your new deposit.\r\n*\r\n* RECOMMENDED GAS LIMIT: 200,000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* You can check the payments on the website etherscan.io, in the \u201cInternal Txns\u201d tab of your wallet.\r\n*\r\n* Referral system is missing.\r\n* Payment to developers is missing.\r\n* There is no payment for advertising.\r\n* All 100% of the contribution remains in the Smart Contract Fund.\r\n* Contract restart is also absent. If there is no * money in the Fund, payments are suspended and * they are renewed again when the Fund is filled. Thus * the contract is able to WORK FOREVER!\r\n* --- It is not allowed to transfer from exchanges, ONLY from your personal wallet ETH from which you have a private key.\r\n*\r\n* The contract has passed all the necessary checks by the professionals!\r\n*/\r\n\r\n\r\nlibrary Math {\r\n  function min(uint a, uint b) internal pure returns(uint) {\r\n    if (a > b) {\r\n      return b;\r\n    }\r\n    return a;\r\n  }\r\n}\r\n\r\n\r\nlibrary Zero {\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \"require not zero address\");\r\n  }\r\n\r\n  function requireNotZero(uint val) internal pure {\r\n    require(val != 0, \"require not zero value\");\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n\r\n  function isZero(uint a) internal pure returns(bool) {\r\n    return a == 0;\r\n  }\r\n\r\n  function notZero(uint a) internal pure returns(bool) {\r\n    return a != 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n\r\n  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n\r\n  // memory \r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a + mmul(p, a);\r\n  }\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function toAddress(bytes source) internal pure returns(address addr) {\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n\r\n  function isNotContract(address addr) internal view returns(bool) {\r\n    uint length;\r\n    assembly { length := extcodesize(addr) }\r\n    return length == 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  address private owner;\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"access denied\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  // Deletion of contract holder and waiver of ownership\r\n  \r\n  function disown() internal {\r\n    delete owner;\r\n  }\r\n}\r\n\r\n\r\ncontract Rev1Storage {\r\n  function investorShortInfo(address addr) public view returns(uint value, uint refBonus); \r\n}\r\n\r\n\r\ncontract Rev2Storage {\r\n  function investorInfo(address addr) public view returns(uint investment, uint paymentTime); \r\n}\r\n\r\n\r\nlibrary PrivateEntrance {\r\n  using PrivateEntrance for privateEntrance;\r\n  using Math for uint;\r\n  struct privateEntrance {\r\n    Rev1Storage rev1Storage;\r\n    Rev2Storage rev2Storage;\r\n    uint investorMaxInvestment;\r\n    uint endTimestamp;\r\n    mapping(address=>bool) hasAccess;\r\n  }\r\n\r\n  function isActive(privateEntrance storage pe) internal view returns(bool) {\r\n    return pe.endTimestamp > now;\r\n  }\r\n\r\n  function maxInvestmentFor(privateEntrance storage pe, address investorAddr) internal view returns(uint) {\r\n    // check if investorAddr has access\r\n    if (!pe.hasAccess[investorAddr]) {\r\n      return 0;\r\n    }\r\n\r\n    // get investor max investment = investment from revolution 1\r\n    (uint maxInvestment, ) = pe.rev1Storage.investorShortInfo(investorAddr);\r\n    if (maxInvestment == 0) {\r\n      return 0;\r\n    }\r\n    maxInvestment = Math.min(maxInvestment, pe.investorMaxInvestment);\r\n\r\n    // get current investment from revolution 2\r\n    (uint currInvestment, ) = pe.rev2Storage.investorInfo(investorAddr);\r\n    \r\n    if (currInvestment >= maxInvestment) {\r\n      return 0;\r\n    }\r\n\r\n    return maxInvestment-currInvestment;\r\n  }\r\n\r\n  function provideAccessFor(privateEntrance storage pe, address[] addrs) internal {\r\n    for (uint16 i; i < addrs.length; i++) {\r\n      pe.hasAccess[addrs[i]] = true;\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n  struct Investor {\r\n    uint investment;\r\n    uint paymentTime;\r\n  }\r\n  uint public size;\r\n\r\n  mapping (address => Investor) private investors;\r\n\r\n  function isInvestor(address addr) public view returns (bool) {\r\n    return investors[addr].investment > 0;\r\n  }\r\n\r\n  function investorInfo(address addr) public view returns(uint investment, uint paymentTime) {\r\n    investment = investors[addr].investment;\r\n    paymentTime = investors[addr].paymentTime;\r\n  }\r\n\r\n  function newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\r\n    Investor storage inv = investors[addr];\r\n    if (inv.investment != 0 || investment == 0) {\r\n      return false;\r\n    }\r\n    inv.investment = investment;\r\n    inv.paymentTime = paymentTime;\r\n    size++;\r\n    return true;\r\n  }\r\n\r\n  function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\r\n    if (investors[addr].investment == 0) {\r\n      return false;\r\n    }\r\n    investors[addr].investment += investment;\r\n    return true;\r\n  }\r\n\r\n  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n    if (investors[addr].investment == 0) {\r\n      return false;\r\n    }\r\n    investors[addr].paymentTime = paymentTime;\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\nlibrary RapidGrowthProtection {\r\n  using RapidGrowthProtection for rapidGrowthProtection;\r\n  \r\n  struct rapidGrowthProtection {\r\n    uint startTimestamp;\r\n    uint maxDailyTotalInvestment;\r\n    uint8 activityDays;\r\n    mapping(uint8 => uint) dailyTotalInvestment;\r\n  }\r\n\r\n  function maxInvestmentAtNow(rapidGrowthProtection storage rgp) internal view returns(uint) {\r\n    uint day = rgp.currDay();\r\n    if (day == 0 || day > rgp.activityDays) {\r\n      return 0;\r\n    }\r\n    if (rgp.dailyTotalInvestment[uint8(day)] >= rgp.maxDailyTotalInvestment) {\r\n      return 0;\r\n    }\r\n    return rgp.maxDailyTotalInvestment - rgp.dailyTotalInvestment[uint8(day)];\r\n  }\r\n\r\n  function isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {\r\n    uint day = rgp.currDay();\r\n    return day != 0 && day <= rgp.activityDays;\r\n  }\r\n\r\n  function saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {\r\n    uint day = rgp.currDay();\r\n    if (day == 0 || day > rgp.activityDays) {\r\n      return false;\r\n    }\r\n    if (rgp.dailyTotalInvestment[uint8(day)] + investment > rgp.maxDailyTotalInvestment) {\r\n      return false;\r\n    }\r\n    rgp.dailyTotalInvestment[uint8(day)] += investment;\r\n    return true;\r\n  }\r\n\r\n \r\n  function currDay(rapidGrowthProtection storage rgp) internal view returns(uint day) {\r\n    if (rgp.startTimestamp > now) {\r\n      return 0;\r\n    }\r\n    day = (now - rgp.startTimestamp) / 24 hours + 1; // +1 for skip zero day\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SpaceEmissio is Accessibility {\r\n  using RapidGrowthProtection for RapidGrowthProtection.rapidGrowthProtection;\r\n  using PrivateEntrance for PrivateEntrance.privateEntrance;\r\n  using Percent for Percent.percent;\r\n  using SafeMath for uint;\r\n  using Math for uint;\r\n\r\n  // easy read for investors\r\n  using Address for *;\r\n  using Zero for *; \r\n  \r\n  RapidGrowthProtection.rapidGrowthProtection private m_rgp;\r\n  PrivateEntrance.privateEntrance private m_privEnter;\r\n  mapping(address => bool) private m_referrals;\r\n  InvestorsStorage private m_investors;\r\n\r\n  // automatically generates getters\r\n  uint public constant minInvesment = 10 finney; //       0.01 eth\r\n  uint public constant maxBalance = 33333e5 ether; // 333 3300 000 eth\r\n  address public advertisingAddress;\r\n  address public adminsAddress;\r\n  uint public investmentsNumber;\r\n  uint public waveStartup;\r\n\r\n  // percents per Day\r\n  Percent.percent private m_1_percent = Percent.percent(26, 100000);           //   26/100000  *100% = 0.26%\r\n  \r\n  // more events for easy read from blockchain\r\n  event LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\r\n  event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\n  event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\n  event LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\r\n  event LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\r\n  event LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\r\n  event LogAutomaticReinvest(address indexed addr, uint when, uint investment);\r\n  event LogPayDividends(address indexed addr, uint when, uint dividends);\r\n  event LogNewInvestor(address indexed addr, uint when);\r\n  event LogBalanceChanged(uint when, uint balance);\r\n  event LogNextWave(uint when);\r\n  event LogDisown(uint when);\r\n\r\n\r\n  modifier balanceChanged {\r\n    _;\r\n    emit LogBalanceChanged(now, address(this).balance);\r\n  }\r\n\r\n  modifier notFromContract() {\r\n    require(msg.sender.isNotContract(), \"only externally accounts\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    adminsAddress = msg.sender;\r\n    advertisingAddress = msg.sender;\r\n    nextWave();\r\n  }\r\n\r\n  function() public payable {\r\n    // investor get him dividends\r\n    if (msg.value.isZero()) {\r\n      getMyDividends();\r\n      return;\r\n    }\r\n\r\n    // sender do invest\r\n    doInvest(msg.data.toAddress());\r\n  }\r\n\r\n  function doDisown() private onlyOwner {\r\n    disown();\r\n    emit LogDisown(now);\r\n  }\r\n\r\n  function init(address rev1StorageAddr, uint timestamp) private onlyOwner {\r\n    // init Rapid Growth Protection\r\n    m_rgp.startTimestamp = timestamp + 1;\r\n    m_rgp.maxDailyTotalInvestment = 500 ether;\r\n    m_rgp.activityDays = 21;\r\n    emit LogRGPInit(\r\n      now, \r\n      m_rgp.startTimestamp,\r\n      m_rgp.maxDailyTotalInvestment,\r\n      m_rgp.activityDays\r\n    );\r\n\r\n\r\n    // init Private Entrance\r\n    m_privEnter.rev1Storage = Rev1Storage(rev1StorageAddr);\r\n    m_privEnter.rev2Storage = Rev2Storage(address(m_investors));\r\n    m_privEnter.investorMaxInvestment = 50 ether;\r\n    m_privEnter.endTimestamp = timestamp;\r\n    emit LogPEInit(\r\n      now, \r\n      address(m_privEnter.rev1Storage), \r\n      address(m_privEnter.rev2Storage), \r\n      m_privEnter.investorMaxInvestment, \r\n      m_privEnter.endTimestamp\r\n    );\r\n  }\r\n\r\n  \r\n\r\n  function privateEntranceProvideAccessFor(address[] addrs) private onlyOwner {\r\n    m_privEnter.provideAccessFor(addrs);\r\n  }\r\n\r\n  function rapidGrowthProtectionmMaxInvestmentAtNow() private view returns(uint investment) {\r\n    investment = m_rgp.maxInvestmentAtNow();\r\n  }\r\n\r\n  function investorsNumber() public view returns(uint) {\r\n    return m_investors.size();\r\n  }\r\n\r\n  function balanceETH() public view returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function percent1() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_1_percent.num, m_1_percent.den);\r\n  }\r\n\r\n  \r\n\r\n  function investorInfo(address investorAddr) public view returns(uint investment, uint paymentTime, bool isReferral) {\r\n    (investment, paymentTime) = m_investors.investorInfo(investorAddr);\r\n    isReferral = m_referrals[investorAddr];\r\n  }\r\n\r\n  function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\n    dividends = calcDividends(investorAddr);\r\n  }\r\n\r\n  function dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n    Percent.percent memory p = dailyPercent();\r\n    (numerator, denominator) = (p.num, p.den);\r\n  }\r\n\r\n  \r\n\r\n  function getMyDividends() public notFromContract balanceChanged {\r\n    // calculate dividends\r\n    uint dividends = calcDividends(msg.sender);\r\n    require (dividends.notZero(), \"cannot to pay zero dividends\");\r\n\r\n    // update investor payment timestamp\r\n    assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n    // check enough eth - goto next wave if needed\r\n    if (address(this).balance <= dividends) {\r\n      nextWave();\r\n      dividends = address(this).balance;\r\n    } \r\n\r\n    // transfer dividends to investor\r\n    msg.sender.transfer(dividends);\r\n    emit LogPayDividends(msg.sender, now, dividends);\r\n  }\r\n\r\n  function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\n    uint investment = msg.value;\r\n    uint receivedEther = msg.value;\r\n    require(investment >= minInvesment, \"investment must be >= minInvesment\");\r\n    require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n    if (m_rgp.isActive()) { \r\n      // use Rapid Growth Protection if needed\r\n      uint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\r\n      rpgMaxInvest.requireNotZero();\r\n      investment = Math.min(investment, rpgMaxInvest);\r\n      assert(m_rgp.saveInvestment(investment));\r\n      emit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\r\n      \r\n    } else if (m_privEnter.isActive()) {\r\n      // use Private Entrance if needed\r\n      uint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\r\n      peMaxInvest.requireNotZero();\r\n      investment = Math.min(investment, peMaxInvest);\r\n    }\r\n\r\n    // send excess of ether if needed\r\n    if (receivedEther > investment) {\r\n      uint excess = receivedEther - investment;\r\n      msg.sender.transfer(excess);\r\n      receivedEther = investment;\r\n      emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\r\n    }\r\n\r\n   // commission\r\n\r\n\r\nbool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n    \r\n    // ref system works only once and only on first invest (is disabled)\r\nif (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\nreferrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\n\r\n}\r\n    \r\n    // automatic reinvest - prevent burning dividends\r\n    uint dividends = calcDividends(msg.sender);\r\n    if (senderIsInvestor && dividends.notZero()) {\r\n      investment += dividends;\r\n      emit LogAutomaticReinvest(msg.sender, now, dividends);\r\n    }\r\n\r\n    if (senderIsInvestor) {\r\n      // update existing investor\r\n      assert(m_investors.addInvestment(msg.sender, investment));\r\n      assert(m_investors.setPaymentTime(msg.sender, now));\r\n    } else {\r\n      // create new investor\r\n      assert(m_investors.newInvestor(msg.sender, investment, now));\r\n      emit LogNewInvestor(msg.sender, now);\r\n    }\r\n\r\n    investmentsNumber++;\r\n    emit LogNewInvesment(msg.sender, now, investment, receivedEther);\r\n  }\r\n\r\n  function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n    (uint investment, uint paymentTime) = m_investors.investorInfo(investorAddr);\r\n    return InvestorsStorage.Investor(investment, paymentTime);\r\n  }\r\n\r\n  function calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n    InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n    // safe gas if dividends will be 0\r\n    if (investor.investment.isZero() || now.sub(investor.paymentTime) < 1 seconds) {\r\n      return 0;\r\n    }\r\n    \r\n    // for prevent burning daily dividends if 24h did not pass - calculate it per 1 sec interval\r\n    // if daily percent is X, then 1 sec percent = X / (24h / 1 sec) = X / 86400\r\n\r\n    // and we must to get numbers of 1 sec interval after investor got payment:\r\n    // (now - investor.paymentTime) / 1 sec \r\n\r\n    // finaly calculate dividends = ((now - investor.paymentTime) / 1 sec) * (X * investor.investment)  / 86400) \r\n\r\n    Percent.percent memory p = dailyPercent();\r\n    dividends = (now.sub(investor.paymentTime) / 1 seconds) * p.mmul(investor.investment) / 86400;\r\n  }\r\n\r\n \r\n  function dailyPercent() internal view returns(Percent.percent memory p) {\r\n    uint balance = address(this).balance;\r\n      \r\n\r\n    if (balance < 33333e5 ether) { \r\n   \r\n      p = m_1_percent.toMemory();    // (1)\r\n\r\n  }\r\n  }\r\n\r\n\r\n\r\n  function nextWave() private {\r\n    m_investors = new InvestorsStorage();\r\n    investmentsNumber = 0;\r\n    waveStartup = now;\r\n    \r\n    \r\n    emit LogRGPInit(now , m_rgp.startTimestamp, m_rgp.maxDailyTotalInvestment, m_rgp.activityDays);\r\n    emit LogNextWave(now);\r\n  }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent1\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rev1Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rev2Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investorMaxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogPEInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxDailyTotalInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityDays\",\"type\":\"uint256\"}],\"name\":\"LogRGPInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"LogRGPInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"LogAutomaticReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]", "ContractName": "SpaceEmissio", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0df2f5af3d01272c29751899e9db62978ee76a07f2046084c61f0aa1654c2363"}