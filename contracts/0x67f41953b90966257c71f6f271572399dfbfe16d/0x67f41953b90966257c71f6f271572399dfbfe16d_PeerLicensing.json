{"SourceCode": "pragma solidity ^0.4.23;/*\r\n _ _____  ___   _ _  __ \r\n ` __ ___  ___  _  _  ,' \r\n  `. __  ____   /__ ,'\r\n    `.  __  __ /  ,'       \r\n      `.__ _  /_,'\r\n        `. _ /,'\r\n          `./'             \r\n          ,/`.             \r\n        ,'/ __`.        \r\n      ,'_/_  _ _`.      \r\n    ,'__/_ ___ _  `.       \r\n  ,'_  /___ __ _ __ `.  \r\n '-.._/____   _  __  _`.\r\nPyrConnect\r\nDecentralized Securities Licensing\r\n*/\r\ncontract PeerLicensing{\r\n\t// scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\n\t// orders of magnitude, hence the need to bridge between the two.\r\n\tuint256 constant scaleFactor = 0x10000000000000000;// 2^64\r\n\r\n\t// CRR = 50%\r\n\t// CRR is Cash Reserve Ratio (in this case Crypto Reserve Ratio).\r\n\t// For more on this: check out https://en.wikipedia.org/wiki/Reserve_requirement\r\n\tuint256 constant trickTax = 3;//divides flux'd fee and for every pass up\r\n\tint constant crr_n = 1; // CRR numerator\r\n\tint constant crr_d = 2; // CRR denominator\r\n\r\n\tint constant price_coeff = 0x57ea9ce452cde449f;\r\n\r\n\t// Array between each address and their number of tokens.\r\n\tmapping(address => uint256) public holdings;\r\n\t//cut down by a percentage when you sell out.\r\n\tmapping(address => uint256) public avgFactor_ethSpent;\r\n\r\n\tmapping(address => uint256) public souleculeR;\r\n\tmapping(address => uint256) public souleculeG;\r\n\tmapping(address => uint256) public souleculeB;\r\n\r\n\t// Array between each address and how much Ether has been paid out to it.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tmapping(address => address) public reff;\r\n\tmapping(address => uint256) public tricklingFlo;\r\n\tmapping(address => uint256) public pocket;\r\n\tmapping(address => int256) public payouts;\r\n\r\n\t// Variable tracking how many tokens are in existence overall.\r\n\tuint256 public totalBondSupply;\r\n\r\n\t// Aggregate sum of all payouts.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tint256 totalPayouts;\r\n\tuint256 public trickleSum;\r\n\tuint256 public stakingRequirement = 1e18;\r\n\t\r\n\taddress public lastGateway;\r\n\r\n\t//flux fee ratio and contract score keepers\r\n\tuint256 public withdrawSum;\r\n\tuint256 public investSum;\r\n\r\n\t// Variable tracking how much Ether each token is currently worth.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tuint256 earningsPerBond;\r\n\r\n\tconstructor() public {}\r\n\r\n\tevent onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n\tevent onBoughtFor(\r\n        address indexed buyerAddress,\r\n        address indexed forWho,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 totalTokensAtTheTime,//maybe it'd be cool to see what % people are selling from their total bank\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned,\r\n        uint256 resolved\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event onCashDividends(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event onColor(\r\n        address indexed customerAddress,\r\n        uint256 oldR,\r\n        uint256 oldG,\r\n        uint256 oldB,\r\n        uint256 newR,\r\n        uint256 newG,\r\n        uint256 newB\r\n    );\r\n\r\n\r\n\t// The following functions are used by the front-end for display purposes.\r\n\r\n\r\n\t// Returns the number of tokens currently held by _owner.\r\n\tfunction holdingsOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn holdings[_owner];\r\n\t}\r\n\r\n\t// Withdraws all dividends held by the caller sending the transaction, updates\r\n\t// the requisite global variables, and transfers Ether back to the caller.\r\n\tfunction withdraw(address to) public {\r\n\t\ttrickleUp();\r\n\t\t// Retrieve the dividends associated with the address the request came from.\r\n\t\tuint256 balance = dividends(msg.sender);\r\n\t\t//uint256 pocketBalance = tricklePocket[msg.sender];\r\n\t\t//tricklePocket[msg.sender] = 0;\r\n\t\t// Update the payouts array, incrementing the request address by `balance`.\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\n\t\t\r\n\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\n\r\n\t\tuint256 pocketETH = pocket[msg.sender];\r\n\t\tpocket[msg.sender] = 0;\r\n\t\ttrickleSum -= pocketETH;\r\n\r\n\t\tbalance += pocketETH;\r\n\t\t// Send the dividends to the address that requested the withdraw.\r\n\t\twithdrawSum += balance;\r\n\t\tto.transfer(balance);\r\n\t\temit onCashDividends(to,balance);\r\n\t}\r\n\tfunction fullCycleSellBonds(uint256 balance) internal {\r\n\t\t// Send the cashed out stake to the address that requested the withdraw.\r\n\t\twithdrawSum += balance;\r\n\t\tmsg.sender.transfer(balance);\r\n\t\temit onWithdraw(msg.sender, balance);\r\n\t}\r\n\r\n\r\n\t// Sells your tokens for Ether. This Ether is assigned to the callers entry\r\n\t// in the tokenBalance array, and therefore is shown as a dividend. A second\r\n\t// call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\n\tfunction sellBonds(uint256 _amount) public {\r\n\t\tuint256 bondBalance = holdings[msg.sender];\r\n\t\tif(_amount <= bondBalance && _amount > 0){\r\n\t\t\tsell(_amount);\r\n\t\t}else{\r\n\t\t\tsell(bondBalance);\r\n\t\t}\r\n\t}\r\n\r\n\t// The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\n\t// invokes the withdraw() function, sending the resulting Ether to the callers address.\r\n    function getMeOutOfHere() public {\r\n\t\tsellBonds( holdings[msg.sender] );\r\n        withdraw(msg.sender);\r\n\t}\r\n\r\n\tfunction reffUp(address _reff) internal{\r\n\t\taddress sender = msg.sender;\r\n\t\tif (_reff == 0x0000000000000000000000000000000000000000 || _reff == msg.sender)\r\n\t\t\t_reff = lastGateway;\r\n\t\t\t\r\n\t\tif(  holdings[_reff] >= stakingRequirement ) {\r\n\t\t\t//good to go. good gateway\r\n\t\t}else{\r\n\t\t\tif(lastGateway == 0x0000000000000000000000000000000000000000){\r\n\t\t\t\tlastGateway = sender;//first buyer ever\r\n\t\t\t\t_reff = sender;//first buyer is their own gateway/masternode\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\t_reff = lastGateway;//the lucky last player gets to be the gate way.\r\n\t\t}\r\n\t\treff[sender] = _reff;\r\n\t}\r\n\tfunction rgbLimit(uint256 _rgb)internal pure returns(uint256){\r\n\t\tif(_rgb > 255)\r\n\t\t\treturn 255;\r\n\t\telse\r\n\t\t\treturn _rgb;\r\n\t}\r\n\t//BONUS\r\n\t//when you don't pick a color, the contract will need a default. which will be your current color\r\n\t/*function edgePigmentR()internal view returns (uint256 x)\r\n\t{if(holdings[msg.sender]==0)return 0;else return 255 * souleculeR[msg.sender]/holdings[msg.sender];}\r\n\tfunction edgePigmentG()internal view returns (uint256 x)\r\n\t{if(holdings[msg.sender]==0)return 0;else return 255 * souleculeG[msg.sender]/holdings[msg.sender];}\r\n\tfunction edgePigmentB()internal view returns (uint256 x)\r\n\t{if(holdings[msg.sender]==0)return 0;else return 255 * souleculeB[msg.sender]/holdings[msg.sender];}*/\r\n\tfunction edgePigment(uint8 C)internal view returns (uint256 x)\r\n\t{\t\r\n\t\tuint256 holding = holdings[msg.sender];\r\n\t\tif(holding==0)\r\n\t\t\treturn 0;\r\n\t\telse{\r\n\t\t\tif(C==0){\r\n\t\t\t\treturn 255 * souleculeR[msg.sender]/holding;\r\n\t\t\t}else if(C==1){\r\n\t\t\t\treturn 255 * souleculeG[msg.sender]/holding;\r\n\t\t\t}else if(C==2){\r\n\t\t\t\treturn 255 * souleculeB[msg.sender]/holding;\r\n\t\t\t}\r\n\t\t} \r\n\t}\r\n\tfunction fund(address reffo, address forWho) payable public {\r\n\t\tfund_color( reffo, forWho, edgePigment(0),edgePigment(1),edgePigment(2) );\r\n\t}\r\n\tfunction fund_color( address _reff, address forWho,uint256 soulR,uint256 soulG,uint256 soulB) payable public {\r\n\t\t// Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\n\t\treffUp(_reff);\r\n\t\tif (msg.value > 0.000001 ether){\r\n\t\t\tinvestSum += msg.value;\r\n\t\t\tsoulR=rgbLimit(soulR);\r\n\t\t\tsoulG=rgbLimit(soulG);\r\n\t\t\tsoulB=rgbLimit(soulB);\r\n\t\t    buy( forWho ,soulR,soulG,soulB);\r\n\t\t\tlastGateway = msg.sender;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n    }\r\n\r\n    function reinvest_color(uint256 soulR,uint256 soulG,uint256 soulB) public {\r\n    \tsoulR=rgbLimit(soulR);\r\n\t\tsoulG=rgbLimit(soulG);\r\n\t\tsoulB=rgbLimit(soulB);\r\n\t\tprocessReinvest( soulR,soulG,soulB);\r\n\t}\r\n    function reinvest() public {\r\n\t\tprocessReinvest( edgePigment(0),edgePigment(1),edgePigment(2) );\r\n\t}\r\n\r\n\t// Function that returns the (dynamic) price of a single token.\r\n\tfunction price(bool buyOrSell) public constant returns (uint) {\r\n        if(buyOrSell){\r\n        \treturn getTokensForEther(1 finney);\r\n        }else{\r\n        \tuint256 eth = getEtherForTokens(1 finney);\r\n\t        uint256 fee = fluxFeed(eth, false, false);\r\n\t        return eth - fee;\r\n        }\r\n    }\r\n\r\n\tfunction fluxFeed(uint256 _eth, bool slim_reinvest,bool buyOrSell) public constant returns (uint256 amount) {\t\r\n\t\tuint8 bonus;\r\n\t\tif(slim_reinvest){\r\n\t\t\tbonus = 3;\r\n\t\t\t/*\r\n\t\t\tFor the ecosystem:\r\n\t\t\tReinvest discount = FluxFee * resolveGroupWithdrawnChoiceSum / ( resolveGroupWithdrawnChoiceSum + resolveGroupReinvestChoiceSum )\r\n\t\t\t\r\n\t\t\tThe reinvest discounted price is equal to the flux'd fee multiplied by\r\n\t\t\tthe sum of ETH chosen to be withdrawn from the pyramid's resolve type divided by\r\n\t\t\tthe sum of BOTH ETH chosen to be withdrawn AND chosen to be reinvested in the same type.\r\n\t\t\t\r\n\t\t\tThis means that the more your community reinvests in another, the better your reinvest deal.\r\n\t\t\t*/\r\n\t\t}else{\r\n\t\t\tbonus = 1;\r\n\t\t}\r\n\t\tif(buyOrSell)\r\n\t\t\treturn  _eth/bonus * withdrawSum/(investSum);//we've already added it in.\r\n\t\telse\r\n\t\t\treturn  _eth/bonus * (withdrawSum + _eth)/investSum;\r\n\t\r\n\t\t//gotta multiply and stuff in that order in order to get a high precision taxed amount.\r\n\t\t//because grouping (withdrawSum / investSum) can't return a precise decimal.\r\n\t\t//so instead we expand the value by multiplying then shrink it. by the denominator\r\n\r\n\t\t/*\r\n\t\t100eth IN & 100eth OUT = 100% tax fee (returning 1) !!!\r\n\t\t100eth IN & 50eth OUT = 50% tax fee (returning 2)\r\n\t\t100eth IN & 33eth OUT = 33% tax fee (returning 3)\r\n\t\t100eth IN & 25eth OUT = 25% tax fee (returning 4)\r\n\t\t100eth IN & 10eth OUT = 10% tax fee (returning 10)\r\n\r\n\t\t!!! keep in mind there is no fee if there are no holders. So if 100% of the eth has left\r\n\t\tthe contract that means there can't possibly be holders to tax you. Funny how that works.\r\n\r\n\t\tThe flux fee also forces communities to help eachother more and more if the value drops.\r\n\t\t*/\r\n\t}\r\n\r\n\t// Calculate the current dividends associated with the caller address. This is the net result\r\n\t// of multiplying the number of tokens held by their current value in Ether and subtracting the\r\n\t// Ether that has already been paid out.\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\n\t\treturn (uint256) ((int256)( earningsPerBond * holdings[_owner] ) - payouts[_owner] ) / scaleFactor;\r\n\t}\r\n\tfunction cashWallet(address _owner) public constant returns (uint256 amount) {\r\n\t\treturn dividends(_owner)+pocket[_owner];\r\n\t}\r\n\r\n\t// Internal balance function, used to calculate the dynamic reserve value.\r\n\tfunction contractBalance() internal constant returns (uint256 amount){\r\n\t\t// msg.value is the amount of Ether sent by the transaction.\r\n\t\treturn investSum - withdrawSum - msg.value - trickleSum;\r\n\t}\r\n\t\t\t\tfunction trickleUp() internal{\r\n\t\t\t\t\tuint256 tricks = tricklingFlo[ msg.sender ];//this is the amount moving in the trickle flo\r\n\t\t\t\t\tif(tricks > 0){\r\n\t\t\t\t\t\ttricklingFlo[ msg.sender ] = 0;//we've already captured the amount so set your tricklingFlo flo to 0\r\n\t\t\t\t\t\tuint256 passUp = tricks/trickTax;//to get the amount we're gonna pass up. divide by trickTax\r\n\t\t\t\t\t\tuint256 reward = tricks-passUp;//and our remaining reward for ourselves is the amount we just slice off subtracted from the flo\r\n\t\t\t\t\t\taddress finalReff;//we're not exactly sure who we're gonna pass this up to yet\r\n\t\t\t\t\t\taddress reffo =  reff[msg.sender];//this is who it should go up to. if everything is legit\r\n\t\t\t\t\t\tif( holdings[reffo] >= stakingRequirement){\r\n\t\t\t\t\t\t\tfinalReff = reffo;//if that address is holding enough to stake, it's a legit node to flo up to.\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tfinalReff = lastGateway;//if not, then we use the last buyer\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttricklingFlo[ finalReff ] += passUp;//so now we add that flo you've passed up to the tricklingFlo of the final Reff\r\n\t\t\t\t\t\tpocket[ msg.sender ] += reward;// oh yeah... and that reward... I gotchu\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfunction buy(address forWho,uint256 soulR,uint256 soulG,uint256 soulB) internal {\r\n\t\t\t\t\t\t\t\t\t// Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\n\t\t\t\t\t\t\t\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\n\t\t\t\t\t\t\t\t\t\trevert();\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t//Fee to pay existing holders, and the referral commission\r\n\t\t\t\t\t\t\t\t\tuint256 fee = 0; \r\n\t\t\t\t\t\t\t\t\tuint256 trickle = 0; \r\n\t\t\t\t\t\t\t\t\tif(holdings[forWho] != totalBondSupply){\r\n\t\t\t\t\t\t\t\t\t\tfee = fluxFeed(msg.value,false,true);\r\n\t\t\t\t\t\t\t\t\t\ttrickle = fee/trickTax;\r\n\t\t\t\t\t\t\t\t\t\tfee = fee - trickle;\r\n\t\t\t\t\t\t\t\t\t\ttricklingFlo[forWho] += trickle;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tuint256 numEther = msg.value - (fee+trickle);// The amount of Ether used to purchase new tokens for the caller.\r\n\t\t\t\t\t\t\t\t\tuint256 numTokens = getTokensForEther(numEther);// The number of tokens which can be purchased for numEther.\r\n\r\n\t\t\t\t\t\t\t\t\tbuyCalcAndPayout( forWho, fee, numTokens, numEther, reserve() );\r\n\r\n\t\t\t\t\t\t\t\t\taddPigment(numTokens,soulR,soulG,soulB);\r\n\r\n\t\t\t\t\t\t\t\t\ttrickleSum += trickle;//add to trickle's Sum after reserve calculations\r\n\t\t\t\t\t\t\t\t\ttrickleUp();\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\temit onTokenPurchase(forWho, numEther ,numTokens , reff[msg.sender]);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif(forWho != msg.sender){//make sure you're not yourself\r\n\t\t\t\t\t\t\t\t\t\t//if forWho doesn't have a reff, then reset it\r\n\t\t\t\t\t\t\t\t\t\tif(reff[forWho] == 0x0000000000000000000000000000000000000000)\r\n\t\t\t\t\t\t\t\t\t\t\t{reff[forWho] = msg.sender;}\r\n\t\t\t\t\t\t\t\t\t\t\temit onBoughtFor(msg.sender, forWho,numEther,numTokens,reff[msg.sender]);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfunction buyCalcAndPayout(address forWho,uint256 fee,uint256 numTokens,uint256 numEther,uint256 res)internal{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The buyer fee, scaled by the scaleFactor variable.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 buyerFee = fee * scaleFactor;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (totalBondSupply > 0){// because ...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Compute the bonus co-efficient for all existing holders and the buyer.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The buyer receives part of the distribution for each token bought in the\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// same way they would have if they bought each token individually.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 bonusCoEff = (scaleFactor - (res + numEther) * numTokens * scaleFactor / ( totalBondSupply  + numTokens) / numEther)\r\n\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t*(uint)(crr_d) / (uint)(crr_d-crr_n);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The total reward to be distributed amongst the masses is the fee (in Ether)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// multiplied by the bonus co-efficient.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 holderReward = fee * bonusCoEff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuyerFee -= holderReward;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearningsPerBond +=  holderReward / totalBondSupply;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//resolve reward tracking stuff\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tavgFactor_ethSpent[forWho] += numEther;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttotalBondSupply += numTokens;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Assign the tokens to the balance of the buyer.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tholdings[forWho] += numTokens;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Also include the fee paid for entering the scheme.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// First we compute how much was just paid out to the buyer...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint256 payoutDiff = (int256) ((earningsPerBond * numTokens) - buyerFee);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Then we update the payouts array for the buyer with this amount...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayouts[forWho] += payoutDiff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttotalPayouts += payoutDiff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\n\t\t\t\t\t\t\t\t// to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\n\t\t\t\t\t\t\t\t// will be *significant*.\r\n\t\t\t\t\t\t\t\tfunction TOKEN_scaleDown(uint256 value,uint256 reduce) internal view returns(uint256 x){\r\n\t\t\t\t\t\t\t\t\tuint256 holdingsOfSender = holdings[msg.sender];\r\n\t\t\t\t\t\t\t\t\treturn value * ( holdingsOfSender - reduce) / holdingsOfSender;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfunction sell(uint256 amount) internal {\r\n\t\t\t\t\t\t\t\t    uint256 numEthersBeforeFee = getEtherForTokens(amount);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// x% of the resulting Ether is used to pay remaining holders.\r\n\t\t\t\t\t\t\t\t\tuint256 fee = 0;\r\n\t\t\t\t\t\t\t\t\tuint256 trickle = 0;\r\n\t\t\t\t\t\t\t\t\tif(totalBondSupply != holdings[msg.sender]){\r\n\t\t\t\t\t\t\t\t\t\tfee = fluxFeed(numEthersBeforeFee, false,false);\r\n\t\t\t\t\t\t\t        \ttrickle = fee/ trickTax;\r\n\t\t\t\t\t\t\t\t\t\tfee -= trickle;\r\n\t\t\t\t\t\t\t\t\t\ttricklingFlo[msg.sender] +=trickle;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Net Ether for the seller after the fee has been subtracted.\r\n\t\t\t\t\t\t\t        uint256 numEthers = numEthersBeforeFee - (fee+trickle);\r\n\r\n\t\t\t\t\t\t\t\t\t//How much you bought it for divided by how much you're getting back.\r\n\t\t\t\t\t\t\t\t\t//This means that if you get dumped on, you can get more resolve tokens if you sell out.\r\n\t\t\t\t\t\t\t\t\tuint256 resolved = mint(\r\n\t\t\t\t\t\t\t\t\t\tcalcResolve(msg.sender,amount,numEthersBeforeFee),\r\n\t\t\t\t\t\t\t\t\t\tmsg.sender\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\t// *Remove* the numTokens which were just sold from the total supply.\r\n\t\t\t\t\t\t\t\t\tavgFactor_ethSpent[msg.sender] = TOKEN_scaleDown(avgFactor_ethSpent[msg.sender] , amount);\r\n\r\n\t\t\t\t\t\t\t\t\tsouleculeR[msg.sender] = TOKEN_scaleDown(souleculeR[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\tsouleculeG[msg.sender] = TOKEN_scaleDown(souleculeG[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\tsouleculeB[msg.sender] = TOKEN_scaleDown(souleculeB[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\ttotalBondSupply -= amount;\r\n\t\t\t\t\t\t\t\t\t// Remove the tokens from the balance of the buyer.\r\n\t\t\t\t\t\t\t\t\tholdings[msg.sender] -= amount;\r\n\r\n\t\t\t\t\t\t\t\t\tint256 payoutDiff = (int256) (earningsPerBond * amount);//we don't add in numETH because it is immedietly paid out.\r\n\t\t\r\n\t\t\t\t\t\t\t        // We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\n\t\t\t\t\t\t\t\t\t// since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\n\t\t\t\t\t\t\t\t\t// they decide to buy back in.\r\n\t\t\t\t\t\t\t\t\tpayouts[msg.sender] -= payoutDiff;\t\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Decrease the total amount that's been paid out to maintain invariance.\r\n\t\t\t\t\t\t\t        totalPayouts -= payoutDiff;\r\n\t\t\t\t\t\t\t        \r\n\r\n\t\t\t\t\t\t\t\t\t// Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\n\t\t\t\t\t\t\t\t\t// selling tokens, but it guards against division by zero).\r\n\t\t\t\t\t\t\t\t\tif (totalBondSupply > 0) {\r\n\t\t\t\t\t\t\t\t\t\t// Scale the Ether taken as the selling fee by the scaleFactor variable.\r\n\t\t\t\t\t\t\t\t\t\tuint256 etherFee = fee * scaleFactor;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// Fee is distributed to all remaining token holders.\r\n\t\t\t\t\t\t\t\t\t\t// rewardPerShare is the amount gained per token thanks to this sell.\r\n\t\t\t\t\t\t\t\t\t\tuint256 rewardPerShare = etherFee / totalBondSupply;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\t\t\t\t\t\t\t\tearningsPerBond +=  rewardPerShare;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tfullCycleSellBonds(numEthers);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\ttrickleSum += trickle;\r\n\t\t\t\t\t\t\t\t\ttrickleUp();\r\n\t\t\t\t\t\t\t\t\temit onTokenSell(msg.sender,holdings[msg.sender]+amount,amount,numEthers,resolved);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t// Converts the Ether accrued as dividends back into Staking tokens without having to\r\n\t\t\t\t// withdraw it first. Saves on gas and potential price spike loss.\r\n\t\t\t\tfunction processReinvest(uint256 soulR,uint256 soulG,uint256 soulB) internal{\r\n\t\t\t\t\t// Retrieve the dividends associated with the address the request came from.\r\n\t\t\t\t\tuint256 balance = dividends(msg.sender);\r\n\r\n\t\t\t\t\t// Update the payouts array, incrementing the request address by `balance`.\r\n\t\t\t\t\t// Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\n\t\t\t\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\t\t\t\ttotalPayouts += (int256) (balance * scaleFactor);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t// Assign balance to a new variable.\r\n\t\t\t\t\tuint256 pocketETH = pocket[msg.sender];\r\n\t\t\t\t\tuint value_ = (uint) (balance + pocketETH);\r\n\t\t\t\t\tpocket[msg.sender] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If your dividends are worth less than 1 szabo, or more than a million Ether\r\n\t\t\t\t\t// (in which case, why are you even here), abort.\r\n\t\t\t\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\n\t\t\t\t\t\trevert();\r\n\r\n\t\t\t\t\tuint256 fee = 0; \r\n\t\t\t\t\tuint256 trickle = 0;\r\n\t\t\t\t\tif(holdings[msg.sender] != totalBondSupply){\r\n\t\t\t\t\t\tfee = fluxFeed(value_, true,true );// reinvestment fees are lower than regular ones.\r\n\t\t\t\t\t\ttrickle = fee/ trickTax;\r\n\t\t\t\t\t\tfee = fee - trickle;\r\n\t\t\t\t\t\ttricklingFlo[msg.sender] += trickle;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\n\t\t\t\t\t// (Yes, the buyer receives a part of the distribution as well!)\r\n\t\t\t\t\tuint256 res = reserve() - balance;\r\n\r\n\t\t\t\t\t// The amount of Ether used to purchase new tokens for the caller.\r\n\t\t\t\t\tuint256 numEther = value_ - (fee+trickle);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// The number of tokens which can be purchased for numEther.\r\n\t\t\t\t\tuint256 numTokens = calculateDividendTokens(numEther, balance);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuyCalcAndPayout( msg.sender, fee, numTokens, numEther, res );\r\n\r\n\t\t\t\t\taddPigment(numTokens,soulR,soulG,soulB);\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\ttrickleUp();\r\n\t\t\t\t\t//trickleSum -= pocketETH;\r\n\t\t\t\t\ttrickleSum += trickle - pocketETH;\r\n\t\t\t\t\temit onReinvestment(msg.sender,numEther,numTokens);\r\n\t\t\t\t\tif(msg.sender != msg.sender){//make sure you're not yourself\r\n\t\t\t\t\t\t//if forWho doesn't have a reff, then reset it\r\n\t\t\t\t\t\tif(reff[msg.sender] == 0x0000000000000000000000000000000000000000)\r\n\t\t\t\t\t\t\t{reff[msg.sender] = msg.sender;}\r\n\t\t\t\t\t\t\temit onBoughtFor(msg.sender, msg.sender,numEther,numTokens,reff[msg.sender]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\tfunction addPigment(uint256 tokens,uint256 r,uint256 g,uint256 b) internal{\r\n\t\tsouleculeR[msg.sender] += tokens * r / 255;\r\n\t\tsouleculeG[msg.sender] += tokens * g / 255;\r\n\t\tsouleculeB[msg.sender] += tokens * b / 255;\r\n\t\temit onColor(msg.sender,r,g,b,souleculeR[msg.sender] ,souleculeG[msg.sender] ,souleculeB[msg.sender] );\r\n\t}\r\n\t// Dynamic value of Ether in reserve, according to the CRR requirement.\r\n\tfunction reserve() internal constant returns (uint256 amount){\r\n\t\treturn contractBalance()-((uint256) ((int256) (earningsPerBond * totalBondSupply) - totalPayouts ) / scaleFactor);\r\n\t}\r\n\r\n\t// Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\n\t// dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\n\t\treturn fixedExp(fixedLog(reserve() + ethervalue)*crr_n/crr_d + price_coeff) - totalBondSupply ;\r\n\t}\r\n\r\n\t// Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\n\t\treturn fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff) -  totalBondSupply;\r\n\t}\r\n\r\n\t// Converts a number tokens into an Ether value.\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\n\t\t// How much reserve Ether do we have left in the contract?\r\n\t\tuint256 reserveAmount = reserve();\r\n\r\n\t\t// If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\n\t\tif (tokens == totalBondSupply )\r\n\t\t\treturn reserveAmount;\r\n\r\n\t\t// If there would be excess Ether left after the transaction this is called within, return the Ether\r\n\t\t// corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\n\t\t// at https://test.jochen-hoenicke.de/eth/ponzitoken/ in the third equation, with the CRR numerator \r\n\t\t// and denominator altered to 1 and 2 respectively.\r\n\t\treturn reserveAmount - fixedExp((fixedLog(totalBondSupply  - tokens) - price_coeff) * crr_d/crr_n);\r\n\t}\r\n\r\n\tfunction () payable public {\r\n\t\tif (msg.value > 0) {\r\n\t\t\tfund(lastGateway,msg.sender);\r\n\t\t} else {\r\n\t\t\twithdraw(msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\taddress public resolver = this;\r\n\t\t\t\t\t\t\t\t\t\tuint256 public totalSupply;\r\n\t\t\t\t\t\t\t\t\t\tuint256 public totalBurned;\r\n\t\t\t\t\t\t\t\t\t    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n\t\t\t\t\t\t\t\t\t    mapping (address => uint256) public balances;\r\n\t\t\t\t\t\t\t\t\t    mapping (address => uint256) public burned;\r\n\t\t\t\t\t\t\t\t\t    mapping (address => mapping (address => uint256)) public allowed;\r\n\t\t\t\t\t\t\t\t\t    \r\n\t\t\t\t\t\t\t\t\t    string public name = \"0xBabylon\";//yes, this is still the CODE name\r\n\t\t\t\t\t\t\t\t\t    uint8 public decimals = 18;\r\n\t\t\t\t\t\t\t\t\t    string public symbol = \"PoWHr\";//PoWHr Brokers\r\n\t\t\t\t\t\t\t\t\t    \r\n\t\t\t\t\t\t\t\t\t    event Transfer(address indexed _from, address indexed _to, uint256 _value); \r\n\t\t\t\t\t\t\t\t\t    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t\t\t\t\t\t\t\t\t    event Resolved(address indexed _owner, uint256 amount);\r\n\t\t\t\t\t\t\t\t\t    event Burned(address indexed _owner, uint256 amount);\r\n\r\n\t\t\t\t\t\t\t\t\t    function mint(uint256 amount,address _account) internal returns (uint minted){\r\n\t\t\t\t\t\t\t\t\t    \ttotalSupply += amount;\r\n\t\t\t\t\t\t\t\t\t    \tbalances[_account] += amount;\r\n\t\t\t\t\t\t\t\t\t    \temit Resolved(_account,amount);\r\n\t\t\t\t\t\t\t\t\t    \treturn amount;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\t\t\t\t\t\t\t\t        return balances[_owner]-burned[_owner];\r\n\t\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t\t    \r\n\t\t\t\t\t\t\t\t\t\tfunction burn(uint256 _value) public returns (uint256 amount) {\r\n\t\t\t\t\t\t\t\t\t        require( balanceOf(msg.sender) >= _value);\r\n\t\t\t\t\t\t\t\t\t        totalBurned += _value;\r\n\t\t\t\t\t\t\t\t\t    \tburned[msg.sender] += _value;\r\n\t\t\t\t\t\t\t\t\t    \temit Burned(msg.sender,_value);\r\n\t\t\t\t\t\t\t\t\t    \treturn _value;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t\tfunction calcResolve(address _owner,uint256 amount,uint256 _eth) public constant returns (uint256 calculatedResolveTokens) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn amount*amount*avgFactor_ethSpent[_owner]/holdings[_owner]/_eth;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t\t\t\t\t\t\t\t        require( balanceOf(msg.sender) >= _value);\r\n\t\t\t\t\t\t\t\t\t        balances[msg.sender] -= _value;\r\n\t\t\t\t\t\t\t\t\t        balances[_to] += _value;\r\n\t\t\t\t\t\t\t\t\t        emit Transfer(msg.sender, _to, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\r\n\t\t\t\t\t\t\t\t\t        uint256 allowance = allowed[_from][msg.sender];\r\n\t\t\t\t\t\t\t\t\t        require(    balanceOf(_from)  >= _value && allowance >= _value );\r\n\t\t\t\t\t\t\t\t\t        balances[_to] += _value;\r\n\t\t\t\t\t\t\t\t\t        balances[_from] -= _value;\r\n\t\t\t\t\t\t\t\t\t        if (allowance < MAX_UINT256) {\r\n\t\t\t\t\t\t\t\t\t            allowed[_from][msg.sender] -= _value;\r\n\t\t\t\t\t\t\t\t\t        }\r\n\t\t\t\t\t\t\t\t\t        emit Transfer(_from, _to, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\t\t\t\t\t\t\t\t        allowed[msg.sender][_spender] = _value;\r\n\t\t\t\t\t\t\t\t\t        emit Approval(msg.sender, _spender, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function resolveSupply() public view returns (uint256 balance) {\r\n\t\t\t\t\t\t\t\t\t        return totalSupply-totalBurned;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n\t\t\t\t\t\t\t\t\t        return allowed[_owner][_spender];\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n    // You don't care about these, but if you really do they're hex values for \r\n\t// co-efficients used to simulate approximations of the log and exp functions.\r\n\tint256  constant one        = 0x10000000000000000;\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\n\r\n\t// The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\n\t// approximates the function log(1+x)-log(1-x)\r\n\t// Hence R(s) = log((1+s)/(1-s)) = log(a)\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\n\t\tint32 scale = 0;\r\n\t\twhile (a > sqrt2) {\r\n\t\t\ta /= 2;\r\n\t\t\tscale++;\r\n\t\t}\r\n\t\twhile (a <= sqrtdot5) {\r\n\t\t\ta *= 2;\r\n\t\t\tscale--;\r\n\t\t}\r\n\t\tint256 s = (((int256)(a) - one) * one) / ((int256)(a) + one);\r\n\t\tint256 z = (s*s) / one;\r\n\t\treturn scale * ln2 +\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one))\r\n\t\t\t\t/one))/one))/one))/one))/one);\r\n\t}\r\n\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\n\r\n\t// The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\n\t// approximates the function x*(exp(x)+1)/(exp(x)-1)\r\n\t// Hence exp(x) = (R(x)+x)/(R(x)-x)\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\n\t\tint256 scale = (a + (ln2_64dot5)) / ln2 - 64;\r\n\t\ta -= scale*ln2;\r\n\t\tint256 z = (a*a) / one;\r\n\t\tint256 R = ((int256)(2) * one) +\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one);\r\n\t\texp = (uint256) (((R + a) * one) / (R - a));\r\n\t\tif (scale >= 0)\r\n\t\t\texp <<= scale;\r\n\t\telse\r\n\t\t\texp >>= -scale;\r\n\t\treturn exp;\r\n\t}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"holdingsOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"slim_reinvest\",\"type\":\"bool\"},{\"name\":\"buyOrSell\",\"type\":\"bool\"}],\"name\":\"fluxFeed\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBondSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"avgFactor_ethSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcResolve\",\"outputs\":[{\"name\":\"calculatedResolveTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolveSupply\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trickleSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"cashWallet\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"name\":\"getTokensForEther\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payouts\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyOrSell\",\"type\":\"bool\"}],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"souleculeB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reff\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastGateway\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reffo\",\"type\":\"address\"},{\"name\":\"forWho\",\"type\":\"address\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMeOutOfHere\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"getEtherForTokens\",\"outputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"},{\"name\":\"subvalue\",\"type\":\"uint256\"}],\"name\":\"calculateDividendTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"souleculeG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holdings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pocket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"soulR\",\"type\":\"uint256\"},{\"name\":\"soulG\",\"type\":\"uint256\"},{\"name\":\"soulB\",\"type\":\"uint256\"}],\"name\":\"reinvest_color\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tricklingFlo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellBonds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"souleculeR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reff\",\"type\":\"address\"},{\"name\":\"forWho\",\"type\":\"address\"},{\"name\":\"soulR\",\"type\":\"uint256\"},{\"name\":\"soulG\",\"type\":\"uint256\"},{\"name\":\"soulB\",\"type\":\"uint256\"}],\"name\":\"fund_color\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"forWho\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onBoughtFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalTokensAtTheTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolved\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onCashDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldR\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldG\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newR\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newG\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newB\",\"type\":\"uint256\"}],\"name\":\"onColor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Resolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"}]", "ContractName": "PeerLicensing", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e3c044986c5d986408ea69871de2e6d5f8d81412bef9b3e59cf6e1c787ff4187"}