{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHasher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IHasher {\\n  function poseidon(bytes32[2] calldata inputs) external pure returns (bytes32);\\n\\n  function poseidon(bytes32[3] calldata inputs) external pure returns (bytes32);\\n\\n  function MiMCSponge(\\n    uint256 in_xL,\\n    uint256 in_xR\\n  ) external pure returns (uint256 xL, uint256 xR);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITornadoTrees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ITornadoTrees {\\n  function registerDeposit(address instance, bytes32 commitment) external;\\n\\n  function registerWithdrawal(address instance, bytes32 nullifier) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/OwnableMerkleTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../tornado-core/MerkleTreeWithHistoryPoseidon.sol\\\";\\n\\ncontract OwnableMerkleTree is Ownable, MerkleTreeWithHistoryPoseidon {\\n  constructor(uint32 _treeLevels, IHasher _hasher) MerkleTreeWithHistoryPoseidon(_treeLevels, _hasher) {}\\n\\n  function insert(bytes32 _leaf) external onlyOwner returns (uint32 index) {\\n    return _insert(_leaf);\\n  }\\n\\n  function bulkInsert(bytes32[] calldata _leaves) external onlyOwner {\\n    _bulkInsert(_leaves);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tornado-core/MerkleTreeWithHistoryPoseidon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"../interfaces/IHasher.sol\\\";\\r\\n\\r\\ncontract MerkleTreeWithHistoryPoseidon {\\r\\n    uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\r\\n    uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\\\"tornado\\\") % FIELD_SIZE\\r\\n\\r\\n    uint32 public immutable levels;\\r\\n    IHasher public hasher; // todo immutable\\r\\n\\r\\n    bytes32[] public filledSubtrees;\\r\\n    bytes32[] public zeros;\\r\\n    uint32 public currentRootIndex = 0;\\r\\n    uint32 public nextIndex = 0;\\r\\n    uint32 public constant ROOT_HISTORY_SIZE = 10;\\r\\n    bytes32[ROOT_HISTORY_SIZE] public roots;\\r\\n\\r\\n    constructor(uint32 _treeLevels, IHasher _hasher) public {\\r\\n        require(_treeLevels > 0, \\\"_treeLevels should be greater than zero\\\");\\r\\n        require(_treeLevels < 32, \\\"_treeLevels should be less than 32\\\");\\r\\n        levels = _treeLevels;\\r\\n        hasher = _hasher;\\r\\n\\r\\n        bytes32 currentZero = bytes32(ZERO_VALUE);\\r\\n        zeros.push(currentZero);\\r\\n        filledSubtrees.push(currentZero);\\r\\n\\r\\n        for (uint32 i = 1; i < _treeLevels; i++) {\\r\\n            currentZero = hashLeftRight(currentZero, currentZero);\\r\\n            zeros.push(currentZero);\\r\\n            filledSubtrees.push(currentZero);\\r\\n        }\\r\\n\\r\\n        filledSubtrees.push(hashLeftRight(currentZero, currentZero));\\r\\n        roots[0] = filledSubtrees[_treeLevels];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n@dev Hash 2 tree leaves, returns poseidon(_left, _right)\\r\\n  */\\r\\n    function hashLeftRight(bytes32 _left, bytes32 _right) public view returns (bytes32) {\\r\\n        return hasher.poseidon([_left, _right]);\\r\\n    }\\r\\n\\r\\n    function _insert(bytes32 _leaf) internal returns (uint32 index) {\\r\\n        uint32 currentIndex = nextIndex;\\r\\n        require(currentIndex != uint32(2)**levels, \\\"Merkle tree is full. No more leaves can be added\\\");\\r\\n        nextIndex = currentIndex + 1;\\r\\n        bytes32 currentLevelHash = _leaf;\\r\\n        bytes32 left;\\r\\n        bytes32 right;\\r\\n\\r\\n        for (uint32 i = 0; i < levels; i++) {\\r\\n            if (currentIndex % 2 == 0) {\\r\\n                left = currentLevelHash;\\r\\n                right = zeros[i];\\r\\n                filledSubtrees[i] = currentLevelHash;\\r\\n            } else {\\r\\n                left = filledSubtrees[i];\\r\\n                right = currentLevelHash;\\r\\n            }\\r\\n\\r\\n            currentLevelHash = hashLeftRight(left, right);\\r\\n            currentIndex /= 2;\\r\\n        }\\r\\n\\r\\n        currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\\r\\n        roots[currentRootIndex] = currentLevelHash;\\r\\n        return nextIndex - 1;\\r\\n    }\\r\\n\\r\\n    function _bulkInsert(bytes32[] memory _leaves) internal {\\r\\n        uint32 insertIndex = nextIndex;\\r\\n        require(insertIndex + _leaves.length <= uint32(2)**levels, \\\"Merkle doesn't have enough capacity to add specified leaves\\\");\\r\\n\\r\\n        bytes32[] memory subtrees = new bytes32[](levels);\\r\\n        bool[] memory modifiedSubtrees = new bool[](levels);\\r\\n        for (uint32 j = 0; j < _leaves.length - 1; j++) {\\r\\n            uint256 index = insertIndex + j;\\r\\n            bytes32 currentLevelHash = _leaves[j];\\r\\n\\r\\n            for (uint32 i = 0; ; i++) {\\r\\n                if (index % 2 == 0) {\\r\\n                    modifiedSubtrees[i] = true;\\r\\n                    subtrees[i] = currentLevelHash;\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                if (subtrees[i] == bytes32(0)) {\\r\\n                    subtrees[i] = filledSubtrees[i];\\r\\n                }\\r\\n                currentLevelHash = hashLeftRight(subtrees[i], currentLevelHash);\\r\\n                index /= 2;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (uint32 i = 0; i < levels; i++) {\\r\\n            // using local map to save on gas on writes if elements were not modified\\r\\n            if (modifiedSubtrees[i]) {\\r\\n                filledSubtrees[i] = subtrees[i];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        nextIndex = uint32(insertIndex + _leaves.length - 1);\\r\\n        _insert(_leaves[_leaves.length - 1]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n@dev Whether the root is present in the root history\\r\\n  */\\r\\n    function isKnownRoot(bytes32 _root) public view returns (bool) {\\r\\n        if (_root == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        uint32 i = currentRootIndex;\\r\\n        do {\\r\\n            if (_root == roots[i]) {\\r\\n                return true;\\r\\n            }\\r\\n            if (i == 0) {\\r\\n                i = ROOT_HISTORY_SIZE;\\r\\n            }\\r\\n            i--;\\r\\n        } while (i != currentRootIndex);\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n@dev Returns the last root\\r\\n  */\\r\\n    function getLastRoot() public view returns (bytes32) {\\r\\n        return roots[currentRootIndex];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tornado-core/TornadoTrees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libs/OwnableMerkleTree.sol\\\";\\nimport \\\"../interfaces/ITornadoTrees.sol\\\";\\nimport \\\"../interfaces/IHasher.sol\\\";\\n\\ncontract TornadoTrees is ITornadoTrees {\\n  OwnableMerkleTree public immutable depositTree;\\n  OwnableMerkleTree public immutable withdrawalTree;\\n  IHasher public immutable hasher;\\n  address public pgRouter;\\n\\n  event DepositData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\n  event WithdrawalData(address instance, bytes32 indexed hash, uint256 block, uint256 index);\\n\\n  struct TreeLeaf {\\n    address instance;\\n    bytes32 hash;\\n    uint256 block;\\n  }\\n\\n  modifier onlyPgRouter {\\n    require(msg.sender == pgRouter, \\\"Not authorized\\\");\\n    _;\\n  }\\n\\n  constructor(\\n    address _pgRouter,\\n    address _hasher2,\\n    address _hasher3,\\n    uint32 _levels\\n  ) {\\n    pgRouter = _pgRouter;\\n    hasher = IHasher(_hasher3);\\n    depositTree = new OwnableMerkleTree(_levels, IHasher(_hasher2));\\n    withdrawalTree = new OwnableMerkleTree(_levels, IHasher(_hasher2));\\n  }\\n\\n  function registerDeposit(address _instance, bytes32 _commitment) external override onlyPgRouter {\\n    bytes32 leaf = hasher.poseidon([bytes32(uint256(uint160(_instance))), _commitment, bytes32(blockNumber())]);\\n    uint32 index = depositTree.insert(leaf);\\n    emit DepositData(_instance, _commitment, blockNumber(), uint256(index));\\n  }\\n\\n  function registerWithdrawal(address _instance, bytes32 _nullifier) external override onlyPgRouter {\\n    bytes32 leaf = hasher.poseidon([bytes32(uint256(uint160(_instance))), _nullifier, bytes32(blockNumber())]);\\n    uint32 index = withdrawalTree.insert(leaf);\\n    emit WithdrawalData(_instance, _nullifier, blockNumber(), uint256(index));\\n  }\\n\\n  function validateRoots(bytes32 _depositRoot, bytes32 _withdrawalRoot) public view {\\n    require(depositTree.isKnownRoot(_depositRoot), \\\"Incorrect deposit tree root\\\");\\n    require(withdrawalTree.isKnownRoot(_withdrawalRoot), \\\"Incorrect withdrawal tree root\\\");\\n  }\\n\\n  function depositRoot() external view returns (bytes32) {\\n    return depositTree.getLastRoot();\\n  }\\n\\n  function withdrawalRoot() external view returns (bytes32) {\\n    return withdrawalTree.getLastRoot();\\n  }\\n\\n  function withdrawalTreeSize() external view returns (uint32) {\\n    return withdrawalTree.nextIndex();\\n  }\\n\\n  function depositTreeSize() external view returns (uint32) {\\n    return depositTree.nextIndex();\\n  }\\n\\n  function blockNumber() public view virtual returns (uint256) {\\n    return block.number;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pgRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hasher2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hasher3\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_levels\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DepositData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"WithdrawalData\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"blockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositTree\",\"outputs\":[{\"internalType\":\"contract OwnableMerkleTree\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositTreeSize\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasher\",\"outputs\":[{\"internalType\":\"contract IHasher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pgRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"registerDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instance\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifier\",\"type\":\"bytes32\"}],\"name\":\"registerWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_depositRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_withdrawalRoot\",\"type\":\"bytes32\"}],\"name\":\"validateRoots\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalTree\",\"outputs\":[{\"internalType\":\"contract OwnableMerkleTree\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalTreeSize\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TornadoTrees", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009c7ebc6aa193a55d07ca38824181a8f26dde930a000000000000000000000000a40c47f764c8aa8e993bfac8e93204169779795a00000000000000000000000089d0a748851b69ca26e636864d8088b1dbe9f2200000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}