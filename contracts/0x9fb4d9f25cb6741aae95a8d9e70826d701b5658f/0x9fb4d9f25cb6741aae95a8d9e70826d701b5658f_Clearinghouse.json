{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/policies/Clearinghouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ERC4626} from \\\"solmate/mixins/ERC4626.sol\\\";\\nimport {IStaking} from \\\"interfaces/IStaking.sol\\\";\\n\\nimport {CoolerFactory, Cooler} from \\\"cooler/CoolerFactory.sol\\\";\\nimport {CoolerCallback} from \\\"cooler/CoolerCallback.sol\\\";\\n\\nimport {ROLESv1, RolesConsumer} from \\\"modules/ROLES/OlympusRoles.sol\\\";\\nimport {TRSRYv1} from \\\"modules/TRSRY/TRSRY.v1.sol\\\";\\nimport {MINTRv1} from \\\"modules/MINTR/MINTR.v1.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @title  Olympus Clearinghouse.\\n/// @notice Olympus Clearinghouse (Policy) Contract.\\n/// @dev    The Olympus Clearinghouse is a lending facility built on top of Cooler Loans. The Clearinghouse\\n///         ensures that OHM holders can take loans against their gOHM holdings according to the parameters\\n///         approved by the community in OIP-144 and its subsequent RFCs. The Clearinghouse parameters are\\n///         immutable, because of that, if backing was to increase substantially, a new governance process\\n///         to fork this implementation with upgraded parameters should take place.\\n///         Although the Cooler contracts allow lenders to transfer ownership of their repayment rights, the\\n///         Clearinghouse doesn't implement any functions to use that feature.\\ncontract Clearinghouse is Policy, RolesConsumer, CoolerCallback {\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error BadEscrow();\\n    error DurationMaximum();\\n    error OnlyBurnable();\\n    error TooEarlyToFund();\\n    error LengthDiscrepancy();\\n    error OnlyBorrower();\\n    error NotLender();\\n\\n    // --- EVENTS ----------------------------------------------------\\n\\n    /// @notice Logs whenever the Clearinghouse is deactivated.\\n    event Deactivate();\\n    /// @notice Logs whenever the Clearinghouse is reactivated.\\n    event Reactivate();\\n    /// @notice Logs whenever the treasury is defunded.\\n    event Defund(address token, uint256 amount);\\n    /// @notice Logs the balance change (in DAI terms) whenever a rebalance occurs.\\n    event Rebalance(bool defund, uint256 daiAmount);\\n\\n    // --- RELEVANT CONTRACTS ----------------------------------------\\n\\n    ERC20 public immutable dai; // Debt token\\n    ERC4626 public immutable sdai; // Idle DAI will be wrapped into sDAI\\n    ERC20 public immutable gohm; // Collateral token\\n    ERC20 public immutable ohm; // Unwrapped gOHM\\n    IStaking public immutable staking; // Necessary to unstake (and burn) OHM from defaults\\n\\n    // --- MODULES ---------------------------------------------------\\n\\n    TRSRYv1 public TRSRY; // Olympus V3 Treasury Module\\n    MINTRv1 public MINTR; // Olympus V3 Minter Module\\n\\n    // --- PARAMETER BOUNDS ------------------------------------------\\n\\n    uint256 public constant INTEREST_RATE = 5e15; // 0.5% anually\\n    uint256 public constant LOAN_TO_COLLATERAL = 3000e18; // 3,000 DAI/gOHM\\n    uint256 public constant DURATION = 121 days; // Four months\\n    uint256 public constant FUND_CADENCE = 7 days; // One week\\n    uint256 public constant FUND_AMOUNT = 18_000_000e18; // 18 million\\n    uint256 public constant MAX_REWARD = 1e17; // 0.1 gOHM\\n\\n    // --- STATE VARIABLES -------------------------------------------\\n\\n    /// @notice determines whether the contract can be funded or not.\\n    bool public active;\\n\\n    /// @notice timestamp at which the next rebalance can occur.\\n    uint256 public fundTime;\\n\\n    /// @notice Outstanding receivables.\\n    /// Incremented when a loan is taken or rolled.\\n    /// Decremented when a loan is repaid or collateral is burned.\\n    uint256 public interestReceivables;\\n    uint256 public principalReceivables;\\n\\n    // --- INITIALIZATION --------------------------------------------\\n\\n    constructor(\\n        address ohm_,\\n        address gohm_,\\n        address staking_,\\n        address sdai_,\\n        address coolerFactory_,\\n        address kernel_\\n    ) Policy(Kernel(kernel_)) CoolerCallback(coolerFactory_) {\\n        // Store the relevant contracts.\\n        ohm = ERC20(ohm_);\\n        gohm = ERC20(gohm_);\\n        staking = IStaking(staking_);\\n        sdai = ERC4626(sdai_);\\n        dai = ERC20(sdai.asset());\\n\\n        // Initialize the contract status and its funding schedule.\\n        active = true;\\n        fundTime = block.timestamp;\\n    }\\n\\n    /// @notice Default framework setup. Configure dependencies for olympus-v3 modules.\\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\\n    ///         policy in the olympus-v3 `Kernel`.\\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\\n        dependencies = new Keycode[](3);\\n        dependencies[0] = toKeycode(\\\"TRSRY\\\");\\n        dependencies[1] = toKeycode(\\\"MINTR\\\");\\n        dependencies[2] = toKeycode(\\\"ROLES\\\");\\n\\n        TRSRY = TRSRYv1(getModuleAddress(toKeycode(\\\"TRSRY\\\")));\\n        MINTR = MINTRv1(getModuleAddress(toKeycode(\\\"MINTR\\\")));\\n        ROLES = ROLESv1(getModuleAddress(toKeycode(\\\"ROLES\\\")));\\n\\n        // Approve MINTR for burning OHM (called here so that it is re-approved on updates)\\n        ohm.approve(address(MINTR), type(uint256).max);\\n    }\\n\\n    /// @notice Default framework setup. Request permissions for interacting with olympus-v3 modules.\\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse\\n    ///         policy in the olympus-v3 `Kernel`.\\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\\n        Keycode TRSRY_KEYCODE = toKeycode(\\\"TRSRY\\\");\\n\\n        requests = new Permissions[](4);\\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.increaseWithdrawApproval.selector);\\n        requests[2] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\\n        requests[3] = Permissions(toKeycode(\\\"MINTR\\\"), MINTR.burnOhm.selector);\\n    }\\n\\n    // --- OPERATION -------------------------------------------------\\n\\n    /// @notice Lend to a cooler.\\n    /// @dev    To simplify the UX and easily ensure that all holders get the same terms,\\n    ///         this function requests a new loan and clears it in the same transaction.\\n    /// @param  cooler_ to lend to.\\n    /// @param  amount_ of DAI to lend.\\n    /// @return the id of the granted loan.\\n    function lendToCooler(Cooler cooler_, uint256 amount_) external returns (uint256) {\\n        // Attempt a clearinghouse <> treasury rebalance.\\n        rebalance();\\n\\n        // Validate that cooler was deployed by the trusted factory.\\n        if (!factory.created(address(cooler_))) revert OnlyFromFactory();\\n\\n        // Validate cooler collateral and debt tokens.\\n        if (cooler_.collateral() != gohm || cooler_.debt() != dai) revert BadEscrow();\\n\\n        // Transfer in collateral owed\\n        uint256 collateral = cooler_.collateralFor(amount_, LOAN_TO_COLLATERAL);\\n        gohm.transferFrom(msg.sender, address(this), collateral);\\n\\n        // Increment interest to be expected\\n        (, uint256 interest) = getLoanForCollateral(collateral);\\n        interestReceivables += interest;\\n        principalReceivables += amount_;\\n\\n        // Create a new loan request.\\n        gohm.approve(address(cooler_), collateral);\\n        uint256 reqID = cooler_.requestLoan(amount_, INTEREST_RATE, LOAN_TO_COLLATERAL, DURATION);\\n\\n        // Clear the created loan request by providing enough DAI.\\n        sdai.withdraw(amount_, address(this), address(this));\\n        dai.approve(address(cooler_), amount_);\\n        uint256 loanID = cooler_.clearRequest(reqID, address(this), true);\\n\\n        return loanID;\\n    }\\n\\n    /// @notice Extend the loan expiry by repaying the extension interest in advance.\\n    ///         The extension cost is paid by the caller. If a third-party executes the\\n    ///         extension, the loan period is extended, but the borrower debt does not increase.\\n    /// @param  cooler_ holding the loan to be extended.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @param  times_ Amount of times that the fixed-term loan duration is extended.\\n    function extendLoan(Cooler cooler_, uint256 loanID_, uint8 times_) external {\\n        // Attempt a clearinghouse <> treasury rebalance.\\n        rebalance();\\n\\n        Cooler.Loan memory loan = cooler_.getLoan(loanID_);\\n\\n        // Ensure Clearinghouse is the lender.\\n        if (loan.lender != address(this)) revert NotLender();\\n\\n        // Calculate extension interest based on the remaining principal.\\n        uint256 interestBase = interestForLoan(loan.principal, loan.request.duration);\\n        // Transfer in extension interest from the caller.\\n        dai.transferFrom(msg.sender, loan.recipient, interestBase * times_);\\n\\n        // Signal to cooler that loan can be extended.\\n        cooler_.extendLoanTerms(loanID_, times_);\\n    }\\n\\n    /// @notice Batch several default claims to save gas.\\n    ///         The elements on both arrays must be paired based on their index.\\n    /// @dev    Implements an auction style reward system that linearly increases up to a max reward.\\n    /// @param  coolers_ Array of contracts where the default must be claimed.\\n    /// @param  loans_ Array of defaulted loan ids.\\n    function claimDefaulted(address[] calldata coolers_, uint256[] calldata loans_) external {\\n        uint256 loans = loans_.length;\\n        if (loans != coolers_.length) revert LengthDiscrepancy();\\n\\n        uint256 totalPrincipal;\\n        uint256 totalInterest;\\n        uint256 totalCollateral;\\n        uint256 keeperRewards;\\n        for (uint256 i = 0; i < loans; ) {\\n            // Validate that cooler was deployed by the trusted factory.\\n            if (!factory.created(coolers_[i])) revert OnlyFromFactory();\\n\\n            // Validate that loan was written by clearinghouse.\\n            if (Cooler(coolers_[i]).getLoan(loans_[i]).lender != address(this)) revert NotLender();\\n\\n            // Claim defaults and update cached metrics.\\n            (uint256 principal, uint256 interest, uint256 collateral, uint256 elapsed) = Cooler(\\n                coolers_[i]\\n            ).claimDefaulted(loans_[i]);\\n\\n            unchecked {\\n                // Cannot overflow due to max supply limits for both tokens\\n                totalPrincipal += principal;\\n                totalInterest += interest;\\n                totalCollateral += collateral;\\n                // There will not exist more than 2**256 loans\\n                ++i;\\n            }\\n\\n            // Cap rewards to 5% of the collateral to avoid OHM holder's dillution.\\n            uint256 maxAuctionReward = (collateral * 5e16) / 1e18;\\n\\n            // Cap rewards to avoid exorbitant amounts.\\n            uint256 maxReward = (maxAuctionReward < MAX_REWARD) ? maxAuctionReward : MAX_REWARD;\\n\\n            // Calculate rewards based on the elapsed time since default.\\n            keeperRewards = (elapsed < 7 days)\\n                ? keeperRewards + (maxReward * elapsed) / 7 days\\n                : keeperRewards + maxReward;\\n        }\\n\\n        // Decrement loan receivables.\\n        interestReceivables = (interestReceivables > totalInterest)\\n            ? interestReceivables - totalInterest\\n            : 0;\\n        principalReceivables = (principalReceivables > totalPrincipal)\\n            ? principalReceivables - totalPrincipal\\n            : 0;\\n\\n        // Update outstanding debt owed to the Treasury upon default.\\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\\n\\n        // debt owed to TRSRY = user debt - user interest\\n        TRSRY.setDebt({\\n            debtor_: address(this),\\n            token_: dai,\\n            amount_: (outstandingDebt > totalPrincipal) ? outstandingDebt - totalPrincipal : 0\\n        });\\n\\n        // Reward keeper.\\n        gohm.transfer(msg.sender, keeperRewards);\\n        // Burn the outstanding collateral of defaulted loans.\\n        burn();\\n    }\\n\\n    // --- CALLBACKS -----------------------------------------------------\\n\\n    /// @notice Overridden callback to decrement loan receivables.\\n    /// @param *unused loadID_ of the load.\\n    /// @param  principalPaid_ in DAI.\\n    /// @param  interestPaid_ in DAI.\\n    function _onRepay(uint256, uint256 principalPaid_, uint256 interestPaid_) internal override {\\n        if (active) {\\n            _sweepIntoDSR(principalPaid_ + interestPaid_);\\n        } else {\\n            _defund(dai, principalPaid_ + interestPaid_);\\n        }\\n\\n        // Decrement loan receivables.\\n        interestReceivables = (interestReceivables > interestPaid_)\\n            ? interestReceivables - interestPaid_\\n            : 0;\\n        principalReceivables = (principalReceivables > principalPaid_)\\n            ? principalReceivables - principalPaid_\\n            : 0;\\n    }\\n\\n    /// @notice Unused callback since defaults are handled by the clearinghouse.\\n    /// @dev    Overriden and left empty to save gas.\\n    function _onDefault(uint256, uint256, uint256, uint256) internal override {}\\n\\n    // --- FUNDING ---------------------------------------------------\\n\\n    /// @notice Fund loan liquidity from treasury.\\n    /// @dev    Exposure is always capped at FUND_AMOUNT and rebalanced at up to FUND_CADANCE.\\n    ///         If several rebalances are available (because some were missed), calling this\\n    ///         function several times won't impact the funds controlled by the contract.\\n    ///         If the emergency shutdown is triggered, a rebalance will send funds back to\\n    ///         the treasury.\\n    /// @return False if too early to rebalance. Otherwise, true.\\n    function rebalance() public returns (bool) {\\n        // If the contract is deactivated, defund.\\n        uint256 maxFundAmount = active ? FUND_AMOUNT : 0;\\n        // Update funding schedule if necessary.\\n        if (fundTime > block.timestamp) return false;\\n        fundTime += FUND_CADENCE;\\n\\n        // Sweep DAI into DSR if necessary.\\n        uint256 idle = dai.balanceOf(address(this));\\n        if (idle != 0) _sweepIntoDSR(idle);\\n\\n        uint256 daiBalance = sdai.maxWithdraw(address(this));\\n        uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\\n        // Rebalance funds on hand with treasury's reserves.\\n        if (daiBalance < maxFundAmount) {\\n            // Since users loans are denominated in DAI, the clearinghouse\\n            // debt is set in DAI terms. It must be adjusted when funding.\\n            uint256 fundAmount = maxFundAmount - daiBalance;\\n            TRSRY.setDebt({\\n                debtor_: address(this),\\n                token_: dai,\\n                amount_: outstandingDebt + fundAmount\\n            });\\n\\n            // Since TRSRY holds sDAI, a conversion must be done before\\n            // funding the clearinghouse.\\n            uint256 sdaiAmount = sdai.previewWithdraw(fundAmount);\\n            TRSRY.increaseWithdrawApproval(address(this), sdai, sdaiAmount);\\n            TRSRY.withdrawReserves(address(this), sdai, sdaiAmount);\\n\\n            // Log the event.\\n            emit Rebalance(false, fundAmount);\\n        } else if (daiBalance > maxFundAmount) {\\n            // Since users loans are denominated in DAI, the clearinghouse\\n            // debt is set in DAI terms. It must be adjusted when defunding.\\n            uint256 defundAmount = daiBalance - maxFundAmount;\\n            TRSRY.setDebt({\\n                debtor_: address(this),\\n                token_: dai,\\n                amount_: (outstandingDebt > defundAmount) ? outstandingDebt - defundAmount : 0\\n            });\\n\\n            // Since TRSRY holds sDAI, a conversion must be done before\\n            // sending sDAI back.\\n            uint256 sdaiAmount = sdai.previewWithdraw(defundAmount);\\n            sdai.transfer(address(TRSRY), sdaiAmount);\\n\\n            // Log the event.\\n            emit Rebalance(true, defundAmount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Sweep excess DAI into vault.\\n    function sweepIntoDSR() public {\\n        uint256 daiBalance = dai.balanceOf(address(this));\\n        _sweepIntoDSR(daiBalance);\\n    }\\n\\n    /// @notice Sweep excess DAI into vault.\\n    function _sweepIntoDSR(uint256 amount_) internal {\\n        dai.approve(address(sdai), amount_);\\n        sdai.deposit(amount_, address(this));\\n    }\\n\\n    /// @notice Return funds to treasury.\\n    /// @param  token_ to transfer.\\n    /// @param  amount_ to transfer.\\n    function defund(ERC20 token_, uint256 amount_) external onlyRole(\\\"cooler_overseer\\\") {\\n        if (token_ == gohm) revert OnlyBurnable();\\n        _defund(token_, amount_);\\n    }\\n\\n    /// @notice Internal function to return funds to treasury.\\n    /// @param  token_ to transfer.\\n    /// @param  amount_ to transfer.\\n    function _defund(ERC20 token_, uint256 amount_) internal {\\n        if (token_ == sdai || token_ == dai) {\\n            // Since users loans are denominated in DAI, the clearinghouse\\n            // debt is set in DAI terms. It must be adjusted when defunding.\\n            uint256 outstandingDebt = TRSRY.reserveDebt(dai, address(this));\\n            uint256 daiAmount = (token_ == sdai) ? sdai.previewRedeem(amount_) : amount_;\\n\\n            TRSRY.setDebt({\\n                debtor_: address(this),\\n                token_: dai,\\n                amount_: (outstandingDebt > daiAmount) ? outstandingDebt - daiAmount : 0\\n            });\\n        }\\n\\n        // Defund and log the event\\n        token_.transfer(address(TRSRY), amount_);\\n        emit Defund(address(token_), amount_);\\n    }\\n\\n    /// @notice Public function to burn gOHM.\\n    /// @dev    Can be used to burn any gOHM defaulted using the Cooler instead of the Clearinghouse.\\n    function burn() public {\\n        uint256 gohmBalance = gohm.balanceOf(address(this));\\n        // Unstake and burn gOHM holdings.\\n        gohm.approve(address(staking), gohmBalance);\\n        MINTR.burnOhm(address(this), staking.unstake(address(this), gohmBalance, false, false));\\n    }\\n\\n    /// @notice Deactivate the contract and return funds to treasury.\\n    function emergencyShutdown() external onlyRole(\\\"emergency_shutdown\\\") {\\n        active = false;\\n\\n        // If necessary, defund sDAI.\\n        uint256 sdaiBalance = sdai.balanceOf(address(this));\\n        if (sdaiBalance != 0) _defund(sdai, sdaiBalance);\\n\\n        // If necessary, defund DAI.\\n        uint256 daiBalance = dai.balanceOf(address(this));\\n        if (daiBalance != 0) _defund(dai, daiBalance);\\n\\n        emit Deactivate();\\n    }\\n\\n    /// @notice Reactivate the contract.\\n    function reactivate() external onlyRole(\\\"cooler_overseer\\\") {\\n        active = true;\\n        fundTime = block.timestamp;\\n\\n        emit Reactivate();\\n    }\\n\\n    // --- AUX FUNCTIONS ---------------------------------------------\\n\\n    /// @notice view function computing collateral for a loan amount.\\n    function getCollateralForLoan(uint256 principal_) external pure returns (uint256) {\\n        return (principal_ * 1e18) / LOAN_TO_COLLATERAL;\\n    }\\n\\n    /// @notice view function computing loan for a collateral amount.\\n    /// @param  collateral_ amount of gOHM.\\n    /// @return debt (amount to be lent + interest) for a given collateral amount.\\n    function getLoanForCollateral(uint256 collateral_) public pure returns (uint256, uint256) {\\n        uint256 principal = (collateral_ * LOAN_TO_COLLATERAL) / 1e18;\\n        uint256 interest = interestForLoan(principal, DURATION);\\n        return (principal, interest);\\n    }\\n\\n    /// @notice view function to compute the interest for given principal amount.\\n    /// @param principal_ amount of DAI being lent.\\n    /// @param duration_ elapsed time in seconds.\\n    function interestForLoan(uint256 principal_, uint256 duration_) public pure returns (uint256) {\\n        uint256 interestPercent = (INTEREST_RATE * duration_) / 365 days;\\n        return (principal_ * interestPercent) / 1e18;\\n    }\\n\\n    /// @notice Get total receivable DAI for the treasury.\\n    ///         Includes both principal and interest.\\n    function getTotalReceivables() external view returns (uint256) {\\n        return principalReceivables + interestReceivables;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/mixins/ERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IStaking {\\n    function unstake(\\n        address to,\\n        uint256 amount,\\n        bool trigger,\\n        bool rebasing\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/Cooler/src/CoolerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ClonesWithImmutableArgs} from \\\"clones/ClonesWithImmutableArgs.sol\\\";\\n\\nimport {Cooler} from \\\"./Cooler.sol\\\";\\n\\n/// @title  Cooler Loans Factory.\\n/// @notice The Cooler Factory creates new Cooler escrow contracts.\\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\\n///         to save gas on deployment.\\ncontract CoolerFactory {\\n    using ClonesWithImmutableArgs for address;\\n\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error NotFromFactory();\\n    error DecimalsNot18();\\n\\n    // --- EVENTS ----------------------------------------------------\\n\\n    /// @notice A global event when a new loan request is created.\\n    event RequestLoan(address indexed cooler, address collateral, address debt, uint256 reqID);\\n    /// @notice A global event when a loan request is rescinded.\\n    event RescindRequest(address indexed cooler, uint256 reqID);\\n    /// @notice A global event when a loan request is fulfilled.\\n    event ClearRequest(address indexed cooler, uint256 reqID, uint256 loanID);\\n    /// @notice A global event when a loan is repaid.\\n    event RepayLoan(address indexed cooler, uint256 loanID, uint256 amount);\\n    /// @notice A global event when a loan is extended.\\n    event ExtendLoan(address indexed cooler, uint256 loanID, uint8 times);\\n    /// @notice A global event when the collateral of defaulted loan is claimed.\\n    event DefaultLoan(address indexed cooler, uint256 loanID, uint256 amount);\\n\\n    // -- STATE VARIABLES --------------------------------------------\\n\\n    /// @notice Cooler reference implementation (deployed on creation to clone from).\\n    Cooler public immutable coolerImplementation;\\n\\n    /// @notice Mapping to validate deployed coolers.\\n    mapping(address => bool) public created;\\n\\n    /// @notice Mapping to prevent duplicate coolers.\\n    mapping(address => mapping(ERC20 => mapping(ERC20 => address)))\\n        private coolerFor;\\n\\n    /// @notice Mapping to query Coolers for Collateral-Debt pair.\\n    mapping(ERC20 => mapping(ERC20 => address[])) public coolersFor;\\n\\n    // --- INITIALIZATION --------------------------------------------\\n\\n    constructor() {\\n        coolerImplementation = new Cooler();\\n    }\\n\\n    // --- DEPLOY NEW COOLERS ----------------------------------------\\n\\n    /// @notice creates a new Escrow contract for collateral and debt tokens.\\n    /// @param  collateral_ the token given as collateral.\\n    /// @param  debt_ the token to be lent. Interest is denominated in debt tokens.\\n    /// @return cooler address of the contract.\\nfunction generateCooler(ERC20 collateral_, ERC20 debt_) external returns (address cooler) {\\n    // Return address if cooler exists.\\n    cooler = coolerFor[msg.sender][collateral_][debt_];\\n\\n    // Otherwise generate new cooler.\\n    if (cooler == address(0)) {\\n        if (collateral_.decimals() != 18 || debt_.decimals() != 18) revert DecimalsNot18();\\n        // Clone the cooler implementation.\\n        bytes memory coolerData = abi.encodePacked(\\n            msg.sender,              // owner\\n            address(collateral_),    // collateral\\n            address(debt_),          // debt\\n            address(this)            // factory\\n        );\\n        cooler = address(coolerImplementation).clone(coolerData);\\n\\n        // Update storage accordingly.\\n        coolerFor[msg.sender][collateral_][debt_] = cooler;\\n        coolersFor[collateral_][debt_].push(cooler);\\n        created[cooler] = true;\\n    }\\n}\\n\\n    // --- EMIT EVENTS -----------------------------------------------\\n\\n    /// @notice Ensure that the called is a Cooler.\\n    modifier onlyFromFactory {        \\n        if (!created[msg.sender]) revert NotFromFactory();\\n        _;\\n    }\\n\\n    /// @notice Emit a global event when a new loan request is created.\\n    function logRequestLoan(uint256 reqID_) external onlyFromFactory {\\n        emit RequestLoan(msg.sender, address(Cooler(msg.sender).collateral()), address(Cooler(msg.sender).debt()), reqID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan request is rescinded.\\n    function logRescindRequest(uint256 reqID_) external onlyFromFactory {\\n        emit RescindRequest(msg.sender, reqID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan request is fulfilled.\\n    function logClearRequest(uint256 reqID_, uint256 loanID_) external onlyFromFactory {\\n        emit ClearRequest(msg.sender, reqID_, loanID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan is repaid.\\n    function logRepayLoan(uint256 loanID_, uint256 repayment_) external onlyFromFactory {\\n        emit RepayLoan(msg.sender, loanID_, repayment_);\\n    }\\n\\n    /// @notice Emit a global event when a loan is extended.\\n    function logExtendLoan(uint256 loanID_, uint8 times_) external onlyFromFactory {\\n        emit ExtendLoan(msg.sender, loanID_, times_);\\n    }\\n\\n    /// @notice Emit a global event when the collateral of defaulted loan is claimed.\\n    function logDefaultLoan(uint256 loanID_, uint256 collateral_) external onlyFromFactory {\\n        emit DefaultLoan(msg.sender, loanID_, collateral_);\\n    }\\n}\"\r\n    },\r\n    \"lib/Cooler/src/CoolerCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {CoolerFactory} from \\\"./CoolerFactory.sol\\\";\\n\\n/// @notice Allows for debt issuers to execute logic when a loan is repaid, rolled, or defaulted.\\n/// @dev    The three callback functions must be implemented if `isCoolerCallback()` is set to true.\\nabstract contract CoolerCallback {\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error OnlyFromFactory();\\n\\n    // --- INITIALIZATION --------------------------------------------\\n\\n    CoolerFactory public immutable factory;\\n\\n    constructor(address coolerFactory_) {\\n        factory = CoolerFactory(coolerFactory_);\\n    }\\n\\n    // --- EXTERNAL FUNCTIONS ------------------------------------------------\\n\\n    /// @notice Informs to Cooler that this contract can handle its callbacks.\\n    function isCoolerCallback() external pure returns (bool) {\\n        return true;\\n    }\\n\\n    /// @notice Callback function that handles repayments.\\n    function onRepay(uint256 loanID_, uint256 principlePaid_, uint256 interestPaid_) external {\\n        if (!factory.created(msg.sender)) revert OnlyFromFactory();\\n        _onRepay(loanID_, principlePaid_, interestPaid_);\\n    }\\n\\n    /// @notice Callback function that handles defaults.\\n    function onDefault(\\n        uint256 loanID_,\\n        uint256 principle,\\n        uint256 interest,\\n        uint256 collateral\\n    ) external {\\n        if (!factory.created(msg.sender)) revert OnlyFromFactory();\\n        _onDefault(loanID_, principle, interest, collateral);\\n    }\\n\\n    // --- INTERNAL FUNCTIONS ------------------------------------------------\\n\\n    /// @notice Callback function that handles repayments. Override for custom logic.\\n    function _onRepay(\\n        uint256 loanID_,\\n        uint256 principlePaid_,\\n        uint256 interestPaid_\\n    ) internal virtual;\\n\\n    /// @notice Callback function that handles defaults.\\n    function _onDefault(\\n        uint256 loanID_,\\n        uint256 principle_,\\n        uint256 interestDue_,\\n        uint256 collateral\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/modules/ROLES/OlympusRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {ROLESv1} from \\\"src/modules/ROLES/ROLES.v1.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @notice Abstract contract to have the `onlyRole` modifier\\n/// @dev    Inheriting this automatically makes ROLES module a dependency\\nabstract contract RolesConsumer {\\n    ROLESv1 public ROLES;\\n\\n    modifier onlyRole(bytes32 role_) {\\n        ROLES.requireRole(role_, msg.sender);\\n        _;\\n    }\\n}\\n\\n/// @notice Module that holds multisig roles needed by various policies.\\ncontract OlympusRoles is ROLESv1 {\\n    //============================================================================================//\\n    //                                        MODULE SETUP                                        //\\n    //============================================================================================//\\n\\n    constructor(Kernel kernel_) Module(kernel_) {}\\n\\n    /// @inheritdoc Module\\n    function KEYCODE() public pure override returns (Keycode) {\\n        return toKeycode(\\\"ROLES\\\");\\n    }\\n\\n    /// @inheritdoc Module\\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\\n        major = 1;\\n        minor = 0;\\n    }\\n\\n    //============================================================================================//\\n    //                                       CORE FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    /// @inheritdoc ROLESv1\\n    function saveRole(bytes32 role_, address addr_) external override permissioned {\\n        if (hasRole[addr_][role_]) revert ROLES_AddressAlreadyHasRole(addr_, role_);\\n\\n        ensureValidRole(role_);\\n\\n        // Grant role to the address\\n        hasRole[addr_][role_] = true;\\n\\n        emit RoleGranted(role_, addr_);\\n    }\\n\\n    /// @inheritdoc ROLESv1\\n    function removeRole(bytes32 role_, address addr_) external override permissioned {\\n        if (!hasRole[addr_][role_]) revert ROLES_AddressDoesNotHaveRole(addr_, role_);\\n\\n        hasRole[addr_][role_] = false;\\n\\n        emit RoleRevoked(role_, addr_);\\n    }\\n\\n    //============================================================================================//\\n    //                                       VIEW FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    /// @inheritdoc ROLESv1\\n    function requireRole(bytes32 role_, address caller_) external view override {\\n        if (!hasRole[caller_][role_]) revert ROLES_RequireRole(role_);\\n    }\\n\\n    /// @inheritdoc ROLESv1\\n    function ensureValidRole(bytes32 role_) public pure override {\\n        for (uint256 i = 0; i < 32; ) {\\n            bytes1 char = role_[i];\\n            if ((char < 0x61 || char > 0x7A) && char != 0x5f && char != 0x00) {\\n                revert ROLES_InvalidRole(role_); // a-z only\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/TRSRY/TRSRY.v1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @notice Treasury holds all other assets under the control of the protocol.\\nabstract contract TRSRYv1 is Module {\\n    // =========  EVENTS ========= //\\n\\n    event IncreaseWithdrawApproval(\\n        address indexed withdrawer_,\\n        ERC20 indexed token_,\\n        uint256 newAmount_\\n    );\\n    event DecreaseWithdrawApproval(\\n        address indexed withdrawer_,\\n        ERC20 indexed token_,\\n        uint256 newAmount_\\n    );\\n    event Withdrawal(\\n        address indexed policy_,\\n        address indexed withdrawer_,\\n        ERC20 indexed token_,\\n        uint256 amount_\\n    );\\n    event IncreaseDebtorApproval(address indexed debtor_, ERC20 indexed token_, uint256 newAmount_);\\n    event DecreaseDebtorApproval(address indexed debtor_, ERC20 indexed token_, uint256 newAmount_);\\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\\n\\n    // =========  ERRORS ========= //\\n\\n    error TRSRY_NoDebtOutstanding();\\n    error TRSRY_NotActive();\\n\\n    // =========  STATE ========= //\\n\\n    /// @notice Status of the treasury. If false, no withdrawals or debt can be incurred.\\n    bool public active;\\n\\n    /// @notice Mapping of who is approved for withdrawal.\\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\\n\\n    /// @notice Mapping of who is approved to incur debt.\\n    /// @dev    debtor -> token -> amount. Infinite approval is max(uint256).\\n    mapping(address => mapping(ERC20 => uint256)) public debtApproval;\\n\\n    /// @notice Total debt for token across all withdrawals.\\n    mapping(ERC20 => uint256) public totalDebt;\\n\\n    /// @notice Debt for particular token and debtor address\\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\\n\\n    // =========  FUNCTIONS ========= //\\n\\n    modifier onlyWhileActive() {\\n        if (!active) revert TRSRY_NotActive();\\n        _;\\n    }\\n\\n    /// @notice Increase approval for specific withdrawer addresses\\n    function increaseWithdrawApproval(\\n        address withdrawer_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external virtual;\\n\\n    /// @notice Decrease approval for specific withdrawer addresses\\n    function decreaseWithdrawApproval(\\n        address withdrawer_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external virtual;\\n\\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\\n    function withdrawReserves(address to_, ERC20 token_, uint256 amount_) external virtual;\\n\\n    /// @notice Increase approval for someone to accrue debt in order to withdraw reserves.\\n    /// @dev    Debt will generally be taken by contracts to allocate treasury funds in yield sources.\\n    function increaseDebtorApproval(\\n        address debtor_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external virtual;\\n\\n    /// @notice Decrease approval for someone to withdraw reserves as debt.\\n    function decreaseDebtorApproval(\\n        address debtor_,\\n        ERC20 token_,\\n        uint256 amount_\\n    ) external virtual;\\n\\n    /// @notice Pre-approved policies can get a loan to perform operations with treasury assets.\\n    function incurDebt(ERC20 token_, uint256 amount_) external virtual;\\n\\n    /// @notice Repay a debtor debt.\\n    /// @dev    Only confirmed to safely handle standard and non-standard ERC20s.\\n    /// @dev    Can have unforeseen consequences with ERC777. Be careful with ERC777 as reserve.\\n    function repayDebt(address debtor_, ERC20 token_, uint256 amount_) external virtual;\\n\\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\\n    function setDebt(address debtor_, ERC20 token_, uint256 amount_) external virtual;\\n\\n    /// @notice Get total balance of assets inside the treasury + any debt taken out against those assets.\\n    function getReserveBalance(ERC20 token_) external view virtual returns (uint256);\\n\\n    /// @notice Emergency shutdown of withdrawals.\\n    function deactivate() external virtual;\\n\\n    /// @notice Re-activate withdrawals after shutdown.\\n    function activate() external virtual;\\n}\\n\"\r\n    },\r\n    \"src/modules/MINTR/MINTR.v1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {OlympusERC20Token as OHM} from \\\"src/external/OlympusERC20.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\n\\n/// @notice Wrapper for minting and burning functions of OHM token.\\nabstract contract MINTRv1 is Module {\\n    // =========  EVENTS ========= //\\n\\n    event IncreaseMintApproval(address indexed policy_, uint256 newAmount_);\\n    event DecreaseMintApproval(address indexed policy_, uint256 newAmount_);\\n    event Mint(address indexed policy_, address indexed to_, uint256 amount_);\\n    event Burn(address indexed policy_, address indexed from_, uint256 amount_);\\n\\n    // ========= ERRORS ========= //\\n\\n    error MINTR_NotApproved();\\n    error MINTR_ZeroAmount();\\n    error MINTR_NotActive();\\n\\n    // =========  STATE ========= //\\n\\n    OHM public ohm;\\n\\n    /// @notice Status of the minter. If false, minting and burning OHM is disabled.\\n    bool public active;\\n\\n    /// @notice Mapping of who is approved for minting.\\n    /// @dev    minter -> amount. Infinite approval is max(uint256).\\n    mapping(address => uint256) public mintApproval;\\n\\n    // =========  FUNCTIONS ========= //\\n\\n    modifier onlyWhileActive() {\\n        if (!active) revert MINTR_NotActive();\\n        _;\\n    }\\n\\n    /// @notice Mint OHM to an address.\\n    function mintOhm(address to_, uint256 amount_) external virtual;\\n\\n    /// @notice Burn OHM from an address. Must have approval.\\n    function burnOhm(address from_, uint256 amount_) external virtual;\\n\\n    /// @notice Increase approval for specific withdrawer addresses\\n    /// @dev    Policies must explicity request how much they want approved before withdrawing.\\n    function increaseMintApproval(address policy_, uint256 amount_) external virtual;\\n\\n    /// @notice Decrease approval for specific withdrawer addresses\\n    function decreaseMintApproval(address policy_, uint256 amount_) external virtual;\\n\\n    /// @notice Emergency shutdown of minting and burning.\\n    function deactivate() external virtual;\\n\\n    /// @notice Re-activate minting and burning after shutdown.\\n    function activate() external virtual;\\n}\\n\"\r\n    },\r\n    \"src/Kernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\n//     \u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588       \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588       \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\\n//  \u2588\u2588\u2588     \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588        \u2591\u2591\u2588\u2588\u2588 \u2588\u2588\u2588   \u2591\u2588\u2588\u2588\u2591\u2588\u2588\u2588\u2588\u2588\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588    \u2591\u2591\u2591\\n// \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588\u2588\u2588    \u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588          \u2591\u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588 \u2591\u2591\u2591  \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591   \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\\n// \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588  \u2591\u2588\u2588\u2588      \u2588    \u2591\u2588\u2588\u2588     \u2591\u2588\u2588\u2588      \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588         \u2591\u2588\u2588\u2588   \u2591\u2588\u2588\u2588  \u2588\u2588\u2588    \u2591\u2588\u2588\u2588\\n//  \u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588     \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588        \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//    \u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591     \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\\n\\n//============================================================================================//\\n//                                        GLOBAL TYPES                                        //\\n//============================================================================================//\\n\\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\\nenum Actions {\\n    InstallModule,\\n    UpgradeModule,\\n    ActivatePolicy,\\n    DeactivatePolicy,\\n    ChangeExecutor,\\n    MigrateKernel\\n}\\n\\n/// @notice Used by executor to select an action and a target contract for a kernel action\\nstruct Instruction {\\n    Actions action;\\n    address target;\\n}\\n\\n/// @notice Used to define which module functions a policy needs access to\\nstruct Permissions {\\n    Keycode keycode;\\n    bytes4 funcSelector;\\n}\\n\\ntype Keycode is bytes5;\\n\\n//============================================================================================//\\n//                                       UTIL FUNCTIONS                                       //\\n//============================================================================================//\\n\\nerror TargetNotAContract(address target_);\\nerror InvalidKeycode(Keycode keycode_);\\n\\n// solhint-disable-next-line func-visibility\\nfunction toKeycode(bytes5 keycode_) pure returns (Keycode) {\\n    return Keycode.wrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction fromKeycode(Keycode keycode_) pure returns (bytes5) {\\n    return Keycode.unwrap(keycode_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureContract(address target_) view {\\n    if (target_.code.length == 0) revert TargetNotAContract(target_);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction ensureValidKeycode(Keycode keycode_) pure {\\n    bytes5 unwrapped = Keycode.unwrap(keycode_);\\n    for (uint256 i = 0; i < 5; ) {\\n        bytes1 char = unwrapped[i];\\n        if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only\\n        unchecked {\\n            i++;\\n        }\\n    }\\n}\\n\\n//============================================================================================//\\n//                                        COMPONENTS                                          //\\n//============================================================================================//\\n\\n/// @notice Generic adapter interface for kernel access in modules and policies.\\nabstract contract KernelAdapter {\\n    error KernelAdapter_OnlyKernel(address caller_);\\n\\n    Kernel public kernel;\\n\\n    constructor(Kernel kernel_) {\\n        kernel = kernel_;\\n    }\\n\\n    /// @notice Modifier to restrict functions to be called only by kernel.\\n    modifier onlyKernel() {\\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Function used by kernel when migrating to a new kernel.\\n    function changeKernel(Kernel newKernel_) external onlyKernel {\\n        kernel = newKernel_;\\n    }\\n}\\n\\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\\n///         interacted with and mutated through policies.\\n/// @dev    Modules are installed and uninstalled via the executor.\\nabstract contract Module is KernelAdapter {\\n    error Module_PolicyNotPermitted(address policy_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Modifier to restrict which policies have access to module functions.\\n    modifier permissioned() {\\n        if (\\n            msg.sender == address(kernel) ||\\n            !kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)\\n        ) revert Module_PolicyNotPermitted(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice 5 byte identifier for a module.\\n    function KEYCODE() public pure virtual returns (Keycode) {}\\n\\n    /// @notice Returns which semantic version of a module is being implemented.\\n    /// @return major - Major version upgrade indicates breaking change to the interface.\\n    /// @return minor - Minor version change retains backward-compatible interface.\\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\\n\\n    /// @notice Initialization function for the module\\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\\n    function INIT() external virtual onlyKernel {}\\n}\\n\\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\\nabstract contract Policy is KernelAdapter {\\n    error Policy_ModuleDoesNotExist(Keycode keycode_);\\n\\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\\n\\n    /// @notice Easily accessible indicator for if a policy is activated or not.\\n    function isActive() external view returns (bool) {\\n        return kernel.isPolicyActive(this);\\n    }\\n\\n    /// @notice Function to grab module address from a given keycode.\\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\\n        return moduleForKeycode;\\n    }\\n\\n    /// @notice Define module dependencies for this policy.\\n    /// @return dependencies - Keycode array of module dependencies.\\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\\n\\n    /// @notice Function called by kernel to set module function permissions.\\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\\n}\\n\\n/// @notice Main contract that acts as a central component registry for the protocol.\\n/// @dev    The kernel manages modules and policies. The kernel is mutated via predefined Actions,\\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\\ncontract Kernel {\\n    // =========  EVENTS ========= //\\n\\n    event PermissionsUpdated(\\n        Keycode indexed keycode_,\\n        Policy indexed policy_,\\n        bytes4 funcSelector_,\\n        bool granted_\\n    );\\n    event ActionExecuted(Actions indexed action_, address indexed target_);\\n\\n    // =========  ERRORS ========= //\\n\\n    error Kernel_OnlyExecutor(address caller_);\\n    error Kernel_ModuleAlreadyInstalled(Keycode module_);\\n    error Kernel_InvalidModuleUpgrade(Keycode module_);\\n    error Kernel_PolicyAlreadyActivated(address policy_);\\n    error Kernel_PolicyNotActivated(address policy_);\\n\\n    // =========  PRIVILEGED ADDRESSES ========= //\\n\\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\\n    address public executor;\\n\\n    // =========  MODULE MANAGEMENT ========= //\\n\\n    /// @notice Array of all modules currently installed.\\n    Keycode[] public allKeycodes;\\n\\n    /// @notice Mapping of module address to keycode.\\n    mapping(Keycode => Module) public getModuleForKeycode;\\n\\n    /// @notice Mapping of keycode to module address.\\n    mapping(Module => Keycode) public getKeycodeForModule;\\n\\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\\n    mapping(Keycode => Policy[]) public moduleDependents;\\n\\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\\n\\n    /// @notice Module <> Policy Permissions.\\n    /// @dev    Keycode -> Policy -> Function Selector -> bool for permission\\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\\n\\n    // =========  POLICY MANAGEMENT ========= //\\n\\n    /// @notice List of all active policies\\n    Policy[] public activePolicies;\\n\\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\\n    mapping(Policy => uint256) public getPolicyIndex;\\n\\n    //============================================================================================//\\n    //                                       CORE FUNCTIONS                                       //\\n    //============================================================================================//\\n\\n    constructor() {\\n        executor = msg.sender;\\n    }\\n\\n    /// @notice Modifier to check if caller is the executor.\\n    modifier onlyExecutor() {\\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\\n        _;\\n    }\\n\\n    function isPolicyActive(Policy policy_) public view returns (bool) {\\n        return activePolicies.length > 0 && activePolicies[getPolicyIndex[policy_]] == policy_;\\n    }\\n\\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\\n    function executeAction(Actions action_, address target_) external onlyExecutor {\\n        if (action_ == Actions.InstallModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _installModule(Module(target_));\\n        } else if (action_ == Actions.UpgradeModule) {\\n            ensureContract(target_);\\n            ensureValidKeycode(Module(target_).KEYCODE());\\n            _upgradeModule(Module(target_));\\n        } else if (action_ == Actions.ActivatePolicy) {\\n            ensureContract(target_);\\n            _activatePolicy(Policy(target_));\\n        } else if (action_ == Actions.DeactivatePolicy) {\\n            ensureContract(target_);\\n            _deactivatePolicy(Policy(target_));\\n        } else if (action_ == Actions.ChangeExecutor) {\\n            executor = target_;\\n        } else if (action_ == Actions.MigrateKernel) {\\n            ensureContract(target_);\\n            _migrateKernel(Kernel(target_));\\n        }\\n\\n        emit ActionExecuted(action_, target_);\\n    }\\n\\n    function _installModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n\\n        if (address(getModuleForKeycode[keycode]) != address(0))\\n            revert Kernel_ModuleAlreadyInstalled(keycode);\\n\\n        getModuleForKeycode[keycode] = newModule_;\\n        getKeycodeForModule[newModule_] = keycode;\\n        allKeycodes.push(keycode);\\n\\n        newModule_.INIT();\\n    }\\n\\n    function _upgradeModule(Module newModule_) internal {\\n        Keycode keycode = newModule_.KEYCODE();\\n        Module oldModule = getModuleForKeycode[keycode];\\n\\n        if (address(oldModule) == address(0) || oldModule == newModule_)\\n            revert Kernel_InvalidModuleUpgrade(keycode);\\n\\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\\n        getKeycodeForModule[newModule_] = keycode;\\n        getModuleForKeycode[keycode] = newModule_;\\n\\n        newModule_.INIT();\\n\\n        _reconfigurePolicies(keycode);\\n    }\\n\\n    function _activatePolicy(Policy policy_) internal {\\n        if (isPolicyActive(policy_)) revert Kernel_PolicyAlreadyActivated(address(policy_));\\n\\n        // Add policy to list of active policies\\n        activePolicies.push(policy_);\\n        getPolicyIndex[policy_] = activePolicies.length - 1;\\n\\n        // Record module dependencies\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depLength = dependencies.length;\\n\\n        for (uint256 i; i < depLength; ) {\\n            Keycode keycode = dependencies[i];\\n\\n            moduleDependents[keycode].push(policy_);\\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Grant permissions for policy to access restricted module functions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, true);\\n    }\\n\\n    function _deactivatePolicy(Policy policy_) internal {\\n        if (!isPolicyActive(policy_)) revert Kernel_PolicyNotActivated(address(policy_));\\n\\n        // Revoke permissions\\n        Permissions[] memory requests = policy_.requestPermissions();\\n        _setPolicyPermissions(policy_, requests, false);\\n\\n        // Remove policy from all policy data structures\\n        uint256 idx = getPolicyIndex[policy_];\\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\\n\\n        activePolicies[idx] = lastPolicy;\\n        activePolicies.pop();\\n        getPolicyIndex[lastPolicy] = idx;\\n        delete getPolicyIndex[policy_];\\n\\n        // Remove policy from module dependents\\n        _pruneFromDependents(policy_);\\n    }\\n\\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\\n    /// @dev    NOTE: Data does not get cleared from this kernel.\\n    function _migrateKernel(Kernel newKernel_) internal {\\n        uint256 keycodeLen = allKeycodes.length;\\n        for (uint256 i; i < keycodeLen; ) {\\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\\n            module.changeKernel(newKernel_);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 policiesLen = activePolicies.length;\\n        for (uint256 j; j < policiesLen; ) {\\n            Policy policy = activePolicies[j];\\n\\n            // Deactivate before changing kernel\\n            policy.changeKernel(newKernel_);\\n            unchecked {\\n                ++j;\\n            }\\n        }\\n    }\\n\\n    function _reconfigurePolicies(Keycode keycode_) internal {\\n        Policy[] memory dependents = moduleDependents[keycode_];\\n        uint256 depLength = dependents.length;\\n\\n        for (uint256 i; i < depLength; ) {\\n            dependents[i].configureDependencies();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _setPolicyPermissions(\\n        Policy policy_,\\n        Permissions[] memory requests_,\\n        bool grant_\\n    ) internal {\\n        uint256 reqLength = requests_.length;\\n        for (uint256 i = 0; i < reqLength; ) {\\n            Permissions memory request = requests_[i];\\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\\n\\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _pruneFromDependents(Policy policy_) internal {\\n        Keycode[] memory dependencies = policy_.configureDependencies();\\n        uint256 depcLength = dependencies.length;\\n\\n        for (uint256 i; i < depcLength; ) {\\n            Keycode keycode = dependencies[i];\\n            Policy[] storage dependents = moduleDependents[keycode];\\n\\n            uint256 origIndex = getDependentIndex[keycode][policy_];\\n            Policy lastPolicy = dependents[dependents.length - 1];\\n\\n            // Swap with last and pop\\n            dependents[origIndex] = lastPolicy;\\n            dependents.pop();\\n\\n            // Record new index and delete deactivated policy index\\n            getDependentIndex[keycode][lastPolicy] = origIndex;\\n            delete getDependentIndex[keycode][policy_];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            uint256 creationSize = 0x43 + extraLength;\\n            uint256 runSize = creationSize - 11;\\n            uint256 dataPtr;\\n            uint256 ptr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (11 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \u2013\\n                mstore(\\n                    ptr,\\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0b\\n                // 80          | DUP1                  | r r 0                   | \u2013\\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \u2013\\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\\n                mstore(\\n                    add(ptr, 0x04),\\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\\n                )\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 36          | CALLDATASIZE          | cds                     | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \u2013\\n                // 37          | CALLDATACOPY          | \u2013                       | [0, cds] = calldata\\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x0b),\\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x10), shl(240, extraLength))\\n\\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x12),\\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\\n                // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x1d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\\n                // fd          | REVERT                | \u2013                       | [0, rds] = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\\n                // f3          | RETURN                | \u2013                       | [0, rds] = return data\\n\\n                mstore(\\n                    add(ptr, 0x34),\\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x43;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                instance := create(0, ptr, creationSize)\\n            }\\n            if (instance == address(0)) {\\n                revert CreateFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/Cooler/src/Cooler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Clone} from \\\"clones/Clone.sol\\\";\\n\\n// Function sig taken from gOHM contract\\ninterface IDelegate {\\n    function delegate(address to_) external;\\n}\\n\\nimport {CoolerFactory} from \\\"./CoolerFactory.sol\\\";\\nimport {CoolerCallback} from \\\"./CoolerCallback.sol\\\";\\n\\n/// @title  Cooler Loans.\\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\\n///         loans for a user-defined debt-collateral pair.\\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\\n///         to save gas on deployment.\\ncontract Cooler is Clone {\\n    using SafeTransferLib for ERC20;\\n\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error OnlyApproved();\\n    error Deactivated();\\n    error Default();\\n    error NotExpired();\\n    error NotCoolerCallback();\\n\\n    // --- DATA STRUCTURES -------------------------------------------\\n\\n    /// @notice A loan begins with a borrow request.\\n    struct Request {\\n        uint256 amount; // Amount to be borrowed.\\n        uint256 interest; // Annualized percentage to be paid as interest.\\n        uint256 loanToCollateral; // Requested loan-to-collateral ratio.\\n        uint256 duration; // Time to repay the loan before it defaults.\\n        bool active; // Any lender can clear an active loan request.\\n        address requester; // The address that created the request.\\n    }\\n\\n    /// @notice A request is converted to a loan when a lender clears it.\\n    struct Loan {\\n        Request request; // Loan terms specified in the request.\\n        uint256 principal; // Amount of principal debt owed to the lender.\\n        uint256 interestDue; // Interest owed to the lender.\\n        uint256 collateral; // Amount of collateral pledged.\\n        uint256 expiry; // Time when the loan defaults.\\n        address lender; // Lender's address.\\n        address recipient; // Recipient of repayments.\\n        bool callback; // If this is true, the lender must inherit CoolerCallback.\\n    }\\n\\n    // --- IMMUTABLES ------------------------------------------------\\n\\n    // This makes the code look prettier.\\n    uint256 private constant DECIMALS_INTEREST = 1e18;\\n\\n    /// @notice This address owns the collateral in escrow.\\n    function owner() public pure returns (address _owner) {\\n        return _getArgAddress(0x0);\\n    }\\n\\n    /// @notice This token is borrowed against.\\n    function collateral() public pure returns (ERC20 _collateral) {\\n        return ERC20(_getArgAddress(0x14));\\n    }\\n\\n    /// @notice This token is lent.\\n    function debt() public pure returns (ERC20 _debt) {\\n        return ERC20(_getArgAddress(0x28));\\n    }\\n\\n    /// @notice This contract created the Cooler\\n    function factory() public pure returns (CoolerFactory _factory) {\\n        return CoolerFactory(_getArgAddress(0x3c));\\n    }\\n\\n    // --- STATE VARIABLES -------------------------------------------\\n\\n    /// @notice Arrays stores all the loan requests.\\n    Request[] public requests;\\n\\n    /// @notice Arrays stores all the granted loans.\\n    Loan[] public loans;\\n\\n    /// @notice Facilitates transfer of lender ownership to new addresses\\n    mapping(uint256 => address) public approvals;\\n\\n    // --- BORROWER --------------------------------------------------\\n\\n    /// @notice Request a loan with given parameters.\\n    ///         Collateral is taken at time of request.\\n    /// @param  amount_ of debt tokens to borrow.\\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**collateral().decimals().\\n    /// @param  duration_ of loan tenure in seconds.\\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\\n    function requestLoan(\\n        uint256 amount_,\\n        uint256 interest_,\\n        uint256 loanToCollateral_,\\n        uint256 duration_\\n    ) external returns (uint256 reqID) {\\n        reqID = requests.length;\\n        requests.push(\\n            Request({\\n                amount: amount_,\\n                interest: interest_,\\n                loanToCollateral: loanToCollateral_,\\n                duration: duration_,\\n                active: true,\\n                requester: msg.sender\\n            })\\n        );\\n\\n        // The collateral is taken upfront. Will be escrowed\\n        // until the loan is repaid or defaulted.\\n        collateral().safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            collateralFor(amount_, loanToCollateral_)\\n        );\\n\\n        // Log the event.\\n        factory().logRequestLoan(reqID);\\n    }\\n\\n    /// @notice Cancel a loan request and get the collateral back.\\n    /// @param  reqID_ index of request in requests[].\\n    function rescindRequest(uint256 reqID_) external {\\n        if (msg.sender != owner()) revert OnlyApproved();\\n\\n        Request storage req = requests[reqID_];\\n\\n        if (!req.active) revert Deactivated();\\n\\n        // Update storage and send collateral back to the owner.\\n        req.active = false;\\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\\n\\n        // Log the event.\\n        factory().logRescindRequest(reqID_);\\n    }\\n\\n    /// @notice Repay a loan to get the collateral back.\\n    /// @dev    Despite a malicious lender could reenter with the callback, the\\n    ///         usage of `msg.sender` prevents any economical benefit to the\\n    ///         attacker, since they would be repaying the loan themselves.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @param  repayment_ debt tokens to be repaid.\\n    /// @return collateral given back to the borrower.\\n    function repayLoan(uint256 loanID_, uint256 repayment_) external returns (uint256) {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (block.timestamp > loan.expiry) revert Default();\\n\\n        // Cap the repayment to the total debt of the loan\\n        uint256 totalDebt = loan.principal + loan.interestDue;\\n        if (repayment_ > totalDebt) repayment_ = totalDebt;\\n\\n        // Need to repay interest first, then any extra goes to paying down principal.\\n        uint256 interestPaid;\\n        uint256 remainder;\\n        if (repayment_ >= loan.interestDue) {\\n            remainder = repayment_ - loan.interestDue;\\n            interestPaid = loan.interestDue;\\n            loan.interestDue = 0;\\n        } else {\\n            loan.interestDue -= repayment_;\\n            interestPaid = repayment_;\\n        }\\n\\n        // We pay back only if user has paid back principal. This can be 0.\\n        uint256 decollateralized;\\n        if (remainder > 0) {\\n            decollateralized = (loan.collateral * remainder) / loan.principal;\\n\\n            loan.principal -= remainder;\\n            loan.collateral -= decollateralized;\\n        }\\n\\n        // Save updated loan info in storage.\\n        loans[loanID_] = loan;\\n\\n        // Transfer repaid debt back to the lender and collateral back to the owner if applicable\\n        debt().safeTransferFrom(msg.sender, loan.recipient, repayment_);\\n        if (decollateralized > 0) collateral().safeTransfer(owner(), decollateralized);\\n\\n        // Log the event.\\n        factory().logRepayLoan(loanID_, repayment_);\\n\\n        // If necessary, trigger lender callback.\\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, remainder, interestPaid);\\n\\n        return decollateralized;\\n    }\\n\\n    /// @notice Delegate voting power on collateral.\\n    /// @param  to_ address to delegate.\\n    function delegateVoting(address to_) external {\\n        if (msg.sender != owner()) revert OnlyApproved();\\n        IDelegate(address(collateral())).delegate(to_);\\n    }\\n\\n    // --- LENDER ----------------------------------------------------\\n\\n    /// @notice Fill a requested loan as a lender.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @param  recipient_ address to repay the loan to.\\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\\n    function clearRequest(\\n        uint256 reqID_,\\n        address recipient_,\\n        bool isCallback_\\n    ) external returns (uint256 loanID) {\\n        Request memory req = requests[reqID_];\\n\\n        // Loan callbacks are only allowed if:\\n        //  1. The loan request has been created via a trusted lender.\\n        //  2. The lender signals that it implements the CoolerCallback Abstract.\\n        bool callback = (isCallback_ && msg.sender == req.requester);\\n\\n        // If necessary, ensure lender implements the CoolerCallback abstract.\\n        if (callback && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\\n        // Ensure loan request is active.\\n        if (!req.active) revert Deactivated();\\n\\n        // Clear the loan request in memory.\\n        req.active = false;\\n\\n        // Calculate and store loan terms.\\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\\n        loanID = loans.length;\\n\\n        loans.push(\\n            Loan({\\n                request: req,\\n                principal: req.amount,\\n                interestDue: interest,\\n                collateral: collat,\\n                expiry: block.timestamp + req.duration,\\n                lender: msg.sender,\\n                recipient: recipient_,\\n                callback: callback\\n            })\\n        );\\n\\n        // Clear the loan request storage.\\n        requests[reqID_].active = false;\\n\\n        // Transfer debt tokens to the owner of the request.\\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\\n\\n        // Log the event.\\n        factory().logClearRequest(reqID_, loanID);\\n    }\\n\\n    /// @notice Allow lender to extend a loan for the borrower. Doesn't require\\n    ///         borrower permission because it doesn't have a negative impact for them.\\n    /// @dev    Since this function solely impacts the expiration day, the lender\\n    ///         should ensure that extension interest payments are done beforehand.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @param  times_ that the fixed-term loan duration is extended.\\n    function extendLoanTerms(uint256 loanID_, uint8 times_) external {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (msg.sender != loan.lender) revert OnlyApproved();\\n        if (block.timestamp > loan.expiry) revert Default();\\n\\n        // Update loan terms to reflect the extension.\\n        loan.expiry += loan.request.duration * times_;\\n\\n        // Save updated loan info in storage.\\n        loans[loanID_] = loan;\\n\\n        // Log the event.\\n        factory().logExtendLoan(loanID_, times_);\\n    }\\n\\n    /// @notice Claim collateral upon loan default.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256, uint256) {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (block.timestamp <= loan.expiry) revert NotExpired();\\n\\n        loans[loanID_].principal = 0;\\n        loans[loanID_].interestDue = 0;\\n        loans[loanID_].collateral = 0;\\n\\n        // Transfer defaulted collateral to the lender.\\n        collateral().safeTransfer(loan.lender, loan.collateral);\\n\\n        // Log the event.\\n        factory().logDefaultLoan(loanID_, loan.collateral);\\n\\n        // If necessary, trigger lender callback.\\n        if (loan.callback)\\n            CoolerCallback(loan.lender).onDefault(\\n                loanID_,\\n                loan.principal,\\n                loan.interestDue,\\n                loan.collateral\\n            );\\n\\n        return (loan.principal, loan.interestDue, loan.collateral, block.timestamp - loan.expiry);\\n    }\\n\\n    /// @notice Approve transfer of loan ownership rights to a new address.\\n    /// @param  to_ address to be approved.\\n    /// @param  loanID_ index of loan in loans[].\\n    function approveTransfer(address to_, uint256 loanID_) external {\\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\\n\\n        // Update transfer approvals.\\n        approvals[loanID_] = to_;\\n    }\\n\\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\\n    /// @param  loanID_ index of loan in loans[].\\n    function transferOwnership(uint256 loanID_) external {\\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\\n\\n        // Update the load lender and the recipient.\\n        loans[loanID_].lender = msg.sender;\\n        loans[loanID_].recipient = msg.sender;\\n        // Callbacks are disabled when transferring ownership.\\n        loans[loanID_].callback = false;\\n        // Clear transfer approvals.\\n        approvals[loanID_] = address(0);\\n    }\\n\\n    /// @notice Allow lender to set repayment recipient of a given loan.\\n    /// @param  loanID_ of lender's loan.\\n    /// @param  recipient_ reciever of repayments\\n    function setRepaymentAddress(uint256 loanID_, address recipient_) external {\\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\\n\\n        // Update the repayment method.\\n        loans[loanID_].recipient = recipient_;\\n    }\\n\\n    // --- AUX FUNCTIONS ---------------------------------------------\\n\\n    /// @notice Compute collateral needed for a desired loan amount at given loan to collateral ratio.\\n    /// @param  principal_ amount of debt tokens.\\n    /// @param  loanToCollateral_ ratio for loan. Expressed in 10**collateral().decimals().\\n    function collateralFor(\\n        uint256 principal_,\\n        uint256 loanToCollateral_\\n    ) public view returns (uint256) {\\n        return (principal_ * (10 ** collateral().decimals())) / loanToCollateral_;\\n    }\\n\\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\\n    /// @param  principal_ amount of debt tokens.\\n    /// @param  rate_ of interest (annualized).\\n    /// @param  duration_ of the loan in seconds.\\n    /// @return Interest in debt token terms.\\n    function interestFor(\\n        uint256 principal_,\\n        uint256 rate_,\\n        uint256 duration_\\n    ) public pure returns (uint256) {\\n        uint256 interest = (rate_ * duration_) / 365 days;\\n        return (principal_ * interest) / DECIMALS_INTEREST;\\n    }\\n\\n    /// @notice Check if given loan has expired.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @return Expiration status.\\n    function hasExpired(uint256 loanID_) external view returns (bool) {\\n        return block.timestamp > loans[loanID_].expiry;\\n    }\\n\\n    /// @notice Check if a given request is active.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @return Active status.\\n    function isActive(uint256 reqID_) external view returns (bool) {\\n        return requests[reqID_].active;\\n    }\\n\\n    /// @notice Getter for Request data as a struct.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @return Request struct.\\n    function getRequest(uint256 reqID_) external view returns (Request memory) {\\n        return requests[reqID_];\\n    }\\n\\n    /// @notice Getter for Loan data as a struct.\\n    /// @param loanID_ index of loan in loans[].\\n    /// @return Loan struct.\\n    function getLoan(uint256 loanID_) external view returns (Loan memory) {\\n        return loans[loanID_];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/modules/ROLES/ROLES.v1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport \\\"src/Kernel.sol\\\";\\n\\nabstract contract ROLESv1 is Module {\\n    // =========  EVENTS ========= //\\n\\n    event RoleGranted(bytes32 indexed role_, address indexed addr_);\\n    event RoleRevoked(bytes32 indexed role_, address indexed addr_);\\n\\n    // =========  ERRORS ========= //\\n\\n    error ROLES_InvalidRole(bytes32 role_);\\n    error ROLES_RequireRole(bytes32 role_);\\n    error ROLES_AddressAlreadyHasRole(address addr_, bytes32 role_);\\n    error ROLES_AddressDoesNotHaveRole(address addr_, bytes32 role_);\\n    error ROLES_RoleDoesNotExist(bytes32 role_);\\n\\n    // =========  STATE ========= //\\n\\n    /// @notice Mapping for if an address has a policy-defined role.\\n    mapping(address => mapping(bytes32 => bool)) public hasRole;\\n\\n    // =========  FUNCTIONS ========= //\\n\\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\\n    function saveRole(bytes32 role_, address addr_) external virtual;\\n\\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\\n    function removeRole(bytes32 role_, address addr_) external virtual;\\n\\n    /// @notice \\\"Modifier\\\" to restrict policy function access to certain addresses with a role.\\n    /// @dev    Roles are defined in the policy and granted by the ROLES admin.\\n    function requireRole(bytes32 role_, address caller_) external virtual;\\n\\n    /// @notice Function that checks if role is valid (all lower case)\\n    function ensureValidRole(bytes32 role_) external pure virtual;\\n}\\n\"\r\n    },\r\n    \"src/external/OlympusERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.7.5;\\n\\n/// @notice Olympus OHM token\\n/// @dev This contract is the legacy v2 OHM token. Included in the repo for completeness,\\n///      since it is not being changed and is imported in some contracts.\\n\\ninterface IOlympusAuthority {\\n    // =========  EVENTS ========= //\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    // =========  VIEW ========= //\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\\n// File: types/OlympusAccessControlled.sol\\n\\nabstract contract OlympusAccessControlled {\\n    // =========  EVENTS ========= //\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string internal UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    // =========  STATE VARIABLES ========= //\\n\\n    IOlympusAuthority public authority;\\n\\n    // =========  Constructor ========= //\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    // =========  MODIFIERS ========= //\\n\\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyPermitted() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    // =========  GOV ONLY ========= //\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\\n// File: cryptography/ECDSA.sol\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(\\n        bytes32 domainSeparator,\\n        bytes32 structHash\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\\n// File: cryptography/EIP712.sol\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = chainID;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        if (chainID == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\\n// File: interfaces/IERC20Permit.sol\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\\n// File: interfaces/IERC20.sol\\n\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n// File: interfaces/IOHM.sol\\n\\ninterface IOHM is IERC20 {\\n    function mint(address account_, uint256 amount_) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account_, uint256 amount_) external;\\n}\\n\\n// File: libraries/SafeMath.sol\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + (a % b)); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\\n        if (a > 3) {\\n            c = a;\\n            uint256 b = add(div(a, 2), 1);\\n            while (b < c) {\\n                c = b;\\n                b = div(add(div(a, b), b), 2);\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\\n// File: libraries/Counters.sol\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\\n// File: types/ERC20.sol\\n\\nabstract contract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    // TODO comment actual hash value.\\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256(\\\"ERC20Token\\\");\\n\\n    mapping(address => uint256) internal _balances;\\n\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n\\n    string internal _symbol;\\n\\n    uint8 internal immutable _decimals;\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            msg.sender,\\n            _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n        );\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(address from_, address to_, uint256 amount_) internal virtual {}\\n}\\n\\n// File: types/ERC20Permit.sol\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH =\\n        keccak256(\\n            \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n        );\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\\n        );\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\\n// File: OlympusERC20.sol\\n\\ncontract OlympusERC20Token is ERC20Permit, IOHM, OlympusAccessControlled {\\n    using SafeMath for uint256;\\n\\n    constructor(\\n        address _authority\\n    )\\n        ERC20(\\\"Olympus\\\", \\\"OHM\\\", 9)\\n        ERC20Permit(\\\"Olympus\\\")\\n        OlympusAccessControlled(IOlympusAuthority(_authority))\\n    {}\\n\\n    function mint(address account_, uint256 amount_) external override onlyVault {\\n        _mint(account_, amount_);\\n    }\\n\\n    function burn(uint256 amount) external override {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    function burnFrom(address account_, uint256 amount_) external override {\\n        _burnFrom(account_, amount_);\\n    }\\n\\n    function _burnFrom(address account_, uint256 amount_) internal {\\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(\\n            amount_,\\n            \\\"ERC20: burn amount exceeds allowance\\\"\\n        );\\n\\n        _approve(account_, msg.sender, decreasedAllowance_);\\n        _burn(account_, amount_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"modules/=src/modules/\",\r\n      \"policies/=src/policies/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"layer-zero/=lib/solidity-examples/contracts/\",\r\n      \"bonds/=lib/bonds/src/\",\r\n      \"test/=src/test/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"cooler/=lib/Cooler/src/\",\r\n      \"balancer-v2/=lib/balancer-v2/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"Cooler/=lib/Cooler/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"olympus-v3/=lib/Cooler/lib/olympus-v3/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-examples/=lib/solidity-examples/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ohm_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gohm_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staking_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sdai_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coolerFactory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"kernel_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadEscrow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DurationMaximum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"}],\"name\":\"KernelAdapter_OnlyKernel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthDiscrepancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBorrower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBurnable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFromFactory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"Keycode\",\"name\":\"keycode_\",\"type\":\"bytes5\"}],\"name\":\"Policy_ModuleDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooEarlyToFund\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Deactivate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Defund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Reactivate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"defund\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_CADENCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTEREST_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOAN_TO_COLLATERAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTR\",\"outputs\":[{\"internalType\":\"contract MINTRv1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLES\",\"outputs\":[{\"internalType\":\"contract ROLESv1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRSRY\",\"outputs\":[{\"internalType\":\"contract TRSRYv1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Kernel\",\"name\":\"newKernel_\",\"type\":\"address\"}],\"name\":\"changeKernel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"coolers_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"loans_\",\"type\":\"uint256[]\"}],\"name\":\"claimDefaulted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configureDependencies\",\"outputs\":[{\"internalType\":\"Keycode[]\",\"name\":\"dependencies\",\"type\":\"bytes5[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"defund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Cooler\",\"name\":\"cooler_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"times_\",\"type\":\"uint8\"}],\"name\":\"extendLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract CoolerFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal_\",\"type\":\"uint256\"}],\"name\":\"getCollateralForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_\",\"type\":\"uint256\"}],\"name\":\"getLoanForCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalReceivables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gohm\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"interestForLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestReceivables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCoolerCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"internalType\":\"contract Kernel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Cooler\",\"name\":\"cooler_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"lendToCooler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ohm\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"onDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principlePaid_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestPaid_\",\"type\":\"uint256\"}],\"name\":\"onRepay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalReceivables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestPermissions\",\"outputs\":[{\"components\":[{\"internalType\":\"Keycode\",\"name\":\"keycode\",\"type\":\"bytes5\"},{\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"}],\"internalType\":\"struct Permissions[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sdai\",\"outputs\":[{\"internalType\":\"contract ERC4626\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepIntoDSR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Clearinghouse", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "00000000000000000000000064aa3364f17a4d01c6f1751fd97c2bd3d7e7f1d50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b63cac384247597756545b500253ff8e607a802000000000000000000000000083f20f44975d03b1b09e64809b757c47f942beea000000000000000000000000de3e735d37a8498ad2f141f603a6d0f976a6f7720000000000000000000000002286d7f9639e8158fad1169e76d1fbc38247f54b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}