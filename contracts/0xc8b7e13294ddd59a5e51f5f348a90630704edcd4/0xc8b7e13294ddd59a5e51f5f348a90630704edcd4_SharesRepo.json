{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.8;\\n\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                set._values[toDeleteIndex] = lastValue;\\n                set._indexes[lastValue] = valueIndex;\\n            }\\n\\n            delete set._values[lastIndex];\\n            set._values.pop();\\n\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return set._values[index];\\n    }\\n\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    //======== Bytes32Set ========\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function length(Bytes32Set storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function values(Bytes32Set storage set)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return _values(set._inner);\\n    }\\n\\n    //======== AddressSet ========\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function length(AddressSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function values(AddressSet storage set)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    //======== UintSet ========\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) public returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function values(UintSet storage set)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SharesRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\nlibrary SharesRepo {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    struct Head {\\n        uint16 class; // \u80a1\u7968\u7c7b\u522b/\u8f6e\u6b21\u7f16\u53f7\\n        uint32 seqOfShare; // \u80a1\u7968\u5e8f\u5217\u53f7\\n        uint32 preSeq; // \u524d\u5e8f\u80a1\u7968\u5e8f\u5217\u53f7\uff08\u80a1\u8f6c\u65f6\u539f\u6807\u7684\u80a1\u5e8f\u5217\u53f7\uff09\\n        uint48 issueDate; // \u80a1\u7968\u7b7e\u53d1\u65e5\u671f\uff08\u79d2\u65f6\u95f4\u6233\uff09\\n        uint40 shareholder; // \u80a1\u4e1c\u4ee3\u7801\\n        uint32 priceOfPaid; // \u53d1\u884c\u4ef7\u683c\uff08\u5b9e\u7f34\u51fa\u8d44\u4ef7\uff09\\n        uint32 priceOfPar; // \u53d1\u884c\u4ef7\u683c\uff08\u8ba4\u7f34\u51fa\u8d44\u4ef7\uff09\\n        uint16 votingWeight; // \u8868\u51b3\u6743\u91cd\uff08\u767e\u5206\u70b9\uff09\\n        uint8 argu;\\n    }\\n\\n    struct Body {\\n        uint48 payInDeadline; // \u51fa\u8d44\u671f\u9650\uff08\u79d2\u65f6\u95f4\u6233\uff09\\n        uint64 paid; // \u5b9e\u7f34\u51fa\u8d44\\n        uint64 par; // \u8ba4\u7f34\u51fa\u8d44\uff08\u6ce8\u518c\u8d44\u672c\u9762\u503c\uff09\\n        uint64 cleanPaid; // \u6e05\u6d01\u5b9e\u7f34\u51fa\u8d44\uff08\u6263\u9664\u51fa\u8d28\u3001\u8fdc\u671f\u3001\u9500\u552e\u8981\u7ea6\u91d1\u989d\uff09\\n        uint8 state;\\n        uint8 para;\\n    }\\n\\n    //Share \u80a1\u7968\\n    struct Share {\\n        Head head; //\u51fa\u8d44\u8bc1\u660e\u4e66\u7f16\u53f7\uff08\u80a1\u7968\u7f16\u53f7\uff09\\n        Body body;\\n    }\\n\\n    struct Class{\\n        Share info;\\n        EnumerableSet.UintSet seqList;\\n    }\\n\\n    struct Repo {\\n        // seqOfClass => Class\\n        mapping(uint256 => Class) classes;\\n        // seqOfShare => Share\\n        mapping(uint => Share) shares;\\n    }\\n\\n    //####################\\n    //##    Modifier    ##\\n    //####################\\n\\n    modifier shareExist(\\n        Repo storage repo,\\n        uint seqOfShare\\n    ) {\\n        require(isShare(repo, seqOfShare),\\n            \\\"SR.shareExist: not\\\");\\n        _;\\n    }\\n\\n    //#################\\n    //##    Write    ##\\n    //#################\\n\\n    function snParser(bytes32 sn) public pure returns(Head memory head)\\n    {\\n        uint _sn = uint(sn);\\n        \\n        head = Head({\\n            class: uint16(_sn >> 240),\\n            seqOfShare: uint32(_sn >> 208),\\n            preSeq: uint32(_sn >> 176),\\n            issueDate: uint48(_sn >> 128),\\n            shareholder: uint40(_sn >> 88),\\n            priceOfPaid: uint32(_sn >> 56),\\n            priceOfPar: uint32(_sn >> 24),\\n            votingWeight: uint16(_sn >> 8),\\n            argu: uint8(_sn)\\n        });\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns (bytes32 sn)\\n    {\\n        bytes memory _sn = \\n            abi.encodePacked(\\n                head.class, \\n                head.seqOfShare, \\n                head.preSeq, \\n                head.issueDate, \\n                head.shareholder, \\n                head.priceOfPaid, \\n                head.priceOfPar, \\n                head.votingWeight, \\n                head.argu\\n            );\\n\\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n\\n    }\\n\\n    // ==== issue/regist share ====\\n\\n    function createShare(\\n        bytes32 sharenumber, \\n        uint payInDeadline, \\n        uint paid, \\n        uint par\\n    ) public pure returns (Share memory share) {\\n\\n        share.head = snParser(sharenumber);\\n\\n        share.body = Body({\\n            payInDeadline: uint48(payInDeadline),\\n            paid: uint64(paid),\\n            par: uint64(par),\\n            cleanPaid: uint64(paid),\\n            state: 0,\\n            para: 0\\n        });\\n    }\\n\\n    function addShare(Repo storage repo, Share memory share)\\n        public returns(Share memory newShare) \\n    {\\n        newShare = regShare(repo, share);\\n\\n        Share storage info = repo.classes[newShare.head.class].info;\\n\\n        if (info.head.issueDate == 0) \\n            repo.classes[newShare.head.class].info.head = \\n                newShare.head;\\n    }\\n\\n    function regShare(Repo storage repo, Share memory share)\\n        public returns(Share memory)\\n    {\\n        require(share.head.class > 0, \\\"SR.regShare: zero class\\\");\\n        require(share.body.par > 0, \\\"SR.regShare: zero par\\\");\\n        require(share.body.par >= share.body.paid, \\\"SR.regShare: paid overflow\\\");\\n        require(share.head.issueDate <= block.timestamp, \\\"SR.regShare: future issueDate\\\");\\n        require(share.head.issueDate <= share.body.payInDeadline, \\\"SR.regShare: issueDate later than payInDeadline\\\");\\n        require(share.head.shareholder > 0, \\\"SR.regShare: zero shareholder\\\");\\n        require(share.head.votingWeight > 0, \\\"SR.regShare: zero votingWeight\\\");\\n\\n        if (share.head.class > counterOfClasses(repo))\\n            share.head.class = _increaseCounterOfClasses(repo);\\n\\n        Class storage class = repo.classes[share.head.class];\\n\\n        if (!class.seqList.contains(share.head.seqOfShare)) {\\n            share.head.seqOfShare = _increaseCounterOfShares(repo);\\n                        \\n            if (share.head.issueDate == 0)\\n                share.head.issueDate = uint48(block.timestamp);\\n\\n            class.seqList.add(share.head.seqOfShare);\\n            repo.classes[0].seqList.add(share.head.seqOfShare);\\n        }\\n\\n        repo.shares[share.head.seqOfShare] = share;\\n\\n        return share;\\n    }\\n\\n    // ==== counters ====\\n\\n    function _increaseCounterOfShares(\\n        Repo storage repo\\n    ) private returns(uint32) {\\n\\n        Head storage h = repo.shares[0].head;\\n\\n        do {\\n            unchecked {\\n                h.seqOfShare++;                \\n            }\\n        } while (isShare(repo, h.seqOfShare) || \\n            h.seqOfShare == 0);\\n\\n        return h.seqOfShare;\\n    }\\n\\n    function _increaseCounterOfClasses(Repo storage repo) \\n        private returns(uint16)\\n    {\\n        repo.shares[0].head.class++;\\n        return repo.shares[0].head.class;\\n    }\\n\\n    // ==== amountChange ====\\n\\n    function payInCapital(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint amt\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint64 deltaPaid = uint64(amt);\\n\\n        require(deltaPaid > 0, \\\"SR.payInCap: zero amt\\\");\\n\\n        require(block.timestamp <= share.body.payInDeadline, \\n            \\\"SR.payInCap: missed deadline\\\");\\n\\n        require(share.body.paid + deltaPaid <= share.body.par, \\n            \\\"SR.payInCap: amt overflow\\\");\\n\\n        share.body.paid += deltaPaid;\\n        share.body.cleanPaid += deltaPaid;\\n\\n    }\\n\\n    function subAmtFromShare(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint paid, \\n        uint par\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n        Class storage class = repo.classes[share.head.class];\\n\\n        uint64 deltaPaid = uint64(paid);\\n        uint64 deltaPar = uint64(par);\\n\\n        require(deltaPar > 0, \\\"SR.subAmt: zero par\\\");\\n        require(share.body.cleanPaid >= deltaPaid, \\\"SR.subAmt: insufficient cleanPaid\\\");\\n\\n        if (deltaPar == share.body.par) {            \\n            class.seqList.remove(seqOfShare);\\n            repo.classes[0].seqList.remove(seqOfShare);\\n            delete repo.shares[seqOfShare];\\n        } else {\\n            share.body.paid -= deltaPaid;\\n            share.body.par -= deltaPar;\\n            share.body.cleanPaid -= deltaPaid;\\n\\n            require(share.body.par >= share.body.paid,\\n                \\\"SR.subAmt: result paid overflow\\\");\\n        }\\n    }\\n\\n    function increaseCleanPaid(\\n        Repo storage repo,\\n        bool isIncrease,\\n        uint seqOfShare,\\n        uint paid\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint64 deltaClean = uint64(paid);\\n\\n        require(deltaClean > 0, \\\"SR.incrClean: zero amt\\\");\\n\\n        if (isIncrease && share.body.cleanPaid + deltaClean <= share.body.paid) \\n            share.body.cleanPaid += deltaClean;\\n        else if(!isIncrease && share.body.cleanPaid >= deltaClean)\\n            share.body.cleanPaid -= deltaClean;\\n        else revert(\\\"SR.incrClean: clean overflow\\\");\\n    }\\n\\n    // ---- EquityOfClass ----\\n\\n    function increaseEquityOfClass(\\n        Repo storage repo,\\n        bool isIncrease,\\n        uint classOfShare,\\n        uint deltaPaid,\\n        uint deltaPar,\\n        uint deltaCleanPaid\\n    ) public {\\n\\n        Body storage equity = repo.classes[classOfShare].info.body;\\n\\n        if (isIncrease) {\\n            equity.paid += uint64(deltaPaid);\\n            equity.par += uint64(deltaPar);\\n            equity.cleanPaid += uint64(deltaCleanPaid);\\n        } else {\\n            equity.paid -= uint64(deltaPaid);\\n            equity.par -= uint64(deltaPar);\\n            equity.cleanPaid -= uint64(deltaCleanPaid);            \\n        }\\n    }\\n\\n    function updatePriceOfPaid(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint newPrice\\n    ) public shareExist(repo, seqOfShare) {\\n        Share storage share = repo.shares[seqOfShare];\\n        share.head.priceOfPaid = uint32(newPrice);\\n    }\\n\\n    function updatePayInDeadline(\\n        Repo storage repo,\\n        uint seqOfShare,\\n        uint deadline\\n    ) public shareExist(repo, seqOfShare) {\\n\\n        Share storage share = repo.shares[seqOfShare];\\n\\n        uint48 newLine = uint48(deadline);\\n\\n        require (block.timestamp < newLine, \\n            \\\"SR.updatePayInDeadline: not future\\\");\\n\\n        share.body.payInDeadline = newLine;\\n    }\\n\\n    //####################\\n    //##    Read I/O    ##\\n    //####################\\n\\n    // ---- Counter ----\\n\\n    function counterOfShares(\\n        Repo storage repo\\n    ) public view returns(uint32) {\\n        return repo.shares[0].head.seqOfShare;\\n    }\\n\\n    function counterOfClasses(\\n        Repo storage repo\\n    ) public view returns(uint16) {\\n        return repo.shares[0].head.class;\\n    }\\n\\n    // ---- Share ----\\n\\n    function isShare(\\n        Repo storage repo, \\n        uint seqOfShare\\n    ) public view returns(bool) {\\n        return repo.shares[seqOfShare].head.issueDate > 0;\\n    }\\n\\n    function getShare(\\n        Repo storage repo, \\n        uint seqOfShare\\n    ) public view shareExist(repo, seqOfShare) returns (\\n        Share memory\\n    ) {\\n        return repo.shares[seqOfShare];\\n    }\\n\\n    function getQtyOfShares(\\n        Repo storage repo\\n    ) public view returns(uint) {\\n        return repo.classes[0].seqList.length();\\n    }\\n\\n    function getSeqListOfShares(\\n        Repo storage repo\\n    ) public view returns(uint[] memory) {\\n        return repo.classes[0].seqList.values();\\n    }\\n\\n    function getSharesList(\\n        Repo storage repo\\n    ) public view returns(Share[] memory) {\\n        uint[] memory seqList = repo.classes[0].seqList.values();\\n        return _getShares(repo, seqList);\\n    }\\n\\n    // ---- Class ----    \\n\\n    function getQtyOfSharesInClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (uint) {\\n        return repo.classes[classOfShare].seqList.length();\\n    }\\n\\n    function getSeqListOfClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (uint[] memory) {\\n        return repo.classes[classOfShare].seqList.values();\\n    }\\n\\n    function getInfoOfClass(\\n        Repo storage repo,\\n        uint classOfShare\\n    ) public view returns (Share memory) {\\n        return repo.classes[classOfShare].info;\\n    }\\n\\n    function getSharesOfClass(\\n        Repo storage repo, \\n        uint classOfShare\\n    ) public view returns (Share[] memory) {\\n        uint[] memory seqList = \\n            repo.classes[classOfShare].seqList.values();\\n        return _getShares(repo, seqList);\\n    }\\n\\n    function _getShares(\\n        Repo storage repo,\\n        uint[] memory seqList\\n    ) private view returns(Share[] memory list) {\\n\\n        uint len = seqList.length;\\n        list = new Share[](len);\\n\\n        while(len > 0) {\\n            list[len - 1] = repo.shares[seqList[len - 1]];\\n            len--;\\n        }\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/EnumerableSet.sol\": {\r\n        \"EnumerableSet\": \"0xc4f24b69792ff96f0316fab2d7df198af8033930\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"class\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"seqOfShare\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"preSeq\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"issueDate\",\"type\":\"uint48\"},{\"internalType\":\"uint40\",\"name\":\"shareholder\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPaid\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPar\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"votingWeight\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"argu\",\"type\":\"uint8\"}],\"internalType\":\"struct SharesRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"name\":\"codifyHead\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sharenumber\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payInDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"par\",\"type\":\"uint256\"}],\"name\":\"createShare\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"class\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"seqOfShare\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"preSeq\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"issueDate\",\"type\":\"uint48\"},{\"internalType\":\"uint40\",\"name\":\"shareholder\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPaid\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPar\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"votingWeight\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"argu\",\"type\":\"uint8\"}],\"internalType\":\"struct SharesRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"payInDeadline\",\"type\":\"uint48\"},{\"internalType\":\"uint64\",\"name\":\"paid\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"par\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"cleanPaid\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"para\",\"type\":\"uint8\"}],\"internalType\":\"struct SharesRepo.Body\",\"name\":\"body\",\"type\":\"tuple\"}],\"internalType\":\"struct SharesRepo.Share\",\"name\":\"share\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"name\":\"snParser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"class\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"seqOfShare\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"preSeq\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"issueDate\",\"type\":\"uint48\"},{\"internalType\":\"uint40\",\"name\":\"shareholder\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPaid\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"priceOfPar\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"votingWeight\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"argu\",\"type\":\"uint8\"}],\"internalType\":\"struct SharesRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SharesRepo", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}