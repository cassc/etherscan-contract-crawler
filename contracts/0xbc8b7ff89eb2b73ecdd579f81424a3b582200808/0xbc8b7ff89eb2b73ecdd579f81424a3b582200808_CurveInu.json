{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"script/Curvy.flat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NONE\\npragma solidity 0.8.19;\\n\\n// Website: https://crvy.wtf/\\n// Twitter: https://twitter.com/CurveInu\\n// Telegram: https://t.me/+GHy795RoC7UwOTZh\\n//\\n// Welcome to the Dogepound!\\n// Curvy is a Liquidity Layer accumulator aiming to educate and raise awareness about Curve.\\n// This is a pure meme coin, so don't expect profits; this project might not succeed.\\n// We either thrive in the ongoing Curve Wars or perish in the bera market.\\n// For updates, follow us on Twitter: https://twitter.com/CurveInu\\n// Visit our website: https://crvy.wtf/\\n//\\n// TAX: 6.66%\\n// - 1.11% tax on both buying and selling for the Helper Treasury\\n// - 2.22% used to buy CRV (to be held)\\n// - 3.333% directed to the LP Pool (for compounding over time)\\n//\\n// FEATURES:\\n// - ANTI-SNIPE: Gradually increasing the amount of supply you can purchase per block during the first day of launch\\n// - UP ONLY: No selling allowed for the first 20 minutes\\n// - ANTI-SANDWICH: Users can only execute one trade per block\\n// - FETCH: Users can trigger the fetch function to earn CRVY and contribute to compounding our LP holdings!\\n//\\n// TOKENOMICS:\\n// - 75% of the supply is seeded to LP and locked for 2 years\\n// - 15% allocated for marketing\\n// - 10% reserved for exchange listings\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(\\n        address indexed user, address indexed newOwner\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from, address indexed to, uint256 amount\\n    );\\n\\n    event Approval(\\n        address indexed owner, address indexed spender, uint256 amount\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) {\\n            allowance[from][msg.sender] = allowed - amount;\\n        }\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(\\n            deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\"\\n        );\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(\\n                recoveredAddress != address(0)\\n                    && recoveredAddress == owner,\\n                \\\"INVALID_SIGNER\\\"\\n            );\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR()\\n        public\\n        view\\n        virtual\\n        returns (bytes32)\\n    {\\n        return block.chainid == INITIAL_CHAIN_ID\\n            ? INITIAL_DOMAIN_SEPARATOR\\n            : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator()\\n        internal\\n        view\\n        virtual\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"1\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Append and mask the \\\"from\\\" argument.\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(\\n                        and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                        iszero(returndatasize())\\n                    ),\\n                    // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n                )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(ERC20 token, address to, uint256 amount)\\n        internal\\n    {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(\\n                        and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                        iszero(returndatasize())\\n                    ),\\n                    // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n                )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(ERC20 token, address to, uint256 amount)\\n        internal\\n    {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(\\n                        and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                        iszero(returndatasize())\\n                    ),\\n                    // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n                )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\\ninterface IFactory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IRouter {\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n}\\n\\ncontract Vesting {\\n    address public immutable token;\\n    address public immutable to;\\n    uint256 public immutable timeVested;\\n\\n    constructor(address _token, address _to, uint256 _timeVested) {\\n        token = _token;\\n        to = _to;\\n        timeVested = _timeVested;\\n    }\\n\\n    function pull() external virtual {\\n        require(block.timestamp >= timeVested, \\\"Vesting: wait\\\");\\n        ERC20(token).transfer(\\n            to, ERC20(token).balanceOf(address(this))\\n        );\\n    }\\n}\\n\\n/// Website: https://CRVY.wtf\\n/// Twitter: https://twitter.com/CurveInu\\n/// Telegram: https://t.me/+GHy795RoC7UwOTZh\\ncontract CurveInu is Owned, ERC20(\\\"Curve Inu\\\", \\\"CRVY\\\", 18) {\\n    using SafeTransferLib for ERC20;\\n    using SafeTransferLib for address;\\n\\n    event Fetch(uint256);\\n    event FetchCallerFeeSet(uint256);\\n    event ExcludedSet(address, bool);\\n\\n    bool public initialized;\\n    uint256 public fetchCallerFeeBips;\\n    mapping(address => bool) public isExcluded;\\n    mapping(address => mapping(uint256 => bool)) public\\n        isTransferSpent;\\n    mapping(uint256 => uint256) public transferedOnBlock;\\n\\n    uint256 internal constant divisorBips = 10_000;\\n    uint256 public constant liquidityTaxBips = 333;\\n    uint256 public constant investmentTaxBips = 222;\\n    uint256 public constant marketingTaxBips = 111;\\n    uint256 public constant vestingTimeSeconds = 2 * 365 days;\\n    uint256 public constant totalTaxBips =\\n        liquidityTaxBips + investmentTaxBips + marketingTaxBips;\\n\\n    IRouter public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n    address public immutable wrappedEther;\\n    address public immutable liquidityVesting;\\n    uint256 public immutable timeSellingAllowed;\\n    uint256 public immutable timeRemoveAntiSnipe;\\n    uint256 public immutable timeCreated;\\n\\n    constructor(\\n        IFactory factory,\\n        IRouter router,\\n        address treasury,\\n        address weth,\\n        uint256 supplyToTreasury,\\n        uint256 supplyToLiquidity,\\n        uint256 secondsSellingDisabled,\\n        uint256 secondsAntiSnipeEnabled\\n    ) Owned(treasury) {\\n        address pair = factory.createPair(address(this), weth);\\n        uniswapV2Pair = pair;\\n        uniswapV2Router = router;\\n        wrappedEther = weth;\\n        timeSellingAllowed = block.timestamp + secondsSellingDisabled;\\n        timeRemoveAntiSnipe =\\n            block.timestamp + secondsAntiSnipeEnabled;\\n        timeCreated = block.timestamp;\\n        uint256 timeVested = block.timestamp + vestingTimeSeconds;\\n        liquidityVesting =\\n            address(new Vesting(pair, treasury, timeVested));\\n        _mint(treasury, supplyToTreasury);\\n        _mint(address(this), supplyToLiquidity);\\n        allowance[address(this)][address(uniswapV2Router)] =\\n            type(uint256).max;\\n        emit Approval(\\n            address(this), address(uniswapV2Router), type(uint256).max\\n        );\\n        isExcluded[address(treasury)] = true;\\n        emit ExcludedSet(address(treasury), true);\\n        isExcluded[address(router)] = true;\\n        emit ExcludedSet(address(router), true);\\n        isExcluded[address(this)] = true;\\n        emit ExcludedSet(address(this), true);\\n        fetchCallerFeeBips = 500;\\n        emit FetchCallerFeeSet(500);\\n    }\\n\\n    function initialize() external payable virtual onlyOwner {\\n        require(!initialized);\\n\\n        uniswapV2Router.addLiquidityETH{value: msg.value}({\\n            token: address(this),\\n            amountTokenDesired: balanceOf[address(this)],\\n            amountTokenMin: 0,\\n            amountETHMin: 0,\\n            to: address(liquidityVesting),\\n            deadline: block.timestamp\\n        });\\n\\n        initialized = true;\\n    }\\n\\n    function setIsExcluded(address account, bool excluded)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        isExcluded[account] = excluded;\\n        emit ExcludedSet(account, excluded);\\n    }\\n\\n    function setFetchCallerFee(uint256 fee)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        require(fee <= 1000, \\\"Curve Inu: fee exceeds 10%\\\");\\n        fetchCallerFeeBips = fee;\\n        emit FetchCallerFeeSet(fee);\\n    }\\n\\n    function fetch() external virtual {\\n        uint256 balance = balanceOf[address(this)];\\n        uint256 fetchFee = balance * fetchCallerFeeBips / divisorBips;\\n        uint256 balanceMinusFee = balance - fetchFee;\\n        if (balanceMinusFee != 0) {\\n            uint256 liquidityTaxHalf = liquidityTaxBips / 2;\\n            uint256 totalTax = liquidityTaxBips + investmentTaxBips\\n                + marketingTaxBips;\\n            uint256 percentToEth =\\n                divisorBips * (totalTax - liquidityTaxHalf) / totalTax;\\n            uint256 tokensIn =\\n                balanceMinusFee * percentToEth / divisorBips;\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = wrappedEther;\\n            uniswapV2Router.swapExactTokensForETH(\\n                tokensIn, 0, path, address(this), block.timestamp\\n            );\\n            uint256 tokensToLiquidity = balanceMinusFee - tokensIn;\\n            uint256 etherToLiquidity = address(this).balance\\n                - address(this).balance\\n                    * (investmentTaxBips + marketingTaxBips)\\n                    / (totalTax - liquidityTaxHalf);\\n            uniswapV2Router.addLiquidityETH{value: etherToLiquidity}({\\n                token: address(this),\\n                amountTokenDesired: tokensToLiquidity,\\n                amountTokenMin: 0,\\n                amountETHMin: 0,\\n                to: address(liquidityVesting),\\n                deadline: block.timestamp\\n            });\\n            owner.safeTransferETH(address(this).balance);\\n            _transferWithTax(address(this), msg.sender, fetchFee);\\n        }\\n        emit Fetch(balanceMinusFee);\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _transferWithTax(msg.sender, to, amount);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[from][msg.sender];\\n        if (allowed != type(uint256).max) {\\n            allowance[from][msg.sender] = allowed - amount;\\n        }\\n        return _transferWithTax(from, to, amount);\\n    }\\n\\n    function _transferWithTax(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual returns (bool) {\\n        if (from != address(this) && to == uniswapV2Pair) {\\n            require(\\n                block.timestamp >= timeSellingAllowed,\\n                \\\"Curve Inu: cannot sell yet\\\"\\n            );\\n        }\\n\\n        if (tx.origin == from || tx.origin == to) {\\n            require(\\n                !isTransferSpent[tx.origin][block.number],\\n                \\\"Curve Inu: transfer spent\\\"\\n            );\\n            isTransferSpent[tx.origin][block.number] = true;\\n        }\\n\\n        uint256 tax;\\n        if (from.code.length != 0 || to.code.length != 0) {\\n            if (!isExcluded[from] && !isExcluded[to]) {\\n                uint256 liquidityTax =\\n                    amount * liquidityTaxBips / divisorBips;\\n                uint256 investmentTax =\\n                    amount * investmentTaxBips / divisorBips;\\n                uint256 exchangeTax =\\n                    amount * marketingTaxBips / divisorBips;\\n                tax = liquidityTax + investmentTax + exchangeTax;\\n\\n                if (block.timestamp < timeRemoveAntiSnipe) {\\n                    uint256 newtotalTransfered =\\n                        transferedOnBlock[block.number] + amount;\\n                    unchecked {\\n                        require(\\n                            newtotalTransfered\\n                                < maxPurchaseAtTime(block.timestamp),\\n                            \\\"Curve Inu: anti snipe\\\"\\n                        );\\n                    }\\n                    transferedOnBlock[block.number] =\\n                        newtotalTransfered;\\n                }\\n            }\\n        }\\n        balanceOf[from] -= amount;\\n        unchecked {\\n            uint256 amountAdjusted = amount - tax;\\n            balanceOf[to] += amountAdjusted;\\n            if (tax != 0) {\\n                balanceOf[address(this)] += tax;\\n                emit Transfer(from, address(this), tax);\\n            }\\n            emit Transfer(from, to, amountAdjusted);\\n        }\\n        return true;\\n    }\\n\\n    function maxPurchaseAtTime(uint256 time)\\n        public\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 supply = totalSupply;\\n        if (time > timeRemoveAntiSnipe) return supply;\\n        return supply * (time - timeCreated)\\n            / (timeRemoveAntiSnipe - timeCreated);\\n    }\\n\\n    receive() external payable virtual {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IRouter\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supplyToTreasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyToLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsSellingDisabled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsAntiSnipeEnabled\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"ExcludedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Fetch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FetchCallerFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchCallerFeeBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentTaxBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTaxBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityVesting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTaxBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"maxPurchaseAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFetchCallerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setIsExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeRemoveAntiSnipe\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSellingAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTaxBips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferedOnBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingTimeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedEther\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CurveInu", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000006b94ebf5a6704164b6d83e15d07a90e62a67e2e0000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000002863c1f5cdae42f9540000000000000000000000000000000000000000000000792b45e1690ac8ebfc00000000000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}