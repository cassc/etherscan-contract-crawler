{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-04-02\r\n*/\r\n\r\n// Sources flattened with buidler v1.2.0 https://buidler.dev\r\n\r\n// File @pie-dao/proxy/contracts/PProxyStorage.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\ncontract PProxyStorage {\r\n\r\n    function readString(bytes32 _key) public view returns(string memory) {\r\n        return bytes32ToString(storageRead(_key));\r\n    }\r\n\r\n    function setString(bytes32 _key, string memory _value) internal {\r\n        storageSet(_key, stringToBytes32(_value));\r\n    }\r\n\r\n    function readBool(bytes32 _key) public view returns(bool) {\r\n        return storageRead(_key) == bytes32(uint256(1));\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value) internal {\r\n        if(_value) {\r\n            storageSet(_key, bytes32(uint256(1)));\r\n        } else {\r\n            storageSet(_key, bytes32(uint256(0)));\r\n        }\r\n    }\r\n\r\n    function readAddress(bytes32 _key) public view returns(address) {\r\n        return bytes32ToAddress(storageRead(_key));\r\n    }\r\n\r\n    function setAddress(bytes32 _key, address _value) internal {\r\n        storageSet(_key, addressToBytes32(_value));\r\n    }\r\n\r\n    function storageRead(bytes32 _key) public view returns(bytes32) {\r\n        bytes32 value;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := sload(_key)\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function storageSet(bytes32 _key, bytes32 _value) internal {\r\n        // targetAddress = _address;  // No!\r\n        bytes32 implAddressStorageKey = _key;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(implAddressStorageKey, _value)\r\n        }\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\r\n        return address(uint160(uint256(_value)));\r\n    }\r\n\r\n    function addressToBytes32(address _value) public pure returns(bytes32) {\r\n        return bytes32(uint256(_value));\r\n    }\r\n\r\n    function stringToBytes32(string memory _value) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(_value);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(_value, 32))\r\n        }\r\n    }\r\n\r\n    function bytes32ToString(bytes32 _value) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_value) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n\r\n// File @pie-dao/proxy/contracts/PProxy.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\ncontract PProxy is PProxyStorage {\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\"IMPLEMENTATION_SLOT\"));\r\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\"OWNER_SLOT\"));\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == readAddress(OWNER_SLOT), \"PProxy.onlyProxyOwner: msg sender not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        setAddress(OWNER_SLOT, msg.sender);\r\n    }\r\n\r\n    function getProxyOwner() public view returns (address) {\r\n       return readAddress(OWNER_SLOT);\r\n    }\r\n\r\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\r\n        setAddress(OWNER_SLOT, _newOwner);\r\n    }\r\n\r\n    function getImplementation() public view returns (address) {\r\n        return readAddress(IMPLEMENTATION_SLOT);\r\n    }\r\n\r\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\r\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\r\n    }\r\n\r\n\r\n    fallback () external payable {\r\n       return internalFallback();\r\n    }\r\n\r\n    function internalFallback() internal virtual {\r\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File @pie-dao/proxy/contracts/PProxyPausable.sol@v0.0.6\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\ncontract PProxyPausable is PProxy {\r\n\r\n    bytes32 constant PAUSED_SLOT = keccak256(abi.encodePacked(\"PAUSED_SLOT\"));\r\n    bytes32 constant PAUZER_SLOT = keccak256(abi.encodePacked(\"PAUZER_SLOT\"));\r\n\r\n    constructor() PProxy() public {\r\n        setAddress(PAUZER_SLOT, msg.sender);\r\n    }\r\n\r\n    modifier onlyPauzer() {\r\n        require(msg.sender == readAddress(PAUZER_SLOT), \"PProxyPausable.onlyPauzer: msg sender not pauzer\");\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!readBool(PAUSED_SLOT), \"PProxyPausable.notPaused: contract is paused\");\r\n        _;\r\n    }\r\n\r\n    function getPauzer() public view returns (address) {\r\n        return readAddress(PAUZER_SLOT);\r\n    }\r\n\r\n    function setPauzer(address _newPauzer) public onlyProxyOwner{\r\n        setAddress(PAUZER_SLOT, _newPauzer);\r\n    }\r\n\r\n    function renouncePauzer() public onlyPauzer {\r\n        setAddress(PAUZER_SLOT, address(0));\r\n    }\r\n\r\n    function getPaused() public view returns (bool) {\r\n        return readBool(PAUSED_SLOT);\r\n    }\r\n\r\n    function setPaused(bool _value) public onlyPauzer {\r\n        setBool(PAUSED_SLOT, _value);\r\n    }\r\n\r\n    function internalFallback() internal virtual override notPaused {\r\n        super.internalFallback();\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IBFactory {\r\n    function newBPool() external returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBPool.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is disstributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IBPool {\r\n    function isBound(address token) external view returns(bool);\r\n    function getBalance(address token) external view returns (uint);\r\n    function rebind(address token, uint balance, uint denorm) external;\r\n    function setSwapFee(uint swapFee) external;\r\n    function setPublicSwap(bool _public) external;\r\n    function bind(address token, uint balance, uint denorm) external;\r\n    function unbind(address token) external;\r\n    function getDenormalizedWeight(address token) external view returns (uint);\r\n    function getTotalDenormalizedWeight() external view returns (uint);\r\n    function getCurrentTokens() external view returns(address[] memory);\r\n    function setController(address manager) external;\r\n    function isPublicSwap() external view returns(bool);\r\n    function getSwapFee() external view returns (uint256);\r\n    function gulp(address token) external;\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountOut);\r\n\r\n    function calcSingleInGivenPoolOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountIn);\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountOut);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountIn);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\r\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _whom) external view returns (uint);\r\n    function allowance(address _src, address _dst) external view returns (uint);\r\n\r\n    function approve(address _dst, uint _amount) external returns (bool);\r\n    function transfer(address _dst, uint _amount) external returns (bool);\r\n    function transferFrom(\r\n        address _src, address _dst, uint _amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Ownable.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n// TODO move this generic contract to a seperate repo with all generic smart contracts\r\n\r\ncontract Ownable {\r\n\r\n    bytes32 constant public oSlot = keccak256(\"Ownable.storage.location\");\r\n\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Ownable struct\r\n    struct os {\r\n        address owner;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == los().owner, \"Ownable.onlyOwner: msg.sender not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @notice Transfer ownership to a new address\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function transferOwnership(address _newOwner) onlyOwner external {\r\n        _setOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n        @notice Internal method to set the owner\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function _setOwner(address _newOwner) internal {\r\n        emit OwnerChanged(los().owner, _newOwner);\r\n        los().owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @notice Load ownable storage\r\n        @return s Storage pointer to the Ownable storage struct\r\n    */\r\n    function los() internal pure returns (os storage s) {\r\n        bytes32 loc = oSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPSmartPool.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IPSmartPool is IERC20 {\r\n    function joinPool(uint256 _amount) external;\r\n    function exitPool(uint256 _amount) external;\r\n    function getController() external view returns(address);\r\n    function getTokens() external view returns(address[] memory);\r\n    function calcTokensForAmount(uint256 _amount) external view  returns(address[] memory tokens, uint256[] memory amounts);\r\n}\r\n\r\n\r\n// File contracts/PCTokenStorage.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ncontract PCTokenStorage {\r\n\r\n    bytes32 constant public ptSlot = keccak256(\"PCToken.storage.location\");\r\n    struct pts {\r\n        string name;\r\n        string symbol;\r\n        uint256 totalSupply;\r\n        mapping(address => uint256) balance;\r\n        mapping(address => mapping(address=>uint256)) allowance;\r\n    }\r\n\r\n    /**\r\n        @notice Load pool token storage\r\n        @return s Storage pointer to the pool token struct\r\n    */\r\n    function lpts() internal pure returns (pts storage s) {\r\n        bytes32 loc = ptSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/PCToken.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n// Highly opinionated token implementation\r\n// Based on the balancer Implementation\r\n\r\n\r\ncontract PCToken is IERC20, PCTokenStorage {\r\n\r\n    event Approval(address indexed _src, address indexed _dst, uint _amount);\r\n    event Transfer(address indexed _src, address indexed _dst, uint _amount);\r\n\r\n    uint8 public constant decimals = 18;\r\n    uint public constant BONE              = 10**18;\r\n    uint public constant MAX_BOUND_TOKENS  = 8;\r\n    uint public constant MIN_WEIGHT        = BONE;\r\n    uint public constant MAX_WEIGHT        = BONE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\r\n    uint public constant MIN_BALANCE       = BONE / 10**6;\r\n    uint public constant MAX_BALANCE       = BONE * 10**12;\r\n\r\n    uint public constant MIN_POOL_SUPPLY   = BONE;\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    function _mint(uint _amount) internal {\r\n        pts storage s = lpts();\r\n        s.balance[address(this)] = badd(s.balance[address(this)], _amount);\r\n        s.totalSupply = badd(s.totalSupply, _amount);\r\n        emit Transfer(address(0), address(this), _amount);\r\n    }\r\n\r\n    function _burn(uint _amount) internal {\r\n        pts storage s = lpts();\r\n        require(s.balance[address(this)] >= _amount, \"ERR_INSUFFICIENT_BAL\");\r\n        s.balance[address(this)] = bsub(s.balance[address(this)], _amount);\r\n        s.totalSupply = bsub(s.totalSupply, _amount);\r\n        emit Transfer(address(this), address(0), _amount);\r\n    }\r\n\r\n    function _move(address _src, address _dst, uint _amount) internal {\r\n        pts storage s = lpts();\r\n        require(s.balance[_src] >= _amount, \"ERR_INSUFFICIENT_BAL\");\r\n        s.balance[_src] = bsub(s.balance[_src], _amount);\r\n        s.balance[_dst] = badd(s.balance[_dst], _amount);\r\n        emit Transfer(_src, _dst, _amount);\r\n    }\r\n\r\n    function _push(address _to, uint _amount) internal {\r\n        _move(address(this), _to, _amount);\r\n    }\r\n\r\n    function _pull(address _from, uint _amount) internal {\r\n        _move(_from, address(this), _amount);\r\n    }\r\n\r\n    function allowance(address _src, address _dst) external view override returns (uint) {\r\n        return lpts().allowance[_src][_dst];\r\n    }\r\n\r\n    function balanceOf(address _whom) external view override returns (uint) {\r\n        return lpts().balance[_whom];\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint) {\r\n        return lpts().totalSupply;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return lpts().name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return lpts().symbol;\r\n    }\r\n\r\n    function approve(address _dst, uint _amount) external override returns (bool) {\r\n        lpts().allowance[msg.sender][_dst] = _amount;\r\n        emit Approval(msg.sender, _dst, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _dst, uint _amount) external returns (bool) {\r\n        pts storage s = lpts();\r\n        s.allowance[msg.sender][_dst] = badd(s.allowance[msg.sender][_dst], _amount);\r\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _dst, uint _amount) external returns (bool) {\r\n        pts storage s = lpts();\r\n        uint oldValue = s.allowance[msg.sender][_dst];\r\n        if (_amount > oldValue) {\r\n            s.allowance[msg.sender][_dst] = 0;\r\n        } else {\r\n            s.allowance[msg.sender][_dst] = bsub(oldValue, _amount);\r\n        }\r\n        emit Approval(msg.sender, _dst, s.allowance[msg.sender][_dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _dst, uint _amount) external override returns (bool) {\r\n        _move(msg.sender, _dst, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _src, address _dst, uint _amount) external override returns (bool) {\r\n        pts storage s = lpts();\r\n        require(msg.sender == _src || _amount <= s.allowance[_src][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\r\n        _move(_src, _dst, _amount);\r\n        if (msg.sender != _src && s.allowance[_src][msg.sender] != uint256(-1)) {\r\n            s.allowance[_src][msg.sender] = bsub(s.allowance[_src][msg.sender], _amount);\r\n            emit Approval(msg.sender, _dst, s.allowance[_src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/ReentryProtection.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n// TODO move this generic contract to a seperate repo with all generic smart contracts\r\n\r\ncontract ReentryProtection {\r\n\r\n    bytes32 constant public rpSlot = keccak256(\"ReentryProtection.storage.location\");\r\n\r\n    // reentry protection storage\r\n    struct rps {\r\n        uint256 lockCounter;\r\n    }\r\n\r\n    modifier noReentry {\r\n        // Use counter to only write to storage once\r\n        lrps().lockCounter ++;\r\n        uint256 lockValue = lrps().lockCounter;\r\n        _;\r\n        require(lockValue == lrps().lockCounter, \"ReentryProtection.noReentry: reentry detected\");\r\n    }\r\n\r\n    /**\r\n        @notice Load reentry protection storage\r\n        @return s Pointer to the reentry protection storage struct\r\n    */\r\n    function lrps() internal pure returns (rps storage s) {\r\n        bytes32 loc = rpSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/smart-pools/PBasicSmartPool.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract PBasicSmartPool is IPSmartPool, PCToken, ReentryProtection {\r\n    \r\n    // P Basic Smart Struct\r\n    bytes32 constant public pbsSlot = keccak256(\"PBasicSmartPool.storage.location\");\r\n    struct pbs {\r\n        IBPool bPool;\r\n        address controller;\r\n        address publicSwapSetter;\r\n        address tokenBinder;\r\n    }\r\n    \r\n    modifier ready() {\r\n        require(address(lpbs().bPool) != address(0), \"PBasicSmartPool.ready: not ready\");\r\n        _;\r\n    }   \r\n\r\n     event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256 tokenAmountIn\r\n    );\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event TokensApproved();\r\n    event ControllerChanged(address indexed previousController, address indexed newController);\r\n    event PublicSwapSetterChanged(address indexed previousSetter, address indexed newSetter);\r\n    event TokenBinderChanged(address indexed previousTokenBinder, address indexed newTokenBinder);\r\n    event PublicSwapSet(address indexed setter, bool indexed value);\r\n    event SwapFeeSet(address indexed setter, uint256 newFee);\r\n    event PoolJoined(address indexed from, uint256 amount);\r\n    event PoolExited(address indexed from, uint256 amount);\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == lpbs().controller, \"PBasicSmartPool.onlyController: not controller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPublicSwapSetter() {\r\n        require(msg.sender == lpbs().publicSwapSetter, \"PBasicSmartPool.onlyPublicSwapSetter: not public swap setter\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenBinder() {\r\n        require(msg.sender == lpbs().tokenBinder, \"PBasicSmartPool.onlyTokenBinder: not token binder\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @notice Initialises the contract\r\n        @param _bPool Address of the underlying balancer pool\r\n        @param _name Name for the smart pool token\r\n        @param _symbol Symbol for the smart pool token\r\n        @param _initialSupply Initial token supply to mint\r\n    */\r\n    function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\r\n        pbs storage s = lpbs();\r\n        require(address(s.bPool) == address(0), \"PBasicSmartPool.init: already initialised\");\r\n        s.bPool = IBPool(_bPool);\r\n        s.controller = msg.sender;\r\n        s.publicSwapSetter = msg.sender;\r\n        s.tokenBinder = msg.sender;\r\n        lpts().name = _name;\r\n        lpts().symbol = _symbol;\r\n        _mintPoolShare(_initialSupply);\r\n        _pushPoolShare(msg.sender, _initialSupply);\r\n    }\r\n\r\n    /**\r\n        @notice Sets approval to all tokens to the underlying balancer pool\r\n        @dev It uses this function to save on gas in joinPool\r\n    */\r\n    function approveTokens() public {\r\n        IBPool bPool = lpbs().bPool;\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            IERC20(tokens[i]).approve(address(bPool), uint256(-1));\r\n        }\r\n        emit TokensApproved();\r\n    }\r\n\r\n    /**\r\n        @notice Sets the controller address. Can only be set by the current controller\r\n        @param _controller Address of the new controller\r\n    */\r\n    function setController(address _controller) onlyController noReentry external {\r\n        emit ControllerChanged(lpbs().controller, _controller);\r\n        lpbs().controller = _controller;\r\n    }\r\n\r\n    /**\r\n        @notice Sets public swap setter address. Can only be set by the controller\r\n        @param _newPublicSwapSetter Address of the new public swap setter\r\n    */\r\n    function setPublicSwapSetter(address _newPublicSwapSetter) onlyController external {\r\n        emit PublicSwapSetterChanged(lpbs().publicSwapSetter, _newPublicSwapSetter);\r\n        lpbs().publicSwapSetter = _newPublicSwapSetter;\r\n    }\r\n\r\n    /**\r\n        @notice Sets the token binder address. Can only be set by the controller\r\n        @param _newTokenBinder Address of the new token binder\r\n    */\r\n    function setTokenBinder(address _newTokenBinder) onlyController external {\r\n        emit TokenBinderChanged(lpbs().tokenBinder, _newTokenBinder);\r\n        lpbs().tokenBinder = _newTokenBinder;\r\n    }\r\n\r\n    /**\r\n        @notice Enables or disables public swapping on the underlying balancer pool. Can only be set by the controller\r\n        @param _public Public or not\r\n    */\r\n    function setPublicSwap(bool _public) onlyPublicSwapSetter external {\r\n        emit PublicSwapSet(msg.sender, _public);\r\n        lpbs().bPool.setPublicSwap(_public);\r\n    }\r\n\r\n    /**\r\n        @notice Set the swap fee on the underlying balancer pool. Can only be called by the controller\r\n        @param _swapFee The new swap fee\r\n    */\r\n    function setSwapFee(uint256 _swapFee) onlyController external {\r\n        emit SwapFeeSet(msg.sender, _swapFee);\r\n        lpbs().bPool.setSwapFee(_swapFee);\r\n    }\r\n\r\n    /** \r\n        @notice Mints pool shares in exchange for underlying assets\r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n    function joinPool(uint256 _amount) external override virtual ready {\r\n        _joinPool(_amount);\r\n    }\r\n\r\n    /**\r\n        @notice Internal join pool function. See joinPool for more info\r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n    function _joinPool(uint256 _amount) internal virtual ready {\r\n        IBPool bPool = lpbs().bPool;\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = bdiv(_amount, poolTotal);\r\n        require(ratio != 0);\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            uint tokenAmountIn = bmul(ratio, bal);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn, bal);\r\n        }\r\n        _mintPoolShare(_amount);\r\n        _pushPoolShare(msg.sender, _amount);\r\n        emit PoolJoined(msg.sender, _amount);\r\n    }\r\n\r\n    /** \r\n        @notice Burns pool shares and sends back the underlying assets\r\n        @param _amount Amount of pool tokens to burn\r\n    */\r\n    function exitPool(uint256 _amount) external override ready noReentry {\r\n        IBPool bPool = lpbs().bPool;\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = bdiv(_amount, poolTotal);\r\n        require(ratio != 0);\r\n\r\n        _pullPoolShare(msg.sender, _amount);\r\n        _burnPoolShare(_amount);\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            uint tAo = bmul(ratio, bal);\r\n            emit LOG_EXIT(msg.sender, t, tAo);  \r\n            _pushUnderlying(t, msg.sender, tAo, bal);\r\n        }\r\n        emit PoolExited(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Bind a token to the underlying balancer pool. Can only be called by the token binder\r\n        @param _token Token to bind\r\n        @param _balance Amount to bind\r\n        @param _denorm Denormalised weight\r\n    */\r\n    function bind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        token.transferFrom(msg.sender, address(this), _balance);\r\n        token.approve(address(bPool), uint256(-1));\r\n        bPool.bind(_token, _balance, _denorm);\r\n    }\r\n\r\n    /**\r\n        @notice Rebind a token to the pool\r\n        @param _token Token to bind\r\n        @param _balance Amount to bind\r\n        @param _denorm Denormalised weight\r\n    */\r\n    function rebind(address _token, uint256 _balance, uint256 _denorm) external onlyTokenBinder {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        \r\n        // gulp old non acounted for token balance in the contract\r\n        bPool.gulp(_token);\r\n\r\n        uint256 oldBalance = token.balanceOf(address(bPool));\r\n        // If tokens need to be pulled from msg.sender\r\n        if(_balance > oldBalance) {\r\n            token.transferFrom(msg.sender, address(this), bsub(_balance, oldBalance));\r\n            token.approve(address(bPool), uint256(-1));\r\n        }\r\n\r\n        bPool.rebind(_token, _balance, _denorm);\r\n\r\n        // If any tokens are in this contract send them to msg.sender\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0) {\r\n            token.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Unbind a token\r\n        @param _token Token to unbind\r\n    */\r\n    function unbind(address _token) external onlyTokenBinder {\r\n        IBPool bPool = lpbs().bPool;\r\n        IERC20 token = IERC20(_token);\r\n        // unbind the token in the bPool\r\n        bPool.unbind(_token);\r\n\r\n        // If any tokens are in this contract send them to msg.sender\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        if(tokenBalance > 0) {\r\n            token.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n\r\n    function getTokens() external view override returns(address[] memory) {\r\n        return lpbs().bPool.getCurrentTokens();\r\n    }\r\n\r\n    /**\r\n        @notice Gets the underlying assets and amounts to mint specific pool shares.\r\n        @param _amount Amount of pool shares to calculate the values for\r\n        @return tokens The addresses of the tokens\r\n        @return amounts The amounts of tokens needed to mint that amount of pool shares\r\n    */\r\n    function calcTokensForAmount(uint256 _amount) external view override returns(address[] memory tokens, uint256[] memory amounts) {\r\n        tokens = lpbs().bPool.getCurrentTokens();\r\n        amounts = new uint256[](tokens.length);\r\n        uint256 ratio = bdiv(_amount, totalSupply());\r\n\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            address t = tokens[i];\r\n            uint256 bal = lpbs().bPool.getBalance(t);\r\n            uint256 amount = bmul(ratio, bal);\r\n            amounts[i] = amount;\r\n        }\r\n    }\r\n\r\n    /** \r\n        @notice Get the address of the controller\r\n        @return The address of the pool\r\n    */\r\n    function getController() external view override returns(address) {\r\n        return lpbs().controller;\r\n    }\r\n\r\n    /** \r\n        @notice Get the address of the public swap setter\r\n        @return The public swap setter address\r\n    */\r\n    function getPublicSwapSetter() external view returns(address) {\r\n        return lpbs().publicSwapSetter;\r\n    }\r\n\r\n    /**\r\n        @notice Get the address of the token binder\r\n        @return The token binder address\r\n    */\r\n    function getTokenBinder() external view returns(address) {\r\n        return lpbs().tokenBinder;\r\n    }\r\n\r\n    /**\r\n        @notice Get if public swapping is enabled\r\n        @return If public swapping is enabled\r\n    */\r\n    function isPublicSwap() external view returns (bool) {\r\n        return lpbs().bPool.isPublicSwap();\r\n    }\r\n\r\n    /**\r\n        @notice Get the current swap fee\r\n        @return The current swap fee\r\n    */\r\n    function getSwapFee() external view returns (uint256) {\r\n        return lpbs().bPool.getSwapFee();\r\n    }\r\n\r\n    /**\r\n        @notice Get the address of the underlying Balancer pool\r\n        @return The address of the underlying balancer pool\r\n    */\r\n    function getBPool() external view returns(address) {\r\n        return address(lpbs().bPool);\r\n    }\r\n\r\n    /**\r\n        @notice Pull the underlying token from an address and rebind it to the balancer pool\r\n        @param _token Address of the token to pull\r\n        @param _from Address to pull the token from\r\n        @param _amount Amount of token to pull\r\n        @param _tokenBalance Balance of the token already in the balancer pool\r\n    */\r\n    function _pullUnderlying(address _token, address _from, uint256 _amount, uint256 _tokenBalance)\r\n        internal\r\n    {   \r\n        IBPool bPool = lpbs().bPool;\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\r\n\r\n        bool xfer = IERC20(_token).transferFrom(_from, address(this), _amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n        bPool.rebind(_token, badd(_tokenBalance, _amount), tokenWeight);\r\n    }\r\n\r\n    /** \r\n        @notice Push a underlying token and rebind the token to the balancer pool\r\n        @param _token Address of the token to push\r\n        @param _to Address to pull the token to\r\n        @param _amount Amount of token to push\r\n        @param _tokenBalance Balance of the token already in the balancer pool\r\n    */\r\n    function _pushUnderlying(address _token, address _to, uint256 _amount, uint256 _tokenBalance)\r\n        internal\r\n    {   \r\n        IBPool bPool = lpbs().bPool;\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenWeight = bPool.getDenormalizedWeight(_token);\r\n        bPool.rebind(_token, bsub(_tokenBalance, _amount), tokenWeight);\r\n\r\n        bool xfer = IERC20(_token).transfer(_to, _amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    /**\r\n        @notice Pull pool shares\r\n        @param _from Address to pull pool shares from\r\n        @param _amount Amount of pool shares to pull\r\n    */\r\n    function _pullPoolShare(address _from, uint256 _amount)\r\n        internal\r\n    {\r\n        _pull(_from, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Burn pool shares\r\n        @param _amount Amount of pool shares to burn\r\n    */\r\n    function _burnPoolShare(uint256 _amount)\r\n        internal\r\n    {\r\n        _burn(_amount);\r\n    }\r\n\r\n    /** \r\n        @notice Mint pool shares \r\n        @param _amount Amount of pool shares to mint\r\n    */\r\n    function _mintPoolShare(uint256 _amount)\r\n        internal\r\n    {\r\n        _mint(_amount);\r\n    }\r\n\r\n    /**\r\n        @notice Push pool shares to account\r\n        @param _to Address to push the pool shares to\r\n        @param _amount Amount of pool shares to push\r\n    */\r\n    function _pushPoolShare(address _to, uint256 _amount)\r\n        internal\r\n    {\r\n        _push(_to, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Load PBasicPool storage\r\n        @return s Pointer to the storage struct\r\n    */\r\n    function lpbs() internal pure returns (pbs storage s) {\r\n        bytes32 loc = pbsSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/smart-pools/PCappedSmartPool.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ncontract PCappedSmartPool is PBasicSmartPool {\r\n\r\n    bytes32 constant public pcsSlot = keccak256(\"PCappedSmartPool.storage.location\");\r\n\r\n    event CapChanged(address indexed setter, uint256 oldCap, uint256 newCap);\r\n\r\n    struct pcs {\r\n        uint256 cap;\r\n    }\r\n\r\n    modifier withinCap() {\r\n        _;\r\n        require(totalSupply() < lpcs().cap, \"PCappedSmartPool.withinCap: Cap limit reached\");\r\n    }\r\n\r\n    /**\r\n        @notice Set the maximum cap of the contract\r\n        @param _cap New cap in wei\r\n    */\r\n    function setCap(uint256 _cap) onlyController external {\r\n        emit CapChanged(msg.sender, lpcs().cap, _cap);\r\n        lpcs().cap = _cap;\r\n    }\r\n\r\n    /**\r\n        @notice Takes underlying assets and mints smart pool tokens. Enforces the cap\r\n        @param _amount Amount of pool tokens to mint\r\n    */\r\n    function joinPool(uint256 _amount) external override withinCap {\r\n        super._joinPool(_amount);\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Get the current cap\r\n        @return The current cap in wei\r\n    */\r\n    function getCap() external view returns(uint256) {\r\n        return lpcs().cap;\r\n    }\r\n\r\n    /**\r\n        @notice Load the PCappedSmartPool storage\r\n        @return s Pointer to the storage struct\r\n    */\r\n    function lpcs() internal pure returns (pcs storage s) {\r\n        bytes32 loc = pcsSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/factory/PProxiedFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PProxiedFactory is Ownable {\r\n\r\n    IBFactory public balancerFactory;\r\n    address public smartPoolImplementation;\r\n    mapping(address => bool) public isPool;\r\n    address[] public pools;\r\n\r\n    event SmartPoolCreated(address indexed poolAddress, string name, string symbol);\r\n\r\n    function init(address _balancerFactory) public {\r\n        require(smartPoolImplementation == address(0), \"Already initialised\");\r\n        _setOwner(msg.sender);\r\n        balancerFactory = IBFactory(_balancerFactory);\r\n        \r\n        PCappedSmartPool implementation = new PCappedSmartPool();\r\n        // function init(address _bPool, string calldata _name, string calldata _symbol, uint256 _initialSupply) external {\r\n        implementation.init(address(0), \"IMPL\", \"IMPL\", 1 ether);\r\n        smartPoolImplementation = address(implementation);\r\n    }\r\n\r\n    function newProxiedSmartPool(\r\n        string memory _name, \r\n        string memory _symbol,\r\n        uint256 _initialSupply,\r\n        address[] memory _tokens,\r\n        uint256[] memory _amounts,\r\n        uint256[] memory _weights,\r\n        uint256 _cap\r\n    ) public onlyOwner returns(address) {\r\n        // Deploy proxy contract\r\n        PProxyPausable proxy = new PProxyPausable();\r\n        \r\n        // Setup proxy\r\n        proxy.setImplementation(smartPoolImplementation);\r\n        proxy.setPauzer(msg.sender);\r\n        proxy.setProxyOwner(msg.sender); \r\n        \r\n        // Setup balancer pool\r\n        address balancerPoolAddress = balancerFactory.newBPool();\r\n        IBPool bPool = IBPool(balancerPoolAddress);\r\n\r\n        for(uint256 i = 0; i < _tokens.length; i ++) {\r\n            IERC20 token = IERC20(_tokens[i]);\r\n            // Transfer tokens to this contract\r\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\r\n            // Approve the balancer pool\r\n            token.approve(balancerPoolAddress, uint256(-1));\r\n            // Bind tokens\r\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\r\n        }\r\n        bPool.setController(address(proxy));\r\n        \r\n        // Setup smart pool\r\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\r\n    \r\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\r\n        smartPool.setCap(_cap);\r\n        smartPool.setPublicSwapSetter(msg.sender);\r\n        smartPool.setTokenBinder(msg.sender);\r\n        smartPool.setController(msg.sender);\r\n        smartPool.approveTokens();\r\n        \r\n        isPool[address(smartPool)] = true;\r\n        pools.push(address(smartPool));\r\n\r\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\r\n\r\n        smartPool.transfer(msg.sender, _initialSupply);\r\n\r\n        return address(smartPool);\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapFactory.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IUniswapFactory {\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapExchange.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    // bytes32 public name;\r\n    // bytes32 public symbol;\r\n    // uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n\r\n// File contracts/recipes/PUniswapPoolRecipe.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n\r\n\r\n// Takes ETH and mints smart pool tokens\r\ncontract PUniswapPoolRecipe {\r\n    \r\n    bytes32 constant public uprSlot = keccak256(\"PUniswapPoolRecipe.storage.location\");\r\n\r\n    // Uniswap pool recipe struct\r\n    struct uprs {\r\n        IPSmartPool pool;\r\n        IUniswapFactory uniswapFactory;\r\n    }\r\n\r\n    function init(address _pool, address _uniswapFactory) public virtual {\r\n        uprs storage s = luprs();\r\n        require(address(s.pool) == address(0), \"already initialised\");\r\n        s.pool = IPSmartPool(_pool);\r\n        s.uniswapFactory = IUniswapFactory(_uniswapFactory);\r\n    }\r\n\r\n    // Using same interface as Uniswap for compatibility\r\n    function ethToTokenTransferOutput(uint256 _tokens_bought, uint256 _deadline, address _recipient) public payable returns (uint256  eth_sold) {\r\n        uprs storage s = luprs();\r\n        require(_deadline >= block.timestamp);\r\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_bought);\r\n\r\n        eth_sold = 0;\r\n        // Buy and approve tokens\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            eth_sold += _ethToToken(tokens[i], amounts[i]);\r\n            IERC20(tokens[i]).approve(address(s.pool), uint256(-1));\r\n        }\r\n\r\n        // Calculate amount of eth sold\r\n        eth_sold = msg.value - address(this).balance;\r\n        // Send back excess eth\r\n        msg.sender.transfer(address(this).balance);\r\n\r\n        // Join pool\r\n        s.pool.joinPool(_tokens_bought);\r\n\r\n        // Send pool tokens to receiver\r\n        s.pool.transfer(_recipient, s.pool.balanceOf(address(this)));\r\n        return eth_sold;\r\n    }\r\n\r\n    function ethToTokenSwapOutput(uint256 _tokens_bought, uint256 _deadline) external payable returns (uint256 eth_sold) {\r\n        return ethToTokenTransferOutput(_tokens_bought, _deadline, msg.sender);\r\n    }\r\n\r\n    function _ethToToken(address _token, uint256 _tokens_bought) internal virtual returns (uint256) {\r\n        uprs storage s = luprs();\r\n        IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(_token));\r\n        return exchange.ethToTokenSwapOutput{value: address(this).balance}(_tokens_bought, uint256(-1));\r\n    }\r\n\r\n    function getEthToTokenOutputPrice(uint256 _tokens_bought) external view virtual returns (uint256 eth_sold) {\r\n        uprs storage s = luprs();\r\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_bought);\r\n\r\n        eth_sold = 0;\r\n\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(tokens[i]));\r\n            eth_sold += exchange.getEthToTokenOutputPrice(amounts[i]);\r\n        }\r\n\r\n        return eth_sold;\r\n    }\r\n\r\n    function tokenToEthTransferInput(uint256 _tokens_sold, uint256 _min_eth, uint256 _deadline, address _recipient) public returns (uint256 eth_bought) {\r\n        uprs storage s = luprs();\r\n        require(_deadline >= block.timestamp);\r\n        require(s.pool.transferFrom(msg.sender, address(this), _tokens_sold), \"PUniswapPoolRecipe.tokenToEthTransferInput: transferFrom failed\");\r\n\r\n        s.pool.exitPool(_tokens_sold);\r\n\r\n        address[] memory tokens = s.pool.getTokens();\r\n\r\n        uint256 ethAmount = 0;\r\n\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            IERC20 token = IERC20(tokens[i]);\r\n            \r\n            uint256 balance = token.balanceOf(address(this));\r\n           \r\n            // Exchange for ETH\r\n            ethAmount += _tokenToEth(token, balance, _recipient);\r\n        }\r\n\r\n        require(ethAmount > _min_eth, \"PUniswapPoolRecipe.tokenToEthTransferInput: not enough ETH\");\r\n        return ethAmount;\r\n    }\r\n\r\n    function tokenToEthSwapInput(uint256 _tokens_sold, uint256 _min_eth, uint256 _deadline) external returns (uint256 eth_bought) {\r\n        return tokenToEthTransferInput(_tokens_sold, _min_eth, _deadline, msg.sender);\r\n    }\r\n\r\n    function _tokenToEth(IERC20 _token, uint256 _tokens_sold, address _recipient) internal virtual returns (uint256 eth_bought) {\r\n        uprs storage s = luprs();\r\n        IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(address(_token)));\r\n        _token.approve(address(exchange), _tokens_sold);\r\n        // Exchange for ETH\r\n        return exchange.tokenToEthTransferInput(_tokens_sold, 1, uint256(-1), _recipient);\r\n    }\r\n\r\n    function getTokenToEthInputPrice(uint256 _tokens_sold) external view virtual returns (uint256 eth_bought) {\r\n        uprs storage s = luprs();\r\n        (address[] memory tokens, uint256[] memory amounts) = s.pool.calcTokensForAmount(_tokens_sold);\r\n\r\n        eth_bought = 0;\r\n\r\n        for(uint256 i = 0; i < tokens.length; i ++) {\r\n            IUniswapExchange exchange = IUniswapExchange(s.uniswapFactory.getExchange(address(tokens[i])));\r\n            eth_bought += exchange.getTokenToEthInputPrice(amounts[i]);\r\n        }\r\n\r\n        return eth_bought;\r\n    }\r\n\r\n    function pool() external view returns (address) {\r\n        return address(luprs().pool);\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    // Load uniswap pool recipe\r\n    function luprs() internal pure returns (uprs storage s) {\r\n        bytes32 loc = uprSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IKyberNetwork.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\ninterface IKyberNetwork {\r\n\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address payable destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    ) external payable returns(uint256);\r\n}\r\n\r\n\r\n// File contracts/recipes/PUniswapKyberPoolRecipe.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\n\r\n\r\ncontract PUniswapKyberPoolRecipe is PUniswapPoolRecipe, Ownable {\r\n\r\n    bytes32 constant public ukprSlot = keccak256(\"PUniswapKyberPoolRecipe.storage.location\");\r\n\r\n    // Uniswap pool recipe struct\r\n    struct ukprs {\r\n        mapping(address => bool) swapOnKyber;\r\n        IKyberNetwork kyber;\r\n        address feeReceiver;\r\n    }\r\n\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    \r\n    function init(address, address) public override {\r\n        require(false, \"not enabled\");\r\n    }\r\n\r\n    // Use seperate init function\r\n    function initUK(address _pool, address _uniswapFactory, address _kyber, address[] memory _swapOnKyber, address _feeReciever) public {\r\n        // UnsiwapRecipe enforces that init can only be called once\r\n        ukprs storage s = lukprs();\r\n\r\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\r\n        s.kyber = IKyberNetwork(_kyber);\r\n        s.feeReceiver = _feeReciever;\r\n\r\n        _setOwner(msg.sender);\r\n\r\n        for(uint256 i = 0; i < _swapOnKyber.length; i ++) {\r\n            s.swapOnKyber[_swapOnKyber[i]] = true;\r\n        }\r\n    }\r\n\r\n    function setKyberSwap(address _token, bool _value) external onlyOwner {\r\n        ukprs storage s = lukprs();\r\n        s.swapOnKyber[_token] = _value;\r\n    }\r\n\r\n    function _ethToToken(address _token, uint256 _tokens_bought) internal override returns (uint256) {\r\n        ukprs storage s = lukprs();\r\n        if(!s.swapOnKyber[_token]) {\r\n            return super._ethToToken(_token, _tokens_bought);\r\n        }\r\n\r\n        uint256 ethBefore = address(this).balance;\r\n        s.kyber.trade{value: address(this).balance}(ETH, address(this).balance, _token, address(this), _tokens_bought, 1, s.feeReceiver);\r\n        uint256 ethAfter = address(this).balance;\r\n\r\n        // return amount of ETH spend\r\n        return ethBefore - ethAfter;\r\n    }\r\n\r\n    function _tokenToEth(IERC20 _token, uint256 _tokens_sold, address _recipient) internal override returns (uint256 eth_bought) {\r\n        ukprs storage s = lukprs();\r\n        if(!s.swapOnKyber[address(_token)]) {\r\n            return super._tokenToEth(_token, _tokens_sold, _recipient);\r\n        }\r\n\r\n        uint256 ethBefore = address(this).balance;\r\n        _token.approve(address(s.kyber), uint256(-1));\r\n        s.kyber.trade(address(_token), _tokens_sold, ETH, address(this), uint256(-1), 1, s.feeReceiver);\r\n        uint256 ethAfter = address(this).balance;\r\n\r\n        // return amount of ETH received\r\n        return ethAfter - ethBefore;\r\n    }\r\n\r\n    // Load uniswap pool recipe\r\n    function lukprs() internal pure returns (ukprs storage s) {\r\n        bytes32 loc = ukprSlot;\r\n        assembly {\r\n            s_slot := loc\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/test/TestReentryProtection.sol\r\n\r\npragma solidity ^0.6.4;\r\n\r\n\r\ncontract TestReentryProtection is ReentryProtection {\r\n\r\n    // This should fail\r\n    function test() external noReentry {\r\n        reenter();\r\n    }\r\n\r\n    function reenter() public noReentry {\r\n        // Do nothing\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"addressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauzer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"readAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"readBool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"readString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauzer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPauzer\",\"type\":\"address\"}],\"name\":\"setPauzer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setProxyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"storageRead\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PProxyPausable", "CompilerVersion": "v0.6.4+commit.1dca32f3", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "1", "Implementation": "0x1f863776975a69b6078fdafab6298d3e823e0190", "SwarmSource": "ipfs://402a3349b51886149d11d3fe7ed7ff4d98a6c6375ecb098e332019cc656fb6d8"}