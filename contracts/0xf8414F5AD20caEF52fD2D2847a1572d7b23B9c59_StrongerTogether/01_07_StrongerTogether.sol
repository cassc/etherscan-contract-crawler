//                    ╓╖╗╗WM╦╦╖,
//               ╓#▓╬╬╣╝╝╨╨╜╩╠╠╠╠╣▒▄,       
//            ,#╣╬╣╜└          └╙╚▒╣╬▓▄      
//           #╬╬╣└    ,▄▒▓╣▓╬╬▓▓▄Q ╙╬╣▓▓▄
//          ╣╬╬╬    ╓▓╬╣╬╢╣╬╬╬╣╙╙╬▓▄,╙╬▓█▓m
//         ╣╬╣╬░   å╬╬╬╩╙`  `└╩╠▒╖╙╣▓▄└▓╬█▓▌    ᴀʀᴛɪsᴛ ᴄᴇᴄɪʟɪᴇ ᴡᴀᴀɢɴᴇʀ ғᴀʟᴋᴇɴsᴛʀᴏᴍ,
//        ╔╬╬╬╬⌐  ]╬▒╩          ╙╟▓ç╟▓▓▄█╬█▓▌   ᴜɴғᴘᴀ, ᴀɴᴅ ᴄʀʏᴘᴛᴏ ғᴏʀ ᴄʜᴀʀɪᴛʏ ᴘʀᴇsᴇɴᴛ:
//        ╠╠╠╬╬▒  ╘╬▒             ║▓▒╟▓███╣██▌
//        ▐╚╬╟╬╬Q  ╚╬▒             ╟╬▓▓████▓██▄
//         ║╠╬╬╬╣▒  └╝▒╓            ╣╣╬╣███▓███
//          ╟╬╣╬╬╬╣▒, '╙▒≥.         └╬▓▓████▓██▌
//           ╠╢╣╬╚╬╬╬▓▄,  ╙╚▒≥╓      ╬╫▓▓███▓██▓
//            "╠╠▒,╙╬╬╬╬▓▒▄,  ╙╙╚▒φ=,▐╟▓▓██████▓b
//              `╩╠▒╖└╙╬╬╬╬╬╬▓▒╗╖, └╙╙▀╣╣╣╬╬╬▀▓▓▌
//                 "╩╩▒╗╓└╙╝╬╬╬╬╬╬╣▓▓▓▓▄▄▄▓▓╣╬╬╠╠╠▒φ╦╓
//                    `╙╠╩╬Q╥╓╙╙╚╬╬╣▓▓███▓▓▓╬╬╬╬╬╬╬╠▒▒▒╠╠▒╦,
//                         "╚╠╩╬▒#╗▄▄╠╙▀╩╣╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒╠╠╬#╓
//                               "╙╩╬╬╬╬▓▓▒╗╗▄▒╙╙╩╠╬╬╬╬╬╬╣╬╢╬▒▒╠╬▒╦
//                                    ╠╢▓▄│╚▄▒╠╠╠╠▒╗▄░╙╚╠╬╬╬╬╬╬╬╠╠╬╬▒≡
//                                    ▐╠█╣█▓▓▓▓▓▓Γ"²╩╚╬▒╗╖╙╙╠╠╬╬╬╬╬╬╬╬╣╦
//  ╔═╗┌┬┐┬─┐┌─┐┌┐┌┌─┐┌─┐┬─┐          └╠▓╬███▓▓╣▓▒     `╙╩╠╠╗ç╙╠╢╬╬╬╬╬╬╬╣╓
//  ╚═╗ │ ├┬┘│ │││││ ┬├┤ ├┬┘           ▒╠▓▓▓██╬╬█╬         `╚╚╠╦ ╚╬╬╬╬╬╬╬╬╦
//  ╚═╝ ┴ ┴└─└─┘┘└┘└─┘└─┘┴└─           ╠╬▓╬╬▓╫▒╬╣▓µ           "╠╠╦ ╠╬╬╬╬╬╬╬╦
//  ╔╦╗┌─┐┌─┐┌─┐┌┬┐┬ ┬┌─┐┬─┐            ╢╬╬╬╬▌▓╬╬╣╬             ╘╠▒ ╠╬╬╬╬╬╬╬
//   ║ │ ││ ┬├┤  │ ├─┤├┤ ├┬┘            ╠╬▓╬╬╬╣╬╟╬╣▒             ╚╠▓j╠╬╬╬╬╣╬▒
//   ╩ └─┘└─┘└─┘ ┴ ┴ ┴└─┘┴└─             ╟╢╬╬╬╣╬╬╠╬╣╦            ╒╠╣▒╠╬╬╬╬╬╬╡             
//                                       └╫╣╬╬╬╣╬╬╬╟╣▒           ╬╠╬╠╬╬╬╣╬╬▒∩
//                                        `╬╣╬╬╬╬╬╬╬╠╬╣╦,     ,#╬╣╠╬╬╬╬╬╬╬╬╠
//                                         `╚╬╬╝╬╬╣╬╬╣╣╬╢╬╣▒╬╬╬╬╬╬╬╬╬╬╬▓▓▓▒
//                                           ╚╠╬╕╙╬╬╬╬╣╣▌╗φ╣╬╬╬╬╬╬╬╬╬╬╣╣╬╩
//                                             ╚╠▒╖└╙╬╬╬╬╬╬╣╬╬╬╬╬╣╬╬╬╬╬╬
//                                               └╠╩▒╗╓,└╙╙╙╙╠╠╠╬╣╬╬╬╙
//                                                  `╙╩╠╠╠╠╠╬╠╟╬╩╜`
//
//                           SPDX-License-Identifier: MIT
//                          Written by Buzzy @ 0xBuzzy.eth
//
pragma solidity ^0.8.7;

import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

error SaleInactive();
error SoldOut();
error InvalidPrice();
error InvalidQuantity();
error WithdrawFailed();

contract StrongerTogether is ERC721A, Ownable {
    // the base price, but can add an optional
    // donation on top.
    uint256 public minPrice = 0.02 ether;

    // tokenIds will range from 1-800
    uint256 public constant SUPPLY = 800;

    // max 5 per address
    uint8 public constant maxQuantity = 5;

    // max 7 transfers that we keep track of
    uint8 public constant maxTransfers = 7;

    // 30 minutes past noon GMT on launch day (nov 17th)
    // can update if launch needs to be pushed forward/back
    uint public startTime = 1668688200;

    string public _baseTokenURI;

    bool public saleActive = false;

    // the deployer address, will use to distribute funds appropriately
    address private cfc = 0x42b4A5ED7B1A6286754bc575907Fa7AC9303eF96;

    mapping(address => uint8) public minted;

    // a mapping for the number of transfers up to maxTransfers
    mapping(uint256 => uint256) public transfers;

    constructor(string memory baseURI) ERC721A("StrongerTogether", "8BIL") {
        _baseTokenURI = baseURI;
    }

    function mint(uint8 qty)
        external
        payable
    {
        if (!saleActive) revert SaleInactive();
        if (block.timestamp < startTime) revert SaleInactive();
        if (totalSupply() + qty > SUPPLY) revert SoldOut();

        // "pay what you want" with minimum price
        if (msg.value < minPrice) revert InvalidPrice();
        if (qty + minted[msg.sender] > maxQuantity) revert InvalidQuantity();

        _mint(msg.sender, qty);

        minted[msg.sender] += qty;
    }

    function airdrop(address receiver, uint256 qty) external onlyOwner {
        if (totalSupply() + qty > SUPPLY) revert InvalidQuantity();

        _mint(receiver, qty);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override payable {
        // the token URI changes on each transfer, up to maxTransfers times.
        // so we keep track of the transfer count up to this point. This doesn't
        // materially affect the transfer mechanic itself.
        if (transfers[tokenId] < maxTransfers) {
            transfers[tokenId]++;
        }

        super.safeTransferFrom(from, to, tokenId);
    }

    function setSaleState(bool active) external onlyOwner {
        saleActive = active;
    }

    function setStartTime(uint startAt) external onlyOwner {
        startTime = startAt;
    }

    function startSale() external onlyOwner {
        saleActive = true;
        startTime = block.timestamp;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        // tokens are 0 padded, so we have to adjust the URI accordingly.
        if (tokenId < 10) {
            return bytes(_baseTokenURI).length > 0 ? string(abi.encodePacked(_baseTokenURI, "00", Strings.toString(tokenId), "/", Strings.toString(transfers[tokenId]), ".json")) : "";
        }
        if (tokenId < 100) {
            return bytes(_baseTokenURI).length > 0 ? string(abi.encodePacked(_baseTokenURI, "0", Strings.toString(tokenId), "/", Strings.toString(transfers[tokenId]), ".json")) : "";
        }
        return bytes(_baseTokenURI).length > 0 ? string(abi.encodePacked(_baseTokenURI, Strings.toString(tokenId), "/", Strings.toString(transfers[tokenId]), ".json")) : "";
    }

    function withdraw() external onlyOwner {
        (bool s, ) = cfc.call{value: (address(this).balance)}("");

        if (!s) revert WithdrawFailed();
    }
}