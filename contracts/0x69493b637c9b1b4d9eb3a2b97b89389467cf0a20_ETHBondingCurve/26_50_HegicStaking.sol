pragma solidity 0.8.6;

/**
 * SPDX-License-Identifier: GPL-3.0-or-later
 * Hegic
 * Copyright (C) 2021 Hegic Protocol
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../Interfaces/Interfaces.sol";

/**
 * @author 0mllwntrmt3
 * @title Hegic Protocol V8888 Staking Contract
 * @notice The contract that stakes the HEGIC tokens through
 * buying the microlots (any amount of HEGIC tokens per microlot)
 * and the staking lots (888,000 HEGIC per lot), accumulates the staking
 * rewards (settlement fees) and distributes the staking rewards among
 * the microlots and staking lots holders (should be claimed manually).
 **/

contract HegicStaking is ERC20, IHegicStaking {
    using SafeERC20 for IERC20;

    IERC20 public immutable HEGIC;
    IERC20 public immutable token;

    uint256 public constant STAKING_LOT_PRICE = 888_000e18;
    uint256 internal constant ACCURACY = 1e30;
    uint256 internal realisedBalance;

    uint256 public microLotsTotal = 0;
    mapping(address => uint256) public microBalance;

    uint256 public totalProfit = 0;
    mapping(address => uint256) internal lastProfit;

    uint256 public microLotsProfits = 0;
    mapping(address => uint256) internal lastMicroLotProfits;

    mapping(address => uint256) internal savedProfit;

    uint256 public classicLockupPeriod = 1 days;
    uint256 public microLockupPeriod = 1 days;

    mapping(address => uint256) public lastBoughtTimestamp;
    mapping(address => uint256) public lastMicroBoughtTimestamp;
    mapping(address => bool) public _revertTransfersInLockUpPeriod;

    constructor(
        ERC20 _hegic,
        ERC20 _token,
        string memory name,
        string memory short
    ) ERC20(name, short) {
        HEGIC = _hegic;
        token = _token;
    }

    function decimals() public pure override returns (uint8) {
        return 0;
    }

    /**
     * @notice Used by the HEGIC microlots holders
     * or staking lots holders for claiming
     * the accumulated staking rewards.
     **/
    function claimProfits(address account)
        external
        override
        returns (uint256 profit)
    {
        saveProfits(account);
        profit = savedProfit[account];
        require(profit > 0, "Zero profit");
        savedProfit[account] = 0;
        realisedBalance -= profit;
        token.safeTransfer(account, profit);
        emit Claim(account, profit);
    }

    /**
     * @notice Used for staking any amount of the HEGIC tokens
     * higher than zero in the form of buying the microlot
     * for receiving a pro rata share of 20% of the total staking
     * rewards (settlement fees) generated by the protocol.
     **/
    function buyMicroLot(uint256 amount) external {
        require(amount > 0, "Amount is zero");
        saveProfits(msg.sender);
        lastMicroBoughtTimestamp[msg.sender] = block.timestamp;
        microLotsTotal += amount;
        microBalance[msg.sender] += amount;
        HEGIC.safeTransferFrom(msg.sender, address(this), amount);
        emit MicroLotsAcquired(msg.sender, amount);
    }

    /**
     * @notice Used for unstaking the HEGIC tokens
     * in the form of selling the microlot.
     **/
    function sellMicroLot(uint256 amount) external {
        require(amount > 0, "Amount is zero");
        require(
            lastMicroBoughtTimestamp[msg.sender] + microLockupPeriod <
                block.timestamp,
            "The action is suspended due to the lockup"
        );
        saveProfits(msg.sender);
        microLotsTotal -= amount;
        microBalance[msg.sender] -= amount;
        HEGIC.safeTransfer(msg.sender, amount);
        emit MicroLotsSold(msg.sender, amount);
    }

    /**
     * @notice Used for staking the fixed amount of 888,000 HEGIC
     * tokens in the form of buying the staking lot (transferrable)
     * for receiving a pro rata share of 80% of the total staking
     * rewards (settlement fees) generated by the protocol.
     **/
    function buyStakingLot(uint256 amount) external override {
        lastBoughtTimestamp[msg.sender] = block.timestamp;
        require(amount > 0, "Amount is zero");
        _mint(msg.sender, amount);
        HEGIC.safeTransferFrom(
            msg.sender,
            address(this),
            amount * STAKING_LOT_PRICE
        );
    }

    /**
     * @notice Used for unstaking 888,000 HEGIC
     * tokens in the form of selling the staking lot.
     **/
    function sellStakingLot(uint256 amount) external override lockupFree {
        _burn(msg.sender, amount);
        HEGIC.safeTransfer(msg.sender, amount * STAKING_LOT_PRICE);
    }

    function revertTransfersInLockUpPeriod(bool value) external {
        _revertTransfersInLockUpPeriod[msg.sender] = value;
    }

    /**
     * @notice Returns the amount of unclaimed staking rewards.
     **/
    function profitOf(address account)
        external
        view
        override
        returns (uint256)
    {
        (uint256 profit, uint256 micro) = getUnsavedProfits(account);
        return savedProfit[account] + profit + micro;
    }

    /**
     * @notice Used for calculating the amount of accumulated
     * staking rewards before the share of the staking participant
     * changes higher (buying more microlots or staking lots)
     * or lower (selling more microlots or staking lots).
     **/
    function getUnsavedProfits(address account)
        internal
        view
        returns (uint256 total, uint256 micro)
    {
        total =
            ((totalProfit - lastProfit[account]) * balanceOf(account)) /
            ACCURACY;
        micro =
            ((microLotsProfits - lastMicroLotProfits[account]) *
                microBalance[account]) /
            ACCURACY;
    }

    /**
     * @notice Used for saving the amount of accumulated
     * staking rewards before the staking participant's share
     * changes higher (buying more microlots or staking lots)
     * or lower (selling more microlots or staking lots).
     **/
    function saveProfits(address account) internal {
        (uint256 unsaved, uint256 micro) = getUnsavedProfits(account);
        lastProfit[account] = totalProfit;
        lastMicroLotProfits[account] = microLotsProfits;
        savedProfit[account] += unsaved;
        savedProfit[account] += micro;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256
    ) internal override {
        if (from != address(0)) saveProfits(from);
        if (to != address(0)) saveProfits(to);
        if (
            lastBoughtTimestamp[from] + classicLockupPeriod > block.timestamp &&
            lastBoughtTimestamp[from] > lastBoughtTimestamp[to]
        ) {
            require(
                !_revertTransfersInLockUpPeriod[to],
                "The recipient does not agree to accept the locked funds"
            );
            lastBoughtTimestamp[to] = lastBoughtTimestamp[from];
        }
    }

    /**
     * @notice Used for distributing the staking rewards
     * among the microlots and staking lots holders.
     **/
    function distributeUnrealizedRewards() external override {
        uint256 amount = token.balanceOf(address(this)) - realisedBalance;
        realisedBalance += amount;
        uint256 _totalSupply = totalSupply();
        if (microLotsTotal + _totalSupply > 0) {
            if (microLotsTotal == 0) {
                totalProfit += (amount * ACCURACY) / _totalSupply;
            } else if (_totalSupply == 0) {
                microLotsProfits += (amount * ACCURACY) / microLotsTotal;
            } else {
                uint256 microAmount = amount / 5;
                uint256 baseAmount = amount - microAmount;
                microLotsProfits += (microAmount * ACCURACY) / microLotsTotal;
                totalProfit += (baseAmount * ACCURACY) / _totalSupply;
            }
            emit Profit(amount);
        }
    }

    modifier lockupFree {
        require(
            lastBoughtTimestamp[msg.sender] + classicLockupPeriod <=
                block.timestamp,
            "The action is suspended due to the lockup"
        );
        _;
    }
}