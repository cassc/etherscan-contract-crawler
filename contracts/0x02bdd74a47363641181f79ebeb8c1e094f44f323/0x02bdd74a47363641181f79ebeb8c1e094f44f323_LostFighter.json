{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LostFighters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// \u00a92022 Ponderware Ltd\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\ninterface IReverseResolver {\\n    function claim(address owner) external returns (bytes32);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface IMoonCatSVGS {\\n    function uint2str (uint value) external pure returns (string memory);\\n}\\n\\ninterface IMetadata {\\n    function legionMetadata (uint256 tokenId) external view returns (string memory);\\n}\\n\\n/*\\n * @title STARKADE Lost Fighters\\n * @author Ponderware Ltd\\n * @dev ERC-721 contract for Starkade Lost Fighters NFT\\n * @notice license: https://starkade.com/licences/nft/starkade-legion/\\n */\\ncontract LostFighter is IERC721Enumerable, IERC721Metadata {\\n\\n    string public IPFS_URI_Prefix = \\\"https://starkade-legion.mypinata.cloud/ipfs/\\\";\\n    string public IPFS_Pass_Folder = \\\"\\\";\\n    string public IPFS_Core_Folder = \\\"\\\";\\n    string public IPFS_Legion_Folder = \\\"\\\";\\n\\n    address public MetadataContractAddress;\\n\\n    address public contractOwner;\\n    address internal flightlistSigner;\\n\\n    bool public paused = true;\\n\\n    string public name = \\\"STARKADE\\\";\\n    string public symbol = unicode\\\"\ud83d\udcab\\\";\\n\\n    address[7015] private Owners;\\n    mapping (address => uint256[]) internal TokensByOwner;\\n    uint16[7015] internal OwnerTokenIndex;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private TokenApprovals;\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private OperatorApprovals;\\n\\n    uint256 internal constant maxSupply = 7015;\\n    uint256 public totalSupply = 0;\\n\\n    enum State\\n    {\\n     Ready,\\n     SaleOpen,\\n     RevealPrepped,\\n     Revealed\\n    }\\n\\n    State public contractState = State.Ready;\\n\\n    uint256 public saleOpenBlock;\\n\\n    bytes32 public revealHash;\\n    uint256 public revealBlock;\\n    bytes32 public revealSeed;\\n\\n    uint256 public coreRaffleIncrement;\\n    uint256[8] internal Primes = [81918643972203779099,\\n                                  72729269248899238429,\\n                                  19314683338901247061,\\n                                  38707402401747623009,\\n                                  54451314435228525599,\\n                                  16972551169207064863,\\n                                  44527956848616763003,\\n                                  51240633499522341181];\\n\\n    uint256 coreRaffleOffset;\\n\\n    /**\\n     * @dev Begin the reveal process by submitting the ipfs asset CIDs and a commitment hash of a secret \\\"seed\\\" value\\n     */\\n    function setSeedHash (bytes32 hash, string calldata ipfsCore, string calldata ipfsLegion) public onlyOwner {\\n        require(contractState == State.SaleOpen ||\\n                contractState == State.RevealPrepped,\\n                \\\"Invalid State\\\");\\n        require(block.number > revealBlock + 200);\\n        contractState = State.RevealPrepped;\\n        revealHash = hash;\\n        revealBlock = block.number;\\n        IPFS_Core_Folder = ipfsCore;\\n        IPFS_Legion_Folder = ipfsLegion;\\n    }\\n\\n    /**\\n     * @dev Reveal all Lost Fighters NFTs and determine core indexes by combining the value of the seed with blockhashes\\n     */\\n    function reveal (uint256 seed) public onlyOwner {\\n        require(block.number > revealBlock + 4\\n                && block.number < revealBlock + 200,\\n                \\\"Block Range\\\");\\n        require(contractState == State.RevealPrepped, \\\"Already Revealed\\\");\\n        require(keccak256(abi.encodePacked(seed)) == revealHash, \\\"Seed Mismatch\\\");\\n        revealSeed = keccak256(abi.encodePacked(seed,\\n                                                blockhash(revealBlock + 1),\\n                                                blockhash(revealBlock + 2),\\n                                                blockhash(revealBlock + 3)));\\n        coreRaffleOffset = uint256(revealSeed) % (totalSupply - 5);\\n        coreRaffleIncrement = Primes[uint256(revealSeed) % 8];\\n        contractState = State.Revealed;\\n    }\\n\\n    /**\\n     * @dev Return the coreIndex of a token (only valid if returned value is < 15)\\n     */\\n    function coreIndex (uint256 tokenId) internal view returns (uint256) {\\n        if (tokenId < 5) {\\n            return tokenId;\\n        } else {\\n            return ((coreRaffleIncrement * (tokenId - 5) + coreRaffleOffset) % (totalSupply - 5)) + 5;\\n        }\\n    }\\n\\n    /**\\n     * @dev Return whether a given tokenId represents a core character and, if so, the associated coreIndex\\n     */\\n    function isCore (uint256 tokenId) public view returns (bool, uint256) {\\n        uint256 coreIdx = coreIndex(tokenId);\\n        if (coreIdx < 15) {\\n            return (true, coreIdx);\\n        } else {\\n            return (false, 0);\\n        }\\n    }\\n\\n    /* Minting/Passes */\\n\\n    uint256 constant FLIGHTLIST_ISSUANCE_DELAY = 830; // Approximately 3 hours time\\n\\n    uint256 public price = 0.08 ether;\\n\\n    uint256 giftCutoff = 0;\\n    uint256 flightlistCutoff = 8000;\\n\\n    /**\\n     * @dev Set mint price\\n     */\\n    function setPrice (uint256 priceWei) public onlyOwner {\\n        price = priceWei;\\n    }\\n\\n    /**\\n     * @dev Begin token sale\\n     */\\n    function openSale () public onlyOwner {\\n        require(contractState == State.Ready, \\\"Not Ready\\\");\\n        contractState = State.SaleOpen;\\n        saleOpenBlock = block.number;\\n        giftCutoff = totalSupply;\\n    }\\n\\n    /**\\n     * @dev Bookeeping for pass issuance\\n     */\\n    function issuePassHelper (address recipient, uint256 passId) private whenNotPaused {\\n        TokensByOwner[recipient].push(passId);\\n        OwnerTokenIndex[passId] = uint16(TokensByOwner[recipient].length);\\n        Owners[passId] = recipient;\\n        emit Transfer(address(0), recipient, passId);\\n    }\\n\\n    /**\\n     * @dev Allow contract owner to give a single pass\\n     */\\n    function givePass (address recipient) public onlyOwner {\\n        require(contractState == State.SaleOpen\\n                || contractState == State.Ready,\\n                \\\"Sale Closed\\\");\\n        require(totalSupply < maxSupply, \\\"Max Supply Exceeded\\\");\\n        issuePassHelper(recipient, totalSupply);\\n        totalSupply++;\\n    }\\n\\n    /**\\n     * @dev Allow contract owner to give multiple passes\\n     */\\n    function givePasses (address[] calldata recipients) public onlyOwner {\\n        require(contractState == State.SaleOpen\\n                || contractState == State.Ready,\\n                \\\"Sale Closed\\\");\\n        require((totalSupply + recipients.length) <= maxSupply, \\\"Max Supply Exceeded\\\");\\n        for (uint i = 0; i < recipients.length; i++) {\\n            issuePassHelper(recipients[i], totalSupply + i);\\n        }\\n        totalSupply += recipients.length;\\n    }\\n\\n    /**\\n     * @dev Check if a flightpass represents the given recipient and is signed by the flightlistSigner address\\n     */\\n    function validFlightlistPass (address recipient, bytes memory pass) public view returns (bool) {\\n        bytes32 m = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", keccak256(abi.encodePacked(\\\"flightlisted\\\", recipient))));\\n\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        require(pass.length == 65, \\\"Invalid Flightpass\\\");\\n\\n        assembly {\\n            r := mload(add(pass, 32))\\n            s := mload(add(pass, 64))\\n            v := byte(0, mload(add(pass, 96)))\\n        }\\n\\n        return (ecrecover(m, v, r, s) == flightlistSigner);\\n    }\\n\\n    /**\\n     * @dev Mint one or more tokens to the provided address\\n     */\\n    function mint (address recipient, uint256 quantity, bytes memory pass) public payable {\\n        if (quantity > 10) {\\n            quantity = 10;\\n        }\\n\\n        require(contractState == State.SaleOpen, \\\"Sale Closed\\\");\\n\\n        if (block.number < saleOpenBlock + (8 * FLIGHTLIST_ISSUANCE_DELAY)) {\\n            require(validFlightlistPass(recipient, pass), \\\"Invalid Flightpass\\\");\\n            require(balanceOf(recipient) == 0, \\\"Preflight Claimed\\\");\\n            quantity = 1;\\n        } else if (block.number < saleOpenBlock + (9 * FLIGHTLIST_ISSUANCE_DELAY)) {\\n            require(validFlightlistPass(recipient, pass), \\\"Invalid Flightpass\\\");\\n            require(balanceOf(recipient) + quantity <= 11, \\\"Flightpass limit exceeded\\\");\\n        } else if (flightlistCutoff == 8000) {\\n            flightlistCutoff = totalSupply;\\n        }\\n\\n        require((totalSupply + quantity) <= maxSupply, \\\"Max Supply Exceeded\\\");\\n\\n        uint256 cost = price * quantity;\\n        require(msg.value >= cost, \\\"Insufficient Funds\\\");\\n\\n        for (uint i = 0; i < quantity; i++) {\\n            issuePassHelper(recipient, totalSupply + i);\\n        }\\n\\n        totalSupply += quantity;\\n\\n        if (msg.value > cost) {\\n            (bool success,) = payable(msg.sender).call{value: msg.value - cost}(\\\"\\\");\\n            require(success, \\\"Refund Transfer Failed\\\");\\n        }\\n\\n    }\\n\\n    /**\\n     * @dev Determine which issuance window a pass was minted in: 0 => Gift; 1 => Flightlist; 2 => General Sale\\n     */\\n    function passType (uint256 tokenId) public view returns (uint8) {\\n        require(tokenExists(tokenId), \\\"Nonexistent Token\\\");\\n        if (tokenId < giftCutoff) return 0;\\n        if (tokenId < flightlistCutoff) return 1;\\n        return 2;\\n    }\\n\\n    /* SVG Assembly */\\n\\n    IMoonCatSVGS MoonCatSVGS = IMoonCatSVGS(0xB39C61fe6281324A23e079464f7E697F8Ba6968f);\\n\\n    /**\\n     * @dev Assemble one png layer of the SVG composite\\n     */\\n    function svgLayer (uint16 componentId)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\\"<image x=\\\\\\\"0\\\\\\\" y=\\\\\\\"0\\\\\\\" width=\\\\\\\"600\\\\\\\" height=\\\\\\\"600\\\\\\\" href=\\\\\\\"\\\",\\n                                IPFS_URI_Prefix,\\n                                IPFS_Legion_Folder,\\n                                \\\"/\\\",\\n                                MoonCatSVGS.uint2str(componentId),\\n                                \\\".png\\\\\\\" />\\\");\\n    }\\n\\n    /**\\n     * @dev Assemble the full SVG image for a legion fighter\\n     */\\n    function assembleSVG (uint16[13] memory componentIds) internal view returns (string memory) {\\n        bytes memory svg = \\\"<svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" preserveAspectRatio=\\\\\\\"xMidYMid meet\\\\\\\" viewBox=\\\\\\\"0 0 600 600\\\\\\\" width=\\\\\\\"600\\\\\\\" height=\\\\\\\"600\\\\\\\">\\\";\\n        for (uint i = 0; i < 12; i++) {\\n            svg = abi.encodePacked(svg, svgLayer(componentIds[i]));\\n        }\\n        return string(abi.encodePacked(svg, \\\"</svg>\\\"));\\n    }\\n\\n    /* Enumerable */\\n\\n    function tokenByIndex(uint256 tokenId) public view returns (uint256) {\\n        require(tokenExists(tokenId), \\\"Nonexistent Token\\\");\\n        return tokenId;\\n    }\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index < balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return TokensByOwner[owner][index];\\n    }\\n\\n    /* Owner Functions */\\n\\n    constructor(address flightlistSigningAddress, string memory ipfsPass) {\\n        contractOwner = msg.sender;\\n        flightlistSigner = flightlistSigningAddress;\\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);\\n        configureCities();\\n        IPFS_Pass_Folder = ipfsPass;\\n    }\\n\\n    /**\\n     * @dev Reset the flightlist signing address used for passes\\n     */\\n    function setFlightlistSigningAddress (address flightlistSigningAddress) public onlyOwner {\\n        flightlistSigner = flightlistSigningAddress;\\n    }\\n\\n    /**\\n     * @dev Set the contract address for on-chain metadata assembly\\n     */\\n    function setMetadataContract (address metadata) public onlyOwner {\\n        MetadataContractAddress = metadata;\\n    }\\n\\n    /**\\n     * @dev Set the URI prefix for accessing ipfs resources through a gateway\\n     */\\n    function setIpfsURIPrefix (string calldata ipfsURIPrefix) public onlyOwner {\\n        IPFS_URI_Prefix = ipfsURIPrefix;\\n    }\\n\\n    /**\\n     * @dev Change the owner of the contract\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        contractOwner = newOwner;\\n    }\\n\\n    function pause () public onlyOwner {\\n        paused = true;\\n    }\\n\\n    function unpause () public onlyOwner {\\n        paused = false;\\n    }\\n\\n    /**\\n     * @dev Public method to fetch a core character or assemble the image of a legion character on-chain (or passes, if not yet revealed)\\n     */\\n    function tokenImage (uint256 tokenId) public view returns (string memory) {\\n        require(tokenExists(tokenId), \\\"Nonexistent Token\\\");\\n        if (contractState == State.Revealed) {\\n            uint256 coreIdx = coreIndex(tokenId);\\n            if(coreIdx < 15) {\\n                return string(abi.encodePacked(\\\"ipfs://\\\", IPFS_Core_Folder, \\\"/\\\", MoonCatSVGS.uint2str(coreIdx), \\\".png\\\"));\\n            } else {\\n                uint256 dna = getDNA(tokenId);\\n                (uint16[13] memory components,,,) = getTraitComponents(tokenId, dna);\\n                return assembleSVG(components);\\n            }\\n        } else {\\n            return string(abi.encodePacked(\\\"ipfs://\\\", IPFS_Pass_Folder, \\\"/\\\", MoonCatSVGS.uint2str(passType(tokenId)), \\\".png\\\"));\\n        }\\n    }\\n\\n    /**\\n     * @notice tokenURIs are returned as IPFS URIs for core characters and on-chain generated BASE64 encoded JSON for legion characters (or IPFS URIs for passes, if not yet revealed)\\n     * @dev JSON data is generated by a call to an external metadata contract\\n     */\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        require(tokenId < totalSupply, \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n        if (contractState == State.Revealed) {\\n            uint256 coreIdx = coreIndex(tokenId);\\n            if (coreIdx < 15) {\\n                return string(abi.encodePacked(\\\"ipfs://\\\", IPFS_Core_Folder, \\\"/\\\", MoonCatSVGS.uint2str(coreIdx), \\\".json\\\"));\\n            } else {\\n                return IMetadata(MetadataContractAddress).legionMetadata(tokenId);\\n            }\\n        } else {\\n            return string(abi.encodePacked(\\\"ipfs://\\\", IPFS_Pass_Folder, \\\"/\\\", MoonCatSVGS.uint2str(passType(tokenId)), \\\".json\\\"));\\n        }\\n    }\\n\\n    function tokenExists(uint256 tokenId) public view returns (bool) {\\n        return (tokenId < totalSupply);\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        require(tokenExists(tokenId), \\\"ERC721: Nonexistent token\\\");\\n        return Owners[tokenId];\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return TokensByOwner[owner].length;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC721Enumerable).interfaceId;\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        TokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function approve(address to, uint256 tokenId) public  {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n                msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n                \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n                );\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(tokenId < totalSupply, \\\"ERC721: approved query for nonexistent token\\\");\\n        return TokenApprovals[tokenId];\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view  returns (bool) {\\n        return OperatorApprovals[owner][operator];\\n    }\\n\\n    function setApprovalForAll(\\n                               address operator,\\n                               bool approved\\n                               ) external virtual {\\n        require(msg.sender != operator, \\\"ERC721: approve to caller\\\");\\n        OperatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n        size := extcodesize(account)\\n                }\\n        return size > 0;\\n    }\\n\\n    function _checkOnERC721Received(\\n                                    address from,\\n                                    address to,\\n                                    uint256 tokenId,\\n                                    bytes memory _data\\n                                    ) private returns (bool) {\\n        if (isContract(to)) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                            }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function _transfer(\\n                       address from,\\n                       address to,\\n                       uint256 tokenId\\n                       ) private whenNotPaused {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        uint16 valueIndex = OwnerTokenIndex[tokenId];\\n        uint256 toDeleteIndex = valueIndex - 1;\\n        uint256 lastIndex = TokensByOwner[from].length - 1;\\n        if (lastIndex != toDeleteIndex) {\\n            uint256 lastTokenId = TokensByOwner[from][lastIndex];\\n            TokensByOwner[from][toDeleteIndex] = lastTokenId;\\n            OwnerTokenIndex[lastTokenId] = valueIndex;\\n        }\\n        TokensByOwner[from].pop();\\n\\n        TokensByOwner[to].push(tokenId);\\n        OwnerTokenIndex[tokenId] = uint16(TokensByOwner[to].length);\\n\\n        Owners[tokenId] = to;\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(tokenId < totalSupply, \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    function transferFrom(\\n                          address from,\\n                          address to,\\n                          uint256 tokenId\\n                          ) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n                              address from,\\n                              address to,\\n                              uint256 tokenId\\n                              ) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n                              address from,\\n                              address to,\\n                              uint256 tokenId,\\n                              bytes memory _data\\n                              ) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n\\n    function _safeTransfer(\\n                           address from,\\n                           address to,\\n                           uint256 tokenId,\\n                           bytes memory _data\\n                           ) private {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /* Modifiers */\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == contractOwner, \\\"Not Owner\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(paused == false, \\\"Paused\\\");\\n        _;\\n    }\\n\\n    modifier whenRevealed() {\\n        require(contractState == State.Revealed, \\\"Not Revealed\\\");\\n        _;\\n    }\\n\\n\\n    /* Rescuers */\\n    /**\\n    * @dev Rescue ERC20 assets sent directly to this contract.\\n    */\\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\\n        IERC20 token = IERC20(tokenContract);\\n        token.transfer(contractOwner, token.balanceOf(address(this)));\\n        }\\n\\n    /**\\n     * @dev Rescue ERC721 assets sent directly to this contract.\\n     */\\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\\n        IERC721(tokenContract).safeTransferFrom(address(this), contractOwner, tokenId);\\n    }\\n\\n    /* Tokens */\\n\\n    string[3] public PassTypeNames =\\n        [\\n         \\\"Signalnoise\\\",\\n         \\\"Flight List\\\",\\n         \\\"STARKADE\\\"\\n         ];\\n\\n    string[182] internal Tokens =\\n        [\\n         \\\"\\\",\\n         \\\"None\\\",\\n         \\\"$Magna\\\",\\n         \\\"Aeon\\\",\\n         \\\"Agile\\\",\\n         \\\"Ai\\\",\\n         \\\"Arcade\\\",\\n         \\\"Arm\\\",\\n         \\\"Armband\\\",\\n         \\\"Arms\\\",\\n         \\\"Arrows\\\",\\n         \\\"Athletic\\\",\\n         \\\"Aviators\\\",\\n         \\\"Awesome\\\",\\n         \\\"Back\\\",\\n         \\\"Bangs\\\",\\n         \\\"Basher\\\",\\n         \\\"Beefy\\\",\\n         \\\"Biker\\\",\\n         \\\"Black\\\",\\n         \\\"Blaster\\\",\\n         \\\"Blonde\\\",\\n         \\\"Blue\\\",\\n         \\\"Bounty\\\",\\n         \\\"Braids\\\",\\n         \\\"Bronco\\\",\\n         \\\"Camo\\\",\\n         \\\"Cap\\\",\\n         \\\"Chaos\\\",\\n         \\\"Choker\\\",\\n         \\\"Classic\\\",\\n         \\\"Clenched\\\",\\n         \\\"Comms\\\",\\n         \\\"Crash\\\",\\n         \\\"CrossStrap\\\",\\n         \\\"Cyan\\\",\\n         \\\"Cyber\\\",\\n         \\\"CyberBangs\\\",\\n         \\\"CyberWolf\\\",\\n         \\\"Digital\\\",\\n         \\\"Doomsday\\\",\\n         \\\"Double\\\",\\n         \\\"Dreadlocks\\\",\\n         \\\"Earring\\\",\\n         \\\"Elv\\\",\\n         \\\"Evil\\\",\\n         \\\"Eye\\\",\\n         \\\"Eyes\\\",\\n         \\\"Fangs\\\",\\n         \\\"Field\\\",\\n         \\\"Finisher\\\",\\n         \\\"Fire\\\",\\n         \\\"Flaming\\\",\\n         \\\"Flash\\\",\\n         \\\"Focussed\\\",\\n         \\\"Force\\\",\\n         \\\"Fortress\\\",\\n         \\\"Frostware\\\",\\n         \\\"Future\\\",\\n         \\\"GM\\\",\\n         \\\"Gem\\\",\\n         \\\"Green\\\",\\n         \\\"Grimm\\\",\\n         \\\"Grin\\\",\\n         \\\"Growl\\\",\\n         \\\"Grump\\\",\\n         \\\"Half-sleeves\\\",\\n         \\\"Hat\\\",\\n         \\\"Headphones\\\",\\n         \\\"Helmet\\\",\\n         \\\"Hex\\\",\\n         \\\"Hood\\\",\\n         \\\"Ice\\\",\\n         \\\"JacK\\\",\\n         \\\"Jacket\\\",\\n         \\\"Jet\\\",\\n         \\\"Kentaro\\\",\\n         \\\"Laugh\\\",\\n         \\\"Lavaware\\\",\\n         \\\"Leather\\\",\\n         \\\"Legion\\\",\\n         \\\"Leopard\\\",\\n         \\\"Lightning\\\",\\n         \\\"Line\\\",\\n         \\\"Long\\\",\\n         \\\"Magic\\\",\\n         \\\"Magna\\\",\\n         \\\"Magnaton\\\",\\n         \\\"Mask\\\",\\n         \\\"Mauve\\\",\\n         \\\"Mech\\\",\\n         \\\"Meh\\\",\\n         \\\"Merc\\\",\\n         \\\"Mohawk\\\",\\n         \\\"Morningstar\\\",\\n         \\\"Multi\\\",\\n         \\\"Necro\\\",\\n         \\\"NeonFire\\\",\\n         \\\"NuTech\\\",\\n         \\\"OG\\\",\\n         \\\"Obrakian\\\",\\n         \\\"Ochre\\\",\\n         \\\"Ombre\\\",\\n         \\\"Orange\\\",\\n         \\\"Pads\\\",\\n         \\\"Panther\\\",\\n         \\\"Paradise\\\",\\n         \\\"Patch\\\",\\n         \\\"Pink\\\",\\n         \\\"Pods\\\",\\n         \\\"Ponderware\\\",\\n         \\\"Ponytail\\\",\\n         \\\"Pout\\\",\\n         \\\"Power\\\",\\n         \\\"Punk\\\",\\n         \\\"Purple\\\",\\n         \\\"Rad\\\",\\n         \\\"Rain\\\",\\n         \\\"Rainbow\\\",\\n         \\\"Rev\\\",\\n         \\\"Ripped\\\",\\n         \\\"Robo\\\",\\n         \\\"Rocker\\\",\\n         \\\"SN\\\",\\n         \\\"Samurai\\\",\\n         \\\"Savage\\\",\\n         \\\"Shade\\\",\\n         \\\"Shades\\\",\\n         \\\"SharpShooter\\\",\\n         \\\"Shave\\\",\\n         \\\"Short\\\",\\n         \\\"Showhawk\\\",\\n         \\\"Side\\\",\\n         \\\"Silver\\\",\\n         \\\"Skull\\\",\\n         \\\"Sleeves\\\",\\n         \\\"Smile\\\",\\n         \\\"Sneer\\\",\\n         \\\"Spear\\\",\\n         \\\"Spears\\\",\\n         \\\"Spectran\\\",\\n         \\\"Spiked\\\",\\n         \\\"Spikes\\\",\\n         \\\"Staff\\\",\\n         \\\"Staffs\\\",\\n         \\\"Starkadian\\\",\\n         \\\"Stay\\\",\\n         \\\"Stealth\\\",\\n         \\\"Strapped\\\",\\n         \\\"Strike\\\",\\n         \\\"Stripe\\\",\\n         \\\"Stripes\\\",\\n         \\\"Stubble\\\",\\n         \\\"SunFire\\\",\\n         \\\"Sweep\\\",\\n         \\\"Swoosh\\\",\\n         \\\"Sword\\\",\\n         \\\"Syndicate\\\",\\n         \\\"Tattoos\\\",\\n         \\\"Tawny\\\",\\n         \\\"Tezukan\\\",\\n         \\\"Tongue\\\",\\n         \\\"Toothy\\\",\\n         \\\"Tribe\\\",\\n         \\\"VR\\\",\\n         \\\"Vapour\\\",\\n         \\\"Vest\\\",\\n         \\\"Visor\\\",\\n         \\\"Visualiser\\\",\\n         \\\"Volta\\\",\\n         \\\"Volume\\\",\\n         \\\"Warrior\\\",\\n         \\\"Wave\\\",\\n         \\\"Whip\\\",\\n         \\\"White\\\",\\n         \\\"Wig\\\",\\n         \\\"Wild\\\",\\n         \\\"Windblown\\\",\\n         \\\"Wink\\\",\\n         \\\"Yell\\\",\\n         \\\"Zebra\\\",\\n         \\\"Shaved\\\"\\n         ];\\n\\n    /* Trait Names */\\n\\n    uint8[996] internal TraitNames =\\n        [\\n         17 , 0  , 0  , 11 , 0  , 0  , 86 , 117, 0  , 51 , 0  , 0  , 82 , 0  , 0  ,\\n         28 , 0  , 103, 28 , 0  , 108, 28 , 0  , 22 , 28 , 0  , 115, 113, 0  , 103,\\n         113, 0  , 108, 113, 0  , 22 , 113, 0  , 115, 86 , 143, 0  , 173, 0  , 0  ,\\n         20 , 0  , 0  , 75 , 109, 0  , 94 , 0  , 0  , 41 , 139, 0  , 55 , 49 , 0  ,\\n         10 , 0  , 0  , 138, 0  , 0  , 156, 0  , 0  , 86 , 143, 0  , 173, 0  , 0  ,\\n         20 , 0  , 0  , 75 , 109, 0  , 94 , 0  , 0  , 41 , 139, 0  , 144, 0  , 0  ,\\n         10 , 0  , 0  , 138, 0  , 0  , 156, 0  , 0  , 89 , 0  , 0  , 35 , 0  , 0  ,\\n         44 , 0  , 0  , 101, 0  , 0  , 159, 0  , 0  , 89 , 0  , 0  , 35 , 0  , 0  ,\\n         44 , 0  , 0  , 101, 0  , 0  , 159, 0  , 0  , 13 , 0  , 0  , 39 , 106, 0  ,\\n         157, 0  , 0  , 123, 134, 0  , 180, 0  , 22 , 145, 0  , 0  , 2  , 0  , 0  ,\\n         59 , 0  , 0  , 180, 0  , 108, 80 , 0  , 0  , 146, 116, 0  , 26 , 0  , 0  ,\\n         169, 62 , 0  , 39 , 106, 0  , 98 , 0  , 0  , 123, 134, 0  , 81 , 0  , 0  ,\\n         145, 0  , 0  , 2  , 0  , 0  , 105, 0  , 0  , 180, 0  , 108, 80 , 0  , 0  ,\\n         151, 0  , 0  , 26 , 0  , 0  , 5  , 0  , 0  , 145, 0  , 0  , 38 , 0  , 0  ,\\n         128, 0  , 0  , 126, 0  , 0  , 57 , 0  , 0  , 99 , 0  , 0  , 34 , 0  , 0  ,\\n         160, 0  , 0  , 80 , 0  , 115, 80 , 0  , 174, 100, 0  , 22 , 100, 0  , 61 ,\\n         5  , 0  , 0  , 145, 0  , 0  , 60 , 0  , 0  , 128, 0  , 0  , 126, 0  , 0  ,\\n         57 , 0  , 0  , 23 , 0  , 0  , 34 , 0  , 0  , 147, 0  , 0  , 80 , 0  , 174,\\n         78 , 0  , 0  , 87 , 0  , 0  , 100, 0  , 61 , 53 , 0  , 0  , 3  , 0  , 108,\\n         3  , 0  , 174, 1  , 0  , 0  , 40 , 0  , 0  , 16 , 0  , 19 , 16 , 0  , 108,\\n         16 , 0  , 115, 152, 0  , 0  , 36 , 163, 108, 36 , 163, 115, 53 , 0  , 0  ,\\n         3  , 0  , 108, 3  , 0  , 174, 1  , 0  , 0  , 171, 47 , 0  , 150, 0  , 0  ,\\n         16 , 0  , 22 , 16 , 0  , 115, 16 , 0  , 174, 36 , 163, 108, 36 , 163, 115,\\n         48 , 0  , 0  , 161, 0  , 0  , 162, 136, 0  , 91 , 0  , 0  , 31 , 0  , 0  ,\\n         65 , 0  , 0  , 77 , 0  , 0  , 137, 0  , 0  , 63 , 0  , 0  , 179, 0  , 0  ,\\n         48 , 0  , 0  , 161, 0  , 0  , 162, 136, 0  , 112, 0  , 0  , 31 , 0  , 0  ,\\n         137, 0  , 19 , 64 , 0  , 0  , 137, 0  , 0  , 136, 0  , 0  , 179, 0  , 0  ,\\n         90 , 0  , 0  , 153, 0  , 0  , 72 , 0  , 0  , 97 , 0  , 0  , 96 , 0  , 0  ,\\n         45 , 0  , 0  , 85 , 0  , 0  , 178, 0  , 0  , 30 , 0  , 0  , 54 , 0  , 0  ,\\n         90 , 0  , 0  , 153, 0  , 0  , 72 , 0  , 0  , 97 , 0  , 0  , 96 , 0  , 0  ,\\n         45 , 0  , 0  , 85 , 0  , 0  , 178, 0  , 0  , 30 , 0  , 0  , 54 , 0  , 0  ,\\n         36 , 46 , 0  , 118, 167, 0  , 124, 88 , 108, 134, 88 , 108, 164, 167, 0  ,\\n         46 , 107, 0  , 124, 88 , 61 , 83 , 127, 0  , 134, 88 , 174, 168, 0  , 0  ,\\n         60 , 0  , 0  , 33 , 88 , 0  , 121, 167, 108, 127, 0  , 133, 127, 0  , 19 ,\\n         127, 0  , 108, 12 , 0  , 0  , 50 , 88 , 22 , 50 , 88 , 115, 43 , 0  , 0  ,\\n         36 , 46 , 0  , 118, 167, 0  , 124, 88 , 103, 134, 88 , 115, 164, 167, 0  ,\\n         46 , 107, 0  , 57 , 88 , 0  , 83 , 127, 0  , 134, 88 , 103, 168, 0  , 0  ,\\n         60 , 0  , 0  , 121, 167, 19 , 121, 167, 174, 127, 0  , 133, 127, 0  , 19 ,\\n         125, 127, 0  , 12 , 0  , 0  , 50 , 88 , 103, 50 , 88 , 61 , 43 , 0  , 0  ,\\n         93 , 0  , 108, 124, 84 , 22 , 155, 0  , 174, 42 , 0  , 115, 176, 0  , 19 ,\\n         176, 0  , 174, 124, 0  , 174, 93 , 0  , 19 , 172, 0  , 115, 93 , 0  , 174,\\n         124, 84 , 174, 172, 0  , 174, 155, 0  , 19 , 42 , 0  , 174, 177, 0  , 19 ,\\n         131, 0  , 19 , 177, 0  , 108, 141, 0  , 19 , 141, 0  , 21 , 130, 142, 19 ,\\n         130, 142, 21 , 124, 0  , 19 , 124, 84 , 19 , 155, 0  , 21 , 172, 0  , 19 ,\\n         102, 0  , 0  , 93 , 0  , 115, 24 , 0  , 115, 141, 14 , 22 , 132, 129, 174,\\n         37 , 0  , 22 , 37 , 0  , 115, 154, 0  , 108, 130, 0  , 115, 111, 0  , 108,\\n         141, 130, 35 , 141, 84 , 35 , 141, 84 , 174, 130, 0  , 174, 24 , 0  , 22 ,\\n         132, 129, 19 , 111, 0  , 19 , 170, 0  , 0  , 141, 14 , 19 , 141, 130, 174,\\n         141, 84 , 19 , 15 , 0  , 108, 15 , 0  , 174, 93 , 0  , 19 , 154, 0  , 19 ,\\n         76 , 74 , 108, 6  , 74 , 0  , 50 , 104, 115, 36 , 7  , 0  , 128, 9  , 0  ,\\n         5  , 9  , 0  , 126, 9  , 0  , 76 , 74 , 22 , 92 , 104, 115, 40 , 104, 108,\\n         40 , 104, 115, 36 , 158, 0  , 73 , 9  , 174, 18 , 166, 0  , 79 , 74 , 19 ,\\n         148, 104, 0  , 149, 104, 108, 149, 104, 22 , 50 , 104, 22 , 145, 9  , 0  ,\\n         73 , 9  , 115, 70 , 9  , 103, 120, 135, 0  , 76 , 74 , 95 , 6  , 74 , 0  ,\\n         114, 166, 0  , 36 , 7  , 0  , 128, 9  , 0  , 5  , 9  , 0  , 126, 9  , 0  ,\\n         92 , 104, 95 , 141, 104, 0  , 40 , 104, 19 , 36 , 158, 0  , 73 , 9  , 174,\\n         29 , 0  , 115, 56 , 104, 0  , 79 , 74 , 174, 66 , 0  , 0  , 149, 104, 108,\\n         4  , 104, 0  , 145, 9  , 0  , 73 , 9  , 115, 29 , 0  , 19 , 120, 135, 0  ,\\n         8  , 0  , 0  , 128, 69 , 0  , 38 , 69 , 0  , 52 , 134, 0  , 73 , 69 , 174,\\n         5  , 69 , 0  , 121, 69 , 0  , 110, 69 , 108, 73 , 69 , 19 , 126, 69 , 0  ,\\n         119, 69 , 19 , 110, 69 , 22 , 119, 69 , 115, 25 , 67 , 0  , 122, 175, 0  ,\\n         71 , 0  , 22 , 71 , 0  , 115, 80 , 27 , 0  , 68 , 0  , 0  , 32 , 0  , 0  ,\\n         58 , 167, 0  , 128, 69 , 0  , 57 , 69 , 0  , 52 , 134, 0  , 73 , 69 , 174,\\n         5  , 69 , 0  , 78 , 69 , 0  , 110, 69 , 108, 73 , 69 , 19 , 126, 69 , 0  ,\\n         119, 69 , 19 , 110, 69 , 22 , 119, 69 , 115, 165, 88 , 0  , 25 , 67 , 0  ,\\n         140, 69 , 0  , 71 , 0  , 22 , 71 , 0  , 174, 80 , 27 , 0  , 68 , 0  , 0  ,\\n         32 , 0  , 0  , 181, 0  , 0\\n         ];\\n\\n    /*\\n     * @dev Assemble the name associated with a traitIndex by building TraitNames from their associated Tokens\\n     */\\n    function traitName (uint256 traitIndex) public view returns (string memory) {\\n        uint256 baseIndex = traitIndex * 3;\\n        uint8 index1 = TraitNames[baseIndex];\\n        uint8 index2 = TraitNames[baseIndex + 1];\\n        uint8 index3 = TraitNames[baseIndex + 2];\\n        bytes memory result = bytes(Tokens[index1]);\\n        if (index2 > 0) {\\n            result = abi.encodePacked(result, \\\" \\\", Tokens[index2]);\\n        }\\n        if (index3 > 0) {\\n            result = abi.encodePacked(result, \\\": \\\", Tokens[index3]);\\n        }\\n        return string(result);\\n    }\\n\\n    string[7] public RegionNames =\\n      [\\\"Shoreridge\\\",\\n       \\\"Skyroar Mountains\\\",\\n       \\\"Ark Teknos\\\",\\n       \\\"The Wailands\\\",\\n       \\\"Aeon Morrow\\\",\\n       \\\"Neowave Desert\\\",\\n       \\\"Grinferno Plains\\\"];\\n\\n    struct City {\\n        uint8 region;\\n        string name;\\n        string characteristic;\\n        uint8[5] bonus;\\n    }\\n    mapping (uint256 => City) internal Cities;\\n\\n    /*\\n     * @dev Initialize Cities\\n     */\\n    function configureCities() internal {\\n        //                Rg. CityName             Characteristic   Po En Sp De Ch\\n        Cities[0] =  City(0, \\\"Fellbreeze\\\",         \\\"Idealistic\\\",   [0, 15, 0, 0, 0]);\\n        Cities[1] =  City(1, \\\"Driftwood Quay\\\",     \\\"Imposing\\\",     [0, 0, 0, 15, 0]);\\n        Cities[2] =  City(2, \\\"Westforge\\\",          \\\"Industrious\\\",  [15, 0, 0, 0, 0]);\\n        Cities[3] =  City(3, \\\"Stonebrigg\\\",         \\\"Regimented\\\",   [5, 0, 0, 5, 5]);\\n        Cities[4] =  City(3, \\\"Kingdom of Spectra\\\", \\\"Fantastical\\\",  [0, 0, 0, 0, 15]);\\n        Cities[5] =  City(4, \\\"Magnaton City\\\",      \\\"Proud\\\",        [5, 10, 0, 0, 0]);\\n        Cities[6] =  City(4, \\\"Los Astra\\\",          \\\"Boisterous\\\",   [0, 10, 0, 5, 0]);\\n        Cities[7] =  City(5, \\\"Tezuka\\\",             \\\"Adaptable\\\",    [0, 10, 0, 5, 0]);\\n        Cities[8] =  City(6, \\\"Castor Locke\\\",       \\\"Cosmopolitan\\\", [5, 5, 5, 0, 0]);\\n        Cities[9] =  City(6, \\\"Obrak\\\",              \\\"Resourceful\\\",  [0, 5, 5, 0, 5]);\\n        Cities[10] = City(6, \\\"Warren Lake\\\",        \\\"Grim\\\",         [5, 0, 5, 5, 0]);\\n        Cities[11] = City(6, \\\"Brawna\\\",             \\\"Optimistic\\\",   [0, 10, 5, 0, 0]);\\n    }\\n\\n    /*\\n     * @dev Get info about a particular city\\n     */\\n    function cityInfo (uint256 cityId) public view returns (string memory regionName, string memory cityName, string memory characteristic) {\\n        require(cityId < 12, \\\"Invalid cityId\\\");\\n        City memory city = Cities[cityId];\\n        regionName = RegionNames[city.region];\\n        cityName = city.name;\\n        characteristic = city.characteristic;\\n    }\\n\\n    //                                   Pow Ene Spe Def Cha\\n    uint8[55] public EquipmentBonuses = [ 0,  0,  0,  0,  0,\\n                                          0,  0,  0,  0, 15,\\n                                          5,  5,  5,  0,  0,\\n                                         15,  0,  0,  0,  0,\\n                                          0,  0, 15,  0,  0,\\n                                          5,  0,  0, 10,  0,\\n                                         10,  0,  0,  5,  0,\\n                                          0,  0,  5, 10,  0,\\n                                          0,  5, 10,  0,  0,\\n                                          5,  0,  5,  5,  0,\\n                                         10,  0,  5,  0,  0];\\n\\n    string[5] public BoostNames =\\n        [\\\"Power\\\",\\n         \\\"Energy\\\",\\n         \\\"Speed\\\",\\n         \\\"Defence\\\",\\n         \\\"Chaos\\\"];\\n\\n    /*\\n     * @dev Determines the bonus associated with a trait based on its rarity\\n     */\\n    function determineTraitBonus (uint8 strand)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        if (strand < 4) {\\n            return 6; // UltraRare\\n        } else if (strand < 24) {\\n            return 5; // Rare\\n        } else if (strand < 96) {\\n            return 4; // Uncommon\\n        } else {\\n            return 3; // Common\\n        }\\n    }\\n\\n    /*\\n     * @dev Computes the component and bonus associated with an indexed trait\\n     */\\n    function determineTraitValue (uint256 dna,\\n                                  bool altBodyType,\\n                                  uint8 traitIndex,\\n                                  uint16 traitOffset,\\n                                  uint8 numElite,\\n                                  uint8 numRare,\\n                                  uint8 numUncommon,\\n                                  uint8 numCommon)\\n\\n        internal\\n        pure\\n        returns (uint16 componentIndex, uint8 traitBonus)\\n    {\\n        uint8 strand = uint8(dna >> (traitIndex * 8));\\n\\n        traitBonus = determineTraitBonus(strand);\\n\\n        componentIndex = traitOffset;\\n\\n        if (traitBonus == 6) {\\n            // UltraRare\\n            componentIndex += strand % numElite;\\n        } else if (traitBonus == 5) {\\n            // Rare\\n            componentIndex += (strand % numRare) + numElite;\\n        } else if (traitBonus == 4) {\\n            // Uncommon\\n            componentIndex += (strand % numUncommon) + numElite + numRare;\\n        } else {\\n            // Common\\n            componentIndex += (strand % numCommon) + numElite + numRare + numUncommon;\\n        }\\n\\n        if (altBodyType) {\\n            componentIndex += (numElite + numRare + numUncommon + numCommon);\\n        }\\n    }\\n\\n\\n    mapping (uint256 => uint8) public Equipped;\\n\\n    enum EquipmentSelectionStates\\n    {\\n     Open,\\n     Closed,\\n     Frozen\\n    }\\n\\n\\n    EquipmentSelectionStates public equipmentSelectionState = EquipmentSelectionStates.Closed;\\n\\n    /*\\n     * @dev Allow equipment selection\\n     */\\n    function openEquipmentSelection () public onlyOwner {\\n        require (equipmentSelectionState == EquipmentSelectionStates.Closed, \\\"Not Closed\\\");\\n        equipmentSelectionState = EquipmentSelectionStates.Open;\\n    }\\n\\n    /*\\n     * @dev Temporarily halt equipment selection\\n     */\\n    function closeEquipmentSelection () public onlyOwner {\\n        require (equipmentSelectionState == EquipmentSelectionStates.Open, \\\"Not Open\\\");\\n        equipmentSelectionState = EquipmentSelectionStates.Closed;\\n    }\\n\\n    /*\\n     * @dev Permanently halt equipment selection\\n     */\\n    function permanentlyFreezeEquimentSelection () public onlyOwner {\\n        equipmentSelectionState = EquipmentSelectionStates.Frozen;\\n    }\\n\\n    /*\\n     * @dev One-time selection of equipment for a legion character as an index from 1 through 5 into their specific equipment options\\n     */\\n    function chooseEquipment (uint256 tokenId, uint8 choice) public whenRevealed {\\n        require(ownerOf(tokenId) == msg.sender, \\\"Not owner\\\");\\n        require(choice > 0 && choice <= 5, \\\"Invalid Choice\\\");\\n        require(Equipped[tokenId] == 0, \\\"Already Equipped\\\");\\n        require(equipmentSelectionState == EquipmentSelectionStates.Open, \\\"Not Open\\\");\\n        Equipped[tokenId] = choice;\\n    }\\n\\n    /*\\n     * @dev Process a tokenId into its associated DNA sequence by combining with the revealSeed (not applicable to core characters)\\n     */\\n    function getDNA (uint256 tokenId) public view returns (uint256) {\\n        require (coreIndex(tokenId) >= 15, \\\"Core Character\\\");\\n        return uint256(keccak256(abi.encodePacked(revealSeed, tokenId)));\\n    }\\n\\n    /*\\n     * @dev Determine the pseudorandom selection of equipment available to a specific legion character\\n     */\\n    function equipmentOptions (uint256 dna) internal pure returns (uint8[5] memory) {\\n\\n        uint16 equipmentSeed = uint8(dna >> 16);\\n        uint8[5] memory options;\\n        for (uint8 i = 0; i < 10; i++) {\\n            uint8 index = uint8((13 * i + equipmentSeed) % 10);\\n            if(index < 5) {\\n                options[index] = i + 1;\\n            }\\n        }\\n\\n        return options;\\n    }\\n\\n    uint16 constant EQUIPMENT_OFFSET = 13;\\n    uint16 constant SKIN_TONE_OFFSET = 33;\\n\\n    /*\\n     * @dev Convert token DNA into an array of trait components, total bonus, active equipment, and body type\\n     */\\n    function getTraitComponents (uint256 tokenId, uint256 dna)\\n        internal\\n        view\\n        returns (uint16[13] memory components, uint8 totalBonus, uint8 equipmentId, bool alt)\\n    {\\n\\n        alt = (dna >> 252 & 1) == 1;\\n        bool head = (dna >> 253 & 1) == 1; // Hair or Head Gear\\n        bool wear = (dna >> 254 & 1) == 1; // Shirt or Armour\\n\\n        uint8 tempBonus;\\n\\n        (components[0], tempBonus) = determineTraitValue(dna, false, 0, 2, 1, 2, 4, 4); // Background\\n        totalBonus += tempBonus;\\n\\n        uint8 equipmentOption = Equipped[tokenId];\\n        if (equipmentOption > 0) {\\n            uint8[5] memory options = equipmentOptions(dna);\\n            equipmentId = options[equipmentOption - 1];\\n            components[1] = equipmentId - 1 + EQUIPMENT_OFFSET;\\n            if (alt) {\\n                components[1] += 10;\\n            }\\n        } else {\\n            components[1] = 96;\\n        }\\n\\n\\n        components[2] = uint16((((dna >> 24) & 255) % 5) + SKIN_TONE_OFFSET);\\n        if (alt) {\\n            components[2] += 5; // Skin Tone\\n        }\\n\\n        if (wear) {\\n            (components[3], tempBonus) = determineTraitValue(dna, alt, 3, 43, 1, 3, 3, 5); // Shirt\\n            components[4] = 96;\\n        } else {\\n            (components[4], tempBonus) = determineTraitValue(dna, alt, 4, 67, 1, 2, 4, 6); // Armour\\n            components[3] = 96;\\n        }\\n        totalBonus += tempBonus;\\n\\n        (components[5], tempBonus) = determineTraitValue(dna, alt, 5, 93, 1, 3, 3, 4); // Face Paint\\n        totalBonus += tempBonus;\\n        (components[6], tempBonus) = determineTraitValue(dna, alt, 6, 115, 1, 1, 4, 4); // Mouth\\n        totalBonus += tempBonus;\\n        (components[7], tempBonus) = determineTraitValue(dna, alt, 7, 135, 1, 4, 3, 2); // Eyes\\n        totalBonus += tempBonus;\\n        (components[8], tempBonus) = determineTraitValue(dna, alt, 8, 155, 3, 4, 6, 7); // Face Gear\\n        totalBonus += tempBonus;\\n\\n        if (head) {\\n            (components[9], tempBonus) = determineTraitValue(dna, alt, 9, 195, 4, 5, 6, 10); // Hair\\n            components[11] = 96;\\n        } else {\\n            (components[11], tempBonus) = determineTraitValue(dna, alt, 11, 291, 3, 4, 6, 7); // Head Gear\\n            components[9] = 331;\\n        }\\n        totalBonus += tempBonus;\\n\\n        (components[10], tempBonus) = determineTraitValue(dna, alt, 10, 245, 2, 4, 7, 10); // Gear\\n        totalBonus += tempBonus;\\n\\n        components[12] = uint16((dna >> 96)) % 12; // City\\n\\n    }\\n\\n    /*\\n     * @dev Compute the boosts for each of Power, Energy, Speed, Defence, & Chaos\\n     */\\n    function getBoosts (uint256 dna, uint16 cityId, uint8 traitBonus, uint8 equipmentId) internal view returns (uint8[5] memory boosts) {\\n        uint8[5] memory cityBonus = Cities[cityId].bonus;\\n\\n        for (uint i = 0; i < 10; i++) {\\n            uint boostId = (dna >> (i * 2 + 14 * 8)) & 3;\\n            while (boosts[boostId] >= 20) {\\n                if(boostId == 3) {\\n                    boostId = 0;\\n                } else {\\n                    boostId++;\\n                }\\n            }\\n            boosts[boostId] += 5;\\n        }\\n\\n        for (uint i = 0; i < 5; i++) {\\n            boosts[i] += 10 + traitBonus + cityBonus[i] + EquipmentBonuses[equipmentId * 5 + i];\\n        }\\n\\n        return boosts;\\n    }\\n\\n    /*\\n     * @dev Public method for fetching the 5 pseudorandom equipment options for a legion character\\n     */\\n    function getEquipmentOptions (uint256 tokenId) public view whenRevealed returns (uint8[5] memory) {\\n        return equipmentOptions(getDNA(tokenId));\\n    }\\n\\n    string[16] public Attributes =\\n        [\\\"Body Type\\\",\\n         \\\"Background\\\",\\n         \\\"Equipment\\\",\\n         \\\"Skin Tone\\\",\\n         \\\"Shirt\\\",\\n         \\\"Armour\\\",\\n         \\\"Face Paint\\\",\\n         \\\"Mouth\\\",\\n         \\\"Eyes\\\",\\n         \\\"Face Gear\\\",\\n         \\\"Hair\\\",\\n         \\\"Gear\\\",\\n         \\\"Head Gear\\\",\\n         \\\"Region\\\",\\n         \\\"City\\\",\\n         \\\"Characteristic\\\"];\\n\\n    /*\\n     * @dev Return human-readable traits and boosts, along with a generated SVG for the provided tokenId (not applicable to core characters)\\n     */\\n    function getTraits (uint256 tokenId) public view whenRevealed returns (string[16] memory attributes, uint8[5] memory boosts, string memory image) {\\n        //  ** Attributes **\\n        //  0 - Body Type\\n        //  1 - Background\\n        //  2 - Equipment\\n        //  3 - Skin Tone\\n        //  4 - Shirt\\n        //  5 - Armour\\n        //  6 - Face Paint\\n        //  7 - Mouth\\n        //  8 - Eyes\\n        //  9 - Face Gear\\n        // 10 - Hair\\n        // 11 - Gear\\n        // 12 - Head Gear\\n        // 13 - Region\\n        // 14 - City\\n        // 15 - Characteristic\\n\\n        // ** Boosts **\\n        //  0 - Power\\n        //  1 - Energy\\n        //  2 - Speed\\n        //  3 - Defence\\n        //  4 - Chaos\\n\\n        uint256 dna = getDNA(tokenId);\\n        (uint16[13] memory components, uint8 totalBonus, uint8 equipmentId, bool alt) = getTraitComponents(tokenId, dna);\\n        boosts = getBoosts(dna, components[12], totalBonus, equipmentId);\\n\\n        if(alt) {\\n            attributes[0] = traitName(1);\\n        } else {\\n            attributes[0] = traitName(0);\\n        }\\n\\n        for (uint i = 0; i < 12; i++) {\\n            attributes[i + 1] = traitName(components[i]);\\n        }\\n\\n        City memory city = Cities[components[12]];\\n\\n        attributes[13] = RegionNames[city.region];\\n        attributes[14] = city.name;\\n        attributes[15] = city.characteristic;\\n\\n        image = assembleSVG(components);\\n    }\\n\\n    /*\\n     * @dev Return attributes and boosts for metadata or other contract consumption\\n     */\\n    function getTraitIndexes (uint256 tokenId) public view whenRevealed returns (uint16[15] memory attributes, uint8[5] memory boosts) {\\n        uint256 dna = getDNA(tokenId);\\n        (uint16[13] memory components, uint8 totalBonus, uint8 equipmentId, bool alt) = getTraitComponents(tokenId, dna);\\n        boosts = getBoosts(dna, components[12], totalBonus, equipmentId);\\n\\n        if(alt) {\\n            attributes[0] = 1;\\n        } else {\\n            attributes[0] = 0;\\n        }\\n\\n        for (uint i = 0; i < 12; i++) {\\n            attributes[i + 1] = components[i];\\n        }\\n\\n        City memory city = Cities[components[12]];\\n\\n        attributes[13] = city.region;\\n        attributes[14] = components[12];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"flightlistSigningAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"ipfsPass\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Attributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BoostNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EquipmentBonuses\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Equipped\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IPFS_Core_Folder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IPFS_Legion_Folder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IPFS_Pass_Folder\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IPFS_URI_Prefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MetadataContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PassTypeNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RegionNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"chooseEquipment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cityId\",\"type\":\"uint256\"}],\"name\":\"cityInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"regionName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"cityName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"characteristic\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeEquipmentSelection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractState\",\"outputs\":[{\"internalType\":\"enum LostFighter.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coreRaffleIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"equipmentSelectionState\",\"outputs\":[{\"internalType\":\"enum LostFighter.EquipmentSelectionStates\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getDNA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getEquipmentOptions\",\"outputs\":[{\"internalType\":\"uint8[5]\",\"name\":\"\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTraitIndexes\",\"outputs\":[{\"internalType\":\"uint16[15]\",\"name\":\"attributes\",\"type\":\"uint16[15]\"},{\"internalType\":\"uint8[5]\",\"name\":\"boosts\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTraits\",\"outputs\":[{\"internalType\":\"string[16]\",\"name\":\"attributes\",\"type\":\"string[16]\"},{\"internalType\":\"uint8[5]\",\"name\":\"boosts\",\"type\":\"uint8[5]\"},{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"givePass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"givePasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isCore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pass\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openEquipmentSelection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"passType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentlyFreezeEquimentSelection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealSeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleOpenBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"flightlistSigningAddress\",\"type\":\"address\"}],\"name\":\"setFlightlistSigningAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ipfsURIPrefix\",\"type\":\"string\"}],\"name\":\"setIpfsURIPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metadata\",\"type\":\"address\"}],\"name\":\"setMetadataContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceWei\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsCore\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ipfsLegion\",\"type\":\"string\"}],\"name\":\"setSeedHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"traitIndex\",\"type\":\"uint256\"}],\"name\":\"traitName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pass\",\"type\":\"bytes\"}],\"name\":\"validFlightlistPass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LostFighter", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000015081629f46a33dfe0f9b9da9e2d4ffce094108d0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000002e516d62563642416f62673644696676346e4541737a663956326d69424c6b43453761506456536242464842454239000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}