{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CalR.sol\": {\r\n      \"content\": \"\\n\\n/*\\n\\n$CalR - Cal Reflections\\n\\nReflecting on the epic success of Calcium, CALR is the mirrored version of CAL, rewarding holders with juicy reflections. \\n\\nFinal tax: 4% TAX, 3% automatic $CAL reflections to all $CAL holders, 1% marketing.\\n\\nhttps://t.me/CalReflections\\n*/\\n\\n// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * Standard SafeMath, stripped down to just add/sub/mul/div\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\\n/**\\n * ERC20 standard interface.\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function name() external view returns (string memory);\\n    function getOwner() external view returns (address);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n \\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n \\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n \\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ninterface ICalReflections {\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\\n    function setShare(address shareholder, uint256 amount) external;\\n    function deposit() external payable;\\n    function process(uint256 gas) external;\\n    function gibTokens(address shareholder) external;\\n}\\n\\n\\ncontract CalReflections is ICalReflections {\\n\\n    using SafeMath for uint256;\\n    address _token;\\n\\n    address public CAL;\\n\\n    IDEXRouter router;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    address[] shareholders;\\n    mapping (address => uint256) shareholderIndexes;\\n    mapping (address => uint256) shareholderClaims;\\n    mapping (address => Share) public shares;\\n\\n    uint256 public totalShares;\\n    uint256 public totalDividends;\\n    uint256 public totalDistributed;\\n    uint256 public dividendsPerShare;\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\\n\\n    uint256 public minPeriod = 30 minutes;\\n    uint256 public minDistribution = 0 * (10 ** 9);\\n\\n    uint256 public currentIndex;\\n    bool initialized;\\n\\n    modifier initialization() {\\n        require(!initialized);\\n        _;\\n        initialized = true;\\n    }\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token); _;\\n    }\\n\\n    constructor () {\\n        _token = msg.sender;\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        CAL = 0x20561172f791f915323241E885b4f7D5187c36E1;\\n    }\\n    \\n    receive() external payable {\\n        deposit();\\n    }\\n\\n    function setDistributionCriteria(uint256 newMinPeriod, uint256 newMinDistribution) external override onlyToken {\\n        minPeriod = newMinPeriod;\\n        minDistribution = newMinDistribution;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\n\\n        if(shares[shareholder].amount > 0){\\n            distributeDividend(shareholder);\\n        }\\n\\n        if(amount > 0 && shares[shareholder].amount == 0){\\n            addShareholder(shareholder);\\n        }else if(amount == 0 && shares[shareholder].amount > 0){\\n            removeShareholder(shareholder);\\n        }\\n\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n        shares[shareholder].amount = amount;\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n    }\\n\\n    function deposit() public payable override {\\n\\n        uint256 balanceBefore = IERC20(CAL).balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = address(CAL);\\n\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amount = IERC20(CAL).balanceOf(address(this)).sub(balanceBefore);\\n        totalDividends = totalDividends.add(amount);\\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\n    }\\n    \\n    function process(uint256 gas) external override {\\n        uint256 shareholderCount = shareholders.length;\\n\\n        if(shareholderCount == 0) { return; }\\n\\n        uint256 iterations = 0;\\n        uint256 gasUsed = 0;\\n        uint256 gasLeft = gasleft();\\n\\n        while(gasUsed < gas && iterations < shareholderCount) {\\n\\n            if(currentIndex >= shareholderCount){ currentIndex = 0; }\\n\\n            if(shouldDistribute(shareholders[currentIndex])){\\n                distributeDividend(shareholders[currentIndex]);\\n            }\\n\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\n            gasLeft = gasleft();\\n            currentIndex++;\\n            iterations++;\\n        }\\n    }\\n    \\n    function shouldDistribute(address shareholder) public view returns (bool) {\\n        return shareholderClaims[shareholder] + minPeriod < block.timestamp\\n                && getUnpaidEarnings(shareholder) > minDistribution;\\n    }\\n\\n    function distributeDividend(address shareholder) internal {\\n        if(shares[shareholder].amount == 0){ return; }\\n\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n        if(amount > 0){\\n            totalDistributed = totalDistributed.add(amount);\\n            IERC20(CAL).transfer(shareholder, amount);\\n            shareholderClaims[shareholder] = block.timestamp;\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n        }\\n    }\\n    \\n    function gibTokens(address shareholder) external override onlyToken {\\n        distributeDividend(shareholder);\\n    }\\n\\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\\n        if(shares[shareholder].amount == 0){ return 0; }\\n\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n\\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\\n\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\n    }\\n\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n    }\\n\\n    function addShareholder(address shareholder) internal {\\n        shareholderIndexes[shareholder] = shareholders.length;\\n        shareholders.push(shareholder);\\n    }\\n\\n    function removeShareholder(address shareholder) internal {\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\n        shareholders.pop();\\n    }\\n}\\n\\ncontract CALR is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    address public CAL = 0x20561172f791f915323241E885b4f7D5187c36E1; //CAL CA\\n\\n    string private constant _name = \\\"CAL Reflections\\\";\\n    string private constant _symbol = \\\"CALR\\\";\\n    uint8 private constant _decimals = 18;\\n    \\n    uint256 private _totalSupply = 1000000000 * (10 ** _decimals);\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping (address => uint256) private cooldown;\\n\\n    address private WETH;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n\\n    bool public antiBot = true;\\n\\n    mapping (address => bool) private bots; \\n    mapping (address => bool) public isFeeExempt;\\n    mapping (address => bool) public isTxLimitExempt;\\n    mapping (address => bool) public isDividendExempt;\\n\\n    uint256 public launchedAt;\\n    address public lpWallet = DEAD;\\n\\n    uint256 public buyFee = 35;\\n    uint256 public sellFee = 50;\\n\\n    uint256 public toReflections = 15;\\n    uint256 public toLiquidity = 10;\\n    uint256 public toMarketing = 75;\\n\\n    uint256 public allocationSum = 100;\\n\\n    IDEXRouter public router;\\n    address public pair;\\n    address public factory;\\n    address private tokenOwner;\\n    address public devWallet = payable(0xF6fa7bf24D5c12752e582eDE532c793E31ccA542);\\n\\n    bool inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled = true;\\n    bool public tradingOpen = false;\\n    \\n    CalReflections public calReflections;\\n    uint256 public calReflectionsGas = 0;\\n\\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    uint256 public maxTx = _totalSupply.div(100);\\n    uint256 public maxWallet = _totalSupply.div(50);\\n    uint256 public swapThreshold = _totalSupply.div(400);\\n\\n    constructor () {\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n            \\n        WETH = router.WETH();\\n        \\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\\n        \\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n\\n        calReflections = new CalReflections();\\n        \\n        isFeeExempt[owner()] = true;\\n        isFeeExempt[devWallet] = true;            \\n\\n        isDividendExempt[pair] = true;\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[DEAD] = true;    \\n\\n        isTxLimitExempt[owner()] = true;\\n        isTxLimitExempt[pair] = true;\\n        isTxLimitExempt[DEAD] = true;\\n        isTxLimitExempt[devWallet] = true;  \\n\\n\\n        _balances[owner()] = _totalSupply;\\n    \\n        emit Transfer(address(0), owner(), _totalSupply);\\n    }\\n\\n    receive() external payable { }\\n\\n    \\n    //once enabled, cannot be reversed\\n    function openTrading() external onlyOwner {\\n        launchedAt = block.number;\\n        tradingOpen = true;\\n    }      \\n\\n    function changeTotalFees(uint256 newBuyFee, uint256 newSellFee) external onlyOwner {\\n\\n        buyFee = newBuyFee;\\n        sellFee = newSellFee;\\n    } \\n    \\n    function changeFeeAllocation(uint256 newRewardFee, uint256 newLpFee, uint256 newMarketingFee) external onlyOwner {\\n        toReflections = newRewardFee;\\n        toLiquidity = newLpFee;\\n        toMarketing = newMarketingFee;\\n    }\\n\\n    function changeTxLimit(uint256 newLimit) external onlyOwner {\\n        maxTx = newLimit;\\n    }\\n\\n    function changeWalletLimit(uint256 newLimit) external onlyOwner {\\n        maxWallet  = newLimit;\\n    }\\n    \\n    function changeIsFeeExempt(address holder, bool exempt) external onlyOwner {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function changeIsTxLimitExempt(address holder, bool exempt) external onlyOwner {      \\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setDevWallet(address payable newDevWallet) external onlyOwner {\\n        devWallet = payable(newDevWallet);\\n    }\\n\\n    function setOwnerWallet(address payable newOwnerWallet) external onlyOwner {\\n        tokenOwner = newOwnerWallet;\\n    }     \\n\\n    function changeSwapBackSettings(bool enableSwapBack, uint256 newSwapBackLimit) external onlyOwner {\\n        swapAndLiquifyEnabled  = enableSwapBack;\\n        swapThreshold = newSwapBackLimit;\\n    }\\n\\n    function setDistributionCriteria(uint256 newMinPeriod, uint256 newMinDistribution) external onlyOwner {\\n        calReflections.setDistributionCriteria(newMinPeriod, newMinDistribution);        \\n    }\\n\\n    function _setIsDividendExempt(address holder, bool exempt) internal {\\n        require(holder != address(this) && holder != pair);\\n        isDividendExempt[holder] = exempt;\\n        if(exempt){\\n            calReflections.setShare(holder, 0);\\n        }else{\\n            calReflections.setShare(holder, _balances[holder]);\\n        }\\n    }\\n\\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\\n        _setIsDividendExempt(holder, exempt);\\n    }\\n\\n    function changeCalReflectionsGas(uint256 newGas) external onlyOwner {\\n        calReflectionsGas = newGas;\\n    }           \\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\n    }\\n\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\n    function name() external pure override returns (string memory) { return _name; }\\n    function getOwner() external view override returns (address) { return owner(); }\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n    \\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, type(uint256).max);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        return _transfer(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        if(_allowances[sender][msg.sender] != type(uint256).max){\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transfer(sender, recipient, amount);\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        if (sender!= owner() && recipient!= owner()) require(tradingOpen, \\\"hold ur horses big guy.\\\"); //transfers disabled before tradingActive\\n        require(!bots[sender] && !bots[recipient]);\\n\\n        if(inSwapAndLiquify){ return _basicTransfer(sender, recipient, amount); }\\n\\n        require(amount <= maxTx || isTxLimitExempt[sender], \\\"tx\\\");\\n\\n        if(!isTxLimitExempt[recipient] && antiBot)\\n        {\\n            require(_balances[recipient].add(amount) <= maxWallet, \\\"wallet\\\");\\n        }\\n\\n        if(msg.sender != pair && !inSwapAndLiquify && swapAndLiquifyEnabled && _balances[address(this)] >= swapThreshold){ swapBack(); }\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        \\n        uint256 finalAmount = !isFeeExempt[sender] && !isFeeExempt[recipient] ? takeFee(sender, recipient, amount) : amount;\\n        _balances[recipient] = _balances[recipient].add(finalAmount);\\n\\n        // Dividend tracker\\n        if(!isDividendExempt[sender]) {\\n            try calReflections.setShare(sender, _balances[sender]) {} catch {}\\n        }\\n\\n        if(!isDividendExempt[recipient]) {\\n            try calReflections.setShare(recipient, _balances[recipient]) {} catch {} \\n        }\\n\\n        emit Transfer(sender, recipient, finalAmount);\\n        return true;\\n    }    \\n\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }  \\n    \\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\\n        \\n        uint256 feeApplicable = pair == recipient ? sellFee : buyFee;\\n        uint256 feeAmount = amount.mul(feeApplicable).div(100);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n    \\n    function swapTokensForEth(uint256 tokenAmount) private {\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n\\n        approve(address(this), tokenAmount);\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0,\\n            0,\\n            lpWallet,\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() internal lockTheSwap {\\n    \\n        uint256 tokenBalance = _balances[address(this)]; \\n        uint256 tokensForLiquidity = tokenBalance.mul(toLiquidity).div(100).div(2);     \\n        uint256 amountToSwap = tokenBalance.sub(tokensForLiquidity);\\n\\n        swapTokensForEth(amountToSwap);\\n\\n        uint256 totalEthBalance = address(this).balance;\\n        uint256 ethForCAL = totalEthBalance.mul(toReflections).div(100);\\n        uint256 ethForDev = totalEthBalance.mul(toMarketing).div(100);\\n        uint256 ethForLiquidity = totalEthBalance.mul(toLiquidity).div(100).div(2);\\n      \\n        if (totalEthBalance > 0){\\n            payable(devWallet).transfer(ethForDev);\\n        }\\n        \\n        try calReflections.deposit{value: ethForCAL}() {} catch {}\\n        \\n        if (tokensForLiquidity > 0){\\n            addLiquidity(tokensForLiquidity, ethForLiquidity);\\n        }\\n    }\\n\\n    function manualSwapBack() external onlyOwner {\\n        swapBack();\\n    }\\n\\n    function clearStuckEth() external onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        if(contractETHBalance > 0){          \\n            payable(devWallet).transfer(contractETHBalance);\\n        }\\n    }\\n\\n    function manualProcessGas(uint256 manualGas) external onlyOwner {\\n        calReflections.process(manualGas);\\n    }\\n\\n    function checkPendingReflections(address shareholder) external view returns (uint256) {\\n        return calReflections.getUnpaidEarnings(shareholder);\\n    }\\n\\n    function getCAL() external {\\n        calReflections.gibTokens(msg.sender);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calReflections\",\"outputs\":[{\"internalType\":\"contract CalReflections\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calReflectionsGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGas\",\"type\":\"uint256\"}],\"name\":\"changeCalReflectionsGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLpFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"}],\"name\":\"changeFeeAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"changeIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"changeIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableSwapBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"newSwapBackLimit\",\"type\":\"uint256\"}],\"name\":\"changeSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellFee\",\"type\":\"uint256\"}],\"name\":\"changeTotalFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"changeTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"changeWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"checkPendingReflections\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearStuckEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCAL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"manualGas\",\"type\":\"uint256\"}],\"name\":\"manualProcessGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newDevWallet\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwnerWallet\",\"type\":\"address\"}],\"name\":\"setOwnerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toReflections\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CALR", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}