{"SourceCode": "pragma solidity ^0.4.23;\r\n\r\n /*\r\n * Contract that is working with ERC223 tokens\r\n * https://github.com/ethereum/EIPs/issues/223\r\n */\r\n\r\n/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data containig a function signature and/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/// @title Base Token contract\r\ncontract Token {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * ERC 20\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    /*\r\n     * ERC 223\r\n     */\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/// @title Standard token contract - Standard token implementation.\r\ncontract StandardToken is Token {\r\n\r\n    /*\r\n     * Data structures\r\n     */\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != 0x0);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        // allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Read functions\r\n     */\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\n/// @title Vitalik2X Token\r\ncontract Vitalik2XToken is StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *  Token metadata\r\n     */\r\n    string constant public symbol = \"V2X\";\r\n    string constant public name = \"Vitalik2X\";\r\n    uint256 constant public decimals = 18;\r\n    uint256 constant public multiplier = 10 ** decimals;\r\n\r\n    address public owner;\r\n\r\n    uint256 public creationBlock;\r\n    uint256 public mainPotTokenBalance;\r\n    uint256 public mainPotETHBalance;\r\n\r\n    mapping (address => uint256) blockLock;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n    event DonatedTokens(address indexed donator, uint256 amount);\r\n    event DonatedETH(address indexed donator, uint256 amount);\r\n    event SoldTokensFromPot(address indexed seller, uint256 amount);\r\n    event BoughtTokensFromPot(address indexed buyer, uint256 amount);\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Function create the token and distribute to the deploying address\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        totalSupply = 10 ** decimals;\r\n        balances[msg.sender] = totalSupply;\r\n        creationBlock = block.number;\r\n\r\n        emit Transfer(0x0, msg.sender, totalSupply);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * External Functions\r\n     */\r\n    /// @dev Adds the tokens to the main Pot.\r\n    function donateTokensToMainPot(uint256 amount) external returns (bool){\r\n        require(_transfer(this, amount));\r\n        mainPotTokenBalance = mainPotTokenBalance.add(amount);\r\n        emit DonatedTokens(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    function donateETHToMainPot() external payable returns (bool){\r\n        require(msg.value > 0);\r\n        mainPotETHBalance = mainPotETHBalance.add(msg.value);\r\n        emit DonatedETH(msg.sender, msg.value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Automatically sends a proportional percent of the ETH balance from the pot for proportion of the Tokens deposited.\r\n    function sellTokensToPot(uint256 amount) external returns (bool) {\r\n        uint256 amountBeingPaid = ethSliceAmount(amount);\r\n        require(amountBeingPaid <= ethSliceCap(), \"Token amount sent is above the cap.\");\r\n        require(_transfer(this, amount));\r\n        mainPotTokenBalance = mainPotTokenBalance.add(amount);\r\n        mainPotETHBalance = mainPotETHBalance.sub(amountBeingPaid);\r\n        msg.sender.transfer(amountBeingPaid);\r\n        emit SoldTokensFromPot(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Automatically sends a proportional percent of the VTK2X token balance from the pot for proportion of the ETH deposited.\r\n    function buyTokensFromPot() external payable returns (uint256) {\r\n        require(msg.value > 0);\r\n        uint256 amountBuying = tokenSliceAmount(msg.value);\r\n        require(amountBuying <= tokenSliceCap(), \"Msg.value is above the cap.\");\r\n        require(mainPotTokenBalance >= 1 finney, \"Pot does not have enough tokens.\");\r\n        mainPotETHBalance = mainPotETHBalance.add(msg.value);\r\n        mainPotTokenBalance = mainPotTokenBalance.sub(amountBuying);\r\n        balances[address(this)] = balances[address(this)].sub(amountBuying);\r\n        balances[msg.sender] = balances[msg.sender].add(amountBuying);\r\n        emit Transfer(address(this), msg.sender, amountBuying);\r\n        emit BoughtTokensFromPot(msg.sender, amountBuying);\r\n        return amountBuying;\r\n    }\r\n\r\n    /// @dev Returns the block number the given address is locked until.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns block number the lock is released.\r\n    function blockLockOf(address _owner) external view returns (uint256) {\r\n        return blockLock[_owner];\r\n    }\r\n\r\n    /// @dev external function to retrieve ETH sent to the contract.\r\n    function withdrawETH() external onlyOwner {\r\n        owner.transfer(address(this).balance.sub(mainPotETHBalance));\r\n    }\r\n\r\n    /// @dev external function to retrieve tokens accidentally sent to the contract.\r\n    function withdrawToken(address token) external onlyOwner {\r\n        require(token != address(this));\r\n        Token erc20 = Token(token);\r\n        erc20.transfer(owner, erc20.balanceOf(this));\r\n    }\r\n\r\n    /*\r\n     * Public Functions\r\n     */\r\n    /// @dev public function to retrieve the ETH amount.\r\n    function ethSliceAmount(uint256 amountOfTokens) public view returns (uint256) {\r\n        uint256 amountBuying = mainPotETHBalance.mul(amountOfTokens).div(mainPotTokenBalance);\r\n        amountBuying = amountBuying.sub(amountBuying.mul(amountOfTokens).div(mainPotTokenBalance));\r\n        return amountBuying;\r\n    }\r\n\r\n    /// @dev public function to retrieve the max ETH slice allotted.\r\n    function ethSliceCap() public view returns (uint256) {\r\n        return mainPotETHBalance.mul(30).div(100);\r\n    }\r\n\r\n    /// @dev public function to retrieve the percentage of ETH user wants from pot.\r\n    function ethSlicePercentage(uint256 amountOfTokens) public view returns (uint256) {\r\n        uint256 amountOfTokenRecieved = ethSliceAmount(amountOfTokens);\r\n        return amountOfTokenRecieved.mul(100).div(mainPotETHBalance);\r\n    }\r\n\r\n    /// @dev public function to retrieve the current pot reward amount.\r\n    function tokenSliceAmount(uint256 amountOfETH) public view returns (uint256) {\r\n        uint256 amountBuying = mainPotTokenBalance.mul(amountOfETH).div(mainPotETHBalance);\r\n        amountBuying = amountBuying.sub(amountBuying.mul(amountOfETH).div(mainPotETHBalance));\r\n        return amountBuying;\r\n    }\r\n\r\n    /// @dev public function to retrieve the max token slice allotted.\r\n    function tokenSliceCap() public view returns (uint256) {\r\n        return mainPotTokenBalance.mul(30).div(100);\r\n    }\r\n    /// @dev public function to retrieve the percentage of ETH user wants from pot.\r\n    function tokenSlicePercentage(uint256 amountOfEth) public view returns (uint256) {\r\n        uint256 amountOfEthRecieved = tokenSliceAmount(amountOfEth);\r\n        return amountOfEthRecieved.mul(100).div(mainPotTokenBalance);\r\n    }\r\n\r\n    /// @dev public function to check the status of account's lock.\r\n    function accountLocked() public view returns (bool) {\r\n        return (block.number < blockLock[msg.sender]);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(block.number >= blockLock[msg.sender], \"Address is still locked.\");\r\n        if (_to == address(this)) {\r\n            return _vitalikize(msg.sender, _value);\r\n        } else {\r\n            return _transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\r\n    /// tokenFallback if sender is a contract.\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data to be sent to tokenFallback\r\n    /// @return Returns success of function call.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _data)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(this));\r\n        // Transfers tokens normally as per ERC20 standards\r\n        require(transfer(_to, _value));\r\n\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        // If codeLength is > 0, it means it is a contract, handle fallback\r\n        if (codeLength > 0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(block.number >= blockLock[_from], \"Address is still locked.\");\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        // Balance of sender is legit\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender`.\r\n    /// @dev Transfers sender's tokens to a given address. Returns success.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function _transfer(address _to, uint256 _value) internal returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Mints the amount of token passed and sends it to the sender\r\n    function _vitalikize(address _sender, uint256 _value) internal returns (bool) {\r\n        require(balances[_sender] >= _value, \"Owner doesnt have enough tokens.\");\r\n        uint256 calcBlockLock = (block.number - creationBlock)/5;\r\n        blockLock[_sender] = block.number + (calcBlockLock > 2600 ? calcBlockLock : 2600);\r\n        require(mint(_sender, _value), \"Minting failed\");\r\n        emit Transfer(address(0), _sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function mint(address _address, uint256 _amount) internal returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_address] = balances[_address].add(_amount);\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountOfETH\",\"type\":\"uint256\"}],\"name\":\"tokenSliceAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountOfEth\",\"type\":\"uint256\"}],\"name\":\"tokenSlicePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokensFromPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellTokensToPot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainPotETHBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donateTokensToMainPot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateETHToMainPot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethSliceCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSliceCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"blockLockOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"ethSliceAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainPotTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"ethSlicePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonatedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonatedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SoldTokensFromPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BoughtTokensFromPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Vitalik2XToken", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3c6ec689f981e0a159c5c4a017b572c146506d5c79c16f1452c65155d3e42a22"}