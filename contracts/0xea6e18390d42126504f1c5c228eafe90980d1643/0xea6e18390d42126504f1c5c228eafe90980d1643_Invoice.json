{"SourceCode": "{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.23;\\r\\n\\r\\ncontract IERC20 {\\r\\n  function totalSupply() public constant returns (uint);\\r\\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\\r\\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\\r\\n  function transfer(address to, uint tokens) public returns (bool success);\\r\\n  function approve(address spender, uint tokens) public returns (bool success);\\r\\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n}\"},\"Invoice.sol\":{\"content\":\"pragma solidity ^0.4.23;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\ncontract Invoice {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  address public owner;\\r\\n  address public quoteSigner;\\r\\n  mapping(bytes32 =\\u003e bool) public isPaid;\\r\\n\\r\\n  event PaymentAccepted(bytes32 indexed hash, address indexed tokenContract,  uint time, uint value);\\r\\n\\r\\n\\r\\n  constructor(address valueSigner) public {\\r\\n    owner = msg.sender;\\r\\n    quoteSigner = valueSigner;\\r\\n  }\\r\\n\\r\\n  function isValidPayment(\\r\\n    uint value,\\r\\n    uint gasPrice,\\r\\n    uint expiration,\\r\\n    bytes32 payload,\\r\\n    bytes32 hash,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s,\\r\\n    address tokenContract\\r\\n  ) public view returns(bool valid) {\\r\\n    bool isValid = !isPaid[payload];\\r\\n    isValid = isValid \\u0026\\u0026 block.timestamp \\u003c= expiration;\\r\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n    bytes32 ourHash = keccak256(abi.encodePacked(value, gasPrice, expiration, payload, tokenContract));\\r\\n    bytes32 payloadHash = keccak256(abi.encodePacked(prefix, ourHash));\\r\\n    isValid = isValid \\u0026\\u0026 ourHash == hash;\\r\\n    isValid = isValid \\u0026\\u0026 (ecrecover(payloadHash, v, r, s) == quoteSigner);\\r\\n    return isValid;\\r\\n  }\\r\\n\\r\\n  function validatePayment(\\r\\n    uint value,\\r\\n    uint gasPrice,\\r\\n    uint expiration,\\r\\n    bytes32 payload,\\r\\n    bytes32 hash,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s,\\r\\n    address tokenContract\\r\\n  ) public view returns(bool valid) {\\r\\n    require(isPaid[payload] == false, \\\"Already been paid\\\");\\r\\n    require(block.timestamp \\u003c= expiration, \\\"Payment is late\\\");\\r\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n    bytes32 ourHash = keccak256(abi.encodePacked(value, gasPrice, expiration, payload, tokenContract));\\r\\n    bytes32 payloadHash = keccak256(abi.encodePacked(prefix, ourHash));\\r\\n    require(ourHash == hash, \\\"Hash mismatch\\\");\\r\\n    require(ecrecover(payloadHash, v, r, s) == quoteSigner, \\\"Signature mismatch for quote\\\");\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n\\r\\n  function pay(\\r\\n    uint value,\\r\\n    uint gasPrice,\\r\\n    uint expiration,\\r\\n    bytes32 payload,\\r\\n    bytes32 hash,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s,\\r\\n    address tokenContract\\r\\n  ) public payable {\\r\\n    if(tokenContract == 0x0) {\\r\\n      require(validatePayment(msg.value, gasPrice, expiration, payload, hash, v, r, s, tokenContract), \\\"Only accept valid payments\\\");\\r\\n    } else {\\r\\n      IERC20 token = IERC20(tokenContract);\\r\\n      require(token.allowance(msg.sender, address(this)) \\u003e= value, \\\"Must have enough tokens to pay\\\");\\r\\n      require(validatePayment(value, gasPrice, expiration, payload, hash, v, r, s, tokenContract), \\\"Only accept valid payments\\\");\\r\\n      require(token.safeTransferFrom(msg.sender, address(this), value), \\\"Transfer must succeed\\\");\\r\\n    }\\r\\n    isPaid[payload] = true;\\r\\n    emit PaymentAccepted(hash, tokenContract, block.timestamp, value);\\r\\n  }\\r\\n\\r\\n  modifier isAdmin() {\\r\\n    require(msg.sender == owner, \\\"Must be the contract owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function withdraw(address tokenContract) public isAdmin {\\r\\n    if(tokenContract == 0x0) {\\r\\n      owner.transfer(address(this).balance);\\r\\n    } else {\\r\\n      IERC20 token = IERC20(tokenContract);\\r\\n      uint balance = token.balanceOf(address(this));\\r\\n      require(token.safeTransfer(owner, balance), \\\"Must succeed withdrawing tokens\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setSigner(address newQuoteSigner) public isAdmin {\\r\\n    quoteSigner = newQuoteSigner;\\r\\n  }\\r\\n  function setAdmin(address newAdmin) public isAdmin {\\r\\n    owner = newAdmin;\\r\\n  }\\r\\n}\\r\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.4.23;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n/**\\r\\n* @dev Library to perform safe calls to standard method for ERC20 tokens.\\r\\n*\\r\\n* Why Transfers: transfer methods could have a return value (bool), throw or revert for insufficient funds or\\r\\n* unathorized value.\\r\\n*\\r\\n* Why Approve: approve method could has a return value (bool) or does not accept 0 as a valid value (BNB token).\\r\\n* The common strategy used to clean approvals.\\r\\n*\\r\\n* We use the Solidity call instead of interface methods because in the case of transfer, it will fail\\r\\n* for tokens with an implementation without returning a value.\\r\\n* Since versions of Solidity 0.4.22 the EVM has a new opcode, called RETURNDATASIZE.\\r\\n* This opcode stores the size of the returned data of an external call. The code checks the size of the return value\\r\\n* after an external call and reverts the transaction in case the return data is shorter than expected\\r\\n*/\\r\\nlibrary SafeERC20 {\\r\\n    /**\\r\\n    * @dev Transfer token for a specified address\\r\\n    * @param _token erc20 The address of the ERC20 contract\\r\\n    * @param _to address The address which you want to transfer to\\r\\n    * @param _value uint256 the _value of tokens to be transferred\\r\\n    * @return bool whether the transfer was successful or not\\r\\n    */\\r\\n    function safeTransfer(IERC20 _token, address _to, uint256 _value) internal returns (bool) {\\r\\n        uint256 prevBalance = _token.balanceOf(address(this));\\r\\n\\r\\n        if (prevBalance \\u003c _value) {\\r\\n            // Insufficient funds\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        address(_token).call(\\r\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _value)\\r\\n        );\\r\\n\\r\\n        // Fail if the new balance its not equal than previous balance sub _value\\r\\n        return prevBalance - _value == _token.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer tokens from one address to another\\r\\n    * @param _token erc20 The address of the ERC20 contract\\r\\n    * @param _from address The address which you want to send tokens from\\r\\n    * @param _to address The address which you want to transfer to\\r\\n    * @param _value uint256 the _value of tokens to be transferred\\r\\n    * @return bool whether the transfer was successful or not\\r\\n    */\\r\\n    function safeTransferFrom(\\r\\n        IERC20 _token,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    ) internal returns (bool)\\r\\n    {\\r\\n        uint256 prevBalance = _token.balanceOf(_from);\\r\\n\\r\\n        if (\\r\\n          prevBalance \\u003c _value || // Insufficient funds\\r\\n          _token.allowance(_from, address(this)) \\u003c _value // Insufficient allowance\\r\\n        ) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        address(_token).call(\\r\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _value)\\r\\n        );\\r\\n\\r\\n        // Fail if the new balance its not equal than previous balance sub _value\\r\\n        return prevBalance - _value == _token.balanceOf(_from);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n   *\\r\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * @param _token erc20 The address of the ERC20 contract\\r\\n   * @param _spender The address which will spend the funds.\\r\\n   * @param _value The amount of tokens to be spent.\\r\\n   * @return bool whether the approve was successful or not\\r\\n   */\\r\\n    function safeApprove(IERC20 _token, address _spender, uint256 _value) internal returns (bool) {\\r\\n        address(_token).call(\\r\\n            abi.encodeWithSignature(\\\"approve(address,uint256)\\\",_spender, _value)\\r\\n        );\\r\\n\\r\\n        // Fail if the new allowance its not equal than _value\\r\\n        return _token.allowance(address(this), _spender) == _value;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n   * @dev Clear approval\\r\\n   * Note that if 0 is not a valid value it will be set to 1.\\r\\n   * @param _token erc20 The address of the ERC20 contract\\r\\n   * @param _spender The address which will spend the funds.\\r\\n   */\\r\\n    function clearApprove(IERC20 _token, address _spender) internal returns (bool) {\\r\\n        bool success = safeApprove(_token, _spender, 0);\\r\\n\\r\\n        if (!success) {\\r\\n            success = safeApprove(_token, _spender, 1);\\r\\n        }\\r\\n\\r\\n        return success;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"payload\",\"type\":\"bytes32\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"validatePayment\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newQuoteSigner\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"payload\",\"type\":\"bytes32\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"isValidPayment\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"payload\",\"type\":\"bytes32\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"valueSigner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PaymentAccepted\",\"type\":\"event\"}]", "ContractName": "Invoice", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005700dcde541e993d087537ecdd4f3562a53a9085", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0e97a872d8012fb3831162aeca722774bbb49760fd41fd9f4b923f4fe2c67841"}