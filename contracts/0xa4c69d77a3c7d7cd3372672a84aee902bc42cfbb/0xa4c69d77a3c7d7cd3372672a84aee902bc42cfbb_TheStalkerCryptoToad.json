{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/JSONConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// JSONConfigurator by int.art.\\n// simple JSON builder for integer and string values.\\n// Mainly built for unifying metadata traits and JS configuration.\\n\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\n\\nlibrary JSONConfigurator {\\n    struct Parameter {\\n        string jsonKey;\\n        string attributeKey;\\n        string value;\\n    }\\n\\n    // Parameter will be ignored for JSON if jsonKey is empty.\\n    // Parameter will be ignored for attributes if attributeKey is empty.\\n    function integerParam(\\n        string memory jsonKey,\\n        string memory attributeKey,\\n        uint256 value\\n    ) internal pure returns (Parameter memory) {\\n        Parameter memory parameter;\\n        parameter.jsonKey = jsonKey;\\n        parameter.attributeKey = attributeKey;\\n        parameter.value = LibString.toString(value);\\n        return parameter;\\n    }\\n\\n    // Parameter will be ignored for JSON if jsonKey is empty.\\n    // Parameter will be ignored for attributes if attributeKey is empty.\\n    function stringParam(\\n        string memory jsonKey,\\n        string memory attributeKey,\\n        string memory value\\n    ) internal pure returns (Parameter memory) {\\n        Parameter memory parameter;\\n        parameter.jsonKey = jsonKey;\\n        parameter.attributeKey = attributeKey;\\n        parameter.value = value;\\n        return parameter;\\n    }\\n\\n    // HELPERS\\n\\n    function integerJSON(\\n        string memory jsonKey,\\n        uint256 value\\n    ) internal pure returns (Parameter memory) {\\n        return integerParam(jsonKey, \\\"\\\", value);\\n    }\\n\\n    function stringJSON(\\n        string memory jsonKey,\\n        string memory value\\n    ) internal pure returns (Parameter memory) {\\n        return stringParam(jsonKey, \\\"\\\", value);\\n    }\\n\\n    function integerAttributes(\\n        string memory attributeKey,\\n        uint256 value\\n    ) internal pure returns (Parameter memory) {\\n        return integerParam(\\\"\\\", attributeKey, value);\\n    }\\n\\n    function stringAttributes(\\n        string memory attributeKey,\\n        string memory value\\n    ) internal pure returns (Parameter memory) {\\n        return stringParam(\\\"\\\", attributeKey, value);\\n    }\\n\\n    // BUILDERS\\n\\n    function buildJSON(\\n        Parameter[] memory parameters\\n    ) internal pure returns (string memory) {\\n        unchecked {\\n            string memory config = \\\"{\\\";\\n            uint256 count;\\n            for (uint256 i; i < parameters.length; i++) {\\n                Parameter memory parameter = parameters[i];\\n                if (bytes(parameter.jsonKey).length == 0) {\\n                    continue;\\n                }\\n                config = string(\\n                    abi.encodePacked(\\n                        config,\\n                        count != 0 ? ',\\\"' : '\\\"',\\n                        parameter.jsonKey,\\n                        '\\\":\\\"',\\n                        parameter.value,\\n                        '\\\"'\\n                    )\\n                );\\n                count++;\\n            }\\n            return string(abi.encodePacked(config, \\\"}\\\"));\\n        }\\n    }\\n\\n    function buildAttributes(\\n        Parameter[] memory parameters\\n    ) internal pure returns (string memory) {\\n        unchecked {\\n            string memory config = \\\"[\\\";\\n            uint256 count;\\n            for (uint256 i; i < parameters.length; i++) {\\n                Parameter memory parameter = parameters[i];\\n                if (bytes(parameter.attributeKey).length == 0) {\\n                    continue;\\n                }\\n                config = string(\\n                    abi.encodePacked(\\n                        config,\\n                        count != 0 ? \\\",\\\" : \\\"\\\",\\n                        '{\\\"trait_type\\\":\\\"',\\n                        parameter.attributeKey,\\n                        '\\\",\\\"value\\\":\\\"',\\n                        parameter.value,\\n                        '\\\"}'\\n                    )\\n                );\\n                count++;\\n            }\\n            return string(abi.encodePacked(config, \\\"]\\\"));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/TheStalkerCryptoToadzRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// the stalker by int.art\\n// a permissionless collaboration program running on EVM.\\n\\n// Original artworks by Gremplin (CrypToadz).\\n// Modified artworks are CCO licensed.\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Base64} from \\\"solady/src/utils/Base64.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {LibPRNG} from \\\"solady/src/utils/LibPRNG.sol\\\";\\n\\nimport {IScriptyBuilderV2, HTMLRequest, HTMLTagType, HTMLTag} from \\\"scripty.sol/contracts/scripty/interfaces/IScriptyBuilderV2.sol\\\";\\n\\nimport {ITheStalkerRenderer} from \\\"./../TheStalkerCommon.sol\\\";\\nimport {JSONConfigurator} from \\\"./JSONConfigurator.sol\\\";\\n\\ninterface ITheStalker {\\n    function ownerOf(uint256 tokeId) external view returns (address);\\n\\n    function tokens(\\n        uint256 tokenId\\n    ) external view returns (bytes32, address, uint256);\\n}\\n\\ninterface ICrypToadzChained {\\n    function imageURI(uint256 tokenId) external view returns (string calldata);\\n}\\n\\ninterface IThePixelsInc {\\n    function tokensOfOwner(\\n        address owner\\n    ) external view returns (uint256[] memory);\\n}\\n\\ncontract TheStalkerCryptoToadzRenderer is Ownable, ITheStalkerRenderer {\\n    ITheStalker public immutable theStalker;\\n    IScriptyBuilderV2 public immutable scriptyBuilder;\\n    address public immutable scriptyETHFSAddress;\\n    ICrypToadzChained public immutable crypToadzChained;\\n    IThePixelsInc public immutable thePixelsInc;\\n    ITheStalkerRenderer public defaultRenderer;\\n\\n    mapping(uint256 => bool) public blockedTokenIds;\\n    error BlockedTokenId();\\n\\n    constructor(\\n        ITheStalker _theStalker,\\n        IScriptyBuilderV2 _scriptyBuilder,\\n        address _scriptyETHFSAddress,\\n        ICrypToadzChained _crypToadzChained,\\n        IThePixelsInc _thePixelsInc,\\n        ITheStalkerRenderer _defaultRenderer\\n    ) Ownable(msg.sender) {\\n        theStalker = _theStalker;\\n        scriptyBuilder = _scriptyBuilder;\\n        scriptyETHFSAddress = _scriptyETHFSAddress;\\n        crypToadzChained = _crypToadzChained;\\n        thePixelsInc = _thePixelsInc;\\n        defaultRenderer = _defaultRenderer;\\n    }\\n\\n    // CONTRACT OWNER\\n\\n    function updateBlockedTokenIds(\\n        uint256 targetTokenId,\\n        bool isBlocked\\n    ) public onlyOwner {\\n        blockedTokenIds[targetTokenId] = isBlocked;\\n        emit BlockedTokenIdUpdate(targetTokenId, isBlocked);\\n    }\\n\\n    function updateDefaultRenderer(\\n        ITheStalkerRenderer _defaultRenderer\\n    ) public onlyOwner {\\n        defaultRenderer = _defaultRenderer;\\n        emit DefaultRendererUpdate(_defaultRenderer);\\n    }\\n\\n    // PUBLIC\\n\\n    function canUpdateToken(\\n        address /*sender*/,\\n        uint256 /*tokenId*/,\\n        uint256 targetTokenId\\n    ) public view override returns (bool) {\\n        return !blockedTokenIds[targetTokenId];\\n    }\\n\\n    function isTokenRenderable(\\n        uint256 /*tokenId*/,\\n        uint256 targetTokenId\\n    ) public view override returns (bool) {\\n        return !blockedTokenIds[targetTokenId];\\n    }\\n\\n    function tokenHTML(\\n        uint256 tokenId,\\n        uint256 targetTokenId\\n    ) public view override returns (string memory) {\\n        if (blockedTokenIds[targetTokenId]) {\\n            return defaultRenderer.tokenHTML(tokenId, targetTokenId);\\n        }\\n\\n        (string memory original, ) = generateModifiedCrypToadzSVG(\\n            targetTokenId\\n        );\\n\\n        JSONConfigurator.Parameter[]\\n            memory artworkParams = artworkConfiguration(\\n                tokenId,\\n                targetTokenId,\\n                original\\n            );\\n\\n        return tokenHTMLWithCrypToadzImage(artworkParams);\\n    }\\n\\n    function tokenImage(\\n        uint256 tokenId,\\n        uint256 targetTokenId\\n    ) public view override returns (string memory) {\\n        if (blockedTokenIds[targetTokenId]) {\\n            return defaultRenderer.tokenImage(tokenId, targetTokenId);\\n        }\\n        (, string memory modified) = generateModifiedCrypToadzSVG(\\n            targetTokenId\\n        );\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/svg+xml;base64,\\\",\\n                    Base64.encode(bytes(modified))\\n                )\\n            );\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId,\\n        uint256 targetTokenId\\n    ) public view override returns (string memory) {\\n        if (blockedTokenIds[targetTokenId]) {\\n            return defaultRenderer.tokenURI(tokenId, targetTokenId);\\n        }\\n\\n        (\\n            string memory original,\\n            string memory modified\\n        ) = generateModifiedCrypToadzSVG(targetTokenId);\\n\\n        JSONConfigurator.Parameter[]\\n            memory artworkParams = artworkConfiguration(\\n                tokenId,\\n                targetTokenId,\\n                original\\n            );\\n\\n        bytes memory metadata = abi.encodePacked(\\n            '{\\\"name\\\":\\\"the stalker #',\\n            LibString.toString(tokenId),\\n            '\\\", \\\"description\\\":\\\"a permissionless collaboration program running on EVM - int.art x Gremplin - Original artwork by Gremplin (CrypToadz).\\\",\\\"animation_url\\\":\\\"',\\n            tokenHTMLWithCrypToadzImage(artworkParams),\\n            '\\\",\\\"image\\\":\\\"',\\n            abi.encodePacked(\\n                \\\"data:image/svg+xml;base64,\\\",\\n                Base64.encode(bytes(modified))\\n            ),\\n            '\\\",\\\"attributes\\\":',\\n            JSONConfigurator.buildAttributes(artworkParams),\\n            \\\"}\\\"\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(metadata)\\n                )\\n            );\\n    }\\n\\n    // Modifying a little bit to make it stand out from original\\n    function generateModifiedCrypToadzSVG(\\n        uint256 targetTokenId\\n    ) public view returns (string memory, string memory) {\\n        if (blockedTokenIds[targetTokenId]) {\\n            revert BlockedTokenId();\\n        }\\n\\n        string memory crypToadzImage = crypToadzChained.imageURI(targetTokenId);\\n\\n        string\\n            memory svgModified = '<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xhtml=\\\"http://www.w3.org/1999/xhtml\\\" viewBox=\\\"0 0 100 100\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"100%\\\" height=\\\"100%\\\" style=\\\"image-rendering:pixelated;image-rendering:-moz-crisp-edges;-ms-interpolation-mode:nearest-neighbor;\\\"><g id=\\\"DUDE\\\"><style type=\\\"text/css\\\">@keyframes shakeAnimation{0%,30%{transform: translate(0.3%, 0.5%) scale(1.1, 1.1);}60%,100% {transform: translate(-0.7%, -0.1%) scale(1.1, 1.1);}}#DUDE {animation: shakeAnimation 0.2s infinite;transform-origin: center;}</style><foreignObject x=\\\"0\\\" y=\\\"0\\\" width=\\\"100\\\" height=\\\"100\\\"><xhtml:img style=\\\"width:100%;height:100%\\\" src=\\\"';\\n        svgModified = LibString.concat(svgModified, crypToadzImage);\\n        svgModified = LibString.concat(\\n            svgModified,\\n            '\\\"/></foreignObject></g></svg>'\\n        );\\n        return (crypToadzImage, svgModified);\\n    }\\n\\n    function tokenHTMLWithCrypToadzImage(\\n        JSONConfigurator.Parameter[] memory artworkParams\\n    ) public view virtual returns (string memory) {\\n        HTMLTag[] memory headTags = new HTMLTag[](1);\\n        headTags[0].name = \\\"fullSizeCanvas.css\\\";\\n        headTags[0]\\n            .tagOpen = '<link rel=\\\"stylesheet\\\" href=\\\"data:text/css;base64,';\\n        headTags[0].tagClose = '\\\">';\\n        headTags[0].contractAddress = scriptyETHFSAddress;\\n\\n        HTMLTag[] memory bodyTags = new HTMLTag[](2);\\n        bodyTags[0].name = \\\"thestalkerCrypToadz.js\\\";\\n        bodyTags[0].contractAddress = scriptyETHFSAddress;\\n        bodyTags[0].tagType = HTMLTagType.scriptBase64DataURI;\\n\\n        bodyTags[1].tagContent = abi.encodePacked(\\n            \\\"const config = \\\",\\n            JSONConfigurator.buildJSON(artworkParams),\\n            \\\";thestalkerCrypToadz(config)\\\"\\n        );\\n        bodyTags[1].tagType = HTMLTagType.script;\\n\\n        HTMLRequest memory htmlRequest;\\n        htmlRequest.headTags = headTags;\\n        htmlRequest.bodyTags = bodyTags;\\n\\n        return scriptyBuilder.getEncodedHTMLString(htmlRequest);\\n    }\\n\\n    function artworkConfiguration(\\n        uint256 tokenId,\\n        uint256 targetTokenId,\\n        string memory crypToadzImageURI\\n    ) public view returns (JSONConfigurator.Parameter[] memory) {\\n        (bytes32 seed, , ) = theStalker.tokens(tokenId);\\n        address tokenOwner = theStalker.ownerOf(tokenId);\\n\\n        LibPRNG.PRNG memory random;\\n        LibPRNG.seed(random, uint256(seed));\\n\\n        JSONConfigurator.Parameter[]\\n            memory parameters = new JSONConfigurator.Parameter[](7);\\n        parameters[0] = JSONConfigurator.integerParam(\\n            \\\"speed\\\",\\n            \\\"CrypToadz - Speed\\\",\\n            LibPRNG.uniform(random, 11)\\n        );\\n\\n        parameters[1] = JSONConfigurator.integerParam(\\n            \\\"intensity\\\",\\n            \\\"CrypToadz - Intensity\\\",\\n            LibPRNG.uniform(random, 121)\\n        );\\n\\n        parameters[2] = JSONConfigurator.integerParam(\\n            \\\"backgroundFilter\\\",\\n            \\\"CrypToadz - Background Filter\\\",\\n            LibPRNG.uniform(random, 11)\\n        );\\n\\n        if (thePixelsInc.tokensOfOwner(tokenOwner).length > 0) {\\n            parameters[3] = JSONConfigurator.integerParam(\\n                \\\"distort\\\",\\n                \\\"CrypToadz - Distort\\\",\\n                1\\n            );\\n        } else {\\n            parameters[3] = JSONConfigurator.integerParam(\\n                \\\"distort\\\",\\n                \\\"CrypToadz - Distort\\\",\\n                0\\n            );\\n        }\\n\\n        parameters[4] = JSONConfigurator.stringJSON(\\\"data\\\", crypToadzImageURI);\\n\\n        parameters[5] = JSONConfigurator.stringAttributes(\\n            \\\"Collection\\\",\\n            \\\"CrypToadz\\\"\\n        );\\n\\n        parameters[6] = JSONConfigurator.integerAttributes(\\n            \\\"Stalked Token ID\\\",\\n            targetTokenId\\n        );\\n\\n        return parameters;\\n    }\\n\\n    // EVENTS\\n\\n    event BlockedTokenIdUpdate(uint256 _tokenId, bool _isBlocked);\\n    event DefaultRendererUpdate(ITheStalkerRenderer _defaultRenderer);\\n}\\n\"\r\n    },\r\n    \"contracts/TheStalkerCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// the stalker by int.art\\n// a permissionless collaboration program running on EVM.\\n\\ninterface ITheStalkerRenderer {\\n    function canUpdateToken(\\n        address sender,\\n        uint256 tokenId,\\n        uint256 targetTokenId\\n    ) external view returns (bool);\\n\\n    function isTokenRenderable(\\n        uint256 tokenId,\\n        uint256 targetTokenId\\n    ) external view returns (bool);\\n\\n    function tokenHTML(\\n        uint256 tokenId,\\n        uint256 targetTokenid\\n    ) external view returns (string memory);\\n\\n    function tokenImage(\\n        uint256 tokenId,\\n        uint256 targetTokenid\\n    ) external view returns (string memory);\\n\\n    function tokenURI(\\n        uint256 tokenId,\\n        uint256 targetTokenid\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/core/ScriptyCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    CORE    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591//\\n///////////////////////////////////////////////////////////\\n\\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \\\"./ScriptyStructs.sol\\\";\\nimport {DynamicBuffer} from \\\"./../utils/DynamicBuffer.sol\\\";\\nimport {IScriptyStorage} from \\\"./../interfaces/IScriptyStorage.sol\\\";\\nimport {IContractScript} from \\\"./../interfaces/IContractScript.sol\\\";\\n\\ncontract ScriptyCore {\\n    using DynamicBuffer for bytes;\\n\\n    // =============================================================\\n    //                        TAG CONSTANTS\\n    // =============================================================\\n\\n    // data:text/html;base64,\\n    // raw\\n    // 22 bytes\\n    bytes public constant DATA_HTML_BASE64_URI_RAW = \\\"data:text/html;base64,\\\";\\n    // url encoded\\n    // 21 bytes\\n    bytes public constant DATA_HTML_URL_SAFE = \\\"data%3Atext%2Fhtml%2C\\\";\\n\\n    // <html>,\\n    // raw\\n    // 6 bytes\\n    bytes public constant HTML_OPEN_RAW = \\\"<html>\\\";\\n    // url encoded\\n    // 10 bytes\\n    bytes public constant HTML_OPEN_URL_SAFE = \\\"%3Chtml%3E\\\";\\n\\n    // <head>,\\n    // raw\\n    // 6 bytes\\n    bytes public constant HEAD_OPEN_RAW = \\\"<head>\\\";\\n    // url encoded\\n    // 10 bytes\\n    bytes public constant HEAD_OPEN_URL_SAFE = \\\"%3Chead%3E\\\";\\n\\n    // </head>,\\n    // raw\\n    // 7 bytes\\n    bytes public constant HEAD_CLOSE_RAW = \\\"</head>\\\";\\n    // url encoded\\n    // 13 bytes\\n    bytes public constant HEAD_CLOSE_URL_SAFE = \\\"%3C%2Fhead%3E\\\";\\n\\n    // <body>\\n    // 6 bytes\\n    bytes public constant BODY_OPEN_RAW = \\\"<body>\\\";\\n    // url encoded\\n    // 10 bytes\\n    bytes public constant BODY_OPEN_URL_SAFE = \\\"%3Cbody%3E\\\";\\n\\n    // </body></html>\\n    // 14 bytes\\n    bytes public constant HTML_BODY_CLOSED_RAW = \\\"</body></html>\\\";\\n    // 26 bytes\\n    bytes public constant HTML_BODY_CLOSED_URL_SAFE =\\n        \\\"%3C%2Fbody%3E%3C%2Fhtml%3E\\\";\\n\\n    // [RAW]\\n    // HTML_OPEN + HEAD_OPEN + HEAD_CLOSE + BODY_OPEN + HTML_BODY_CLOSED\\n    uint256 public constant URLS_RAW_BYTES = 39;\\n\\n    // [URL_SAFE]\\n    // DATA_HTML_URL_SAFE + HTML_OPEN + HEAD_OPEN + HEAD_CLOSE + BODY_OPEN + HTML_BODY_CLOSED\\n    uint256 public constant URLS_SAFE_BYTES = 90;\\n\\n    // [RAW]\\n    // HTML_OPEN + HTML_CLOSE\\n    uint256 public constant HTML_RAW_BYTES = 13;\\n\\n    // [RAW]\\n    // HEAD_OPEN + HEAD_CLOSE\\n    uint256 public constant HEAD_RAW_BYTES = 13;\\n\\n    // [RAW]\\n    // BODY_OPEN + BODY_CLOSE\\n    uint256 public constant BODY_RAW_BYTES = 13;\\n\\n    // All raw\\n    // HTML_RAW_BYTES + HEAD_RAW_BYTES + BODY_RAW_BYTES\\n    uint256 public constant RAW_BYTES = 39;\\n\\n    // [URL_SAFE]\\n    // HTML_OPEN + HTML_CLOSE\\n    uint256 public constant HTML_URL_SAFE_BYTES = 23;\\n\\n    // [URL_SAFE]\\n    // HEAD_OPEN + HEAD_CLOSE\\n    uint256 public constant HEAD_URL_SAFE_BYTES = 23;\\n\\n    // [URL_SAFE]\\n    // BODY_OPEN + BODY_CLOSE\\n    uint256 public constant BODY_SAFE_BYTES = 23;\\n\\n    // All url safe\\n    // HTML_URL_SAFE_BYTES + HEAD_URL_SAFE_BYTES + BODY_URL_SAFE_BYTES\\n    // %3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\\n    uint256 public constant URL_SAFE_BYTES = 69;\\n\\n    // data:text/html;base64,\\n    uint256 public constant HTML_BASE64_DATA_URI_BYTES = 22;\\n\\n    // =============================================================\\n    //                    TAG OPEN CLOSE TEMPLATES\\n    // =============================================================\\n\\n    /**\\n     * @notice Grab tag open and close depending on tag type\\n     * @dev\\n     *      tagType: 0/HTMLTagType.useTagOpenAndClose or any other:\\n     *          [tagOpen][CONTENT][tagClose]\\n     *\\n     *      tagType: 1/HTMLTagType.script:\\n     *          <script>[SCRIPT]</script>\\n     *\\n     *      tagType: 2/HTMLTagType.scriptBase64DataURI:\\n     *          <script src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      tagType: 3/HTMLTagType.scriptGZIPBase64DataURI:\\n     *          <script type=\\\"text/javascript+gzip\\\" src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      tagType: 4/HTMLTagType.scriptPNGBase64DataURI\\n     *          <script type=\\\"text/javascript+png\\\" name=\\\"[NAME]\\\" src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      [IMPORTANT NOTE]: The tags `text/javascript+gzip` and `text/javascript+png` are used to identify scripts\\n     *      during decompression\\n     *\\n     * @param htmlTag - HTMLTag data for code\\n     * @return (tagOpen, tagClose) - Tag open and close as a tuple\\n     */\\n    function tagOpenCloseForHTMLTag(\\n        HTMLTag memory htmlTag\\n    ) public pure returns (bytes memory, bytes memory) {\\n        if (htmlTag.tagType == HTMLTagType.script) {\\n            return (\\\"<script>\\\", \\\"</script>\\\");\\n        } else if (htmlTag.tagType == HTMLTagType.scriptBase64DataURI) {\\n            return ('<script src=\\\"data:text/javascript;base64,', '\\\"></script>');\\n        } else if (htmlTag.tagType == HTMLTagType.scriptGZIPBase64DataURI) {\\n            return (\\n                '<script type=\\\"text/javascript+gzip\\\" src=\\\"data:text/javascript;base64,',\\n                '\\\"></script>'\\n            );\\n        } else if (htmlTag.tagType == HTMLTagType.scriptPNGBase64DataURI) {\\n            return (\\n                '<script type=\\\"text/javascript+png\\\" src=\\\"data:text/javascript;base64,',\\n                '\\\"></script>'\\n            );\\n        }\\n        return (htmlTag.tagOpen, htmlTag.tagClose);\\n    }\\n\\n    /**\\n     * @notice Grab URL safe tag open and close depending on tag type\\n     * @dev\\n     *      tagType: 0/HTMLTagType.useTagOpenAndClose or any other:\\n     *          [tagOpen][scriptContent or scriptFromContract][tagClose]\\n     *\\n     *      tagType: 1/HTMLTagType.script:\\n     *      tagType: 2/HTMLTagType.scriptBase64DataURI:\\n     *          <script src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      tagType: 3/HTMLTagType.scriptGZIPBase64DataURI:\\n     *          <script type=\\\"text/javascript+gzip\\\" src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      tagType: 4/HTMLTagType.scriptPNGBase64DataURI\\n     *          <script type=\\\"text/javascript+png\\\" name=\\\"[NAME]\\\" src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      [IMPORTANT NOTE]: The tags `text/javascript+gzip` and `text/javascript+png` are used to identify scripts\\n     *      during decompression\\n     *\\n     * @param htmlTag - HTMLTag data for code\\n     * @return (tagOpen, tagClose) - Tag open and close as a tuple\\n     */\\n    function tagOpenCloseForHTMLTagURLSafe(\\n        HTMLTag memory htmlTag\\n    ) public pure returns (bytes memory, bytes memory) {\\n        if (\\n            htmlTag.tagType == HTMLTagType.script ||\\n            htmlTag.tagType == HTMLTagType.scriptBase64DataURI\\n        ) {\\n            // <script src=\\\"data:text/javascript;base64,\\n            // \\\"></script>\\n            return (\\n                \\\"%253Cscript%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\\\",\\n                \\\"%2522%253E%253C%252Fscript%253E\\\"\\n            );\\n        } else if (htmlTag.tagType == HTMLTagType.scriptGZIPBase64DataURI) {\\n            // <script type=\\\"text/javascript+gzip\\\" src=\\\"data:text/javascript;base64,\\n            // \\\"></script>\\n            return (\\n                \\\"%253Cscript%2520type%253D%2522text%252Fjavascript%252Bgzip%2522%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\\\",\\n                \\\"%2522%253E%253C%252Fscript%253E\\\"\\n            );\\n        } else if (htmlTag.tagType == HTMLTagType.scriptPNGBase64DataURI) {\\n            // <script type=\\\"text/javascript+png\\\" src=\\\"data:text/javascript;base64,\\n            // \\\"></script>\\n            return (\\n                \\\"%253Cscript%2520type%253D%2522text%252Fjavascript%252Bpng%2522%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\\\",\\n                \\\"%2522%253E%253C%252Fscript%253E\\\"\\n            );\\n        }\\n        return (htmlTag.tagOpen, htmlTag.tagClose);\\n    }\\n\\n    // =============================================================\\n    //                      TAG CONTENT FETCHER\\n    // =============================================================\\n\\n    /**\\n     * @notice Grabs requested tag content from storage\\n     * @dev\\n     *      If given HTMLTag contains non empty tagContent\\n     *      this method will return tagContent. Otherwise, \\n     *      method will fetch it from the given storage \\n     *      contract\\n     *\\n     * @param htmlTag - HTMLTag\\n     */\\n    function fetchTagContent(\\n        HTMLTag memory htmlTag\\n    ) public view returns (bytes memory) {\\n        if (htmlTag.tagContent.length > 0) {\\n            return htmlTag.tagContent;\\n        }\\n        return\\n            IContractScript(htmlTag.contractAddress).getScript(\\n                htmlTag.name,\\n                htmlTag.contractData\\n            );\\n    }\\n\\n    // =============================================================\\n    //                        SIZE OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @notice Calculate the buffer size post base64 encoding\\n     * @param value - Starting buffer size\\n     * @return Final buffer size as uint256\\n     */\\n    function sizeForBase64Encoding(\\n        uint256 value\\n    ) public pure returns (uint256) {\\n        unchecked {\\n            return 4 * ((value + 2) / 3);\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds the required tag open/close and calculates buffer size of tags\\n     * @dev Effectively multiple functions bundled into one as this saves gas\\n     * @param htmlTags - Array of HTMLTag\\n     * @param isURLSafe - Bool to handle tag content/open/close encoding\\n     * @return Total buffersize of updated HTMLTags\\n     */\\n    function _enrichHTMLTags(\\n        HTMLTag[] memory htmlTags,\\n        bool isURLSafe\\n    ) internal view returns (uint256) {\\n        if (htmlTags.length == 0) {\\n            return 0;\\n        }\\n\\n        bytes memory tagOpen;\\n        bytes memory tagClose;\\n        bytes memory tagContent;\\n\\n        uint256 totalSize;\\n        uint256 length = htmlTags.length;\\n        uint256 i;\\n\\n        unchecked {\\n            do {\\n                tagContent = fetchTagContent(htmlTags[i]);\\n                htmlTags[i].tagContent = tagContent;\\n\\n                if (isURLSafe && htmlTags[i].tagType == HTMLTagType.script) {\\n                    totalSize += sizeForBase64Encoding(tagContent.length);\\n                } else {\\n                    totalSize += tagContent.length;\\n                }\\n\\n                if (isURLSafe) {\\n                    (tagOpen, tagClose) = tagOpenCloseForHTMLTagURLSafe(\\n                        htmlTags[i]\\n                    );\\n                } else {\\n                    (tagOpen, tagClose) = tagOpenCloseForHTMLTag(htmlTags[i]);\\n                }\\n\\n                htmlTags[i].tagOpen = tagOpen;\\n                htmlTags[i].tagClose = tagClose;\\n\\n                totalSize += tagOpen.length;\\n                totalSize += tagClose.length;\\n            } while (++i < length);\\n        }\\n        return totalSize;\\n    }\\n\\n    // =============================================================\\n    //                     HTML CONCATENATION\\n    // =============================================================\\n\\n    /**\\n     * @notice Append tags to the html buffer for tags\\n     * @param htmlFile - bytes buffer\\n     * @param htmlTags - Tags being added to buffer\\n     * @param encodeTagContent - Bool to handle tag content encoding\\n     */\\n    function _appendHTMLTags(\\n        bytes memory htmlFile,\\n        HTMLTag[] memory htmlTags,\\n        bool encodeTagContent\\n    ) internal pure {\\n        uint256 i;\\n        unchecked {\\n            do {\\n                _appendHTMLTag(\\n                    htmlFile,\\n                    htmlTags[i],\\n                    encodeTagContent\\n                );\\n            } while (++i < htmlTags.length);\\n        }\\n    }\\n\\n    /**\\n     * @notice Append tag to the html buffer\\n     * @param htmlFile - bytes buffer\\n     * @param htmlTag - Request being added to buffer\\n     * @param encodeTagContent - Bool to handle tag content encoding\\n     */\\n    function _appendHTMLTag(\\n        bytes memory htmlFile,\\n        HTMLTag memory htmlTag,\\n        bool encodeTagContent\\n    ) internal pure {\\n        htmlFile.appendSafe(htmlTag.tagOpen);\\n        if (encodeTagContent) {\\n            htmlFile.appendSafeBase64(htmlTag.tagContent, false, false);\\n        } else {\\n            htmlFile.appendSafe(htmlTag.tagContent);\\n        }\\n        htmlFile.appendSafe(htmlTag.tagClose);\\n    }\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/core/ScriptyStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n//\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    REQUESTS    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591//\\n///////////////////////////////////////////////////////////\\n\\nstruct HTMLRequest {\\n    HTMLTag[] headTags;\\n    HTMLTag[] bodyTags;\\n}\\n\\nenum HTMLTagType {\\n    useTagOpenAndClose,\\n    script,\\n    scriptBase64DataURI,\\n    scriptGZIPBase64DataURI,\\n    scriptPNGBase64DataURI\\n}\\n\\nstruct HTMLTag {\\n    string name;\\n    address contractAddress;\\n    bytes contractData;\\n    HTMLTagType tagType;\\n    bytes tagOpen;\\n    bytes tagClose;\\n    bytes tagContent;\\n}\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/interfaces/IContractScript.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\ninterface IContractScript {\\n    // =============================================================\\n    //                            GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice Get the full script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param data - Arbitrary data to be passed to storage\\n     * @return script - Full script from merged chunks\\n     */\\n    function getScript(string calldata name, bytes memory data)\\n        external\\n        view\\n        returns (bytes memory script);\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/interfaces/IScriptyBuilderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\n/**\\n  @title A generic HTML builder that fetches and assembles given JS requests.\\n  @author @0xthedude\\n  @author @xtremetom\\n\\n  Special thanks to @cxkoda and @frolic\\n*/\\n\\nimport \\\"./IScriptyHTML.sol\\\";\\nimport \\\"./IScriptyHTMLURLSafe.sol\\\";\\n\\ninterface IScriptyBuilderV2 is IScriptyHTML, IScriptyHTMLURLSafe {}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/interfaces/IScriptyHTML.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \\\"./../core/ScriptyCore.sol\\\";\\n\\ninterface IScriptyHTML {\\n    // =============================================================\\n    //                      RAW HTML GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice  Get HTML with requested head tags and body tags\\n     * @dev Your HTML is returned in the following format:\\n     *      <html>\\n     *          <head>\\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\\n     *              ...\\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\\n     *          </head>\\n     *          <body>\\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\\n     *              ...\\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\\n     *          </body>\\n     *      </html>\\n     * @param htmlRequest - HTMLRequest\\n     * @return Full HTML with head and body tags\\n     */\\n    function getHTML(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (bytes memory);\\n\\n    // =============================================================\\n    //                      ENCODED HTML GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice Get {getHTML} and base64 encode it\\n     * @param htmlRequest - HTMLRequest\\n     * @return Full HTML with head and script tags, base64 encoded\\n     */\\n    function getEncodedHTML(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (bytes memory);\\n\\n    // =============================================================\\n    //                      STRING UTILITIES\\n    // =============================================================\\n\\n    /**\\n     * @notice Convert {getHTML} output to a string\\n     * @param htmlRequest - HTMLRequest\\n     * @return {getHTMLWrapped} as a string\\n     */\\n    function getHTMLString(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (string memory);\\n\\n    /**\\n     * @notice Convert {getEncodedHTML} output to a string\\n     * @param htmlRequest - HTMLRequest\\n     * @return {getEncodedHTML} as a string\\n     */\\n    function getEncodedHTMLString(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/interfaces/IScriptyHTMLURLSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \\\"./../core/ScriptyCore.sol\\\";\\n\\ninterface IScriptyHTMLURLSafe {\\n    // =============================================================\\n    //                      RAW HTML GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice  Get URL safe HTML with requested head tags and body tags\\n     * @dev Any tags with tagType = 1/script are converted to base64 and wrapped\\n     *      with <script src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      [WARNING]: Large non-base64 libraries that need base64 encoding\\n     *      carry a high risk of causing a gas out. Highly advised the use\\n     *      of base64 encoded scripts where possible\\n     *\\n     *      Your HTML is returned in the following format:\\n     *\\n     *      <html>\\n     *          <head>\\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\\n     *              ...\\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\\n     *          </head>\\n     *          <body>\\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\\n     *              ...\\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\\n     *          </body>\\n     *      </html>\\n     * @param htmlRequest - HTMLRequest\\n     * @return Full HTML with head and body tags\\n     */\\n    function getHTMLURLSafe(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (bytes memory);\\n\\n    // =============================================================\\n    //                      STRING UTILITIES\\n    // =============================================================\\n\\n    /**\\n     * @notice Convert {getHTMLURLSafe} output to a string\\n     * @param htmlRequest - HTMLRequest\\n     * @return {getHTMLURLSafe} as a string\\n     */\\n    function getHTMLURLSafeString(\\n        HTMLRequest memory htmlRequest\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/interfaces/IScriptyStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\ninterface IScriptyStorage {\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct Script {\\n        bool isVerified;\\n        bool isFrozen;\\n        address owner;\\n        uint256 size;\\n        bytes details;\\n        address[] chunks;\\n    }\\n\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @notice Error for, The Script you are trying to create already exists\\n     */\\n    error ScriptExists();\\n\\n    /**\\n     * @notice Error for, You dont have permissions to perform this action\\n     */\\n    error NotScriptOwner();\\n\\n    /**\\n     * @notice Error for, The Script you are trying to edit is frozen\\n     */\\n    error ScriptIsFrozen(string name);\\n\\n    // =============================================================\\n    //                            EVENTS\\n    // =============================================================\\n\\n    /**\\n     * @notice Event for, Successful freezing of a script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     */\\n    event ScriptFrozen(string indexed name);\\n\\n    /**\\n     * @notice Event for, Successful update of script verification status\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param isVerified - Verification status of the script\\n     */\\n    event ScriptVerificationUpdated(string indexed name, bool isVerified);\\n\\n    /**\\n     * @notice Event for, Successful creation of a script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param details - Custom details of the script\\n     */\\n    event ScriptCreated(string indexed name, bytes details);\\n\\n    /**\\n     * @notice Event for, Successful addition of script chunk\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param size - Bytes size of the chunk\\n     */\\n    event ChunkStored(string indexed name, uint256 size);\\n\\n    /**\\n     * @notice Event for, Successful update of custom details\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param details - Custom details of the script\\n     */\\n    event ScriptDetailsUpdated(string indexed name, bytes details);\\n\\n    // =============================================================\\n    //                      MANAGEMENT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @notice Create a new script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param details - Any details the owner wishes to store about the script\\n     *\\n     * Emits an {ScriptCreated} event.\\n     */\\n    function createScript(string calldata name, bytes calldata details)\\n        external;\\n\\n    /**\\n     * @notice Add a code chunk to the script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param chunk - Next sequential code chunk\\n     *\\n     * Emits an {ChunkStored} event.\\n     */\\n    function addChunkToScript(string calldata name, bytes calldata chunk)\\n        external;\\n\\n    /**\\n     * @notice Edit the script details\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param details - Any details the owner wishes to store about the script\\n     *\\n     * Emits an {ScriptDetailsUpdated} event.\\n     */\\n    function updateDetails(string calldata name, bytes calldata details)\\n        external;\\n\\n    /**\\n     * @notice Update the verification status of the script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param isVerified - The verification status\\n     *\\n     * Emits an {ScriptVerificationUpdated} event.\\n     */\\n    function updateScriptVerification(string calldata name, bool isVerified)\\n        external;\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/utils/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\n\\npragma solidity >=0.8.0;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\\n/// @notice This library is used to allocate a big amount of container memory\\n//          which will be subsequently filled without needing to reallocate\\n///         memory.\\n/// @dev First, allocate memory.\\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\\n///      bounds checking is required.\\nlibrary DynamicBuffer {\\n    /// @notice Allocates container space for the DynamicBuffer\\n    /// @param capacity_ The intended max amount of bytes in the buffer\\n    /// @return buffer The memory location of the buffer\\n    /// @dev Allocates `capacity_ + 0x60` bytes of space\\n    ///      The buffer array starts at the first container data position,\\n    ///      (i.e. `buffer = container + 0x20`)\\n    function allocate(uint256 capacity_)\\n        internal\\n        pure\\n        returns (bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            let container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                // Add 32 bytes safety space for 32B chunked copy\\n                let size := add(capacity_, 0x60)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity_, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Does not perform out-of-bound checks (container capacity)\\n    ///      for efficiency.\\n    function appendUnchecked(bytes memory buffer, bytes memory data)\\n        internal\\n        pure\\n    {\\n        assembly {\\n            let length := mload(data)\\n            for {\\n                data := add(data, 0x20)\\n                let dataEnd := add(data, length)\\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\\n            } lt(data, dataEnd) {\\n                data := add(data, 0x20)\\n                copyTo := add(copyTo, 0x20)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length, and have allocated an\\n                // additional word to avoid buffer overflow.\\n                mstore(copyTo, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer, add(mload(buffer), length))\\n        }\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\\n        checkOverflow(buffer, data.length);\\n        appendUnchecked(buffer, data);\\n    }\\n\\n    /// @notice Appends data encoded as Base64 to buffer.\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\\n    function appendSafeBase64(\\n        bytes memory buffer,\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure {\\n        uint256 dataLength = data.length;\\n\\n        if (data.length == 0) {\\n            return;\\n        }\\n\\n        uint256 encodedLength;\\n        uint256 r;\\n        assembly {\\n            // For each 3 bytes block, we will have 4 bytes in the base64\\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n            r := mod(dataLength, 3)\\n            if noPadding {\\n                // if r == 0 => no modification\\n                // if r == 1 => encodedLength -= 2\\n                // if r == 2 => encodedLength -= 1\\n                encodedLength := sub(\\n                    encodedLength,\\n                    add(iszero(iszero(r)), eq(r, 1))\\n                )\\n            }\\n        }\\n\\n        checkOverflow(buffer, encodedLength);\\n\\n        assembly {\\n            let nextFree := mload(0x40)\\n\\n            // Store the table into the scratch space.\\n            // Offsetted by -1 byte so that the `mload` will load the character.\\n            // We will rewrite the free memory pointer at `0x40` later with\\n            // the allocated size.\\n            mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n            mstore(\\n                0x3f,\\n                sub(\\n                    \\\"ghijklmnopqrstuvwxyz0123456789-_\\\",\\n                    // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                    mul(iszero(fileSafe), 0x0230)\\n                )\\n            )\\n\\n            // Skip the first slot, which stores the length.\\n            let ptr := add(add(buffer, 0x20), mload(buffer))\\n            let end := add(data, dataLength)\\n\\n            // Run over the input, 3 bytes at a time.\\n            // prettier-ignore\\n            // solhint-disable-next-line no-empty-blocks\\n            for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n            if iszero(noPadding) {\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n            }\\n\\n            mstore(buffer, add(mload(buffer), encodedLength))\\n            mstore(0x40, nextFree)\\n        }\\n    }\\n\\n    /// @notice Appends data encoded as Base64 to buffer.\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\\n    function appendUncheckedBase64(\\n        bytes memory buffer,\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure {\\n        uint256 dataLength = data.length;\\n\\n        if (data.length == 0) {\\n            return;\\n        }\\n\\n        uint256 encodedLength;\\n        uint256 r;\\n        assembly {\\n            // For each 3 bytes block, we will have 4 bytes in the base64\\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n            r := mod(dataLength, 3)\\n            if noPadding {\\n                // if r == 0 => no modification\\n                // if r == 1 => encodedLength -= 2\\n                // if r == 2 => encodedLength -= 1\\n                encodedLength := sub(\\n                    encodedLength,\\n                    add(iszero(iszero(r)), eq(r, 1))\\n                )\\n            }\\n        }\\n\\n        assembly {\\n            let nextFree := mload(0x40)\\n\\n            // Store the table into the scratch space.\\n            // Offsetted by -1 byte so that the `mload` will load the character.\\n            // We will rewrite the free memory pointer at `0x40` later with\\n            // the allocated size.\\n            mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n            mstore(\\n                0x3f,\\n                sub(\\n                    \\\"ghijklmnopqrstuvwxyz0123456789-_\\\",\\n                    // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                    mul(iszero(fileSafe), 0x0230)\\n                )\\n            )\\n\\n            // Skip the first slot, which stores the length.\\n            let ptr := add(add(buffer, 0x20), mload(buffer))\\n            let end := add(data, dataLength)\\n\\n            // Run over the input, 3 bytes at a time.\\n            // prettier-ignore\\n            // solhint-disable-next-line no-empty-blocks\\n            for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n            if iszero(noPadding) {\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n            }\\n\\n            mstore(buffer, add(mload(buffer), encodedLength))\\n            mstore(0x40, nextFree)\\n        }\\n    }\\n\\n    /// @notice Returns the capacity of a given buffer.\\n    function capacity(bytes memory buffer) internal pure returns (uint256) {\\n        uint256 cap;\\n        assembly {\\n            cap := sub(mload(sub(buffer, 0x20)), 0x40)\\n        }\\n        return cap;\\n    }\\n\\n    /// @notice Reverts if the buffer will overflow after appending a given\\n    /// number of bytes.\\n    function checkOverflow(bytes memory buffer, uint256 addedLength)\\n        internal\\n        pure\\n    {\\n        uint256 cap = capacity(buffer);\\n        uint256 newLength = buffer.length + addedLength;\\n        if (cap < newLength) {\\n            revert(\\\"DynamicBuffer: Appending out of bounds.\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\n                    mstore8(3, mload(and(input, 0x3F)))\\n                    mstore(ptr, mload(0x00))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\n                let o := div(2, mod(dataLength, 3))\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\n                // Set `o` to zero if there is padding.\\n                o := mul(iszero(iszero(noPadding)), o)\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                for {} 1 {} {\\n                    // If padded.\\n                    if iszero(and(dataLength, 3)) {\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\n                        // forgefmt: disable-next-item\\n                        decodedLength := sub(\\n                            decodedLength,\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\n                        )\\n                        break\\n                    }\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                    break\\n                }\\n                result := mload(0x40)\\n\\n                // Write the length of the bytes.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, decodedLength)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    // forgefmt: disable-next-item\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n                    ptr := add(ptr, 3)\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\n                mstore(0x60, 0) // Restore the zero slot.\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibPRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\nlibrary LibPRNG {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\\n    /// `b` must be null-terminated and normalized, or behavior will be undefined.\\n    /// See: `normalizeSmallString`.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let x := and(b, add(not(b), 1))\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITheStalker\",\"name\":\"_theStalker\",\"type\":\"address\"},{\"internalType\":\"contract IScriptyBuilderV2\",\"name\":\"_scriptyBuilder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_scriptyETHFSAddress\",\"type\":\"address\"},{\"internalType\":\"contract ICrypToadzChained\",\"name\":\"_crypToadzChained\",\"type\":\"address\"},{\"internalType\":\"contract IThePixelsInc\",\"name\":\"_thePixelsInc\",\"type\":\"address\"},{\"internalType\":\"contract ITheStalkerRenderer\",\"name\":\"_defaultRenderer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BlockedTokenId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isBlocked\",\"type\":\"bool\"}],\"name\":\"BlockedTokenIdUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ITheStalkerRenderer\",\"name\":\"_defaultRenderer\",\"type\":\"address\"}],\"name\":\"DefaultRendererUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"crypToadzImageURI\",\"type\":\"string\"}],\"name\":\"artworkConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"jsonKey\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"attributeKey\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"internalType\":\"struct JSONConfigurator.Parameter[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockedTokenIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"canUpdateToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crypToadzChained\",\"outputs\":[{\"internalType\":\"contract ICrypToadzChained\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRenderer\",\"outputs\":[{\"internalType\":\"contract ITheStalkerRenderer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"generateModifiedCrypToadzSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenRenderable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scriptyBuilder\",\"outputs\":[{\"internalType\":\"contract IScriptyBuilderV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scriptyETHFSAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thePixelsInc\",\"outputs\":[{\"internalType\":\"contract IThePixelsInc\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"theStalker\",\"outputs\":[{\"internalType\":\"contract ITheStalker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"tokenHTML\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"jsonKey\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"attributeKey\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"internalType\":\"struct JSONConfigurator.Parameter[]\",\"name\":\"artworkParams\",\"type\":\"tuple[]\"}],\"name\":\"tokenHTMLWithCrypToadzImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"tokenImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBlocked\",\"type\":\"bool\"}],\"name\":\"updateBlockedTokenIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITheStalkerRenderer\",\"name\":\"_defaultRenderer\",\"type\":\"address\"}],\"name\":\"updateDefaultRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TheStalkerCryptoToadzRenderer", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001399827d34d06042ab57c24800db57f267b981700000000000000000000000005ceb91d612a735ec5f50ad68c7ad22a945c602fc0000000000000000000000003349705ff99e44d1a42c8ea600de7cf5be36e034000000000000000000000000e8d8c0a6f174e08c44ab399b7ce810bc4dce096a0000000000000000000000002228b2a09ed31aedbf28172e79dc89e681504e98000000000000000000000000f8f294572d6304a7801c80928e045fa491d936fb", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}