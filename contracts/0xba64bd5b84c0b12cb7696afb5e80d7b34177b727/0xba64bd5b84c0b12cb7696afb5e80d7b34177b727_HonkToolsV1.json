{"SourceCode": "pragma solidity 0.8.23;\r\n\r\n// H   H  OOO  N   N K   K TTTTT  OOO  OOO  L     SSS\r\n// H   H O   O NN  N K  K    T   O   O O   O L    S\r\n// HHHHH O   O N N N KKK     T   O   O O   O L     SSS\r\n// H   H O   O N  NN K  K    T   O   O O   O L        S\r\n// H   H  OOO  N   N K   K   T    OOO   OOO  LLLL SSS\r\n\r\n/**\r\n * @title HonkToolsV1 by the Hyppocritez\r\n * @dev This contract allows users to create permanent inscriptions (ethscriptions) on the blockchain.\r\n *      Ethscriptions once made are immutable and stored eternally on-chain.\r\n *      The protocol is designed to be extendable and compatible with various use cases,\r\n *      including but not limited to, digital art, messages, and public information.\r\n *      Hyppocritez team reserves all rights to administer this smart contract as seen fit\r\n *      In case of error or critical issue we reserve the right to modify the smart contract state as needed\r\n */\r\n \r\ncontract HonkToolsV1 {\r\n    bool public initialized;\r\n    bool public paused;\r\n    bool public forwardAllFunds;\r\n    address public fundReceiver;\r\n    address public owner;\r\n    address public controller;\r\n    mapping(bytes32 => bool) public uniqueHash;\r\n    mapping(string => bool) public uniqueSalt;\r\n\r\n    event ethscriptions_protocol_CreateEthscription(\r\n        address indexed initialOwner,\r\n        string contentURI\r\n    );\r\n\r\n    event ethscriptions_protocol_TransferEthscription(address indexed recipient, bytes32 indexed ethscriptionId);\r\n\r\n    event ProductPurchasedWithSignature(address purchaser, string productId, bytes32 sha256Hash, uint256 expiry);\r\n\r\n    event UserEthWithdrawn(address user, uint256 amount, string salt, uint256 expiry);\r\n\r\n    event ChangeOwner(address newOwner);\r\n\r\n    event ChangeController(address newController);\r\n\r\n    event ChangeFundReceiver(address newReceiver);\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(paused == false, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    constructor(){\r\n    }\r\n\r\n    function initialize() public{\r\n        if(!initialized){\r\n            forwardAllFunds = false;\r\n            fundReceiver = address(0);\r\n            owner = msg.sender;\r\n            controller = msg.sender;\r\n            paused = false;\r\n            initialized = true;\r\n        }\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n        emit ChangeOwner(owner);\r\n    }\r\n\r\n    function changeController(address newController) public onlyOwner {\r\n        controller = newController;\r\n        emit ChangeController(controller);\r\n    }\r\n    function changeFundReceiver(address newFundReceiver) public onlyOwner {\r\n        fundReceiver = newFundReceiver;\r\n        if(newFundReceiver == address(0)){\r\n            forwardAllFunds = false;\r\n        } else {\r\n            forwardAllFunds = true;\r\n        }\r\n        emit ChangeFundReceiver(newFundReceiver);\r\n    }\r\n\r\n    function togglePause() public onlyOwner {\r\n        paused = !paused;\r\n    }\r\n\r\n    function inscribeWithSignature(string memory inscriptionData,  string memory salt, bytes memory signature, uint256 expiry) public notPaused payable {\r\n        require(expiry == 0 || expiry >= _getNow(), \"Expired\");\r\n\r\n        require(!uniqueSalt[salt], \"Salt has already been used\");\r\n\r\n        require(uniqueHash[sha256(abi.encodePacked(inscriptionData))] == false, \"Not Unique Hash\");\r\n\r\n        bytes32 dataHash = keccak256(abi.encodePacked(inscriptionData, msg.sender, salt, expiry));\r\n\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)); // check if useful later\r\n        address recovered = getRecoveredAddress(signature, prefixedHash);\r\n\r\n        require(recovered == controller, \"Signature Message is invalid\");\r\n\r\n        uniqueSalt[salt] = true;\r\n\r\n        if(forwardAllFunds){\r\n            (bool success, ) = fundReceiver.call{value: msg.value}(\"\");\r\n            require(success, \"Transfer failed\");\r\n        }\r\n\r\n        emit ethscriptions_protocol_CreateEthscription(msg.sender, string(abi.encodePacked(inscriptionData)));\r\n    }\r\n\r\n    function inscribePurchaseWithSignature(string memory inscriptionData,  string memory salt, bytes memory signature, uint256 expiry, string memory productId, bool unique) public notPaused payable {\r\n        require(expiry == 0 || expiry >= _getNow(), \"Expired\");\r\n        require(!uniqueSalt[salt], \"Salt has already been used\");\r\n\r\n        require(!unique || (unique && uniqueHash[sha256(abi.encodePacked(inscriptionData))]) == false, \"Not Unique Hash\");\r\n\r\n        bytes32 dataHash = keccak256(abi.encodePacked(inscriptionData, msg.sender, salt, expiry, productId, unique));\r\n\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)); // check if useful later\r\n        address recovered = getRecoveredAddress(signature, prefixedHash);\r\n\r\n        require(recovered == controller, \"Signature Message is invalid\");\r\n\r\n        uniqueSalt[salt] = true;\r\n\r\n        if(forwardAllFunds){\r\n            (bool success, ) = fundReceiver.call{value: msg.value}(\"\");\r\n            require(success, \"Transfer failed\");\r\n        }\r\n\r\n        emit ethscriptions_protocol_CreateEthscription(msg.sender, string(abi.encodePacked(inscriptionData)));\r\n        uniqueHash[sha256(abi.encodePacked(inscriptionData))] = true;\r\n        emit ProductPurchasedWithSignature(msg.sender, productId, sha256(abi.encodePacked(inscriptionData)), expiry);\r\n    }\r\n\r\n    function withdrawOwnerETH(uint256 amount) public onlyOwner {\r\n        owner.call{value: amount}(\"\");\r\n    }\r\n\r\n    function withdrawUserEthscriptions(bytes memory ethscriptionsIdsData, string memory salt, bytes memory signature, uint256 expiry) public notPaused {\r\n        require(expiry == 0 || expiry >= _getNow(), \"Expired\");\r\n        require(!uniqueSalt[salt], \"Salt has already been used\");\r\n\r\n        bytes32[] memory ethscriptionsIds = abi.decode(ethscriptionsIdsData, (bytes32[]));\r\n        require(ethscriptionsIds.length > 0, \"There must be 1 or more tokens being sent\");\r\n\r\n        bytes32 dataHash = keccak256(abi.encodePacked(ethscriptionsIdsData, msg.sender, salt, expiry));\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)); // check if useful later\r\n        address recovered = getRecoveredAddress(signature, prefixedHash);\r\n\r\n\r\n        require(recovered == controller, \"Signature Message is invalid\");\r\n\r\n        uniqueSalt[salt] = true;\r\n\r\n        for(uint256 i= 0; i < ethscriptionsIds.length; i++){\r\n            emit ethscriptions_protocol_TransferEthscription(msg.sender, ethscriptionsIds[i]);\r\n        }\r\n    }\r\n\r\n    function withdrawUserEth(uint256 amount, string memory salt, bytes memory signature, uint256 expiry) public notPaused {\r\n        require(expiry == 0 || expiry >= _getNow(), \"Expired\");\r\n        require(!uniqueSalt[salt], \"Salt has already been used\");\r\n\r\n        require(amount > 0, \"Must send more than 0 eth\");\r\n\r\n        bytes32 dataHash = keccak256(abi.encodePacked(amount, msg.sender, salt, expiry));\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)); // check if useful later\r\n        address recovered = getRecoveredAddress(signature, prefixedHash);\r\n\r\n        require(recovered == controller, \"Signature Message is invalid\");\r\n\r\n        uniqueSalt[salt] = true;\r\n\r\n        emit UserEthWithdrawn(msg.sender, amount, salt,expiry);\r\n\r\n        address payable ethRecipient = payable(msg.sender);\r\n        ethRecipient.transfer(amount);\r\n    }\r\n\r\n    function getRecoveredAddress(bytes memory sig, bytes32 dataHash)\r\n    public\r\n    pure\r\n    returns (address addr)\r\n    {\r\n        bytes32 ra;\r\n        bytes32 sa;\r\n        uint8 va;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            ra := mload(add(sig, 32))\r\n            sa := mload(add(sig, 64))\r\n            va := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        if (va < 27) {\r\n            va += 27;\r\n        }\r\n\r\n        address recoveredAddress = ecrecover(dataHash, va, ra, sa);\r\n\r\n        return (recoveredAddress);\r\n    }\r\n\r\n    function _getNow() internal virtual view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    fallback() external {\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"ChangeController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"ChangeFundReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sha256Hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"ProductPurchasedWithSignature\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"UserEthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"contentURI\",\"type\":\"string\"}],\"name\":\"ethscriptions_protocol_CreateEthscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"ethscriptionId\",\"type\":\"bytes32\"}],\"name\":\"ethscriptions_protocol_TransferEthscription\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFundReceiver\",\"type\":\"address\"}],\"name\":\"changeFundReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardAllFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"getRecoveredAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"inscriptionData\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"productId\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"unique\",\"type\":\"bool\"}],\"name\":\"inscribePurchaseWithSignature\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"inscriptionData\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"inscribeWithSignature\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uniqueHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"uniqueSalt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawOwnerETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"withdrawUserEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"ethscriptionsIdsData\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"withdrawUserEthscriptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HonkToolsV1", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a013121c80b65bc08eb786c64485b0902a1d7afe0972551af0a9f49b7344b143"}