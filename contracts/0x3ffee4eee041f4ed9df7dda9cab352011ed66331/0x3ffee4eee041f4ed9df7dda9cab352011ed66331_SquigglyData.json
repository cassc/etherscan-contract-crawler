{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n/// [MIT License]\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n\r\n            } {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n\r\ninterface iSquiggly {\r\n    function getIdToSVG(uint8 id) external view returns (string memory);\r\n    function getIdToCreator(uint8 id) external view returns (address);\r\n    function getIdToCurveType(uint8 id) external view returns (uint256);\r\n}\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract SquigglyData {\r\n\r\n    constructor() { \r\n        initializeAddress(0x36F379400DE6c6BCDF4408B282F8b685c56adc60);\r\n    }\r\n    \r\n    using Strings for uint256;\r\n\r\n    address public squigglyAddress; \r\n    iSquiggly squiggly; \r\n\r\n    function initializeAddress(address contractAddress) internal {\r\n        squigglyAddress = contractAddress;\r\n        squiggly = iSquiggly(squigglyAddress);\r\n    }\r\n\r\n    string svgJSON = '{\"image_data\": \"'; //squiggly SVG;\r\n    string idJSON = '\",\"description\": \"Randomly generated and fully on-chain squiggly lines, the first project in the Atlantes series\",\"external_url\": \"https://www.squiggly.wtf\",\"name\": \"Squiggly '; //id;\r\n    string creatorJSON = '\",\"attributes\": [{\"trait_type\": \"created by\",\"value\": \"'; //squiggly creator;\r\n    string curveJSON = '\"},{\"trait_type\": \"curve type\",\"value\": \"'; //squiggly curve type;\r\n    string classJSON = '\"},{\"trait_type\": \"class type\",\"value\": \"'; //squiggly class type;\r\n    string endJSON = '\"}]}';\r\n\r\n    function tokenURI(uint256 id) public view returns (string memory) {  \r\n        string memory encodedJSON;\r\n        string memory dataURI;\r\n\r\n        encodedJSON = Base64.encode(bytes(tokenJSON(id)));\r\n        dataURI = string(abi.encodePacked('data:application/json;base64,', encodedJSON));\r\n\r\n        return dataURI;\r\n    }\r\n\r\n    function renderSquiggly(uint256 id) public view returns (string memory) {\r\n        uint8 id8 = uint8(id);\r\n        string memory squigglySVG;\r\n\r\n        squigglySVG = string(abi.encodePacked('<?xml version=\"1.0\" encoding=\"UTF-8\"?>',squiggly.getIdToSVG(id8)));\r\n\r\n        return squigglySVG;\r\n    }\r\n\r\n    function tokenJSON(uint256 id) public view returns (string memory) {\r\n        uint8 id8 = uint8(id);\r\n        string memory JSON;\r\n\r\n        JSON = string(abi.encodePacked(svgJSON, squiggly.getIdToSVG(id8)));\r\n        JSON = string(abi.encodePacked(JSON, idJSON, id.toString()));\r\n        JSON = string(abi.encodePacked(JSON, creatorJSON, Strings.toHexString(uint256(uint160(squiggly.getIdToCreator(id8))), 20)));\r\n        JSON = string(abi.encodePacked(JSON, curveJSON, translateCurveType(squiggly.getIdToCurveType(id8))));\r\n        JSON = string(abi.encodePacked(JSON, classJSON, getClass(id), endJSON));\r\n\r\n        return JSON;        \r\n    }\r\n\r\n    function translateCurveType(uint256 curveType) public pure returns (string memory curveTypeString) {\r\n        if (curveType == 1){\r\n            curveTypeString = \"C Curve\";\r\n        }\r\n        else if (curveType == 2){\r\n            curveTypeString = \"S Curve\";\r\n        }\r\n        else if (curveType == 3){\r\n            curveTypeString = \"Q Curve\";\r\n        }\r\n        else if (curveType == 4){\r\n            curveTypeString = \"T Curve\";\r\n        }\r\n        else {\r\n            curveTypeString = \"No Curve\";\r\n        }        \r\n    }\r\n\r\n    function getClass(uint256 id) public pure returns (string memory classType) {\r\n        if (id <= 4){\r\n            classType = \"Promo\";\r\n        }\r\n        else {\r\n            classType = \"Standard\";\r\n        }\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getClass\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"classType\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"renderSquiggly\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"squigglyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"curveType\",\"type\":\"uint256\"}],\"name\":\"translateCurveType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"curveTypeString\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SquigglyData", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7e2c2dd9636bb24ec8f35d6ffba6a9753c9dd9ae5ed2e1eb68bb9e99111d60cc"}