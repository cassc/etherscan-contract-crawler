{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"BurnItDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n//                                                                                                                    //\\n//                                                                        #                                           //\\n//                                                                      ##                                            //\\n//                                                                    ###                                             //\\n//                                                               #######                                              //\\n//                                                            ####%**##                                               //\\n//                                                         ####*:---##                                                //\\n//                                                      ###%*:-----###                                                //\\n//                                                    ###%-----+---##                                                 //\\n//                                                  ####----====--=##                                                 //\\n//                                                ####:---======--*##                                                 //\\n//                                              ####----+===+===--###                                                 //\\n//                                             ###=---+===**+===--###                                                 //\\n//                                            ###:--====+***+===--*##                                                 //\\n//                                          ###=---===+******===--+##                                                 //\\n//                                         ##%:--====********===--=##                                                 //\\n//                                        ###---===+*********+==---###                                                //\\n//                                       ###---+==+**********+===--+##                                                //\\n//                                      ###---+==+************===--:%##                                               //\\n//                                     ###:--===+**************===--=##                                               //\\n//                                    ##%---===+***************+===--*##                                              //\\n//                                    ##=--===+*****************===---*##                                             //\\n//                                   ##*---==+*******************==+---*##                                            //\\n//                                  ##%:--+==*********************===---=###                                          //\\n//                         #        ##+--===+**********************====---%##                                         //\\n//                       ###       ##%---+==************************====---+###                                       //\\n//                     ####        ##*--===+*************************+===---:*###                                     //\\n//                   ######        #%=--+==****************************====----+%###                                  //\\n//                  ##%=###       ##%---==+******************************===+----=####                                //\\n//                 ###-:%##       ###---==+********************************=====---:#####                             //\\n//               ###+--:%##       ##*--===+**********************************====+----=%###                           //\\n//              ###=----###       ##*--===+************************************+=====----%###                         //\\n//             ###---=--+##       ###--===+***************************************=====---:%###                       //\\n//            ###---==--:%##      ##*--===+**************#####**********************+====----%##                      //\\n//            ##=--====---%##    ##%---+==********####################****************+====---+###                    //\\n//           ##*---====+:--+%######---===+****#####%#+:.       ..-*######***************+====---###                   //\\n//          ###---+==+====----===:---===+***#####:                    =%####**************====--:###                  //\\n//          #%=--===+**=====-------====*+*###%:                          +%###************++===---*##                 //\\n//         ###---==+*****+===========+**###%.                              =%###*************===---*##                //\\n//         ##=--+==**********+++++*****###-                                  *###*************===---*##               //\\n//        ###---==+******************###%.                                    :%##*************==+---###              //\\n//        ##*--===+*****************###%                                       .%##************+==+:--%##             //\\n//        ##=--===******************##%                                         :%##+***********+===--*##             //\\n//        ##=--===*****************##%.                                          =###************==+---###            //\\n//        ##---===*****************##+                                            ###************+===--###            //\\n//        ##---===****************##%:                                            +##*************===--+##            //\\n//        ##---===****************###.                                            :###************===--=##            //\\n//        ##=--===****************###                                             :###************===---##            //\\n//        ##*--===+***************###.         *%###%.            +%###%-         :###************+==---##            //\\n//        ###---==+***************##%.       .%#######*         .#########        =###************===---##            //\\n//         ##---+==***************###-       +########%         -########%:       ###*************===---##            //\\n//         ##*--===+***************##%.      .%########         .%########.      -###*************===--+##            //\\n//         ##%---+==***************###*       .#####%=     #-    .*%###%+       .###*************+===--*##            //\\n//          ##*---==+***************###=                  *#%:                 .###**************===---###            //\\n//          ##%---===+***************###+                +###%.               .####*************+===--+##             //\\n//           ##%:--+==****************####.             =%%%%%%.             .%##***************==+---###             //\\n//            ###:--===*****************###=                                %###***************+==---*##              //\\n//             ###---===*****************####+                           .#####***************+===--=##               //\\n//              ###---===+*****************####%.                      =%###*****************+===---%##               //\\n//               ###:--====******************###:  *%%:   ..:.   *%%.  +##******************====---%##                //\\n//                ##%----===+****************###:  +##:   +#%.   *#%.  +##*****************====--=###                 //\\n//                 ###+---====+**************###:  +##:   +#%.   *#%.  +##***************===+---+###                  //\\n//                   ##%----====+************###=::*##-:::*##-:::*##-::*##*************+===----###                    //\\n//                    ###%----=====**********#############################***********=====---+###                     //\\n//                      ###%:--:======================================================+----=%##                       //\\n//                        ###%=----=++++++++++++++++++++++++++++++++++++++++++++++++=---:*###                         //\\n//                          #####------------------------------------------------------####                           //\\n//                             ##########################################################                             //\\n//                                ####################################################                                //\\n//                                                                                                                    //\\n//  :::::::::  :::    ::: :::::::::  ::::    :::      ::::::::::: :::::::::::      :::::::::      :::      ::::::::   //\\n//  :+:    :+: :+:    :+: :+:    :+: :+:+:   :+:          :+:         :+:          :+:    :+:   :+: :+:   :+:    :+:  //\\n//  +:+    +:+ +:+    +:+ +:+    +:+ :+:+:+  +:+          +:+         +:+          +:+    +:+  +:+   +:+  +:+    +:+  //\\n//  +#++:++#+  +#+    +:+ +#++:++#:  +#+ +:+ +#+          +#+         +#+          +#+    +:+ +#++:++#++: +#+    +:+  //\\n//  +#+    +#+ +#+    +#+ +#+    +#+ +#+  +#+#+#          +#+         +#+          +#+    +#+ +#+     +#+ +#+    +#+  //\\n//  #+#    #+# #+#    #+# #+#    #+# #+#   #+#+#          #+#         #+#          #+#    #+# #+#     #+# #+#    #+#  //\\n//  #########   ########  ###    ### ###    ####      ###########     ###          #########  ###     ###  ########   //\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\npragma solidity ^0.8.21;\\n\\nimport {ERC721PsiBurnable, ERC721Psi} from \\\"./ERC721Psi/extension/ERC721PsiBurnable.sol\\\";\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {PullPayment} from \\\"./OpenZeppelin4/PullPayment.sol\\\";\\n\\nimport {LibPRNG} from \\\"solady/src/utils/LibPRNG.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\n\\nimport {LibBitSet, ILibBitSet64Filter} from \\\"./LibBitSet.sol\\\";\\nimport {LibShared} from \\\"./LibShared.sol\\\";\\nimport {LibConfig} from \\\"./LibConfig.sol\\\";\\nimport {LibGame, GameStatus} from \\\"./LibGame.sol\\\";\\nimport {LibWinners} from \\\"./LibWinners.sol\\\";\\nimport {LibRefundable} from \\\"./LibRefundable.sol\\\";\\nimport {TimeLock} from \\\"./TimeLock.sol\\\";\\nimport {LibUser} from \\\"./LibUser.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\ncontract BurnItDAO is\\nERC721PsiBurnable,\\nPullPayment,\\nOwnable,\\nReentrancyGuard,\\nTimeLock,\\nILibBitSet64Filter\\n{\\n    using LibPRNG for LibPRNG.PRNG;\\n    using LibBitSet for LibBitSet.Set;\\n    using LibConfig for LibConfig.Config;\\n    using LibGame for LibGame.Game;\\n    using LibUser for LibUser.User;\\n    using LibWinners for LibWinners.Winners;\\n    using LibRefundable for LibRefundable.MintData;\\n    using LibShared for uint256;\\n    using LibConfig for uint256;\\n    using LibGame for uint256;\\n    using LibShared for uint32;\\n    using LibString for uint256;\\n    using LibString for uint8;\\n\\n    uint32 private constant MINT_START_LOCK = 180 days;\\n    uint32 private constant MINT_LAST_LOCK = 30 days;\\n    uint8 private constant MINT_INDEX = 0;\\n    string private constant URI_SLASH = \\\"/\\\";\\n\\n    LibConfig.Config public config;\\n    string public baseURI;\\n\\n    LibGame.Game private _game;\\n    LibWinners.Winners private _winners;\\n    LibRefundable.MintData private _mints;\\n    mapping(address => LibUser.User) private _users;\\n    uint256 private _claimSeed;\\n\\n    event Commit(address indexed from, uint32 indexed gameRound);\\n    event Reveal(address indexed from, uint32 indexed gameRound);\\n    event Claim(address indexed from, uint32 indexed gameRound, uint256 indexed tokenId);\\n\\n    error ErrorDoNotSendDirectEth();\\n    error ErrorMintExpired();\\n    error ErrorMintTxAmount();\\n    error ErrorMintTxPrice();\\n    error ErrorMintResetting();\\n    error ErrorMintNotActive();\\n    error ErrorMintMaxTokens();\\n    error ErrorMintMaxWallet();\\n    error ErrorCommitInvalidUser();\\n    error ErrorGameNotRunning();\\n    error ErrorClaimInvalidOwner();\\n    error ErrorClaimUnavailable();\\n    error ErrorClaimMaxWallet();\\n    error ErrorClaimRoundClosed();\\n    error ErrorClaimInvalidUser();\\n    error ErrorClaimPermissionDenied();\\n    error ErrorClaimInvalidToken(uint256 tokenId);\\n    error ErrorClaimInvalidBurn(uint256 tokenId);\\n    error ErrorNonRefundable();\\n    error ErrorMintComplete();\\n    error ErrorInvalidToken();\\n    error ErrorTransferDenied();\\n    error ErrorTransferInvalidUser();\\n    error ErrorTransferInvalidBalance();\\n    error ErrorInvalidTokenURI();\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _tokenPrice,\\n        uint16 _maxTokens,\\n        uint16 _maxWallet,\\n        uint16 _maxTx,\\n        uint8 _teamSplit,\\n        address payable _teamAddress,\\n        address payable _drawAddress,\\n        string memory _tokenURI\\n    )\\n    ERC721Psi(_name, _symbol)\\n    Ownable(msg.sender)\\n    PullPayment()\\n    TimeLock(MINT_START_LOCK, MINT_LAST_LOCK)\\n    {\\n        config.initConfig(\\n            _tokenPrice,\\n            _maxTokens,\\n            _maxWallet,\\n            _maxTx,\\n            _teamSplit,\\n            _teamAddress,\\n            _drawAddress);\\n        _setBaseURI(_tokenURI);\\n        _game.initGame(_nextTokenId());\\n        _claimSeed = uint256(uint160(msg.sender));\\n    }\\n\\n    function setWallets(\\n        address payable _teamAddress,\\n        address payable _drawAddress\\n    ) external nonReentrant onlyOwner {\\n        config.setAddresses(_teamAddress, _drawAddress);\\n    }\\n\\n    function setBaseURI(\\n        string memory newURI\\n    ) external onlyOwner {\\n        _setBaseURI(newURI);\\n    }\\n\\n    fallback() external {\\n        revert ErrorDoNotSendDirectEth();\\n    }\\n\\n    function mint(\\n        uint16 quantity\\n    ) external payable nonReentrant {\\n        uint256 configData = config.data;\\n        uint256 gameData = _game.data;\\n        uint32 gameRound = gameData.getGameRound();\\n        GameStatus status = _game.getStatus(gameData);\\n        if (quantity > configData.maxTx()) revert ErrorMintTxAmount();\\n        if (msg.value < config.tokenPrice * quantity) revert ErrorMintTxPrice();\\n        if (block.timestamp <= _game.virtualResetEndTime(status)) revert ErrorMintResetting();\\n        if (_isGameExpired(status)) revert ErrorMintExpired();\\n        if (gameData.gameState() != GAME_STATE_OFFLINE && status > GameStatus.RUNNING) {\\n            if (gameData.resetEndTime() == 0) {\\n                _finalizeGame(gameRound);\\n            }\\n            gameRound = _game.resetGame(_nextTokenId());\\n        } else if (status != GameStatus.MINTING) revert ErrorMintNotActive();\\n        unchecked {\\n            LibUser.User storage user = _users[msg.sender];\\n            uint256 userData = user.initUser(msg.sender, gameRound);\\n            if (userData.getLiveCount() + quantity > configData.maxWallet()) revert ErrorMintMaxWallet();\\n            LibBitSet.Set storage gameTokens = _game.tokens[MINT_INDEX];\\n            uint16 total = uint16(gameTokens.length()) + quantity;\\n            uint16 maxTokens = configData.maxTokens();\\n            if (total > maxTokens) revert ErrorMintMaxTokens();\\n            gameTokens.addBatch(_nextTokenId(), quantity);\\n            user.data = userData.addLiveCount(quantity);\\n            _mint(msg.sender, quantity);\\n            uint256 teamAmount = (msg.value * configData.teamSplit()) / 100;\\n            uint256 userAmount = msg.value - teamAmount;\\n            _game.prizePool += userAmount;\\n            _mints.addRefundableAmount(gameRound >> OFFSET_GAME_NUMBER, msg.sender, userAmount);\\n            _asyncTransfer(configData.teamAddress(), teamAmount);\\n            if (total == maxTokens) {\\n                _game.startGame();\\n                resetTimeLock();\\n            }\\n        }\\n        timeLock();\\n    }\\n\\n    function commit(\\n        bytes32 hash\\n    ) external nonReentrant {\\n        uint256 gameData = _game.data;\\n        uint32 gameRound = gameData.getGameRound();\\n        LibUser.User storage user = _users[msg.sender];\\n        if (user.isInvalid(gameRound)) {\\n            revert ErrorClaimInvalidUser();\\n        }\\n        GameStatus status = _game.getStatus();\\n        if (status != GameStatus.PENDING && status != GameStatus.RUNNING) {\\n            revert ErrorGameNotRunning();\\n        }\\n        if (status == GameStatus.PENDING) {\\n            if (gameData.pauseEndTime() != 0) {\\n                unchecked { gameRound++; }\\n            }\\n            _game.startRound(gameRound);\\n            status = GameStatus.RUNNING;\\n        }\\n        user.commit(gameRound, status, hash);\\n        emit Commit(msg.sender, gameRound);\\n    }\\n\\n    function reveal(\\n        bytes memory secret\\n    ) external nonReentrant {\\n        uint32 gameRound = _game.data.getGameRound();\\n        _users[msg.sender].reveal(gameRound, _game.getStatus(), secret);\\n        _randomSeed(bytes32(secret));\\n        emit Reveal(msg.sender, gameRound);\\n    }\\n\\n    function claim(\\n        uint256 tokenId\\n    ) external nonReentrant {\\n        LibUser.User storage user = _users[msg.sender];\\n        LibUser.User memory claimUser = user;\\n        uint256 claimData    = claimUser.data;\\n        uint256 gameData     = _game.data;\\n        uint32 gameRound     = gameData.getGameRound();\\n        uint256 roundEndTime = gameData.roundEndTime();\\n        LibBitSet.Set storage liveTokens = _game.tokens[gameRound.liveIndex()];\\n        uint256 liveCount    = liveTokens.length();\\n        if (ownerOf(tokenId) != msg.sender) revert ErrorClaimInvalidOwner();\\n        if (liveCount <= 1) revert ErrorClaimUnavailable();\\n        if (claimData.getSafeCount() >= config.maxWallet()) revert ErrorClaimMaxWallet();\\n        if (roundEndTime <= block.timestamp) revert ErrorClaimRoundClosed();\\n        if (claimData.getGameRound() != gameRound) revert ErrorClaimInvalidUser();\\n        if (claimUser.lastCommit <= REVEAL_THRESHOLD) revert ErrorClaimPermissionDenied();\\n        if (!liveTokens.remove(tokenId)) revert ErrorClaimInvalidToken(tokenId);\\n        uint256 safeCount = _game.tokens[gameRound.safeIndex()].add(tokenId);\\n        claimData = claimData.subLiveCount(1);\\n        claimData = claimData.addSafeCount(1);\\n        unchecked {\\n            liveCount -= 1;\\n            uint256 burnId = liveTokens.removeAt(_randomN(tokenId, liveCount));\\n            if (burnId == LibBitSet.NOT_FOUND) revert ErrorClaimInvalidBurn(burnId);\\n            address burnAddress = ownerOf(burnId);\\n            _burn(burnId);\\n            liveCount -= 1;\\n            gameData += 1;\\n            if (burnAddress != msg.sender) {\\n                uint256 burnData = _users[burnAddress].initUser(burnAddress, gameRound);\\n                _users[burnAddress].data = burnData.subLiveCount(1) + 1;\\n            } else {\\n                claimData = claimData.subLiveCount(1) + 1;\\n            }\\n            emit Claim(msg.sender, gameRound, tokenId);\\n            if (claimData.getSafeCount() != safeCount) {\\n                gameData = gameData.setMultiUser();\\n            }\\n            if (liveCount <= 1) {\\n                gameData = gameData.clearRoundEndTime();\\n            }\\n            if ((liveCount > 1) || (gameData.isMultiUser() && (safeCount > 1))) {\\n                uint256 pauseTime = LibShared.max(safeCount << TOKEN_DELAY_PAUSE, MIN_PAUSE_TIME);\\n                gameData = gameData.setPauseEndTime(LibShared.max(gameData.roundEndTime(), block.timestamp) + pauseTime);\\n            }\\n            else {\\n                gameData = gameData.clearPauseEndTime() | gameData.setResetEndTime(block.timestamp + MIN_RESET_TIME);\\n                uint256 prize = _game.prizePool;\\n                _winners.recordWinner(tokenId, prize, gameRound, msg.sender);\\n                _asyncTransfer(msg.sender, prize);\\n                emit LibGame.GameOver(gameRound, msg.sender);\\n            }\\n        }\\n        user.data = claimData;\\n        _game.data = gameData;\\n    }\\n\\n    function finalize(\\n    ) external nonReentrant {\\n        _finalizeGame(_game.data.getGameRound());\\n    }\\n\\n    function refund(\\n        uint32 gameNumber,\\n        address payable owner\\n    ) external nonReentrant {\\n        uint256 amount = _mints.removeRefundableAmount(gameNumber, owner);\\n        if (amount == 0) revert ErrorNonRefundable();\\n        _asyncTransfer(owner, amount);\\n    }\\n\\n    function cancel(\\n    ) external nonReentrant timeLocked {\\n        if (_game.getStatus() != GameStatus.MINTING) revert ErrorMintNotActive();\\n        if ( _game.liveTokenCount() >= config.maxTokens()) revert ErrorMintComplete();\\n        _mints.cancelMint(_game.data.getGameNumber(), _game.prizePool);\\n        _game.cancelGame(_nextTokenId());\\n        resetTimeLock();\\n    }\\n\\n    function getRefundAmount(\\n        uint256 gameNumber,\\n        address owner\\n    ) external view returns (uint256) {\\n        return _mints.getRefundableAmount(gameNumber, owner);\\n    }\\n\\n    function canCancelGame(\\n    ) external view returns (uint256) {\\n        if (_game.getStatus() != GameStatus.MINTING) return TimeLock.MAX_LOCK;\\n        return timeLockLeft();\\n    }\\n\\n    function cancelledGames(\\n    ) external view returns (uint256[] memory) {\\n        return _mints.cancelledMints();\\n    }\\n\\n    function totalCancelledGames(\\n    ) external view returns (uint256) {\\n        return _mints.totalCancelledMints();\\n    }\\n\\n    function cancelledGameAtIndex(\\n        uint256 index\\n    ) external view returns (uint256) {\\n        return _mints.cancelledMintAtIndex(index);\\n    }\\n\\n    function isGameFinalized(\\n    ) external view returns (bool) {\\n        (, bool finalized) = _isGameFinalized(_game.data.getGameRound());\\n        return finalized;\\n    }\\n\\n    function isGameExpired(\\n    ) external view returns (bool) {\\n        return _isGameExpired(_game.getStatus());\\n    }\\n\\n    function getGameInfo(\\n    ) external view returns (uint256) {\\n        return _game.gameInfo();\\n    }\\n\\n    function getUserInfo(\\n        address userAddress\\n    ) external view returns (uint256) {\\n        return _users[userAddress].getUserInfo(_game);\\n    }\\n\\n    function getTokenStatus(\\n        uint256 tokenId\\n    ) external view returns (uint8) {\\n        uint8 status = _getVirtualTokenStatus(tokenId);\\n        if (status == TOKEN_STATUS_SECURE && _game.data.hasPauseExpired()) {\\n            status = TOKEN_STATUS_ACTIVE;\\n        } else if ((status & TOKEN_STATUS_BURNED) != 0) {\\n            status = TOKEN_STATUS_BURNED;\\n        } else if ((status & TOKEN_STATUS_WINNER) != 0) {\\n            status = TOKEN_STATUS_WINNER;\\n        }\\n        return status;\\n    }\\n\\n    function isTokenOwner(\\n        address owner,\\n        uint256 idx\\n    ) external view override returns (bool) {\\n        return ownerOf(idx) == owner;\\n    }\\n\\n    function liveTokenOfOwner(\\n        address owner\\n    ) external view returns (uint256) {\\n        uint256 data = _users[owner].data;\\n        uint32 gameRound = _game.data.getGameRound();\\n        if ((gameRound != data.getGameRound()) || (data.getLiveCount() == 0))\\n            return LibBitSet.NOT_FOUND;\\n        return _game.tokens[gameRound.liveIndex()].findFirstOfOwner(owner, this);\\n    }\\n\\n    function totalWinners(\\n    ) external view returns (uint256) {\\n        uint256 total = _winners.totalWinners();\\n        (uint256 tokenId, bool finalized) = _isGameFinalized(_game.data.getGameRound());\\n        if (finalized || tokenId == LibBitSet.NOT_FOUND) return total;\\n        return total + 1;\\n    }\\n\\n    function getWinnerAtIndex(\\n        uint256 index\\n    ) external view returns (LibWinners.Winner memory) {\\n        if (index == _winners.totalWinners()) {\\n            return _virtualWinner(_game.data.getGameRound());\\n        }\\n        return _winners.getWinnerAt(index);\\n    }\\n\\n    function getWinner(\\n        uint32 gameNumber\\n    ) external view returns (LibWinners.Winner memory) {\\n        uint32 gameRound = _game.data.getGameRound();\\n        uint32 currentGame = gameRound >> OFFSET_GAME_NUMBER;\\n        if (gameNumber > currentGame) {\\n            gameNumber = currentGame;\\n        }\\n        LibWinners.Winner memory winner = _winners.getWinner(gameNumber);\\n        if (winner.data != 0 || gameNumber != currentGame) {\\n            return winner;\\n        }\\n        return _virtualWinner(gameRound);\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override returns (string memory) {\\n        if (!_exists(tokenId)) {\\n            revert ErrorInvalidToken();\\n        }\\n        uint8 slug = _getVirtualTokenStatus(tokenId);\\n        if (slug == TOKEN_STATUS_BANNED || ((slug & TOKEN_STATUS_BURNED) != 0)) {\\n            slug = TOKEN_STATUS_BURNED;\\n        }\\n        if (slug == TOKEN_STATUS_SECURE && _game.data.hasPauseExpired()) {\\n            slug = TOKEN_STATUS_ACTIVE;\\n        }\\n        if ((slug & TOKEN_STATUS_WINNER) != 0) {\\n            slug = TOKEN_STATUS_WINNER;\\n            tokenId = _winners.getWinnerId(tokenId);\\n        } else {\\n            tokenId %= config.maxTokens();\\n        }\\n        return string(abi.encodePacked(\\n            baseURI, slug.toString(), URI_SLASH, tokenId.toString()\\n        ));\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        if (!_approveTransfer(from, to, tokenId)) return;\\n        super._transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable override {\\n        if (!_approveTransfer(from, to, tokenId)) return;\\n        super._safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _finalizeGame(\\n        uint32 gameRound\\n    ) internal returns (bool) {\\n        (uint256 tokenId, bool finalized) = _isGameFinalized(gameRound);\\n        if (finalized) return false;\\n        address winnerAddress = tokenId >= FORFEIT_TOKEN_ID ?\\n            config.drawAddress : ownerOf(tokenId);\\n        uint256 prize = _game.prizePool;\\n        _winners.recordWinner(tokenId, prize, gameRound, winnerAddress);\\n        _asyncTransfer(winnerAddress, prize);\\n        emit LibGame.GameOver(gameRound, winnerAddress);\\n        return true;\\n    }\\n\\n    function _isGameFinalized(\\n        uint32 gameRound\\n    ) internal view returns (uint256, bool) {\\n        uint256 tokenId = _game.isGameOver(gameRound);\\n        return (tokenId, tokenId == LibBitSet.NOT_FOUND || _winners.hasWinner(tokenId));\\n    }\\n\\n    function _isGameExpired(\\n        GameStatus status\\n    ) internal view returns (bool) {\\n        return (status == GameStatus.MINTING) && timeLockExpired();\\n    }\\n\\n    function _getVirtualTokenStatus(\\n        uint256 tokenId\\n    ) internal view returns (uint8) {\\n        if (_winners.hasWinner(tokenId)) return TOKEN_STATUS_WINNER;\\n        uint8 status = _game.getTokenStatus(tokenId);\\n        if ((status & (TOKEN_STATUS_ACTIVE | TOKEN_STATUS_SECURE)) != 0) {\\n            uint256 winnerId = _game.isGameOver(_game.data.getGameRound());\\n            if (winnerId != LibBitSet.NOT_FOUND) {\\n                return status | (winnerId == tokenId ? TOKEN_STATUS_WINNER : TOKEN_STATUS_BURNED);\\n            }\\n        }\\n        return status;\\n    }\\n\\n    function _approveTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal returns (bool) {\\n        if (from == to) revert ErrorTransferDenied();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert TransferFromIncorrectOwner();\\n        uint8 tokenStatus = _getVirtualTokenStatus(tokenId);\\n        if (tokenStatus == TOKEN_STATUS_BANNED || ((tokenStatus & TOKEN_STATUS_BURNED) != 0)) {\\n            _burn(tokenId);\\n            return false;\\n        }\\n        if ((tokenStatus & TOKEN_STATUS_WINNER) != 0) return true;\\n        if ( _game.getStatus() == GameStatus.RUNNING) revert ErrorTransferDenied();\\n        uint32 gameRound = _game.data.getGameRound();\\n        LibUser.User storage fromUser = _users[from];\\n        if (fromUser.isInvalid(gameRound)) revert ErrorTransferInvalidUser();\\n        uint256 fromData = fromUser.initUser(from, gameRound);\\n        if ((tokenStatus & (TOKEN_STATUS_ACTIVE | TOKEN_STATUS_QUEUED)) != 0) {\\n            if (fromData.getLiveCount() == 0) revert ErrorTransferInvalidBalance();\\n            fromData = fromData.subLiveCount(1);\\n        } else if ((tokenStatus & TOKEN_STATUS_SECURE) != 0) {\\n            if (fromData.getSafeCount() == 0) revert ErrorTransferInvalidBalance();\\n            fromData = fromData.subSafeCount(1);\\n        }\\n        fromUser.data = fromData;\\n        LibUser.User storage toUser = _users[to];\\n        uint256 toData = toUser.initUser(to, gameRound);\\n        if ((tokenStatus & (TOKEN_STATUS_ACTIVE | TOKEN_STATUS_QUEUED)) != 0) {\\n            toData = toData.addLiveCount(1);\\n        } else if ((tokenStatus & TOKEN_STATUS_SECURE) != 0) {\\n            toData = toData.addSafeCount(1);\\n        }\\n        toUser.data = toData;\\n        return true;\\n    }\\n\\n    function _setBaseURI(\\n        string memory newURI\\n    ) private {\\n        if (bytes(newURI).length < 10) revert ErrorInvalidTokenURI();\\n        baseURI = newURI;\\n    }\\n\\n    function _virtualUserOf(\\n        address owner\\n    ) private view returns (LibUser.User storage, uint32) {\\n        LibUser.User storage user = _users[owner];\\n        uint32 gameRound =_game.data.getGameRound();\\n        return (user, user.isExpired(gameRound) ? 0 : gameRound);\\n    }\\n\\n    function _virtualWinner(\\n        uint32 gameRound\\n    ) private view returns (LibWinners.Winner memory) {\\n        LibWinners.Winner memory winner;\\n        uint256 tokenId = _game.isGameOver(gameRound);\\n        if (tokenId == LibBitSet.NOT_FOUND) return winner;\\n        bool draw = tokenId >= FORFEIT_TOKEN_ID;\\n        address winAddress = draw ? config.drawAddress : ownerOf(tokenId);\\n        gameRound ^= (gameRound & uint32(LibShared.MASK_ROUND));\\n        winner.data = _winners.packWinnerData(gameRound, winAddress);\\n        winner.tokenId = draw ? 0 : tokenId;\\n        winner.prize = _game.prizePool;\\n        return winner;\\n    }\\n\\n    function _randomSeed(\\n        bytes32 seed\\n    ) private {\\n        unchecked {\\n            uint256 blockIndex = uint256(seed) % (block.number < 255 ? block.number - 1 : 255) + 1;\\n            _claimSeed = uint256(keccak256(abi.encodePacked(\\n                _claimSeed, block.prevrandao, msg.sender, block.timestamp, seed,\\n                tx.gasprice, blockhash(block.number - blockIndex))));\\n        }\\n    }\\n\\n    function _randomN(\\n        uint256 nonce,\\n        uint256 max\\n    ) private view returns (uint256 result) {\\n        return LibPRNG.PRNG({state: uint256(keccak256(\\n            abi.encodePacked(nonce, block.prevrandao, msg.sender, block.timestamp, _claimSeed)\\n        ))}).uniform(max);\\n    }\\n}\\n\"\r\n    },\r\n    \"Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nuint256 constant WEI = 100000000000000;\\nuint256 constant DATA_OFFSET_SAFE_COUNT = 16;\\nuint256 constant DATA_OFFSET_LIVE_COUNT = 32;\\nuint256 constant DATA_OFFSET_GAME_ROUND = 224;\\nuint256 constant DATA_OFFSET_ROUND_COUNT = 224;\\nuint256 constant DATA_OFFSET_GAME_NUMBER = 232;\\nuint256 constant MAX_TOKEN_ID = type(uint56).max;\\nuint256 constant FORFEIT_TOKEN_ID = 1e6;\\nuint256 constant REVEAL_THRESHOLD = 0xFFFFFFFF;\\nuint32 constant MIN_ROUND_TIME = 60 minutes;\\nuint32 constant MIN_PAUSE_TIME = 60 minutes;\\nuint32 constant MIN_RESET_TIME = 24 hours;\\nuint256 constant GAME_STATE_OFFLINE = 0x0;\\nuint256 constant GAME_STATE_STARTED = 0x1;\\nuint256 constant GAME_STATE_VIRTUAL = 0x2;\\nuint16 constant TOKEN_DELAY_ROUND = 4;\\nuint16 constant TOKEN_DELAY_PAUSE = 5;\\nuint16 constant MIN_TOKENS = 2;\\nuint16 constant MAX_TOKENS = 2**14;\\nuint32 constant OFFSET_GAME_NUMBER = 8;\\nuint8 constant MAX_TEAM_SPLIT = 50;\\nuint8 constant TOKEN_STATUS_BANNED = 0x00;\\nuint8 constant TOKEN_STATUS_BURNED = 0x02;\\nuint8 constant TOKEN_STATUS_QUEUED = 0x04;\\nuint8 constant TOKEN_STATUS_ACTIVE = 0x08;\\nuint8 constant TOKEN_STATUS_SECURE = 0x10;\\nuint8 constant TOKEN_STATUS_WINNER = 0x20;\\n\\n\"\r\n    },\r\n    \"LibUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport {LibShared} from \\\"./LibShared.sol\\\";\\nimport {LibGame, GameStatus} from \\\"./LibGame.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nenum UserStatus {\\n    EXPIRED,\\n    STALE,\\n    VALID\\n}\\n\\nlibrary LibUser {\\n    using LibGame for LibGame.Game;\\n    using LibShared for uint256;\\n    using LibGame for uint256;\\n    using LibShared for uint32;\\n\\n    uint256 private constant INFO_OFFSET_IS_PLAYING = 0;\\n    uint256 private constant INFO_OFFSET_PERMISSION = 1;\\n    uint256 private constant INFO_OFFSET_BURN_COUNT = 8;\\n    uint256 private constant INFO_OFFSET_SAFE_COUNT = 24;\\n    uint256 private constant INFO_OFFSET_LIVE_COUNT = 40;\\n    uint256 private constant COMMIT_WINDOW = 120;\\n    uint256 private constant OFFSET_COMMIT = 32;\\n    uint256 private constant USER_OFFSET_OWNER_ADDR = 64;\\n    uint8 private constant PERM_DENIED = 0x0;\\n    uint8 private constant PERM_COMMIT = 0x1;\\n    uint8 private constant PERM_REVEAL = 0x2;\\n    uint8 private constant PERM_CLAIMS = 0x4;\\n\\n    struct User {\\n        uint256 data;\\n        uint256 lastCommit;\\n    }\\n\\n    error ErrorCommitPrevious();\\n    error ErrorCommitDenied();\\n    error ErrorRevealLength();\\n    error ErrorRevealDenied();\\n    error ErrorRevealMismatch();\\n\\n    function isInvalid(User storage self,\\n        uint32 gameRound\\n    ) internal view returns (bool) {\\n        uint256 data = self.data;\\n        unchecked {\\n            return (\\n                (data == 0) ||\\n                (gameRound - data.getGameRound() >= 2) ||\\n                (data.getLiveCount() == 0 && data.getSafeCount() == 0)\\n            );\\n        }\\n    }\\n\\n    function initUser(User storage self,\\n        address addy,\\n        uint32 gameRound\\n    ) internal returns (uint256) {\\n        return _initUser(self, addy, gameRound);\\n    }\\n\\n    function isExpired(User storage self,\\n        uint32 gameRound\\n    ) internal view returns (bool) {\\n        return _isExpired(self, gameRound);\\n    }\\n\\n    function commit(User storage self,\\n        uint32 gameRound,\\n        GameStatus status,\\n        bytes32 hash\\n    ) internal {\\n        _commit(self, gameRound, status, hash);\\n    }\\n\\n    function reveal(User storage self,\\n        uint32 gameRound,\\n        GameStatus status,\\n        bytes memory secret\\n    ) internal {\\n        _reveal(self, gameRound, status, secret);\\n    }\\n\\n    function getUserInfo(User storage self,\\n        LibGame.Game storage game\\n    ) internal view returns (uint256) {\\n        return _getUserInfo(self, game);\\n    }\\n\\n    function _initUser(User storage self,\\n        address addr,\\n        uint32 gameRound\\n    ) private returns (uint256) {\\n        uint256 data = self.data;\\n        uint32 prevGameRound = data.getGameRound();\\n        unchecked {\\n            uint32 nextGameRound = prevGameRound + 1;\\n            if (data == 0 || gameRound - prevGameRound >= 2) {\\n                data = uint256(uint160(addr)) << USER_OFFSET_OWNER_ADDR;\\n                self.lastCommit = 0;\\n            } else if (nextGameRound == gameRound) {\\n                data = data.addBurnCount(data.getLiveCount());\\n                data = data.setLiveCount(data.getSafeCount());\\n                data = data.clearSafeCount();\\n                self.lastCommit = 0;\\n            }\\n        }\\n        data = data.setGameRound(gameRound);\\n        self.data = data;\\n        return data;\\n    }\\n\\n    function _isExpired(User storage self, uint32 gameRound) private view returns (bool) {\\n        return gameRound - self.data.getGameRound() >= 2;\\n    }\\n\\n    function _commit(User storage self,\\n        uint32 gameRound,\\n        GameStatus status,\\n        bytes32 hash\\n    ) private {\\n        _initUser(self, address(0), gameRound);\\n        if (self.lastCommit != 0) revert ErrorCommitPrevious();\\n        if ((_getPermissions(self, status, gameRound) != PERM_COMMIT)) revert ErrorCommitDenied();\\n        self.lastCommit = (uint256(hash) << OFFSET_COMMIT) | (block.number + COMMIT_WINDOW);\\n    }\\n\\n    function _reveal(User storage self,\\n        uint32 gameRound,\\n        GameStatus status,\\n        bytes memory secret\\n    ) private {\\n        if (secret.length != 4) revert ErrorRevealLength();\\n        if (_getPermissions(self, status, gameRound) != PERM_REVEAL) revert ErrorRevealDenied();\\n        bytes32 hash = keccak256(secret);\\n        self.lastCommit = uint256(hash) << OFFSET_COMMIT;\\n        if (self.lastCommit != (self.lastCommit & ~uint256(0xFFFFFFFF))) revert ErrorRevealMismatch();\\n        return;\\n    }\\n\\n    function _getStatus(User storage self,\\n        uint32 gameRound\\n    ) private view returns (UserStatus) {\\n        uint256 lastGameRound = self.data.getGameRound();\\n        if (lastGameRound == gameRound) return UserStatus.VALID;\\n        unchecked {\\n            if (lastGameRound + 1 == gameRound) return UserStatus.STALE;\\n        }\\n        return UserStatus.EXPIRED;\\n    }\\n\\n    function _getPermissions(User storage self,\\n        GameStatus status,\\n        uint32 gameRound\\n    ) private view returns (uint8) {\\n        uint256 data = self.data;\\n        uint32 lastGameRound =  data.getGameRound();\\n        uint16 count = data.getLiveCount();\\n        if ((status == GameStatus.PENDING || status == GameStatus.RUNNING) && (lastGameRound + 1 == gameRound)) {\\n            count = data.getSafeCount();\\n        }\\n        if ((status != GameStatus.PENDING && status != GameStatus.RUNNING) ||\\n            (gameRound - lastGameRound >= 2) || (count == 0)) {\\n            return PERM_DENIED;\\n        }\\n        uint256 lastCommit = self.lastCommit;\\n        if (lastCommit == 0) return PERM_COMMIT;\\n        uint32 blockNumber = uint32(lastCommit);\\n        if ((blockNumber == 0) && (lastGameRound + 1 == gameRound) &&\\n            (lastCommit > REVEAL_THRESHOLD)) {\\n            return PERM_COMMIT;\\n        }\\n        if (lastCommit <= REVEAL_THRESHOLD) return PERM_DENIED;\\n        return (blockNumber > 1 && block.number <= blockNumber) ? PERM_REVEAL : PERM_CLAIMS;\\n    }\\n\\n    function _getUserInfo(User storage self,\\n        LibGame.Game storage game\\n    ) private view returns (uint256) {\\n        uint256 userData = self.data;\\n        uint32 lastGameRound = userData.getGameRound();\\n        if (lastGameRound == 0) return 0;\\n        uint256 gameData = game.data;\\n        uint256 resetEndTime = gameData.resetEndTime();\\n        uint32 gameRound = gameData.getGameRound();\\n        uint16 liveCount = userData.getLiveCount();\\n        uint16 safeCount = userData.getSafeCount();\\n        uint16 burnCount = userData.getBurnCount();\\n        GameStatus status = game.getStatus();\\n        if (status > GameStatus.RUNNING) {\\n            if (resetEndTime == 0) {\\n                resetEndTime = game.virtualResetEndTime(status);\\n            }\\n            if (resetEndTime != 0 && block.timestamp > resetEndTime) {\\n                gameRound = game.nextGameRound();\\n            }\\n        }\\n        unchecked {\\n            uint256 isPlayer = (userData.getGameNumber() == gameData.getGameNumber() &&\\n                (liveCount | safeCount | burnCount) != 0) ? 1 : 0;\\n            if (((status == GameStatus.PAUSING || status == GameStatus.PENDING) && (gameData.pauseEndTime() != 0))) {\\n                gameRound++;\\n            }\\n            uint256 perms = _getPermissions(self, status, gameRound);\\n            if (gameRound - lastGameRound >= 2) {\\n                burnCount += (liveCount + safeCount);\\n                liveCount = safeCount = 0;\\n            }\\n            else if ((lastGameRound + 1 == gameRound) || (status > GameStatus.RUNNING)) {\\n                burnCount += liveCount;\\n                liveCount  = 0;\\n                if (status == GameStatus.PENDING || status == GameStatus.RUNNING) {\\n                    (liveCount, safeCount) = (safeCount, 0);\\n                } else if (status > GameStatus.RUNNING) {\\n                    burnCount += safeCount;\\n                    safeCount  = 0;\\n                }\\n            }\\n            return\\n                (isPlayer           << INFO_OFFSET_IS_PLAYING) |\\n                (perms              << INFO_OFFSET_PERMISSION) |\\n                (uint256(burnCount) << INFO_OFFSET_BURN_COUNT) |\\n                (uint256(safeCount) << INFO_OFFSET_SAFE_COUNT) |\\n                (uint256(liveCount) << INFO_OFFSET_LIVE_COUNT);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"TimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title TimeLock\\n * @dev This contract provides a time lock mechanism. Functions with the `timeLocked` modifier\\n * can only be called after either `startTime` or `lastTime` has expired.\\n */\\ncontract TimeLock {\\n\\n    uint256 public constant MAX_LOCK = type(uint256).max;\\n\\n    uint256 public startTime;\\n    uint256 public lastTime;\\n    uint256 public startLock;\\n    uint256 public lastLock;\\n\\n    error ErrorTimeLocked(uint256 remaining);\\n\\n    /**\\n     * @dev Initializes the contract setting the `startLock` and `lastLock` state variables.\\n     * @param _startLock The max time after `startTime` when function can be called.\\n     * @param _lastLock The max time after `lastTime` when function can be called.\\n     */\\n    constructor(uint256 _startLock, uint256 _lastLock) {\\n        startLock = _startLock;\\n        lastLock = _lastLock;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only after the lock has expired.\\n     */\\n    modifier timeLocked() {\\n        uint256 t = timeLockLeft();\\n        if (t > 0) revert ErrorTimeLocked(t);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Set the last time and initialize start time if not set.\\n     */\\n    function timeLock() internal {\\n        if (timeLockExpired()) return;\\n        lastTime = block.timestamp;\\n        if (startTime == 0) startTime = lastTime;\\n    }\\n\\n    /**\\n     * @dev Reset the start and last time to zero.\\n     */\\n    function resetTimeLock() internal {\\n        startTime = lastTime = 0;\\n    }\\n\\n    /**\\n     * @dev Check if the time lock is active (not expired).\\n     * @return Time remaining if lock is active, false otherwise.\\n     */\\n    function timeLockLeft() internal view returns (uint256) {\\n        if (startTime == 0) return MAX_LOCK;\\n        uint256 cancelTime = _cancelTime(startLock, lastLock);\\n        return (block.timestamp < cancelTime) ? cancelTime - block.timestamp : 0;\\n    }\\n\\n    /**\\n     * @dev Check if the time is expired past the start time lock.\\n     * @return True if time is expired past start time lock, false otherwise.\\n     */\\n    function timeLockExpired() internal view returns (bool) {\\n        return startTime > 0 && block.timestamp > (startTime + startLock);\\n    }\\n\\n    /**\\n     * @dev Calculate the time at which the lock will cancel.\\n     * This is an assembly-optimized version of comparing startTime + startLock with lastTime + lastLock.\\n     * @return The time at which the lock will cancel.\\n     */\\n    function _cancelTime(uint256 _startLock, uint256 _lastLock) private view returns (uint256) {\\n        uint256 result;\\n        assembly {\\n            let s := add(sload(startTime.slot), _startLock)\\n            let l := add(sload(lastTime.slot), _lastLock)\\n            result := or(mul(lt(s, l), s), mul(iszero(lt(s, l)), l))\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibRefundable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.21;\\n\\n/// @title LibRefundable - Library for handling cancellable mint operations.\\nlibrary LibRefundable {\\n\\n    /// @dev Struct to hold data for mints.\\n    struct MintData {\\n        mapping(bytes32 => uint256) _mintAmounts;\\n        uint256[] _cancelledMints;\\n    }\\n\\n    /// @dev Custom error for mints that are not cancelled.\\n    error ErrorMintNonRefundable();\\n\\n    /// @dev Cancels a mint.\\n    /// @param self The storage reference to a MintData.\\n    /// @param mintId The ID of the mint.\\n    function cancelMint(MintData storage self, uint256 mintId, uint256 total) internal {\\n        self._mintAmounts[_mintKey(mintId, address(0))] = total;\\n        self._cancelledMints.push(mintId);\\n    }\\n\\n    /// @dev Returns all cancelled mints.\\n    /// @param self The storage reference to a MintData.\\n    function cancelledMints(MintData storage self) internal view returns (uint256[] memory) {\\n        return self._cancelledMints;\\n    }\\n\\n    /// @dev Returns the total number of cancelled mints.\\n    /// @param self The storage reference to a MintData.\\n    function totalCancelledMints(MintData storage self) internal view returns (uint256) {\\n        return self._cancelledMints.length;\\n    }\\n\\n    /// @dev Returns a cancelled mint at a specific index.\\n    /// @param self The storage reference to a MintData.\\n    /// @param index The index of the cancelled mint.\\n    function cancelledMintAtIndex(MintData storage self, uint256 index) internal view returns (uint256) {\\n        return index < self._cancelledMints.length ? self._cancelledMints[index] : 0;\\n    }\\n\\n    /// @dev Records the amount of a mint.\\n    /// @param self The storage reference to a MintData.\\n    /// @param mintId The ID of the mint.\\n    /// @param owner The address of the owner.\\n    /// @param amount The amount to record.\\n    function addRefundableAmount(MintData storage self, uint256 mintId, address owner, uint256 amount) internal {\\n        self._mintAmounts[_mintKey(mintId, owner)] += amount;\\n    }\\n\\n    /// @dev Retrieves the refundable amount of a mint.\\n    /// @param self The storage reference to a MintData.\\n    /// @param mintId The ID of the mint.\\n    /// @param owner The address of the owner.\\n    /// @return The refundable amount for the mint.\\n    function getRefundableAmount(MintData storage self, uint256 mintId, address owner) internal view returns (uint256) {\\n        return self._mintAmounts[_mintKey(mintId, owner)];\\n    }\\n\\n    /// @dev Refunds the amount of a mint.\\n    /// @param self The storage reference to a MintData.\\n    /// @param mintId The ID of the mint.\\n    /// @param owner The address of the owner.\\n    function removeRefundableAmount(MintData storage self, uint256 mintId, address owner) internal returns (uint256) {\\n        bytes32 cancelKey = _mintKey(mintId, address(0));\\n        bytes32 key = _mintKey(mintId, owner);\\n        if (self._mintAmounts[cancelKey] == 0) {\\n            revert ErrorMintNonRefundable();\\n        }\\n        uint256 refund = self._mintAmounts[key];\\n        delete self._mintAmounts[key];\\n        self._mintAmounts[cancelKey] -= refund;\\n        if (self._mintAmounts[cancelKey] == 0) {\\n            delete self._mintAmounts[cancelKey];\\n        }\\n        return refund;\\n    }\\n\\n    /// @dev Generates a key for mint.\\n    /// @param mintId The ID of the mint.\\n    /// @param owner The address of the owner.\\n    function _mintKey(uint256 mintId, address owner) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(mintId, owner));\\n    }\\n}\\n\"\r\n    },\r\n    \"LibWinners.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport {EnumerableMap} from \\\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport {LibShared} from \\\"./LibShared.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary LibWinners {\\n    using EnumerableMap for EnumerableMap.UintToUintMap;\\n    using LibShared for uint32;\\n\\n    uint256 private constant WINNER_OFFSET_ADDRESS = 96;\\n    uint32 private constant WINNER_MASK_ID = 0xFFFFFFFF;\\n    uint8 private constant WINNER_OFFSET_ID = 32;\\n\\n    struct Winner {\\n        uint256 data;\\n        uint256 tokenId;\\n        uint256 prize;\\n    }\\n\\n    struct Winners {\\n        mapping(uint256 => Winner) _winningData;\\n        EnumerableMap.UintToUintMap _gameWinners;\\n    }\\n\\n    function recordWinner(Winners storage self,\\n        uint256 tokenId,\\n        uint256 prize,\\n        uint32 gameRound,\\n        address winnerAddress\\n    ) internal {\\n        _recordWinner(self, tokenId, prize, gameRound, winnerAddress);\\n    }\\n\\n    function hasWinner(Winners storage self,\\n        uint256 tokenId\\n    ) internal view returns (bool) {\\n        return self._winningData[tokenId].data != 0;\\n    }\\n\\n    function totalWinners(Winners storage self\\n    ) internal view returns (uint256) {\\n        return self._gameWinners.length();\\n    }\\n\\n    function getWinnerAt(Winners storage self,\\n        uint256 index\\n    ) internal view returns (Winner memory) {\\n        (, uint256 tokenId) = self._gameWinners.at(index);\\n        return self._winningData[tokenId];\\n    }\\n\\n    function getWinner(Winners storage self,\\n        uint32 gameNumber\\n    ) internal view returns (Winner memory) {\\n        return _getWinner(self, gameNumber);\\n    }\\n\\n    function getWinnerId(Winners storage self,\\n        uint256 tokenId\\n    ) internal view returns (uint32) {\\n        return uint32((self._winningData[tokenId].data >> WINNER_OFFSET_ID) & WINNER_MASK_ID);\\n    }\\n\\n    function packWinnerData(Winners storage self,\\n        uint32 gameRound,\\n        address winnerAddress\\n    ) internal view returns (uint256) {\\n        return\\n            (uint256(uint160(winnerAddress)) << WINNER_OFFSET_ADDRESS) |\\n            (self._gameWinners.length() << WINNER_OFFSET_ID) |\\n            uint256(gameRound);\\n    }\\n\\n    function _recordWinner(Winners storage self,\\n        uint256 tokenId,\\n        uint256 prize,\\n        uint32 gameRound,\\n        address winnerAddress\\n    ) private {\\n        self._gameWinners.set(gameRound >> OFFSET_GAME_NUMBER, tokenId);\\n        self._winningData[tokenId] = Winner({\\n            data: packWinnerData(self, gameRound, winnerAddress),\\n            tokenId: tokenId,\\n            prize: prize\\n        });\\n    }\\n\\n    function _getWinner(Winners storage self,\\n        uint32 gameNumber\\n    ) private view returns (Winner memory) {\\n        Winner memory winner;\\n        (bool isFound, uint256 tokenId) = self._gameWinners.tryGet(gameNumber);\\n        if (!isFound) return winner;\\n        winner = self._winningData[tokenId];\\n        if (tokenId >= FORFEIT_TOKEN_ID) winner.tokenId = 0;\\n        return winner;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport {LibBitSet} from \\\"./LibBitSet.sol\\\";\\nimport {LibShared} from \\\"./LibShared.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nenum GameStatus {\\n    MINTING,\\n    PAUSING,\\n    PENDING,\\n    RUNNING,\\n    FORFEIT,\\n    WINNERS\\n}\\n\\nlibrary LibGame {\\n    using LibBitSet for LibBitSet.Set;\\n    using LibShared for uint256;\\n    using LibShared for uint32;\\n\\n    uint256 private constant GAME_OFFSET_RESET_TIME = 112;\\n    uint256 private constant GAME_OFFSET_PAUSE_TIME = 144;\\n    uint256 private constant GAME_OFFSET_ROUND_TIME = 176;\\n    uint256 private constant GAME_OFFSET_MULTI_USER = 208;\\n    uint256 private constant GAME_OFFSET_GAME_STATE = 216;\\n    uint256 private constant INFO_OFFSET_GAME_STATE = 0;\\n    uint256 private constant INFO_OFFSET_BLOCK_TIME = 8;\\n    uint256 private constant INFO_OFFSET_RESET_TIME = 40;\\n    uint256 private constant INFO_OFFSET_PAUSE_TIME = 72;\\n    uint256 private constant INFO_OFFSET_ROUND_TIME = 104;\\n    uint256 private constant INFO_OFFSET_PRIZE_POOL = 136;\\n    uint256 private constant INFO_OFFSET_GAMESTATUS = 168;\\n    uint256 private constant INFO_OFFSET_BURN_COUNT = 176;\\n    uint256 private constant INFO_OFFSET_SAFE_COUNT = 192;\\n    uint256 private constant INFO_OFFSET_LIVE_COUNT = 208;\\n    uint256 private constant INFO_OFFSET_GAME_ROUND = 224;\\n    uint256 private constant MASK_MULTI = 0xFF;\\n    uint256 private constant MASK_STATE = 0xFF;\\n    uint256 private constant MASK_BURNED = 0xFFFF;\\n    uint256 private constant MASK_TIMESTAMP = 0xFFFFFFFF;\\n    uint256 private constant MASK_PENDING = 0xFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    struct Game {\\n        uint256 data;\\n        uint256 prizePool;\\n        LibBitSet.Set[2] tokens;\\n    }\\n\\n    event GameStart(uint32 indexed gameRound);\\n    event GameOver(uint32 indexed gameRound, address winner);\\n    event GameCancelled(uint32 indexed gameRound, uint256 mintCount);\\n    event RoundStart(uint32 indexed gameRound);\\n\\n    function nextGameRound(Game storage self\\n    ) internal view returns (uint32) {\\n       return _nextGameRound(self.data);\\n    }\\n\\n    function initGame(Game storage self,\\n        uint256 startTokenId\\n    ) internal returns (uint32) {\\n        return _initGame(self, self.data, startTokenId);\\n    }\\n\\n    function startGame(Game storage self\\n    ) internal {\\n        _startGame(self);\\n    }\\n\\n    function startRound(Game storage self,\\n        uint32 gameRound\\n    ) internal {\\n        _startRound(self, gameRound);\\n    }\\n\\n    function resetGame(Game storage self,\\n        uint256 startTokenId\\n    ) internal returns (uint32) {\\n        return _resetGame(self, self.data, startTokenId);\\n    }\\n\\n    function cancelGame(Game storage self,\\n        uint256 startTokenId\\n    ) internal {\\n        uint256 data = self.data;\\n        emit GameCancelled(data.getGameRound(), data.getLiveCount());\\n        _resetGame(self, data, startTokenId);\\n    }\\n\\n    function getStatus(Game storage self\\n    )  internal view returns (GameStatus) {\\n        return _getStatus(self, self.data);\\n    }\\n\\n    function getStatus(Game storage self,\\n        uint256 data\\n    )  internal view returns (GameStatus) {\\n        return _getStatus(self, data);\\n    }\\n\\n    function isGameOver(Game storage self,\\n        uint32 gameRound\\n    ) internal view returns (uint256) {\\n        return _isGameOver(self, gameRound);\\n    }\\n\\n    function liveTokenCount(Game storage self\\n    ) internal view returns (uint16) {\\n        return _liveTokenCount(self, self.data);\\n    }\\n\\n    function virtualLiveTokenCount(Game storage self\\n    ) internal view returns (uint16) {\\n        return _virtualLiveTokenCount(self, self.data);\\n    }\\n\\n    function virtualSafeTokenCount(Game storage self\\n    ) internal view returns (uint16) {\\n        return _virtualSafeTokenCount(self, self.data);\\n    }\\n\\n    function virtualBurnTokenCount(Game storage self\\n    ) internal view returns (uint16) {\\n        return _virtualBurnTokenCount(self, self.data);\\n    }\\n\\n    function getTokenStatus(Game storage self,\\n        uint256 tokenId\\n    ) internal view returns (uint8) {\\n        return _getTokenStatus(self, tokenId);\\n    }\\n\\n    function virtualResetEndTime(Game storage self,\\n        GameStatus status\\n    ) internal view returns (uint32) {\\n        return _virtualResetEndTime(self.data, status);\\n    }\\n\\n    function gameInfo(Game storage self\\n    ) internal view returns (uint256) {\\n       return _gameInfo(self);\\n    }\\n\\n    function _nextGameRound(\\n        uint256 data\\n    ) private pure returns (uint32) {\\n        unchecked {\\n            return (data.getGameRound() + (uint32(1) << OFFSET_GAME_NUMBER)) | 1;\\n        }\\n    }\\n\\n    function _initGame(Game storage self,\\n        uint256 data,\\n        uint256 startTokenId\\n    ) private returns (uint32)  {\\n        uint256 gameRound = _nextGameRound(data);\\n        self.data = gameRound << DATA_OFFSET_GAME_ROUND;\\n        self.tokens[0].offset = self.tokens[1].offset = startTokenId;\\n        return uint32(gameRound);\\n    }\\n\\n    function _startGame(Game storage self\\n    ) private {\\n        uint256 data = self.data;\\n        data = _clearEndTimes(data) | (GAME_STATE_STARTED << GAME_OFFSET_GAME_STATE);\\n        self.data = data;\\n        emit GameStart(data.getGameRound());\\n    }\\n\\n    function _startRound(Game storage self,\\n        uint32 gameRound\\n    ) private {\\n        uint256 data = self.data;\\n        if (block.timestamp <= roundEndTime(data)) return;\\n        unchecked {\\n            LibBitSet.Set[2] storage tokens = self.tokens;\\n            if (data.getGameRound() != gameRound) {\\n                uint8 prevIndex = data.getLiveIndex();\\n                data = data.addBurnCount(uint16(tokens[prevIndex].length()));\\n                delete tokens[prevIndex];\\n                tokens[prevIndex].offset = tokens[1 - prevIndex].offset;\\n                data = data.setGameRound(gameRound);\\n            }\\n            data = _clearMultiUser(data);\\n            self.data = setRoundEndTime(data, block.timestamp +\\n                LibShared.max(tokens[gameRound.liveIndex()].length() << TOKEN_DELAY_ROUND, MIN_ROUND_TIME));\\n            emit RoundStart(gameRound);\\n        }\\n    }\\n\\n    function _resetGame(Game storage self,\\n        uint256 data,\\n        uint256 startTokenId\\n    ) private returns (uint32) {\\n        self.prizePool = 0;\\n        delete self.tokens;\\n        self.tokens[0].offset = self.tokens[1].offset = startTokenId;\\n        return _initGame(self, data.clearRound(), startTokenId);\\n    }\\n\\n    function _getStatus(Game storage self,\\n        uint256 data\\n    ) private view returns (GameStatus) {\\n        uint256 pauseTime = pauseEndTime(data);\\n        uint256 resetTime = resetEndTime(data);\\n        if (block.timestamp > pauseTime && (resetTime > 0 && block.timestamp <= resetTime)) {\\n            return GameStatus.WINNERS;\\n        }\\n        if (gameState(data) == GAME_STATE_OFFLINE) {\\n            return GameStatus.MINTING;\\n        }\\n        if (_isPending(data)) {\\n            return GameStatus.PENDING;\\n        }\\n        uint256 roundTime = roundEndTime(data);\\n        if (roundTime != 0 && block.timestamp <= roundTime && self.tokens[data.getLiveIndex()].length() > 1) {\\n            return GameStatus.RUNNING;\\n        }\\n        if (isMultiUser(data)) {\\n            if ((roundTime == 0 || block.timestamp > roundTime) && (pauseTime > 0 && block.timestamp <= pauseTime)) {\\n                return GameStatus.PAUSING;\\n            }\\n            return (pauseTime > 0 && block.timestamp > pauseTime && roundTime < pauseTime) ?\\n                GameStatus.PENDING : GameStatus.RUNNING;\\n        }\\n        return self.tokens[data.getSafeIndex()].length() == 0 ?\\n            GameStatus.FORFEIT : GameStatus.WINNERS;\\n    }\\n\\n    function _liveTokenCount(Game storage self,\\n        uint256 data\\n    ) private view returns (uint16) {\\n        return uint16(self.tokens[data.getLiveIndex()].length());\\n    }\\n\\n    function _safeTokenCount(Game storage self,\\n        uint256 data\\n    ) private view returns (uint16) {\\n        return uint16(self.tokens[data.getSafeIndex()].length());\\n    }\\n\\n    function _virtualLiveTokenCount(Game storage self,\\n        uint256 data\\n    ) private view returns (uint16) {\\n        if ((gameState(data) == GAME_STATE_OFFLINE) ||\\n            (block.timestamp <= roundEndTime(data)) ||\\n            _isPending(data)) {\\n            return _liveTokenCount(self, data);\\n        }\\n        return 0;\\n    }\\n\\n    function _virtualSafeTokenCount(Game storage self,\\n        uint256 data\\n    ) private view returns (uint16) {\\n        if (gameState(data) == GAME_STATE_OFFLINE) {\\n            return 0;\\n        }\\n        return _safeTokenCount(self, data);\\n    }\\n\\n    function _virtualBurnTokenCount(Game storage self,\\n        uint256 data\\n    ) private view returns (uint16) {\\n        uint16 burnCount = data.getBurnCount();\\n        if ((gameState(data) == GAME_STATE_STARTED) &&\\n            (block.timestamp > roundEndTime(data)) &&\\n            !_isPending(data)) {\\n            burnCount += _liveTokenCount(self, data);\\n        }\\n        return burnCount;\\n    }\\n\\n    function _getTokenStatus(Game storage self,\\n        uint256 tokenId\\n    ) private view returns (uint8) {\\n        if (tokenId < self.tokens[0].offset) return TOKEN_STATUS_BANNED;\\n        uint256 data = self.data;\\n        if (gameState(data) == GAME_STATE_OFFLINE) return TOKEN_STATUS_QUEUED;\\n        if (_virtualLiveTokenCount(self, data) > 1 && self.tokens[data.getLiveIndex()].contains(tokenId)) {\\n            return TOKEN_STATUS_ACTIVE;\\n        }\\n        return (self.tokens[data.getSafeIndex()].contains(tokenId)) ? TOKEN_STATUS_SECURE : TOKEN_STATUS_BURNED;\\n    }\\n\\n    function _isGameOver(Game storage self,\\n        uint32 gameRound\\n    ) private view returns (uint256) {\\n        GameStatus status = _getStatus(self, self.data);\\n        if (status < GameStatus.FORFEIT) return LibBitSet.NOT_FOUND;\\n        if (status == GameStatus.FORFEIT) return FORFEIT_TOKEN_ID + (gameRound >> OFFSET_GAME_NUMBER);\\n        return self.tokens[gameRound.safeIndex()].findFirst();\\n    }\\n\\n    function _virtualResetEndTime(\\n        uint256 data,\\n        GameStatus status\\n    ) private pure returns (uint32) {\\n        uint32 resetTime = resetEndTime(data);\\n        if (status > GameStatus.RUNNING && resetTime == 0) {\\n            return roundEndTime(data) + MIN_RESET_TIME;\\n        }\\n        return resetTime;\\n    }\\n\\n    function _gameInfo(Game storage self\\n    ) private view returns (uint256) {\\n        uint256 data = self.data;\\n        GameStatus status = _getStatus(self, data);\\n        uint256 prizePool = self.prizePool / WEI;\\n        uint32 gameRound = data.getGameRound();\\n        uint256 state = gameState(data);\\n        uint32 roundTime = roundEndTime(data);\\n        uint32 pauseTime = pauseEndTime(data);\\n        uint32 resetTime = resetEndTime(data);\\n        uint16 liveCount = _virtualLiveTokenCount(self, data);\\n        uint16 safeCount = _virtualSafeTokenCount(self, data);\\n        uint16 burnCount = _virtualBurnTokenCount(self, data);\\n        if (status == GameStatus.RUNNING) {\\n            pauseTime = resetTime = 0;\\n        }\\n        if ((status == GameStatus.PAUSING || status == GameStatus.PENDING) && pauseTime != 0) {\\n            unchecked { gameRound++; }\\n            (liveCount, safeCount) = (safeCount, 0);\\n            roundTime = resetTime = 0;\\n            if (block.timestamp > pauseTime) {\\n                pauseTime = 0;\\n            }\\n        }\\n        if (status == GameStatus.PENDING) {\\n            roundTime = pauseTime = resetTime = 0;\\n        }\\n        if (status > GameStatus.RUNNING) {\\n            roundTime = pauseTime = 0;\\n            if (resetTime == 0) {\\n                resetTime = _virtualResetEndTime(data, status);\\n                state = GAME_STATE_VIRTUAL;\\n            }\\n            if (resetTime != 0 && block.timestamp > resetTime) {\\n                status = GameStatus.MINTING;\\n                gameRound = _nextGameRound(data);\\n                prizePool = roundTime = pauseTime = liveCount = safeCount = burnCount = 0;\\n            }\\n        }\\n        uint256 info = (state << INFO_OFFSET_GAME_STATE);\\n        info |=\\n            (uint256(block.timestamp) << INFO_OFFSET_BLOCK_TIME) |\\n            (uint256(resetTime) << INFO_OFFSET_RESET_TIME) |\\n            (uint256(pauseTime) << INFO_OFFSET_PAUSE_TIME) |\\n            (uint256(roundTime) << INFO_OFFSET_ROUND_TIME) |\\n            (prizePool << INFO_OFFSET_PRIZE_POOL) |\\n            (uint256(status) << INFO_OFFSET_GAMESTATUS);\\n        info |=\\n            (uint256(burnCount) << INFO_OFFSET_BURN_COUNT) |\\n            (uint256(safeCount) << INFO_OFFSET_SAFE_COUNT) |\\n            (uint256(liveCount) << INFO_OFFSET_LIVE_COUNT) |\\n            (uint256(gameRound) << INFO_OFFSET_GAME_ROUND);\\n        return info;\\n    }\\n\\n    function gameState(uint256 data) internal pure returns (uint8) {\\n        return uint8((data >> GAME_OFFSET_GAME_STATE) & MASK_STATE);\\n    }\\n\\n    function setMultiUser(uint256 data) internal pure returns (uint256) {\\n        return _clearMultiUser(data) | (1 << GAME_OFFSET_MULTI_USER);\\n    }\\n\\n    function isMultiUser(uint256 data) internal pure returns (bool) {\\n        return uint8((data >> GAME_OFFSET_MULTI_USER) & MASK_MULTI) == 1;\\n    }\\n\\n    function hasPauseExpired(uint256 data) internal view returns (bool) {\\n        uint32 pauseTime = pauseEndTime(data);\\n        return (pauseTime > 0 && block.timestamp > pauseTime && roundEndTime(data) < pauseTime);\\n    }\\n\\n    function roundEndTime(uint256 data) internal pure returns (uint32) {\\n        return uint32((data >> GAME_OFFSET_ROUND_TIME) & MASK_TIMESTAMP);\\n    }\\n\\n    function setRoundEndTime(uint256 data, uint256 time) internal pure returns (uint256) {\\n        return clearRoundEndTime(data) | (time << GAME_OFFSET_ROUND_TIME);\\n    }\\n\\n    function clearRoundEndTime(uint256 data) internal pure returns (uint256) {\\n        return (data & ~(MASK_TIMESTAMP << GAME_OFFSET_ROUND_TIME));\\n    }\\n\\n    function pauseEndTime(uint256 data) internal pure returns (uint32) {\\n        return uint32((data >> GAME_OFFSET_PAUSE_TIME) & MASK_TIMESTAMP);\\n    }\\n\\n    function setPauseEndTime(uint256 data, uint256 time) internal pure returns (uint256) {\\n        return clearPauseEndTime(data) | (time << GAME_OFFSET_PAUSE_TIME);\\n    }\\n\\n    function clearPauseEndTime(uint256 data) internal pure returns (uint256) {\\n        return (data & ~(MASK_TIMESTAMP << GAME_OFFSET_PAUSE_TIME));\\n    }\\n\\n    function resetEndTime(uint256 data) internal pure returns (uint32) {\\n        return uint32((data >> GAME_OFFSET_RESET_TIME) & MASK_TIMESTAMP);\\n    }\\n\\n    function setResetEndTime(uint256 data, uint256 time) internal pure returns (uint256) {\\n        return clearPauseEndTime(data) | (time << GAME_OFFSET_RESET_TIME);\\n    }\\n\\n    function clearResetEndTime(uint256 data) internal pure returns (uint256) {\\n        return (data & ~(MASK_TIMESTAMP << GAME_OFFSET_RESET_TIME));\\n    }\\n\\n    function _clearMultiUser(uint256 data) private pure returns (uint256) {\\n        return (data & ~(MASK_MULTI << GAME_OFFSET_MULTI_USER));\\n    }\\n\\n    function _clearEndTimes(uint256 data) private pure returns (uint256) {\\n        return (data & ~(MASK_PENDING << GAME_OFFSET_RESET_TIME));\\n    }\\n\\n    function _isPending(uint256 data) private pure returns (bool) {\\n        return ((data >> GAME_OFFSET_RESET_TIME) & MASK_PENDING) == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport {LibShared} from \\\"./LibShared.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary LibConfig {\\n\\n    uint256 private constant CONFIG_OFFSET_MAX_TOKENS = 0;\\n    uint256 private constant CONFIG_OFFSET_MAX_WALLET = 16;\\n    uint256 private constant CONFIG_OFFSET_MAX_TX = 32;\\n    uint256 private constant CONFIG_OFFSET_FREE = 48;\\n    uint256 private constant CONFIG_OFFSET_TEAM_SPLIT = 88;\\n    uint256 private constant CONFIG_OFFSET_TEAM_ADDRESS = 96;\\n    uint256 private constant MASK_MAX_TX = 0xFFFF;\\n    uint256 private constant MASK_MAX_WALLET = 0xFFFF;\\n    uint256 private constant MASK_MAX_TOKENS = 0xFFFF;\\n    uint256 private constant MASK_TEAM_SPLIT = 0xFF;\\n\\n    struct Config {\\n        uint256 tokenPrice;\\n        uint256 data;\\n        address drawAddress;\\n    }\\n\\n    error ErrorMaxTokens();\\n    error ErrorTokenPrice();\\n    error ErrorMaxWallet();\\n    error ErrorMaxTx();\\n    error ErrorTeamAddress();\\n    error ErrorDrawAddress();\\n    error ErrorTeamSplit();\\n\\n    function initConfig(Config storage self,\\n        uint256 _tokenPrice,\\n        uint16 _maxTokens,\\n        uint16 _maxWallet,\\n        uint16 _maxTx,\\n        uint8 _teamSplit,\\n        address _teamAddress,\\n        address _drawAddress\\n    ) internal {\\n        if (_tokenPrice == 0) revert ErrorTokenPrice();\\n        if ((_maxTokens < MIN_TOKENS) || (_maxTokens > MAX_TOKENS)) revert ErrorMaxTokens();\\n        if ((_maxWallet == 0) || (_maxWallet > _maxTokens)) revert ErrorMaxWallet();\\n        if ((_maxTx == 0) || (_maxTx > _maxWallet)) revert ErrorMaxTx();\\n        if (_teamSplit > MAX_TEAM_SPLIT) revert ErrorTeamSplit();\\n        if (_teamAddress == address(0)) revert ErrorTeamAddress();\\n        if (_drawAddress == address(0)) revert ErrorDrawAddress();\\n        self.tokenPrice = _tokenPrice;\\n        self.data |=\\n            (uint256(_maxTokens)            << CONFIG_OFFSET_MAX_TOKENS) |\\n            (uint256(_maxWallet)            << CONFIG_OFFSET_MAX_WALLET) |\\n            (uint256(_maxTx)                << CONFIG_OFFSET_MAX_TX)     |\\n            (uint256(_teamSplit)            << CONFIG_OFFSET_TEAM_SPLIT) |\\n            (uint256(uint160(_teamAddress)) << CONFIG_OFFSET_TEAM_ADDRESS);\\n        self.drawAddress = _drawAddress;\\n    }\\n\\n    function setAddresses(Config storage self,\\n        address _teamAddress,\\n        address _drawAddress\\n    ) internal {\\n        if (_teamAddress == address(0)) revert ErrorTeamAddress();\\n        if (_drawAddress == address(0)) revert ErrorDrawAddress();\\n        self.data |= uint256(uint160(_teamAddress)) << CONFIG_OFFSET_TEAM_ADDRESS;\\n        self.drawAddress = _drawAddress;\\n    }\\n\\n    function teamAddress(Config storage self\\n    ) internal view returns (address) {\\n        return teamAddress(self.data);\\n    }\\n\\n    function teamSplit(Config storage self\\n    ) internal view returns (uint8) {\\n        return teamSplit(self.data);\\n    }\\n\\n    function maxTx(Config storage self\\n    ) internal view returns (uint16) {\\n        return maxTx(self.data);\\n    }\\n\\n    function maxWallet(Config storage self\\n    ) internal view returns (uint16) {\\n        return maxWallet(self.data);\\n    }\\n\\n    function maxTokens(Config storage self\\n    ) internal view returns (uint16) {\\n        return maxTokens(self.data);\\n    }\\n\\n    function teamAddress(uint256 data) internal pure returns (address) {\\n        return address(uint160(data >> CONFIG_OFFSET_TEAM_ADDRESS));\\n    }\\n\\n    function teamSplit(uint256 data) internal pure returns (uint8) {\\n        return uint8((data >> CONFIG_OFFSET_TEAM_SPLIT) & MASK_TEAM_SPLIT);\\n    }\\n\\n    function maxTx(uint256 data) internal pure returns (uint16) {\\n        return uint16((data >> CONFIG_OFFSET_MAX_TX) & MASK_MAX_TX);\\n    }\\n\\n    function maxWallet(uint256 data) internal pure returns (uint16) {\\n        return uint16((data >> CONFIG_OFFSET_MAX_WALLET) & MASK_MAX_WALLET);\\n    }\\n\\n    function maxTokens(uint256 data) internal pure returns (uint16) {\\n        return uint16((data >> CONFIG_OFFSET_MAX_TOKENS) & MASK_MAX_TOKENS);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibShared.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary LibShared {\\n\\n    uint256 internal constant MASK_GAME_ROUND = 0xFFFFFFFF;\\n    uint256 internal constant MASK_GAME_NUMBER = 0xFFFFFF;\\n    uint256 internal constant MASK_COUNT = 0xFFFF;\\n    uint256 internal constant MASK_ROUND = 0xFF;\\n\\n    function liveIndex(uint32 n) internal pure returns (uint8) {\\n        return uint8((n + 1) & 1);\\n    }\\n\\n    function safeIndex(uint32 n) internal pure returns (uint8) {\\n        return uint8(n & 1);\\n    }\\n\\n    function getLiveIndex(uint256 data) internal pure returns (uint8) {\\n        return liveIndex(uint32((data >> DATA_OFFSET_ROUND_COUNT) & MASK_ROUND));\\n    }\\n\\n    function getSafeIndex(uint256 data) internal pure returns (uint8) {\\n        return safeIndex(uint32((data >> DATA_OFFSET_ROUND_COUNT) & MASK_ROUND));\\n    }\\n\\n    function getGameNumber(uint256 data) internal pure returns (uint32) {\\n        return uint32((data >> DATA_OFFSET_GAME_NUMBER) & MASK_GAME_NUMBER);\\n    }\\n\\n    function getGameRound(uint256 data) internal pure returns (uint32) {\\n        return uint32((data >> DATA_OFFSET_GAME_ROUND) & MASK_GAME_ROUND);\\n    }\\n\\n    function setGameRound(uint256 data, uint32 gameRound) internal pure returns (uint256) {\\n        return (data & ~(MASK_GAME_ROUND << DATA_OFFSET_GAME_ROUND)) |\\n            (uint256(gameRound) << DATA_OFFSET_GAME_ROUND);\\n    }\\n\\n    function clearRound(uint256 data) internal pure returns (uint256) {\\n        return (data & ~(MASK_ROUND << DATA_OFFSET_ROUND_COUNT));\\n    }\\n\\n    function getLiveCount(uint256 data) internal pure returns (uint16) {\\n        return uint16((data >> DATA_OFFSET_LIVE_COUNT) & MASK_COUNT);\\n    }\\n\\n    function addLiveCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        unchecked {\\n            return data + (uint256(count) << DATA_OFFSET_LIVE_COUNT);\\n        }\\n    }\\n\\n    function subLiveCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        unchecked {\\n            return data - (uint256(count) << DATA_OFFSET_LIVE_COUNT);\\n        }\\n    }\\n\\n    function setLiveCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        return clearLiveCount(data) | (uint256(count) << DATA_OFFSET_LIVE_COUNT);\\n    }\\n\\n    function clearLiveCount(uint256 data) internal pure returns (uint256) {\\n        return data & ~(MASK_COUNT << DATA_OFFSET_LIVE_COUNT);\\n    }\\n\\n    function getSafeCount(uint256 data) internal pure returns (uint16) {\\n        return uint16((data >> DATA_OFFSET_SAFE_COUNT) & MASK_COUNT);\\n    }\\n\\n    function addSafeCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        unchecked {\\n            return data + (uint256(count) << DATA_OFFSET_SAFE_COUNT);\\n        }\\n    }\\n\\n    function subSafeCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        unchecked {\\n            return data - (uint256(count) << DATA_OFFSET_SAFE_COUNT);\\n        }\\n    }\\n\\n    function setSafeCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        return clearSafeCount(data) | (uint256(count) << DATA_OFFSET_SAFE_COUNT);\\n    }\\n\\n    function clearSafeCount(uint256 data) internal pure returns (uint256) {\\n        return data & ~(MASK_COUNT << DATA_OFFSET_SAFE_COUNT);\\n    }\\n\\n    function getBurnCount(uint256 data) internal pure returns (uint16) {\\n        return uint16(data);\\n    }\\n\\n    function addBurnCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        unchecked {\\n            return data + count;\\n        }\\n    }\\n\\n    function setBurnCount(uint256 data, uint16 count) internal pure returns (uint256) {\\n        return clearBurnCount(data) | uint256(count);\\n    }\\n\\n    function clearBurnCount(uint256 data) internal pure returns (uint256) {\\n        return data & ~MASK_COUNT;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibBitSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.21;\\n\\nimport {LibBit} from \\\"solady/src/utils/LibBit.sol\\\";\\n\\ninterface ILibBitSet64Filter {\\n    function isTokenOwner(address owner, uint256 idx) external view returns (bool);\\n}\\n\\nlibrary LibBitSet {\\n\\n    uint256 public constant NOT_FOUND = type(uint256).max;\\n    uint256 private constant MAX_MASK = type(uint256).max;\\n    uint256 private constant MAX_INDEX = 16383;\\n    uint256 private constant MAX_LENGTH = 64;\\n    uint16 public constant MAX_POP_COUNT = 256;\\n    uint16 private constant MASK_SET_COUNT = 0xFFFF;\\n    uint8 private constant MAX_BIT_COUNT = 255;\\n    uint8 private constant MASK_BIT_COUNT = 0xFF;\\n    uint8 private constant INDEX_SHIFT = 8;\\n    uint8 private constant INDEX_MASK = 0xFF;\\n    uint8 private constant INDEX_NOT_FOUND = 0xFF;\\n    uint8 private constant OFFSET_BUCKET_FLAGS = 192;\\n\\n    struct Set {\\n        uint256 offset;\\n        uint256 count;\\n        uint256[2] popCounts;\\n        uint256[64] map;\\n    }\\n\\n    function add(Set storage self,\\n        uint256 tokenId\\n    ) internal returns (uint256) {\\n        uint256 count = self.count;\\n        unchecked {\\n            tokenId -= self.offset;\\n            if (tokenId > MAX_INDEX) return uint16(count);\\n            uint8 bucket = uint8(tokenId >> INDEX_SHIFT);\\n            uint256 bitIndex = tokenId & INDEX_MASK;\\n            uint256 mask = 1 << bitIndex;\\n            uint256 bitmap = self.map[bucket];\\n            if ((bitmap & mask) == 0) {\\n                bitmap |= mask;\\n                self.map[bucket] = bitmap;\\n                if (bitmap != MAX_MASK) {\\n                    _addPopCount(self, bucket, 1);\\n                }\\n                count = ((count & ~(1 << (bucket + OFFSET_BUCKET_FLAGS))) ^\\n                    (((~(bitmap + 1) & bitmap) >> MAX_BIT_COUNT) << (bucket + OFFSET_BUCKET_FLAGS))) + 1;\\n                self.count = count;\\n            }\\n        }\\n        return uint16(count);\\n    }\\n\\n    function addBatch(Set storage self,\\n        uint256 startId,\\n        uint256 amount\\n    ) internal {\\n        unchecked {\\n            startId -= self.offset;\\n            if (startId > MAX_INDEX) return;\\n            uint256[2] memory popCounts = self.popCounts;\\n            uint256 mask = 0;\\n            uint256 delta = 0;\\n            uint256 count = self.count + amount;\\n            uint8 bits = 0;\\n            uint8 bucket = uint8(startId >> INDEX_SHIFT);\\n            uint8 shift = uint8(startId & INDEX_MASK);\\n            while (amount > 0) {\\n                delta = MAX_POP_COUNT - shift;\\n                if (amount >= delta) {\\n                    mask = MAX_MASK << shift;\\n                    bits = MAX_BIT_COUNT - shift;\\n                    count |= (1 << (bucket + OFFSET_BUCKET_FLAGS));\\n                    amount -= delta;\\n                    shift = 0;\\n                } else {\\n                    mask = ((1 << amount) - 1) << shift;\\n                    bits = uint8(amount);\\n                    count &= ~(1 << (bucket + OFFSET_BUCKET_FLAGS));\\n                    amount = 0;\\n                }\\n                _addPopCounts(popCounts, bucket, bits);\\n                self.map[bucket] |= mask;\\n                bucket++;\\n            }\\n            self.popCounts = popCounts;\\n            self.count = count;\\n        }\\n    }\\n\\n    function remove(Set storage self,\\n        uint256 tokenId\\n    ) internal returns (bool) {\\n        unchecked {\\n            tokenId -= self.offset;\\n            uint8 bucket = uint8(tokenId >> INDEX_SHIFT);\\n            if (bucket >= MAX_LENGTH) return false;\\n            uint256 bitmap = self.map[bucket];\\n            uint256 mask = 1 << (tokenId & INDEX_MASK);\\n            if ((bitmap & mask) == 0) return false;\\n            uint256 count = self.count;\\n            uint256 offset = bucket + OFFSET_BUCKET_FLAGS;\\n            if (((count >> offset) & 1) == 0) {\\n                _subPopCount(self, bucket, 1);\\n            }\\n            self.count = (count - 1) & ~(1 << offset);\\n            self.map[bucket] = bitmap & ~mask;\\n            return true;\\n        }\\n    }\\n\\n    function removeAt(Set storage self,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        uint256 count = self.count;\\n        if (index >= uint16(count)) return NOT_FOUND;\\n        uint256[2] memory popCounts = self.popCounts;\\n        (uint256 bucket, uint16 remaining) = _positionOfIndex(count, popCounts, uint16(index));\\n        if (bucket == INDEX_NOT_FOUND) return NOT_FOUND;\\n        uint256 bit;\\n        uint256 pos;\\n        uint256 offset;\\n        uint256 bitmap = self.map[bucket];\\n        unchecked {\\n            while (bitmap != 0) {\\n                bit = bitmap & (~bitmap + 1);\\n                pos = LibBit.fls(bit);\\n                if (remaining == 0) {\\n                    offset = bucket + OFFSET_BUCKET_FLAGS;\\n                    if (((count >> offset) & 1) == 0) {\\n                        _subPopCounts(popCounts, uint8(bucket), 1);\\n                        self.popCounts = popCounts;\\n                    }\\n                    self.count = (count - 1) & ~(1 << offset);\\n                    self.map[bucket] ^= bit;\\n                    return ((bucket << INDEX_SHIFT) | pos) + self.offset;\\n                }\\n                remaining--;\\n                bitmap ^= bit;\\n            }\\n        }\\n        return NOT_FOUND;\\n    }\\n\\n    function contains(Set storage self,\\n        uint256 tokenId\\n    ) internal view returns (bool isSet) {\\n        unchecked {\\n            tokenId -= self.offset;\\n            uint256 bucket = tokenId >> INDEX_SHIFT;\\n            if (bucket >= MAX_LENGTH) return false;\\n            uint256 bit = (self.map[bucket] >> (tokenId & INDEX_MASK)) & 1;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                isSet := bit\\n            }\\n        }\\n    }\\n\\n    function at(Set storage self,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        if (index >= uint16(self.count)) return NOT_FOUND;\\n        uint256 len = 0;\\n        uint256 bitmap;\\n        uint256 bitsCount;\\n        uint256 remaining;\\n        uint256 bucket;\\n        uint256 bit;\\n        uint256 pos;\\n        unchecked {\\n            for (bucket = 0; bucket < MAX_LENGTH; ++bucket) {\\n                bitmap = self.map[bucket];\\n                bitsCount = LibBit.popCount(bitmap);\\n                if (len + bitsCount > index) {\\n                    remaining = index - len;\\n                    while (bitmap != 0) {\\n                        bit = bitmap & (~bitmap + 1);\\n                        pos = LibBit.fls(bit);\\n                        if (remaining == 0) {\\n                            return ((bucket << INDEX_SHIFT) | pos) + self.offset;\\n                        }\\n                        remaining--;\\n                        bitmap ^= bit;\\n                    }\\n                }\\n                len += bitsCount;\\n            }\\n        }\\n        return NOT_FOUND;\\n    }\\n\\n    function findFirst(Set storage self\\n    ) internal view returns (uint256) {\\n        if (self.count == 0) return NOT_FOUND;\\n        uint256 bitmap;\\n        uint256 lsb;\\n        unchecked {\\n            for (uint256 bucket = 0; bucket < MAX_LENGTH; bucket++) {\\n                bitmap = self.map[bucket];\\n                if (bitmap != 0) {\\n                    lsb = LibBit.ffs(bitmap);\\n                    return (bucket << INDEX_SHIFT | lsb) + self.offset;\\n                }\\n            }\\n        }\\n        return NOT_FOUND;\\n    }\\n\\n    function findFirstOfOwner(Set storage self,\\n        address owner,\\n        ILibBitSet64Filter filter\\n    ) internal view returns (uint256) {\\n        uint256 count = self.count;\\n        if (count == 0) return NOT_FOUND;\\n        unchecked {\\n            uint256 offset = self.offset;\\n            uint256 bitmap;\\n            uint256 tokenId;\\n            uint256 pos;\\n            for (uint256 bucket = 0; bucket < MAX_LENGTH; bucket++) {\\n                bitmap = self.map[bucket];\\n                while (bitmap != 0) {\\n                    pos = LibBit.ffs(bitmap);\\n                    tokenId = ((bucket << INDEX_SHIFT) | pos) + offset;\\n                    if (filter.isTokenOwner(owner, tokenId)) return tokenId;\\n                    bitmap &= ~(1 << pos);\\n                }\\n            }\\n        }\\n        return NOT_FOUND;\\n    }\\n\\n    function findNearest(Set storage self,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        if (self.count == 0) return NOT_FOUND;\\n        unchecked {\\n            index -= self.offset;\\n            uint256 bucket = index >> INDEX_SHIFT;\\n            uint256 bitIndex = index & INDEX_MASK;\\n            uint256 bitmap = bucket < MAX_LENGTH ? self.map[bucket] : 0;\\n            if ((bitmap >> bitIndex) & 1 == 1) {\\n                return index + self.offset;\\n            }\\n            for (uint256 i = bucket; i < MAX_LENGTH; i++) {\\n                bitmap = self.map[i];\\n                if (bitmap != 0) {\\n                    return (i << INDEX_SHIFT) | LibBit.fls(bitmap) + self.offset;\\n                }\\n            }\\n        }\\n        return NOT_FOUND;\\n    }\\n\\n    function findLast(Set storage self) internal view returns (uint256) {\\n        if (self.count == 0) return NOT_FOUND;\\n        for (uint256 bucket = MAX_LENGTH; bucket > 0; bucket--) {\\n            if (self.map[bucket - 1] != 0) {\\n                uint256 bitIndex = LibBit.fls(self.map[bucket - 1]);\\n                return ((bucket - 1) << INDEX_SHIFT) + bitIndex + self.offset;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function mapRange(Set storage self\\n    ) internal view returns (uint256 start, uint256 len) {\\n        unchecked {\\n            for (uint256 i = 0; i < MAX_LENGTH; i++) {\\n                if (self.map[i] != 0) {\\n                    start = (i << INDEX_SHIFT) + LibBit.ffs(self.map[i]);\\n                    break;\\n                }\\n            }\\n            for (uint256 i = MAX_LENGTH; i > 0; i--) {\\n                if (self.map[i - 1] != 0) {\\n                    len = ((i - 1) << INDEX_SHIFT) + LibBit.fls(self.map[i - 1]);\\n                    break;\\n                }\\n            }\\n            len += 1;\\n        }\\n        return (start, len);\\n    }\\n\\n    function getRange(Set storage self,\\n        uint256 start,\\n        uint256 stop\\n    ) internal view returns (uint256[] memory) {\\n        unchecked {\\n            uint256 count = uint16(self.count);\\n            stop = (stop > count) ? count : stop;\\n            uint256 startBucket = (start - self.offset) >> INDEX_SHIFT;\\n            uint256 endBucket = (stop - self.offset) >> INDEX_SHIFT;\\n            uint256 arraySize = stop - start + 1;\\n            uint256[] memory result = new uint256[](arraySize);\\n            uint256 resultIndex = 0;\\n            uint256 bucketBits;\\n            for (uint256 i = startBucket; i <= endBucket && i < MAX_LENGTH; ++i) {\\n                bucketBits = self.map[i];\\n                if (bucketBits == 0) continue;\\n                for (uint256 j = 0; j < MAX_POP_COUNT; ++j) {\\n                    uint256 bitIndex = (i << INDEX_SHIFT) + j + self.offset;\\n                    if (bitIndex < start) continue;\\n                    if (bitIndex > stop) break;\\n\\n                    if ((bucketBits & (1 << j)) != 0) {\\n                        result[resultIndex++] = bitIndex;\\n                    }\\n                }\\n            }\\n            if (resultIndex < arraySize) {\\n                assembly {\\n                    mstore(result, resultIndex)\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n\\n    function rangeLength(Set storage self\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 bitmap;\\n            for (uint256 bucket = (MAX_LENGTH - 1); bucket >= 0; bucket--) {\\n                bitmap = self.map[bucket];\\n                if (bitmap != 0) {\\n                    return (bucket << INDEX_SHIFT) + LibBit.fls(bitmap) + 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function mapLength(Set storage /*self*/\\n    ) internal pure returns (uint256) {\\n        return MAX_LENGTH;\\n    }\\n\\n    function length(Set storage self\\n    ) internal view returns (uint256) {\\n        return self.count & MASK_SET_COUNT;\\n    }\\n\\n    function trim(Set storage self\\n    ) internal {\\n        uint256 len = self.map.length;\\n        while (len > 0 && self.map[len - 1] == 0) {\\n            delete self.map[--len];\\n        }\\n    }\\n\\n    function values(Set storage self\\n    ) internal view returns (uint256[] memory result) {\\n        result = new uint256[](uint16(self.count));\\n        uint256 index = 0;\\n        uint256 offset = self.offset;\\n        for (uint256 i = 0; i < MAX_LENGTH; i++) {\\n            uint256 bucket = self.map[i];\\n            if (bucket == 0) continue;\\n            for (uint256 j = 0; j < MAX_POP_COUNT; j++) {\\n                if ((bucket & (1 << j)) == 0) continue;\\n                result[index] = ((i << INDEX_SHIFT) | j) + offset;\\n                index++;\\n            }\\n        }\\n    }\\n\\n    function _addPopCount(Set storage self,\\n        uint8 slot,\\n        uint8 amount\\n    ) private {\\n        unchecked {\\n            self.popCounts[slot >> 5] += uint256(amount & INDEX_MASK) << ((slot & 31) << 3);\\n        }\\n    }\\n\\n    function _addPopCounts(\\n        uint256[2] memory popCounts,\\n        uint8 slot,\\n        uint8 amount\\n    ) private pure {\\n        unchecked {\\n            popCounts[slot >> 5] += uint256(amount & INDEX_MASK) << ((slot & 31) << 3);\\n        }\\n    }\\n\\n    function _subPopCount(Set storage self,\\n        uint8 slot,\\n        uint8 amount\\n    ) private {\\n        unchecked {\\n            self.popCounts[slot >> 5] -= uint256(amount & INDEX_MASK) << ((slot & 31) << 3);\\n        }\\n    }\\n\\n    function _subPopCounts(\\n        uint256[2] memory popCounts,\\n        uint8 slot,\\n        uint8 amount\\n    ) private pure {\\n        unchecked {\\n            popCounts[slot >> 5] -= uint256(amount & INDEX_MASK) << ((slot & 31) << 3);\\n        }\\n    }\\n\\n    function _getPopCount(\\n        uint256 count,\\n        uint256[2] memory popCounts,\\n        uint256 slot\\n    ) private pure returns (uint16) {\\n        return ((count >> (slot + OFFSET_BUCKET_FLAGS)) & 1) == 1 ?\\n            MAX_POP_COUNT :\\n            uint16((popCounts[slot >> 5] >> ((slot & 31) << 3)) & MASK_BIT_COUNT);\\n    }\\n\\n    function _positionOfIndex(\\n        uint256 count,\\n        uint256[2] memory popCounts,\\n        uint16 index\\n    ) private pure returns (uint8 bucket, uint16 /*pos*/) {\\n        unchecked {\\n            if (index > uint16(count)) return (INDEX_NOT_FOUND, 0);\\n            uint16 total = 0;\\n            uint16 popCount = 0;\\n            uint16 next = 0;\\n            for (bucket = 0; bucket < MAX_LENGTH; ++bucket) {\\n                popCount = _getPopCount(count, popCounts, bucket);\\n                next = total + popCount;\\n                if (next > index) return (bucket, index - total);\\n                total = next;\\n            }\\n            return (INDEX_NOT_FOUND, 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\\n        if (smallString == bytes32(0)) return result;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n\\n            for {} 1 {} {\\n                n := add(n, 1)\\n                if iszero(byte(n, smallString)) { break } // Scan for '\\\\0'.\\n            }\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, smallString)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`. For short strings up to 32 bytes.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let x := and(b, add(not(b), 1))\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibPRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for generating pseudorandom numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\\nlibrary LibPRNG {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A pseudorandom number state in memory.\\n    struct PRNG {\\n        uint256 state;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Seeds the `prng` with `state`.\\n    function seed(PRNG memory prng, uint256 state) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(prng, state)\\n        }\\n    }\\n\\n    /// @dev Returns the next pseudorandom uint256.\\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\\n        // We simply use `keccak256` for a great balance between\\n        // runtime gas costs, bytecode size, and statistical properties.\\n        //\\n        // A high-quality LCG with a 32-byte state\\n        // is only about 30% more gas efficient during runtime,\\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\\n        // when this function is inlined.\\n        //\\n        // Using this method is about 2x more efficient than\\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(prng, 0x20)\\n            mstore(prng, result)\\n        }\\n    }\\n\\n    /// @dev Returns a pseudorandom uint256, uniformly distributed\\n    /// between 0 (inclusive) and `upper` (exclusive).\\n    /// If your modulus is big, this method is recommended\\n    /// for uniform sampling to avoid modulo bias.\\n    /// For uniform sampling across all uint256 values,\\n    /// or for small enough moduli such that the bias is neligible,\\n    /// use {next} instead.\\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := keccak256(prng, 0x20)\\n                mstore(prng, result)\\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\\n            }\\n            result := mod(result, upper)\\n        }\\n    }\\n\\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n\\n                    {\\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let i := add(a, shl(5, n))\\n                        let t := mload(i)\\n                        mstore(i, mload(j))\\n                        mstore(j, t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let n := mload(a)\\n            let w := not(0)\\n            let mask := shr(128, w)\\n            if n {\\n                let b := add(a, 0x01)\\n                for { a := add(a, 0x20) } 1 {} {\\n                    // We can just directly use `keccak256`, cuz\\n                    // the other approaches don't save much.\\n                    let r := keccak256(prng, 0x20)\\n                    mstore(prng, r)\\n\\n                    // Note that there will be a very tiny modulo bias\\n                    // if the length of the array is not a power of 2.\\n                    // For all practical purposes, it is negligible\\n                    // and will not be a fairness or security concern.\\n                    {\\n                        let o := mod(shr(128, r), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n\\n                    {\\n                        let o := mod(and(r, mask), n)\\n                        n := add(n, w) // `sub(n, 1)`.\\n                        if iszero(n) { break }\\n\\n                        let t := mload(add(b, n))\\n                        mstore8(add(a, n), mload(add(b, o)))\\n                        mstore8(add(a, o), t)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"OpenZeppelin4/PullPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/PullPayment.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Escrow.sol\\\";\\n\\n/**\\n * @dev Simple implementation of a\\n * https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls[pull-payment]\\n * strategy, where the paying contract doesn't interact directly with the\\n * receiver account, which must withdraw its payments itself.\\n *\\n * Pull-payments are often considered the best practice when it comes to sending\\n * Ether, security-wise. It prevents recipients from blocking execution, and\\n * eliminates reentrancy concerns.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}\\n * instead of Solidity's `transfer` function. Payees can query their due\\n * payments with {payments}, and retrieve them with {withdrawPayments}.\\n */\\nabstract contract PullPayment {\\n    Escrow private immutable _escrow;\\n\\n    constructor() {\\n        _escrow = new Escrow();\\n    }\\n\\n    /**\\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\\n     *\\n     * Note that _any_ account can call this function, not just the `payee`.\\n     * This means that contracts unaware of the `PullPayment` protocol can still\\n     * receive funds this way, by having a separate account call\\n     * {withdrawPayments}.\\n     *\\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\\n     * Make sure you trust the recipient, or are either following the\\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\\n     *\\n     * @param payee Whose payments will be withdrawn.\\n     *\\n     * Causes the `escrow` to emit a {Withdrawn} event.\\n     */\\n    function withdrawPayments(address payable payee) public virtual {\\n        _escrow.withdraw(payee);\\n    }\\n\\n    /**\\n     * @dev Returns the payments owed to an address.\\n     * @param dest The creditor's address.\\n     */\\n    function payments(address dest) public view returns (uint256) {\\n        return _escrow.depositsOf(dest);\\n    }\\n\\n    /**\\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\\n     * there is no danger of them being spent before withdrawal.\\n     *\\n     * @param dest The destination address of the funds.\\n     * @param amount The amount to transfer.\\n     *\\n     * Causes the `escrow` to emit a {Deposited} event.\\n     */\\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\\n        _escrow.deposit{value: amount}(dest);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721Psi/extension/ERC721PsiBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n  ______ _____   _____ ______ ___  __ _  _  _ \\n |  ____|  __ \\\\ / ____|____  |__ \\\\/_ | || || |\\n | |__  | |__) | |        / /   ) || | \\\\| |/ |\\n |  __| |  _  /| |       / /   / / | |\\\\_   _/ \\n | |____| | \\\\ \\\\| |____  / /   / /_ | |  | |   \\n |______|_|  \\\\_\\\\\\\\_____|/_/   |____||_|  |_|   \\n                                              \\n                                            \\n */\\npragma solidity ^0.8.0;\\n\\nimport \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport \\\"../ERC721Psi.sol\\\";\\n\\nabstract contract ERC721PsiBurnable is ERC721Psi {\\n    using LibBitmap for LibBitmap.Bitmap;\\n    LibBitmap.Bitmap private _burnedToken;\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address from = ownerOf(tokenId);\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n        _burnedToken.set(tokenId);\\n        \\n        emit Transfer(from, address(0), tokenId);\\n\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view override virtual returns (bool){\\n        if(_burnedToken.get(tokenId)) {\\n            return false;\\n        } \\n        return super._exists(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        if (_burnedToken.get(tokenId)) {\\n            return address(0);\\n        }\\n        else {\\n            return super.ownerOf(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _currentIndex - _burned() - _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns number of token burned.\\n     */\\n    function _burned() internal view returns (uint256 burned){\\n        return _burnedToken.popCount( _startTokenId(), _totalMinted());\\n    }\\n}\"\r\n    },\r\n    \"OpenZeppelin4/Escrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/escrow/Escrow.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Escrow\\n * @dev Base escrow contract, holds funds designated for a payee until they\\n * withdraw them.\\n *\\n * Intended usage: This contract (and derived escrow contracts) should be a\\n * standalone contract, that only interacts with the contract that instantiated\\n * it. That way, it is guaranteed that all Ether will be handled according to\\n * the `Escrow` rules, and there is no need to check for payable functions or\\n * transfers in the inheritance tree. The contract that uses the escrow as its\\n * payment method should be its owner, and provide public methods redirecting\\n * to the escrow's deposit and withdraw.\\n */\\ncontract Escrow is Ownable {\\n    using Address for address payable;\\n\\n    event Deposited(address indexed payee, uint256 weiAmount);\\n    event Withdrawn(address indexed payee, uint256 weiAmount);\\n\\n    mapping(address => uint256) private _deposits;\\n\\n    /// @dev modify this to support Ownable v5.0\\n    constructor() Ownable(msg.sender) {}\\n\\n    function depositsOf(address payee) public view returns (uint256) {\\n        return _deposits[payee];\\n    }\\n\\n    /**\\n     * @dev Stores the sent amount as credit to be withdrawn.\\n     * @param payee The destination address of the funds.\\n     *\\n     * Emits a {Deposited} event.\\n     */\\n    function deposit(address payee) public payable virtual onlyOwner {\\n        uint256 amount = msg.value;\\n        _deposits[payee] += amount;\\n        emit Deposited(payee, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\\n     * recipient.\\n     *\\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\\n     * Make sure you trust the recipient, or are either following the\\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\\n     *\\n     * @param payee The address whose funds will be withdrawn and transferred to.\\n     *\\n     * Emits a {Withdrawn} event.\\n     */\\n    function withdraw(address payable payee) public virtual onlyOwner {\\n        uint256 payment = _deposits[payee];\\n\\n        _deposits[payee] = 0;\\n\\n        payee.sendValue(payment);\\n\\n        emit Withdrawn(payee, payment);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\\n\\n    /**\\n     * @dev Query for a nonexistent map key.\\n     */\\n    error EnumerableMapNonexistentKey(bytes32 key);\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 key => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == 0 && !contains(map, key)) {\\n            revert EnumerableMapNonexistentKey(key);\\n        }\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\\n        return map._keys.values();\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the map. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Return the an array containing all the keys\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = keys(map._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibBit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for bit twiddling and boolean operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\\nlibrary LibBit {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  BIT TWIDDLING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Find last set.\\n    /// Returns the index of the most significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    function fls(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, byte(shr(r, x), hex\\\"00000101020202020303030303030303\\\"))\\n        }\\n    }\\n\\n    /// @dev Count leading zeros.\\n    /// Returns the number of zeros preceding the most significant one bit.\\n    /// If `x` is zero, returns 256.\\n    function clz(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := add(iszero(x), xor(255,\\n                or(r, byte(shr(r, x), hex\\\"00000101020202020303030303030303\\\"))))\\n        }\\n    }\\n\\n    /// @dev Find first set.\\n    /// Returns the index of the least significant bit of `x`,\\n    /// counting from the least significant bit position.\\n    /// If `x` is zero, returns 256.\\n    /// Equivalent to `ctz` (count trailing zeros), which gives\\n    /// the number of zeros following the least significant one bit.\\n    function ffs(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Isolate the least significant bit.\\n            let b := and(x, add(not(x), 1))\\n\\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\\n        }\\n    }\\n\\n    /// @dev Returns the number of set bits in `x`.\\n    function popCount(uint256 x) internal pure returns (uint256 c) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let isMax := eq(x, max)\\n            x := sub(x, and(shr(1, x), div(max, 3)))\\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\\n            x := and(add(x, shr(4, x)), div(max, 17))\\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\\n        }\\n    }\\n\\n    /// @dev Returns whether `x` is a power of 2.\\n    function isPo2(uint256 x) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `x && !(x & (x - 1))`.\\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the bit level.\\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 500 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if iszero(s) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `x` reversed at the byte level.\\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\\n            let m := not(0)\\n            r := x\\n            for { let s := 128 } 1 {} {\\n                m := xor(m, shl(s, m))\\n                r := or(and(shr(s, r), m), and(shl(s, r), not(m)))\\n                s := shr(1, s)\\n                if eq(s, 4) { break }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     BOOLEAN OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\\n    // Non-zero values are true, zero is false.\\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\\n    // Usually, if not always, the bool result of a regular Solidity expression,\\n    // or the argument of a public/external function will be a clean bool.\\n    // You can usually use the raw variants for more performance.\\n    // If uncertain, test (best with exact compiler settings).\\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\\n\\n    /// @dev Returns `x & y`. Inputs must be clean.\\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x & y`.\\n    function and(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`. Inputs must be clean.\\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x | y`.\\n    function or(bool x, bool y) internal pure returns (bool z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\\n    function rawToUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := b\\n        }\\n    }\\n\\n    /// @dev Returns 1 if `b` is true, else 0.\\n    function toUint(bool b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721Psi/ERC721Psi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n  ______ _____   _____ ______ ___  __ _  _  _ \\n |  ____|  __ \\\\ / ____|____  |__ \\\\/_ | || || |\\n | |__  | |__) | |        / /   ) || | \\\\| |/ |\\n |  __| |  _  /| |       / /   / / | |\\\\_   _/ \\n | |____| | \\\\ \\\\| |____  / /   / /_ | |  | |   \\n |______|_|  \\\\_\\\\\\\\_____|/_/   |____||_|  |_|   \\n\\n - github: https://github.com/estarriolvetch/ERC721Psi\\n - npm: https://www.npmjs.com/package/erc721psi\\n\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"solady/src/utils/LibBitmap.sol\\\";\\nimport \\\"./interface/IERC721Psi.sol\\\";\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721Psi__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ncontract ERC721Psi is IERC721Psi {\\n    \\n    using Address for address;\\n    using Strings for uint256;\\n    using LibBitmap for LibBitmap.Bitmap;\\n\\n    LibBitmap.Bitmap private _batchHead;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) internal _owners;\\n    uint256 internal _currentIndex;\\n\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        return _currentIndex - _startTokenId();\\n    }\\n\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) \\n        public \\n        view \\n        virtual \\n        override \\n        returns (uint) \\n    {\\n        if(owner == address(0)) revert BalanceQueryForZeroAddress();\\n\\n        uint count;\\n        for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){\\n            if(_exists(i)){\\n                if( owner == ownerOf(i)){\\n                    ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        (address owner, ) = _ownerAndBatchHeadOf(tokenId);\\n        return owner;\\n    }\\n\\n    function _ownerAndBatchHeadOf(uint256 tokenId) internal view returns (address owner, uint256 tokenIdBatchHead){\\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\\n        tokenIdBatchHead = _getBatchHead(tokenId);\\n        owner = _owners[tokenIdBatchHead];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if( !_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721Psi() != owner) {\\n            if (!isApprovedForAll(owner, _msgSenderERC721Psi())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (address) \\n    {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, 1, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return tokenId < _nextTokenId() && _startTokenId() <= tokenId;\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721Psi: operator query for nonexistent token\\\"\\n        );\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, \\\"\\\");\\n    }\\n\\n    \\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n        uint256 end = _currentIndex;\\n        if (!_checkOnERC721Received(address(0), to, end - quantity, quantity, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n        // Reentrancy protection.\\n        if (_currentIndex != end) revert();\\n    }\\n\\n\\n    function _mint(\\n        address to,\\n        uint256 quantity\\n    ) internal virtual {\\n        uint256 nextTokenId = _nextTokenId();\\n        \\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (to == address(0)) revert MintToZeroAddress();\\n        \\n        _beforeTokenTransfers(address(0), to, nextTokenId, quantity);\\n        _currentIndex += quantity;\\n        _owners[nextTokenId] = to;\\n        _batchHead.set(nextTokenId);\\n\\n        uint256 toMasked;\\n        uint256 end = nextTokenId + quantity;\\n\\n        // Use assembly to loop and emit the `Transfer` event for gas savings.\\n        // The duplicated `log4` removes an extra check and reduces stack juggling.\\n        // The assembly, together with the surrounding Solidity code, have been\\n        // delicately arranged to nudge the compiler into producing optimized opcodes.\\n        assembly {\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            toMasked := and(to, _BITMASK_ADDRESS)\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                0, // `address(0)`.\\n                toMasked, // `to`.\\n                nextTokenId // `tokenId`.\\n            )\\n\\n            // The `iszero(eq(,))` check ensures that large values of `quantity`\\n            // that overflows uint256 will make the loop run out of gas.\\n            // The compiler will optimize the `iszero` away for performance.\\n            for {\\n                let tokenId := add(nextTokenId, 1)\\n            } iszero(eq(tokenId, end)) {\\n                tokenId := add(tokenId, 1)\\n            } {\\n                // Emit the `Transfer` event. Similar to above.\\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n            }\\n        }\\n\\n        _afterTokenTransfers(address(0), to, nextTokenId, quantity);\\n    }\\n\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n\\n        (address owner, uint256 tokenIdBatchHead) = _ownerAndBatchHeadOf(tokenId);\\n\\n        if (owner != from) revert TransferFromIncorrectOwner();\\n\\n        if (!_isApprovedOrOwner(_msgSenderERC721Psi(), tokenId)) {\\n            revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);   \\n\\n        uint256 subsequentTokenId = tokenId + 1;\\n\\n        if(!_batchHead.get(subsequentTokenId) &&  \\n            subsequentTokenId < _nextTokenId()\\n        ) {\\n            _owners[subsequentTokenId] = from;\\n            _batchHead.set(subsequentTokenId);\\n        }\\n\\n        _owners[tokenId] = to;\\n        if(tokenId != tokenIdBatchHead) {\\n            _batchHead.set(tokenId);\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param startTokenId uint256 the first ID of the tokens to be transferred\\n     * @param quantity uint256 amount of the tokens to be transfered.\\n     * @param _data bytes optional data to send along with the call\\n     * @return r bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) private returns (bool r) {\\n        /// @dev removed isContract() in v5.0 but their ERC721 uses this check:\\n        if (to.code.length > 0) {\\n            r = true;\\n            for(uint256 tokenId = startTokenId; tokenId < startTokenId + quantity; tokenId++){\\n                try ERC721Psi__IERC721Receiver(to).onERC721Received( _msgSenderERC721Psi(), from, tokenId, _data) returns (bytes4 retval) {\\n                    r = r && retval == ERC721Psi__IERC721Receiver.onERC721Received.selector;\\n                } catch (bytes memory reason) {\\n                    if (reason.length == 0) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    } else {\\n                        assembly {\\n                            revert(add(32, reason), mload(reason))\\n                        }\\n                    }\\n                }\\n            }\\n            return r;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function _getBatchHead(uint256 tokenId) internal view returns (uint256 tokenIdBatchHead) {\\n        tokenIdBatchHead = _batchHead.findLastSet(tokenId); \\n    }\\n\\n\\n    function totalSupply() public virtual override view returns (uint256) {\\n        return _totalMinted();\\n    }\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * This function is compatiable with ERC721AQueryable.\\n     */\\n    function tokensOfOwner(address owner) external view virtual returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                if (_exists(i)) {\\n                    if (ownerOf(i) == owner) {\\n                        tokenIds[tokenIdsIdx++] = i;\\n                    }\\n                }\\n            }\\n            return tokenIds;   \\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721Psi() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"solady/src/utils/LibBitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibBit} from \\\"./LibBit.sol\\\";\\n\\n/// @notice Library for storage of packed unsigned booleans.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\\nlibrary LibBitmap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when a bitmap scan does not find a result.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\\n        // Both cost the same amount of gas, but the former allows the returned value\\n        // to be reused without cleaning the upper bits.\\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            isSet := b\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to true.\\n    function set(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to false.\\n    function unset(Bitmap storage bitmap, uint256 index) internal {\\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\\n    }\\n\\n    /// @dev Flips the bit at `index` in `bitmap`.\\n    /// Returns the boolean result of the flipped bit.\\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let shift := and(index, 0xff)\\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\\n            // It makes sense to return the `newIsSet`,\\n            // as it allow us to skip an additional warm `sload`,\\n            // and it costs minimal gas (about 15),\\n            // which may be optimized away if the returned value is unused.\\n            newIsSet := and(1, shr(shift, storageValue))\\n            sstore(storageSlot, storageValue)\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, index))\\n            let storageSlot := keccak256(0x00, 0x40)\\n            let storageValue := sload(storageSlot)\\n            let shift := and(index, 0xff)\\n            sstore(\\n                storageSlot,\\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let max := not(0)\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), max)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\\n        }\\n    }\\n\\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let shift := and(start, 0xff)\\n            mstore(0x20, bitmap.slot)\\n            mstore(0x00, shr(8, start))\\n            if iszero(lt(add(shift, amount), 257)) {\\n                let storageSlot := keccak256(0x00, 0x40)\\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\\n                let bucket := add(mload(0x00), 1)\\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\\n                amount := and(add(amount, shift), 0xff)\\n                shift := 0\\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\\n                    mstore(0x00, bucket)\\n                    sstore(keccak256(0x00, 0x40), 0)\\n                }\\n                mstore(0x00, bucket)\\n            }\\n            let storageSlot := keccak256(0x00, 0x40)\\n            sstore(\\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns number of set bits within a range by\\n    /// scanning `amount` of bits starting from the bit at `start`.\\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\\n        internal\\n        view\\n        returns (uint256 count)\\n    {\\n        unchecked {\\n            uint256 bucket = start >> 8;\\n            uint256 shift = start & 0xff;\\n            if (!(amount + shift < 257)) {\\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\\n                amount = (amount + shift) & 0xff;\\n                shift = 0;\\n                for (++bucket; bucket != bucketEnd; ++bucket) {\\n                    count += LibBit.popCount(bitmap.map[bucket]);\\n                }\\n            }\\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\\n        }\\n    }\\n\\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\\n    /// If no set bit is found, returns `NOT_FOUND`.\\n    function findLastSet(Bitmap storage bitmap, uint256 before)\\n        internal\\n        view\\n        returns (uint256 setBitIndex)\\n    {\\n        uint256 bucket;\\n        uint256 bucketBits;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            setBitIndex := not(0)\\n            bucket := shr(8, before)\\n            mstore(0x00, bucket)\\n            mstore(0x20, bitmap.slot)\\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\\n            if iszero(or(bucketBits, iszero(bucket))) {\\n                for {} 1 {} {\\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\\n                    mstore(0x00, bucket)\\n                    bucketBits := sload(keccak256(0x00, 0x40))\\n                    if or(bucketBits, iszero(bucket)) { break }\\n                }\\n            }\\n        }\\n        if (bucketBits != 0) {\\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721Psi/interface/IERC721Psi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of ERC721Psi.\\n */\\ninterface IERC721Psi {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_maxTokens\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_maxWallet\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_maxTx\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_teamSplit\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"_teamAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_drawAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorClaimInvalidBurn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ErrorClaimInvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimInvalidUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimMaxWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimPermissionDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimRoundClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorClaimUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCommitDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCommitInvalidUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCommitPrevious\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorDoNotSendDirectEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorDrawAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorGameNotRunning\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorInvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorInvalidTokenURI\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMaxTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMaxTx\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMaxWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintComplete\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintMaxTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintMaxWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintNonRefundable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintResetting\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintTxAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorMintTxPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNonRefundable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorRevealDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorRevealLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorRevealMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTeamAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTeamSplit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"ErrorTimeLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTokenPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTransferDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTransferInvalidBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorTransferInvalidUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintCount\",\"type\":\"uint256\"}],\"name\":\"GameCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"GameOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"}],\"name\":\"GameStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gameRound\",\"type\":\"uint32\"}],\"name\":\"RoundStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MAX_LOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canCancelGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cancelledGameAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelledGames\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"drawAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getRefundAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenStatus\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"gameNumber\",\"type\":\"uint32\"}],\"name\":\"getWinner\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct LibWinners.Winner\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getWinnerAtIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"internalType\":\"struct LibWinners.Winner\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGameExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGameFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"isTokenOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"liveTokenOfOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"quantity\",\"type\":\"uint16\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"gameNumber\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"secret\",\"type\":\"bytes\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_teamAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_drawAddress\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCancelledGames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWinners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdrawPayments\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BurnItDAO", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000001158e460913d00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000140000000000000000000000002598e873c1d0726d8259b5b148782d9d60f3fc66000000000000000000000000bface924e15b78ee7fc1be1bc377fb8f3bcc751000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000094275726e497444414f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000442494431000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043697066733a2f2f6261667962656966706d75706666666d7872646b686e6432767a73766c7861736879366471637233367079676668706d636c766c763772726377612f0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}