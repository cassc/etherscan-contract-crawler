{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Map implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableMap {\\n    error EnumerableMap__IndexOutOfBounds();\\n    error EnumerableMap__NonExistentKey();\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct AddressToAddressMap {\\n        Map _inner;\\n    }\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function at(\\n        AddressToAddressMap storage map,\\n        uint256 index\\n    ) internal view returns (address, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n\\n        return (\\n            address(uint160(uint256(key))),\\n            address(uint160(uint256(value)))\\n        );\\n    }\\n\\n    function at(\\n        UintToAddressMap storage map,\\n        uint256 index\\n    ) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function contains(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function contains(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(\\n        AddressToAddressMap storage map\\n    ) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function length(\\n        UintToAddressMap storage map\\n    ) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function get(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal view returns (address) {\\n        return\\n            address(\\n                uint160(\\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\\n                )\\n            );\\n    }\\n\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function set(\\n        AddressToAddressMap storage map,\\n        address key,\\n        address value\\n    ) internal returns (bool) {\\n        return\\n            _set(\\n                map._inner,\\n                bytes32(uint256(uint160(key))),\\n                bytes32(uint256(uint160(value)))\\n            );\\n    }\\n\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal returns (bool) {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function remove(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function toArray(\\n        AddressToAddressMap storage map\\n    )\\n        internal\\n        view\\n        returns (address[] memory keysOut, address[] memory valuesOut)\\n    {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new address[](len);\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._key))\\n                );\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function toArray(\\n        UintToAddressMap storage map\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\\n    {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new uint256[](len);\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = uint256(map._inner._entries[i]._key);\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function keys(\\n        AddressToAddressMap storage map\\n    ) internal view returns (address[] memory keysOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._key))\\n                );\\n            }\\n        }\\n    }\\n\\n    function keys(\\n        UintToAddressMap storage map\\n    ) internal view returns (uint256[] memory keysOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new uint256[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = uint256(map._inner._entries[i]._key);\\n            }\\n        }\\n    }\\n\\n    function values(\\n        AddressToAddressMap storage map\\n    ) internal view returns (address[] memory valuesOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function values(\\n        UintToAddressMap storage map\\n    ) internal view returns (address[] memory valuesOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function _at(\\n        Map storage map,\\n        uint256 index\\n    ) private view returns (bytes32, bytes32) {\\n        if (index >= map._entries.length)\\n            revert EnumerableMap__IndexOutOfBounds();\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _contains(\\n        Map storage map,\\n        bytes32 key\\n    ) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\\n        unchecked {\\n            return map._entries[keyIndex - 1]._value;\\n        }\\n    }\\n\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            unchecked {\\n                map._entries[keyIndex - 1]._value = value;\\n            }\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) {\\n            unchecked {\\n                MapEntry storage last = map._entries[map._entries.length - 1];\\n\\n                // move last entry to now-vacant index\\n                map._entries[keyIndex - 1] = last;\\n                map._indexes[last._key] = keyIndex;\\n            }\\n\\n            // clear last index\\n            map._entries.pop();\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165Internal } from './IERC165Internal.sol';\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 is IERC165Internal {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC165 interface registration interface\\n */\\ninterface IERC165Internal {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { IERC721Internal } from './IERC721Internal.sol';\\n\\n/**\\n * @title ERC721 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721 is IERC721Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given address\\n     * @return balance quantity of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice query the owner of given token\\n     * @param tokenId token to query\\n     * @return owner token owner\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice grant approval to given account to spend token\\n     * @param operator address to be approved\\n     * @param tokenId token to approve\\n     */\\n    function approve(address operator, uint256 tokenId) external payable;\\n\\n    /**\\n     * @notice get approval status for given token\\n     * @param tokenId token to query\\n     * @return operator address approved to spend token\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address operator);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\\n     * @param operator address to be approved\\n     * @param status approval status\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return status whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC721 interface needed by internal functions\\n */\\ninterface IERC721Internal {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed operator,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\\nimport { IERC721Base } from './IERC721Base.sol';\\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\\n\\n/**\\n * @title Base ERC721 implementation, excluding optional extensions\\n * @dev inheritor must either implement ERC165 supportsInterface or inherit ERC165Base\\n */\\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address) {\\n        return _ownerOf(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address) {\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool) {\\n        return _isApprovedForAll(account, operator);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable {\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable {\\n        _safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external payable {\\n        _safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function approve(address operator, uint256 tokenId) external payable {\\n        _approve(operator, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function setApprovalForAll(address operator, bool status) external {\\n        _setApprovalForAll(operator, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\n\\n/**\\n * @title Base ERC721 internal functions\\n */\\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    function _balanceOf(\\n        address account\\n    ) internal view virtual returns (uint256) {\\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\\n        return ERC721BaseStorage.layout().holderTokens[account].length();\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\\n        return owner;\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\\n    }\\n\\n    function _getApproved(\\n        uint256 tokenId\\n    ) internal view virtual returns (address) {\\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\\n\\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\\n    }\\n\\n    function _isApprovedForAll(\\n        address account,\\n        address operator\\n    ) internal view virtual returns (bool) {\\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        return (spender == owner ||\\n            _getApproved(tokenId) == spender ||\\n            _isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, '');\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\\n            revert ERC721Base__ERC721ReceiverNotImplemented();\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = _ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[owner].remove(tokenId);\\n        l.tokenOwners.remove(tokenId);\\n\\n        l.tokenApprovals[tokenId] = address(0);\\n\\n        emit Approval(owner, address(0), tokenId);\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        address owner = _ownerOf(tokenId);\\n\\n        if (owner != from) revert ERC721Base__NotTokenOwner();\\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[from].remove(tokenId);\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n        l.tokenApprovals[tokenId] = address(0);\\n\\n        emit Approval(owner, address(0), tokenId);\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\\n            revert ERC721Base__NotOwnerOrApproved();\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data))\\n            revert ERC721Base__ERC721ReceiverNotImplemented();\\n    }\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\\n            revert ERC721Base__NotOwnerOrApproved();\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    function _approve(address operator, uint256 tokenId) internal virtual {\\n        _handleApproveMessageValue(operator, tokenId, msg.value);\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        if (operator == owner) revert ERC721Base__SelfApproval();\\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\\n            revert ERC721Base__NotOwnerOrApproved();\\n\\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\\n        emit Approval(owner, operator, tokenId);\\n    }\\n\\n    function _setApprovalForAll(\\n        address operator,\\n        bool status\\n    ) internal virtual {\\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\\n            operator\\n        ] = status;\\n        emit ApprovalForAll(msg.sender, operator, status);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes memory returnData = to.functionCall(\\n            abi.encodeWithSelector(\\n                IERC721Receiver(to).onERC721Received.selector,\\n                msg.sender,\\n                from,\\n                tokenId,\\n                data\\n            ),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n\\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\\n        return returnValue == type(IERC721Receiver).interfaceId;\\n    }\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\\n     * @param operator beneficiary of approval\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\n\\nlibrary ERC721BaseStorage {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Base');\\n\\n    struct Layout {\\n        EnumerableMap.UintToAddressMap tokenOwners;\\n        mapping(address => EnumerableSet.UintSet) holderTokens;\\n        mapping(uint256 => address) tokenApprovals;\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/IERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\\n\\n/**\\n * @title ERC721 base interface\\n */\\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\\n\\n/**\\n * @title ERC721 base interface\\n */\\ninterface IERC721BaseInternal is IERC721Internal {\\n    error ERC721Base__NotOwnerOrApproved();\\n    error ERC721Base__SelfApproval();\\n    error ERC721Base__BalanceQueryZeroAddress();\\n    error ERC721Base__ERC721ReceiverNotImplemented();\\n    error ERC721Base__InvalidOwner();\\n    error ERC721Base__MintToZeroAddress();\\n    error ERC721Base__NonExistentToken();\\n    error ERC721Base__NotTokenOwner();\\n    error ERC721Base__TokenAlreadyMinted();\\n    error ERC721Base__TransferToZeroAddress();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\n\\nabstract contract ERC721EnumerableInternal {\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _totalSupply() internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().tokenOwners.length();\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenByIndex(\\n        uint256 index\\n    ) internal view returns (uint256 tokenId) {\\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/base/BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport {LibAppStorage} from \\\"../libraries/storage/LibAppStorage.sol\\\";\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  BaseStorage\\n * @author slvrfn\\n * @notice Abstract contract which contains the shared AppStorage values.\\n * @dev    This contract is meant to be inherited by contracts so they can use the shared AppStorage values.\\n *         This contract should always be inherited from FIRST in order to preserve the AppStorage struct being stored\\n *         at position 0 in consuming contracts.\\n */\\nabstract contract BaseStorage {\\n    LibAppStorage.AppStorage internal s;\\n}\\n\"\r\n    },\r\n    \"Contracts/base/FeatureFlag.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {FlagStorage} from \\\"../libraries/storage/FlagStorage.sol\\\";\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  FeatureFlag\\n * @author slvrfn\\n * @notice Abstract contract which contains logic to manage FeatureFlags across a Diamond.\\n * @dev    This contract is meant to be inherited by contracts so they can use the shared FeatureFlag behavior.\\n */\\nabstract contract FeatureFlag {\\n    using FlagStorage for FlagStorage.Layout;\\n\\n    // Flag used to pause all contract functionality\\n    uint256 internal constant PAUSED_FLAG_BIT = 1 << 0;\\n    // Flag used to pause all token functionality\\n    uint256 internal constant TOKEN_FLAG_BIT = 1 << 1;\\n\\n    // More specificFlags used at time of contract deployment\\n    uint256 internal constant MINT_FLAG_BIT = 1 << 2;\\n    uint256 internal constant REVEAL_FLAG_BIT = 1 << 3;\\n    uint256 internal constant MIX_FLAG_BIT = 1 << 4;\\n    uint256 internal constant COMBINE_FLAG_BIT = 1 << 5;\\n    uint256 internal constant SEED_BIT = 1 << 6;\\n\\n    /**\\n     * @dev Emitted when a given feature flag is updated by address.\\n     */\\n    event FlagUpdate(uint256 indexed flagGroup, uint256 value, address operator);\\n\\n    /**\\n     * @dev Raised when checking if a Feature is enabled.\\n     */\\n    error FlagMismatch();\\n\\n    /**\\n     * @dev   Returns whether the group of flags in _flagGroup have the expected bits unset.\\n     *        This allows to check that bits in a particular _flagGroup are in the expected state (unset).\\n     *        If a bit is set, that means the feature is disabled.\\n     * @param flagGroup - the group of flags to be returned.\\n     */\\n    function _getFlagGroupBits(uint256 flagGroup) internal view returns (uint256) {\\n        return FlagStorage.layout()._flagBits(flagGroup);\\n    }\\n\\n    /**\\n     * @dev   Returns whether the group of flags in _flagGroup have the expected bits unset.\\n     *        This allows to check that bits in a particular _flagGroup are in the expected state (unset).\\n     *        If a bit is set, that means the feature is disabled.\\n     * @param flagGroup - the group of flags to be evaluated.\\n     * @param notMatchBits - 256-bit bitmap to be checked.\\n     */\\n    function _flagBitsUnset(uint256 flagGroup, uint256 notMatchBits) internal view returns (bool) {\\n        return FlagStorage.layout()._flagBitsUnset(flagGroup, notMatchBits);\\n    }\\n\\n    /**\\n     * @dev   Checks that bits relating to certain feature flags are unset (enabled), and reverts otherwise\\n     * @param flagGroup - the group of flags to be evaluated.\\n     * @param notMatchBits - 256-bit bitmap to be checked.\\n     */\\n    function _requireFeaturesEnabled(uint256 flagGroup, uint256 notMatchBits) internal view {\\n        if (!_flagBitsUnset(flagGroup, notMatchBits)) {\\n            revert FlagMismatch();\\n        }\\n    }\\n\\n    /**\\n     * @dev   Updates the stored set of bits _flagGroup to be _value. This allows the simultaneous update of\\n     *        multiple flags in the same group\\n     * @param flagGroup - the group of flags to be evaluated.\\n     * @param bits - 256-bit bitmap to be assigned.\\n     */\\n    function _setFeatureFlag(uint256 flagGroup, uint256 bits) internal {\\n        FlagStorage.Layout storage f = FlagStorage.layout();\\n        f._setFlagBits(flagGroup, bits);\\n        emit FlagUpdate(flagGroup, bits, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/base/MintVoucherVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibEIP712} from \\\"../libraries/LibEIP712.sol\\\";\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  MintVoucherVerifier\\n * @author slvrfn\\n * @notice Abstract contract which contains the necessary logic to verify the validity of a MintVoucher.\\n * @dev    This contract is meant to be inherited by contracts so they can use the internal functions as desired\\n */\\nabstract contract MintVoucherVerifier {\\n    using LibEIP712 for LibEIP712.Layout;\\n\\n    /**\\n     * @dev Raised if a user has not provided the necessary fee associated with a MintVoucher.\\n     */\\n    error MintFee();\\n    /**\\n     * @dev Raised if a user tried to mint 0 tokens, or more than their voucher is allowed.\\n     */\\n    error MintLimit();\\n    /**\\n     * @dev Raised if a user tried to mint before their assigned phase.\\n     */\\n    error MintPhase();\\n    /**\\n     * @dev Raised if a user tried to use a voucher not assigned to them.\\n     */\\n    error VoucherAddress();\\n    /**\\n     * @dev Raised if a user tried to use an invalid voucher (signature doesnt match fields).\\n     */\\n    error VoucherInvalid();\\n    /**\\n     * @dev Raised if a user tried to mint more than their voucher allows.\\n     */\\n    error VoucherQty();\\n    /**\\n     * @dev Raised if a user tried to use a voucher that has been fully consumed\\n     */\\n    error VoucherClaimed();\\n\\n    /**\\n     * @dev Represents a voucher to Mint 1 or more NFTs. A signed voucher is used for proving the contained parameters\\n     *      were set by an address with the appropriate role.\\n     */\\n    struct MintVoucher {\\n        /// @dev single use nonce that prevents voucher reuse\\n        uint256 nonce;\\n        /// @dev address this voucher is associated with\\n        address addr;\\n        /// @dev how many mints this voucher is worth (in a single use)\\n        uint16 qty;\\n        /// @dev phase of mint this voucher can be used\\n        uint8 phase;\\n        /// @dev if the caller receives a free mint\\n        uint8 free;\\n        /// @dev the EIP-712 signature of all other fields in the MintVoucher struct. For a voucher to be valid, it must be signed by an account with the MINTER_ROLE.\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @dev   Returns the current mint fee.\\n     * @param currentPhase - mint phase to return the fee for.\\n     */\\n    // solhint-disable-next-line no-unused-vars\\n    function _getMintFee(uint256 currentPhase, uint16 desiredQty) internal virtual returns (uint256) {\\n        revert(\\\"_getMintFee needs override\\\");\\n    }\\n\\n    /**\\n     * @dev   Returns a hash of the given MintVoucher, prepared using EIP712 typed data hashing rules.\\n     * @param voucher - An MintVoucher to hash.\\n     */\\n    function _hashMintVoucher(LibEIP712.Layout storage e, MintVoucher memory voucher) internal view returns (bytes32) {\\n        return\\n            e._hashTypedDataV4(\\n                keccak256(\\n                    abi.encode(\\n                        keccak256(\\\"MintVoucher(uint256 nonce,address addr,uint16 qty,uint8 phase,uint8 free)\\\"),\\n                        voucher.nonce,\\n                        voucher.addr,\\n                        voucher.qty,\\n                        voucher.phase,\\n                        voucher.free\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev   Verifies the signature for a given MintVoucher, returning the address of the signer. Will revert if\\n     *        the signature is invalid. Does not verify that the signer is authorized to create a MintVoucher.\\n     * @param voucher - A MintVoucher describing a user's mint details.\\n     */\\n    function _verifyMintVoucher(LibEIP712.Layout storage e, MintVoucher memory voucher) internal view returns (address) {\\n        bytes32 digest = _hashMintVoucher(e, voucher);\\n        return LibEIP712._verifySignedData(digest, voucher.signature);\\n    }\\n\\n    /**\\n     * @dev   Signals whether an MintVoucher is verified, and able to be used.\\n     * @param voucher - A MintVoucher describing a user's mint details.\\n     */\\n    function _checkVoucherGetSigner(MintVoucher memory voucher, uint40 currentPhase, uint16 desiredQty, bool claim) internal returns (address) {\\n        LibEIP712.Layout storage e = LibEIP712.layout();\\n\\n        _checkVoucherConditions(voucher, currentPhase, desiredQty);\\n\\n        // make sure signature is valid and get the address of the signer\\n        address signer = _verifyMintVoucher(e, voucher);\\n\\n        // in public mint phase, dont claim voucher; fall back to per-address mint checks\\n        if (!claim) return signer;\\n\\n        // make sure that the voucher has not redeemed more than its allotted amount\\n        if (e.isVoucherClaimed(voucher.nonce, voucher.qty, desiredQty)) {\\n            revert VoucherClaimed();\\n        }\\n\\n        // mark the voucher claimed so that it can not be reused in the future\\n        e.claimVoucher(voucher.nonce, desiredQty);\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev   Checks basic features of the voucher to make sure it is being consumed when/how expected.\\n     * @param voucher - A MintVoucher describing a user's mint details.\\n     * @param currentPhase - the current mint phase.\\n     * @param desiredQty - a qty that a user chooses to consume.\\n     */\\n    function _checkVoucherConditions(MintVoucher memory voucher, uint40 currentPhase, uint16 desiredQty) internal {\\n        // in phase 3\\n        //      -yes -make sure caller is using the voucher associated with open mint\\n        //      -no  -make sure caller is using a voucher assigned to them\\n        if (currentPhase == 3 ? voucher.addr != address(this) : voucher.addr != msg.sender) {\\n            revert VoucherAddress();\\n        }\\n\\n        if (voucher.phase > currentPhase) {\\n            revert MintPhase();\\n        }\\n\\n        if (desiredQty > voucher.qty) {\\n            revert VoucherQty();\\n        }\\n\\n        // enforce minting fee included\\n        if (msg.value != (voucher.free == 1 ? 0 : (_getMintFee(currentPhase, desiredQty)))) {\\n            revert MintFee();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/facets/Mint/MintFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {MintInternal} from \\\"./MintInternal.sol\\\";\\nimport {MintStorage} from \\\"../../libraries/storage/MintStorage.sol\\\";\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  MintFacet\\n * @author slvrfn\\n * @notice Implementation contract of the abstract MintInternal. The role of this contract is to manage the mint\\n *         process and associated control-parameters\\n */\\ncontract MintFacet is MintInternal {\\n    using MintStorage for MintStorage.Layout;\\n\\n    /**\\n     * @notice Allows creation of a variable number of NFTs to a chosen holder, using a MintVoucher.\\n     * @param  holder - recipient of the minted NFTs.\\n     * @param  mintQty - the chosen quantity of NFTs to mint.\\n     * @param  voucher - the MintVoucher that acts as a \\\"permission slip\\\" to mint NFTs.\\n     */\\n    function createTokens(address holder, uint16 mintQty, MintVoucher calldata voucher) public payable {\\n        _createTokens(holder, mintQty, voucher);\\n    }\\n\\n    /**\\n     * @notice Update the current Mint phase.\\n     * @param  newPhase - the new mint phase.\\n     */\\n    function setMintingPhase(uint16 newPhase) external onlyRole(keccak256(\\\"admin\\\")) {\\n        _setMintingPhase(newPhase);\\n    }\\n\\n    /**\\n     * @notice Get the current Mint phase.\\n     */\\n    function getMintPhase() external view returns (uint16) {\\n        return _getMintPhase();\\n    }\\n\\n    /**\\n     * @notice Update the max tokens that can be minted by any one address.\\n     * @param  newMax - the new max.\\n     */\\n    function setMaxTokensPerAddress(uint16 newMax) external onlyRole(keccak256(\\\"admin\\\")) {\\n        MintStorage.Layout storage m = MintStorage.layout();\\n        _setMaxTokensPerAddress(m, newMax);\\n    }\\n\\n    /**\\n     * @notice Get the max tokens that can be minted by any one address.\\n     */\\n    function getMaxTokensPerAddress() external view returns (uint16 maxTokensPerAddress) {\\n        return _getMaxTokensPerAddress();\\n    }\\n\\n    /**\\n     * @notice Update the fee for a specific mint phase.\\n     * @param  phase - the phase that will have its mint fee updated.\\n     * @param  newFee - the new mint fee for the provided phase.\\n     */\\n    function setMintingFee(uint256 phase, uint256 newFee) external onlyRole(keccak256(\\\"admin\\\")) {\\n        MintStorage.Layout storage m = MintStorage.layout();\\n        _setMintingFee(m, phase, newFee);\\n    }\\n\\n    /**\\n     * @notice Returns the mint fee for a chosen mint phase.\\n     * @param  phase - the phase to get the mint fee for.\\n     */\\n    function getMintFee(uint256 phase, uint16 qty) external view returns (uint256) {\\n        return _getMintFee(phase, qty);\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/facets/Mint/MintInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {AccessControlInternal} from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport {AccessControlInternal} from \\\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\\\";\\nimport {ERC721BaseInternal} from \\\"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\\\";\\nimport {ERC721EnumerableInternal} from \\\"@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol\\\";\\nimport {FeatureFlag} from \\\"../../base/FeatureFlag.sol\\\";\\nimport {TokenStorage} from \\\"../../libraries/storage/TokenStorage.sol\\\";\\nimport {MintStorage} from \\\"../../libraries/storage/MintStorage.sol\\\";\\nimport {BaseStorage} from \\\"../../base/BaseStorage.sol\\\";\\nimport {MintVoucherVerifier} from \\\"../../base/MintVoucherVerifier.sol\\\";\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  MintInternal\\n * @author slvrfn\\n * @notice Abstract contract which contains the necessary logic to manage the mint process and associated\\n *         control-parameters\\n * @dev    This contract is meant to be inherited by contracts so they can use the internal functions\\n *         as desired\\n */\\nabstract contract MintInternal is BaseStorage, AccessControlInternal, FeatureFlag, MintVoucherVerifier, ERC721BaseInternal, ERC721EnumerableInternal {\\n    using TokenStorage for TokenStorage.Layout;\\n    using MintStorage for MintStorage.Layout;\\n\\n    /**\\n     * @dev Broadcast when the minting fee is updated\\n     */\\n    event UpdateMintingFee(uint256 phase, uint256 fee);\\n    /**\\n     * @dev Broadcast when the max tokens per address limit is updated\\n     */\\n    event UpdateMaxTokensPerAddress(uint16 count);\\n    /**\\n     * @dev Broadcast when the current mint phase is updated\\n     */\\n    event UpdateMintPhase(uint16 phase);\\n    /**\\n     * @dev Raised if a user tries to mint through a smart contract.\\n     */\\n    error SmartContract();\\n\\n    /**\\n     * @notice See {ERC721BaseInternal-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev   Increments the overall token id counter and mints a NFT to the provided holder.\\n     * @param holder - the recipient of the token being minted.\\n     */\\n    function __mintToken(MintStorage.Layout storage m, address holder) internal {\\n        uint216 tokenId = m._postincTokenIdCounter();\\n\\n        super._safeMint(holder, tokenId);\\n    }\\n\\n    /**\\n     * @dev   Allows minting several NFTs at once, Incrementing the overall token id counter and mints the qty of\\n     *        tokens to the provided holder.\\n     * @param holder - the recipient of the token being minted.\\n     * @param qty - the number of NFTs to be minted.\\n     */\\n    function __mintTokens(MintStorage.Layout storage m, address holder, uint256 qty) internal {\\n        for (uint i = 0; i < qty; ) {\\n            __mintToken(m, holder);\\n\\n            // save some gas\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev   Checks additional features of the voucher to make sure it is being consumed when/how expected.\\n     * @param voucherSigner - the signer of the MintVoucher.\\n     * @param qty - the number of NFTs to be minted.\\n     */\\n    function _ensureCanMintQty(MintStorage.Layout storage m, address voucherSigner, uint16 qty) internal {\\n        uint16 desiredQty = 0;\\n        uint16 currentPhase = m._mintPhase();\\n\\n        bytes32 checkRole = bytes32(0);\\n        // determine the expected role based on phase\\n        if (currentPhase == 1) {\\n            // only members of FriendsList\\n            checkRole = keccak256(\\\"friendsSigner\\\");\\n        } else if (currentPhase == 2) {\\n            // members of FriendsList & FCFS\\n            checkRole = keccak256(\\\"fcfsSigner\\\");\\n        } else if (currentPhase == 3) {\\n            // everyone can mint in public\\n            checkRole = keccak256(\\\"publicSigner\\\");\\n        }\\n\\n        // remaining tokens an address can mint\\n        // users can mint up to the max per address limit\\n        uint16 maxPerAddress = m._maxTokensPerAddress();\\n        uint256 mintedPerAddress = m._tokensMintedPerAddress(msg.sender);\\n\\n        if(mintedPerAddress > maxPerAddress){\\n            revert MintLimit();\\n        }\\n\\n        uint256 remaining = maxPerAddress - mintedPerAddress;\\n\\n        // check if the voucher being used has the correct role based on phase\\n        if (checkRole != bytes32(0) && _hasRole(checkRole, voucherSigner)) {\\n            desiredQty = qty;\\n        }\\n        // else check if user is admin\\n        else if (_hasRole(keccak256(\\\"admin\\\"), msg.sender)) {\\n            desiredQty = qty;\\n            uint32 maxTokens = s.maxTokens;\\n            uint216 tokenCounter = m._tokenIdCounter();\\n            if(tokenCounter > maxTokens){\\n                revert MintLimit();\\n            }\\n\\n            remaining = s.maxTokens - m._tokenIdCounter();\\n        }\\n        // otherwise, user is not allowed to mint/or attempted out of assigned phase\\n        else {\\n            revert VoucherInvalid();\\n        }\\n\\n        // remaining > count >= 1\\n        if ((desiredQty > remaining) || (desiredQty < 1)) {\\n            // Cannot mint more than the maximum\\n            revert MintLimit();\\n        }\\n        m._incTokensMintedPerAddress(msg.sender, desiredQty);\\n    }\\n\\n    /**\\n     * @dev   Allows creation of a variable number of NFTs to a chosen holder, using a MintVoucher.\\n     * @param holder - recipient of the minted NFTs.\\n     * @param mintQty - the chosen quantity of NFTs to mint.\\n     * @param voucher - the MintVoucher that acts as a \\\"permission slip\\\" to mint NFTs.\\n     */\\n    function _createTokens(address holder, uint16 mintQty, MintVoucher calldata voucher) internal {\\n        // prevent smart contracts from being able to initiate mint\\n        // the holder can still be a smart-contract (vault/etc)\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) {\\n            revert SmartContract();\\n        }\\n\\n        _requireFeaturesEnabled(0, PAUSED_FLAG_BIT | MINT_FLAG_BIT);\\n\\n        MintStorage.Layout storage m = MintStorage.layout();\\n\\n        uint40 currentPhase = m._mintPhase();\\n\\n        // mint has ended\\n        if (currentPhase > 3) {\\n            revert MintPhase();\\n        }\\n\\n        // check voucher is valid, and claim it if not in the public mint\\n        address voucherSigner = _checkVoucherGetSigner(voucher, currentPhase, mintQty, currentPhase != 3);\\n\\n        // check if user allowed to mint based on voucher-role/own-role/phase\\n        _ensureCanMintQty(m, voucherSigner, mintQty);\\n\\n        // if only minting 1 token, no need to allocate extra memory\\n        if (voucher.qty == 1) {\\n            __mintToken(m, holder);\\n            return;\\n        }\\n\\n        __mintTokens(m, holder, mintQty);\\n    }\\n\\n    /**\\n     * @dev   Returns the mint fee for a chosen mint phase.\\n     * @param currentPhase - the phase to get the mint fee for.\\n     */\\n    function _getMintFee(uint256 currentPhase, uint16 qty) internal view override(MintVoucherVerifier) returns (uint256) {\\n        return MintStorage.layout()._phaseFee(currentPhase) * qty;\\n    }\\n\\n    /**\\n     * @dev   Update the current Mint phase.\\n     * @param newPhase - the new mint phase.\\n     */\\n    function _setMintingPhase(uint16 newPhase) internal onlyRole(keccak256(\\\"admin\\\")) {\\n        MintStorage.Layout storage m = MintStorage.layout();\\n        m._setMintPhase(newPhase);\\n        emit UpdateMintPhase(newPhase);\\n    }\\n\\n    /**\\n     * @dev   Get the current Mint phase.\\n     */\\n    function _getMintPhase() internal view returns (uint16) {\\n        return MintStorage.layout()._mintPhase();\\n    }\\n\\n    /**\\n     * @dev   Update the max tokens that can be minted by any one address.\\n     * @param newMax - the new max.\\n     */\\n    function _setMaxTokensPerAddress(MintStorage.Layout storage m, uint16 newMax) internal onlyRole(keccak256(\\\"admin\\\")) {\\n        m._setMaxTokensPerAddress(newMax);\\n        emit UpdateMaxTokensPerAddress(newMax);\\n    }\\n\\n    /**\\n     * @dev Get the max tokens that can be minted by any one address.\\n     */\\n    function _getMaxTokensPerAddress() internal view returns (uint16 maxTokensPerAddress) {\\n        return MintStorage.layout()._maxTokensPerAddress();\\n    }\\n\\n    /**\\n     * @dev   Update the fee for a specific mint phase.\\n     * @param phase - the phase that will have its mint fee updated.\\n     * @param newFee - the new mint fee for the provided phase.\\n     */\\n    function _setMintingFee(MintStorage.Layout storage m, uint256 phase, uint256 newFee) internal onlyRole(keccak256(\\\"admin\\\")) {\\n        m._setPhaseFee(phase, newFee);\\n        emit UpdateMintingFee(phase, newFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/libraries/LibEIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Forked from OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\npragma solidity ^0.8.20;\\n\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @title  LibEIP712\\n * @author slvrfn\\n * @notice https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n *      The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n *      thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n *      they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n *      This library implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n *      scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n *      ({_hashTypedDataV4}).\\n *\\n *      The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n *      the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n *      NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n *      https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n *      _Available since v3.4._\\n * @dev Updated to allow using Diamond storage pattern, and some managing of signed vouchers\\n */\\nlibrary LibEIP712 {\\n    using LibEIP712 for LibEIP712.Layout;\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"genesis.libraries.storage.LibEIP712\\\");\\n\\n    /* solhint-disable var-name-mixedcase */\\n    struct Layout {\\n        // Cache the domain separator, but also store the chain id that it corresponds to, in order to\\n        // invalidate the cached domain separator if the chain id changes.\\n        bytes32 _CACHED_DOMAIN_SEPARATOR;\\n        uint256 _CACHED_CHAIN_ID;\\n        address _CACHED_THIS;\\n        bytes32 _HASHED_NAME;\\n        bytes32 _HASHED_VERSION;\\n        bytes32 _TYPE_HASH;\\n        mapping(uint256 => uint256) voucherClaimed;\\n    }\\n\\n    /* solhint-disable var-name-mixedcase */\\n    function layout() internal pure returns (Layout storage e) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            e.slot := slot\\n        }\\n    }\\n\\n    function _setup(Layout storage e, bytes32 hashedName, uint256 cachedChainId, address cachedThis, bytes32 typeHash) internal {\\n        e._HASHED_NAME = hashedName;\\n        e._CACHED_CHAIN_ID = cachedChainId;\\n        e._CACHED_THIS = cachedThis;\\n        e._TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4(Layout storage e) internal view returns (bytes32) {\\n        if (address(this) == e._CACHED_THIS && block.chainid == e._CACHED_CHAIN_ID) {\\n            return e._CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return __buildDomainSeparator(e._TYPE_HASH, e._HASHED_NAME, e._HASHED_VERSION);\\n        }\\n    }\\n\\n    function __buildDomainSeparator(bytes32 typeHash, bytes32 nameHash, bytes32 versionHash) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(Layout storage e, bytes32 structHash) internal view returns (bytes32) {\\n        return ECDSA.toTypedDataHash(e._domainSeparatorV4(), structHash);\\n    }\\n\\n    function _updateVersion(Layout storage e, string memory version) internal returns (bytes32) {\\n        bytes32 hashedVersion = keccak256(abi.encodePacked(version));\\n        e._HASHED_VERSION = hashedVersion;\\n        e._CACHED_DOMAIN_SEPARATOR = __buildDomainSeparator(e._TYPE_HASH, e._HASHED_NAME, hashedVersion);\\n        return hashedVersion;\\n    }\\n\\n    function _hashedVersion(Layout storage e) internal view returns (bytes32) {\\n        return e._HASHED_VERSION;\\n    }\\n\\n    function claimVoucher(Layout storage e, uint256 voucherNonce, uint256 amount) internal {\\n        // save some gas\\n        unchecked {\\n            e.voucherClaimed[voucherNonce] += amount;\\n        }\\n    }\\n\\n    function isVoucherClaimed(Layout storage e, uint256 nonce, uint256 max, uint16 desiredQty) internal view returns (bool) {\\n        return (e.voucherClaimed[nonce] + desiredQty) > max;\\n    }\\n\\n    /// @notice Verifies the digest for a given signature, returning the address of the signer.\\n    /// @dev Will revert if the signature is invalid. Does not verify that the signer is authorized to do anything.\\n    /// @param digest the typed keccak256 digest of some data.\\n    /// @param signature An ECDSA signature of some data.\\n    function _verifySignedData(bytes32 digest, bytes memory signature) internal pure returns (address) {\\n        return ECDSA.recover(digest, signature);\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/libraries/storage/FlagStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  FlagStorage\\n * @author slvrfn\\n * @notice Library responsible for loading the associated \\\"layout\\\" from storage, and setting/retrieving\\n *         the internal fields.\\n */\\nlibrary FlagStorage {\\n    struct Layout {\\n        mapping(uint256 => uint256) flagBits;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"genesis.libraries.storage.FlagStorage\\\");\\n\\n    /**\\n     * @notice Obtains the FlagStorage layout from storage.\\n     * @dev    layout is stored at the chosen STORAGE_SLOT.\\n     */\\n    function layout() internal pure returns (Layout storage f) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            f.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev    Obtains the 256-bit feature-flag bitmask associated with a flagGroup\\n     * @param  flagGroup - the group of flags to lookup.\\n     */\\n    function _flagBits(Layout storage f, uint256 flagGroup) internal view returns (uint256) {\\n        return f.flagBits[flagGroup];\\n    }\\n\\n    /**\\n     * @dev    Checks if the feature-flag(s) bitmask associated with a flagGroup is are unset.\\n     * @param  flagGroup - the group of flags to lookup.\\n     */\\n    function _flagBitsUnset(Layout storage f, uint256 flagGroup, uint256 notMatchBits) internal view returns (bool) {\\n        // check notMatchBits are NOT SET\\n        return (f.flagBits[flagGroup] & notMatchBits) == 0;\\n    }\\n\\n    /**\\n     * @dev    Updates the 256-bit feature-flag bitmask associated with a flagGroup.\\n     * @param  flagGroup - the group of flags to lookup.\\n     */\\n    function _setFlagBits(Layout storage f, uint256 flagGroup, uint256 bits) internal {\\n        f.flagBits[flagGroup] = bits;\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/libraries/storage/LibAppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  LibAppStorage\\n * @author slvrfn\\n * @notice Library responsible for loading the associated AppStorage from storage, and setting/retrieving\\n *         the internal fields.\\n */\\nlibrary LibAppStorage {\\n    struct AppStorage {\\n        uint32 maxTokens;\\n        address royaltyRecipient;\\n        uint16 royaltyPct; // stored as an integer, where 1 = 0.01%\\n    }\\n\\n    /**\\n     * @notice Obtains the AppStorage layout from storage.\\n     * @dev    layout is stored at position 0.\\n     */\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/libraries/storage/MintStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  MintStorage\\n * @author slvrfn\\n * @notice Library responsible for loading the associated \\\"layout\\\" from storage, and setting/retrieving\\n *         the internal fields.\\n */\\nlibrary MintStorage {\\n    using MintStorage for MintStorage.Layout;\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"genesis.libraries.storage.MintStorage\\\");\\n\\n    struct Layout {\\n        uint216 tokenIdCounter;\\n        uint16 mintPhase;\\n        uint16 maxTokensPerAddress;\\n        mapping(address => uint256) tokensMintedPerAddress;\\n        mapping(uint256 => uint256) phaseFee;\\n    }\\n\\n    /**\\n     * @notice Obtains the MintStorage layout from storage.\\n     * @dev    layout is stored at the chosen STORAGE_SLOT.\\n     */\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            s.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current token id counter.\\n     */\\n    function _tokenIdCounter(Layout storage m) internal view returns (uint216) {\\n        return m.tokenIdCounter;\\n    }\\n\\n    /**\\n     * @dev Obtains the current tokenIdCounter, incrementing it afterwards for later use.\\n     */\\n    function _postincTokenIdCounter(Layout storage m) internal returns (uint216) {\\n        // token id is current state of the counter\\n        uint216 tokenId = m.tokenIdCounter;\\n        // increment tokenId counter\\n        // save some gas\\n        unchecked {\\n            ++m.tokenIdCounter;\\n        }\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev Returns the current mint phase.\\n     */\\n    function _mintPhase(Layout storage m) internal view returns (uint16) {\\n        return m.mintPhase;\\n    }\\n\\n    /**\\n     * @dev   Updates the current mint phase.\\n     * @param newPhase - the new mint phase.\\n     */\\n    function _setMintPhase(Layout storage m, uint16 newPhase) internal {\\n        m.mintPhase = newPhase;\\n    }\\n\\n    /**\\n     * @dev Returns the current max tokens per address.\\n     */\\n    function _maxTokensPerAddress(Layout storage m) internal view returns (uint16) {\\n        return m.maxTokensPerAddress;\\n    }\\n\\n    /**\\n     * @dev   Updates the current max tokens per address.\\n     * @param newMax - the new max.\\n     */\\n    function _setMaxTokensPerAddress(Layout storage m, uint16 newMax) internal {\\n        m.maxTokensPerAddress = newMax;\\n    }\\n\\n    /**\\n     * @dev Returns the current number tokens minted by an address.\\n     * @param addr - the address to check.\\n     */\\n    function _tokensMintedPerAddress(Layout storage m, address addr) internal view returns (uint256) {\\n        return m.tokensMintedPerAddress[addr];\\n    }\\n\\n    /**\\n     * @dev   Updates the current max tokens per address.\\n     * @param addr - the address to get incremented.\\n     * @param qty - how much to increment by.\\n     */\\n    function _incTokensMintedPerAddress(Layout storage m, address addr, uint256 qty) internal {\\n        // save some gas\\n        unchecked {\\n            m.tokensMintedPerAddress[addr] += qty;\\n        }\\n    }\\n\\n    /**\\n     * @dev   Returns the current fee associated with a mint phase\\n     * @param phase - the phase to check.\\n     */\\n    function _phaseFee(Layout storage m, uint256 phase) internal view returns (uint256) {\\n        return m.phaseFee[phase];\\n    }\\n\\n    /**\\n     * @dev   Returns the current fee associated with a mint phase\\n     * @param phase - the phase to have its fee updated.\\n     * @param newFee - the new mint fee.\\n     */\\n    function _setPhaseFee(Layout storage m, uint256 phase, uint256 newFee) internal {\\n        m.phaseFee[phase] = newFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"Contracts/libraries/storage/TokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n *  \u2554\u2557  \u2554\u2557\u2554\u2557      \u2554\u2557 \u2554\u2557     \u2554\u2557\\n *  \u2551\u255a\u2557\u2554\u255d\u2560\u255d\u255a\u2557     \u2551\u2551 \u2551\u2551     \u2551\u2551\\n *  \u255a\u2557\u2551\u2551\u2554\u256c\u2557\u2554\u256c\u2550\u2566\u2566\u2550\u2550\u2563\u2551 \u2551\u2551  \u2554\u2550\u2550\u2563\u255a\u2550\u2566\u2550\u2550\u2557\\n *   \u2551\u255a\u255d\u2560\u2563\u2551\u2551\u2551\u2554\u256c\u2563\u2554\u2557\u2551\u2551 \u2551\u2551 \u2554\u2563\u2554\u2557\u2551\u2554\u2557\u2551\u2550\u2550\u2563\\n *   \u255a\u2557\u2554\u2563\u2551\u2551\u255a\u2563\u2551\u2551\u2551\u255a\u255d\u2551\u255a\u2557\u2551\u255a\u2550\u255d\u2551\u2554\u2557\u2551\u255a\u255d\u2560\u2550\u2550\u2551\\n *    \u255a\u255d\u255a\u255d\u255a\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u255d\u255a\u2550\u2550\u2550\u2569\u255d\u255a\u2569\u2550\u2550\u2569\u2550\u2550\u255d\\n */\\n\\n/**\\n * @title  TokenStorage\\n * @author slvrfn\\n * @notice Library responsible for loading the associated \\\"layout\\\" from storage, and setting/retrieving\\n *         the internal fields.\\n */\\nlibrary TokenStorage {\\n    using TokenStorage for TokenStorage.Layout;\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"genesis.libraries.storage.TokenStorage\\\");\\n\\n    struct Layout {\\n        string baseRelicUri;\\n        mapping(uint256 => mapping(uint256 => uint256)) tokenData;\\n    }\\n\\n    /**\\n     * @notice Obtains the TokenStorage layout from storage.\\n     * @dev    layout is stored at the chosen STORAGE_SLOT.\\n     */\\n    function layout() internal pure returns (Layout storage t) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            t.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev returns the current base Relic uri.\\n     */\\n    function _baseRelicUri(Layout storage t) internal view returns (string memory) {\\n        return t.baseRelicUri;\\n    }\\n\\n    /**\\n     * @dev updates the current base Relic uri.\\n     */\\n    function _setBaseRelicUri(Layout storage t, string memory uri) internal {\\n        t.baseRelicUri = uri;\\n    }\\n\\n    /**\\n     * @dev returns the current token data associated with a token id and data position.\\n     * @param relicId - the relic to obtain data from\\n     * @param loc - the position in the token's data storage\\n     */\\n    function _tokenData(Layout storage t, uint256 relicId, uint256 loc) internal view returns (uint256) {\\n        return t.tokenData[relicId][loc];\\n    }\\n\\n    /**\\n     * @dev updates the current token data associated with a token id and data position.\\n     * @param relicId - the relic to obtain data from\\n     * @param loc - the position in the token's data storage\\n     * @param bits - the data to be assigned to a tokens data storage\\n     */\\n    function _setTokenData(Layout storage t, uint256 relicId, uint256 loc, uint256 bits) internal {\\n        t.tokenData[relicId][loc] = bits;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 50000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AddressUtils__NotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__BalanceQueryZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__ERC721ReceiverNotImplemented\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__NotOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__NotTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__SelfApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__TokenAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721Base__TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlagMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SmartContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UintUtils__InsufficientHexLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VoucherAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VoucherClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VoucherInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VoucherQty\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"flagGroup\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"FlagUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"UpdateMaxTokensPerAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"phase\",\"type\":\"uint16\"}],\"name\":\"UpdateMintPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"UpdateMintingFee\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"mintQty\",\"type\":\"uint16\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"qty\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"phase\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"free\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct MintVoucherVerifier.MintVoucher\",\"name\":\"voucher\",\"type\":\"tuple\"}],\"name\":\"createTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTokensPerAddress\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"maxTokensPerAddress\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"qty\",\"type\":\"uint16\"}],\"name\":\"getMintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPhase\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newMax\",\"type\":\"uint16\"}],\"name\":\"setMaxTokensPerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setMintingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newPhase\",\"type\":\"uint16\"}],\"name\":\"setMintingPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MintFacet", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "50000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}