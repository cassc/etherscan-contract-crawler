{"SourceCode": "// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *    is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n    /**\r\n     * 0x780e9d63 ===\r\n     *     bytes4(keccak256('totalSupply()')) ^\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner));\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply());\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\r\n        // lasTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    /**\r\n     * 0x5b5e139f ===\r\n     *     bytes4(keccak256('name()')) ^\r\n     *     bytes4(keccak256('symbol()')) ^\r\n     *     bytes4(keccak256('tokenURI(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId));\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId));\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\r\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/strings.sol\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly {\r\n            retptr := add(ret, 32)\r\n        }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: contracts/Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n/**\r\n* Metadata contract is upgradeable and returns metadata about Token\r\n*/\r\n\r\n\r\ncontract Metadata {\r\n    using strings for *;\r\n\r\n    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {\r\n        string memory base = \"https://folia.app/v1/metadata/\";\r\n        string memory id = uint2str(_tokenId);\r\n        return base.toSlice().concat(id.toSlice());\r\n    }\r\n    function uint2str(uint i) internal pure returns (string memory) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0) {\r\n            uint _uint = 48 + i % 10;\r\n            bstr[k--] = toBytes(_uint)[31];\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    function toBytes(uint256 x) public pure returns (bytes memory b) {\r\n        b = new bytes(32);\r\n        assembly { mstore(add(b, 32), x) }\r\n    }\r\n}\r\n\r\n// File: contracts/Folia.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The Token contract does this and that...\r\n */\r\ncontract Folia is ERC721Full, Ownable {\r\n    using Roles for Roles.Role;\r\n    Roles.Role private _admins;\r\n    uint8 admins;\r\n\r\n    address public metadata;\r\n    address public controller;\r\n\r\n    modifier onlyAdminOrController() {\r\n        require((_admins.has(msg.sender) || msg.sender == controller), \"DOES_NOT_HAVE_ADMIN_OR_CONTROLLER_ROLE\");\r\n        _;\r\n    }\r\n\r\n    constructor(string memory name, string memory symbol, address _metadata) public ERC721Full(name, symbol) {\r\n        metadata = _metadata;\r\n        _admins.add(msg.sender);\r\n        admins += 1;\r\n    }\r\n\r\n    function mint(address recepient, uint256 tokenId) public onlyAdminOrController {\r\n        _mint(recepient, tokenId);\r\n    }\r\n    function burn(uint256 tokenId) public onlyAdminOrController {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n    function updateMetadata(address _metadata) public onlyAdminOrController {\r\n        metadata = _metadata;\r\n    }\r\n    function updateController(address _controller) public onlyAdminOrController {\r\n        controller = _controller;\r\n    }\r\n\r\n    function addAdmin(address _admin) public onlyOwner {\r\n        _admins.add(_admin);\r\n        admins += 1;\r\n    }\r\n    function removeAdmin(address _admin) public onlyOwner {\r\n        require(admins > 1, \"CANT_REMOVE_LAST_ADMIN\");\r\n        _admins.remove(_admin);\r\n        admins -= 1;\r\n    }\r\n\r\n    function tokenURI(uint _tokenId) external view returns (string memory _infoUrl) {\r\n        return Metadata(metadata).tokenURI(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Moves Eth to a certain address for use in the FoliaController\r\n    * @param _to The address to receive the Eth.\r\n    * @param _amount The amount of Eth to be transferred.\r\n    */\r\n    function moveEth(address payable _to, uint256 _amount) public onlyAdminOrController {\r\n        require(_amount <= address(this).balance);\r\n        _to.transfer(_amount);\r\n    }\r\n    /**\r\n    * @dev Moves Token to a certain address for use in the FoliaController\r\n    * @param _to The address to receive the Token.\r\n    * @param _amount The amount of Token to be transferred.\r\n    * @param _token The address of the Token to be transferred.\r\n    */\r\n    function moveToken(address _to, uint256 _amount, address _token) public onlyAdminOrController returns (bool) {\r\n        require(_amount <= IERC20(_token).balanceOf(address(this)));\r\n        return IERC20(_token).transfer(_to, _amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/DotComSeance.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n ______   _______ _________ _______  _______  _______ \r\n(  __  \\ (  ___  )\\__   __/(  ____ \\(  ___  )(       )\r\n| (  \\  )| (   ) |   ) (   | (    \\/| (   ) || () () |\r\n| |   ) || |   | |   | |   | |      | |   | || || || |\r\n| |   | || |   | |   | |   | |      | |   | || |(_)| |\r\n| |   ) || |   | |   | |   | |      | |   | || |   | |\r\n| (__/  )| (___) |   | |   | (____/\\| (___) || )   ( |\r\n(______/ (_______)   )_(   (_______/(_______)|/     \\|\r\n                                                      \r\n _______  _______  _______  _        _______  _______ \r\n(  ____ \\(  ____ \\(  ___  )( (    /|(  ____ \\(  ____ \\\r\n| (    \\/| (    \\/| (   ) ||  \\  ( || (    \\/| (    \\/\r\n| (_____ | (__    | (___) ||   \\ | || |      | (__    \r\n(_____  )|  __)   |  ___  || (\\ \\) || |      |  __)   \r\n      ) || (      | (   ) || | \\   || |      | (      \r\n/\\____) || (____/\\| )   ( || )  \\  || (____/\\| (____/\\\r\n\\_______)(_______/|/     \\||/    )_)(_______/(_______/\r\n                                                      \r\n\r\n\"There are no bad ideas in tech, only bad timing\"\r\n- Marc Andreessen\r\n\r\nDotCom Seance \u2014 Simon Denny, Guile Twardowski, Cosmographia (David Holz)\r\nPublished in partnership wth Folia (Billy Rennenkamp, Dan Denorch, Everett Williams)\r\n*/\r\n\r\ncontract DotComSeance is Folia {\r\n    constructor(address _metadata) public Folia(\"DotCom Seance\", \"DOTCOM\", _metadata){}\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: contracts/DotComSeanceController.sol\r\n\r\npragma solidity ^0.5.0;\r\n/**\r\n * The FoliaControllerV2 is an upgradeable endpoint for controlling Folia.sol\r\n */\r\n\r\n\r\n\r\n\r\n\r\ncontract DotComSeanceController is Ownable, ReentrancyGuard {\r\n\r\n    event newWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool _paused);\r\n    event updatedWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool _paused);\r\n    event editionBought(uint256 workId, uint256 editionId, uint256 tokenId, address recipient, uint256 paid, uint256 artistReceived, uint256 adminReceived);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum SaleType {noID, ID}\r\n\r\n    uint256 constant MAX_EDITIONS = 100;\r\n    uint256 public latestWorkId = 0;\r\n\r\n\r\n    mapping (uint256 => Work) public _works;\r\n    struct Work {\r\n        bool exists;\r\n        bool paused;\r\n        SaleType saleType;\r\n        uint256 editions;\r\n        uint256 printed;\r\n        uint256 price;\r\n        address payable artist;\r\n    }\r\n\r\n    DotComSeance public dotComSeance;\r\n\r\n    uint256 public adminSplit = 20;\r\n    address payable public adminWallet;\r\n    bool public paused;\r\n\r\n    modifier notPaused() {\r\n        require(!paused, \"Must not be paused\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        DotComSeance _dotComSeance,\r\n        address payable _adminWallet\r\n    ) public {\r\n        dotComSeance = _dotComSeance;\r\n        adminWallet = _adminWallet;\r\n    }\r\n\r\n    function addArtwork(address payable artist, uint256 editions, uint256 price, bool _paused, SaleType saleType) public onlyOwner {\r\n        require(editions < MAX_EDITIONS, \"MAX_EDITIONS_EXCEEDED\");\r\n\r\n\r\n        _works[latestWorkId] = Work({\r\n          exists: true,\r\n          paused: _paused,\r\n          saleType: saleType,\r\n          editions: editions,\r\n          printed: 0,\r\n          price: price,\r\n          artist: artist\r\n        });\r\n\r\n        latestWorkId += 1;\r\n\r\n        emit newWork(latestWorkId, artist, editions, price, _paused);\r\n    }\r\n\r\n    function updateArtworkPaused(uint256 workId, bool _paused) public onlyOwner {\r\n        Work storage work = _works[workId];\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n        work.paused = _paused;\r\n        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\r\n    }\r\n\r\n    function updateArtworkEditions(uint256 workId, uint256 _editions) public onlyOwner {\r\n        Work storage work = _works[workId];\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n        require(work.printed < _editions, \"WORK_EXCEEDS_EDITIONS\");\r\n        work.editions = _editions;\r\n        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\r\n    }\r\n\r\n    function updateArtworkPrice(uint256 workId, uint256 _price) public onlyOwner {\r\n        Work storage work = _works[workId];\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n        work.price = _price;\r\n        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\r\n    }\r\n\r\n    function updateArtworkArtist(uint256 workId, address payable _artist) public onlyOwner {\r\n        Work storage work = _works[workId];\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n        work.artist = _artist;\r\n        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\r\n    }\r\n\r\n    function buyByID(address recipient, uint256 workId, uint256 editionId) public payable notPaused nonReentrant returns(bool) {\r\n        Work storage work = _works[workId];\r\n        require(!work.paused, \"WORK_NOT_YET_FOR_SALE\");\r\n        require(work.saleType == SaleType.ID, \"WRONG_SALE_TYPE\");\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n\r\n        require(work.editions >= editionId && editionId > 0, \"OUTSIDE_RANGE_OF_EDITIONS\");\r\n        uint256 tokenId = workId.mul(MAX_EDITIONS).add(editionId);\r\n\r\n        require(msg.value == work.price, \"DID_NOT_SEND_PRICE\");\r\n\r\n        work.printed += 1;\r\n        dotComSeance.mint(recipient, tokenId);\r\n        \r\n        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\r\n        uint256 artistReceives = msg.value.sub(adminReceives);\r\n\r\n        (bool success, ) = adminWallet.call.value(adminReceives)(\"\");\r\n        require(success, \"admin failed to receive\");\r\n\r\n        (success, ) = work.artist.call.value(artistReceives)(\"\");\r\n        require(success, \"artist failed to receive\");\r\n\r\n        emit editionBought(workId, editionId, tokenId, recipient,  work.price, artistReceives, adminReceives);\r\n    }\r\n\r\n    function buy(address recipient, uint256 workId) public payable notPaused nonReentrant returns (bool) {\r\n        Work storage work = _works[workId];\r\n        require(!work.paused, \"WORK_NOT_YET_FOR_SALE\");\r\n        require(work.saleType == SaleType.noID, \"WRONG_SALE_TYPE\");\r\n        require(work.exists, \"WORK_DOES_NOT_EXIST\");\r\n        require(work.editions > work.printed, \"EDITIONS_EXCEEDED\");\r\n        require(msg.value == work.price, \"DID_NOT_SEND_PRICE\");\r\n\r\n        uint256 editionId = work.printed.add(1);\r\n        work.printed = editionId;\r\n        \r\n        uint256 tokenId = workId.mul(MAX_EDITIONS).add(editionId);\r\n\r\n        dotComSeance.mint(recipient, tokenId);\r\n        \r\n        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\r\n        uint256 artistReceives = msg.value.sub(adminReceives);\r\n\r\n        (bool success, ) = adminWallet.call.value(adminReceives)(\"\");\r\n        require(success, \"admin failed to receive\");\r\n        \r\n        (success, ) = work.artist.call.value(artistReceives)(\"\");\r\n        require(success, \"artist failed to receive\");\r\n\r\n        emit editionBought(workId, editionId, tokenId, recipient,  work.price, artistReceives, adminReceives);\r\n    }\r\n\r\n    function updateAdminSplit(uint256 _adminSplit) public onlyOwner {\r\n        require(_adminSplit <= 100, \"SPLIT_MUST_BE_LTE_100\");\r\n        adminSplit = _adminSplit;\r\n    }\r\n\r\n    function updateAdminWallet(address payable _adminWallet) public onlyOwner {\r\n        adminWallet = _adminWallet;\r\n    }\r\n\r\n    function updatePaused(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"workId\",\"type\":\"uint256\"},{\"name\":\"_editions\",\"type\":\"uint256\"}],\"name\":\"updateArtworkEditions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updatePaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dotComSeance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestWorkId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminSplit\",\"type\":\"uint256\"}],\"name\":\"updateAdminSplit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"workId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateArtworkPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminWallet\",\"type\":\"address\"}],\"name\":\"updateAdminWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"artist\",\"type\":\"address\"},{\"name\":\"editions\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"_paused\",\"type\":\"bool\"},{\"name\":\"saleType\",\"type\":\"uint8\"}],\"name\":\"addArtwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"workId\",\"type\":\"uint256\"},{\"name\":\"editionId\",\"type\":\"uint256\"}],\"name\":\"buyByID\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"workId\",\"type\":\"uint256\"},{\"name\":\"_artist\",\"type\":\"address\"}],\"name\":\"updateArtworkArtist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_works\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"paused\",\"type\":\"bool\"},{\"name\":\"saleType\",\"type\":\"uint8\"},{\"name\":\"editions\",\"type\":\"uint256\"},{\"name\":\"printed\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"artist\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"workId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"workId\",\"type\":\"uint256\"},{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updateArtworkPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminSplit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dotComSeance\",\"type\":\"address\"},{\"name\":\"_adminWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"workId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"artist\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"editions\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"newWork\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"workId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"artist\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"editions\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updatedWork\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"workId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"artistReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"adminReceived\",\"type\":\"uint256\"}],\"name\":\"editionBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "DotComSeanceController", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "0000000000000000000000006ca044fb1cd505c1db4ef7332e73a236ad6cb71c0000000000000000000000002f5866d7215416fa60bedf532856736cd9a76acf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4e9145ee97eeaaf1970a1e32d51963c50d10ca2c53e74a539bf44e7fec5663c2"}