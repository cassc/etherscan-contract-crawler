{"SourceCode": "# @version 0.3.9\r\n\r\n\"\"\"\r\n@title Curve DCA Bot\r\n@license Apache 2.0\r\n@author Volume.finance\r\n\"\"\"\r\n\r\nstruct Deposit:\r\n    depositor: address\r\n    route: address[9]\r\n    swap_params: uint256[3][4]\r\n    pools: address[4]\r\n    input_amount: uint256\r\n    number_trades: uint256\r\n    interval: uint256\r\n    remaining_counts: uint256\r\n    starting_time: uint256\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\ninterface CurveSwapRouter:\r\n    def exchange_multiple(\r\n        _route: address[9],\r\n        _swap_params: uint256[3][4],\r\n        _amount: uint256,\r\n        _expected: uint256,\r\n        _pools: address[4]=[ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS],\r\n        _receiver: address=msg.sender\r\n    ) -> uint256: payable\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE # Virtual ETH\r\nROUTER: immutable(address)\r\nMAX_SIZE: constant(uint256) = 8\r\ncompass_evm: public(address)\r\nadmin: public(address)\r\ndeposit_list: HashMap[uint256, Deposit]\r\nnext_deposit: public(uint256)\r\nrefund_wallet: public(address)\r\nfee: public(uint256)\r\npaloma: public(bytes32)\r\nservice_fee_collector: public(address)\r\n\r\nevent Deposited:\r\n    deposit_id: uint256\r\n    token0: address\r\n    token1: address\r\n    input_amount: uint256\r\n    number_trades: uint256\r\n    interval: uint256\r\n    starting_time: uint256\r\n    depositor: address\r\n\r\nevent Swapped:\r\n    deposit_id: uint256\r\n    remaining_counts: uint256\r\n    amount: uint256\r\n    out_amount: uint256\r\n\r\nevent Canceled:\r\n    deposit_id: uint256\r\n\r\nevent UpdateCompass:\r\n    old_compass: address\r\n    new_compass: address\r\n\r\nevent UpdateRefundWallet:\r\n    old_refund_wallet: address\r\n    new_refund_wallet: address\r\n\r\nevent UpdateFee:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n\r\nevent SetPaloma:\r\n    paloma: bytes32\r\n\r\nevent UpdateServiceFeeCollector:\r\n    old_service_fee_collector: address\r\n    new_service_fee_collector: address\r\n\r\n@external\r\ndef __init__(_compass_evm: address, router: address, _refund_wallet: address, _fee: uint256, _service_fee_collector: address):\r\n    self.compass_evm = _compass_evm\r\n    ROUTER = router\r\n    self.refund_wallet = _refund_wallet\r\n    self.fee = _fee\r\n    self.service_fee_collector = _service_fee_collector\r\n    log UpdateCompass(empty(address), _compass_evm)\r\n    log UpdateRefundWallet(empty(address), _refund_wallet)\r\n    log UpdateFee(0, _fee)\r\n    log UpdateServiceFeeCollector(empty(address), _service_fee_collector)\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"failed transferFrom\"  # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef deposit(route: address[9], swap_params: uint256[3][4], amount: uint256, pools: address[4], number_trades: uint256, interval: uint256, starting_time: uint256):\r\n    _value: uint256 = msg.value\r\n    _fee: uint256 = self.fee\r\n    _fee = _fee * number_trades\r\n    assert _value >= _fee, \"Insufficient fee\"\r\n    send(self.refund_wallet, _fee)\r\n    _value = unsafe_sub(_value, _fee)\r\n    last_index: uint256 = 0\r\n    for i in range(4):\r\n        last_index = 8 - i * 2\r\n        if route[last_index] != empty(address):\r\n            break\r\n    token1: address = route[last_index]\r\n    if route[0] == VETH:\r\n        assert _value >= amount, \"Insufficient deposit\"\r\n        if _value > amount:\r\n            send(msg.sender, unsafe_sub(_value, amount))\r\n    else:\r\n        send(msg.sender, _value)\r\n        self._safe_transfer_from(route[0], msg.sender, self, amount)\r\n    _next_deposit: uint256 = self.next_deposit\r\n    _starting_time: uint256 = starting_time\r\n    if starting_time <= block.timestamp:\r\n        _starting_time = block.timestamp\r\n    assert number_trades > 0, \"Wrong trade count\"\r\n    self.deposit_list[_next_deposit] = Deposit({\r\n        depositor: msg.sender,\r\n        route: route,\r\n        swap_params: swap_params,\r\n        pools: pools,\r\n        input_amount: amount,\r\n        number_trades: number_trades,\r\n        interval: interval,\r\n        remaining_counts: number_trades,\r\n        starting_time: _starting_time\r\n    })\r\n    log Deposited(_next_deposit, route[0], route[last_index], amount, number_trades, interval, _starting_time, msg.sender)\r\n    _next_deposit += 1\r\n    self.next_deposit = _next_deposit\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"failed approve\"  # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transfer\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transfer\r\n\r\n@internal\r\ndef _swap(deposit_id: uint256, remaining_count: uint256, amount_out_min: uint256) -> uint256:\r\n    _deposit: Deposit = self.deposit_list[deposit_id]\r\n    assert _deposit.remaining_counts > 0 and _deposit.remaining_counts == remaining_count, \"wrong count\"\r\n    _amount: uint256 = _deposit.input_amount / _deposit.remaining_counts\r\n    _deposit.input_amount -= _amount\r\n    _deposit.remaining_counts -= 1\r\n    self.deposit_list[deposit_id] = _deposit\r\n    _out_amount: uint256 = 0\r\n    last_index: uint256 = 0\r\n    for i in range(4):\r\n        last_index = 8 - i * 2\r\n        if _deposit.route[last_index] != empty(address):\r\n            break\r\n    if _deposit.route[0] == VETH:\r\n        _out_amount = CurveSwapRouter(ROUTER).exchange_multiple(_deposit.route, _deposit.swap_params, _amount, amount_out_min, _deposit.pools, self, value=_amount)\r\n    else:\r\n        self._safe_approve(_deposit.route[0], ROUTER, _amount)\r\n        _out_amount = CurveSwapRouter(ROUTER).exchange_multiple(_deposit.route, _deposit.swap_params, _amount, amount_out_min, _deposit.pools, self)\r\n    actual_amount: uint256 = 0\r\n    if _deposit.route[last_index] == VETH:\r\n        actual_amount = unsafe_div(_out_amount * 995, 1000)\r\n        send(_deposit.depositor, actual_amount)\r\n        send(self.service_fee_collector, unsafe_sub(_out_amount, actual_amount))\r\n    else:\r\n        actual_amount = unsafe_div(_out_amount * 995, 1000)\r\n        self._safe_transfer(_deposit.route[last_index], _deposit.depositor, actual_amount)\r\n        self._safe_transfer(_deposit.route[last_index], self.service_fee_collector, unsafe_sub(_out_amount, actual_amount))\r\n    log Swapped(deposit_id, _deposit.remaining_counts, _amount, _out_amount)\r\n    return _out_amount\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef multiple_swap(deposit_id: DynArray[uint256, MAX_SIZE], remaining_counts: DynArray[uint256, MAX_SIZE], amount_out_min: DynArray[uint256, MAX_SIZE]):\r\n    assert msg.sender == self.compass_evm, \"Unauthorized\"\r\n    _len: uint256 = len(deposit_id)\r\n    assert _len == len(amount_out_min) and _len == len(remaining_counts), \"Validation error\"\r\n    _len = unsafe_add(unsafe_mul(unsafe_add(_len, 2), 96), 36)\r\n    assert len(msg.data) == _len, \"invalid payload\"\r\n    assert self.paloma == convert(slice(msg.data, unsafe_sub(_len, 32), 32), bytes32), \"invalid paloma\"\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_id):\r\n            break\r\n        self._swap(deposit_id[i], remaining_counts[i], amount_out_min[i])\r\n\r\n@external\r\ndef multiple_swap_view(deposit_id: DynArray[uint256, MAX_SIZE], remaining_counts: DynArray[uint256, MAX_SIZE]) -> DynArray[uint256, MAX_SIZE]:\r\n    assert msg.sender == empty(address) # only for view function\r\n    _len: uint256 = len(deposit_id)\r\n    res: DynArray[uint256, MAX_SIZE] = []\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_id):\r\n            break\r\n        res.append(self._swap(deposit_id[i], remaining_counts[i], 1))\r\n    return res\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef cancel(deposit_id: uint256):\r\n    _deposit: Deposit = self.deposit_list[deposit_id]\r\n    assert _deposit.depositor == msg.sender, \"Unauthorized\"\r\n    assert _deposit.input_amount > 0, \"all traded\"\r\n    if _deposit.route[0] == VETH:\r\n        send(msg.sender, _deposit.input_amount)\r\n    else:\r\n        self._safe_transfer(_deposit.route[0], msg.sender, _deposit.input_amount)\r\n    _deposit.input_amount = 0\r\n    _deposit.remaining_counts = 0\r\n    self.deposit_list[deposit_id] = _deposit\r\n    log Canceled(deposit_id)\r\n\r\n@external\r\ndef update_compass(new_compass: address):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    self.compass_evm = new_compass\r\n    log UpdateCompass(msg.sender, new_compass)\r\n\r\n@external\r\ndef update_refund_wallet(new_refund_wallet: address):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_refund_wallet: address = self.refund_wallet\r\n    self.refund_wallet = new_refund_wallet\r\n    log UpdateRefundWallet(old_refund_wallet, new_refund_wallet)\r\n\r\n@external\r\ndef update_fee(new_fee: uint256):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_fee: uint256 = self.fee\r\n    self.fee = new_fee\r\n    log UpdateFee(old_fee, new_fee)\r\n\r\n@external\r\ndef set_paloma():\r\n    assert msg.sender == self.compass_evm and self.paloma == empty(bytes32) and len(msg.data) == 36, \"Invalid\"\r\n    _paloma: bytes32 = convert(slice(msg.data, 4, 32), bytes32)\r\n    self.paloma = _paloma\r\n    log SetPaloma(_paloma)\r\n\r\n@external\r\ndef update_service_fee_collector(new_service_fee_collector: address):\r\n    assert msg.sender == self.service_fee_collector, \"Unauthorized\"\r\n    self.service_fee_collector = new_service_fee_collector\r\n    log UpdateServiceFeeCollector(msg.sender, new_service_fee_collector)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    assert msg.sender == ROUTER", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":false},{\"name\":\"input_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"number_trades\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"interval\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"starting_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Swapped\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"remaining_counts\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Canceled\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCompass\",\"inputs\":[{\"name\":\"old_compass\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_compass\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateRefundWallet\",\"inputs\":[{\"name\":\"old_refund_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_refund_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPaloma\",\"inputs\":[{\"name\":\"paloma\",\"type\":\"bytes32\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateServiceFeeCollector\",\"inputs\":[{\"name\":\"old_service_fee_collector\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_service_fee_collector\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass_evm\",\"type\":\"address\"},{\"name\":\"router\",\"type\":\"address\"},{\"name\":\"_refund_wallet\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_service_fee_collector\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"route\",\"type\":\"address[9]\"},{\"name\":\"swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pools\",\"type\":\"address[4]\"},{\"name\":\"number_trades\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"starting_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_swap\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256[]\"},{\"name\":\"remaining_counts\",\"type\":\"uint256[]\"},{\"name\":\"amount_out_min\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_swap_view\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256[]\"},{\"name\":\"remaining_counts\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_compass\",\"inputs\":[{\"name\":\"new_compass\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_refund_wallet\",\"inputs\":[{\"name\":\"new_refund_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_fee\",\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_paloma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_service_fee_collector\",\"inputs\":[{\"name\":\"new_service_fee_collector\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass_evm\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"next_deposit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refund_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paloma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"service_fee_collector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Curve DCA Bot", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000007eec3e2f4d567794b927b6d904fbf973bc8d15e600000000000000000000000099a58482bd75cbab83b27ec03ca68ff489b5788f0000000000000000000000006dc0a87638cd75cc700ccdb226c7ab6c054bc70b00000000000000000000000000000000000000000000000000354a6ba7a180000000000000000000000000007a16ff8270133f063aab6c9977183d9e72835428", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}