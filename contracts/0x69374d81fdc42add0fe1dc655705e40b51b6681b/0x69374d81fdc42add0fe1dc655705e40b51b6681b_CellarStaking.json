{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/modules/staking/CellarStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport { ERC20 } from \\\"@solmate/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"@solmate/utils/SafeTransferLib.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ICellarStaking } from \\\"src/interfaces/ICellarStaking.sol\\\";\\n\\nimport \\\"./Errors.sol\\\";\\n\\n/**\\n * @title Sommelier Staking\\n * @author Kevin Kennis\\n *\\n * Staking for Sommelier Cellars.\\n *\\n * This contract is inspired by the Synthetix staking rewards contract, Ampleforth's\\n * token geyser, and Treasure DAO's MAGIC mine. However, there are unique improvements\\n * and new features, specifically unbonding, as inspired by LP bonding on Osmosis.\\n * Unbonding allows the contract to guarantee deposits for a certain amount of time,\\n * increasing predictability and stickiness of TVL for Cellars.\\n *\\n * *********************************** Funding Flow ***********************************\\n *\\n * 1) The contract owner calls 'notifyRewardAmount' to specify an initial schedule of rewards\\n *    The contract should hold enough the distribution token to fund the\\n *    specified reward schedule, where the length of the reward schedule is defined by\\n *    epochDuration. This duration can also be changed by the owner, and any change will apply\\n *    to future calls to 'notifyRewardAmount' (but will not affect active schedules).\\n * 2) At a future time, the contract owner may call 'notifyRewardAmount' again to extend the\\n *    staking program with new rewards. These new schedules may distribute more or less\\n *    rewards than previous epochs. If a previous epoch is not finished, any leftover rewards\\n *    get rolled into the new schedule, increasing the reward rate. Reward schedules always\\n *    end exactly 'epochDuration' seconds from the most recent time 'notifyRewardAmount' has been\\n *    called.\\n *\\n * ********************************* Staking Lifecycle ********************************\\n *\\n * 1) A user may deposit a certain amount of tokens to stake, and is required to lock\\n *    those tokens for a specified amount of time. There are three locking options:\\n *    one day, one week, or one month. Longer locking times receive larger 'boosts',\\n *    that the deposit will receive a larger proportional amount of shares. A user\\n *    may not unstake until they choose to unbond, and time defined by the lock has\\n *    elapsed during unbonding.\\n * 2) When a user wishes to withdraw, they must first \\\"unbond\\\" their stake, which starts\\n *    a timer equivalent to the lock time. They still receive their rewards during this\\n *    time, but forfeit any locktime boosts. A user may cancel the unbonding period at any\\n *    time to regain their boosts, which will set the unbonding timer back to 0.\\n * 2) Once the lock has elapsed, a user may unstake their deposit, either partially\\n *    or in full. The user will continue to receive the same 'boosted' amount of rewards\\n *    until they unstake. The user may unstake all of their deposits at once, as long\\n *    as all of the lock times have elapsed. When unstaking, the user will also receive\\n *    all eligible rewards for all deposited stakes, which accumulate linearly.\\n * 3) At any time, a user may claim their available rewards for their deposits. Rewards\\n *    accumulate linearly and can be claimed at any time, whether or not the lock has\\n *    for a given deposit has expired. The user can claim rewards for a specific deposit,\\n *    or may choose to collect all eligible rewards at once.\\n *\\n * ************************************ Accounting ************************************\\n *\\n * The contract uses an accounting mechanism based on the 'rewardPerToken' model,\\n * originated by the Synthetix staking rewards contract. First, token deposits are accounted\\n * for, with synthetic \\\"boosted\\\" amounts used for reward calculations. As time passes,\\n * rewardPerToken continues to accumulate, whereas the value of 'rewardPerToken' will match\\n * the reward due to a single token deposited before the first ever rewards were scheduled.\\n *\\n * At each accounting checkpoint, rewardPerToken will be recalculated, and every time an\\n * existing stake is 'touched', this value is used to calculate earned rewards for that\\n * stake. Each stake tracks a 'rewardPerTokenPaid' value, which represents the 'rewardPerToken'\\n * value the last time the stake calculated \\\"earned\\\" rewards. Every recalculation pays the difference.\\n * This ensures no earning is double-counted. When a new stake is deposited, its\\n * initial 'rewardPerTokenPaid' is set to the current 'rewardPerToken' in the contract,\\n * ensuring it will not receive any rewards emitted during the period before deposit.\\n *\\n * The following example applies to a given epoch of 100 seconds, with a reward rate\\n * of 100 tokens per second:\\n *\\n * a) User 1 deposits a stake of 50 before the epoch begins\\n * b) User 2 deposits a stake of 20 at second 20 of the epoch\\n * c) User 3 deposits a stake of 100 at second 50 of the epoch\\n *\\n * In this case,\\n *\\n * a) At second 20, before User 2's deposit, rewardPerToken will be 40\\n *     (2000 total tokens emitted over 20 seconds / 50 staked).\\n * b) At second 50, before User 3's deposit, rewardPerToken will be 82.857\\n *     (previous 40 + 3000 tokens emitted over 30 seconds / 70 staked == 42.857)\\n * c) At second 100, when the period is over, rewardPerToken will be 112.267\\n *     (previous 82.857 + 5000 tokens emitted over 50 seconds / 170 staked == 29.41)\\n *\\n *\\n * Then, each user will receive rewards proportional to the their number of tokens. At second 100:\\n * a) User 1 will receive 50 * 112.267 = 5613.35 rewards\\n * b) User 2 will receive 20 * (112.267 - 40) = 1445.34\\n *       (40 is deducted because it was the current rewardPerToken value on deposit)\\n * c) User 3 will receive 100 * (112.267 - 82.857) = 2941\\n *       (82.857 is deducted because it was the current rewardPerToken value on deposit)\\n *\\n * Depending on deposit times, this accumulation may take place over multiple\\n * reward periods, and the total rewards earned is simply the sum of rewards earned for\\n * each period. A user may also have multiple discrete deposits, which are all\\n * accounted for separately due to timelocks and locking boosts. Therefore,\\n * a user's total earned rewards are a function of their rewards across\\n * the proportional tokens deposited, across different ranges of rewardPerToken.\\n *\\n * Reward accounting takes place before every operation which may change\\n * accounting calculations (minting of new shares on staking, burning of\\n * shares on unstaking, or claiming, which decrements eligible rewards).\\n * This is gas-intensive but unavoidable, since retroactive accounting\\n * based on previous proportionate shares would require a prohibitive\\n * amount of storage of historical state. On every accounting run, there\\n * are a number of safety checks to ensure that all reward tokens are\\n * accounted for and that no accounting time periods have been missed.\\n *\\n */\\ncontract CellarStaking is ICellarStaking, Ownable {\\n    using SafeTransferLib for ERC20;\\n\\n    // ============================================ STATE ==============================================\\n\\n    // ============== Constants ==============\\n\\n    uint256 public constant ONE = 1e18;\\n    uint256 public constant ONE_DAY = 60 * 60 * 24;\\n    uint256 public constant ONE_WEEK = ONE_DAY * 7;\\n    uint256 public constant TWO_WEEKS = ONE_WEEK * 2;\\n\\n    uint256 public immutable SHORT_BOOST;\\n    uint256 public immutable MEDIUM_BOOST;\\n    uint256 public immutable LONG_BOOST;\\n\\n    uint256 public immutable SHORT_BOOST_TIME;\\n    uint256 public immutable MEDIUM_BOOST_TIME;\\n    uint256 public immutable LONG_BOOST_TIME;\\n\\n    // ============ Global State =============\\n\\n    ERC20 public immutable override stakingToken;\\n    ERC20 public immutable override distributionToken;\\n    uint256 public override currentEpochDuration;\\n    uint256 public override nextEpochDuration;\\n    uint256 public override rewardsReady;\\n\\n    uint256 public override minimumDeposit;\\n    uint256 public override endTimestamp;\\n    uint256 public override totalDeposits;\\n    uint256 public override totalDepositsWithBoost;\\n    uint256 public override rewardRate;\\n    uint256 public override rewardPerTokenStored;\\n\\n    uint256 private lastAccountingTimestamp = block.timestamp;\\n\\n    /// @notice Emergency states in case of contract malfunction.\\n    bool public override paused;\\n    bool public override ended;\\n    bool public override claimable;\\n\\n    // ============= User State ==============\\n\\n    /// @notice user => all user's staking positions\\n    mapping(address => UserStake[]) public stakes;\\n\\n    // ========================================== CONSTRUCTOR ===========================================\\n\\n    /**\\n     * @param _owner                The owner of the staking contract - will immediately receive ownership.\\n     * @param _stakingToken         The token users will deposit in order to stake.\\n     * @param _distributionToken    The token the staking contract will distribute as rewards.\\n     * @param _epochDuration        The length of a reward schedule.\\n     * @param shortBoost            The boost multiplier for the short unbonding time.\\n     * @param mediumBoost           The boost multiplier for the medium unbonding time.\\n     * @param longBoost             The boost multiplier for the long unbonding time.\\n     * @param shortBoostTime        The short unbonding time.\\n     * @param mediumBoostTime       The medium unbonding time.\\n     * @param longBoostTime         The long unbonding time.\\n     */\\n    constructor(\\n        address _owner,\\n        ERC20 _stakingToken,\\n        ERC20 _distributionToken,\\n        uint256 _epochDuration,\\n        uint256 shortBoost,\\n        uint256 mediumBoost,\\n        uint256 longBoost,\\n        uint256 shortBoostTime,\\n        uint256 mediumBoostTime,\\n        uint256 longBoostTime\\n    ) {\\n        stakingToken = _stakingToken;\\n        distributionToken = _distributionToken;\\n        nextEpochDuration = _epochDuration;\\n\\n        SHORT_BOOST = shortBoost;\\n        MEDIUM_BOOST = mediumBoost;\\n        LONG_BOOST = longBoost;\\n\\n        SHORT_BOOST_TIME = shortBoostTime;\\n        MEDIUM_BOOST_TIME = mediumBoostTime;\\n        LONG_BOOST_TIME = longBoostTime;\\n\\n        transferOwnership(_owner);\\n    }\\n\\n    // ======================================= STAKING OPERATIONS =======================================\\n\\n    /**\\n     * @notice  Make a new deposit into the staking contract. Longer locks receive reward boosts.\\n     * @dev     Specified amount of stakingToken must be approved for withdrawal by the caller.\\n     * @dev     Valid lock values are 0 (one day), 1 (one week), and 2 (two weeks).\\n     *\\n     * @param amount                The amount of the stakingToken to stake.\\n     * @param lock                  The amount of time to lock stake for.\\n     */\\n    function stake(uint256 amount, Lock lock) external override whenNotPaused updateRewards {\\n        if (amount == 0) revert USR_ZeroDeposit();\\n        if (amount < minimumDeposit) revert USR_MinimumDeposit(amount, minimumDeposit);\\n\\n        if (totalDeposits == 0 && rewardsReady > 0) {\\n            _startProgram(rewardsReady);\\n            rewardsReady = 0;\\n\\n            // Need to run updateRewards again\\n            _updateRewards();\\n        } else if (block.timestamp > endTimestamp) {\\n            revert STATE_NoRewardsLeft();\\n        }\\n\\n        // Do share accounting and populate user stake information\\n        (uint256 boost, ) = _getBoost(lock);\\n        uint256 amountWithBoost = amount + ((amount * boost) / ONE);\\n\\n        stakes[msg.sender].push(\\n            UserStake({\\n                amount: uint112(amount),\\n                amountWithBoost: uint112(amountWithBoost),\\n                unbondTimestamp: 0,\\n                rewardPerTokenPaid: uint112(rewardPerTokenStored),\\n                rewards: 0,\\n                lock: lock\\n            })\\n        );\\n\\n        // Update global state\\n        totalDeposits += amount;\\n        totalDepositsWithBoost += amountWithBoost;\\n\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit Stake(msg.sender, stakes[msg.sender].length - 1, amount);\\n    }\\n\\n    /**\\n     * @notice  Unbond a specified amount from a certain deposited stake.\\n     * @dev     After the unbond time elapses, the deposit can be unstaked.\\n     *\\n     * @param depositId             The specified deposit to unstake from.\\n     *\\n     */\\n    function unbond(uint256 depositId) external override whenNotPaused updateRewards {\\n        _unbond(depositId);\\n    }\\n\\n    /**\\n     * @notice  Unbond all user deposits.\\n     * @dev     Different deposits may have different timelocks.\\n     *\\n     */\\n    function unbondAll() external override whenNotPaused updateRewards {\\n        // Individually unbond each deposit\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            UserStake storage s = userStakes[i];\\n\\n            if (s.amount != 0 && s.unbondTimestamp == 0) {\\n                _unbond(i);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev     Contains all logic for processing an unbond operation.\\n     *          For the given deposit, sets an unlock time, and\\n     *          reverts boosts to 0.\\n     *\\n     * @param depositId             The specified deposit to unbond from.\\n     */\\n    function _unbond(uint256 depositId) internal {\\n        // Fetch stake and make sure it is withdrawable\\n        UserStake storage s = stakes[msg.sender][depositId];\\n\\n        uint256 depositAmount = s.amount;\\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\\n        if (s.unbondTimestamp > 0) revert USR_AlreadyUnbonding(depositId);\\n\\n        _updateRewardForStake(msg.sender, depositId);\\n\\n        // Remove any lock boosts\\n        uint256 depositAmountReduced = s.amountWithBoost - depositAmount;\\n        (, uint256 lockDuration) = _getBoost(s.lock);\\n\\n        s.amountWithBoost = uint112(depositAmount);\\n        s.unbondTimestamp = uint32(block.timestamp + lockDuration);\\n\\n        totalDepositsWithBoost -= uint112(depositAmountReduced);\\n\\n        emit Unbond(msg.sender, depositId, depositAmount);\\n    }\\n\\n    /**\\n     * @notice  Cancel an unbonding period for a stake that is currently unbonding.\\n     * @dev     Resets the unbonding timer and reinstates any lock boosts.\\n     *\\n     * @param depositId             The specified deposit to unstake from.\\n     *\\n     */\\n    function cancelUnbonding(uint256 depositId) external override whenNotPaused updateRewards {\\n        _cancelUnbonding(depositId);\\n    }\\n\\n    /**\\n     * @notice  Cancel an unbonding period for all stakes.\\n     * @dev     Only cancels stakes that are unbonding.\\n     *\\n     */\\n    function cancelUnbondingAll() external override whenNotPaused updateRewards {\\n        // Individually unbond each deposit\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            UserStake storage s = userStakes[i];\\n\\n            if (s.amount != 0 && s.unbondTimestamp != 0) {\\n                _cancelUnbonding(i);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev     Contains all logic for cancelling an unbond operation.\\n     *          For the given deposit, resets the unbonding timer, and\\n     *          reverts boosts to amount determined by lock.\\n     *\\n     * @param depositId             The specified deposit to unbond from.\\n     */\\n    function _cancelUnbonding(uint256 depositId) internal {\\n        // Fetch stake and make sure it is withdrawable\\n        UserStake storage s = stakes[msg.sender][depositId];\\n\\n        uint256 depositAmount = s.amount;\\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\\n        if (s.unbondTimestamp == 0) revert USR_NotUnbonding(depositId);\\n\\n        _updateRewardForStake(msg.sender, depositId);\\n\\n        // Reinstate\\n        (uint256 boost, ) = _getBoost(s.lock);\\n        uint256 depositAmountIncreased = (s.amount * boost) / ONE;\\n        uint256 amountWithBoost = s.amount + depositAmountIncreased;\\n\\n        s.amountWithBoost = uint112(amountWithBoost);\\n        s.unbondTimestamp = 0;\\n\\n        totalDepositsWithBoost += depositAmountIncreased;\\n\\n        emit CancelUnbond(msg.sender, depositId);\\n    }\\n\\n    /**\\n     * @notice  Unstake a specific deposited stake.\\n     * @dev     The unbonding time for the specified deposit must have elapsed.\\n     * @dev     Unstaking automatically claims available rewards for the deposit.\\n     *\\n     * @param depositId             The specified deposit to unstake from.\\n     *\\n     * @return reward               The amount of accumulated rewards since the last reward claim.\\n     */\\n    function unstake(uint256 depositId) external override whenNotPaused updateRewards returns (uint256 reward) {\\n        return _unstake(depositId);\\n    }\\n\\n    /**\\n     * @notice  Unstake all user deposits.\\n     * @dev     Only unstakes rewards that are unbonded.\\n     * @dev     Unstaking automatically claims all available rewards.\\n     *\\n     * @return rewards              The amount of accumulated rewards since the last reward claim.\\n     */\\n    function unstakeAll() external override whenNotPaused updateRewards returns (uint256[] memory) {\\n        // Individually unstake each deposit\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        uint256[] memory rewards = new uint256[](userStakes.length);\\n\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            UserStake storage s = userStakes[i];\\n\\n            if (s.amount != 0 && s.unbondTimestamp != 0 && block.timestamp >= s.unbondTimestamp) {\\n                rewards[i] = _unstake(i);\\n            }\\n        }\\n\\n        return rewards;\\n    }\\n\\n    /**\\n     * @dev     Contains all logic for processing an unstake operation.\\n     *          For the given deposit, does share accounting and burns\\n     *          shares, returns staking tokens to the original owner,\\n     *          updates global deposit and share trackers, and claims\\n     *          rewards for the given deposit.\\n     *\\n     * @param depositId             The specified deposit to unstake from.\\n     */\\n    function _unstake(uint256 depositId) internal returns (uint256 reward) {\\n        // Fetch stake and make sure it is withdrawable\\n        UserStake storage s = stakes[msg.sender][depositId];\\n\\n        uint256 depositAmount = s.amount;\\n\\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\\n        if (s.unbondTimestamp == 0 || block.timestamp < s.unbondTimestamp) revert USR_StakeLocked(depositId);\\n\\n        _updateRewardForStake(msg.sender, depositId);\\n\\n        // Start unstaking\\n        reward = s.rewards;\\n\\n        s.amount = 0;\\n        s.amountWithBoost = 0;\\n        s.rewards = 0;\\n\\n        // Update global state\\n        // Boosted amount same as deposit amount, since we have unbonded\\n        totalDeposits -= depositAmount;\\n        totalDepositsWithBoost -= depositAmount;\\n\\n        // Distribute stake\\n        stakingToken.safeTransfer(msg.sender, depositAmount);\\n\\n        // Distribute reward\\n        distributionToken.safeTransfer(msg.sender, reward);\\n\\n        emit Unstake(msg.sender, depositId, depositAmount, reward);\\n    }\\n\\n    /**\\n     * @notice  Claim rewards for a given deposit.\\n     * @dev     Rewards accumulate linearly since deposit.\\n     *\\n     * @param depositId             The specified deposit for which to claim rewards.\\n     *\\n     * @return reward               The amount of accumulated rewards since the last reward claim.\\n     */\\n    function claim(uint256 depositId) external override whenNotPaused updateRewards returns (uint256 reward) {\\n        return _claim(depositId);\\n    }\\n\\n    /**\\n     * @notice  Claim all available rewards.\\n     * @dev     Rewards accumulate linearly.\\n     *\\n     *\\n     * @return rewards               The amount of accumulated rewards since the last reward claim.\\n     *                               Each element of the array specified rewards for the corresponding\\n     *                               indexed deposit.\\n     */\\n    function claimAll() external override whenNotPaused updateRewards returns (uint256[] memory rewards) {\\n        // Individually claim for each stake\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        rewards = new uint256[](userStakes.length);\\n\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            rewards[i] = _claim(i);\\n        }\\n    }\\n\\n    /**\\n     * @dev Contains all logic for processing a claim operation.\\n     *      Relies on previous reward accounting done before\\n     *      processing external functions. Updates the amount\\n     *      of rewards claimed so rewards cannot be claimed twice.\\n     *\\n     *\\n     * @param depositId             The specified deposit to claim rewards for.\\n     *\\n     * @return reward               The amount of accumulated rewards since the last reward claim.\\n     */\\n    function _claim(uint256 depositId) internal returns (uint256 reward) {\\n        // Fetch stake and make sure it is valid\\n        UserStake storage s = stakes[msg.sender][depositId];\\n\\n        _updateRewardForStake(msg.sender, depositId);\\n\\n        reward = s.rewards;\\n\\n        // Distribute reward\\n        if (reward > 0) {\\n            s.rewards = 0;\\n\\n            distributionToken.safeTransfer(msg.sender, reward);\\n\\n            emit Claim(msg.sender, depositId, reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice  Unstake and return all staked tokens to the caller.\\n     * @dev     In emergency mode, staking time locks do not apply.\\n     */\\n    function emergencyUnstake() external override {\\n        if (!ended) revert STATE_NoEmergencyUnstake();\\n\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            if (claimable) _updateRewardForStake(msg.sender, i);\\n\\n            UserStake storage s = userStakes[i];\\n            uint256 amount = s.amount;\\n\\n            if (amount > 0) {\\n                // Update global state\\n                totalDeposits -= amount;\\n                totalDepositsWithBoost -= s.amountWithBoost;\\n\\n                s.amount = 0;\\n                s.amountWithBoost = 0;\\n\\n                stakingToken.transfer(msg.sender, amount);\\n\\n                emit EmergencyUnstake(msg.sender, i, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice  Claim any accumulated rewards in emergency mode.\\n     * @dev     In emergency node, no additional reward accounting is done.\\n     *          Rewards do not accumulate after emergency mode begins,\\n     *          so any earned amount is only retroactive to when the contract\\n     *          was active.\\n     */\\n    function emergencyClaim() external override {\\n        if (!ended) revert STATE_NoEmergencyUnstake();\\n        if (!claimable) revert STATE_NoEmergencyClaim();\\n\\n        uint256 reward;\\n\\n        UserStake[] storage userStakes = stakes[msg.sender];\\n        for (uint256 i = 0; i < userStakes.length; i++) {\\n            _updateRewardForStake(msg.sender, i);\\n\\n            UserStake storage s = userStakes[i];\\n\\n            reward += s.rewards;\\n            s.rewards = 0;\\n        }\\n\\n        if (reward > 0) {\\n            distributionToken.safeTransfer(msg.sender, reward);\\n\\n            // No need for per-stake events like emergencyUnstake:\\n            // don't need to make sure positions were unwound\\n            emit EmergencyClaim(msg.sender, reward);\\n        }\\n    }\\n\\n    // ======================================== ADMIN OPERATIONS ========================================\\n\\n    /**\\n     * @notice Specify a new schedule for staking rewards. Contract must already hold enough tokens.\\n     * @dev    Can only be called by reward distributor. Owner must approve distributionToken for withdrawal.\\n     * @dev    epochDuration must divide reward evenly, otherwise any remainder will be lost.\\n     *\\n     * @param reward                The amount of rewards to distribute per second.\\n     */\\n    function notifyRewardAmount(uint256 reward) external override onlyOwner updateRewards {\\n        if (block.timestamp < endTimestamp) {\\n            uint256 remaining = endTimestamp - block.timestamp;\\n            uint256 leftover = remaining * rewardRate;\\n            reward += leftover;\\n        }\\n\\n        if (reward < nextEpochDuration) revert USR_ZeroRewardsPerEpoch();\\n\\n        uint256 rewardBalance = distributionToken.balanceOf(address(this));\\n        uint256 pendingRewards = reward + rewardsReady;\\n        if (rewardBalance < pendingRewards) revert STATE_RewardsNotFunded(rewardBalance, pendingRewards);\\n\\n        // prevent overflow when computing rewardPerToken\\n        uint256 proposedRewardRate = reward / nextEpochDuration;\\n        if (proposedRewardRate >= ((type(uint256).max / ONE) / nextEpochDuration)) {\\n            revert USR_RewardTooLarge();\\n        }\\n\\n        if (totalDeposits == 0) {\\n            // No deposits yet, so keep rewards pending until first deposit\\n            // Incrementing in case it is called twice\\n            rewardsReady += reward;\\n        } else {\\n            // Ready to start\\n            _startProgram(reward);\\n        }\\n\\n        lastAccountingTimestamp = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Change the length of a reward epoch for future reward schedules.\\n     *\\n     * @param _epochDuration        The new duration for reward schedules.\\n     */\\n    function setRewardsDuration(uint256 _epochDuration) external override onlyOwner {\\n        if (rewardsReady > 0) revert STATE_RewardsReady();\\n\\n        nextEpochDuration = _epochDuration;\\n        emit EpochDurationChange(nextEpochDuration);\\n    }\\n\\n    /**\\n     * @notice Specify a minimum deposit for staking.\\n     * @dev    Can only be called by owner.\\n     *\\n     * @param _minimum              The minimum deposit for each new stake.\\n     */\\n    function setMinimumDeposit(uint256 _minimum) external override onlyOwner {\\n        minimumDeposit = _minimum;\\n    }\\n\\n    /**\\n     * @notice Pause the contract. Pausing prevents staking, unstaking, claiming\\n     *         rewards, and scheduling new rewards. Should only be used\\n     *         in an emergency.\\n     *\\n     * @param _paused               Whether the contract should be paused.\\n     */\\n    function setPaused(bool _paused) external override onlyOwner {\\n        paused = _paused;\\n    }\\n\\n    /**\\n     * @notice Stops the contract - this is irreversible. Should only be used\\n     *         in an emergency, for example an irreversible accounting bug\\n     *         or an exploit. Enables all depositors to withdraw their stake\\n     *         instantly. Also stops new rewards accounting.\\n     *\\n     * @param makeRewardsClaimable  Whether any previously accumulated rewards should be claimable.\\n     */\\n    function emergencyStop(bool makeRewardsClaimable) external override onlyOwner {\\n        if (ended) revert STATE_AlreadyShutdown();\\n\\n        // Update state and put in irreversible emergency mode\\n        ended = true;\\n        claimable = makeRewardsClaimable;\\n        uint256 amountToReturn = distributionToken.balanceOf(address(this));\\n\\n        if (makeRewardsClaimable) {\\n            // Update rewards one more time\\n            _updateRewards();\\n\\n            // Return any remaining, since new calculation is stopped\\n            uint256 remaining = endTimestamp > block.timestamp ? (endTimestamp - block.timestamp) * rewardRate : 0;\\n\\n            // Make sure any rewards except for remaining are kept for claims\\n            uint256 amountToKeep = rewardRate * currentEpochDuration - remaining;\\n\\n            amountToReturn -= amountToKeep;\\n        }\\n\\n        // Send distribution token back to owner\\n        distributionToken.transfer(msg.sender, amountToReturn);\\n\\n        emit EmergencyStop(msg.sender, makeRewardsClaimable);\\n    }\\n\\n    // ======================================= STATE INFORMATION =======================================\\n\\n    /**\\n     * @notice Returns the latest time to account for in the reward program.\\n     *\\n     * @return timestamp           The latest time to calculate.\\n     */\\n    function latestRewardsTimestamp() public view override returns (uint256) {\\n        return block.timestamp < endTimestamp ? block.timestamp : endTimestamp;\\n    }\\n\\n    /**\\n     * @notice Returns the amount of reward to distribute per currently-depostied token.\\n     *         Will update on changes to total deposit balance or reward rate.\\n     * @dev    Sets rewardPerTokenStored.\\n     *\\n     *\\n     * @return newRewardPerTokenStored  The new rewards to distribute per token.\\n     * @return latestTimestamp          The latest time to calculate.\\n     */\\n    function rewardPerToken() public view override returns (uint256 newRewardPerTokenStored, uint256 latestTimestamp) {\\n        latestTimestamp = latestRewardsTimestamp();\\n\\n        if (totalDeposits == 0) return (rewardPerTokenStored, latestTimestamp);\\n\\n        uint256 timeElapsed = latestTimestamp - lastAccountingTimestamp;\\n        uint256 rewardsForTime = timeElapsed * rewardRate;\\n        uint256 newRewardsPerToken = (rewardsForTime * ONE) / totalDepositsWithBoost;\\n\\n        newRewardPerTokenStored = rewardPerTokenStored + newRewardsPerToken;\\n    }\\n\\n    /**\\n     * @notice Gets all of a user's stakes.\\n     * @dev This is provided because Solidity converts public arrays into index getters,\\n     *      but we need a way to allow external contracts and users to access the whole array.\\n\\n     * @param user                      The user whose stakes to get.\\n     *\\n     * @return stakes                   Array of all user's stakes\\n     */\\n    function getUserStakes(address user) public view override returns (UserStake[] memory) {\\n        return stakes[user];\\n    }\\n\\n    // ============================================ HELPERS ============================================\\n\\n    /**\\n     * @dev Modifier to apply reward updates before functions that change accounts.\\n     */\\n    modifier updateRewards() {\\n        _updateRewards();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Blocks calls if contract is paused or killed.\\n     */\\n    modifier whenNotPaused() {\\n        if (paused) revert STATE_ContractPaused();\\n        if (ended) revert STATE_ContractKilled();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Update reward accounting for the global state totals.\\n     */\\n    function _updateRewards() internal {\\n        (rewardPerTokenStored, lastAccountingTimestamp) = rewardPerToken();\\n    }\\n\\n    /**\\n     * @dev On initial deposit, start the rewards program.\\n     *\\n     * @param reward                    The pending rewards to start distributing.\\n     */\\n    function _startProgram(uint256 reward) internal {\\n        // Assumptions\\n        // Total deposits are now (mod current tx), no ongoing program\\n        // Rewards are already funded (since checked in notifyRewardAmount)\\n\\n        rewardRate = reward / nextEpochDuration;\\n        endTimestamp = block.timestamp + nextEpochDuration;\\n        currentEpochDuration = nextEpochDuration;\\n\\n        emit Funding(reward, endTimestamp);\\n    }\\n\\n    /**\\n     * @dev Update reward for a specific user stake.\\n     */\\n    function _updateRewardForStake(address user, uint256 depositId) internal {\\n        UserStake storage s = stakes[user][depositId];\\n        if (s.amount == 0) return;\\n\\n        uint256 earned = _earned(s);\\n        s.rewards += uint112(earned);\\n\\n        s.rewardPerTokenPaid = uint112(rewardPerTokenStored);\\n    }\\n\\n    /**\\n     * @dev Return how many rewards a stake has earned and has claimable.\\n     */\\n    function _earned(UserStake memory s) internal view returns (uint256) {\\n        uint256 rewardPerTokenAcc = rewardPerTokenStored - s.rewardPerTokenPaid;\\n        uint256 newRewards = (s.amountWithBoost * rewardPerTokenAcc) / ONE;\\n\\n        return newRewards;\\n    }\\n\\n    /**\\n     * @dev Maps Lock enum values to corresponding lengths of time and reward boosts.\\n     */\\n    function _getBoost(Lock _lock) internal view returns (uint256 boost, uint256 timelock) {\\n        if (_lock == Lock.short) {\\n            return (SHORT_BOOST, SHORT_BOOST_TIME);\\n        } else if (_lock == Lock.medium) {\\n            return (MEDIUM_BOOST, MEDIUM_BOOST_TIME);\\n        } else if (_lock == Lock.long) {\\n            return (LONG_BOOST, LONG_BOOST_TIME);\\n        } else {\\n            revert USR_InvalidLockValue(uint256(_lock));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By defaul t, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICellarStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport { ERC20 } from \\\"@solmate/tokens/ERC20.sol\\\";\\n\\n/**\\n * @title Sommelier Staking Interface\\n * @author Kevin Kennis\\n *\\n * @notice Full documentation in implementation contract.\\n */\\ninterface ICellarStaking {\\n    // ===================== Events =======================\\n\\n    event Funding(uint256 rewardAmount, uint256 rewardEnd);\\n    event Stake(address indexed user, uint256 depositId, uint256 amount);\\n    event Unbond(address indexed user, uint256 depositId, uint256 amount);\\n    event CancelUnbond(address indexed user, uint256 depositId);\\n    event Unstake(address indexed user, uint256 depositId, uint256 amount, uint256 reward);\\n    event Claim(address indexed user, uint256 depositId, uint256 amount);\\n    event EmergencyStop(address owner, bool claimable);\\n    event EmergencyUnstake(address indexed user, uint256 depositId, uint256 amount);\\n    event EmergencyClaim(address indexed user, uint256 amount);\\n    event EpochDurationChange(uint256 duration);\\n\\n    // ===================== Errors =======================\\n\\n    /**\\n     * @notice Attempted to shutdown the contract when it was already shutdown.\\n     */\\n    error CellarStaking__AlreadyShutdown();\\n\\n    /**\\n     * @notice The caller attempted to start a reward period, but the contract did not have enough tokens\\n     *         for the specified amount of rewards.\\n     *\\n     * @param rewardBalance         The amount of distributionToken held by the contract.\\n     * @param reward                The amount of rewards the caller attempted to distribute.\\n     */\\n    error CellarStaking__RewardsNotFunded(uint256 rewardBalance, uint256 reward);\\n\\n    /**\\n     * @notice The caller attempted to change the next epoch duration, but there are rewards ready.\\n     */\\n    error CellarStaking__RewardsReady();\\n\\n    /**\\n     * @notice The caller attempted to deposit stake, but there are no remaining rewards to pay out.\\n     */\\n    error CellarStaking__NoRewardsLeft();\\n\\n    /**\\n     * @notice The caller attempted to perform an an emergency unstake, but the contract\\n     *         is not in emergency mode.\\n     */\\n    error CellarStaking__NoEmergencyUnstake();\\n\\n    /**\\n     * @notice The caller attempted to perform an an emergency unstake, but the contract\\n     *         is not in emergency mode, or the emergency mode does not allow claiming rewards.\\n     */\\n    error CellarStaking__NoEmergencyClaim();\\n\\n    /**\\n     * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\\n     *         while the contract was paused.\\n     */\\n    error CellarStaking__ContractPaused();\\n\\n    /**\\n     * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\\n     *         while the contract was killed (placed in emergency mode).\\n     * @dev    Emergency mode is irreversible.\\n     */\\n    error CellarStaking__ContractKilled();\\n\\n    /**\\n     * @notice The caller attempted to stake with a lock value that did not\\n     *         correspond to a valid staking time.\\n     *\\n     * @param lock                  The provided lock value.\\n     */\\n    error CellarStaking__InvalidLockValue(uint256 lock);\\n\\n    /**\\n     * @notice The reward distributor attempted to update rewards but 0 rewards per epoch.\\n     *         This can also happen if there is less than 1 wei of rewards per second of the\\n     *         epoch - due to integer division this will also lead to 0 rewards.\\n     */\\n    error CellarStaking__ZeroRewardsPerEpoch();\\n\\n    /**\\n     * @notice The contract owner attempted to update rewards but the new reward rate would cause overflow.\\n     */\\n    error CellarStaking__RewardTooLarge();\\n\\n    /**\\n     * @notice User attempted to stake an amount smaller than the minimum deposit.\\n     *\\n     * @param amount                Amount user attmpted to stake.\\n     * @param minimumDeposit        The minimum deopsit amount accepted.\\n     */\\n    error CellarStaking__MinimumDeposit(uint256 amount, uint256 minimumDeposit);\\n\\n    /**\\n     * @notice The specified deposit ID does not exist for the caller.\\n     *\\n     * @param depositId             The deposit ID provided for lookup.\\n     */\\n    error CellarStaking__NoDeposit(uint256 depositId);\\n\\n    /**\\n     * @notice The user is attempting to cancel unbonding for a deposit which is not unbonding.\\n     *\\n     * @param depositId             The deposit ID the user attempted to cancel.\\n     */\\n    error CellarStaking__NotUnbonding(uint256 depositId);\\n\\n    /**\\n     * @notice The user is attempting to unbond a deposit which has already been unbonded.\\n     *\\n     * @param depositId             The deposit ID the user attempted to unbond.\\n     */\\n    error CellarStaking__AlreadyUnbonding(uint256 depositId);\\n\\n    /**\\n     * @notice The user is attempting to unstake a deposit which is still timelocked.\\n     *\\n     * @param depositId             The deposit ID the user attempted to unstake.\\n     */\\n    error CellarStaking__StakeLocked(uint256 depositId);\\n\\n    /**\\n     * @notice User attempted to stake zero amount.\\n     */\\n    error CellarStaking__ZeroDeposit();\\n\\n    // ===================== Structs ======================\\n\\n    enum Lock {\\n        short,\\n        medium,\\n        long\\n    }\\n\\n    struct UserStake {\\n        uint112 amount;\\n        uint112 amountWithBoost;\\n        uint32 unbondTimestamp;\\n        uint112 rewardPerTokenPaid;\\n        uint112 rewards;\\n        Lock lock;\\n    }\\n\\n    // ============== Public State Variables ==============\\n\\n    function stakingToken() external returns (ERC20);\\n\\n    function distributionToken() external returns (ERC20);\\n\\n    function currentEpochDuration() external returns (uint256);\\n\\n    function nextEpochDuration() external returns (uint256);\\n\\n    function rewardsReady() external returns (uint256);\\n\\n    function minimumDeposit() external returns (uint256);\\n\\n    function endTimestamp() external returns (uint256);\\n\\n    function totalDeposits() external returns (uint256);\\n\\n    function totalDepositsWithBoost() external returns (uint256);\\n\\n    function rewardRate() external returns (uint256);\\n\\n    function rewardPerTokenStored() external returns (uint256);\\n\\n    function paused() external returns (bool);\\n\\n    function ended() external returns (bool);\\n\\n    function claimable() external returns (bool);\\n\\n    // ================ User Functions ================\\n\\n    function stake(uint256 amount, Lock lock) external;\\n\\n    function unbond(uint256 depositId) external;\\n\\n    function unbondAll() external;\\n\\n    function cancelUnbonding(uint256 depositId) external;\\n\\n    function cancelUnbondingAll() external;\\n\\n    function unstake(uint256 depositId) external returns (uint256 reward);\\n\\n    function unstakeAll() external returns (uint256[] memory rewards);\\n\\n    function claim(uint256 depositId) external returns (uint256 reward);\\n\\n    function claimAll() external returns (uint256[] memory rewards);\\n\\n    function emergencyUnstake() external;\\n\\n    function emergencyClaim() external;\\n\\n    // ================ Admin Functions ================\\n\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    function setRewardsDuration(uint256 _epochDuration) external;\\n\\n    function setMinimumDeposit(uint256 _minimum) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function emergencyStop(bool makeRewardsClaimable) external;\\n\\n    // ================ View Functions ================\\n\\n    function latestRewardsTimestamp() external view returns (uint256);\\n\\n    function rewardPerToken() external view returns (uint256, uint256);\\n\\n    function getUserStakes(address user) external view returns (UserStake[] memory);\\n}\\n\"\r\n    },\r\n    \"src/modules/staking/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n// ========================================== USER ERRORS ===========================================\\n\\n/**\\n * @dev These errors represent invalid user input to functions. Where appropriate, the invalid value\\n *      is specified along with constraints. These errors can be resolved by callers updating their\\n *      arguments.\\n */\\n\\n/**\\n * @notice Attempted an action with zero assets.\\n */\\nerror USR_ZeroAssets();\\n\\n/**\\n * @notice Attempted an action with zero shares.\\n */\\nerror USR_ZeroShares();\\n\\n/**\\n * @notice Attempted deposit more than the max deposit.\\n * @param assets the assets user attempted to deposit\\n * @param maxDeposit the max assets that can be deposited\\n */\\nerror USR_DepositRestricted(uint256 assets, uint256 maxDeposit);\\n\\n/**\\n * @notice Attempted to transfer more active shares than the user has.\\n * @param activeShares amount of shares user has\\n * @param attemptedActiveShares amount of shares user tried to transfer\\n */\\nerror USR_NotEnoughActiveShares(uint256 activeShares, uint256 attemptedActiveShares);\\n\\n/**\\n * @notice Attempted swap into an asset that is not the current asset of the position.\\n * @param assetOut address of the asset attempted to swap to\\n * @param currentAsset address of the current asset of position\\n */\\nerror USR_InvalidSwap(address assetOut, address currentAsset);\\n\\n/**\\n * @notice Attempted to sweep an asset that is managed by the cellar.\\n * @param token address of the token that can't be sweeped\\n */\\nerror USR_ProtectedAsset(address token);\\n\\n/**\\n * @notice Attempted rebalance into the same position.\\n * @param position address of the position\\n */\\nerror USR_SamePosition(address position);\\n\\n/**\\n * @notice Attempted to update the position to one that is not supported by the platform.\\n * @param unsupportedPosition address of the unsupported position\\n */\\nerror USR_UnsupportedPosition(address unsupportedPosition);\\n\\n/**\\n * @notice Attempted an operation on an untrusted position.\\n * @param position address of the position\\n */\\nerror USR_UntrustedPosition(address position);\\n\\n/**\\n * @notice Attempted to update a position to an asset that uses an incompatible amount of decimals.\\n * @param newDecimals decimals of precision that the new position uses\\n * @param maxDecimals maximum decimals of precision for a position to be compatible with the cellar\\n */\\nerror USR_TooManyDecimals(uint8 newDecimals, uint8 maxDecimals);\\n\\n/**\\n * @notice User attempted to stake zero amout.\\n */\\nerror USR_ZeroDeposit();\\n\\n/**\\n * @notice User attempted to stake an amount smaller than the minimum deposit.\\n *\\n * @param amount                Amount user attmpted to stake.\\n * @param minimumDeposit        The minimum deopsit amount accepted.\\n */\\nerror USR_MinimumDeposit(uint256 amount, uint256 minimumDeposit);\\n\\n/**\\n * @notice The specified deposit ID does not exist for the caller.\\n *\\n * @param depositId             The deposit ID provided for lookup.\\n */\\nerror USR_NoDeposit(uint256 depositId);\\n\\n/**\\n * @notice The user is attempting to cancel unbonding for a deposit which is not unbonding.\\n *\\n * @param depositId             The deposit ID the user attempted to cancel.\\n */\\nerror USR_NotUnbonding(uint256 depositId);\\n\\n/**\\n * @notice The user is attempting to unbond a deposit which has already been unbonded.\\n *\\n * @param depositId             The deposit ID the user attempted to unbond.\\n */\\nerror USR_AlreadyUnbonding(uint256 depositId);\\n\\n/**\\n * @notice The user is attempting to unstake a deposit which is still timelocked.\\n *\\n * @param depositId             The deposit ID the user attempted to unstake.\\n */\\nerror USR_StakeLocked(uint256 depositId);\\n\\n/**\\n * @notice The contract owner attempted to update rewards but the new reward rate would cause overflow.\\n */\\nerror USR_RewardTooLarge();\\n\\n/**\\n * @notice The reward distributor attempted to update rewards but 0 rewards per epoch.\\n *         This can also happen if there is less than 1 wei of rewards per second of the\\n *         epoch - due to integer division this will also lead to 0 rewards.\\n */\\nerror USR_ZeroRewardsPerEpoch();\\n\\n/**\\n * @notice The caller attempted to stake with a lock value that did not\\n *         correspond to a valid staking time.\\n *\\n * @param lock                  The provided lock value.\\n */\\nerror USR_InvalidLockValue(uint256 lock);\\n\\n/**\\n * @notice The caller attempted an signed action with an invalid signature.\\n * @param signatureLength length of the signature passed in\\n * @param expectedSignatureLength expected length of the signature passed in\\n */\\nerror USR_InvalidSignature(uint256 signatureLength, uint256 expectedSignatureLength);\\n\\n/**\\n * @notice Attempted an action by a non-custodian\\n */\\nerror USR_NotCustodian();\\n\\n// ========================================== STATE ERRORS ===========================================\\n\\n/**\\n * @dev These errors represent actions that are being prevented due to current contract state.\\n *      These errors do not relate to user input, and may or may not be resolved by other actions\\n *      or the progression of time.\\n */\\n\\n/**\\n * @notice Attempted an action when cellar is using an asset that has a fee on transfer.\\n * @param assetWithFeeOnTransfer address of the asset with fee on transfer\\n */\\nerror STATE_AssetUsesFeeOnTransfer(address assetWithFeeOnTransfer);\\n\\n/**\\n * @notice Attempted action was prevented due to contract being shutdown.\\n */\\nerror STATE_ContractShutdown();\\n\\n/**\\n * @notice Attempted to shutdown the contract when it was already shutdown.\\n */\\nerror STATE_AlreadyShutdown();\\n\\n/**\\n * @notice The caller attempted to start a reward period, but the contract did not have enough tokens\\n *         for the specified amount of rewards.\\n *\\n * @param rewardBalance         The amount of distributionToken held by the contract.\\n * @param reward                The amount of rewards the caller attempted to distribute.\\n */\\nerror STATE_RewardsNotFunded(uint256 rewardBalance, uint256 reward);\\n\\n/**\\n * @notice Attempted an operation that is prohibited while yield is still being distributed from the last accrual.\\n */\\nerror STATE_AccrualOngoing();\\n\\n/**\\n * @notice The caller attempted to change the epoch length, but current reward epochs were active.\\n */\\nerror STATE_RewardsOngoing();\\n\\n/**\\n * @notice The caller attempted to change the next epoch duration, but there are rewards ready.\\n */\\nerror STATE_RewardsReady();\\n\\n/**\\n * @notice The caller attempted to deposit stake, but there are no remaining rewards to pay out.\\n */\\nerror STATE_NoRewardsLeft();\\n\\n/**\\n * @notice The caller attempted to perform an an emergency unstake, but the contract\\n *         is not in emergency mode.\\n */\\nerror STATE_NoEmergencyUnstake();\\n\\n/**\\n * @notice The caller attempted to perform an an emergency unstake, but the contract\\n *         is not in emergency mode, or the emergency mode does not allow claiming rewards.\\n */\\nerror STATE_NoEmergencyClaim();\\n\\n/**\\n * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\\n *         while the contract was paused.\\n */\\nerror STATE_ContractPaused();\\n\\n/**\\n * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\\n *         while the contract was killed (placed in emergency mode).\\n * @dev    Emergency mode is irreversible.\\n */\\nerror STATE_ContractKilled();\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@balancer/=lib/balancer-v2-monorepo/pkg/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@uniswapV3C/=lib/v3-core/contracts/\",\r\n      \"@uniswapV3P/=lib/v3-periphery/contracts/\",\r\n      \"axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/\",\r\n      \"balancer-v2-monorepo/=lib/balancer-v2-monorepo/\",\r\n      \"chainlink/=lib/chainlink/integration-tests/contracts/ethereum/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"lib/balancer-v2-monorepo:@balancer-labs/=lib/balancer-v2-monorepo/../../node_modules/@balancer-labs/\",\r\n      \"lib/balancer-v2-monorepo:ds-test/=lib/balancer-v2-monorepo/../../pvt/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/balancer-v2-monorepo:forge-std/=lib/balancer-v2-monorepo/../../pvt/lib/forge-std/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_distributionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBoost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mediumBoost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBoost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBoostTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mediumBoostTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBoostTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CellarStaking__AlreadyShutdown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__AlreadyUnbonding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__ContractKilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__ContractPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__InvalidLockValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__MinimumDeposit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__NoDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__NoEmergencyClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__NoEmergencyUnstake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__NoRewardsLeft\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__NotUnbonding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__RewardTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__RewardsNotFunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__RewardsReady\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"CellarStaking__StakeLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__ZeroDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CellarStaking__ZeroRewardsPerEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_AlreadyShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_ContractKilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_ContractPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_NoEmergencyClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_NoEmergencyUnstake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_NoRewardsLeft\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"STATE_RewardsNotFunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"STATE_RewardsReady\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"USR_AlreadyUnbonding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"USR_InvalidLockValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"}],\"name\":\"USR_MinimumDeposit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"USR_NoDeposit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"USR_NotUnbonding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"USR_RewardTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"USR_StakeLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"USR_ZeroDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"USR_ZeroRewardsPerEpoch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"CancelUnbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"claimable\",\"type\":\"bool\"}],\"name\":\"EmergencyStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"EpochDurationChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardEnd\",\"type\":\"uint256\"}],\"name\":\"Funding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LONG_BOOST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LONG_BOOST_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEDIUM_BOOST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MEDIUM_BOOST_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHORT_BOOST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHORT_BOOST_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWO_WEEKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"cancelUnbonding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUnbondingAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"makeRewardsClaimable\",\"type\":\"bool\"}],\"name\":\"emergencyStop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"amountWithBoost\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unbondTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"rewards\",\"type\":\"uint112\"},{\"internalType\":\"enum ICellarStaking.Lock\",\"name\":\"lock\",\"type\":\"uint8\"}],\"internalType\":\"struct ICellarStaking.UserStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRewardsTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEpochDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsReady\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimum\",\"type\":\"uint256\"}],\"name\":\"setMinimumDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochDuration\",\"type\":\"uint256\"}],\"name\":\"setRewardsDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum ICellarStaking.Lock\",\"name\":\"lock\",\"type\":\"uint8\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"amountWithBoost\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unbondTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"rewards\",\"type\":\"uint112\"},{\"internalType\":\"enum ICellarStaking.Lock\",\"name\":\"lock\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositsWithBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"unbond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unbondAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CellarStaking", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eef7b7205caf2bcd71437d9acde3874c3388c138000000000000000000000000d33dad974b938744dac81fe00ac67cb5aa13958e000000000000000000000000a670d7237398238de01267472c6f13e5b8010fd10000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000012750000000000000000000000000000000000000000000000000000000000001275000000000000000000000000000000000000000000000000000000000000127500", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}