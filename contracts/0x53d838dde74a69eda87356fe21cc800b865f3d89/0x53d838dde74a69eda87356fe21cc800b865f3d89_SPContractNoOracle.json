{"SourceCode": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ISmartSwap {\r\n    function isSystem(address caller) external returns(bool);   // check if caller is system wallet.\r\n    function decimals(address token) external returns(uint256);   // token address => token decimals\r\n    function processingFee() external returns(uint256); // Processing fee\r\n    function companyFee() external returns(uint256); // Company fee\r\n    //function reimburse(address user, uint256 amount) external; // reimburse user for SP payment\r\n    function swap(\r\n        address tokenA,\r\n        address tokenB, \r\n        address receiver,\r\n        uint256 amountA,\r\n        address licensee,\r\n        bool isInvestment,\r\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\r\n        uint128 limitPice,   // Do not match user if token A price less this limit\r\n        uint256 fee          // company + licensee fee amount\r\n    )\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function cancel(\r\n        address tokenA,\r\n        address tokenB, \r\n        address receiver,\r\n        uint256 amountA    //amount of tokenA to cancel\r\n    )\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function claimToken(\r\n        address tokenA, // foreignToken\r\n        address tokenB, // nativeToken\r\n        address sender,\r\n        address receiver,\r\n        uint128 amountA,    //amount of tokenA that has to be swapped\r\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\r\n        uint256 foreignBalance,  // total tokens amount sent by user to pair on other chain\r\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\r\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)\r\n    )   \r\n        external\r\n        returns (bool);\r\n}\r\n\r\ncontract SPContractNoOracle{\r\n\r\n    address public owner;\r\n    address public nativeTokenReceiver;\r\n    address public nativeToken;\r\n    mapping(address => address) public foreignToken;    // SmartSwap => foreign token\r\n    mapping(address => address) public foreignTokenReceiver;    // SmartSwap => receiver address where tokens will be transferred from SmartSwap\r\n\r\n    //ISmartSwap public smartSwap; // assign SmartSwap address here\r\n    uint256 private feeAmountLimit; // limit of amount that System withdraw for fee reimbursement\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event FeeTransfer(address indexed systemWallet, uint256 fee);\r\n    event Deposit(uint256 value);\r\n\r\n    // run only once from proxy\r\n    function initialize(\r\n        address _owner,     // contract owner\r\n        address _nativeToken, // native token that will be send to SmartSwap\r\n        address _nativeTokenReceiver, // address on Binance to deposit native token\r\n        uint256 _feeAmountLimit, // limit of amount that System may withdraw for fee reimbursement\r\n        address[] calldata _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\r\n        address[] calldata _foreignTokenReceiver, // address of foreign SP contract deposit foreign token\r\n        address[] calldata _smartSwap   // address of local SmartSwap contract\r\n    )\r\n        external\r\n    {\r\n        require(owner == address(0)); // run only once\r\n        require(\r\n            _nativeToken != address(0)\r\n            && _nativeTokenReceiver != address(0)\r\n        );\r\n        nativeToken = _nativeToken;\r\n        nativeTokenReceiver = _nativeTokenReceiver;\r\n        for (uint i; i < _smartSwap.length; i++) {\r\n            foreignTokenReceiver[_smartSwap[i]] = _foreignTokenReceiver[i];\r\n            foreignToken[_smartSwap[i]] = _foreignToken[i];\r\n        }\r\n        feeAmountLimit = _feeAmountLimit;\r\n        //smartSwap = ISmartSwap(_smartSwap[0]);\r\n        owner = _owner;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the system.\r\n    */\r\n    modifier onlySystem(address _smartSwap) {\r\n        require(ISmartSwap(_smartSwap).isSystem(msg.sender), \"Caller is not the system\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // set limit of amount that System withdraw for fee reimbursement\r\n    function setFeeAmountLimit(uint256 amount) external onlyOwner {\r\n        feeAmountLimit = amount;\r\n    }\r\n\r\n\r\n    // set limit of amount that System withdraw for fee reimbursement\r\n    function setForeignToken(address _localSmartSwap, address _foreignToken, address _foreignTokenReceiver) external onlyOwner {\r\n        foreignTokenReceiver[_localSmartSwap] = _foreignTokenReceiver;\r\n        foreignToken[_localSmartSwap] = _foreignToken;\r\n    }\r\n\r\n    // get limit of amount that System withdraw for fee reimbursement\r\n    function getFeeAmountLimit() external view returns(uint256) {\r\n        return feeAmountLimit;\r\n    }\r\n\r\n    function cancel(address smartSwap, uint256 amount) external onlySystem(smartSwap) {\r\n        ISmartSwap(smartSwap).cancel(nativeToken, foreignToken[smartSwap], foreignTokenReceiver[smartSwap], amount);\r\n    }\r\n\r\n    // Allow owner withdraw tokens from contract\r\n    function withdraw(address token, uint256 amount) external onlyOwner {\r\n        if (token < address(9))\r\n            safeTransferETH(msg.sender, amount);\r\n        else\r\n            safeTransfer(token, msg.sender, amount);\r\n    }\r\n\r\n    // Allow owner withdraw tokens from contract\r\n    function withdrawSystem(address smartSwap, uint256 amount) external onlySystem(smartSwap) {\r\n        require(foreignTokenReceiver[smartSwap] != address(0), \"Wrong smartSwap\");\r\n        address token = nativeToken;\r\n        if (token < address(9))\r\n            safeTransferETH(nativeTokenReceiver, amount);\r\n        else\r\n            safeTransfer(token, nativeTokenReceiver, amount);\r\n    }    \r\n\r\n\r\n\r\n    // add liquidity to counterparty \r\n    function addLiquidityAndClaimBehalf(\r\n        address smartSwap, // address of local SmartSwap\r\n        uint256 feeAmount,   // processing fee amount to reimburse system wallet.\r\n        uint128 amount,    //amount of native token that has to be swapped (amount of provided liquidity)\r\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\r\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\r\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\r\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\r\n        address[] memory receiverCounterparty,    // correspondent value from SwapRequest event\r\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\r\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)        \r\n    ) \r\n        external \r\n        onlySystem(smartSwap) \r\n    {\r\n        require(feeAmountLimit >= feeAmount, \"Fee limit exceeded\");\r\n        require(foreignTokenReceiver[smartSwap] != address(0), \"Wrong smartSwap\");\r\n\r\n        feeAmountLimit -= feeAmount;\r\n        require(claimAmount.length == foreignBalance.length &&\r\n            senderCounterparty.length == receiverCounterparty.length &&\r\n            foreignBalance.length == senderCounterparty.length,\r\n            \"Wrong length\"\r\n        );\r\n        // send swap request\r\n        swap(smartSwap, amount, feeAmount);\r\n        // claim tokens on users behalf\r\n        claimBehalf(smartSwap, currentRate, claimAmount, foreignBalance, senderCounterparty, receiverCounterparty, foreignSpent, nativeEncoded);\r\n    }\r\n\r\n    function claimBehalf(\r\n        address smartSwap, // address of local SmartSwap\r\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\r\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\r\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\r\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\r\n        address[] memory receiverCounterparty,    // correspondent value from SwapRequest event\r\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\r\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)  \r\n    ) \r\n        internal \r\n    {\r\n        //uint256 totalAmount;\r\n        address _foreignToken = foreignToken[smartSwap];\r\n        for (uint256 i = 0; i < claimAmount.length; i++) {\r\n            //totalAmount += claimAmount[i];\r\n            ISmartSwap(smartSwap).claimToken(\r\n                _foreignToken,\r\n                nativeToken,\r\n                senderCounterparty[i],\r\n                receiverCounterparty[i],\r\n                claimAmount[i],\r\n                currentRate, \r\n                foreignBalance[i],\r\n                foreignSpent,\r\n                nativeEncoded\r\n            );\r\n        }\r\n        //require(totalAmount * currentRate / (10**(18+t.foreignDecimals-t.nativeDecimals)) <= uint256(amount), \"Insuficiant amount\");\r\n    }\r\n\r\n    function swap(address smartSwap, uint128 amount, uint256 feeAmount) internal {\r\n        uint256 processingFee = ISmartSwap(smartSwap).processingFee();\r\n        if (nativeToken > address(9)) {\r\n            // can't get company fee amount\r\n            IERC20(nativeToken).approve(address(smartSwap), uint256(amount));\r\n            ISmartSwap(smartSwap).swap{value: processingFee}(\r\n                nativeToken, \r\n                foreignToken[smartSwap],\r\n                foreignTokenReceiver[smartSwap], \r\n                amount, \r\n                address(0),\r\n                false, \r\n                0,\r\n                0,\r\n                0\r\n            );            \r\n        } else {    // native coin (ETH, BNB)\r\n            uint256 fee = uint256(amount)*ISmartSwap(smartSwap).companyFee()/10000;  // company fee\r\n            processingFee = fee + processingFee;\r\n            ISmartSwap(smartSwap).swap{value: uint256(amount) + processingFee}(\r\n                nativeToken, \r\n                foreignToken[smartSwap],\r\n                foreignTokenReceiver[smartSwap], \r\n                amount, \r\n                address(0),\r\n                false, \r\n                0,\r\n                0,\r\n                fee\r\n            );\r\n        }\r\n        require(processingFee <= feeAmount, \"Insuficiant fee\");\r\n        feeAmount -= processingFee; // we already paid processing fee to SmartSwap contract\r\n        if (feeAmount != 0) {\r\n            payable(msg.sender).transfer(feeAmount);\r\n            emit FeeTransfer(msg.sender, feeAmount);\r\n        }        \r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'ETH_TRANSFER_FAILED');\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"systemWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128[]\",\"name\":\"claimAmount\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"foreignBalance\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"senderCounterparty\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"receiverCounterparty\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"foreignSpent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeEncoded\",\"type\":\"uint256\"}],\"name\":\"addLiquidityAndClaimBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foreignToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"foreignTokenReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmountLimit\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_foreignToken\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_foreignTokenReceiver\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_smartSwap\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setFeeAmountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_localSmartSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_foreignTokenReceiver\",\"type\":\"address\"}],\"name\":\"setForeignToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SPContractNoOracle", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dd60a932416784d81ab45cd5351973a348a422515773f427d696835a3f555681"}