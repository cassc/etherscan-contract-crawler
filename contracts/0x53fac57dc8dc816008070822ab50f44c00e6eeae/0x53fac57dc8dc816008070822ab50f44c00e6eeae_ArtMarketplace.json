{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ArtMarketplace.sol\": {\r\n      \"content\": \"\\n// File: contracts/libs/SafeTransferLib.sol\\n\\n\\npragma solidity >=0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n/// responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// Note: This implementation does NOT protect against gas griefing.\\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overridden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x60.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/utils/Context.sol\\n\\n\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/access/Ownable.sol\\n\\n\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n// File: contracts/ArtMarketplace.sol\\n\\n\\npragma solidity ^0.8.21;\\n\\n\\n\\ncontract ArtMarketplace is Ownable {\\n  uint256 private constant BPS = 10_000;\\n  uint256 private constant BID_INCREASE_THRESHOLD = 0.2 ether;\\n  uint256 private constant DEFAULT_SPLIT = 7_500;\\n  uint256 private constant EXTENSION_TIME = 10 minutes;\\n  uint256 private constant INIT_AUCTION_DURATION = 24 hours;\\n  uint256 private constant MIN_BID = 0.01 ether;\\n  uint256 private constant MIN_BID_INCREASE_PRE = 2_000;\\n  uint256 private constant MIN_BID_INCREASE_POST = 1_000;\\n  uint256 private constant SAFE_GAS_LIMIT = 30_000;\\n\\n  address public beneficiary;\\n  bool public paused;\\n\\n  struct Auction {\\n    uint24 offsetFromEnd;\\n    uint72 amount;\\n    address bidder;\\n  }\\n\\n  struct AuctionConfig {\\n    address artist;\\n    uint16 split;\\n    uint80 buyNowStartTime;\\n    uint80 auctionStartTime;\\n    uint88 buyNowPrice;\\n    uint88 reservePrice;\\n  }\\n\\n  mapping(uint256 => AuctionConfig) public auctionConfig;\\n  mapping(uint256 => Auction) public auctionIdToAuction;\\n  \\n  event BidMade(\\n    uint256 indexed auctionId,\\n    address indexed collectionAddress,\\n    uint256 indexed tokenId,\\n    address bidder,\\n    uint256 amount,\\n    uint256 timestamp\\n  );\\n\\n  event Settled(\\n    uint256 indexed auctionId,\\n    address indexed collectionAddress,\\n    uint256 indexed tokenId,\\n    uint256 timestamp\\n  );\\n\\n  function bid(\\n    uint256 auctionId\\n  ) external payable {\\n    require(!paused, 'Bidding is paused');\\n\\n    if (auctionConfig[auctionId].auctionStartTime == type(uint80).max) {\\n      auctionConfig[auctionId].auctionStartTime = uint80(block.timestamp);\\n    }\\n\\n    require(\\n      isAuctionActive(auctionId)\\n      && block.timestamp >= auctionConfig[auctionId].buyNowStartTime,\\n      'Auction Inactive'\\n    );\\n\\n    Auction memory highestBid = auctionIdToAuction[auctionId];\\n    uint256 bidIncrease = highestBid.amount >= BID_INCREASE_THRESHOLD\\n      ? MIN_BID_INCREASE_POST : MIN_BID_INCREASE_PRE;\\n\\n    require(\\n      msg.value >= (highestBid.amount * (BPS + bidIncrease) / BPS)\\n      && msg.value >= reservePrice(auctionId),\\n      'Bid not high enough'\\n    );\\n\\n    uint256 refundAmount;\\n    address refundBidder;\\n    uint256 offset = highestBid.offsetFromEnd;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n\\n    if (highestBid.amount > 0) {\\n      refundAmount = highestBid.amount;\\n      refundBidder = highestBid.bidder;\\n    }\\n\\n    if (endTime - block.timestamp < EXTENSION_TIME) {\\n      offset += block.timestamp + EXTENSION_TIME - endTime;\\n    }\\n\\n    auctionIdToAuction[auctionId] = Auction(uint24(offset), uint72(msg.value), msg.sender);\\n\\n    emit BidMade(\\n      auctionId,\\n      getCollectionFromId(auctionId),\\n      getArtTokenIdFromId(auctionId),\\n      msg.sender,\\n      msg.value,\\n      block.timestamp\\n    );\\n\\n    if (refundAmount > 0) {\\n      SafeTransferLib.forceSafeTransferETH(refundBidder, refundAmount, SAFE_GAS_LIMIT);\\n    }\\n  }\\n\\n  function bidOnFavs(\\n    uint256[] calldata favorites,\\n    uint256[] calldata expectedPrices\\n  ) external payable {\\n    require(!paused, 'Bidding is paused');\\n    require(favorites.length == expectedPrices.length);\\n\\n    uint256 totalFailed; uint256 expectedTotal;\\n    for(uint256 i; i < favorites.length; ++i) {\\n      uint256 auctionId = favorites[i];\\n      uint256 expectedPrice = expectedPrices[i];\\n      expectedTotal += expectedPrice;\\n      AuctionConfig memory config = auctionConfig[auctionId];\\n\\n      if (config.auctionStartTime == type(uint80).max) {\\n        auctionConfig[auctionId].auctionStartTime = uint80(block.timestamp);\\n      }\\n\\n      if(!isAuctionActive(auctionId) || block.timestamp < config.buyNowStartTime) {\\n        totalFailed += expectedPrice;\\n        continue;\\n      }\\n\\n      Auction memory highestBid = auctionIdToAuction[auctionId];\\n      uint256 bidIncrease = highestBid.amount >= BID_INCREASE_THRESHOLD\\n        ? MIN_BID_INCREASE_POST : MIN_BID_INCREASE_PRE;\\n\\n      if (\\n        expectedPrice >= (highestBid.amount * (BPS + bidIncrease) / BPS)\\n        && expectedPrice >= reservePrice(auctionId)\\n      ) {\\n        uint256 refundAmount;\\n        address refundBidder;\\n        uint256 offset = highestBid.offsetFromEnd;\\n        uint256 endTime = getAuctionEndTime(auctionId);\\n\\n        if (highestBid.amount > 0) {\\n          refundAmount = highestBid.amount;\\n          refundBidder = highestBid.bidder;\\n        }\\n\\n        if (endTime - block.timestamp < EXTENSION_TIME) {\\n          offset += block.timestamp + EXTENSION_TIME - endTime;\\n        }\\n\\n        auctionIdToAuction[auctionId] = Auction(uint24(offset), uint72(expectedPrice), msg.sender);\\n\\n        emit BidMade(\\n          auctionId,\\n          getCollectionFromId(auctionId),\\n          getArtTokenIdFromId(auctionId),\\n          msg.sender,\\n          expectedPrice,\\n          block.timestamp\\n        );\\n\\n        if (refundAmount > 0) {\\n          SafeTransferLib.forceSafeTransferETH(refundBidder, refundAmount, SAFE_GAS_LIMIT);\\n        }\\n      } else{\\n        totalFailed += expectedPrice;\\n      }\\n    }\\n\\n    require(msg.value == expectedTotal, 'Incorrect amount of ETH sent');\\n    if (totalFailed > 0) {\\n      SafeTransferLib.forceSafeTransferETH(msg.sender, totalFailed, SAFE_GAS_LIMIT);\\n    }\\n  }\\n\\n  function buyNow(\\n    uint256 auctionId\\n  ) external payable {\\n    AuctionConfig memory config = auctionConfig[auctionId];\\n    uint256 amountToPay = config.buyNowPrice;\\n    require(!paused, 'Buying is paused');\\n    require(block.timestamp >= config.buyNowStartTime, 'Can not buy now yet.');\\n    require(config.auctionStartTime > block.timestamp, 'Auction already started.');\\n    require(amountToPay != 0 && msg.value == amountToPay, 'Incorrect ETH sent.');\\n\\n    auctionConfig[auctionId].auctionStartTime = uint80(block.timestamp - INIT_AUCTION_DURATION);\\n    auctionIdToAuction[auctionId] = Auction(0, uint72(msg.value), msg.sender);\\n    _mint(msg.sender, auctionId);\\n\\n    emit Settled(\\n      auctionId,\\n      getCollectionFromId(auctionId),\\n      getArtTokenIdFromId(auctionId),\\n      block.timestamp\\n    );\\n\\n    uint256 split = config.split;\\n    if (split == 0) {\\n      split = DEFAULT_SPLIT;\\n    }\\n    uint256 amountForArtist = amountToPay * split / 10_000;\\n    SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n    SafeTransferLib.forceSafeTransferETH(beneficiary, amountToPay - amountForArtist, SAFE_GAS_LIMIT);\\n  }\\n\\n  function buyNowMultiple(\\n    uint256[] calldata auctionIds\\n  ) external payable {\\n    require(!paused, 'Buying is paused');\\n\\n    uint256 totalFailed; uint256 totalPrice;\\n    for(uint256 i; i < auctionIds.length; ++i) {\\n      uint256 auctionId = auctionIds[i];\\n      AuctionConfig memory config = auctionConfig[auctionId];\\n      uint256 amountToPay = config.buyNowPrice;\\n\\n      if (\\n        (block.timestamp < config.buyNowStartTime)\\n        ||(config.auctionStartTime <= block.timestamp)\\n        || amountToPay == 0\\n      ) {\\n        totalFailed += amountToPay;\\n        continue;\\n      }\\n\\n      auctionConfig[auctionId].auctionStartTime = uint80(block.timestamp - INIT_AUCTION_DURATION);\\n      auctionIdToAuction[auctionId] = Auction(0, uint72(amountToPay), msg.sender);\\n      totalPrice += amountToPay;\\n      _mint(msg.sender, auctionId);\\n\\n      emit Settled(\\n        auctionId,\\n        getCollectionFromId(auctionId),\\n        getArtTokenIdFromId(auctionId),\\n        block.timestamp\\n      );\\n\\n      uint256 split = config.split;\\n      if (split == 0) {\\n        split = DEFAULT_SPLIT;\\n      }\\n      uint256 amountForArtist = amountToPay * split / 10_000;\\n      SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n      SafeTransferLib.forceSafeTransferETH(beneficiary, amountToPay - amountForArtist, SAFE_GAS_LIMIT);\\n    }\\n\\n    require(totalPrice == msg.value, 'Incorrect ETH amount sent.');\\n    if (totalFailed > 0) {\\n      SafeTransferLib.forceSafeTransferETH(msg.sender, totalFailed, SAFE_GAS_LIMIT);\\n    }\\n  }\\n\\n  function settleAuction(\\n    uint256 auctionId\\n  ) external payable {\\n    Auction memory highestBid = auctionIdToAuction[auctionId];\\n    AuctionConfig memory config = auctionConfig[auctionId];\\n    require(isAuctionOver(auctionId), 'Auction is still active');\\n\\n    uint256 amountToPay = highestBid.amount;\\n    if (amountToPay > 0) {\\n      _mint(highestBid.bidder, auctionId);\\n    } else {\\n      require(msg.value == reservePrice(auctionId), 'Incorrect funds sent for unclaimed');\\n      amountToPay = msg.value;\\n\\n      _mint(owner(), auctionId);\\n    }\\n\\n    emit Settled(\\n      auctionId,\\n      getCollectionFromId(auctionId),\\n      getArtTokenIdFromId(auctionId),\\n      block.timestamp\\n    );\\n\\n    uint256 split = config.split;\\n    if (split == 0) {\\n      split = DEFAULT_SPLIT;\\n    }\\n    uint256 amountForArtist = amountToPay * split / 10_000;\\n    SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n    SafeTransferLib.forceSafeTransferETH(beneficiary, amountToPay - amountForArtist, SAFE_GAS_LIMIT);\\n  }\\n\\n  function settleMultipleAuctions(\\n    uint256[] calldata auctionIds\\n  ) external payable {\\n    uint256 unclaimedCost; uint256 amountForBene;\\n    for (uint256 i; i < auctionIds.length; ++i) {\\n      uint256 auctionId = auctionIds[i];\\n      Auction memory highestBid = auctionIdToAuction[auctionId];\\n      require(isAuctionOver(auctionId), 'Auction is still active');\\n\\n      uint256 amountToPay = highestBid.amount;\\n      if (amountToPay > 0) {\\n        _mint(highestBid.bidder, auctionId);\\n      } else {\\n        amountToPay = reservePrice(auctionId);\\n        unclaimedCost += amountToPay;\\n        _mint(owner(), auctionId);\\n      }\\n\\n      emit Settled(\\n        auctionId,\\n        getCollectionFromId(auctionId),\\n        getArtTokenIdFromId(auctionId),\\n        block.timestamp\\n      );\\n\\n      AuctionConfig memory config = auctionConfig[auctionId];\\n      uint256 split = config.split;\\n      if (split == 0) {\\n        split = DEFAULT_SPLIT;\\n      }\\n      uint256 amountForArtist = amountToPay * split / 10_000;\\n      SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n\\n      amountForBene += amountToPay - amountForArtist;\\n    }\\n\\n    require(msg.value == unclaimedCost, 'Incorrect funds sent for unclaimed');\\n    SafeTransferLib.forceSafeTransferETH(beneficiary, amountForBene, SAFE_GAS_LIMIT);\\n  }\\n\\n  function _mint(\\n    address to,\\n    uint256 auctionId\\n  ) internal {\\n    address collection = getCollectionFromId(auctionId);\\n    uint256 tokenId = getArtTokenIdFromId(auctionId);\\n    try INFT(collection).ownerOf(tokenId) returns (address _owner) {\\n      if (_owner == address(0)) {\\n        INFT(collection).mint(to, tokenId);\\n      } else {\\n        INFT(collection).transferFrom(_owner, to, tokenId);\\n      }\\n    } catch {\\n      INFT(collection).mint(to, tokenId);\\n    }\\n  }\\n\\n  function _changePrices(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newBuyNowPrice,\\n    uint256 newReservePrice\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime > block.timestamp);\\n\\n    auctionConfig[auctionId].buyNowPrice = uint88(newBuyNowPrice);\\n    auctionConfig[auctionId].reservePrice = uint88(newReservePrice);\\n  }\\n\\n  function _changeSplit(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    address artist,\\n    uint256 newSplit\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    if (artist != address(0)) {\\n      auctionConfig[auctionId].artist = artist;\\n    }\\n    auctionConfig[auctionId].split = uint16(newSplit);\\n  }\\n\\n  function _reschedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newBuyNowStartTime,\\n    uint256 newAuctionStartTime\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime > block.timestamp);\\n    require(newBuyNowStartTime <= newAuctionStartTime);\\n\\n    auctionConfig[auctionId].buyNowStartTime = uint80(newBuyNowStartTime);\\n    auctionConfig[auctionId].auctionStartTime = uint80(newAuctionStartTime);\\n  }\\n\\n  function _schedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 buyNowStartTime,\\n    uint256 auctionStartTime,\\n    address artist,\\n    uint256 split,\\n    uint256 buyNowPrice,\\n    uint256 reserve\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime == 0);\\n\\n    uint256 adjAucStartTime = auctionStartTime;\\n    if (adjAucStartTime == 0) {\\n      adjAucStartTime = type(uint80).max;\\n    }\\n    auctionConfig[auctionId] = AuctionConfig(\\n      artist,\\n      uint16(split),\\n      uint80(buyNowStartTime),\\n      uint80(adjAucStartTime),\\n      uint88(buyNowPrice),\\n      uint88(reserve)\\n    );\\n  }\\n\\n  // ONLY OWNER\\n\\n  function changePrices(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newBuyNowPrice,\\n    uint256 newReservePrice\\n  ) external onlyOwner {\\n    _changePrices(collectionAddress, tokenId, newBuyNowPrice, newReservePrice);\\n  }\\n\\n  function changePricesMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata newBuyNowPrices,\\n    uint256[] calldata newReservePrices\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == newBuyNowPrices.length\\n      && newBuyNowPrices.length == newReservePrices.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _changePrices(collections[i], tokenIds[i], newBuyNowPrices[i], newReservePrices[i]);\\n    }\\n  }\\n\\n  function changeSplit(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    address artist,\\n    uint256 split\\n  ) external onlyOwner {\\n    _changeSplit(collectionAddress, tokenId, artist, split);\\n  }\\n\\n  function changeSplitMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    address[] calldata artists,\\n    uint256[] calldata splits\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == artists.length\\n      && artists.length == splits.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _changeSplit(collections[i], tokenIds[i], artists[i], splits[i]);\\n    }\\n  }\\n\\n  function reschedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newBuyNowStartTime,\\n    uint256 newAuctionStartTime\\n  ) external onlyOwner {\\n    _reschedule(collectionAddress, tokenId, newBuyNowStartTime, newAuctionStartTime);\\n  }\\n\\n  function rescheduleMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata newBuyNowStartTimes,\\n    uint256[] calldata newAuctionStartTimes\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == newBuyNowStartTimes.length\\n      && newBuyNowStartTimes.length == newAuctionStartTimes.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _reschedule(collections[i], tokenIds[i], newBuyNowStartTimes[i], newAuctionStartTimes[i]);\\n    }\\n  }\\n\\n  function schedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 buyNowStartTime,\\n    uint256 auctionStartTime,\\n    address artist,\\n    uint256 split,\\n    uint256 buyNowPrice,\\n    uint256 reserve\\n  ) external onlyOwner {\\n    _schedule(\\n      collectionAddress,\\n      tokenId,\\n      buyNowStartTime,\\n      auctionStartTime,\\n      artist,\\n      split,\\n      buyNowPrice,\\n      reserve\\n    );\\n  }\\n\\n  function scheduleMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata buyNowStartTimes,\\n    uint256[] calldata auctionStartTimes,\\n    address[] calldata artists,\\n    uint256[] calldata splits,\\n    uint256[] calldata buyNowPrices,\\n    uint256[] calldata reservePrices\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == buyNowStartTimes.length &&\\n      buyNowStartTimes.length == auctionStartTimes.length && auctionStartTimes.length == artists.length\\n      && artists.length == splits.length && splits.length == buyNowPrices.length &&\\n      buyNowPrices.length == reservePrices.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _schedule(\\n        collections[i],\\n        tokenIds[i],\\n        buyNowStartTimes[i],\\n        auctionStartTimes[i],\\n        artists[i],\\n        splits[i],\\n        buyNowPrices[i],\\n        reservePrices[i]\\n      );\\n    }\\n  }\\n\\n  function setBeneficiary(\\n    address _beneficiary\\n  ) external onlyOwner {\\n    beneficiary = _beneficiary;\\n  }\\n\\n  function setPaused(\\n    bool _paused\\n  ) external onlyOwner {\\n    paused = _paused;\\n  }\\n\\n  // GETTERS\\n\\n  function artTokentoAuctionId(\\n    address collection,\\n    uint256 tokenId\\n  ) public pure returns (uint256) {\\n    return (uint256(uint160(collection)) << 96) | uint96(tokenId);\\n  }\\n\\n  function isAuctionActive(\\n    uint256 auctionId\\n  ) public view returns (bool) {\\n    uint256 startTime = auctionConfig[auctionId].auctionStartTime;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n    return (startTime > 0 && block.timestamp >= startTime && block.timestamp < endTime);\\n  }\\n\\n  function isAuctionOver(\\n    uint256 auctionId\\n  ) public view returns (bool) {\\n    uint256 startTime = auctionConfig[auctionId].auctionStartTime;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n    return (startTime > 0 && block.timestamp >= endTime);\\n  }\\n\\n  function getAuctionEndTime(\\n    uint256 auctionId\\n  ) public view returns (uint256) {\\n    return auctionConfig[auctionId].auctionStartTime + INIT_AUCTION_DURATION + auctionIdToAuction[auctionId].offsetFromEnd;\\n  }\\n\\n  function getAuctionStartTime(\\n    uint256 auctionId\\n  ) external view returns (uint256) {\\n    return auctionConfig[auctionId].auctionStartTime;\\n  }\\n\\n  function getCollectionFromId(\\n    uint256 id\\n  ) public pure returns (address) {\\n    return address(uint160(id >> 96));\\n  }\\n\\n  function getArtTokenIdFromId(\\n    uint256 id\\n  ) public pure returns (uint256) {\\n    return uint256(uint96(id));\\n  }\\n\\n  function reservePrice(\\n    uint256 auctionId\\n  ) public view returns (uint256) {\\n    uint256 reserve = auctionConfig[auctionId].reservePrice;\\n    return reserve != 0 ? reserve : MIN_BID;\\n  }\\n}\\n\\n\\ninterface INFT {\\n  function mint(address to, uint256 tokenId) external;\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"artTokentoAuctionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"split\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"buyNowStartTime\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"auctionStartTime\",\"type\":\"uint80\"},{\"internalType\":\"uint88\",\"name\":\"buyNowPrice\",\"type\":\"uint88\"},{\"internalType\":\"uint88\",\"name\":\"reservePrice\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToAuction\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"offsetFromEnd\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"favorites\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"expectedPrices\",\"type\":\"uint256[]\"}],\"name\":\"bidOnFavs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"buyNow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"}],\"name\":\"buyNowMultiple\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newReservePrice\",\"type\":\"uint256\"}],\"name\":\"changePrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newBuyNowPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newReservePrices\",\"type\":\"uint256[]\"}],\"name\":\"changePricesMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"}],\"name\":\"changeSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"artists\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splits\",\"type\":\"uint256[]\"}],\"name\":\"changeSplitMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getArtTokenIdFromId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCollectionFromId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isAuctionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isAuctionOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyNowStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAuctionStartTime\",\"type\":\"uint256\"}],\"name\":\"reschedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newBuyNowStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newAuctionStartTimes\",\"type\":\"uint256[]\"}],\"name\":\"rescheduleMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"reservePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNowPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyNowStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"auctionStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"artists\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splits\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyNowPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reservePrices\",\"type\":\"uint256[]\"}],\"name\":\"scheduleMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"}],\"name\":\"settleMultipleAuctions\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtMarketplace", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9eb44b425fef9950b2d08a3557d06e8d2e4de1647775c6834c49146f12492c24"}