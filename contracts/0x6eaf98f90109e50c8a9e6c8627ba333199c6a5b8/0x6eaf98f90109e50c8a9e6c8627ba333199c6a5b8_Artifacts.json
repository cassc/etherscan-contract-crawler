{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Artifacts_project-main-4/src/Artifacts.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC404.sol\\\";\\r\\n\\r\\ncontract Artifacts is ERC404, ERC721Receiver {\\r\\n\\r\\n    uint256 public constant FEE_PERCENTAGE = 25; \\r\\n\\r\\n    event TokenStaked (\\r\\n        address indexed staker,\\r\\n        uint256 indexed nftId,\\r\\n        uint256 indexed stakingDuration\\r\\n    );\\r\\n\\r\\n    event PandoraStaked(\\r\\n        address indexed staker,\\r\\n        uint256 indexed nftId,\\r\\n        uint256 indexed stakingDuration\\r\\n    );\\r\\n\\r\\n    event PandoraClaimed(\\r\\n        address indexed staker,\\r\\n        uint256 indexed nftId\\r\\n    );\\r\\n\\r\\n    event RewardClaimed(\\r\\n        address indexed staker,\\r\\n        uint256 indexed amount\\r\\n    );\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 startTime;\\r\\n        uint256 nftId;\\r\\n        uint256 stakingDuration;\\r\\n    }\\r\\n\\r\\n    mapping(address => StakingInfo[]) public stakingTokenBalances;\\r\\n    mapping(address => StakingInfo[]) public stakingPandoraBalances;\\r\\n\\r\\n    uint256 public stakingRewardPoolBalance;\\r\\n    address payable private _teamAddress;\\r\\n    address payable private _feeAddress;\\r\\n    address public immutable pandoraTokenAddress; //True Pandora: 0x9E9FbDE7C7a83c43913BddC8779158F1368F0413;\\r\\n    uint256 public stakingTokenProportion = 60; // 60% for staking reward\\r\\n    uint256 public stakingPandoraProportion = 20; // 20% for pandora staking reward\\r\\n    uint256 public totalStakingToken;\\r\\n    uint256 public totalStakingPandora;\\r\\n    uint256 public totalStakingTokenWeight;\\r\\n    uint256 public totalStakingPandoraWeight;\\r\\n    string public baseTokenURI;\\r\\n    bool private stakingOpen;\\r\\n    bool public tradeOpen;\\r\\n\\r\\n    constructor(\\r\\n        address _owner, address payable teamAddress, address payable feeAddress, address _pandoraTokenAddress\\r\\n    ) ERC404(\\\"Artifacts\\\", \\\"ATFS\\\", 18, 42069, _owner) {\\r\\n        setFeeAddress(feeAddress);\\r\\n        setTeamAddress(teamAddress);\\r\\n        setWhitelist(teamAddress, true);\\r\\n        setWhitelist(feeAddress, true);\\r\\n        setWhitelist(address(this), true);\\r\\n        // mint initial supply to team address: 10% for team, 10% for intial liquidity\\r\\n        balanceOf[_teamAddress] = 42069 * 20 * 10**18 / 100;\\r\\n        stakingRewardPoolBalance = 42069 * 80 * 10**18 / 100 ;\\r\\n        pandoraTokenAddress = _pandoraTokenAddress;\\r\\n        setTokenURI(\\\"https://erc404r.4everland.store/Artifacts\\\");\\r\\n    }\\r\\n\\r\\n    modifier checkStakingTokenEligibility(address user, uint256 nftId) {\\r\\n        require(ownerOf(nftId) == user, \\\"nftId not owned by user\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier checkStakingPandoraEligibility(address user, uint256 nftId) {\\r\\n        require(ERC404(pandoraTokenAddress).ownerOf(nftId) == user, \\\"nftId not owned by user\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier checkStakingOpen() {\\r\\n        require(stakingOpen, \\\"Staking not open yet\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getExpectedStakingTokenRewardByUser(address user) public view returns (uint256) {\\r\\n        uint256 reward = 0;\\r\\n        for (uint256 i = 0; i < stakingTokenBalances[user].length; i++) {\\r\\n            StakingInfo memory info = stakingTokenBalances[user][i];\\r\\n            uint256 weight = calculateWeight(info.stakingDuration);\\r\\n            reward += weight * totalSupply * stakingTokenProportion * 5 / 100 / totalStakingTokenWeight / 100;\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function getExpectedStakingPandoraRewardByUser(address user) public view returns (uint256) {\\r\\n        uint256 reward = 0;\\r\\n        for (uint256 i = 0; i < stakingPandoraBalances[user].length; i++) {\\r\\n            StakingInfo memory info = stakingPandoraBalances[user][i];\\r\\n            uint256 weight = calculateWeight(info.stakingDuration);\\r\\n            reward += weight * totalSupply * stakingPandoraProportion * 5 / 100 / totalStakingPandoraWeight / 100;\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function getExpectedStakingTokenRewardById(address user, uint256 nftId) public view returns (uint256) {\\r\\n        uint256 reward = 0;\\r\\n        for (uint256 i = 0; i < stakingTokenBalances[user].length; i++) {\\r\\n            if (stakingTokenBalances[user][i].nftId == nftId) {\\r\\n                StakingInfo memory info = stakingTokenBalances[user][i];\\r\\n                uint256 weight = calculateWeight(info.stakingDuration);\\r\\n                reward = weight * totalSupply * stakingTokenProportion * 5 / 100 / totalStakingTokenWeight / 100;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function getExpectedStakingPandoraRewardById(address user, uint256 nftId) public view returns (uint256) {\\r\\n        uint256 reward = 0;\\r\\n        for (uint256 i = 0; i < stakingPandoraBalances[user].length; i++) {\\r\\n            if (stakingPandoraBalances[user][i].nftId == nftId) {\\r\\n                StakingInfo memory info = stakingPandoraBalances[user][i];\\r\\n                uint256 weight = calculateWeight(info.stakingDuration);\\r\\n                reward = weight * totalSupply * stakingPandoraProportion * 5 / 100 / totalStakingPandoraWeight / 100;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function openTrading() external onlyOwner() {\\r\\n        require(!tradeOpen,\\\"trading is already open\\\");\\r\\n        tradeOpen = true;\\r\\n    }\\r\\n\\r\\n    function openStaking() external onlyOwner() {\\r\\n        require(!stakingOpen,\\\"staking is already open\\\");\\r\\n        stakingOpen = true;\\r\\n    }\\r\\n\\r\\n    function setSaveGas(bool state) public {\\r\\n        require(balanceOf[msg.sender] == 0, \\\"Balance not zero\\\");\\r\\n        whitelist[msg.sender] = state;\\r\\n    }\\r\\n\\r\\n    function setTeamAddress(address payable teamAddress) public onlyOwner {\\r\\n        _teamAddress = teamAddress;\\r\\n    }\\r\\n\\r\\n    function setFeeAddress(address payable feeAddress) public onlyOwner {\\r\\n        _feeAddress = feeAddress;\\r\\n    }\\r\\n\\r\\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\\r\\n        baseTokenURI = _tokenURI;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\r\\n        return baseTokenURI;\\r\\n    }\\r\\n\\r\\n    function setStakingProportion(uint256 _stakingTokenProportion, uint256 _stakingPandoraProportion) public onlyOwner {\\r\\n        require(_stakingTokenProportion > 0 && _stakingTokenProportion < 100 && _stakingPandoraProportion > 0 && _stakingPandoraProportion < 100 && _stakingTokenProportion + _stakingPandoraProportion < 80, \\\"Invalid staking proportion\\\");\\r\\n        stakingTokenProportion = _stakingTokenProportion;\\r\\n        stakingPandoraProportion = _stakingPandoraProportion;\\r\\n    }\\r\\n\\r\\n    function getStakingTokenRewardPoolBalance() public view returns (uint256) {\\r\\n        return stakingRewardPoolBalance * stakingTokenProportion / 80;\\r\\n    }\\r\\n\\r\\n    function getStakingPandoraRewardPoolBalance() public view returns (uint256) {\\r\\n        return stakingRewardPoolBalance * stakingPandoraProportion / 80;\\r\\n    }\\r\\n\\r\\n    function stakeNativeToken(uint256 nftId, uint256 duration) public checkStakingOpen {\\r\\n        require(duration >= 1 days && duration <= 21 days, \\\"Invalid staking duration\\\");\\r\\n    \\r\\n        stakingTokenBalances[msg.sender].push(StakingInfo({\\r\\n            nftId: nftId,\\r\\n            startTime: block.timestamp,\\r\\n            stakingDuration: duration\\r\\n        }));\\r\\n\\r\\n        totalStakingToken += 1;\\r\\n        totalStakingTokenWeight += calculateWeight(duration);\\r\\n        emit TokenStaked(msg.sender, nftId, duration);\\r\\n        safeTransferFrom(msg.sender, address(this), nftId);\\r\\n    }\\r\\n    \\r\\n    function stakePandoraToken(uint256 nftId, uint256 duration) public checkStakingOpen {\\r\\n        require(duration >= 1 days && duration <= 21 days, \\\"Invalid staking duration\\\");\\r\\n        stakingPandoraBalances[msg.sender].push(StakingInfo({\\r\\n            nftId: nftId,\\r\\n            startTime: block.timestamp,\\r\\n            stakingDuration: duration\\r\\n        }));\\r\\n        totalStakingPandora += 1;\\r\\n        totalStakingPandoraWeight += calculateWeight(duration);\\r\\n\\r\\n        ERC404 Pandora = ERC404(pandoraTokenAddress);\\r\\n        emit PandoraStaked(msg.sender, nftId, duration);\\r\\n        Pandora.transferFrom(msg.sender, address(this), nftId);\\r\\n    }\\r\\n\\r\\n\\r\\n    function claimStakingPandoraReward(uint256 nftId) public {\\r\\n        require(stakingRewardPoolBalance>0, \\\"No reward available\\\");\\r\\n        bool isStaked = false;\\r\\n        uint256 index = 0;\\r\\n        for (uint256 i = 0; i < stakingPandoraBalances[msg.sender].length; i++) {\\r\\n            if (stakingPandoraBalances[msg.sender][i].nftId == nftId) {\\r\\n                index = i;\\r\\n                isStaked = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (isStaked) {\\r\\n            StakingInfo storage info = stakingPandoraBalances[msg.sender][index];\\r\\n            require(block.timestamp >= info.startTime + info.stakingDuration, \\\"Staking period not yet ended\\\");\\r\\n            uint256 weight = calculateWeight(info.stakingDuration);\\r\\n            uint256 reward = weight * totalSupply * stakingPandoraProportion * 5 / 100 / totalStakingPandoraWeight / 100;\\r\\n            removePandoraStakingRecord(msg.sender, index);\\r\\n            if(reward <= stakingRewardPoolBalance){\\r\\n                balanceOf[msg.sender] += reward;\\r\\n                stakingRewardPoolBalance -= reward;\\r\\n            }else{\\r\\n                balanceOf[msg.sender] += stakingRewardPoolBalance;\\r\\n                stakingRewardPoolBalance = 0;\\r\\n            }\\r\\n            ERC404 Pandora = ERC404(pandoraTokenAddress);\\r\\n            emit PandoraClaimed(msg.sender, 10**18);\\r\\n            totalStakingPandoraWeight -= weight;\\r\\n            totalStakingPandora -=1;\\r\\n            bool success = Pandora.transfer(msg.sender, 10**18);\\r\\n            require(success, \\\"Failed to transfer reward\\\");\\r\\n\\r\\n        } else {\\r\\n            revert(\\\"NFT not staked or already claimed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimStakingTokenReward(uint256 nftId) public {\\r\\n        require(stakingRewardPoolBalance>0, \\\"No reward available\\\");\\r\\n        bool isStaked = false;\\r\\n        uint256 index = 0;\\r\\n        for (uint256 i = 0; i < stakingTokenBalances[msg.sender].length; i++) {\\r\\n            if (stakingTokenBalances[msg.sender][i].nftId == nftId) {\\r\\n                index = i;\\r\\n                isStaked = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (isStaked) {\\r\\n            StakingInfo storage info = stakingTokenBalances[msg.sender][index];\\r\\n            require(block.timestamp >= info.startTime + info.stakingDuration, \\\"Staking period not yet ended\\\");\\r\\n            uint256 weight = calculateWeight(info.stakingDuration);\\r\\n            uint256 reward = weight * totalSupply * stakingTokenProportion * 5 / totalStakingTokenWeight / 100 / 100;\\r\\n            removeTokenStakingRecord(msg.sender, index);\\r\\n            if(reward <= stakingRewardPoolBalance){\\r\\n                balanceOf[msg.sender] += reward + _getUnit();\\r\\n                stakingRewardPoolBalance -= reward;\\r\\n            }else{\\r\\n                balanceOf[msg.sender] += stakingRewardPoolBalance;\\r\\n                stakingRewardPoolBalance = 0;\\r\\n            }\\r\\n            totalStakingTokenWeight -= weight;\\r\\n            totalStakingToken -= 1;\\r\\n        } else {\\r\\n            revert(\\\"NFT not staked or already claimed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    \\r\\n    function calculateWeight(uint256 duration) public pure returns (uint256) {\\r\\n        require(duration >= 1 days && duration <= 21 days, \\\"Invalid staking duration\\\");\\r\\n        uint256 weight = (1 + (6 * (duration - 1 days)) / (21 days - 1 days));\\r\\n        return weight * duration / 1 days;\\r\\n    }\\r\\n\\r\\n    function removeTokenStakingRecord(address user, uint256 index) private {\\r\\n        require(index < stakingTokenBalances[user].length, \\\"Index out of bounds\\\");\\r\\n        stakingTokenBalances[user][index] = stakingTokenBalances[user][stakingTokenBalances[user].length - 1];\\r\\n        stakingTokenBalances[user].pop();\\r\\n    }\\r\\n\\r\\n    function removePandoraStakingRecord(address user, uint256 index) private {\\r\\n        require(index < stakingPandoraBalances[user].length, \\\"Index out of bounds\\\");\\r\\n        stakingPandoraBalances[user][index] = stakingPandoraBalances[user][stakingPandoraBalances[user].length - 1];\\r\\n        stakingPandoraBalances[user].pop();\\r\\n    }\\r\\n\\r\\n    event testEvent(uint256 indexed taxamount, bool indexed whitelistFrom, bool indexed whitelistTo);\\r\\n\\r\\n    function _transfer(\\r\\n            address from,\\r\\n            address to,\\r\\n            uint256 amount\\r\\n        ) internal override returns (bool) {\\r\\n            require(tradeOpen || from == owner || msg.sender == owner, \\\"Trading not yet open\\\");\\r\\n            uint256 unit = _getUnit();\\r\\n            uint256 taxAmount = 0;\\r\\n            if(msg.sender != owner && tradeOpen){\\r\\n                taxAmount = (amount * FEE_PERCENTAGE) * 2 / 1000; \\r\\n            }\\r\\n            uint256 balanceBeforeSender = balanceOf[from];\\r\\n            uint256 balanceBeforeReceiver = balanceOf[to];\\r\\n            balanceOf[from] -= amount;\\r\\n            unchecked {\\r\\n                balanceOf[to] += (amount - taxAmount);\\r\\n                balanceOf[_feeAddress] += taxAmount;\\r\\n            }\\r\\n            if(tradeOpen){\\r\\n                if (!whitelist[from]) {\\r\\n                    uint256 tokens_to_burn = (balanceBeforeSender / unit) -\\r\\n                        (balanceOf[from] / unit);\\r\\n                    for (uint256 i = 0; i < tokens_to_burn; i++) {\\r\\n                        _burn(from);\\r\\n                    }\\r\\n                }\\r\\n                if (!whitelist[to]) {\\r\\n                    uint256 tokens_to_mint = (balanceOf[to] / unit) -\\r\\n                        (balanceBeforeReceiver / unit);\\r\\n                    for (uint256 i = 0; i < tokens_to_mint; i++) {\\r\\n                        _mint(to);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            emit ERC20Transfer(from, to, amount);\\r\\n            emit testEvent(taxAmount, whitelist[from], whitelist[to]);\\r\\n            return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"Artifacts_project-main-4/src/ERC404.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Ownable {\\r\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\r\\n\\r\\n    error Unauthorized();\\r\\n    error InvalidOwner();\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner() virtual {\\r\\n        if (msg.sender != owner) revert Unauthorized();\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        if (_owner == address(0)) revert InvalidOwner();\\r\\n\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _owner) public virtual onlyOwner {\\r\\n        if (_owner == address(0)) revert InvalidOwner();\\r\\n\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, _owner);\\r\\n    }\\r\\n\\r\\n    function revokeOwnership() public virtual onlyOwner {\\r\\n        owner = address(0);\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, address(0));\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract ERC721Receiver {\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external virtual returns (bytes4) {\\r\\n        return ERC721Receiver.onERC721Received.selector;\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice ERC404\\r\\n///         A gas-efficient, mixed ERC20 / ERC721 implementation\\r\\n///         with native liquidity and fractionalization.\\r\\n///\\r\\n///         This is an experimental standard designed to integrate\\r\\n///         with pre-existing ERC20 / ERC721 support as smoothly as\\r\\n///         possible.\\r\\n///\\r\\n/// @dev    In order to support full functionality of ERC20 and ERC721\\r\\n///         supply assumptions are made that slightly constraint usage.\\r\\n///         Ensure decimals are sufficiently large (standard 18 recommended)\\r\\n///         as ids are effectively encoded in the lowest range of amounts.\\r\\n///\\r\\n///         NFTs are spent on ERC20 functions in a FILO queue, this is by\\r\\n///         design.\\r\\n///\\r\\nabstract contract ERC404 is Ownable {\\r\\n    // Events\\r\\n    event ERC20Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n    event ERC721Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    // Errors\\r\\n    error NotFound();\\r\\n    error AlreadyExists();\\r\\n    error InvalidRecipient();\\r\\n    error InvalidSender();\\r\\n    error UnsafeRecipient();\\r\\n\\r\\n    // Metadata\\r\\n    /// @dev Token name\\r\\n    string public name;\\r\\n\\r\\n    /// @dev Token symbol\\r\\n    string public symbol;\\r\\n\\r\\n    /// @dev Decimals for fractional representation\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /// @dev Total supply in fractionalized representation\\r\\n    uint256 public immutable totalSupply;\\r\\n\\r\\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\\r\\n    uint256 public minted;\\r\\n\\r\\n    // Mappings\\r\\n    /// @dev Balance of user in fractional representation\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n\\r\\n    /// @dev Allowance of user in fractional representation\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /// @dev Approval in native representaion\\r\\n    mapping(uint256 => address) public getApproved;\\r\\n\\r\\n    /// @dev Approval for all in native representation\\r\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\r\\n\\r\\n    /// @dev Owner of id in native representation\\r\\n    mapping(uint256 => address) internal _ownerOf;\\r\\n\\r\\n    /// @dev Array of owned ids in native representation\\r\\n    mapping(address => uint256[]) internal _owned;\\r\\n\\r\\n    /// @dev Tracks indices for the _owned mapping\\r\\n    mapping(uint256 => uint256) internal _ownedIndex;\\r\\n\\r\\n    /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\\r\\n    mapping(address => bool) public whitelist;\\r\\n\\r\\n    // Constructor\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals,\\r\\n        uint256 _totalNativeSupply,\\r\\n        address _owner\\r\\n    ) Ownable(_owner) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n        totalSupply = _totalNativeSupply * (10 ** decimals);\\r\\n    }\\r\\n\\r\\n    /// @notice Initialization function to set pairs / etc\\r\\n    ///         saving gas by avoiding mint / burn on unnecessary targets\\r\\n    function setWhitelist(address target, bool state) public onlyOwner {\\r\\n        whitelist[target] = state;\\r\\n    }\\r\\n\\r\\n    /// @notice Function to find owner of a given native token\\r\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\r\\n        owner = _ownerOf[id];\\r\\n\\r\\n        if (owner == address(0)) {\\r\\n            revert NotFound();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice tokenURI must be implemented by child contract\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\r\\n\\r\\n    /// @notice Function for token approvals\\r\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amountOrId\\r\\n    ) public virtual returns (bool) {\\r\\n        if (amountOrId <= minted && amountOrId > 0) {\\r\\n            address owner = _ownerOf[amountOrId];\\r\\n\\r\\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\\r\\n                revert Unauthorized();\\r\\n            }\\r\\n\\r\\n            getApproved[amountOrId] = spender;\\r\\n\\r\\n            emit Approval(owner, spender, amountOrId);\\r\\n        } else {\\r\\n            allowance[msg.sender][spender] = amountOrId;\\r\\n\\r\\n            emit Approval(msg.sender, spender, amountOrId);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Function native approvals\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        isApprovedForAll[msg.sender][operator] = approved;\\r\\n\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /// @notice Function for mixed transfers\\r\\n    /// @dev This function assumes id / native if amount less than or equal to current max id\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amountOrId\\r\\n    ) public virtual {\\r\\n        if (amountOrId <= minted) {\\r\\n            if (from != _ownerOf[amountOrId]) {\\r\\n                revert InvalidSender();\\r\\n            }\\r\\n\\r\\n            if (to == address(0)) {\\r\\n                revert InvalidRecipient();\\r\\n            }\\r\\n\\r\\n            if (\\r\\n                msg.sender != from &&\\r\\n                !isApprovedForAll[from][msg.sender] &&\\r\\n                msg.sender != getApproved[amountOrId]\\r\\n            ) {\\r\\n                revert Unauthorized();\\r\\n            }\\r\\n\\r\\n            balanceOf[from] -= _getUnit();\\r\\n\\r\\n            unchecked {\\r\\n                balanceOf[to] += _getUnit();\\r\\n            }\\r\\n\\r\\n            _ownerOf[amountOrId] = to;\\r\\n            delete getApproved[amountOrId];\\r\\n\\r\\n            // update _owned for sender\\r\\n            uint256 updatedId = _owned[from][_owned[from].length - 1];\\r\\n            _owned[from][_ownedIndex[amountOrId]] = updatedId;\\r\\n            // pop\\r\\n            _owned[from].pop();\\r\\n            // update index for the moved id\\r\\n            _ownedIndex[updatedId] = _ownedIndex[amountOrId];\\r\\n            // push token to to owned\\r\\n            _owned[to].push(amountOrId);\\r\\n            // update index for to owned\\r\\n            _ownedIndex[amountOrId] = _owned[to].length - 1;\\r\\n\\r\\n            emit Transfer(from, to, amountOrId);\\r\\n            emit ERC20Transfer(from, to, _getUnit());\\r\\n        } else {\\r\\n            uint256 allowed = allowance[from][msg.sender];\\r\\n\\r\\n            if (allowed != type(uint256).max)\\r\\n                allowance[from][msg.sender] = allowed - amountOrId;\\r\\n\\r\\n            _transfer(from, to, amountOrId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Function for fractional transfers\\r\\n    function transfer(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        return _transfer(msg.sender, to, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Function for native transfers with contract support\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (\\r\\n            to.code.length != 0 &&\\r\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") !=\\r\\n            ERC721Receiver.onERC721Received.selector\\r\\n        ) {\\r\\n            revert UnsafeRecipient();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Function for native transfers with contract support and callback data\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes calldata data\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (\\r\\n            to.code.length != 0 &&\\r\\n            ERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\\r\\n            ERC721Receiver.onERC721Received.selector\\r\\n        ) {\\r\\n            revert UnsafeRecipient();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Internal function for fractional transfers\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual returns (bool) {\\r\\n        uint256 unit = _getUnit();\\r\\n        uint256 balanceBeforeSender = balanceOf[from];\\r\\n        uint256 balanceBeforeReceiver = balanceOf[to];\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        // Skip burn for certain addresses to save gas\\r\\n        if (!whitelist[from]) {\\r\\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) -\\r\\n                (balanceOf[from] / unit);\\r\\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\\r\\n                _burn(from);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Skip minting for certain addresses to save gas\\r\\n        if (!whitelist[to]) {\\r\\n            uint256 tokens_to_mint = (balanceOf[to] / unit) -\\r\\n                (balanceBeforeReceiver / unit);\\r\\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\\r\\n                _mint(to);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit ERC20Transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Internal utility logic\\r\\n    function _getUnit() internal view returns (uint256) {\\r\\n        return 10 ** decimals;\\r\\n    }\\r\\n\\r\\n    function _mint(address to) internal virtual {\\r\\n        if (to == address(0)) {\\r\\n            revert InvalidRecipient();\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            minted++;\\r\\n        }\\r\\n\\r\\n        uint256 id = minted;\\r\\n\\r\\n        if (_ownerOf[id] != address(0)) {\\r\\n            revert AlreadyExists();\\r\\n        }\\r\\n\\r\\n        _ownerOf[id] = to;\\r\\n        _owned[to].push(id);\\r\\n        _ownedIndex[id] = _owned[to].length - 1;\\r\\n\\r\\n        emit Transfer(address(0), to, id);\\r\\n    }\\r\\n\\r\\n    function _burn(address from) internal virtual {\\r\\n        if (from == address(0)) {\\r\\n            revert InvalidSender();\\r\\n        }\\r\\n\\r\\n        uint256 id = _owned[from][_owned[from].length - 1];\\r\\n        _owned[from].pop();\\r\\n        delete _ownedIndex[id];\\r\\n        delete _ownerOf[id];\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(from, address(0), id);\\r\\n    }\\r\\n\\r\\n    function _setNameSymbol(\\r\\n        string memory _name,\\r\\n        string memory _symbol\\r\\n    ) internal {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"teamAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pandoraTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"PandoraClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingDuration\",\"type\":\"uint256\"}],\"name\":\"PandoraStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingDuration\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"taxamount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"whitelistFrom\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"whitelistTo\",\"type\":\"bool\"}],\"name\":\"testEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"calculateWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"claimStakingPandoraReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"claimStakingTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"getExpectedStakingPandoraRewardById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getExpectedStakingPandoraRewardByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"getExpectedStakingTokenRewardById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getExpectedStakingTokenRewardByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingPandoraRewardPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingTokenRewardPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pandoraTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setSaveGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingTokenProportion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingPandoraProportion\",\"type\":\"uint256\"}],\"name\":\"setStakingProportion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"teamAddress\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"stakeNativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"stakePandoraToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingPandoraBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPandoraProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingTokenBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingTokenProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingPandora\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingPandoraWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakingTokenWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Artifacts", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ecd957a33ebd5221bb6625e16d2451fb909bd821000000000000000000000000ecd957a33ebd5221bb6625e16d2451fb909bd821000000000000000000000000ecd957a33ebd5221bb6625e16d2451fb909bd8210000000000000000000000009e9fbde7c7a83c43913bddc8779158f1368f0413", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}