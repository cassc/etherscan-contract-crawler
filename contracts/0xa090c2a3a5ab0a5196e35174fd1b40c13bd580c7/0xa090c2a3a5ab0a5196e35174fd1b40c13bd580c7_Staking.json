{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract Constant {\r\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\r\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\r\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\r\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\r\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\r\n    string constant ERR_NOT_ENOUGH_BALANCE = \"ERR_NOT_ENOUGH_BALANCE\";\r\n\r\n    modifier notOwnAddress(address _which) {\r\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // validates an address is not zero\r\n    modifier notZeroAddress(address _which) {\r\n        require(_which != address(0), ERR_ZERO_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThisAddress(address _which) {\r\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\r\n        _;\r\n    }\r\n\r\n    modifier notZeroValue(uint256 _value) {\r\n        require(_value > 0, ERR_VALUE_IS_ZERO);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Ownable is Constant {\r\n\r\n    address payable public owner;\r\n    address payable public newOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function _transferOwnership(address payable _whom) internal {\r\n        emit OwnershipTransferred(owner,_whom);\r\n        owner = _whom;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, ERR_AUTHORIZED_ADDRESS_ONLY);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address payable _newOwner)\r\n    external\r\n    virtual\r\n    notZeroAddress(_newOwner)\r\n    onlyOwner\r\n    {\r\n        // emit OwnershipTransferred(owner, newOwner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external\r\n    virtual\r\n    returns (bool){\r\n        require(msg.sender == newOwner,\"ERR_ONLY_NEW_OWNER\");\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        newOwner = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n    /**\r\n      * @dev Returns the subtraction of two unsigned integers, reverting on\r\n      * overflow (when the result is negative).\r\n      *\r\n      * Counterpart to Solidity's `-` operator.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - Subtraction cannot overflow.\r\n      */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b <= a, error);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\r\n        require(b > 0, error);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\r\n        uint256 result;\r\n        assembly {\r\n            result:=exp(a, b)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\ninterface ERC20Interface\r\n{\r\n    function totalSupply() external view returns(uint256);\r\n\r\n    function balanceOf(address _tokenOwner)external view returns(uint balance );\r\n\r\n    function allowance(address _tokenOwner, address _spender)external view returns (uint supply);\r\n\r\n    function transfer(address _to,uint _tokens)external returns(bool success);\r\n\r\n    function approve(address _spender,uint _tokens)external returns(bool success);\r\n\r\n    function transferFrom(address _from,address _to,uint _tokens)external returns(bool success);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _tokens);\r\n}\r\n\r\ncontract StakeStorage {\r\n\r\n    /**\r\n    * @dev check if token is listed\r\n   **/\r\n    mapping(address => bool) public listedToken;\r\n\r\n    /**\r\n     * @dev list of tokens\r\n    **/\r\n    address[] public tokens;\r\n\r\n    mapping(address => uint256)public tokenIndex;\r\n    mapping(address => mapping(address => uint256)) public stakeBalance;\r\n    mapping(address => mapping(address => uint256)) public lastStakeClaimed;\r\n    mapping(address => uint256)public totalTokens;\r\n\r\n    /**\r\n     * @dev annual mint percent of a token\r\n     **/\r\n    mapping(address => uint256) public annualMintPercentage;\r\n    /**\r\n    * @dev list of particular token's paynoder\r\n    **/\r\n    mapping(address => address[])public payNoders;\r\n    /**\r\n     * @dev check if address is in paynode\r\n     **/\r\n    mapping(address => mapping(address => bool)) public isPayNoder;\r\n    /**\r\n     * @dev maintain array index for addresses\r\n     **/\r\n    mapping(address => mapping(address => uint256)) public payNoderIndex;\r\n    /**\r\n     * @dev token's  paynode slot\r\n    **/\r\n    mapping(address => uint256)public tokenPayNoderSlot;\r\n\r\n    /**\r\n     * @dev minimum balance require for be in paynode\r\n    **/\r\n    mapping(address => uint256)public tokenMinimumBalance;\r\n    mapping(address => uint256)public tokenExtraMintForPayNodes;\r\n\r\n    event Stake(\r\n        uint256 indexed _stakeTimestamp,\r\n        address indexed _token,\r\n        address indexed _whom,\r\n        uint256 _amount\r\n    );\r\n\r\n    event StakeClaimed(\r\n        uint256 indexed _stakeClaimedTimestamp,\r\n        address indexed _token,\r\n        address indexed _whom,\r\n        uint256 _amount\r\n    );\r\n\r\n    event UnStake(\r\n        uint256 indexed _unstakeTimestamp,\r\n        address indexed _token,\r\n        address indexed _whom,\r\n        uint256 _amount\r\n    );\r\n}\r\n\r\ncontract Paynodes is Ownable, SafeMath, StakeStorage {\r\n\r\n    /**\r\n     * @dev adding paynode account\r\n    **/\r\n    function addaccountToPayNode(address _token, address _whom)\r\n    external\r\n    onlyOwner()\r\n    returns (bool)\r\n    {\r\n        require(isPayNoder[_token][_whom] == false, \"ERR_ALREADY_IN_PAYNODE_LIST\");\r\n\r\n        require(payNoders[_token].length < tokenPayNoderSlot[_token], \"ERR_PAYNODE_LIST_FULL\");\r\n\r\n        require(stakeBalance[_token][_whom] >= tokenMinimumBalance[_token], \"ERR_PAYNODE_MINIMUM_BALANCE\");\r\n\r\n        isPayNoder[_token][_whom] = true;\r\n        payNoderIndex[_token][_whom] = payNoders[_token].length;\r\n        payNoders[_token].push(_whom);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev removing paynode account\r\n     **/\r\n    function _removeaccountToPayNode(address _token, address _whom) internal returns (bool) {\r\n\r\n        require(isPayNoder[_token][_whom], \"ERR_ONLY_PAYNODER\");\r\n        uint256 _payNoderIndex = payNoderIndex[_token][_whom];\r\n\r\n        address _lastAddress = payNoders[_token][safeSub(payNoders[_token].length, 1)];\r\n        payNoders[_token][_payNoderIndex] = _lastAddress;\r\n        payNoderIndex[_token][_lastAddress] = _payNoderIndex;\r\n        delete isPayNoder[_token][_whom];\r\n        payNoders[_token].pop();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove account from paynode\r\n     **/\r\n    function removeaccountToPayNode(address _token, address _whom)\r\n    external\r\n    onlyOwner()\r\n    returns (bool)\r\n    {\r\n        return _removeaccountToPayNode(_token, _whom);\r\n    }\r\n\r\n    /**\r\n     * @dev owner can change minimum balance requirement\r\n     **/\r\n    function setMinimumBalanceForPayNoder(address _token, uint256 _minimumBalance)\r\n    external\r\n    onlyOwner()\r\n    returns (bool)\r\n    {\r\n        tokenMinimumBalance[_token] = _minimumBalance;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev owner can change extra mint percent for paynoder\r\n     * _extraMintForPayNodes is set in percent with mulitply 100\r\n     * if owner want to set 1.25% then value is 125\r\n     **/\r\n    function setExtraMintingForNodes(address _token, uint256 _extraMintForPayNodes)\r\n    external\r\n    onlyOwner()\r\n    returns (bool)\r\n    {\r\n        tokenExtraMintForPayNodes[_token] = _extraMintForPayNodes;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev owner can set paynoder slots\r\n     **/\r\n    function setPayNoderSlot(address _token, uint256 _payNoderSlot)\r\n    external\r\n    onlyOwner()\r\n    returns (bool)\r\n    {\r\n        tokenPayNoderSlot[_token] = _payNoderSlot;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Staking is Paynodes {\r\n\r\n    constructor(address[] memory _token) public {\r\n        for (uint8 i = 0; i < _token.length; i++) {\r\n            listedToken[_token[i]] = true;\r\n            tokens.push(_token[i]);\r\n            tokenIndex[_token[i]] = i;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev stake token\r\n    **/\r\n    function stake(address _token, uint256 _amount) external returns (bool){\r\n\r\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\r\n\r\n        ERC20Interface(_token).transferFrom(msg.sender, address(this), _amount);\r\n\r\n        if (lastStakeClaimed[_token][msg.sender] == 0) {\r\n            lastStakeClaimed[_token][msg.sender] = now;\r\n        } else {\r\n            uint256 _stakeReward = _calculateStake(_token, msg.sender);\r\n            lastStakeClaimed[_token][msg.sender] = now;\r\n            stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\r\n        }\r\n\r\n        totalTokens[_token] = safeAdd(totalTokens[_token], _amount);\r\n        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _amount);\r\n        emit Stake(now, _token, msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev stake token\r\n     **/\r\n    function unStake(address _token) external returns (bool){\r\n\r\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\r\n\r\n        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\r\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\r\n        ERC20Interface(_token).transfer(msg.sender, safeAdd(userTokenBalance, _stakeReward));\r\n        emit UnStake(now, _token, msg.sender, safeAdd(userTokenBalance, _stakeReward));\r\n        totalTokens[_token] = safeSub(totalTokens[_token], userTokenBalance);\r\n        stakeBalance[_token][msg.sender] = 0;\r\n        lastStakeClaimed[_token][msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw token\r\n     **/\r\n    function withdrawToken(address _token) external returns (bool){\r\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\r\n        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\r\n        stakeBalance[_token][msg.sender] = 0;\r\n        lastStakeClaimed[_token][msg.sender] = 0;\r\n        ERC20Interface(_token).transfer(msg.sender, userTokenBalance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw token by owner\r\n     **/\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner() returns (bool) {\r\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\r\n        require(totalTokens[_token] == 0, \"ERR_TOTAL_TOKENS_NEEDS_TO_BE_0_FOR_WITHDRAWL\");\r\n        ERC20Interface(_token).transfer(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    // we calculate daily basis stake amount\r\n    function _calculateStake(address _token, address _whom) internal view returns (uint256) {\r\n        uint256 _lastRound = lastStakeClaimed[_token][_whom];\r\n        uint256 totalStakeDays = safeDiv(safeSub(now, _lastRound), 86400);\r\n        uint256 userTokenBalance = stakeBalance[_token][_whom];\r\n        uint256 tokenPercentage = annualMintPercentage[_token];\r\n        if (totalStakeDays > 0) {\r\n            uint256 stakeAmount = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), totalStakeDays), 3650000);\r\n            if (isPayNoder[_token][_whom]) {\r\n                if (stakeBalance[_token][_whom] >= tokenMinimumBalance[_token]) {\r\n                    uint256 extraPayNode = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), tokenExtraMintForPayNodes[_token]), 3650000);\r\n                    stakeAmount = safeAdd(stakeAmount, extraPayNode);\r\n                }\r\n            }\r\n            return stakeAmount;\r\n        }\r\n        return 0;\r\n\r\n    }\r\n\r\n    // show stake balance with what user get\r\n    function balanceOf(address _token, address _whom) external view returns (uint256) {\r\n        uint256 _stakeReward = _calculateStake(_token, _whom);\r\n        return safeAdd(stakeBalance[_token][_whom], _stakeReward);\r\n    }\r\n\r\n    // show stake balance with what user get\r\n    function getOnlyRewards(address _token, address _whom) external view returns (uint256) {\r\n        return _calculateStake(_token, _whom);\r\n    }\r\n\r\n    // claim only rewards and withdraw it\r\n    function claimRewardsOnlyAndWithDraw(address _token) external returns (bool) {\r\n        require(lastStakeClaimed[_token][msg.sender] != 0, \"ERR_TOKEN_IS_NOT_STAKED\");\r\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\r\n        ERC20Interface(_token).transfer(msg.sender, _stakeReward);\r\n        lastStakeClaimed[_token][msg.sender] = now;\r\n        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\r\n        return true;\r\n    }\r\n\r\n    // claim only rewards and restake it\r\n    function claimRewardsOnlyAndStake(address _token) external returns (bool) {\r\n        require(lastStakeClaimed[_token][msg.sender] != 0, \"ERR_TOKEN_IS_NOT_STAKED\");\r\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\r\n\r\n        lastStakeClaimed[_token][msg.sender] = now;\r\n        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\r\n        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\r\n        emit Stake(now, _token, msg.sender, stakeBalance[_token][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    // _percent should be mulitplied by 100\r\n    function setAnnualMintPercentage(address _token, uint256 _percent) external onlyOwner() returns (bool) {\r\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\r\n        annualMintPercentage[_token] = _percent;\r\n        return true;\r\n    }\r\n\r\n    // to add new token\r\n    function addToken(address _token) external onlyOwner() {\r\n        require(!listedToken[_token], \"ERR_TOKEN_ALREADY_EXISTS\");\r\n        tokens.push(_token);\r\n        listedToken[_token] = true;\r\n        tokenIndex[_token] = tokens.length;\r\n    }\r\n\r\n    // to remove the token\r\n    function removeToken(address _token) external onlyOwner() {\r\n        require(listedToken[_token], \"ERR_TOKEN_DOESNOT_EXISTS\");\r\n        uint256 _lastindex = tokenIndex[_token];\r\n        address _lastaddress = tokens[safeSub(tokens.length, 1)];\r\n        tokenIndex[_lastaddress] = _lastindex;\r\n        tokens[_lastindex] = _lastaddress;\r\n        tokens.pop();\r\n        delete tokenIndex[_lastaddress];\r\n        listedToken[_token] = false;\r\n    }\r\n\r\n    function availabletokens() public view returns (uint){\r\n        return tokens.length;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_stakeClaimedTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_unstakeTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"addaccountToPayNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"annualMintPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availabletokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimRewardsOnlyAndStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimRewardsOnlyAndWithDraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"getOnlyRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPayNoder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastStakeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payNoderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payNoders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"removeaccountToPayNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setAnnualMintPercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_extraMintForPayNodes\",\"type\":\"uint256\"}],\"name\":\"setExtraMintingForNodes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumBalance\",\"type\":\"uint256\"}],\"name\":\"setMinimumBalanceForPayNoder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_payNoderSlot\",\"type\":\"uint256\"}],\"name\":\"setPayNoderSlot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenExtraMintForPayNodes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMinimumBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenPayNoderSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000008ef47555856f6ce2e0cd7c36aef4fab317d2e2e2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9f9738484aadc22a59270bdf044023531f32087f20c326d71a68d6dbc559495a"}