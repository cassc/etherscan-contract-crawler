{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModelV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./InterestRateModelXAI.sol\\\";\\nimport \\\"./lib/EasyMathV2.sol\\\";\\n\\ninterface IGenericInterestRateModel {\\n    function config(address _silo, address _asset) external view returns (IInterestRateModel.Config memory);\\n}\\n\\n/// @title InterestRateModelV2\\n/// @notice Dynamic interest rate model implementation\\n/// @dev Model stores some Silo specific data. If model is replaced, it needs to set proper config after redeployment\\n/// for seamless service. Please refer to separate litepaper about model for design details.\\n/// @custom:security-contact security@silo.finance\\ncontract InterestRateModelV2 is InterestRateModelXAI {\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n\\n    constructor(Config memory _config, address _owner) InterestRateModelXAI(_config) {\\n        if (_owner != address(0) && _owner != msg.sender) {\\n            transferOwnership(_owner);\\n        }\\n    }\\n\\n    /// @dev migration method for models before InterestRateModelV2\\n    /// @param _silos array of Silos addresses for which config will be cloned\\n    /// @param _siloRepository SiloRepository addresses\\n    function migrationFromV1(address[] calldata _silos, ISiloRepository _siloRepository)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        IInterestRateModel model;\\n\\n        for (uint256 i; i < _silos.length;) {\\n            address[] memory assets = ISilo(_silos[i]).getAssets();\\n\\n            if (address(model) == address(0)) {\\n                // assumption is that XAI is not first asset otherwise this optimisation will not work\\n                model = _siloRepository.getInterestRateModel(_silos[0], assets[0]);\\n            }\\n\\n            for (uint256 j; j < assets.length;) {\\n                Config memory clonedConfig = IGenericInterestRateModel(address(model)).config(_silos[i], assets[j]);\\n\\n                if (clonedConfig.uopt == 0) {\\n                    IInterestRateModel secondModel = _siloRepository.getInterestRateModel(_silos[i], assets[j]);\\n                    clonedConfig = IGenericInterestRateModel(address(secondModel)).config(_silos[i], assets[j]);\\n                }\\n\\n                // in order not to clone empty config, check `uopt` - based on requirements it can not be 0\\n                if (clonedConfig.uopt != 0) {\\n                    // beta is divided by value of 4 for all configs, except stableLowCap, stableHighCap and bridgeXAI\\n                    // With current values of beta parameter, volatile assets will get their interest rate\\n                    // (proportional term) multiplied by 2 in one hour. Division of beta coefficient by 4 will result\\n                    // in changing time for to double from one hour to four hours, which will make the interest rate\\n                    // model behaviour less risky,\\n                    // If we will forget about integral term (which will have less impact in first hours of critical\\n                    // utilisation), proportional term will grow linear. It will double in first 4 hours,\\n                    // triple in 8, x4 in 12, etc.\\n                    if (clonedConfig.beta == 277777777777778) {\\n                        clonedConfig.beta = 69444444444444;\\n                    }\\n\\n                    // when we `setConfig()` we call `accrueInterest()`\\n                    // we don't have to do it when we cloning, because config will not change\\n                    _setConfig(_silos[i], assets[j], clonedConfig);\\n                }\\n\\n                unchecked { j++; }\\n            }\\n\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function calculateCurrentInterestRate( // solhint-disable-line function-max-lines\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) public pure virtual override returns (uint256 rcur) {\\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\\n\\n        // struct for local vars to avoid \\\"Stack too deep\\\"\\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\\n\\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\\n            _c,\\n            _totalDeposits,\\n            _totalBorrowAmount,\\n            _interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n\\n        if (_l.overflow) {\\n            return 0;\\n        }\\n\\n        // There can't be an underflow in the subtraction because of the previous check\\n        unchecked {\\n            // T := t1 - t0 # length of time period in seconds\\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\\n        }\\n\\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\\n        _l.DP = int256(DP);\\n\\n        if (_l.u > _c.ucrit) {\\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\\n        } else {\\n            // rp := min (0, klow * (u0 - ulow ))\\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\\n        }\\n\\n        // rlin := klin * u0 # lower bound between t0 and t1\\n        _l.rlin = _c.klin * _l.u / _l.DP;\\n        // ri := max(ri , rlin )\\n        _l.ri = _max(_c.ri, _l.rlin);\\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\\n        rcur *= 365 days;\\n\\n        return _currentInterestRateCAP(rcur);\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function calculateCompoundInterestRateWithOverflowDetection( // solhint-disable-line function-max-lines\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) public pure virtual override returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\\n        bool overflow\\n    ) {\\n        ri = _c.ri;\\n        Tcrit = _c.Tcrit;\\n\\n        // struct for local vars to avoid \\\"Stack too deep\\\"\\n        LocalVarsRComp memory _l = LocalVarsRComp(0,0,0,0,0,0,0,0,0,0);\\n\\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\\n\\n        // There can't be an underflow in the subtraction because of the previous check\\n        unchecked {\\n            // length of time period in seconds\\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\\n        }\\n\\n        int256 _DP = int256(DP); // solhint-disable-line var-name-mixedcase\\n\\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\\n\\n        // slopei := ki * (u0 - uopt )\\n        _l.slopei = _c.ki * (_l.u - _c.uopt) / _DP;\\n\\n        if (_l.u > _c.ucrit) {\\n            // rp := kcrit * (1 + Tcrit) * (u0 - ucrit )\\n            _l.rp = _c.kcrit * (_DP + Tcrit) / _DP * (_l.u - _c.ucrit) / _DP;\\n            // slope := slopei + kcrit * beta * (u0 - ucrit )\\n            _l.slope = _l.slopei + _c.kcrit * _c.beta / _DP * (_l.u - _c.ucrit) / _DP;\\n            // Tcrit := Tcrit + beta * T\\n            Tcrit = Tcrit + _c.beta * _l.T;\\n        } else {\\n            // rp := min (0, klow * (u0 - ulow ))\\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _DP);\\n            // slope := slopei\\n            _l.slope = _l.slopei;\\n            // Tcrit := max (0, Tcrit - beta * T)\\n            Tcrit = _max(0, Tcrit - _c.beta * _l.T);\\n        }\\n\\n        // rlin := klin * u0 # lower bound between t0 and t1\\n        _l.rlin = _c.klin * _l.u / _DP;\\n        // ri := max(ri , rlin )\\n        ri = _max(ri , _l.rlin);\\n        // r0 := ri + rp # interest rate at t0 ignoring lower bound\\n        _l.r0 = ri + _l.rp;\\n        // r1 := r0 + slope *T # what interest rate would be at t1 ignoring lower bound\\n        _l.r1 = _l.r0 + _l.slope * _l.T;\\n\\n        // Calculating the compound interest\\n\\n        if (_l.r0 >= _l.rlin && _l.r1 >= _l.rlin) {\\n            // lower bound isn\u2019t activated\\n            // rcomp := exp (( r0 + r1) * T / 2) - 1\\n            _l.x = (_l.r0 + _l.r1) * _l.T / 2;\\n        } else if (_l.r0 < _l.rlin && _l.r1 < _l.rlin) {\\n            // lower bound is active during the whole time\\n            // rcomp := exp( rlin * T) - 1\\n            _l.x = _l.rlin * _l.T;\\n        } else if (_l.r0 >= _l.rlin && _l.r1 < _l.rlin) {\\n            // lower bound is active after some time\\n            // rcomp := exp( rlin *T - (r0 - rlin )^2/ slope /2) - 1\\n            _l.x = _l.rlin * _l.T - (_l.r0 - _l.rlin)**2 / _l.slope / 2;\\n        } else {\\n            // lower bound is active before some time\\n            // rcomp := exp( rlin *T + (r1 - rlin )^2/ slope /2) - 1\\n            _l.x = _l.rlin * _l.T + (_l.r1 - _l.rlin)**2 / _l.slope / 2;\\n        }\\n\\n        // ri := max(ri + slopei * T, rlin )\\n        ri = _max(ri + _l.slopei * _l.T, _l.rlin);\\n\\n        // Checking for the overflow below. In case of the overflow, ri and Tcrit will be set back to zeros. Rcomp is\\n        // calculated to not make an overflow in totalBorrowedAmount, totalDeposits.\\n        (rcomp, overflow) = _calculateRComp(_totalDeposits, _totalBorrowAmount, _l.x);\\n\\n        // if we got a limit for rcomp, we reset Tcrit and Ri model parameters to zeros\\n        // Resetting parameters will make IR drop from 10k%/year to 100% per year and it will start growing again.\\n        // If we don\u2019t reset, we will have to wait ~2 weeks to make IR drop (low utilisation ratio required).\\n        // So zeroing parameters is a only hope for a market to get well again, otherwise it will be almost impossible.\\n        bool capApplied;\\n\\n        (rcomp, capApplied) = _compoundInterestRateCAP(rcomp, _l.T.toUint256());\\n\\n        if (overflow || capApplied) {\\n            ri = 0;\\n            Tcrit = 0;\\n        }\\n    }\\n\\n    /// @dev in order to keep methods pure and bee able to deploy easily new caps,\\n    /// that method with hardcoded CAP was created\\n    /// @notice limit for compounding interest rcomp := RCOMP_CAP * _l.T.\\n    /// The limit is simple. Let\u2019s threat our interest rate model as the black box. And for past _l.T time we got\\n    /// a value for rcomp. We need to provide the top limit this value to take into account the limit for current\\n    /// interest. Let\u2019s imagine, if we had maximum allowed interest for _l.T. `RCOMP_CAP * _l.T` will be the value of\\n    /// rcomp in this case, which will serve as the limit.\\n    /// If we got this limit, we should make Tcrit and Ri equal to zero, otherwise there is a low probability of the\\n    /// market going back below the limit.\\n    function _compoundInterestRateCAP(uint256 _rcomp, uint256 _t)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 updatedRcomp, bool capApplied) {\\n        // uint256 cap = 10**20 / (365 * 24 * 3600); // this is per-second rate because _l.T is in seconds.\\n        uint256 cap = 3170979198376 * _t;\\n        return _rcomp > cap ? (cap, true) : (_rcomp, false);\\n    }\\n\\n    /// @notice limit for rcur - RCUR_CAP (FE/integrations, does not affect our protocol).\\n    /// This is the limit for current interest rate, we picked 10k% of interest per year. Interest rate model is working\\n    /// as expected before that threshold and simply sets the maximum value in case of limit.\\n    /// 10k% is a really significant threshold, which will mean the death of market in most of cases.\\n    /// Before 10k% interest rate can be good for certain market conditions.\\n    /// We don\u2019t read the current interest rate in our protocol, because we care only about the interest we compounded\\n    /// over the past time since the last update. It is used in UI and other protocols integrations,\\n    /// for example investing strategies.\\n    function _currentInterestRateCAP(uint256 _rcur) internal pure virtual returns (uint256) {\\n        uint256 cap = 1e20; // 10**20; this is 10,000% APR in the 18-decimals format.\\n        return _rcur > cap ? cap : _rcur;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModelXAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./lib/PRBMathSD59x18.sol\\\";\\nimport \\\"./lib/EasyMathV2.sol\\\";\\nimport \\\"./interfaces/ISilo.sol\\\";\\nimport \\\"./interfaces/IInterestRateModel.sol\\\";\\nimport \\\"./utils/TwoStepOwnable.sol\\\";\\n\\n/// @title InterestRateModelXAI\\n/// @notice Dynamic interest rate model implementation\\n/// @dev Model stores some Silo specific data. If model is replaced, it needs to set proper config after redeployment\\n/// for seamless service. Please refer to separate litepaper about model for design details.\\n/// Difference between original `InterestRateModel` is that we made methods to be `virtual` and :\\n///     if (_config.ki < 0) revert InvalidKi();  --- was ... <= 0\\n//      if (_config.kcrit < 0) revert InvalidKcrit();  --- was ... <= 0\\n/// @custom:security-contact security@silo.finance\\nabstract contract InterestRateModelXAI is IInterestRateModel, TwoStepOwnable {\\n    using PRBMathSD59x18 for int256;\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n\\n    /// @dev DP is 18 decimal points used for integer calculations\\n    uint256 public constant override DP = 1e18;\\n\\n    /// @dev maximum value of compound interest the model will return\\n    uint256 public constant RCOMP_MAX = (2**16) * 1e18;\\n\\n    /// @dev maximum value of X for which, RCOMP_MAX should be returned. If x > X_MAX => exp(x) > RCOMP_MAX.\\n    /// X_MAX = ln(RCOMP_MAX + 1)\\n    int256 public constant X_MAX = 11090370147631773313;\\n\\n    /// @dev maximum allowed amount for accruedInterest, totalDeposits and totalBorrowedAmount\\n    /// after adding compounded interest. If rcomp cause this values to overflow, rcomp is reduced.\\n    /// 196 bits max allowed for an asset amounts because the multiplication product with\\n    /// decimal points (10^18) should not cause an overflow. 196 < log2(2^256 / 10^18)\\n    uint256 public constant ASSET_DATA_OVERFLOW_LIMIT = 2**196;\\n\\n    // Silo => asset => ModelData\\n    mapping(address => mapping(address => Config)) public config;\\n\\n    /// @notice Emitted on config change\\n    /// @param silo Silo address for which config should be set\\n    /// @param asset asset address for which config should be set\\n    /// @param config config struct for asset in Silo\\n    event ConfigUpdate(address indexed silo, address indexed asset, Config config);\\n\\n    error InvalidBeta();\\n    error InvalidKcrit();\\n    error InvalidKi();\\n    error InvalidKlin();\\n    error InvalidKlow();\\n    error InvalidTcrit();\\n    error InvalidTimestamps();\\n    error InvalidUcrit();\\n    error InvalidUlow();\\n    error InvalidUopt();\\n    error InvalidRi();\\n\\n    constructor(Config memory _config) {\\n        _setConfig(address(0), address(0), _config);\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function setConfig(address _silo, address _asset, Config calldata _config) external virtual override onlyOwner {\\n        // we do not care, if accrueInterest call will be successful\\n        // solhint-disable-next-line avoid-low-level-calls\\n        _silo.call(abi.encodeCall(ISilo.accrueInterest, _asset));\\n\\n        _setConfig(_silo, _asset, _config);\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function getCompoundInterestRateAndUpdate(\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external virtual override returns (uint256 rcomp) {\\n        // assume that caller is Silo\\n        address silo = msg.sender;\\n\\n        ISilo.UtilizationData memory data = ISilo(silo).utilizationData(_asset);\\n\\n        // TODO when depositing, we doing two calls for `calculateCompoundInterestRate`, maybe we can optimize?\\n        Config storage currentConfig = config[silo][_asset];\\n\\n        (rcomp, currentConfig.ri, currentConfig.Tcrit) = calculateCompoundInterestRate(\\n            getConfig(silo, _asset),\\n            data.totalDeposits,\\n            data.totalBorrowAmount,\\n            data.interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function getCompoundInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view virtual override returns (uint256 rcomp) {\\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\\n\\n        (rcomp,,) = calculateCompoundInterestRate(\\n            getConfig(_silo, _asset),\\n            data.totalDeposits,\\n            data.totalBorrowAmount,\\n            data.interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function overflowDetected(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view virtual override returns (bool overflow) {\\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\\n\\n        (,,,overflow) = calculateCompoundInterestRateWithOverflowDetection(\\n            getConfig(_silo, _asset),\\n            data.totalDeposits,\\n            data.totalBorrowAmount,\\n            data.interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function getCurrentInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view virtual override returns (uint256 rcur) {\\n        ISilo.UtilizationData memory data = ISilo(_silo).utilizationData(_asset);\\n\\n        rcur = calculateCurrentInterestRate(\\n            getConfig(_silo, _asset),\\n            data.totalDeposits,\\n            data.totalBorrowAmount,\\n            data.interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function getConfig(address _silo, address _asset) public view virtual override returns (Config memory) {\\n        Config storage currentConfig = config[_silo][_asset];\\n\\n        if (currentConfig.uopt != 0) {\\n            return currentConfig;\\n        }\\n\\n        // use default config\\n        Config memory c = config[address(0)][address(0)];\\n\\n        // model data is always stored for each silo and asset so default values must be replaced\\n        c.ri = currentConfig.ri;\\n        c.Tcrit = currentConfig.Tcrit;\\n        return c;\\n    }\\n\\n    /* solhint-disable */\\n\\n    struct LocalVarsRCur {\\n        int256 T;\\n        int256 u;\\n        int256 DP;\\n        int256 rp;\\n        int256 rlin;\\n        int256 ri;\\n        bool overflow;\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function calculateCurrentInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) public pure virtual override returns (uint256 rcur) {\\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\\n\\n        // struct for local vars to avoid \\\"Stack too deep\\\"\\n        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);\\n\\n        (,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(\\n            _c,\\n            _totalDeposits,\\n            _totalBorrowAmount,\\n            _interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n\\n        if (_l.overflow) {\\n            return 0;\\n        }\\n\\n        // There can't be an underflow in the subtraction because of the previous check\\n        unchecked {\\n            // T := t1 - t0 # length of time period in seconds\\n            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\\n        }\\n\\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\\n        _l.DP = int256(DP);\\n\\n        if (_l.u > _c.ucrit) {\\n            // rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )\\n            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;\\n        } else {\\n            // rp := min (0, klow * (u0 - ulow ))\\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);\\n        }\\n\\n        // rlin := klin * u0 # lower bound between t0 and t1\\n        _l.rlin = _c.klin * _l.u / _l.DP;\\n        // ri := max(ri , rlin )\\n        _l.ri = _max(_c.ri, _l.rlin);\\n        // ri := max(ri + ki * (u0 - uopt ) * T, rlin )\\n        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);\\n        // rcur := max (ri + rp , rlin ) # current per second interest rate\\n        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();\\n        rcur *= 365 days;\\n    }\\n\\n    struct LocalVarsRComp {\\n        int256 T;\\n        int256 slopei;\\n        int256 rp;\\n        int256 slope;\\n        int256 r0;\\n        int256 rlin;\\n        int256 r1;\\n        int256 x;\\n        int256 rlin1;\\n        int256 u;\\n    }\\n\\n    function interestRateModelPing() external pure virtual override returns (bytes4) {\\n        return this.interestRateModelPing.selector;\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function calculateCompoundInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) public pure virtual override returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit\\n    ) {\\n        (rcomp, ri, Tcrit,) = calculateCompoundInterestRateWithOverflowDetection(\\n            _c,\\n            _totalDeposits,\\n            _totalBorrowAmount,\\n            _interestRateTimestamp,\\n            _blockTimestamp\\n        );\\n    }\\n\\n    /// @inheritdoc IInterestRateModel\\n    function calculateCompoundInterestRateWithOverflowDetection(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) public pure virtual override returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit,\\n        bool overflow\\n    ) {\\n        ri = _c.ri;\\n        Tcrit = _c.Tcrit;\\n\\n        // struct for local vars to avoid \\\"Stack too deep\\\"\\n        LocalVarsRComp memory _l = LocalVarsRComp(0,0,0,0,0,0,0,0,0,0);\\n\\n        if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();\\n\\n        // There can't be an underflow in the subtraction because of the previous check\\n    unchecked {\\n        // length of time period in seconds\\n        _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();\\n    }\\n\\n        int256 _DP = int256(DP);\\n\\n        _l.u = EasyMathV2.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();\\n\\n        // slopei := ki * (u0 - uopt )\\n        _l.slopei = _c.ki * (_l.u - _c.uopt) / _DP;\\n\\n        if (_l.u > _c.ucrit) {\\n            // rp := kcrit * (1 + Tcrit) * (u0 - ucrit )\\n            _l.rp = _c.kcrit * (_DP + Tcrit) / _DP * (_l.u - _c.ucrit) / _DP;\\n            // slope := slopei + kcrit * beta * (u0 - ucrit )\\n            _l.slope = _l.slopei + _c.kcrit * _c.beta / _DP * (_l.u - _c.ucrit) / _DP;\\n            // Tcrit := Tcrit + beta * T\\n            Tcrit = Tcrit + _c.beta * _l.T;\\n        } else {\\n            // rp := min (0, klow * (u0 - ulow ))\\n            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _DP);\\n            // slope := slopei\\n            _l.slope = _l.slopei;\\n            // Tcrit := max (0, Tcrit - beta * T)\\n            Tcrit = _max(0, Tcrit - _c.beta * _l.T);\\n        }\\n\\n        // rlin := klin * u0 # lower bound between t0 and t1\\n        _l.rlin = _c.klin * _l.u / _DP;\\n        // ri := max(ri , rlin )\\n        ri = _max(ri , _l.rlin);\\n        // r0 := ri + rp # interest rate at t0 ignoring lower bound\\n        _l.r0 = ri + _l.rp;\\n        // r1 := r0 + slope *T # what interest rate would be at t1 ignoring lower bound\\n        _l.r1 = _l.r0 + _l.slope * _l.T;\\n\\n        // Calculating the compound interest\\n\\n        if (_l.r0 >= _l.rlin && _l.r1 >= _l.rlin) {\\n            // lower bound isn\u2019t activated\\n            // rcomp := exp (( r0 + r1) * T / 2) - 1\\n            _l.x = (_l.r0 + _l.r1) * _l.T / 2;\\n        } else if (_l.r0 < _l.rlin && _l.r1 < _l.rlin) {\\n            // lower bound is active during the whole time\\n            // rcomp := exp( rlin * T) - 1\\n            _l.x = _l.rlin * _l.T;\\n        } else if (_l.r0 >= _l.rlin && _l.r1 < _l.rlin) {\\n            // lower bound is active after some time\\n            // rcomp := exp( rlin *T - (r0 - rlin )^2/ slope /2) - 1\\n            _l.x = _l.rlin * _l.T - (_l.r0 - _l.rlin)**2 / _l.slope / 2;\\n        } else {\\n            // lower bound is active before some time\\n            // rcomp := exp( rlin *T + (r1 - rlin )^2/ slope /2) - 1\\n            _l.x = _l.rlin * _l.T + (_l.r1 - _l.rlin)**2 / _l.slope / 2;\\n        }\\n\\n        // ri := max(ri + slopei * T, rlin )\\n        ri = _max(ri + _l.slopei * _l.T, _l.rlin);\\n\\n        // Checking for the overflow below. In case of the overflow, ri and Tcrit will be set back to zeros. Rcomp is\\n        // calculated to not make an overflow in totalBorrowedAmount, totalDeposits.\\n        (rcomp, overflow) = _calculateRComp(_totalDeposits, _totalBorrowAmount, _l.x);\\n\\n        if (overflow) {\\n            ri = 0;\\n            Tcrit = 0;\\n        }\\n    }\\n\\n    /// @dev set config for silo and asset\\n    function _setConfig(address _silo, address _asset, Config memory _config) internal virtual {\\n        int256 _DP = int256(DP);\\n\\n        if (_config.uopt <= 0 || _config.uopt >= _DP) revert InvalidUopt();\\n        if (_config.ucrit <= _config.uopt || _config.ucrit >= _DP) revert InvalidUcrit();\\n        if (_config.ulow <= 0 || _config.ulow >= _config.uopt) revert InvalidUlow();\\n        if (_config.ki < 0) revert InvalidKi();\\n        if (_config.kcrit < 0) revert InvalidKcrit();\\n        if (_config.klow < 0) revert InvalidKlow();\\n        if (_config.klin < 0) revert InvalidKlin();\\n        if (_config.beta < 0) revert InvalidBeta();\\n        if (_config.ri < 0) revert InvalidRi();\\n        if (_config.Tcrit < 0) revert InvalidTcrit();\\n\\n        config[_silo][_asset] = _config;\\n        emit ConfigUpdate(_silo, _asset, _config);\\n    }\\n\\n    /* solhint-enable */\\n\\n    /// @dev checks for the overflow in rcomp calculations, accruedInterest, totalDeposits and totalBorrowedAmount.\\n    /// In case of the overflow, rcomp is reduced to make totalDeposits and totalBorrowedAmount <= 2**196.\\n    function _calculateRComp(\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        int256 _x\\n    ) internal pure virtual returns (uint256 rcomp, bool overflow) {\\n        int256 rcompSigned;\\n\\n        if (_x >= X_MAX) {\\n            rcomp = RCOMP_MAX;\\n            // overflow, but not return now. It counts as an overflow to reset model parameters,\\n            // but later on we can get overflow worse.\\n            overflow = true;\\n        } else {\\n            rcompSigned = _x.exp() - int256(DP);\\n            rcomp = rcompSigned > 0 ? rcompSigned.toUint256() : 0;\\n        }\\n\\n        unchecked {\\n            // maxAmount = max(_totalDeposits, _totalBorrowAmount) to see\\n            // if any of this variables overflow in result.\\n            uint256 maxAmount = _totalDeposits > _totalBorrowAmount ? _totalDeposits : _totalBorrowAmount;\\n\\n            if (maxAmount >= ASSET_DATA_OVERFLOW_LIMIT) {\\n                return (0, true);\\n            }\\n\\n            uint256 rcompMulTBA = rcomp * _totalBorrowAmount;\\n\\n            if (rcompMulTBA == 0) {\\n                return (rcomp, overflow);\\n            }\\n\\n            if (\\n                rcompMulTBA / rcomp != _totalBorrowAmount ||\\n                rcompMulTBA / DP > ASSET_DATA_OVERFLOW_LIMIT - maxAmount\\n            ) {\\n                rcomp = (ASSET_DATA_OVERFLOW_LIMIT - maxAmount) * DP / _totalBorrowAmount;\\n\\n                return (rcomp, true);\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the largest of two numbers\\n    function _max(int256 a, int256 b) internal pure virtual returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /// @dev Returns the smallest of two numbers\\n    function _min(int256 a, int256 b) internal pure virtual returns (int256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseSilo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IShareToken.sol\\\";\\nimport \\\"./IFlashLiquidationReceiver.sol\\\";\\nimport \\\"./ISiloRepository.sol\\\";\\n\\ninterface IBaseSilo {\\n    enum AssetStatus { Undefined, Active, Removed }\\n\\n    /// @dev Storage struct that holds all required data for a single token market\\n    struct AssetStorage {\\n        /// @dev Token that represents a share in totalDeposits of Silo\\n        IShareToken collateralToken;\\n        /// @dev Token that represents a share in collateralOnlyDeposits of Silo\\n        IShareToken collateralOnlyToken;\\n        /// @dev Token that represents a share in totalBorrowAmount of Silo\\n        IShareToken debtToken;\\n        /// @dev COLLATERAL: Amount of asset token that has been deposited to Silo with interest earned by depositors.\\n        /// It also includes token amount that has been borrowed.\\n        uint256 totalDeposits;\\n        /// @dev COLLATERAL ONLY: Amount of asset token that has been deposited to Silo that can be ONLY used\\n        /// as collateral. These deposits do NOT earn interest and CANNOT be borrowed.\\n        uint256 collateralOnlyDeposits;\\n        /// @dev DEBT: Amount of asset token that has been borrowed with accrued interest.\\n        uint256 totalBorrowAmount;\\n    }\\n\\n    /// @dev Storage struct that holds data related to fees and interest\\n    struct AssetInterestData {\\n        /// @dev Total amount of already harvested protocol fees\\n        uint256 harvestedProtocolFees;\\n        /// @dev Total amount (ever growing) of asset token that has been earned by the protocol from\\n        /// generated interest.\\n        uint256 protocolFees;\\n        /// @dev Timestamp of the last time `interestRate` has been updated in storage.\\n        uint64 interestRateTimestamp;\\n        /// @dev True if asset was removed from the protocol. If so, deposit and borrow functions are disabled\\n        /// for that asset\\n        AssetStatus status;\\n    }\\n\\n    /// @notice data that InterestModel needs for calculations\\n    struct UtilizationData {\\n        uint256 totalDeposits;\\n        uint256 totalBorrowAmount;\\n        /// @dev timestamp of last interest accrual\\n        uint64 interestRateTimestamp;\\n    }\\n\\n    /// @dev Shares names and symbols that are generated while asset initialization\\n    struct AssetSharesMetadata {\\n        /// @dev Name for the collateral shares token\\n        string collateralName;\\n        /// @dev Symbol for the collateral shares token\\n        string collateralSymbol;\\n        /// @dev Name for the collateral only (protected collateral) shares token\\n        string protectedName;\\n        /// @dev Symbol for the collateral only (protected collateral) shares token\\n        string protectedSymbol;\\n        /// @dev Name for the debt shares token\\n        string debtName;\\n        /// @dev Symbol for the debt shares token\\n        string debtSymbol;\\n    }\\n\\n    /// @notice Emitted when deposit is made\\n    /// @param asset asset address that was deposited\\n    /// @param depositor wallet address that deposited asset\\n    /// @param amount amount of asset that was deposited\\n    /// @param collateralOnly type of deposit, true if collateralOnly deposit was used\\n    event Deposit(address indexed asset, address indexed depositor, uint256 amount, bool collateralOnly);\\n\\n    /// @notice Emitted when withdraw is made\\n    /// @param asset asset address that was withdrawn\\n    /// @param depositor wallet address that deposited asset\\n    /// @param receiver wallet address that received asset\\n    /// @param amount amount of asset that was withdrew\\n    /// @param collateralOnly type of withdraw, true if collateralOnly deposit was used\\n    event Withdraw(\\n        address indexed asset,\\n        address indexed depositor,\\n        address indexed receiver,\\n        uint256 amount,\\n        bool collateralOnly\\n    );\\n\\n    /// @notice Emitted on asset borrow\\n    /// @param asset asset address that was borrowed\\n    /// @param user wallet address that borrowed asset\\n    /// @param amount amount of asset that was borrowed\\n    event Borrow(address indexed asset, address indexed user, uint256 amount);\\n\\n    /// @notice Emitted on asset repay\\n    /// @param asset asset address that was repaid\\n    /// @param user wallet address that repaid asset\\n    /// @param amount amount of asset that was repaid\\n    event Repay(address indexed asset, address indexed user, uint256 amount);\\n\\n    /// @notice Emitted on user liquidation\\n    /// @param asset asset address that was liquidated\\n    /// @param user wallet address that was liquidated\\n    /// @param shareAmountRepaid amount of collateral-share token that was repaid. This is collateral token representing\\n    /// ownership of underlying deposit.\\n    /// @param seizedCollateral amount of underlying token that was seized by liquidator\\n    event Liquidate(address indexed asset, address indexed user, uint256 shareAmountRepaid, uint256 seizedCollateral);\\n\\n    /// @notice Emitted when the status for an asset is updated\\n    /// @param asset asset address that was updated\\n    /// @param status new asset status\\n    event AssetStatusUpdate(address indexed asset, AssetStatus indexed status);\\n\\n    /// @return version of the silo contract\\n    function VERSION() external returns (uint128); // solhint-disable-line func-name-mixedcase\\n\\n    /// @notice Synchronize current bridge assets with Silo\\n    /// @dev This function needs to be called on Silo deployment to setup all assets for Silo. It needs to be\\n    /// called every time a bridged asset is added or removed. When bridge asset is removed, depositing and borrowing\\n    /// should be disabled during asset sync.\\n    function syncBridgeAssets() external;\\n\\n    /// @notice Get Silo Repository contract address\\n    /// @return Silo Repository contract address\\n    function siloRepository() external view returns (ISiloRepository);\\n\\n    /// @notice Get asset storage data\\n    /// @param _asset asset address\\n    /// @return AssetStorage struct\\n    function assetStorage(address _asset) external view returns (AssetStorage memory);\\n\\n    /// @notice Get asset interest data\\n    /// @param _asset asset address\\n    /// @return AssetInterestData struct\\n    function interestData(address _asset) external view returns (AssetInterestData memory);\\n\\n    /// @dev helper method for InterestRateModel calculations\\n    function utilizationData(address _asset) external view returns (UtilizationData memory data);\\n\\n    /// @notice Calculates solvency of an account\\n    /// @param _user wallet address for which solvency is calculated\\n    /// @return true if solvent, false otherwise\\n    function isSolvent(address _user) external view returns (bool);\\n\\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\\n    /// @return assets array of initialized assets of Silo\\n    function getAssets() external view returns (address[] memory assets);\\n\\n    /// @notice Returns all initialized (synced) assets of Silo including current and removed bridge assets\\n    /// with corresponding state\\n    /// @return assets array of initialized assets of Silo\\n    /// @return assetsStorage array of assets state corresponding to `assets` array\\n    function getAssetsWithState() external view returns (address[] memory assets, AssetStorage[] memory assetsStorage);\\n\\n    /// @notice Check if depositing an asset for given account is possible\\n    /// @dev Depositing an asset that has been already borrowed (and vice versa) is disallowed\\n    /// @param _asset asset we want to deposit\\n    /// @param _depositor depositor address\\n    /// @return true if asset can be deposited by depositor\\n    function depositPossible(address _asset, address _depositor) external view returns (bool);\\n\\n    /// @notice Check if borrowing an asset for given account is possible\\n    /// @dev Borrowing an asset that has been already deposited (and vice versa) is disallowed\\n    /// @param _asset asset we want to deposit\\n    /// @param _borrower borrower address\\n    /// @return true if asset can be borrowed by borrower\\n    function borrowPossible(address _asset, address _borrower) external view returns (bool);\\n\\n    /// @dev Amount of token that is available for borrowing\\n    /// @param _asset asset to get liquidity for\\n    /// @return Silo liquidity\\n    function liquidity(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLiquidationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/// @dev when performing Silo flash liquidation, FlashReceiver contract will receive all collaterals\\ninterface IFlashLiquidationReceiver {\\n    /// @dev this method is called when doing Silo flash liquidation\\n    ///         one can NOT assume, that if _seizedCollateral[i] != 0, then _shareAmountsToRepaid[i] must be 0\\n    ///         one should assume, that any combination of amounts is possible\\n    ///         on callback, one must call `Silo.repayFor` because at the end of transaction,\\n    ///         Silo will check if borrower is solvent.\\n    /// @param _user user address, that is liquidated\\n    /// @param _assets array of collateral assets received during user liquidation\\n    ///         this array contains all assets (collateral borrowed) without any order\\n    /// @param _receivedCollaterals array of collateral amounts received during user liquidation\\n    ///         indexes of amounts are related to `_assets`,\\n    /// @param _shareAmountsToRepaid array of amounts to repay for each asset\\n    ///         indexes of amounts are related to `_assets`,\\n    /// @param _flashReceiverData data that are passed from sender that executes liquidation\\n    function siloLiquidationCallback(\\n        address _user,\\n        address[] calldata _assets,\\n        uint256[] calldata _receivedCollaterals,\\n        uint256[] calldata _shareAmountsToRepaid,\\n        bytes memory _flashReceiverData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\ninterface IInterestRateModel {\\n    /* solhint-disable */\\n    struct Config {\\n        // uopt \u2208 (0, 1) \u2013 optimal utilization;\\n        int256 uopt;\\n        // ucrit \u2208 (uopt, 1) \u2013 threshold of large utilization;\\n        int256 ucrit;\\n        // ulow \u2208 (0, uopt) \u2013 threshold of low utilization\\n        int256 ulow;\\n        // ki > 0 \u2013 integrator gain\\n        int256 ki;\\n        // kcrit > 0 \u2013 proportional gain for large utilization\\n        int256 kcrit;\\n        // klow \u2265 0 \u2013 proportional gain for low utilization\\n        int256 klow;\\n        // klin \u2265 0 \u2013 coefficient of the lower linear bound\\n        int256 klin;\\n        // beta \u2265 0 - a scaling factor\\n        int256 beta;\\n        // ri \u2265 0 \u2013 initial value of the integrator\\n        int256 ri;\\n        // Tcrit \u2265 0 - the time during which the utilization exceeds the critical value\\n        int256 Tcrit;\\n    }\\n    /* solhint-enable */\\n\\n    /// @dev Set dedicated config for given asset in a Silo. Config is per asset per Silo so different assets\\n    /// in different Silo can have different configs.\\n    /// It will try to call `_silo.accrueInterest(_asset)` before updating config, but it is not guaranteed,\\n    /// that this call will be successful, if it fail config will be set anyway.\\n    /// @param _silo Silo address for which config should be set\\n    /// @param _asset asset address for which config should be set\\n    function setConfig(address _silo, address _asset, Config calldata _config) external;\\n\\n    /// @dev get compound interest rate and update model storage\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    function getCompoundInterestRateAndUpdate(\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external returns (uint256 rcomp);\\n\\n    /// @dev Get config for given asset in a Silo. If dedicated config is not set, default one will be returned.\\n    /// @param _silo Silo address for which config should be set\\n    /// @param _asset asset address for which config should be set\\n    /// @return Config struct for asset in Silo\\n    function getConfig(address _silo, address _asset) external view returns (Config memory);\\n\\n    /// @dev get compound interest rate\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    function getCompoundInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (uint256 rcomp);\\n\\n    /// @dev get current annual interest rate\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset in Silo for which interest rate should be calculated\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcur current annual interest rate (1e18 == 100%)\\n    function getCurrentInterestRate(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (uint256 rcur);\\n\\n    /// @notice get the flag to detect rcomp restriction (zero current interest) due to overflow\\n    /// overflow boolean flag to detect rcomp restriction\\n    function overflowDetected(\\n        address _silo,\\n        address _asset,\\n        uint256 _blockTimestamp\\n    ) external view returns (bool overflow);\\n\\n    /// @dev pure function that calculates current annual interest rate\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcur current annual interest rate (1e18 == 100%)\\n    function calculateCurrentInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (uint256 rcur);\\n\\n    /// @dev pure function that calculates interest rate based on raw input data\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    /// @return ri current integral part of the rate\\n    /// @return Tcrit time during which the utilization exceeds the critical value\\n    /// @return overflow boolean flag to detect rcomp restriction\\n    function calculateCompoundInterestRateWithOverflowDetection(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit, // solhint-disable-line var-name-mixedcase\\n        bool overflow\\n    );\\n\\n    /// @dev pure function that calculates interest rate based on raw input data\\n    /// @param _c configuration object, InterestRateModel.Config\\n    /// @param _totalBorrowAmount current total borrows for asset\\n    /// @param _totalDeposits current total deposits for asset\\n    /// @param _interestRateTimestamp timestamp of last interest rate update\\n    /// @param _blockTimestamp current block timestamp\\n    /// @return rcomp compounded interest rate from last update until now (1e18 == 100%)\\n    /// @return ri current integral part of the rate\\n    /// @return Tcrit time during which the utilization exceeds the critical value\\n    function calculateCompoundInterestRate(\\n        Config memory _c,\\n        uint256 _totalDeposits,\\n        uint256 _totalBorrowAmount,\\n        uint256 _interestRateTimestamp,\\n        uint256 _blockTimestamp\\n    ) external pure returns (\\n        uint256 rcomp,\\n        int256 ri,\\n        int256 Tcrit // solhint-disable-line var-name-mixedcase\\n    );\\n\\n    /// @dev returns decimal points used by model\\n    function DP() external pure returns (uint256); // solhint-disable-line func-name-mixedcase\\n\\n    /// @dev just a helper method to see if address is a InterestRateModel\\n    /// @return always true\\n    function interestRateModelPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INotificationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\n/// @title Common interface for Silo Incentive Contract\\ninterface INotificationReceiver {\\n    /// @dev Informs the contract about token transfer\\n    /// @param _token address of the token that was transferred\\n    /// @param _from sender\\n    /// @param _to receiver\\n    /// @param _amount amount that was transferred\\n    function onAfterTransfer(address _token, address _from, address _to, uint256 _amount) external;\\n\\n    /// @dev Sanity check function\\n    /// @return always true\\n    function notificationReceiverPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title Common interface for Silo Price Providers\\ninterface IPriceProvider {\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset. Calculates TWAP price for quote/asset.\\n    /// It unifies all tokens decimal to 18, examples:\\n    /// - if asses == quote it returns 1e18\\n    /// - if asset is USDC and quote is ETH and ETH costs ~$3300 then it returns ~0.0003e18 WETH per 1 USDC\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price of asses with 18 decimals, throws when pool is not ready yet to provide price\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @dev Informs if PriceProvider is setup for asset. It does not means PriceProvider can provide price right away.\\n    /// Some providers implementations need time to \\\"build\\\" buffer for TWAP price,\\n    /// so price may not be available yet but this method will return true.\\n    /// @param _asset asset in question\\n    /// @return TRUE if asset has been setup, otherwise false\\n    function assetSupported(address _asset) external view returns (bool);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Helper method that allows easily detects, if contract is PriceProvider\\n    /// @dev this can save us from simple human errors, in case we use invalid address\\n    /// but this should NOT be treated as security check\\n    /// @return always true\\n    function priceProviderPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceProvidersRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport \\\"./IPriceProvider.sol\\\";\\n\\ninterface IPriceProvidersRepository {\\n    /// @notice Emitted when price provider is added\\n    /// @param newPriceProvider new price provider address\\n    event NewPriceProvider(IPriceProvider indexed newPriceProvider);\\n\\n    /// @notice Emitted when price provider is removed\\n    /// @param priceProvider removed price provider address\\n    event PriceProviderRemoved(IPriceProvider indexed priceProvider);\\n\\n    /// @notice Emitted when asset is assigned to price provider\\n    /// @param asset assigned asset   address\\n    /// @param priceProvider price provider address\\n    event PriceProviderForAsset(address indexed asset, IPriceProvider indexed priceProvider);\\n\\n    /// @notice Register new price provider\\n    /// @param _priceProvider address of price provider\\n    function addPriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Unregister price provider\\n    /// @param _priceProvider address of price provider to be removed\\n    function removePriceProvider(IPriceProvider _priceProvider) external;\\n\\n    /// @notice Sets price provider for asset\\n    /// @dev Request for asset price is forwarded to the price provider assigned to that asset\\n    /// @param _asset address of an asset for which price provider will be used\\n    /// @param _priceProvider address of price provider\\n    function setPriceProviderForAsset(address _asset, IPriceProvider _priceProvider) external;\\n\\n    /// @notice Returns \\\"Time-Weighted Average Price\\\" for an asset\\n    /// @param _asset address of an asset for which to read price\\n    /// @return price TWAP price of a token with 18 decimals\\n    function getPrice(address _asset) external view returns (uint256 price);\\n\\n    /// @notice Gets price provider assigned to an asset\\n    /// @param _asset address of an asset for which to get price provider\\n    /// @return priceProvider address of price provider\\n    function priceProviders(address _asset) external view returns (IPriceProvider priceProvider);\\n\\n    /// @notice Gets token address in which prices are quoted\\n    /// @return quoteToken address\\n    function quoteToken() external view returns (address);\\n\\n    /// @notice Gets manager role address\\n    /// @return manager role address\\n    function manager() external view returns (address);\\n\\n    /// @notice Checks if providers are available for an asset\\n    /// @param _asset asset address to check\\n    /// @return returns TRUE if price feed is ready, otherwise false\\n    function providersReadyForAsset(address _asset) external view returns (bool);\\n\\n    /// @notice Returns true if address is a registered price provider\\n    /// @param _provider address of price provider to be removed\\n    /// @return true if address is a registered price provider, otherwise false\\n    function isPriceProvider(IPriceProvider _provider) external view returns (bool);\\n\\n    /// @notice Gets number of price providers registered\\n    /// @return number of price providers registered\\n    function providersCount() external view returns (uint256);\\n\\n    /// @notice Gets an array of price providers\\n    /// @return array of price providers\\n    function providerList() external view returns (address[] memory);\\n\\n    /// @notice Sanity check function\\n    /// @return returns always TRUE\\n    function priceProvidersRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShareToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"./INotificationReceiver.sol\\\";\\n\\ninterface IShareToken is IERC20Metadata {\\n    /// @notice Emitted every time receiver is notified about token transfer\\n    /// @param notificationReceiver receiver address\\n    /// @param success false if TX reverted on `notificationReceiver` side, otherwise true\\n    event NotificationSent(\\n        INotificationReceiver indexed notificationReceiver,\\n        bool success\\n    );\\n\\n    /// @notice Mint method for Silo to create debt position\\n    /// @param _account wallet for which to mint token\\n    /// @param _amount amount of token to be minted\\n    function mint(address _account, uint256 _amount) external;\\n\\n    /// @notice Burn method for Silo to close debt position\\n    /// @param _account wallet for which to burn token\\n    /// @param _amount amount of token to be burned\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISilo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IBaseSilo.sol\\\";\\n\\ninterface ISilo is IBaseSilo {\\n    /// @notice Deposit `_amount` of `_asset` tokens from `msg.sender` to the Silo\\n    /// @param _asset The address of the token to deposit\\n    /// @param _amount The amount of the token to deposit\\n    /// @param _collateralOnly True if depositing collateral only\\n    /// @return collateralAmount deposited amount\\n    /// @return collateralShare user collateral shares based on deposited amount\\n    function deposit(address _asset, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 collateralAmount, uint256 collateralShare);\\n\\n    /// @notice Router function to deposit `_amount` of `_asset` tokens to the Silo for the `_depositor`\\n    /// @param _asset The address of the token to deposit\\n    /// @param _depositor The address of the recipient of collateral tokens\\n    /// @param _amount The amount of the token to deposit\\n    /// @param _collateralOnly True if depositing collateral only\\n    /// @return collateralAmount deposited amount\\n    /// @return collateralShare `_depositor` collateral shares based on deposited amount\\n    function depositFor(address _asset, address _depositor, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 collateralAmount, uint256 collateralShare);\\n\\n    /// @notice Withdraw `_amount` of `_asset` tokens from the Silo to `msg.sender`\\n    /// @param _asset The address of the token to withdraw\\n    /// @param _amount The amount of the token to withdraw\\n    /// @param _collateralOnly True if withdrawing collateral only deposit\\n    /// @return withdrawnAmount withdrawn amount that was transferred to user\\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\\n    function withdraw(address _asset, uint256 _amount, bool _collateralOnly)\\n        external\\n        returns (uint256 withdrawnAmount, uint256 withdrawnShare);\\n\\n    /// @notice Router function to withdraw `_amount` of `_asset` tokens from the Silo for the `_depositor`\\n    /// @param _asset The address of the token to withdraw\\n    /// @param _depositor The address that originally deposited the collateral tokens being withdrawn,\\n    /// it should be the one initiating the withdrawal through the router\\n    /// @param _receiver The address that will receive the withdrawn tokens\\n    /// @param _amount The amount of the token to withdraw\\n    /// @param _collateralOnly True if withdrawing collateral only deposit\\n    /// @return withdrawnAmount withdrawn amount that was transferred to `_receiver`\\n    /// @return withdrawnShare burned share based on `withdrawnAmount`\\n    function withdrawFor(\\n        address _asset,\\n        address _depositor,\\n        address _receiver,\\n        uint256 _amount,\\n        bool _collateralOnly\\n    ) external returns (uint256 withdrawnAmount, uint256 withdrawnShare);\\n\\n    /// @notice Borrow `_amount` of `_asset` tokens from the Silo to `msg.sender`\\n    /// @param _asset The address of the token to borrow\\n    /// @param _amount The amount of the token to borrow\\n    /// @return debtAmount borrowed amount\\n    /// @return debtShare user debt share based on borrowed amount\\n    function borrow(address _asset, uint256 _amount) external returns (uint256 debtAmount, uint256 debtShare);\\n\\n    /// @notice Router function to borrow `_amount` of `_asset` tokens from the Silo for the `_receiver`\\n    /// @param _asset The address of the token to borrow\\n    /// @param _borrower The address that will take the loan,\\n    /// it should be the one initiating the borrowing through the router\\n    /// @param _receiver The address of the asset receiver\\n    /// @param _amount The amount of the token to borrow\\n    /// @return debtAmount borrowed amount\\n    /// @return debtShare `_receiver` debt share based on borrowed amount\\n    function borrowFor(address _asset, address _borrower, address _receiver, uint256 _amount)\\n        external\\n        returns (uint256 debtAmount, uint256 debtShare);\\n\\n    /// @notice Repay `_amount` of `_asset` tokens from `msg.sender` to the Silo\\n    /// @param _asset The address of the token to repay\\n    /// @param _amount amount of asset to repay, includes interests\\n    /// @return repaidAmount amount repaid\\n    /// @return burnedShare burned debt share\\n    function repay(address _asset, uint256 _amount) external returns (uint256 repaidAmount, uint256 burnedShare);\\n\\n    /// @notice Allows to repay in behalf of borrower to execute liquidation\\n    /// @param _asset The address of the token to repay\\n    /// @param _borrower The address of the user to have debt tokens burned\\n    /// @param _amount amount of asset to repay, includes interests\\n    /// @return repaidAmount amount repaid\\n    /// @return burnedShare burned debt share\\n    function repayFor(address _asset, address _borrower, uint256 _amount)\\n        external\\n        returns (uint256 repaidAmount, uint256 burnedShare);\\n\\n    /// @dev harvest protocol fees from an array of assets\\n    /// @return harvestedAmounts amount harvested during tx execution for each of silo asset\\n    function harvestProtocolFees() external returns (uint256[] memory harvestedAmounts);\\n\\n    /// @notice Function to update interests for `_asset` token since the last saved state\\n    /// @param _asset The address of the token to be updated\\n    /// @return interest accrued interest\\n    function accrueInterest(address _asset) external returns (uint256 interest);\\n\\n    /// @notice this methods does not requires to have tokens in order to liquidate user\\n    /// @dev during liquidation process, msg.sender will be notified once all collateral will be send to him\\n    /// msg.sender needs to be `IFlashLiquidationReceiver`\\n    /// @param _users array of users to liquidate\\n    /// @param _flashReceiverData this data will be forward to msg.sender on notification\\n    /// @return assets array of all processed assets (collateral + debt, including removed)\\n    /// @return receivedCollaterals receivedCollaterals[userId][assetId] => amount\\n    /// amounts of collaterals send to `_flashReceiver`\\n    /// @return shareAmountsToRepaid shareAmountsToRepaid[userId][assetId] => amount\\n    /// required amounts of debt to be repaid\\n    function flashLiquidate(address[] memory _users, bytes memory _flashReceiverData)\\n        external\\n        returns (\\n            address[] memory assets,\\n            uint256[][] memory receivedCollaterals,\\n            uint256[][] memory shareAmountsToRepaid\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISiloFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\ninterface ISiloFactory {\\n    /// @notice Emitted when Silo is deployed\\n    /// @param silo address of deployed Silo\\n    /// @param asset address of asset for which Silo was deployed\\n    /// @param version version of silo implementation\\n    event NewSiloCreated(address indexed silo, address indexed asset, uint128 version);\\n\\n    /// @notice Must be called by repository on constructor\\n    /// @param _siloRepository the SiloRepository to set\\n    function initRepository(address _siloRepository) external;\\n\\n    /// @notice Deploys Silo\\n    /// @param _siloAsset unique asset for which Silo is deployed\\n    /// @param _version version of silo implementation\\n    /// @param _data (optional) data that may be needed during silo creation\\n    /// @return silo deployed Silo address\\n    function createSilo(address _siloAsset, uint128 _version, bytes memory _data) external returns (address silo);\\n\\n    /// @dev just a helper method to see if address is a factory\\n    function siloFactoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISiloRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./ISiloFactory.sol\\\";\\nimport \\\"./ITokensFactory.sol\\\";\\nimport \\\"./IPriceProvidersRepository.sol\\\";\\nimport \\\"./INotificationReceiver.sol\\\";\\nimport \\\"./IInterestRateModel.sol\\\";\\n\\ninterface ISiloRepository {\\n    /// @dev protocol fees in precision points (Solvency._PRECISION_DECIMALS), we do allow for fee == 0\\n    struct Fees {\\n        /// @dev One time protocol fee for opening a borrow position in precision points (Solvency._PRECISION_DECIMALS)\\n        uint64 entryFee;\\n        /// @dev Protocol revenue share in interest paid in precision points (Solvency._PRECISION_DECIMALS)\\n        uint64 protocolShareFee;\\n        /// @dev Protocol share in liquidation profit in precision points (Solvency._PRECISION_DECIMALS).\\n        /// It's calculated from total collateral amount to be transferred to liquidator.\\n        uint64 protocolLiquidationFee;\\n    }\\n\\n    struct SiloVersion {\\n        /// @dev Default version of Silo. If set to 0, it means it is not set. By default it is set to 1\\n        uint128 byDefault;\\n\\n        /// @dev Latest added version of Silo. If set to 0, it means it is not set. By default it is set to 1\\n        uint128 latest;\\n    }\\n\\n    /// @dev AssetConfig struct represents configurable parameters for each Silo\\n    struct AssetConfig {\\n        /// @dev Loan-to-Value ratio represents the maximum borrowing power of a specific collateral.\\n        ///      For example, if the collateral asset has an LTV of 75%, the user can borrow up to 0.75 worth\\n        ///      of quote token in the principal currency for every quote token worth of collateral.\\n        ///      value uses 18 decimals eg. 100% == 1e18\\n        ///      max valid value is 1e18 so it needs storage of 60 bits\\n        uint64 maxLoanToValue;\\n\\n        /// @dev Liquidation Threshold represents the threshold at which a borrow position will be considered\\n        ///      undercollateralized and subject to liquidation for each collateral. For example,\\n        ///      if a collateral has a liquidation threshold of 80%, it means that the loan will be\\n        ///      liquidated when the borrowAmount value is worth 80% of the collateral value.\\n        ///      value uses 18 decimals eg. 100% == 1e18\\n        uint64 liquidationThreshold;\\n\\n        /// @dev interest rate model address\\n        IInterestRateModel interestRateModel;\\n    }\\n\\n    event NewDefaultMaximumLTV(uint64 defaultMaximumLTV);\\n\\n    event NewDefaultLiquidationThreshold(uint64 defaultLiquidationThreshold);\\n\\n    /// @notice Emitted on new Silo creation\\n    /// @param silo deployed Silo address\\n    /// @param asset unique asset for deployed Silo\\n    /// @param siloVersion version of deployed Silo\\n    event NewSilo(address indexed silo, address indexed asset, uint128 siloVersion);\\n\\n    /// @notice Emitted when new Silo (or existing one) becomes a bridge pool (pool with only bridge tokens).\\n    /// @param pool address of the bridge pool, It can be zero address when bridge asset is removed and pool no longer\\n    /// is treated as bridge pool\\n    event BridgePool(address indexed pool);\\n\\n    /// @notice Emitted on new bridge asset\\n    /// @param newBridgeAsset address of added bridge asset\\n    event BridgeAssetAdded(address indexed newBridgeAsset);\\n\\n    /// @notice Emitted on removed bridge asset\\n    /// @param bridgeAssetRemoved address of removed bridge asset\\n    event BridgeAssetRemoved(address indexed bridgeAssetRemoved);\\n\\n    /// @notice Emitted when default interest rate model is changed\\n    /// @param newModel address of new interest rate model\\n    event InterestRateModel(IInterestRateModel indexed newModel);\\n\\n    /// @notice Emitted on price provider repository address update\\n    /// @param newProvider address of new oracle repository\\n    event PriceProvidersRepositoryUpdate(\\n        IPriceProvidersRepository indexed newProvider\\n    );\\n\\n    /// @notice Emitted on token factory address update\\n    /// @param newTokensFactory address of new token factory\\n    event TokensFactoryUpdate(address indexed newTokensFactory);\\n\\n    /// @notice Emitted on router address update\\n    /// @param newRouter address of new router\\n    event RouterUpdate(address indexed newRouter);\\n\\n    /// @notice Emitted on INotificationReceiver address update\\n    /// @param newIncentiveContract address of new INotificationReceiver\\n    event NotificationReceiverUpdate(INotificationReceiver indexed newIncentiveContract);\\n\\n    /// @notice Emitted when new Silo version is registered\\n    /// @param factory factory address that deploys registered Silo version\\n    /// @param siloLatestVersion Silo version of registered Silo\\n    /// @param siloDefaultVersion current default Silo version\\n    event RegisterSiloVersion(address indexed factory, uint128 siloLatestVersion, uint128 siloDefaultVersion);\\n\\n    /// @notice Emitted when Silo version is unregistered\\n    /// @param factory factory address that deploys unregistered Silo version\\n    /// @param siloVersion version that was unregistered\\n    event UnregisterSiloVersion(address indexed factory, uint128 siloVersion);\\n\\n    /// @notice Emitted when default Silo version is updated\\n    /// @param newDefaultVersion new default version\\n    event SiloDefaultVersion(uint128 newDefaultVersion);\\n\\n    /// @notice Emitted when default fee is updated\\n    /// @param newEntryFee new entry fee\\n    /// @param newProtocolShareFee new protocol share fee\\n    /// @param newProtocolLiquidationFee new protocol liquidation fee\\n    event FeeUpdate(\\n        uint64 newEntryFee,\\n        uint64 newProtocolShareFee,\\n        uint64 newProtocolLiquidationFee\\n    );\\n\\n    /// @notice Emitted when asset config is updated for a silo\\n    /// @param silo silo for which asset config is being set\\n    /// @param asset asset for which asset config is being set\\n    /// @param assetConfig new asset config\\n    event AssetConfigUpdate(address indexed silo, address indexed asset, AssetConfig assetConfig);\\n\\n    /// @notice Emitted when silo (silo factory) version is set for asset\\n    /// @param asset asset for which asset config is being set\\n    /// @param version Silo version\\n    event VersionForAsset(address indexed asset, uint128 version);\\n\\n    /// @param _siloAsset silo asset\\n    /// @return version of Silo that is assigned for provided asset, if not assigned it returns zero (default)\\n    function getVersionForAsset(address _siloAsset) external returns (uint128);\\n\\n    /// @notice setter for `getVersionForAsset` mapping\\n    /// @param _siloAsset silo asset\\n    /// @param _version version of Silo that will be assigned for `_siloAsset`, zero (default) is acceptable\\n    function setVersionForAsset(address _siloAsset, uint128 _version) external;\\n\\n    /// @notice use this method only when off-chain verification is OFF\\n    /// @dev Silo does NOT support rebase and deflationary tokens\\n    /// @param _siloAsset silo asset\\n    /// @param _siloData (optional) data that may be needed during silo creation\\n    /// @return createdSilo address of created silo\\n    function newSilo(address _siloAsset, bytes memory _siloData) external returns (address createdSilo);\\n\\n    /// @notice use this method to deploy new version of Silo for an asset that already has Silo deployed.\\n    /// Only owner (DAO) can replace.\\n    /// @dev Silo does NOT support rebase and deflationary tokens\\n    /// @param _siloAsset silo asset\\n    /// @param _siloVersion version of silo implementation. Use 0 for default version which is fine\\n    /// for 99% of cases.\\n    /// @param _siloData (optional) data that may be needed during silo creation\\n    /// @return createdSilo address of created silo\\n    function replaceSilo(\\n        address _siloAsset,\\n        uint128 _siloVersion,\\n        bytes memory _siloData\\n    ) external returns (address createdSilo);\\n\\n    /// @notice Set factory contract for debt and collateral tokens for each Silo asset\\n    /// @dev Callable only by owner\\n    /// @param _tokensFactory address of TokensFactory contract that deploys debt and collateral tokens\\n    function setTokensFactory(address _tokensFactory) external;\\n\\n    /// @notice Set default fees\\n    /// @dev Callable only by owner\\n    /// @param _fees:\\n    /// - _entryFee one time protocol fee for opening a borrow position in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    /// - _protocolShareFee protocol revenue share in interest paid in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    /// - _protocolLiquidationFee protocol share in liquidation profit in precision points\\n    /// (Solvency._PRECISION_DECIMALS). It's calculated from total collateral amount to be transferred\\n    /// to liquidator.\\n    function setFees(Fees calldata _fees) external;\\n\\n    /// @notice Set configuration for given asset in given Silo\\n    /// @dev Callable only by owner\\n    /// @param _silo Silo address for which config applies\\n    /// @param _asset asset address for which config applies\\n    /// @param _assetConfig:\\n    ///    - _maxLoanToValue maximum Loan-to-Value, for details see `Repository.AssetConfig.maxLoanToValue`\\n    ///    - _liquidationThreshold liquidation threshold, for details see `Repository.AssetConfig.maxLoanToValue`\\n    ///    - _interestRateModel interest rate model address, for details see `Repository.AssetConfig.interestRateModel`\\n    function setAssetConfig(\\n        address _silo,\\n        address _asset,\\n        AssetConfig calldata _assetConfig\\n    ) external;\\n\\n    /// @notice Set default interest rate model\\n    /// @dev Callable only by owner\\n    /// @param _defaultInterestRateModel default interest rate model\\n    function setDefaultInterestRateModel(IInterestRateModel _defaultInterestRateModel) external;\\n\\n    /// @notice Set default maximum LTV\\n    /// @dev Callable only by owner\\n    /// @param _defaultMaxLTV default maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\\n    function setDefaultMaximumLTV(uint64 _defaultMaxLTV) external;\\n\\n    /// @notice Set default liquidation threshold\\n    /// @dev Callable only by owner\\n    /// @param _defaultLiquidationThreshold default liquidation threshold in precision points\\n    /// (Solvency._PRECISION_DECIMALS)\\n    function setDefaultLiquidationThreshold(uint64 _defaultLiquidationThreshold) external;\\n\\n    /// @notice Set price provider repository\\n    /// @dev Callable only by owner\\n    /// @param _repository price provider repository address\\n    function setPriceProvidersRepository(IPriceProvidersRepository _repository) external;\\n\\n    /// @notice Set router contract\\n    /// @dev Callable only by owner\\n    /// @param _router router address\\n    function setRouter(address _router) external;\\n\\n    /// @notice Set NotificationReceiver contract\\n    /// @dev Callable only by owner\\n    /// @param _silo silo address for which to set `_notificationReceiver`\\n    /// @param _notificationReceiver NotificationReceiver address\\n    function setNotificationReceiver(address _silo, INotificationReceiver _notificationReceiver) external;\\n\\n    /// @notice Adds new bridge asset\\n    /// @dev New bridge asset must be unique. Duplicates in bridge assets are not allowed. It's possible to add\\n    /// bridge asset that has been removed in the past. Note that all Silos must be synced manually. Callable\\n    /// only by owner.\\n    /// @param _newBridgeAsset bridge asset address\\n    function addBridgeAsset(address _newBridgeAsset) external;\\n\\n    /// @notice Removes bridge asset\\n    /// @dev Note that all Silos must be synced manually. Callable only by owner.\\n    /// @param _bridgeAssetToRemove bridge asset address to be removed\\n    function removeBridgeAsset(address _bridgeAssetToRemove) external;\\n\\n    /// @notice Registers new Silo version\\n    /// @dev User can choose which Silo version he wants to deploy. It's possible to have multiple versions of Silo.\\n    /// Callable only by owner.\\n    /// @param _factory factory contract that deploys new version of Silo\\n    /// @param _isDefault true if this version should be used as default\\n    function registerSiloVersion(ISiloFactory _factory, bool _isDefault) external;\\n\\n    /// @notice Unregisters Silo version\\n    /// @dev Callable only by owner.\\n    /// @param _siloVersion Silo version to be unregistered\\n    function unregisterSiloVersion(uint128 _siloVersion) external;\\n\\n    /// @notice Sets default Silo version\\n    /// @dev Callable only by owner.\\n    /// @param _defaultVersion Silo version to be set as default\\n    function setDefaultSiloVersion(uint128 _defaultVersion) external;\\n\\n    /// @notice Check if contract address is a Silo deployment\\n    /// @param _silo address of expected Silo\\n    /// @return true if address is Silo deployment, otherwise false\\n    function isSilo(address _silo) external view returns (bool);\\n\\n    /// @notice Get Silo address of asset\\n    /// @param _asset address of asset\\n    /// @return address of corresponding Silo deployment\\n    function getSilo(address _asset) external view returns (address);\\n\\n    /// @notice Get Silo Factory for given version\\n    /// @param _siloVersion version of Silo implementation\\n    /// @return ISiloFactory contract that deploys Silos of given version\\n    function siloFactory(uint256 _siloVersion) external view returns (ISiloFactory);\\n\\n    /// @notice Get debt and collateral Token Factory\\n    /// @return ITokensFactory contract that deploys debt and collateral tokens\\n    function tokensFactory() external view returns (ITokensFactory);\\n\\n    /// @notice Get Router contract\\n    /// @return address of router contract\\n    function router() external view returns (address);\\n\\n    /// @notice Get current bridge assets\\n    /// @dev Keep in mind that not all Silos may be synced with current bridge assets so it's possible that some\\n    /// assets in that list are not part of given Silo.\\n    /// @return address array of bridge assets\\n    function getBridgeAssets() external view returns (address[] memory);\\n\\n    /// @notice Get removed bridge assets\\n    /// @dev Keep in mind that not all Silos may be synced with bridge assets so it's possible that some\\n    /// assets in that list are still part of given Silo.\\n    /// @return address array of bridge assets\\n    function getRemovedBridgeAssets() external view returns (address[] memory);\\n\\n    /// @notice Get maximum LTV for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return maximum LTV in precision points (Solvency._PRECISION_DECIMALS)\\n    function getMaximumLTV(address _silo, address _asset) external view returns (uint256);\\n\\n    /// @notice Get Interest Rate Model address for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return address of interest rate model\\n    function getInterestRateModel(address _silo, address _asset) external view returns (IInterestRateModel);\\n\\n    /// @notice Get liquidation threshold for asset in given Silo\\n    /// @dev If dedicated config is not set, method returns default config\\n    /// @param _silo address of Silo\\n    /// @param _asset address of an asset\\n    /// @return liquidation threshold in precision points (Solvency._PRECISION_DECIMALS)\\n    function getLiquidationThreshold(address _silo, address _asset) external view returns (uint256);\\n\\n    /// @notice Get incentive contract address. Incentive contracts are responsible for distributing rewards\\n    /// to debt and/or collateral token holders of given Silo\\n    /// @param _silo address of Silo\\n    /// @return incentive contract address\\n    function getNotificationReceiver(address _silo) external view returns (INotificationReceiver);\\n\\n    /// @notice Get owner role address of Repository\\n    /// @return owner role address\\n    function owner() external view returns (address);\\n\\n    /// @notice get PriceProvidersRepository contract that manages price providers implementations\\n    /// @return IPriceProvidersRepository address\\n    function priceProvidersRepository() external view returns (IPriceProvidersRepository);\\n\\n    /// @dev Get protocol fee for opening a borrow position\\n    /// @return fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function entryFee() external view returns (uint256);\\n\\n    /// @dev Get protocol share fee\\n    /// @return protocol share fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function protocolShareFee() external view returns (uint256);\\n\\n    /// @dev Get protocol liquidation fee\\n    /// @return protocol liquidation fee in precision points (Solvency._PRECISION_DECIMALS == 100%)\\n    function protocolLiquidationFee() external view returns (uint256);\\n\\n    /// @dev Checks all conditions for new silo creation and throws when not possible to create\\n    /// @param _asset address of asset for which you want to create silo\\n    /// @param _assetIsABridge bool TRUE when `_asset` is bridge asset, FALSE when it is not\\n    function ensureCanCreateSiloFor(address _asset, bool _assetIsABridge) external view;\\n\\n    function siloRepositoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokensFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\nimport \\\"./IShareToken.sol\\\";\\n\\ninterface ITokensFactory {\\n    /// @notice Emitted when collateral token is deployed\\n    /// @param token address of deployed collateral token\\n    event NewShareCollateralTokenCreated(address indexed token);\\n\\n    /// @notice Emitted when collateral token is deployed\\n    /// @param token address of deployed debt token\\n    event NewShareDebtTokenCreated(address indexed token);\\n\\n    ///@notice Must be called by repository on constructor\\n    /// @param _siloRepository the SiloRepository to set\\n    function initRepository(address _siloRepository) external;\\n\\n    /// @notice Deploys collateral token\\n    /// @param _name name of the token\\n    /// @param _symbol symbol of the token\\n    /// @param _asset underlying asset for which token is deployed\\n    /// @return address of deployed collateral share token\\n    function createShareCollateralToken(\\n        string memory _name,\\n        string memory _symbol,\\n        address _asset\\n    ) external returns (IShareToken);\\n\\n    /// @notice Deploys debt token\\n    /// @param _name name of the token\\n    /// @param _symbol symbol of the token\\n    /// @param _asset underlying asset for which token is deployed\\n    /// @return address of deployed debt share token\\n    function createShareDebtToken(\\n        string memory _name,\\n        string memory _symbol,\\n        address _asset\\n    )\\n        external\\n        returns (IShareToken);\\n\\n    /// @dev just a helper method to see if address is a factory\\n    /// @return always true\\n    function tokensFactoryPing() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EasyMathV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.13;\\n\\n/// @dev EasyMathV2 is optimised version of EasyMath, many places was `unchecked` for lower gas cost.\\n/// There is also fixed version of `calculateUtilization()` method.\\nlibrary EasyMathV2 {\\n    error ZeroAssets();\\n    error ZeroShares();\\n\\n    function toShare(uint256 amount, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        result = amount * totalShares;\\n        // totalAmount is never 0 based on above check, so we can uncheck\\n        unchecked { result /= totalAmount; }\\n\\n        // Prevent rounding error\\n        if (result == 0 && amount != 0) {\\n            revert ZeroShares();\\n        }\\n    }\\n\\n    function toShareRoundUp(uint256 amount, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return amount;\\n        }\\n\\n        uint256 numerator = amount * totalShares;\\n        // totalAmount is not 0, so it is safe to uncheck\\n        unchecked { result = numerator / totalAmount; }\\n        \\n        // Round up\\n        if (numerator % totalAmount != 0) {\\n            unchecked { result += 1; }\\n        }\\n    }\\n\\n    function toAmount(uint256 share, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        result = share * totalAmount;\\n        // totalShares are not 0, so we can uncheck\\n        unchecked { result /= totalShares; }\\n\\n        // Prevent rounding error\\n        if (result == 0 && share != 0) {\\n            revert ZeroAssets();\\n        }\\n    }\\n\\n    function toAmountRoundUp(uint256 share, uint256 totalAmount, uint256 totalShares)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        if (totalShares == 0 || totalAmount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 numerator = share * totalAmount;\\n        // totalShares are not 0, based on above check, so we can uncheck\\n        unchecked { result = numerator / totalShares; }\\n        \\n        // Round up\\n        if (numerator % totalShares != 0) {\\n            unchecked { result += 1; }\\n        }\\n    }\\n\\n    function toValue(uint256 _assetAmount, uint256 _assetPrice, uint256 _assetDecimals)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = _assetAmount * _assetPrice;\\n        // power of 10 can not be 0, so we can uncheck\\n        unchecked { value /= 10 ** _assetDecimals; }\\n    }\\n\\n    function sum(uint256[] memory _numbers) internal pure returns (uint256 s) {\\n        for(uint256 i; i < _numbers.length;) {\\n            s += _numbers[i];\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @notice Calculates fraction between borrowed and deposited amount of tokens denominated in percentage\\n    /// @dev It assumes `_dp` = 100%.\\n    /// @param _dp decimal points used by model\\n    /// @param _totalDeposits current total deposits for assets\\n    /// @param _totalBorrowAmount current total borrows for assets\\n    /// @return utilization value, capped to 100%\\n    /// Limiting utilisation ratio by 100% max will allows us to perform better interest rate computations\\n    /// and should not affect any other part of protocol.\\n    function calculateUtilization(uint256 _dp, uint256 _totalDeposits, uint256 _totalBorrowAmount)\\n        internal\\n        pure\\n        returns (uint256 utilization)\\n    {\\n        if (_totalDeposits == 0 || _totalBorrowAmount == 0) return 0;\\n\\n        utilization = _totalBorrowAmount * _dp;\\n        // _totalDeposits is not 0 based on above check, so it is safe to uncheck this division\\n        unchecked { utilization /= _totalDeposits; }\\n\\n        // cap at 100%\\n        if (utilization > _dp) utilization = _dp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/PRBMathCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\n/* solhint-disable */\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n// representation. When it does not, it is annonated in the function's NatSpec documentation.\\n/// @author Paul Razvan Berg\\nlibrary PRBMathCommon {\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Uses 128.128-bit fixed-point numbers - it is the most efficient way.\\n    /// @param x The exponent as an unsigned 128.128-bit fixed-point number.\\n    /// @return result The result as an unsigned 60x18 decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 128.128-bit fixed-point format. We need to use uint256 because the intermediary\\n            // may get very close to 2^256, which doesn't fit in int256.\\n            result = 0x80000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^127 and all magic factors are less than 2^129.\\n            if (x & 0x80000000000000000000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\n            if (x & 0x40000000000000000000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDED) >> 128;\\n            if (x & 0x20000000000000000000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A7920) >> 128;\\n            if (x & 0x10000000000000000000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98364) >> 128;\\n            if (x & 0x8000000000000000000000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FE) >> 128;\\n            if (x & 0x4000000000000000000000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE9) >> 128;\\n            if (x & 0x2000000000000000000000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA40) >> 128;\\n            if (x & 0x1000000000000000000000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9544) >> 128;\\n            if (x & 0x800000000000000000000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679C) >> 128;\\n            if (x & 0x400000000000000000000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A011) >> 128;\\n            if (x & 0x200000000000000000000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5E0) >> 128;\\n            if (x & 0x100000000000000000000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939726) >> 128;\\n            if (x & 0x80000000000000000000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3E) >> 128;\\n            if (x & 0x40000000000000000000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B4) >> 128;\\n            if (x & 0x20000000000000000000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292027) >> 128;\\n            if (x & 0x10000000000000000000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FD) >> 128;\\n            if (x & 0x8000000000000000000000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAC) >> 128;\\n            if (x & 0x4000000000000000000000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7CA) >> 128;\\n            if (x & 0x2000000000000000000000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\n            if (x & 0x1000000000000000000000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\n            if (x & 0x800000000000000000000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1629) >> 128;\\n            if (x & 0x400000000000000000000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2C) >> 128;\\n            if (x & 0x200000000000000000000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A6) >> 128;\\n            if (x & 0x100000000000000000000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFF) >> 128;\\n            if (x & 0x80000000000000000000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2F0) >> 128;\\n            if (x & 0x40000000000000000000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737B) >> 128;\\n            if (x & 0x20000000000000000000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F07) >> 128;\\n            if (x & 0x10000000000000000000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44FA) >> 128;\\n            if (x & 0x8000000000000000000000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC824) >> 128;\\n            if (x & 0x4000000000000000000000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE51) >> 128;\\n            if (x & 0x2000000000000000000000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFD0) >> 128;\\n            if (x & 0x1000000000000000000000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\n            if (x & 0x800000000000000000000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AE) >> 128;\\n            if (x & 0x400000000000000000000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CD) >> 128;\\n            if (x & 0x200000000000000000000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\n            if (x & 0x100000000000000000000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AF) >> 128;\\n            if (x & 0x80000000000000000000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCF) >> 128;\\n            if (x & 0x40000000000000000000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0E) >> 128;\\n            if (x & 0x20000000000000000000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\n            if (x & 0x10000000000000000000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94D) >> 128;\\n            if (x & 0x8000000000000000000000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33E) >> 128;\\n            if (x & 0x4000000000000000000000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26946) >> 128;\\n            if (x & 0x2000000000000000000000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388D) >> 128;\\n            if (x & 0x1000000000000000000000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D41) >> 128;\\n            if (x & 0x800000000000000000000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDF) >> 128;\\n            if (x & 0x400000000000000000000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77F) >> 128;\\n            if (x & 0x200000000000000000000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C3) >> 128;\\n            if (x & 0x100000000000000000000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E3) >> 128;\\n            if (x & 0x80000000000000000000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F2) >> 128;\\n            if (x & 0x40000000000000000000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA39) >> 128;\\n            if (x & 0x20000000000000000000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\n            if (x & 0x10000000000000000000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\n            if (x & 0x8000000000000000000 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\n            if (x & 0x4000000000000000000 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\n            if (x & 0x2000000000000000000 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D92) >> 128;\\n            if (x & 0x1000000000000000000 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\\n            if (x & 0x800000000000000000 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE545) >> 128;\\n            if (x & 0x400000000000000000 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\n            if (x & 0x200000000000000000 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\\n            if (x & 0x100000000000000000 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\n            if (x & 0x80000000000000000 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6E) >> 128;\\n            if (x & 0x40000000000000000 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B3) >> 128;\\n            if (x & 0x20000000000000000 > 0) result = (result * 0x1000000000000000162E42FEFA39EF359) >> 128;\\n            if (x & 0x10000000000000000 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AC) >> 128;\\n\\n            // Multiply the result by the integer part 2^n + 1. We have to shift by one bit extra because we have already divided\\n            // by two when we set the result equal to 0.5 above.\\n            result = result << ((x >> 128) + 1);\\n\\n            // Convert the result to the signed 60.18-decimal fixed-point format.\\n            result = PRBMathCommon.mulDiv(result, 1e18, 2**128);\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2**256 and mod 2**256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256. Also prevents denominator == 0.\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2**256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2**256. Now that denominator is an odd number, it has an inverse modulo 2**256 such\\n            // that denominator * inv = 1 mod 2**256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2**256. Since the precoditions guarantee that the outcome is\\n            // less than 2**256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n}\\n/* solhint-enable */\\n\"\r\n    },\r\n    \"contracts/lib/PRBMathSD59x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\nimport \\\"./PRBMathCommon.sol\\\";\\n\\n/* solhint-disable */\\n/// @title PRBMathSD59x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math. It works with int256 numbers considered to have 18\\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\\nlibrary PRBMathSD59x18 {\\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\\n    int256 internal constant LOG2_E = 1442695040888963407;\\n\\n    /// @dev Half the SCALE number.\\n    int256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\\n    int256 internal constant MAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    int256 internal constant SCALE = 1e18;\\n\\n    /// INTERNAL FUNCTIONS ///\\n\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 88722839111672999628.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp(int256 x) internal pure returns (int256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be less than -59794705707972522261.\\n        if (x < -41446531673892822322) {\\n            return 0;\\n        }\\n\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 128e18.\\n        require(x < 88722839111672999628);\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            int256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 128e18 or less.\\n    /// - The result must fit within MAX_SD59x18.\\n    ///\\n    /// Caveats:\\n    /// - For any x less than -59794705707972522261, the result is zero.\\n    ///\\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\\n    function exp2(int256 x) internal pure returns (int256 result) {\\n        // This works because 2^-x = 1/2^x.\\n        if (x < 0) {\\n            // 2**59.794705707972522262 is the maximum number whose inverse does not equal zero.\\n            if (x < -59794705707972522261) {\\n                return 0;\\n            }\\n\\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n            unchecked { result = 1e36 / exp2(-x); }\\n            return result;\\n        } else {\\n            // 2**128 doesn't fit within the 128.128-bit fixed-point representation.\\n            require(x < 128e18);\\n\\n            unchecked {\\n                // Convert x to the 128.128-bit fixed-point format.\\n                uint256 x128x128 = (uint256(x) << 128) / uint256(SCALE);\\n\\n                // Safe to convert the result to int256 directly because the maximum input allowed is 128e18.\\n                result = int256(PRBMathCommon.exp2(x128x128));\\n            }\\n        }\\n    }\\n}\\n/* solhint-enable */\\n\"\r\n    },\r\n    \"contracts/utils/TwoStepOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.7.6 <0.9.0;\\n\\n/// @title TwoStepOwnable\\n/// @notice Contract that implements the same functionality as popular Ownable contract from openzeppelin library.\\n/// The only difference is that it adds a possibility to transfer ownership in two steps. Single step ownership\\n/// transfer is still supported.\\n/// @dev Two step ownership transfer is meant to be used by humans to avoid human error. Single step ownership\\n/// transfer is meant to be used by smart contracts to avoid over-complicated two step integration. For that reason,\\n/// both ways are supported.\\nabstract contract TwoStepOwnable {\\n    /// @dev current owner\\n    address private _owner;\\n    /// @dev candidate to an owner\\n    address private _pendingOwner;\\n\\n    /// @notice Emitted when ownership is transferred on `transferOwnership` and `acceptOwnership`\\n    /// @param newOwner new owner\\n    event OwnershipTransferred(address indexed newOwner);\\n    /// @notice Emitted when ownership transfer is proposed, aka pending owner is set\\n    /// @param newPendingOwner new proposed/pending owner\\n    event OwnershipPending(address indexed newPendingOwner);\\n\\n    /**\\n     *  error OnlyOwner();\\n     *  error OnlyPendingOwner();\\n     *  error OwnerIsZero();\\n     */\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert(\\\"OnlyOwner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert(\\\"OwnerIsZero\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers pending ownership of the contract to a new account (`newPendingOwner`) and clears any existing\\n     * pending ownership.\\n     * Can only be called by the current owner.\\n     */\\n    function transferPendingOwnership(address newPendingOwner) public virtual onlyOwner {\\n        _setPendingOwner(newPendingOwner);\\n    }\\n\\n    /**\\n     * @dev Clears the pending ownership.\\n     * Can only be called by the current owner.\\n     */\\n    function removePendingOwnership() public virtual onlyOwner {\\n        _setPendingOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a pending owner\\n     * Can only be called by the pending owner.\\n     */\\n    function acceptOwnership() public virtual {\\n        if (msg.sender != pendingOwner()) revert(\\\"OnlyPendingOwner\\\");\\n        _setOwner(pendingOwner());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Sets the new owner and emits the corresponding event.\\n     */\\n    function _setOwner(address newOwner) private {\\n        if (_owner == newOwner) revert(\\\"OwnerDidNotChange\\\");\\n\\n        _owner = newOwner;\\n        emit OwnershipTransferred(newOwner);\\n\\n        if (_pendingOwner != address(0)) {\\n            _setPendingOwner(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the new pending owner and emits the corresponding event.\\n     */\\n    function _setPendingOwner(address newPendingOwner) private {\\n        if (_pendingOwner == newPendingOwner) revert(\\\"PendingOwnerDidNotChange\\\");\\n\\n        _pendingOwner = newPendingOwner;\\n        emit OwnershipPending(newPendingOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"_config\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidBeta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKcrit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKi\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKlin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKlow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRi\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTcrit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamps\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUcrit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUlow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUopt\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"silo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"indexed\":false,\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"ConfigUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ASSET_DATA_OVERFLOW_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCOMP_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"X_MAX\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"_c\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"calculateCompoundInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcomp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"_c\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"calculateCompoundInterestRateWithOverflowDetection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcomp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"overflow\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"_c\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"calculateCurrentInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcur\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"config\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getCompoundInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcomp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getCompoundInterestRateAndUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcomp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getCurrentInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rcur\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateModelPing\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_silos\",\"type\":\"address[]\"},{\"internalType\":\"contract ISiloRepository\",\"name\":\"_siloRepository\",\"type\":\"address\"}],\"name\":\"migrationFromV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"overflowDetected\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"overflow\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removePendingOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"uopt\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ucrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ulow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ki\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"kcrit\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klow\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"klin\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"beta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"ri\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"Tcrit\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateModel.Config\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"transferPendingOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InterestRateModelV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000429d069189e00000000000000000000000000000000000000000000000000000000000000023d7500000000000000000000000000000000000000000000000000000049d482455e000000000000000000000000000000000000000000000000000000189c2b6c750000000000000000000000000000000000000000000000000000000071672e7f00000000000000000000000000000000000000000000000000003f28cb71571c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006d228fa4dad2163056a48fc2186d716f5c65e89a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}