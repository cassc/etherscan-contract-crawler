{"SourceCode": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title WadRayMath library\r\n* @author Aave\r\n* @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n**/\r\n\r\nlibrary WadRayMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    /**\r\n    * @return one ray, 1e27\r\n    **/\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    /**\r\n    * @return one wad, 1e18\r\n    **/\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e27/2\r\n    **/\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e18/2\r\n    **/\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a*b, in wad\r\n    **/\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfWAD.add(a.mul(b)).div(WAD);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a/b, in wad\r\n    **/\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(WAD)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a*b, in ray\r\n    **/\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfRAY.add(a.mul(b)).div(RAY);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a/b, in ray\r\n    **/\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(RAY)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev casts ray down to wad\r\n    * @param a ray\r\n    * @return a casted to wad, rounded half up to the nearest wad\r\n    **/\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n\r\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev convert wad up to ray\r\n    * @param a wad\r\n    * @return a converted in ray\r\n    **/\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        return a.mul(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates base^exp. The code uses the ModExp precompile\r\n    * @return base^exp, in ray\r\n    */\r\n    //solium-disable-next-line\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rayMul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rayMul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * > Note that this information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * `IERC20.balanceOf` and `IERC20.transfer`.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\ncontract VersionedInitializable {\r\n    /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n    uint256 private lastInitializedRevision = 0;\r\n\r\n    /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n    bool private initializing;\r\n\r\n    /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n    modifier initializer() {\r\n        uint256 revision = getRevision();\r\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            lastInitializedRevision = revision;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns the revision number of the contract.\r\n    /// Needs to be defined in the inherited class as a constant.\r\n    function getRevision() internal pure returns(uint256);\r\n\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            cs := extcodesize(address)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n    /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n   * @return The Address of the implementation.\r\n   */\r\n    function _implementation() internal view returns (address);\r\n\r\n    /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n    function _delegate(address implementation) internal {\r\n        //solium-disable-next-line\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n                // delegatecall returns 0 on error.\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n    function _willFallback() internal {}\r\n\r\n    /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n    /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n   * @dev Returns the current implementation.\r\n   * @return Address of the current implementation\r\n   */\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(\r\n            Address.isContract(newImplementation),\r\n            \"Cannot set a proxy implementation to a non-contract address\"\r\n        );\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        //solium-disable-next-line\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title BaseAdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n\r\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n    function admin() external ifAdmin returns (address) {\r\n        return _admin();\r\n    }\r\n\r\n    /**\r\n   * @return The address of the implementation.\r\n   */\r\n    function implementation() external ifAdmin returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n    function changeAdmin(address newAdmin) external ifAdmin {\r\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        (bool success, ) = newImplementation.delegatecall(data);\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n   * @return The admin slot.\r\n   */\r\n    function _admin() internal view returns (address adm) {\r\n        bytes32 slot = ADMIN_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n    function _setAdmin(address newAdmin) internal {\r\n        bytes32 slot = ADMIN_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n    function _willFallback() internal {\r\n        require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n        super._willFallback();\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n * implementation and init data.\r\n */\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Contract constructor.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    constructor(address _logic, bytes memory _data) public payable {\r\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n    /**\r\n   * Contract constructor.\r\n   * @param _logic address of the initial implementation.\r\n   * @param _admin Address of the proxy administrator.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\r\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(_admin);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Contract initializer.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    function initialize(address _logic, bytes memory _data) public payable {\r\n        require(_implementation() == address(0));\r\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AddressStorage {\r\n    mapping(bytes32 => address) private addresses;\r\n\r\n    function getAddress(bytes32 _key) public view returns (address) {\r\n        return addresses[_key];\r\n    }\r\n\r\n    function _setAddress(bytes32 _key, address _value) internal {\r\n        addresses[_key] = _value;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\r\n    /**\r\n   * Contract initializer.\r\n   * @param _logic address of the initial implementation.\r\n   * @param _admin Address of the proxy administrator.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\r\n        require(_implementation() == address(0));\r\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\r\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(_admin);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\ncontract ILendingPoolAddressesProvider {\r\n\r\n    function getLendingPool() public view returns (address);\r\n    function setLendingPoolImpl(address _pool) public;\r\n\r\n    function getLendingPoolCore() public view returns (address payable);\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\r\n\r\n    function getLendingPoolConfigurator() public view returns (address);\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\r\n\r\n    function getLendingPoolDataProvider() public view returns (address);\r\n    function setLendingPoolDataProviderImpl(address _provider) public;\r\n\r\n    function getLendingPoolParametersProvider() public view returns (address);\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\r\n\r\n    function getTokenDistributor() public view returns (address);\r\n    function setTokenDistributor(address _tokenDistributor) public;\r\n\r\n\r\n    function getFeeProvider() public view returns (address);\r\n    function setFeeProviderImpl(address _feeProvider) public;\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address);\r\n    function setLendingPoolLiquidationManager(address _manager) public;\r\n\r\n    function getLendingPoolManager() public view returns (address);\r\n    function setLendingPoolManager(address _lendingPoolManager) public;\r\n\r\n    function getPriceOracle() public view returns (address);\r\n    function setPriceOracle(address _priceOracle) public;\r\n\r\n    function getLendingRateOracle() public view returns (address);\r\n    function setLendingRateOracle(address _lendingRateOracle) public;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @title LendingPoolAddressesProvider contract\r\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\r\n* through the addresses provider.\r\n* @author Aave\r\n**/\r\n\r\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\r\n    //events\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event LendingPoolCoreUpdated(address indexed newAddress);\r\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\r\n    event LendingPoolManagerUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\r\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\r\n    event EthereumAddressUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event FeeProviderUpdated(address indexed newAddress);\r\n    event TokenDistributorUpdated(address indexed newAddress);\r\n\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n\r\n    bytes32 private constant LENDING_POOL = \"LENDING_POOL\";\r\n    bytes32 private constant LENDING_POOL_CORE = \"LENDING_POOL_CORE\";\r\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\r\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \"PARAMETERS_PROVIDER\";\r\n    bytes32 private constant LENDING_POOL_MANAGER = \"LENDING_POOL_MANAGER\";\r\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\r\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \"FLASHLOAN_PROVIDER\";\r\n    bytes32 private constant DATA_PROVIDER = \"DATA_PROVIDER\";\r\n    bytes32 private constant ETHEREUM_ADDRESS = \"ETHEREUM_ADDRESS\";\r\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\r\n    bytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\r\n    bytes32 private constant FEE_PROVIDER = \"FEE_PROVIDER\";\r\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \"WALLET_BALANCE_PROVIDER\";\r\n    bytes32 private constant TOKEN_DISTRIBUTOR = \"TOKEN_DISTRIBUTOR\";\r\n\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPool proxy\r\n    * @return the lending pool proxy address\r\n    **/\r\n    function getLendingPool() public view returns (address) {\r\n        return getAddress(LENDING_POOL);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool\r\n    * @param _pool the new lending pool implementation\r\n    **/\r\n    function setLendingPoolImpl(address _pool) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL, _pool);\r\n        emit LendingPoolUpdated(_pool);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolCore proxy\r\n    * @return the lending pool core proxy address\r\n     */\r\n    function getLendingPoolCore() public view returns (address payable) {\r\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\r\n        return core;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool core\r\n    * @param _lendingPoolCore the new lending pool core implementation\r\n    **/\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\r\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolConfigurator proxy\r\n    * @return the lending pool configurator proxy address\r\n    **/\r\n    function getLendingPoolConfigurator() public view returns (address) {\r\n        return getAddress(LENDING_POOL_CONFIGURATOR);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool configurator\r\n    * @param _configurator the new lending pool configurator implementation\r\n    **/\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\r\n        emit LendingPoolConfiguratorUpdated(_configurator);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolDataProvider proxy\r\n    * @return the lending pool data provider proxy address\r\n     */\r\n    function getLendingPoolDataProvider() public view returns (address) {\r\n        return getAddress(DATA_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool data provider\r\n    * @param _provider the new lending pool data provider implementation\r\n    **/\r\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\r\n        updateImplInternal(DATA_PROVIDER, _provider);\r\n        emit LendingPoolDataProviderUpdated(_provider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolParametersProvider proxy\r\n    * @return the address of the Lending pool parameters provider proxy\r\n    **/\r\n    function getLendingPoolParametersProvider() public view returns (address) {\r\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool parameters provider\r\n    * @param _parametersProvider the new lending pool parameters provider implementation\r\n    **/\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\r\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the FeeProvider proxy\r\n    * @return the address of the Fee provider proxy\r\n    **/\r\n    function getFeeProvider() public view returns (address) {\r\n        return getAddress(FEE_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the FeeProvider proxy\r\n    * @param _feeProvider the new lending pool fee provider implementation\r\n    **/\r\n    function setFeeProviderImpl(address _feeProvider) public onlyOwner {\r\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\r\n        emit FeeProviderUpdated(_feeProvider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\r\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\r\n    * the addresses are changed directly.\r\n    * @return the address of the Lending pool liquidation manager\r\n    **/\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address) {\r\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the address of the Lending pool liquidation manager\r\n    * @param _manager the new lending pool liquidation manager address\r\n    **/\r\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\r\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\r\n        emit LendingPoolLiquidationManagerUpdated(_manager);\r\n    }\r\n\r\n    /**\r\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\r\n    * hence the upgradable proxy pattern is not used\r\n    **/\r\n\r\n\r\n    function getLendingPoolManager() public view returns (address) {\r\n        return getAddress(LENDING_POOL_MANAGER);\r\n    }\r\n\r\n    function setLendingPoolManager(address _lendingPoolManager) public onlyOwner {\r\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\r\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\r\n    }\r\n\r\n    function getPriceOracle() public view returns (address) {\r\n        return getAddress(PRICE_ORACLE);\r\n    }\r\n\r\n    function setPriceOracle(address _priceOracle) public onlyOwner {\r\n        _setAddress(PRICE_ORACLE, _priceOracle);\r\n        emit PriceOracleUpdated(_priceOracle);\r\n    }\r\n\r\n    function getLendingRateOracle() public view returns (address) {\r\n        return getAddress(LENDING_RATE_ORACLE);\r\n    }\r\n\r\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\r\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\r\n        emit LendingRateOracleUpdated(_lendingRateOracle);\r\n    }\r\n\r\n\r\n    function getTokenDistributor() public view returns (address) {\r\n        return getAddress(TOKEN_DISTRIBUTOR);\r\n    }\r\n\r\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\r\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\r\n        emit TokenDistributorUpdated(_tokenDistributor);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev internal function to update the implementation of a specific component of the protocol\r\n    * @param _id the id of the contract to be updated\r\n    * @param _newAddress the address of the new implementation\r\n    **/\r\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\r\n        address payable proxyAddress = address(uint160(getAddress(_id)));\r\n\r\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\r\n        bytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\r\n\r\n        if (proxyAddress == address(0)) {\r\n            proxy = new InitializableAdminUpgradeabilityProxy();\r\n            proxy.initialize(_newAddress, address(this), params);\r\n            _setAddress(_id, address(proxy));\r\n            emit ProxyCreated(_id, address(proxy));\r\n        } else {\r\n            proxy.upgradeToAndCall(_newAddress, params);\r\n        }\r\n\r\n    }\r\n}\r\n\r\ncontract UintStorage {\r\n    mapping(bytes32 => uint256) private uints;\r\n\r\n    function getUint(bytes32 _key) public view returns (uint256) {\r\n        return uints[_key];\r\n    }\r\n\r\n    function _setUint(bytes32 _key, uint256 _value) internal {\r\n        uints[_key] = _value;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title LendingPoolParametersProvider\r\n* @author Aave\r\n* @notice stores the configuration parameters of the Lending Pool contract\r\n**/\r\n\r\ncontract LendingPoolParametersProvider is VersionedInitializable {\r\n\r\n    uint256 private constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 25;\r\n    uint256 private constant REBALANCE_DOWN_RATE_DELTA = (1e27)/5;\r\n    uint256 private constant FLASHLOAN_FEE_TOTAL = 35;\r\n    uint256 private constant FLASHLOAN_FEE_PROTOCOL = 3000;\r\n\r\n    uint256 constant private DATA_PROVIDER_REVISION = 0x1;\r\n\r\n    function getRevision() internal pure returns(uint256) {\r\n        return DATA_PROVIDER_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev initializes the LendingPoolParametersProvider after it's added to the proxy\r\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\r\n    */\r\n    function initialize(address _addressesProvider) public initializer {\r\n    }\r\n    /**\r\n    * @dev returns the maximum stable rate borrow size, in percentage of the available liquidity.\r\n    **/\r\n    function getMaxStableRateBorrowSizePercent() external pure returns (uint256)  {\r\n        return MAX_STABLE_RATE_BORROW_SIZE_PERCENT;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the delta between the current stable rate and the user stable rate at\r\n    *      which the borrow position of the user will be rebalanced (scaled down)\r\n    **/\r\n    function getRebalanceDownRateDelta() external pure returns (uint256) {\r\n        return REBALANCE_DOWN_RATE_DELTA;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the fee applied to a flashloan and the portion to redirect to the protocol, in basis points.\r\n    **/\r\n    function getFlashLoanFeesInBips() external pure returns (uint256, uint256) {\r\n        return (FLASHLOAN_FEE_TOTAL, FLASHLOAN_FEE_PROTOCOL);\r\n    }\r\n}\r\n\r\n/**\r\n* @title CoreLibrary library\r\n* @author Aave\r\n* @notice Defines the data structures of the reserves and the user data\r\n**/\r\nlibrary CoreLibrary {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n\r\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\r\n\r\n    struct UserReserveData {\r\n        //principal amount borrowed by the user.\r\n        uint256 principalBorrowBalance;\r\n        //cumulated variable borrow index for the user. Expressed in ray\r\n        uint256 lastVariableBorrowCumulativeIndex;\r\n        //origination fee cumulated by the user\r\n        uint256 originationFee;\r\n        // stable borrow rate at which the user has borrowed. Expressed in ray\r\n        uint256 stableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //defines if a specific deposit should or not be used as a collateral in borrows\r\n        bool useAsCollateral;\r\n    }\r\n\r\n    struct ReserveData {\r\n        /**\r\n        * @dev refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n        **/\r\n        //the liquidity index. Expressed in ray\r\n        uint256 lastLiquidityCumulativeIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint256 currentLiquidityRate;\r\n        //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\r\n        uint256 totalBorrowsStable;\r\n        //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\r\n        uint256 totalBorrowsVariable;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint256 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint256 currentStableBorrowRate;\r\n        //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\r\n        uint256 currentAverageStableBorrowRate;\r\n        //variable borrow index. Expressed in ray\r\n        uint256 lastVariableBorrowCumulativeIndex;\r\n        //the ltv of the reserve. Expressed in percentage (0-100)\r\n        uint256 baseLTVasCollateral;\r\n        //the liquidation threshold of the reserve. Expressed in percentage (0-100)\r\n        uint256 liquidationThreshold;\r\n        //the liquidation bonus of the reserve. Expressed in percentage\r\n        uint256 liquidationBonus;\r\n        //the decimals of the reserve asset\r\n        uint256 decimals;\r\n        /**\r\n        * @dev address of the aToken representing the asset\r\n        **/\r\n        address aTokenAddress;\r\n        /**\r\n        * @dev address of the interest rate strategy contract\r\n        **/\r\n        address interestRateStrategyAddress;\r\n        uint40 lastUpdateTimestamp;\r\n        // borrowingEnabled = true means users can borrow from this reserve\r\n        bool borrowingEnabled;\r\n        // usageAsCollateralEnabled = true means users can use this reserve as collateral\r\n        bool usageAsCollateralEnabled;\r\n        // isStableBorrowRateEnabled = true means users can borrow at a stable rate\r\n        bool isStableBorrowRateEnabled;\r\n        // isActive = true means the reserve has been activated and properly configured\r\n        bool isActive;\r\n        // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\r\n        bool isFreezed;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the ongoing normalized income for the reserve.\r\n    * a value of 1e27 means there is no income. As time passes, the income is accrued.\r\n    * A value of 2*1e27 means that the income of the reserve is double the initial amount.\r\n    * @param _reserve the reserve object\r\n    * @return the normalized income. expressed in ray\r\n    **/\r\n    function getNormalizedIncome(CoreLibrary.ReserveData storage _reserve)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 cumulated = calculateLinearInterest(\r\n            _reserve\r\n                .currentLiquidityRate,\r\n            _reserve\r\n                .lastUpdateTimestamp\r\n        )\r\n            .rayMul(_reserve.lastLiquidityCumulativeIndex);\r\n\r\n        return cumulated;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\r\n    * a formal specification.\r\n    * @param _self the reserve object\r\n    **/\r\n    function updateCumulativeIndexes(ReserveData storage _self) internal {\r\n        uint256 totalBorrows = getTotalBorrows(_self);\r\n\r\n        if (totalBorrows > 0) {\r\n            //only cumulating if there is any income being produced\r\n            uint256 cumulatedLiquidityInterest = calculateLinearInterest(\r\n                _self.currentLiquidityRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n\r\n            _self.lastLiquidityCumulativeIndex = cumulatedLiquidityInterest.rayMul(\r\n                _self.lastLiquidityCumulativeIndex\r\n            );\r\n\r\n            uint256 cumulatedVariableBorrowInterest = calculateCompoundedInterest(\r\n                _self.currentVariableBorrowRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n            _self.lastVariableBorrowCumulativeIndex = cumulatedVariableBorrowInterest.rayMul(\r\n                _self.lastVariableBorrowCumulativeIndex\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\r\n    * the flashloan fee to the reserve, and spread it through the depositors.\r\n    * @param _self the reserve object\r\n    * @param _totalLiquidity the total liquidity available in the reserve\r\n    * @param _amount the amount to accomulate\r\n    **/\r\n    function cumulateToLiquidityIndex(\r\n        ReserveData storage _self,\r\n        uint256 _totalLiquidity,\r\n        uint256 _amount\r\n    ) internal {\r\n        uint256 amountToLiquidityRatio = _amount.wadToRay().rayDiv(_totalLiquidity.wadToRay());\r\n\r\n        uint256 cumulatedLiquidity = amountToLiquidityRatio.add(WadRayMath.ray());\r\n\r\n        _self.lastLiquidityCumulativeIndex = cumulatedLiquidity.rayMul(\r\n            _self.lastLiquidityCumulativeIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev initializes a reserve\r\n    * @param _self the reserve object\r\n    * @param _aTokenAddress the address of the overlying atoken contract\r\n    * @param _decimals the number of decimals of the underlying asset\r\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n    function init(\r\n        ReserveData storage _self,\r\n        address _aTokenAddress,\r\n        uint256 _decimals,\r\n        address _interestRateStrategyAddress\r\n    ) external {\r\n        require(_self.aTokenAddress == address(0), \"Reserve has already been initialized\");\r\n\r\n        if (_self.lastLiquidityCumulativeIndex == 0) {\r\n            //if the reserve has not been initialized yet\r\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\r\n        }\r\n\r\n        if (_self.lastVariableBorrowCumulativeIndex == 0) {\r\n            _self.lastVariableBorrowCumulativeIndex = WadRayMath.ray();\r\n        }\r\n\r\n        _self.aTokenAddress = _aTokenAddress;\r\n        _self.decimals = _decimals;\r\n\r\n        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\r\n        _self.isActive = true;\r\n        _self.isFreezed = false;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev enables borrowing on a reserve\r\n    * @param _self the reserve object\r\n    * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\r\n    **/\r\n    function enableBorrowing(ReserveData storage _self, bool _stableBorrowRateEnabled) external {\r\n        require(_self.borrowingEnabled == false, \"Reserve is already enabled\");\r\n\r\n        _self.borrowingEnabled = true;\r\n        _self.isStableBorrowRateEnabled = _stableBorrowRateEnabled;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev disables borrowing on a reserve\r\n    * @param _self the reserve object\r\n    **/\r\n    function disableBorrowing(ReserveData storage _self) external {\r\n        _self.borrowingEnabled = false;\r\n    }\r\n\r\n    /**\r\n    * @dev enables a reserve to be used as collateral\r\n    * @param _self the reserve object\r\n    * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\r\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\r\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\r\n    **/\r\n    function enableAsCollateral(\r\n        ReserveData storage _self,\r\n        uint256 _baseLTVasCollateral,\r\n        uint256 _liquidationThreshold,\r\n        uint256 _liquidationBonus\r\n    ) external {\r\n        require(\r\n            _self.usageAsCollateralEnabled == false,\r\n            \"Reserve is already enabled as collateral\"\r\n        );\r\n\r\n        _self.usageAsCollateralEnabled = true;\r\n        _self.baseLTVasCollateral = _baseLTVasCollateral;\r\n        _self.liquidationThreshold = _liquidationThreshold;\r\n        _self.liquidationBonus = _liquidationBonus;\r\n\r\n        if (_self.lastLiquidityCumulativeIndex == 0)\r\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev disables a reserve as collateral\r\n    * @param _self the reserve object\r\n    **/\r\n    function disableAsCollateral(ReserveData storage _self) external {\r\n        _self.usageAsCollateralEnabled = false;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev calculates the compounded borrow balance of a user\r\n    * @param _self the userReserve object\r\n    * @param _reserve the reserve object\r\n    * @return the user compounded borrow balance\r\n    **/\r\n    function getCompoundedBorrowBalance(\r\n        CoreLibrary.UserReserveData storage _self,\r\n        CoreLibrary.ReserveData storage _reserve\r\n    ) internal view returns (uint256) {\r\n        if (_self.principalBorrowBalance == 0) return 0;\r\n\r\n        uint256 principalBorrowBalanceRay = _self.principalBorrowBalance.wadToRay();\r\n        uint256 compoundedBalance = 0;\r\n        uint256 cumulatedInterest = 0;\r\n\r\n        if (_self.stableBorrowRate > 0) {\r\n            cumulatedInterest = calculateCompoundedInterest(\r\n                _self.stableBorrowRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n        } else {\r\n            //variable interest\r\n            cumulatedInterest = calculateCompoundedInterest(\r\n                _reserve\r\n                    .currentVariableBorrowRate,\r\n                _reserve\r\n                    .lastUpdateTimestamp\r\n            )\r\n                .rayMul(_reserve.lastVariableBorrowCumulativeIndex)\r\n                .rayDiv(_self.lastVariableBorrowCumulativeIndex);\r\n        }\r\n\r\n        compoundedBalance = principalBorrowBalanceRay.rayMul(cumulatedInterest).rayToWad();\r\n\r\n        if (compoundedBalance == _self.principalBorrowBalance) {\r\n            //solium-disable-next-line\r\n            if (_self.lastUpdateTimestamp != block.timestamp) {\r\n                //no interest cumulation because of the rounding - we add 1 wei\r\n                //as symbolic cumulated interest to avoid interest free loans.\r\n\r\n                return _self.principalBorrowBalance.add(1 wei);\r\n            }\r\n        }\r\n\r\n        return compoundedBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev increases the total borrows at a stable rate on a specific reserve and updates the\r\n    * average stable rate consequently\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to add to the total borrows stable\r\n    * @param _rate the rate at which the amount has been borrowed\r\n    **/\r\n    function increaseTotalBorrowsStableAndUpdateAverageRate(\r\n        ReserveData storage _reserve,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) internal {\r\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\r\n        //updating reserve borrows stable\r\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.add(_amount);\r\n\r\n        //update the average stable rate\r\n        //weighted average of all the borrows\r\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\r\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\r\n            _reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        _reserve.currentAverageStableBorrowRate = weightedLastBorrow\r\n            .add(weightedPreviousTotalBorrows)\r\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\r\n    }\r\n\r\n    /**\r\n    * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\r\n    * average stable rate consequently\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to substract to the total borrows stable\r\n    * @param _rate the rate at which the amount has been repaid\r\n    **/\r\n    function decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n        ReserveData storage _reserve,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) internal {\r\n        require(_reserve.totalBorrowsStable >= _amount, \"Invalid amount to decrease\");\r\n\r\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\r\n\r\n        //updating reserve borrows stable\r\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.sub(_amount);\r\n\r\n        if (_reserve.totalBorrowsStable == 0) {\r\n            _reserve.currentAverageStableBorrowRate = 0; //no income if there are no stable rate borrows\r\n            return;\r\n        }\r\n\r\n        //update the average stable rate\r\n        //weighted average of all the borrows\r\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\r\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\r\n            _reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        require(\r\n            weightedPreviousTotalBorrows >= weightedLastBorrow,\r\n            \"The amounts to subtract don't match\"\r\n        );\r\n\r\n        _reserve.currentAverageStableBorrowRate = weightedPreviousTotalBorrows\r\n            .sub(weightedLastBorrow)\r\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\r\n    }\r\n\r\n    /**\r\n    * @dev increases the total borrows at a variable rate\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to add to the total borrows variable\r\n    **/\r\n    function increaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\r\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.add(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev decreases the total borrows at a variable rate\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to substract to the total borrows variable\r\n    **/\r\n    function decreaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\r\n        require(\r\n            _reserve.totalBorrowsVariable >= _amount,\r\n            \"The amount that is being subtracted from the variable total borrows is incorrect\"\r\n        );\r\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.sub(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate the interest using a linear interest rate formula\r\n    * @param _rate the interest rate, in ray\r\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\r\n    * @return the interest rate linearly accumulated during the timeDelta, in ray\r\n    **/\r\n\r\n    function calculateLinearInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //solium-disable-next-line\r\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\r\n\r\n        uint256 timeDelta = timeDifference.wadToRay().rayDiv(SECONDS_PER_YEAR.wadToRay());\r\n\r\n        return _rate.rayMul(timeDelta).add(WadRayMath.ray());\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate the interest using a compounded interest rate formula\r\n    * @param _rate the interest rate, in ray\r\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\r\n    * @return the interest rate compounded during the timeDelta, in ray\r\n    **/\r\n    function calculateCompoundedInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //solium-disable-next-line\r\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\r\n\r\n        uint256 ratePerSecond = _rate.div(SECONDS_PER_YEAR);\r\n\r\n        return ratePerSecond.add(WadRayMath.ray()).rayPow(timeDifference);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the total borrows on the reserve\r\n    * @param _reserve the reserve object\r\n    * @return the total borrows (stable + variable)\r\n    **/\r\n    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _reserve.totalBorrowsStable.add(_reserve.totalBorrowsVariable);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title IPriceOracleGetter interface\r\n* @notice Interface for the Aave price oracle.\r\n**/\r\n\r\ninterface IPriceOracleGetter {\r\n    /**\r\n    * @dev returns the asset price in ETH\r\n    * @param _asset the address of the asset\r\n    * @return the ETH price of the asset\r\n    **/\r\n    function getAssetPrice(address _asset) external view returns (uint256);\r\n}\r\n\r\n/**\r\n* @title IFeeProvider interface\r\n* @notice Interface for the Aave fee provider.\r\n**/\r\n\r\ninterface IFeeProvider {\r\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256);\r\n    function getLoanOriginationFeePercentage() external view returns (uint256);\r\n}\r\n\r\n/**\r\n* @title LendingPoolDataProvider contract\r\n* @author Aave\r\n* @notice Implements functions to fetch data from the core, and aggregate them in order to allow computation\r\n* on the compounded balances and the account balances in ETH\r\n**/\r\ncontract LendingPoolDataProvider is VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    LendingPoolCore public core;\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n\r\n    /**\r\n    * @dev specifies the health factor threshold at which the user position is liquidated.\r\n    * 1e18 by default, if the health factor drops below 1e18, the loan can be liquidated.\r\n    **/\r\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\r\n\r\n    uint256 public constant DATA_PROVIDER_REVISION = 0x1;\r\n\r\n    function getRevision() internal pure returns (uint256) {\r\n        return DATA_PROVIDER_REVISION;\r\n    }\r\n\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(_addressesProvider.getLendingPoolCore());\r\n    }\r\n\r\n    /**\r\n    * @dev struct to hold calculateUserGlobalData() local computations\r\n    **/\r\n    struct UserGlobalDataLocalVars {\r\n        uint256 reserveUnitPrice;\r\n        uint256 tokenUnit;\r\n        uint256 compoundedLiquidityBalance;\r\n        uint256 compoundedBorrowBalance;\r\n        uint256 reserveDecimals;\r\n        uint256 baseLtv;\r\n        uint256 liquidationThreshold;\r\n        uint256 originationFee;\r\n        bool usageAsCollateralEnabled;\r\n        bool userUsesReserveAsCollateral;\r\n        address currentReserve;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the user data across the reserves.\r\n    * this includes the total liquidity/collateral/borrow balances in ETH,\r\n    * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\r\n    * @param _user the address of the user\r\n    * @return the total liquidity, total collateral, total borrow balances of the user in ETH.\r\n    * also the average Ltv, liquidation threshold, and the health factor\r\n    **/\r\n    function calculateUserGlobalData(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityBalanceETH,\r\n            uint256 totalCollateralBalanceETH,\r\n            uint256 totalBorrowBalanceETH,\r\n            uint256 totalFeesETH,\r\n            uint256 currentLtv,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 healthFactor,\r\n            bool healthFactorBelowThreshold\r\n        )\r\n    {\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        UserGlobalDataLocalVars memory vars;\r\n\r\n        address[] memory reserves = core.getReserves();\r\n\r\n        for (uint256 i = 0; i < reserves.length; i++) {\r\n            vars.currentReserve = reserves[i];\r\n\r\n            (\r\n                vars.compoundedLiquidityBalance,\r\n                vars.compoundedBorrowBalance,\r\n                vars.originationFee,\r\n                vars.userUsesReserveAsCollateral\r\n            ) = core.getUserBasicReserveData(vars.currentReserve, _user);\r\n\r\n            if (vars.compoundedLiquidityBalance == 0 && vars.compoundedBorrowBalance == 0) {\r\n                continue;\r\n            }\r\n\r\n            //fetch reserve data\r\n            (\r\n                vars.reserveDecimals,\r\n                vars.baseLtv,\r\n                vars.liquidationThreshold,\r\n                vars.usageAsCollateralEnabled\r\n            ) = core.getReserveConfiguration(vars.currentReserve);\r\n\r\n            vars.tokenUnit = 10 ** vars.reserveDecimals;\r\n            vars.reserveUnitPrice = oracle.getAssetPrice(vars.currentReserve);\r\n\r\n            //liquidity and collateral balance\r\n            if (vars.compoundedLiquidityBalance > 0) {\r\n                uint256 liquidityBalanceETH = vars\r\n                    .reserveUnitPrice\r\n                    .mul(vars.compoundedLiquidityBalance)\r\n                    .div(vars.tokenUnit);\r\n                totalLiquidityBalanceETH = totalLiquidityBalanceETH.add(liquidityBalanceETH);\r\n\r\n                if (vars.usageAsCollateralEnabled && vars.userUsesReserveAsCollateral) {\r\n                    totalCollateralBalanceETH = totalCollateralBalanceETH.add(liquidityBalanceETH);\r\n                    currentLtv = currentLtv.add(liquidityBalanceETH.mul(vars.baseLtv));\r\n                    currentLiquidationThreshold = currentLiquidationThreshold.add(\r\n                        liquidityBalanceETH.mul(vars.liquidationThreshold)\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (vars.compoundedBorrowBalance > 0) {\r\n                totalBorrowBalanceETH = totalBorrowBalanceETH.add(\r\n                    vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\r\n                );\r\n                totalFeesETH = totalFeesETH.add(\r\n                    vars.originationFee.mul(vars.reserveUnitPrice).div(vars.tokenUnit)\r\n                );\r\n            }\r\n        }\r\n\r\n        currentLtv = totalCollateralBalanceETH > 0 ? currentLtv.div(totalCollateralBalanceETH) : 0;\r\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\r\n            ? currentLiquidationThreshold.div(totalCollateralBalanceETH)\r\n            : 0;\r\n\r\n        healthFactor = calculateHealthFactorFromBalancesInternal(\r\n            totalCollateralBalanceETH,\r\n            totalBorrowBalanceETH,\r\n            totalFeesETH,\r\n            currentLiquidationThreshold\r\n        );\r\n        healthFactorBelowThreshold = healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n\r\n    }\r\n\r\n    struct balanceDecreaseAllowedLocalVars {\r\n        uint256 decimals;\r\n        uint256 collateralBalanceETH;\r\n        uint256 borrowBalanceETH;\r\n        uint256 totalFeesETH;\r\n        uint256 currentLiquidationThreshold;\r\n        uint256 reserveLiquidationThreshold;\r\n        uint256 amountToDecreaseETH;\r\n        uint256 collateralBalancefterDecrease;\r\n        uint256 liquidationThresholdAfterDecrease;\r\n        uint256 healthFactorAfterDecrease;\r\n        bool reserveUsageAsCollateralEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to decrease\r\n    * @return true if the decrease of the balance is allowed\r\n    **/\r\n\r\n    function balanceDecreaseAllowed(address _reserve, address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        balanceDecreaseAllowedLocalVars memory vars;\r\n\r\n        (\r\n            vars.decimals,\r\n            ,\r\n            vars.reserveLiquidationThreshold,\r\n            vars.reserveUsageAsCollateralEnabled\r\n        ) = core.getReserveConfiguration(_reserve);\r\n\r\n        if (\r\n            !vars.reserveUsageAsCollateralEnabled ||\r\n            !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)\r\n        ) {\r\n            return true; //if reserve is not used as collateral, no reasons to block the transfer\r\n        }\r\n\r\n        (\r\n            ,\r\n            vars.collateralBalanceETH,\r\n            vars.borrowBalanceETH,\r\n            vars.totalFeesETH,\r\n            ,\r\n            vars.currentLiquidationThreshold,\r\n            ,\r\n\r\n        ) = calculateUserGlobalData(_user);\r\n\r\n        if (vars.borrowBalanceETH == 0) {\r\n            return true; //no borrows - no reasons to block the transfer\r\n        }\r\n\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        vars.amountToDecreaseETH = oracle.getAssetPrice(_reserve).mul(_amount).div(\r\n            10 ** vars.decimals\r\n        );\r\n\r\n        vars.collateralBalancefterDecrease = vars.collateralBalanceETH.sub(\r\n            vars.amountToDecreaseETH\r\n        );\r\n\r\n        //if there is a borrow, there can't be 0 collateral\r\n        if (vars.collateralBalancefterDecrease == 0) {\r\n            return false;\r\n        }\r\n\r\n        vars.liquidationThresholdAfterDecrease = vars\r\n            .collateralBalanceETH\r\n            .mul(vars.currentLiquidationThreshold)\r\n            .sub(vars.amountToDecreaseETH.mul(vars.reserveLiquidationThreshold))\r\n            .div(vars.collateralBalancefterDecrease);\r\n\r\n        uint256 healthFactorAfterDecrease = calculateHealthFactorFromBalancesInternal(\r\n            vars.collateralBalancefterDecrease,\r\n            vars.borrowBalanceETH,\r\n            vars.totalFeesETH,\r\n            vars.liquidationThresholdAfterDecrease\r\n        );\r\n\r\n        return healthFactorAfterDecrease > HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n\r\n    }\r\n\r\n    /**\r\n   * @notice calculates the amount of collateral needed in ETH to cover a new borrow.\r\n   * @param _reserve the reserve from which the user wants to borrow\r\n   * @param _amount the amount the user wants to borrow\r\n   * @param _fee the fee for the amount that the user needs to cover\r\n   * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)\r\n   * @param _userCurrentLtv the average ltv of the user given his current collateral\r\n   * @return the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee\r\n   **/\r\n    function calculateCollateralNeededInETH(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        uint256 _userCurrentBorrowBalanceTH,\r\n        uint256 _userCurrentFeesETH,\r\n        uint256 _userCurrentLtv\r\n    ) external view returns (uint256) {\r\n        uint256 reserveDecimals = core.getReserveDecimals(_reserve);\r\n\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        uint256 requestedBorrowAmountETH = oracle\r\n            .getAssetPrice(_reserve)\r\n            .mul(_amount.add(_fee))\r\n            .div(10 ** reserveDecimals); //price is in ether\r\n\r\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\r\n        uint256 collateralNeededInETH = _userCurrentBorrowBalanceTH\r\n            .add(_userCurrentFeesETH)\r\n            .add(requestedBorrowAmountETH)\r\n            .mul(100)\r\n            .div(_userCurrentLtv); //LTV is calculated in percentage\r\n\r\n        return collateralNeededInETH;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\r\n    * average Loan To Value.\r\n    * @param collateralBalanceETH the total collateral balance\r\n    * @param borrowBalanceETH the total borrow balance\r\n    * @param totalFeesETH the total fees\r\n    * @param ltv the average loan to value\r\n    * @return the amount available to borrow in ETH for the user\r\n    **/\r\n\r\n    function calculateAvailableBorrowsETHInternal(\r\n        uint256 collateralBalanceETH,\r\n        uint256 borrowBalanceETH,\r\n        uint256 totalFeesETH,\r\n        uint256 ltv\r\n    ) internal view returns (uint256) {\r\n        uint256 availableBorrowsETH = collateralBalanceETH.mul(ltv).div(100); //ltv is in percentage\r\n\r\n        if (availableBorrowsETH < borrowBalanceETH) {\r\n            return 0;\r\n        }\r\n\r\n        availableBorrowsETH = availableBorrowsETH.sub(borrowBalanceETH.add(totalFeesETH));\r\n        //calculate fee\r\n        uint256 borrowFee = IFeeProvider(addressesProvider.getFeeProvider())\r\n            .calculateLoanOriginationFee(msg.sender, availableBorrowsETH);\r\n        return availableBorrowsETH.sub(borrowFee);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the health factor from the corresponding balances\r\n    * @param collateralBalanceETH the total collateral balance in ETH\r\n    * @param borrowBalanceETH the total borrow balance in ETH\r\n    * @param totalFeesETH the total fees in ETH\r\n    * @param liquidationThreshold the avg liquidation threshold\r\n    **/\r\n    function calculateHealthFactorFromBalancesInternal(\r\n        uint256 collateralBalanceETH,\r\n        uint256 borrowBalanceETH,\r\n        uint256 totalFeesETH,\r\n        uint256 liquidationThreshold\r\n    ) internal pure returns (uint256) {\r\n        if (borrowBalanceETH == 0) return uint256(-1);\r\n\r\n        return\r\n            (collateralBalanceETH.mul(liquidationThreshold).div(100)).wadDiv(\r\n                borrowBalanceETH.add(totalFeesETH)\r\n            );\r\n    }\r\n\r\n    /**\r\n    * @dev returns the health factor liquidation threshold\r\n    **/\r\n    function getHealthFactorLiquidationThreshold() public pure returns (uint256) {\r\n        return HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n    }\r\n\r\n    /**\r\n    * @dev accessory functions to fetch data from the lendingPoolCore\r\n    **/\r\n    function getReserveConfigurationData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            address rateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive\r\n        )\r\n    {\r\n        (, ltv, liquidationThreshold, usageAsCollateralEnabled) = core.getReserveConfiguration(\r\n            _reserve\r\n        );\r\n        stableBorrowRateEnabled = core.getReserveIsStableBorrowRateEnabled(_reserve);\r\n        borrowingEnabled = core.isReserveBorrowingEnabled(_reserve);\r\n        isActive = core.getReserveIsActive(_reserve);\r\n        liquidationBonus = core.getReserveLiquidationBonus(_reserve);\r\n\r\n        rateStrategyAddress = core.getReserveInterestRateStrategyAddress(_reserve);\r\n    }\r\n\r\n    function getReserveData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,\r\n            uint256 availableLiquidity,\r\n            uint256 totalBorrowsStable,\r\n            uint256 totalBorrowsVariable,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 utilizationRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            address aTokenAddress,\r\n            uint40 lastUpdateTimestamp\r\n        )\r\n    {\r\n        totalLiquidity = core.getReserveTotalLiquidity(_reserve);\r\n        availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n        totalBorrowsStable = core.getReserveTotalBorrowsStable(_reserve);\r\n        totalBorrowsVariable = core.getReserveTotalBorrowsVariable(_reserve);\r\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        variableBorrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\r\n        stableBorrowRate = core.getReserveCurrentStableBorrowRate(_reserve);\r\n        averageStableBorrowRate = core.getReserveCurrentAverageStableBorrowRate(_reserve);\r\n        utilizationRate = core.getReserveUtilizationRate(_reserve);\r\n        liquidityIndex = core.getReserveLiquidityCumulativeIndex(_reserve);\r\n        variableBorrowIndex = core.getReserveVariableBorrowsCumulativeIndex(_reserve);\r\n        aTokenAddress = core.getReserveATokenAddress(_reserve);\r\n        lastUpdateTimestamp = core.getReserveLastUpdate(_reserve);\r\n    }\r\n\r\n    function getUserAccountData(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,\r\n            uint256 totalCollateralETH,\r\n            uint256 totalBorrowsETH,\r\n            uint256 totalFeesETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        (\r\n            totalLiquidityETH,\r\n            totalCollateralETH,\r\n            totalBorrowsETH,\r\n            totalFeesETH,\r\n            ltv,\r\n            currentLiquidationThreshold,\r\n            healthFactor,\r\n\r\n        ) = calculateUserGlobalData(_user);\r\n\r\n        availableBorrowsETH = calculateAvailableBorrowsETHInternal(\r\n            totalCollateralETH,\r\n            totalBorrowsETH,\r\n            totalFeesETH,\r\n            ltv\r\n        );\r\n    }\r\n\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentBorrowBalance,\r\n            uint256 principalBorrowBalance,\r\n            uint256 borrowRateMode,\r\n            uint256 borrowRate,\r\n            uint256 liquidityRate,\r\n            uint256 originationFee,\r\n            uint256 variableBorrowIndex,\r\n            uint256 lastUpdateTimestamp,\r\n            bool usageAsCollateralEnabled\r\n        )\r\n    {\r\n        currentATokenBalance = AToken(core.getReserveATokenAddress(_reserve)).balanceOf(_user);\r\n        CoreLibrary.InterestRateMode mode = core.getUserCurrentBorrowRateMode(_reserve, _user);\r\n        (principalBorrowBalance, currentBorrowBalance, ) = core.getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        //default is 0, if mode == CoreLibrary.InterestRateMode.NONE\r\n        if (mode == CoreLibrary.InterestRateMode.STABLE) {\r\n            borrowRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\r\n        } else if (mode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            borrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\r\n        }\r\n\r\n        borrowRateMode = uint256(mode);\r\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        originationFee = core.getUserOriginationFee(_reserve, _user);\r\n        variableBorrowIndex = core.getUserVariableBorrowCumulativeIndex(_reserve, _user);\r\n        lastUpdateTimestamp = core.getUserLastUpdate(_reserve, _user);\r\n        usageAsCollateralEnabled = core.isUserUseReserveAsCollateralEnabled(_reserve, _user);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Aave ERC20 AToken\r\n *\r\n * @dev Implementation of the interest bearing token for the DLP protocol.\r\n * @author Aave\r\n */\r\ncontract AToken is ERC20, ERC20Detailed {\r\n    using WadRayMath for uint256;\r\n\r\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\r\n\r\n    /**\r\n    * @dev emitted after the redeem action\r\n    * @param _from the address performing the redeem\r\n    * @param _value the amount to be redeemed\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event Redeem(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted after the mint action\r\n    * @param _from the address performing the mint\r\n    * @param _value the amount to be minted\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event MintOnDeposit(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during the liquidation action, when the liquidator reclaims the underlying\r\n    * asset\r\n    * @param _from the address from which the tokens are being burned\r\n    * @param _value the amount to be burned\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event BurnOnLiquidation(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during the transfer action\r\n    * @param _from the address from which the tokens are being transferred\r\n    * @param _to the adress of the destination\r\n    * @param _value the amount to be minted\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _toBalanceIncrease the cumulated balance since the last update of the destination\r\n    * @param _fromIndex the last index of the user\r\n    * @param _toIndex the last index of the liquidator\r\n    **/\r\n    event BalanceTransfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _toBalanceIncrease,\r\n        uint256 _fromIndex,\r\n        uint256 _toIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when the accumulation of the interest\r\n    * by an user is redirected to another user\r\n    * @param _from the address from which the interest is being redirected\r\n    * @param _to the adress of the destination\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event InterestStreamRedirected(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _redirectedBalance,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when the redirected balance of an user is being updated\r\n    * @param _targetAddress the address of which the balance is being updated\r\n    * @param _targetBalanceIncrease the cumulated balance since the last update of the target\r\n    * @param _targetIndex the last index of the user\r\n    * @param _redirectedBalanceAdded the redirected balance being added\r\n    * @param _redirectedBalanceRemoved the redirected balance being removed\r\n    **/\r\n    event RedirectedBalanceUpdated(\r\n        address indexed _targetAddress,\r\n        uint256 _targetBalanceIncrease,\r\n        uint256 _targetIndex,\r\n        uint256 _redirectedBalanceAdded,\r\n        uint256 _redirectedBalanceRemoved\r\n    );\r\n\r\n    event InterestRedirectionAllowanceChanged(\r\n        address indexed _from,\r\n        address indexed _to\r\n    );\r\n\r\n    address public underlyingAssetAddress;\r\n\r\n    mapping (address => uint256) private userIndexes;\r\n    mapping (address => address) private interestRedirectionAddresses;\r\n    mapping (address => uint256) private redirectedBalances;\r\n    mapping (address => address) private interestRedirectionAllowances;\r\n\r\n    LendingPoolAddressesProvider private addressesProvider;\r\n    LendingPoolCore private core;\r\n    LendingPool private pool;\r\n    LendingPoolDataProvider private dataProvider;\r\n\r\n    modifier onlyLendingPool {\r\n        require(\r\n            msg.sender == address(pool),\r\n            \"The caller of this function must be a lending pool\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenTransferAllowed(address _from, uint256 _amount) {\r\n        require(isTransferAllowed(_from, _amount), \"Transfer cannot be allowed.\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        LendingPoolAddressesProvider _addressesProvider,\r\n        address _underlyingAsset,\r\n        uint8 _underlyingAssetDecimals,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) public ERC20Detailed(_name, _symbol, _underlyingAssetDecimals) {\r\n\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\r\n        pool = LendingPool(addressesProvider.getLendingPool());\r\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\r\n        underlyingAssetAddress = _underlyingAsset;\r\n    }\r\n\r\n    /**\r\n     * @notice ERC20 implementation internal function backing transfer() and transferFrom()\r\n     * @dev validates the transfer before allowing it. NOTE: This is not standard ERC20 behavior\r\n     **/\r\n    function _transfer(address _from, address _to, uint256 _amount) internal whenTransferAllowed(_from, _amount) {\r\n\r\n        executeTransferInternal(_from, _to, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev redirects the interest generated to a target address.\r\n    * when the interest is redirected, the user balance is added to\r\n    * the recepient redirected balance.\r\n    * @param _to the address to which the interest will be redirected\r\n    **/\r\n    function redirectInterestStream(address _to) external {\r\n        redirectInterestStreamInternal(msg.sender, _to);\r\n    }\r\n\r\n    /**\r\n    * @dev redirects the interest generated by _from to a target address.\r\n    * when the interest is redirected, the user balance is added to\r\n    * the recepient redirected balance. The caller needs to have allowance on\r\n    * the interest redirection to be able to execute the function.\r\n    * @param _from the address of the user whom interest is being redirected\r\n    * @param _to the address to which the interest will be redirected\r\n    **/\r\n    function redirectInterestStreamOf(address _from, address _to) external {\r\n        require(\r\n            msg.sender == interestRedirectionAllowances[_from],\r\n            \"Caller is not allowed to redirect the interest of the user\"\r\n        );\r\n        redirectInterestStreamInternal(_from,_to);\r\n    }\r\n\r\n    /**\r\n    * @dev gives allowance to an address to execute the interest redirection\r\n    * on behalf of the caller.\r\n    * @param _to the address to which the interest will be redirected. Pass address(0) to reset\r\n    * the allowance.\r\n    **/\r\n    function allowInterestRedirectionTo(address _to) external {\r\n        require(_to != msg.sender, \"User cannot give allowance to himself\");\r\n        interestRedirectionAllowances[msg.sender] = _to;\r\n        emit InterestRedirectionAllowanceChanged(\r\n            msg.sender,\r\n            _to\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev redeems aToken for the underlying asset\r\n    * @param _amount the amount being redeemed\r\n    **/\r\n    function redeem(uint256 _amount) external {\r\n\r\n        require(_amount > 0, \"Amount to redeem needs to be > 0\");\r\n\r\n        //cumulates the balance of the user\r\n        (,\r\n        uint256 currentBalance,\r\n        uint256 balanceIncrease,\r\n        uint256 index) = cumulateBalanceInternal(msg.sender);\r\n\r\n        uint256 amountToRedeem = _amount;\r\n\r\n        //if amount is equal to uint(-1), the user wants to redeem everything\r\n        if(_amount == UINT_MAX_VALUE){\r\n            amountToRedeem = currentBalance;\r\n        }\r\n\r\n        require(amountToRedeem <= currentBalance, \"User cannot redeem more than the available balance\");\r\n\r\n        //check that the user is allowed to redeem the amount\r\n        require(isTransferAllowed(msg.sender, amountToRedeem), \"Transfer cannot be allowed.\");\r\n\r\n        //if the user is redirecting his interest towards someone else,\r\n        //we update the redirected balance of the redirection address by adding the accrued interest,\r\n        //and removing the amount to redeem\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(msg.sender, balanceIncrease, amountToRedeem);\r\n\r\n        // burns tokens equivalent to the amount requested\r\n        _burn(msg.sender, amountToRedeem);\r\n\r\n        bool userIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(currentBalance.sub(amountToRedeem) == 0){\r\n            userIndexReset = resetDataOnZeroBalanceInternal(msg.sender);\r\n        }\r\n\r\n        // executes redeem of the underlying asset\r\n        pool.redeemUnderlying(\r\n            underlyingAssetAddress,\r\n            msg.sender,\r\n            amountToRedeem,\r\n            currentBalance.sub(amountToRedeem)\r\n        );\r\n\r\n        emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);\r\n    }\r\n\r\n    /**\r\n     * @dev mints token in the event of users depositing the underlying asset into the lending pool\r\n     * only lending pools can call this function\r\n     * @param _account the address receiving the minted tokens\r\n     * @param _amount the amount of tokens to mint\r\n     */\r\n    function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {\r\n\r\n        //cumulates the balance of the user\r\n        (,\r\n        ,\r\n        uint256 balanceIncrease,\r\n        uint256 index) = cumulateBalanceInternal(_account);\r\n\r\n         //if the user is redirecting his interest towards someone else,\r\n        //we update the redirected balance of the redirection address by adding the accrued interest\r\n        //and the amount deposited\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);\r\n\r\n        //mint an equivalent amount of tokens to cover the new deposit\r\n        _mint(_account, _amount);\r\n\r\n        emit MintOnDeposit(_account, _amount, balanceIncrease, index);\r\n    }\r\n\r\n    /**\r\n     * @dev burns token in the event of a borrow being liquidated, in case the liquidators reclaims the underlying asset\r\n     * Transfer of the liquidated asset is executed by the lending pool contract.\r\n     * only lending pools can call this function\r\n     * @param _account the address from which burn the aTokens\r\n     * @param _value the amount to burn\r\n     **/\r\n    function burnOnLiquidation(address _account, uint256 _value) external onlyLendingPool {\r\n\r\n        //cumulates the balance of the user being liquidated\r\n        (,uint256 accountBalance,uint256 balanceIncrease,uint256 index) = cumulateBalanceInternal(_account);\r\n\r\n        //adds the accrued interest and substracts the burned amount to\r\n        //the redirected balance\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease, _value);\r\n\r\n        //burns the requested amount of tokens\r\n        _burn(_account, _value);\r\n\r\n        bool userIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(accountBalance.sub(_value) == 0){\r\n            userIndexReset = resetDataOnZeroBalanceInternal(_account);\r\n        }\r\n\r\n        emit BurnOnLiquidation(_account, _value, balanceIncrease, userIndexReset ? 0 : index);\r\n    }\r\n\r\n    /**\r\n     * @dev transfers tokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n     *      only lending pools can call this function\r\n     * @param _from the address from which transfer the aTokens\r\n     * @param _to the destination address\r\n     * @param _value the amount to transfer\r\n     **/\r\n    function transferOnLiquidation(address _from, address _to, uint256 _value) external onlyLendingPool {\r\n\r\n        //being a normal transfer, the Transfer() and BalanceTransfer() are emitted\r\n        //so no need to emit a specific event here\r\n        executeTransferInternal(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the balance of the user, which is the\r\n    * principal balance + interest generated by the principal balance + interest generated by the redirected balance\r\n    * @param _user the user for which the balance is being calculated\r\n    * @return the total balance of the user\r\n    **/\r\n    function balanceOf(address _user) public view returns(uint256) {\r\n\r\n        //current principal balance of the user\r\n        uint256 currentPrincipalBalance = super.balanceOf(_user);\r\n        //balance redirected by other users to _user for interest rate accrual\r\n        uint256 redirectedBalance = redirectedBalances[_user];\r\n\r\n        if(currentPrincipalBalance == 0 && redirectedBalance == 0){\r\n            return 0;\r\n        }\r\n        //if the _user is not redirecting the interest to anybody, accrues\r\n        //the interest for himself\r\n\r\n        if(interestRedirectionAddresses[_user] == address(0)){\r\n\r\n            //accruing for himself means that both the principal balance and\r\n            //the redirected balance partecipate in the interest\r\n            return calculateCumulatedBalanceInternal(\r\n                _user,\r\n                currentPrincipalBalance.add(redirectedBalance)\r\n                )\r\n                .sub(redirectedBalance);\r\n        }\r\n        else {\r\n            //if the user redirected the interest, then only the redirected\r\n            //balance generates interest. In that case, the interest generated\r\n            //by the redirected balance is added to the current principal balance.\r\n            return currentPrincipalBalance.add(\r\n                calculateCumulatedBalanceInternal(\r\n                    _user,\r\n                    redirectedBalance\r\n                )\r\n                .sub(redirectedBalance)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev returns the principal balance of the user. The principal balance is the last\r\n    * updated stored balance, which does not consider the perpetually accruing interest.\r\n    * @param _user the address of the user\r\n    * @return the principal balance of the user\r\n    **/\r\n    function principalBalanceOf(address _user) external view returns(uint256) {\r\n        return super.balanceOf(_user);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev calculates the total supply of the specific aToken\r\n    * since the balance of every single user increases over time, the total supply\r\n    * does that too.\r\n    * @return the current total supply\r\n    **/\r\n    function totalSupply() public view returns(uint256) {\r\n\r\n        uint256 currentSupplyPrincipal = super.totalSupply();\r\n\r\n        if(currentSupplyPrincipal == 0){\r\n            return 0;\r\n        }\r\n\r\n        return currentSupplyPrincipal\r\n            .wadToRay()\r\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\r\n            .rayToWad();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Used to validate transfers before actually executing them.\r\n     * @param _user address of the user to check\r\n     * @param _amount the amount to check\r\n     * @return true if the _user can transfer _amount, false otherwise\r\n     **/\r\n    function isTransferAllowed(address _user, uint256 _amount) public view returns (bool) {\r\n        return dataProvider.balanceDecreaseAllowed(underlyingAssetAddress, _user, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the last index of the user, used to calculate the balance of the user\r\n    * @param _user address of the user\r\n    * @return the last user index\r\n    **/\r\n    function getUserIndex(address _user) external view returns(uint256) {\r\n        return userIndexes[_user];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev returns the address to which the interest is redirected\r\n    * @param _user address of the user\r\n    * @return 0 if there is no redirection, an address otherwise\r\n    **/\r\n    function getInterestRedirectionAddress(address _user) external view returns(address) {\r\n        return interestRedirectionAddresses[_user];\r\n    }\r\n\r\n    /**\r\n    * @dev returns the redirected balance of the user. The redirected balance is the balance\r\n    * redirected by other accounts to the user, that is accrueing interest for him.\r\n    * @param _user address of the user\r\n    * @return the total redirected balance\r\n    **/\r\n    function getRedirectedBalance(address _user) external view returns(uint256) {\r\n        return redirectedBalances[_user];\r\n    }\r\n\r\n    /**\r\n    * @dev accumulates the accrued interest of the user to the principal balance\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @return the previous principal balance, the new principal balance, the balance increase\r\n    * and the new user index\r\n    **/\r\n    function cumulateBalanceInternal(address _user)\r\n        internal\r\n        returns(uint256, uint256, uint256, uint256) {\r\n\r\n        uint256 previousPrincipalBalance = super.balanceOf(_user);\r\n\r\n        //calculate the accrued interest since the last accumulation\r\n        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);\r\n        //mints an amount of tokens equivalent to the amount accumulated\r\n        _mint(_user, balanceIncrease);\r\n        //updates the user index\r\n        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);\r\n        return (\r\n            previousPrincipalBalance,\r\n            previousPrincipalBalance.add(balanceIncrease),\r\n            balanceIncrease,\r\n            index\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev updates the redirected balance of the user. If the user is not redirecting his\r\n    * interest, nothing is executed.\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @param _balanceToAdd the amount to add to the redirected balance\r\n    * @param _balanceToRemove the amount to remove from the redirected balance\r\n    **/\r\n    function updateRedirectedBalanceOfRedirectionAddressInternal(\r\n        address _user,\r\n        uint256 _balanceToAdd,\r\n        uint256 _balanceToRemove\r\n    ) internal {\r\n\r\n        address redirectionAddress = interestRedirectionAddresses[_user];\r\n        //if there isn't any redirection, nothing to be done\r\n        if(redirectionAddress == address(0)){\r\n            return;\r\n        }\r\n\r\n        //compound balances of the redirected address\r\n        (,,uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(redirectionAddress);\r\n\r\n        //updating the redirected balance\r\n        redirectedBalances[redirectionAddress] = redirectedBalances[redirectionAddress]\r\n            .add(_balanceToAdd)\r\n            .sub(_balanceToRemove);\r\n\r\n        //if the interest of redirectionAddress is also being redirected, we need to update\r\n        //the redirected balance of the redirection target by adding the balance increase\r\n        address targetOfRedirectionAddress = interestRedirectionAddresses[redirectionAddress];\r\n\r\n        if(targetOfRedirectionAddress != address(0)){\r\n            redirectedBalances[targetOfRedirectionAddress] = redirectedBalances[targetOfRedirectionAddress].add(balanceIncrease);\r\n        }\r\n\r\n        emit RedirectedBalanceUpdated(\r\n            redirectionAddress,\r\n            balanceIncrease,\r\n            index,\r\n            _balanceToAdd,\r\n            _balanceToRemove\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev calculate the interest accrued by _user on a specific balance\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @param _balance the balance on which the interest is calculated\r\n    * @return the interest rate accrued\r\n    **/\r\n    function calculateCumulatedBalanceInternal(\r\n        address _user,\r\n        uint256 _balance\r\n    ) internal view returns (uint256) {\r\n        return _balance\r\n            .wadToRay()\r\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\r\n            .rayDiv(userIndexes[_user])\r\n            .rayToWad();\r\n    }\r\n\r\n    /**\r\n    * @dev executes the transfer of aTokens, invoked by both _transfer() and\r\n    *      transferOnLiquidation()\r\n    * @param _from the address from which transfer the aTokens\r\n    * @param _to the destination address\r\n    * @param _value the amount to transfer\r\n    **/\r\n    function executeTransferInternal(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n\r\n        require(_value > 0, \"Transferred amount needs to be greater than zero\");\r\n\r\n        //cumulate the balance of the sender\r\n        (,\r\n        uint256 fromBalance,\r\n        uint256 fromBalanceIncrease,\r\n        uint256 fromIndex\r\n        ) = cumulateBalanceInternal(_from);\r\n\r\n        //cumulate the balance of the receiver\r\n        (,\r\n        ,\r\n        uint256 toBalanceIncrease,\r\n        uint256 toIndex\r\n        ) = cumulateBalanceInternal(_to);\r\n\r\n        //if the sender is redirecting his interest towards someone else,\r\n        //adds to the redirected balance the accrued interest and removes the amount\r\n        //being transferred\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from, fromBalanceIncrease, _value);\r\n\r\n        //if the receiver is redirecting his interest towards someone else,\r\n        //adds to the redirected balance the accrued interest and the amount\r\n        //being transferred\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_to, toBalanceIncrease.add(_value), 0);\r\n\r\n        //performs the transfer\r\n        super._transfer(_from, _to, _value);\r\n\r\n        bool fromIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(fromBalance.sub(_value) == 0){\r\n            fromIndexReset = resetDataOnZeroBalanceInternal(_from);\r\n        }\r\n\r\n        emit BalanceTransfer(\r\n            _from,\r\n            _to,\r\n            _value,\r\n            fromBalanceIncrease,\r\n            toBalanceIncrease,\r\n            fromIndexReset ? 0 : fromIndex,\r\n            toIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev executes the redirection of the interest from one address to another.\r\n    * immediately after redirection, the destination address will start to accrue interest.\r\n    * @param _from the address from which transfer the aTokens\r\n    * @param _to the destination address\r\n    **/\r\n    function redirectInterestStreamInternal(\r\n        address _from,\r\n        address _to\r\n    ) internal {\r\n\r\n        address currentRedirectionAddress = interestRedirectionAddresses[_from];\r\n\r\n        require(_to != currentRedirectionAddress, \"Interest is already redirected to the user\");\r\n\r\n        //accumulates the accrued interest to the principal\r\n        (uint256 previousPrincipalBalance,\r\n        uint256 fromBalance,\r\n        uint256 balanceIncrease,\r\n        uint256 fromIndex) = cumulateBalanceInternal(_from);\r\n\r\n        require(fromBalance > 0, \"Interest stream can only be redirected if there is a valid balance\");\r\n\r\n        //if the user is already redirecting the interest to someone, before changing\r\n        //the redirection address we substract the redirected balance of the previous\r\n        //recipient\r\n        if(currentRedirectionAddress != address(0)){\r\n            updateRedirectedBalanceOfRedirectionAddressInternal(_from,0, previousPrincipalBalance);\r\n        }\r\n\r\n        //if the user is redirecting the interest back to himself,\r\n        //we simply set to 0 the interest redirection address\r\n        if(_to == _from) {\r\n            interestRedirectionAddresses[_from] = address(0);\r\n            emit InterestStreamRedirected(\r\n                _from,\r\n                address(0),\r\n                fromBalance,\r\n                balanceIncrease,\r\n                fromIndex\r\n            );\r\n            return;\r\n        }\r\n\r\n        //first set the redirection address to the new recipient\r\n        interestRedirectionAddresses[_from] = _to;\r\n\r\n        //adds the user balance to the redirected balance of the destination\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from,fromBalance,0);\r\n\r\n        emit InterestStreamRedirected(\r\n            _from,\r\n            _to,\r\n            fromBalance,\r\n            balanceIncrease,\r\n            fromIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev function to reset the interest stream redirection and the user index, if the\r\n    * user has no balance left.\r\n    * @param _user the address of the user\r\n    * @return true if the user index has also been reset, false otherwise. useful to emit the proper user index value\r\n    **/\r\n    function resetDataOnZeroBalanceInternal(address _user) internal returns(bool) {\r\n\r\n        //if the user has 0 principal balance, the interest stream redirection gets reset\r\n        interestRedirectionAddresses[_user] = address(0);\r\n\r\n        //emits a InterestStreamRedirected event to notify that the redirection has been reset\r\n        emit InterestStreamRedirected(_user, address(0),0,0,0);\r\n\r\n        //if the redirected balance is also 0, we clear up the user index\r\n        if(redirectedBalances[_user] == 0){\r\n            userIndexes[_user] = 0;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* @title IFlashLoanReceiver interface\r\n* @notice Interface for the Aave fee IFlashLoanReceiver.\r\n* @author Aave\r\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n**/\r\ninterface IFlashLoanReceiver {\r\n\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\r\n}\r\n\r\n/**\r\n* @title ILendingRateOracle interface\r\n* @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\r\n**/\r\n\r\ninterface ILendingRateOracle {\r\n    /**\r\n    @dev returns the market borrow rate in ray\r\n    **/\r\n    function getMarketBorrowRate(address _asset) external view returns (uint256);\r\n\r\n    /**\r\n    @dev sets the market borrow rate. Rate value must be in ray\r\n    **/\r\n    function setMarketBorrowRate(address _asset, uint256 _rate) external;\r\n}\r\n\r\n/**\r\n@title IReserveInterestRateStrategyInterface interface\r\n@notice Interface for the calculation of the interest rates.\r\n*/\r\n\r\ninterface IReserveInterestRateStrategy {\r\n\r\n    /**\r\n    * @dev returns the base variable borrow rate, in rays\r\n    */\r\n\r\n    function getBaseVariableBorrowRate() external view returns (uint256);\r\n    /**\r\n    * @dev calculates the liquidity, stable, and variable rates depending on the current utilization rate\r\n    *      and the base parameters\r\n    *\r\n    */\r\n    function calculateInterestRates(\r\n        address _reserve,\r\n        uint256 _utilizationRate,\r\n        uint256 _totalBorrowsStable,\r\n        uint256 _totalBorrowsVariable,\r\n        uint256 _averageStableBorrowRate)\r\n    external\r\n    view\r\n    returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\r\n}\r\n\r\nlibrary EthAddressLib {\r\n\r\n    /**\r\n    * @dev returns the address used within the protocol to identify ETH\r\n    * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns(address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\n\r\n/**\r\n* @title LendingPoolCore contract\r\n* @author Aave\r\n* @notice Holds the state of the lending pool and all the funds deposited\r\n* @dev NOTE: The core does not enforce security checks on the update of the state\r\n* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\r\n* The check that an action can be performed is a duty of the overlying LendingPool contract.\r\n**/\r\n\r\ncontract LendingPoolCore is VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using CoreLibrary for CoreLibrary.ReserveData;\r\n    using CoreLibrary for CoreLibrary.UserReserveData;\r\n    using SafeERC20 for ERC20;\r\n    using Address for address payable;\r\n\r\n    /**\r\n    * @dev Emitted when the state of a reserve is updated\r\n    * @param reserve the address of the reserve\r\n    * @param liquidityRate the new liquidity rate\r\n    * @param stableBorrowRate the new stable borrow rate\r\n    * @param variableBorrowRate the new variable borrow rate\r\n    * @param liquidityIndex the new liquidity index\r\n    * @param variableBorrowIndex the new variable borrow index\r\n    **/\r\n    event ReserveUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    address public lendingPoolAddress;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n\r\n    /**\r\n    * @dev only lending pools can use functions affected by this modifier\r\n    **/\r\n    modifier onlyLendingPool {\r\n        require(lendingPoolAddress == msg.sender, \"The caller must be a lending pool contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev only lending pools configurator can use functions affected by this modifier\r\n    **/\r\n    modifier onlyLendingPoolConfigurator {\r\n        require(\r\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\r\n            \"The caller must be a lending pool configurator contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    mapping(address => CoreLibrary.ReserveData) internal reserves;\r\n    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;\r\n\r\n    address[] public reservesList;\r\n\r\n    uint256 public constant CORE_REVISION = 0x4;\r\n\r\n    /**\r\n    * @dev returns the revision number of the contract\r\n    **/\r\n    function getRevision() internal pure returns (uint256) {\r\n        return CORE_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\r\n    * @param _addressesProvider the addressesProvider contract\r\n    **/\r\n\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        refreshConfigInternal();\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a deposit action\r\n    * @param _reserve the address of the reserve in which the deposit is happening\r\n    * @param _user the address of the the user depositing\r\n    * @param _amount the amount being deposited\r\n    * @param _isFirstDeposit true if the user is depositing for the first time\r\n    **/\r\n\r\n    function updateStateOnDeposit(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amount,\r\n        bool _isFirstDeposit\r\n    ) external onlyLendingPool {\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\r\n\r\n        if (_isFirstDeposit) {\r\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\r\n            setUserUseReserveAsCollateral(_reserve, _user, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a redeem action\r\n    * @param _reserve the address of the reserve in which the redeem is happening\r\n    * @param _user the address of the the user redeeming\r\n    * @param _amountRedeemed the amount being redeemed\r\n    * @param _userRedeemedEverything true if the user is redeeming everything\r\n    **/\r\n    function updateStateOnRedeem(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountRedeemed,\r\n        bool _userRedeemedEverything\r\n    ) external onlyLendingPool {\r\n        //compound liquidity and variable borrow interests\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\r\n\r\n        //if user redeemed everything the useReserveAsCollateral flag is reset\r\n        if (_userRedeemedEverything) {\r\n            setUserUseReserveAsCollateral(_reserve, _user, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a flashloan action\r\n    * @param _reserve the address of the reserve in which the flashloan is happening\r\n    * @param _income the income of the protocol as a result of the action\r\n    **/\r\n    function updateStateOnFlashLoan(\r\n        address _reserve,\r\n        uint256 _availableLiquidityBefore,\r\n        uint256 _income,\r\n        uint256 _protocolFee\r\n    ) external onlyLendingPool {\r\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\r\n\r\n        //compounding the cumulated interest\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\r\n            getReserveTotalBorrows(_reserve)\r\n        );\r\n\r\n        //compounding the received fee into the reserve\r\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\r\n\r\n        //refresh interest rates\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _amountBorrowed the new amount borrowed\r\n    * @param _borrowFee the fee on the amount borrowed\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    * @return the new borrow rate for the user\r\n    **/\r\n    function updateStateOnBorrow(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountBorrowed,\r\n        uint256 _borrowFee,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) external onlyLendingPool returns (uint256, uint256) {\r\n        // getting the previous borrow data of the user\r\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        updateReserveStateOnBorrowInternal(\r\n            _reserve,\r\n            _user,\r\n            principalBorrowBalance,\r\n            balanceIncrease,\r\n            _amountBorrowed,\r\n            _rateMode\r\n        );\r\n\r\n        updateUserStateOnBorrowInternal(\r\n            _reserve,\r\n            _user,\r\n            _amountBorrowed,\r\n            balanceIncrease,\r\n            _borrowFee,\r\n            _rateMode\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\r\n\r\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\r\n    **/\r\n\r\n    function updateStateOnRepay(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _originationFeeRepaid,\r\n        uint256 _balanceIncrease,\r\n        bool _repaidWholeLoan\r\n    ) external onlyLendingPool {\r\n        updateReserveStateOnRepayInternal(\r\n            _reserve,\r\n            _user,\r\n            _paybackAmountMinusFees,\r\n            _balanceIncrease\r\n        );\r\n        updateUserStateOnRepayInternal(\r\n            _reserve,\r\n            _user,\r\n            _paybackAmountMinusFees,\r\n            _originationFeeRepaid,\r\n            _balanceIncrease,\r\n            _repaidWholeLoan\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the amount borrowed by the user\r\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _currentRateMode the current interest rate mode for the user\r\n    **/\r\n    function updateStateOnSwapRate(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _compoundedBorrowBalance,\r\n        uint256 _balanceIncrease,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\r\n        updateReserveStateOnSwapRateInternal(\r\n            _reserve,\r\n            _user,\r\n            _principalBorrowBalance,\r\n            _compoundedBorrowBalance,\r\n            _currentRateMode\r\n        );\r\n\r\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\r\n            _reserve,\r\n            _user,\r\n            _balanceIncrease,\r\n            _currentRateMode\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\r\n\r\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a liquidation action.\r\n    * @param _principalReserve the address of the principal reserve that is being repaid\r\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _collateralToLiquidate the amount of collateral being liquidated\r\n    * @param _feeLiquidated the amount of origination fee being liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\r\n    **/\r\n    function updateStateOnLiquidation(\r\n        address _principalReserve,\r\n        address _collateralReserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _collateralToLiquidate,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _balanceIncrease,\r\n        bool _liquidatorReceivesAToken\r\n    ) external onlyLendingPool {\r\n        updatePrincipalReserveStateOnLiquidationInternal(\r\n            _principalReserve,\r\n            _user,\r\n            _amountToLiquidate,\r\n            _balanceIncrease\r\n        );\r\n\r\n        updateCollateralReserveStateOnLiquidationInternal(\r\n            _collateralReserve\r\n        );\r\n\r\n        updateUserStateOnLiquidationInternal(\r\n            _principalReserve,\r\n            _user,\r\n            _amountToLiquidate,\r\n            _feeLiquidated,\r\n            _balanceIncrease\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\r\n\r\n        if (!_liquidatorReceivesAToken) {\r\n            updateReserveInterestRatesAndTimestampInternal(\r\n                _collateralReserve,\r\n                0,\r\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @return the new stable rate for the user\r\n    **/\r\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\r\n        external\r\n        onlyLendingPool\r\n        returns (uint256)\r\n    {\r\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\r\n\r\n        //update user data and rebalance the rate\r\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\r\n        return usersReserveData[_user][_reserve].stableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev enables or disables a reserve as collateral\r\n    * @param _reserve the address of the principal reserve where the user deposited\r\n    * @param _user the address of the depositor\r\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\r\n    **/\r\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\r\n        public\r\n        onlyLendingPool\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        user.useAsCollateral = _useAsCollateral;\r\n    }\r\n\r\n    /**\r\n    * @notice ETH/token transfer functions\r\n    **/\r\n\r\n    /**\r\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\r\n    **/\r\n    function() external payable {\r\n        //only contracts can send ETH to the core\r\n        require(msg.sender.isContract(), \"Only contracts can send ether to the Lending pool core\");\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev transfers to the user a specific amount from the reserve.\r\n    * @param _reserve the address of the reserve where the transfer is happening\r\n    * @param _user the address of the user receiving the transfer\r\n    * @param _amount the amount being transferred\r\n    **/\r\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\r\n        external\r\n        onlyLendingPool\r\n    {\r\n        if (_reserve != EthAddressLib.ethAddress()) {\r\n            ERC20(_reserve).safeTransfer(_user, _amount);\r\n        } else {\r\n            //solium-disable-next-line\r\n            (bool result, ) = _user.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers the protocol fees to the fees collection address\r\n    * @param _token the address of the token being transferred\r\n    * @param _user the address of the user from where the transfer is happening\r\n    * @param _amount the amount being transferred\r\n    * @param _destination the fee receiver address\r\n    **/\r\n\r\n    function transferToFeeCollectionAddress(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amount,\r\n        address _destination\r\n    ) external payable onlyLendingPool {\r\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            require(\r\n                msg.value == 0,\r\n                \"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\"\r\n            );\r\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\r\n        } else {\r\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\r\n            //solium-disable-next-line\r\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers the fees to the fees collection address in the case of liquidation\r\n    * @param _token the address of the token being transferred\r\n    * @param _amount the amount being transferred\r\n    * @param _destination the fee receiver address\r\n    **/\r\n    function liquidateFee(\r\n        address _token,\r\n        uint256 _amount,\r\n        address _destination\r\n    ) external payable onlyLendingPool {\r\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\r\n        require(\r\n            msg.value == 0,\r\n            \"Fee liquidation does not require any transfer of value\"\r\n        );\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            ERC20(_token).safeTransfer(feeAddress, _amount);\r\n        } else {\r\n            //solium-disable-next-line\r\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers an amount from a user to the destination reserve\r\n    * @param _reserve the address of the reserve where the amount is being transferred\r\n    * @param _user the address of the user from where the transfer is happening\r\n    * @param _amount the amount being transferred\r\n    **/\r\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\r\n        external\r\n        payable\r\n        onlyLendingPool\r\n    {\r\n        if (_reserve != EthAddressLib.ethAddress()) {\r\n            require(msg.value == 0, \"User is sending ETH along with the ERC20 transfer.\");\r\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\r\n\r\n        } else {\r\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\r\n\r\n            if (msg.value > _amount) {\r\n                //send back excess ETH\r\n                uint256 excessAmount = msg.value.sub(_amount);\r\n                //solium-disable-next-line\r\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)(\"\");\r\n                require(result, \"Transfer of ETH failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice data access functions\r\n    **/\r\n\r\n    /**\r\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\r\n    * needed to calculate the global account data in the LendingPoolDataProvider\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\r\n    **/\r\n    function getUserBasicReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\r\n\r\n        if (user.principalBorrowBalance == 0) {\r\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\r\n        }\r\n\r\n        return (\r\n            underlyingBalance,\r\n            user.getCompoundedBorrowBalance(reserve),\r\n            user.originationFee,\r\n            user.useAsCollateral\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev checks if a user is allowed to borrow at a stable rate\r\n    * @param _reserve the reserve address\r\n    * @param _user the user\r\n    * @param _amount the amount the the user wants to borrow\r\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\r\n    **/\r\n\r\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (!reserve.isStableBorrowRateEnabled) return false;\r\n\r\n        return\r\n            !user.useAsCollateral ||\r\n            !reserve.usageAsCollateralEnabled ||\r\n            _amount > getUserUnderlyingAssetBalance(_reserve, _user);\r\n    }\r\n\r\n    /**\r\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\r\n    * @param _reserve the reserve address\r\n    * @param _user the user address\r\n    * @return the underlying deposit balance of the user\r\n    **/\r\n\r\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\r\n        return aToken.balanceOf(_user);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev gets the interest rate strategy contract address for the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the address of the interest rate strategy contract\r\n    **/\r\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.interestRateStrategyAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the aToken contract address for the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the address of the aToken contract\r\n    **/\r\n\r\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.aTokenAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\r\n    * @param _reserve the reserve address\r\n    * @return the available liquidity\r\n    **/\r\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\r\n        uint256 balance = 0;\r\n\r\n        if (_reserve == EthAddressLib.ethAddress()) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            balance = IERC20(_reserve).balanceOf(address(this));\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\r\n    * @param _reserve the reserve address\r\n    * @return the total liquidity\r\n    **/\r\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\r\n    }\r\n\r\n    /**\r\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\r\n    * there has been 100% income.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve normalized income\r\n    **/\r\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.getNormalizedIncome();\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows (stable + variable)\r\n    **/\r\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\r\n        return reserves[_reserve].getTotalBorrows();\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows stable\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows stable\r\n    **/\r\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.totalBorrowsStable;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows variable\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows variable\r\n    **/\r\n\r\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.totalBorrowsVariable;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidation threshold\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidation threshold\r\n    **/\r\n\r\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.liquidationThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidation bonus\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidation bonus\r\n    **/\r\n\r\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.liquidationBonus;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current variable borrow rate\r\n    **/\r\n\r\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        if (reserve.currentVariableBorrowRate == 0) {\r\n            return\r\n                IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\r\n                .getBaseVariableBorrowRate();\r\n        }\r\n        return reserve.currentVariableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current stable borrow rate\r\n    **/\r\n\r\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\r\n\r\n        if (reserve.currentStableBorrowRate == 0) {\r\n            //no stable rate borrows yet\r\n            return oracle.getMarketBorrowRate(_reserve);\r\n        }\r\n\r\n        return reserve.currentStableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\r\n    * of all the loans taken at stable rate.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current average borrow rate\r\n    **/\r\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.currentAverageStableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidity rate\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidity rate\r\n    **/\r\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.currentLiquidityRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidity cumulative index\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidity cumulative index\r\n    **/\r\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.lastLiquidityCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve variable borrow index\r\n    * @param _reserve the reserve address\r\n    * @return the reserve variable borrow index\r\n    **/\r\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.lastVariableBorrowCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev this function aggregates the configuration parameters of the reserve.\r\n    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid\r\n    * multiple external contract calls to fetch the same data.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve decimals\r\n    * @return the base ltv as collateral\r\n    * @return the liquidation threshold\r\n    * @return if the reserve is used as collateral or not\r\n    **/\r\n    function getReserveConfiguration(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        uint256 decimals;\r\n        uint256 baseLTVasCollateral;\r\n        uint256 liquidationThreshold;\r\n        bool usageAsCollateralEnabled;\r\n\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        decimals = reserve.decimals;\r\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\r\n        liquidationThreshold = reserve.liquidationThreshold;\r\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\r\n\r\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the decimals of the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the reserve decimals\r\n    **/\r\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\r\n        return reserves[_reserve].decimals;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is enabled for borrowing\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is enabled for borrowing, false otherwise\r\n    **/\r\n\r\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.borrowingEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is enabled as collateral\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is enabled as collateral, false otherwise\r\n    **/\r\n\r\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.usageAsCollateralEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the stable rate is enabled on reserve\r\n    * @param _reserve the reserve address\r\n    * @return true if the stable rate is enabled on reserve, false otherwise\r\n    **/\r\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isStableBorrowRateEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is active\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is active, false otherwise\r\n    **/\r\n    function getReserveIsActive(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isActive;\r\n    }\r\n\r\n    /**\r\n    * @notice returns if a reserve is freezed\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return true if the reserve is freezed, false otherwise\r\n    **/\r\n\r\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isFreezed;\r\n    }\r\n\r\n    /**\r\n    * @notice returns the timestamp of the last action on the reserve\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return the last updated timestamp of the reserve\r\n    **/\r\n\r\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        timestamp = reserve.lastUpdateTimestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the utilization rate U of a specific reserve\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return the utilization rate in ray\r\n    **/\r\n\r\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        uint256 totalBorrows = reserve.getTotalBorrows();\r\n\r\n        if (totalBorrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\r\n\r\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\r\n    }\r\n\r\n    /**\r\n    * @return the array of reserves configured on the core\r\n    **/\r\n    function getReserves() external view returns (address[] memory) {\r\n        return reservesList;\r\n    }\r\n\r\n    /**\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\r\n    **/\r\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.useAsCollateral;\r\n    }\r\n\r\n    /**\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the origination fee for the user\r\n    **/\r\n    function getUserOriginationFee(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.originationFee;\r\n    }\r\n\r\n    /**\r\n    * @dev users with no loans in progress have NONE as borrow rate mode\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the borrow rate mode for the user,\r\n    **/\r\n\r\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (CoreLibrary.InterestRateMode)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (user.principalBorrowBalance == 0) {\r\n            return CoreLibrary.InterestRateMode.NONE;\r\n        }\r\n\r\n        return\r\n            user.stableBorrowRate > 0\r\n            ? CoreLibrary.InterestRateMode.STABLE\r\n            : CoreLibrary.InterestRateMode.VARIABLE;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the current borrow rate of the user\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the borrow rate for the user,\r\n    **/\r\n    function getUserCurrentBorrowRate(address _reserve, address _user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\r\n\r\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\r\n            return 0;\r\n        }\r\n\r\n        return\r\n            rateMode == CoreLibrary.InterestRateMode.STABLE\r\n            ? usersReserveData[_user][_reserve].stableBorrowRate\r\n            : reserves[_reserve].currentVariableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the user stable rate\r\n    **/\r\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.stableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates and returns the borrow balances of the user\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\r\n    **/\r\n\r\n    function getUserBorrowBalances(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        if (user.principalBorrowBalance == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 principal = user.principalBorrowBalance;\r\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\r\n            user,\r\n            reserves[_reserve]\r\n        );\r\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\r\n    }\r\n\r\n    /**\r\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the variable borrow index for the user\r\n    **/\r\n\r\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.lastVariableBorrowCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the variable borrow index for the user\r\n    **/\r\n\r\n    function getUserLastUpdate(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256 timestamp)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        timestamp = user.lastUpdateTimestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the lending pool core configuration\r\n    **/\r\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\r\n        refreshConfigInternal();\r\n    }\r\n\r\n    /**\r\n    * @dev initializes a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _aTokenAddress the address of the overlying aToken contract\r\n    * @param _decimals the decimals of the reserve currency\r\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n    function initReserve(\r\n        address _reserve,\r\n        address _aTokenAddress,\r\n        uint256 _decimals,\r\n        address _interestRateStrategyAddress\r\n    ) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\r\n        addReserveToListInternal(_reserve);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev removes the last added reserve in the reservesList array\r\n    * @param _reserveToRemove the address of the reserve\r\n    **/\r\n    function removeLastAddedReserve(address _reserveToRemove)\r\n     external onlyLendingPoolConfigurator {\r\n\r\n        address lastReserve = reservesList[reservesList.length-1];\r\n\r\n        require(lastReserve == _reserveToRemove, \"Reserve being removed is different than the reserve requested\");\r\n\r\n        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\r\n        require(getReserveTotalBorrows(lastReserve) == 0, \"Cannot remove a reserve with liquidity deposited\");\r\n\r\n        reserves[lastReserve].isActive = false;\r\n        reserves[lastReserve].aTokenAddress = address(0);\r\n        reserves[lastReserve].decimals = 0;\r\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\r\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\r\n        reserves[lastReserve].borrowingEnabled = false;\r\n        reserves[lastReserve].usageAsCollateralEnabled = false;\r\n        reserves[lastReserve].baseLTVasCollateral = 0;\r\n        reserves[lastReserve].liquidationThreshold = 0;\r\n        reserves[lastReserve].liquidationBonus = 0;\r\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\r\n\r\n        reservesList.pop();\r\n    }\r\n\r\n    /**\r\n    * @dev updates the address of the interest rate strategy contract\r\n    * @param _reserve the address of the reserve\r\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n\r\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\r\n    * @param _reserve the address of the reserve\r\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\r\n    **/\r\n\r\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\r\n    }\r\n\r\n    /**\r\n    * @dev disables borrowing on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n\r\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].disableBorrowing();\r\n    }\r\n\r\n    /**\r\n    * @dev enables a reserve to be used as collateral\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function enableReserveAsCollateral(\r\n        address _reserve,\r\n        uint256 _baseLTVasCollateral,\r\n        uint256 _liquidationThreshold,\r\n        uint256 _liquidationBonus\r\n    ) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].enableAsCollateral(\r\n            _baseLTVasCollateral,\r\n            _liquidationThreshold,\r\n            _liquidationBonus\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev disables a reserve to be used as collateral\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].disableAsCollateral();\r\n    }\r\n\r\n    /**\r\n    * @dev enable the stable borrow rate mode on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isStableBorrowRateEnabled = true;\r\n    }\r\n\r\n    /**\r\n    * @dev disable the stable borrow rate mode on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isStableBorrowRateEnabled = false;\r\n    }\r\n\r\n    /**\r\n    * @dev activates a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        require(\r\n            reserve.lastLiquidityCumulativeIndex > 0 &&\r\n                reserve.lastVariableBorrowCumulativeIndex > 0,\r\n            \"Reserve has not been initialized yet\"\r\n        );\r\n        reserve.isActive = true;\r\n    }\r\n\r\n    /**\r\n    * @dev deactivates a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isActive = false;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to freeze the reserve.\r\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isFreezed = true;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isFreezed = false;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the loan to value of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _ltv the new loan to value\r\n    **/\r\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.baseLTVasCollateral = _ltv;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the liquidation threshold of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _threshold the new liquidation threshold\r\n    **/\r\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.liquidationThreshold = _threshold;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the liquidation bonus of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _bonus the new liquidation bonus\r\n    **/\r\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.liquidationBonus = _bonus;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the reserve decimals\r\n    * @param _reserve the address of the reserve\r\n    * @param _decimals the decimals of the reserve\r\n    **/\r\n    function setReserveDecimals(address _reserve, uint256 _decimals)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n    * @notice internal functions\r\n    **/\r\n\r\n    /**\r\n    * @dev updates the state of a reserve as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\r\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\r\n    * @param _amountBorrowed the new amount borrowed\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    **/\r\n\r\n    function updateReserveStateOnBorrowInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _balanceIncrease,\r\n        uint256 _amountBorrowed,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) internal {\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        //increasing reserve total borrows to account for the new borrow balance of the user\r\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\r\n\r\n        updateReserveTotalBorrowsByRateModeInternal(\r\n            _reserve,\r\n            _user,\r\n            _principalBorrowBalance,\r\n            _balanceIncrease,\r\n            _amountBorrowed,\r\n            _rateMode\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of a user as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _amountBorrowed the amount borrowed\r\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    * @return the final borrow rate for the user. Emitted by the borrow() event\r\n    **/\r\n\r\n    function updateUserStateOnBorrowInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountBorrowed,\r\n        uint256 _balanceIncrease,\r\n        uint256 _fee,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //stable\r\n            //reset the user variable index, and update the stable rate\r\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //variable\r\n            //reset the user stable rate, and store the new borrow index\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        } else {\r\n            revert(\"Invalid borrow rate mode\");\r\n        }\r\n        //increase the principal borrows and the origination fee\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\r\n            _balanceIncrease\r\n        );\r\n        user.originationFee = user.originationFee.add(_fee);\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the reserve as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateReserveStateOnRepayInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\r\n\r\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\r\n\r\n        //update the indexes\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\r\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _balanceIncrease,\r\n                user.stableBorrowRate\r\n            );\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _paybackAmountMinusFees,\r\n                user.stableBorrowRate\r\n            );\r\n        } else {\r\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\r\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\r\n    **/\r\n    function updateUserStateOnRepayInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _originationFeeRepaid,\r\n        uint256 _balanceIncrease,\r\n        bool _repaidWholeLoan\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\r\n            _paybackAmountMinusFees\r\n        );\r\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n\r\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\r\n        //and the rate mode is stable, we reset the interest rate mode of the user\r\n        if (_repaidWholeLoan) {\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        }\r\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\r\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\r\n    * @param _currentRateMode the rate mode at which the user borrowed\r\n    **/\r\n    function updateReserveStateOnSwapRateInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _compoundedBorrowBalance,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        //compounding reserve indexes\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            uint256 userCurrentStableRate = user.stableBorrowRate;\r\n\r\n            //swap to variable\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _principalBorrowBalance,\r\n                userCurrentStableRate\r\n            ); //decreasing stable from old principal balance\r\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\r\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //swap to stable\r\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\r\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _compoundedBorrowBalance,\r\n                currentStableRate\r\n            );\r\n\r\n        } else {\r\n            revert(\"Invalid rate mode received\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is performing the swap\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _currentRateMode the current rate mode of the user\r\n    **/\r\n\r\n    function updateUserStateOnSwapRateInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) internal returns (CoreLibrary.InterestRateMode) {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\r\n\r\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //switch to stable\r\n            newMode = CoreLibrary.InterestRateMode.STABLE;\r\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        } else {\r\n            revert(\"Invalid interest rate mode received\");\r\n        }\r\n        //compounding cumulated interest\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n        return newMode;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\r\n    * @param _principalReserve the address of the principal reserve that is being repaid\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updatePrincipalReserveStateOnLiquidationInternal(\r\n        address _principalReserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\r\n\r\n        //update principal reserve data\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\r\n            _principalReserve,\r\n            _user\r\n        );\r\n\r\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //increase the total borrows by the compounded interest\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _balanceIncrease,\r\n                user.stableBorrowRate\r\n            );\r\n\r\n            //decrease by the actual amount to liquidate\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _amountToLiquidate,\r\n                user.stableBorrowRate\r\n            );\r\n\r\n        } else {\r\n            //increase the total borrows by the compounded interest\r\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\r\n\r\n            //decrease by the actual amount to liquidate\r\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\r\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\r\n    **/\r\n    function updateCollateralReserveStateOnLiquidationInternal(\r\n        address _collateralReserve\r\n    ) internal {\r\n        //update collateral reserve\r\n        reserves[_collateralReserve].updateCumulativeIndexes();\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\r\n    * @param _reserve the address of the principal reserve that is being repaid\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _feeLiquidated the amount of origination fee being liquidated\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n    function updateUserStateOnLiquidationInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _feeLiquidated,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        //first increase by the compounded interest, then decrease by the liquidated amount\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\r\n            _amountToLiquidate\r\n        );\r\n\r\n        if (\r\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\r\n        ) {\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        }\r\n\r\n        if(_feeLiquidated > 0){\r\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\r\n        }\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateReserveStateOnRebalanceInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n            _balanceIncrease,\r\n            user.stableBorrowRate\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateUserStateOnRebalanceInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\r\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _amountBorrowed the accrued interest on the borrowed amount\r\n    **/\r\n    function updateReserveTotalBorrowsByRateModeInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBalance,\r\n        uint256 _balanceIncrease,\r\n        uint256 _amountBorrowed,\r\n        CoreLibrary.InterestRateMode _newBorrowRateMode\r\n    ) internal {\r\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\r\n            _reserve,\r\n            _user\r\n        );\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _principalBalance,\r\n                user.stableBorrowRate\r\n            );\r\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\r\n        }\r\n\r\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\r\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                newPrincipalAmount,\r\n                reserve.currentStableBorrowRate\r\n            );\r\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\r\n        } else {\r\n            revert(\"Invalid new borrow rate mode\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\r\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\r\n    * @param _reserve the address of the reserve to be updated\r\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\r\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\r\n    **/\r\n\r\n    function updateReserveInterestRatesAndTimestampInternal(\r\n        address _reserve,\r\n        uint256 _liquidityAdded,\r\n        uint256 _liquidityTaken\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\r\n            reserve\r\n                .interestRateStrategyAddress\r\n        )\r\n            .calculateInterestRates(\r\n            _reserve,\r\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\r\n            reserve.totalBorrowsStable,\r\n            reserve.totalBorrowsVariable,\r\n            reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        reserve.currentLiquidityRate = newLiquidityRate;\r\n        reserve.currentStableBorrowRate = newStableRate;\r\n        reserve.currentVariableBorrowRate = newVariableRate;\r\n\r\n        //solium-disable-next-line\r\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n        emit ReserveUpdated(\r\n            _reserve,\r\n            newLiquidityRate,\r\n            newStableRate,\r\n            newVariableRate,\r\n            reserve.lastLiquidityCumulativeIndex,\r\n            reserve.lastVariableBorrowCumulativeIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\r\n    * @param _token the address of the token being transferred\r\n    * @param _amount the amount being transferred\r\n    **/\r\n\r\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\r\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            ERC20(_token).safeTransfer(receiver, _amount);\r\n        } else {\r\n            receiver.transfer(_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the internal configuration of the core\r\n    **/\r\n    function refreshConfigInternal() internal {\r\n        lendingPoolAddress = addressesProvider.getLendingPool();\r\n    }\r\n\r\n    /**\r\n    * @dev adds a reserve to the array of the reserves address\r\n    **/\r\n    function addReserveToListInternal(address _reserve) internal {\r\n        bool reserveAlreadyAdded = false;\r\n        for (uint256 i = 0; i < reservesList.length; i++)\r\n            if (reservesList[i] == _reserve) {\r\n                reserveAlreadyAdded = true;\r\n            }\r\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title LendingPool contract\r\n* @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\r\n* @author Aave\r\n **/\r\n\r\ncontract LendingPool is ReentrancyGuard, VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using Address for address;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n    LendingPoolCore public core;\r\n    LendingPoolDataProvider public dataProvider;\r\n    LendingPoolParametersProvider public parametersProvider;\r\n    IFeeProvider feeProvider;\r\n\r\n    /**\r\n    * @dev emitted on deposit\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _referral the referral number of the action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Deposit(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint16 indexed _referral,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during a redeem action.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event RedeemUnderlying(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted on borrow\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _borrowRateMode the rate mode, can be either 1-stable or 2-variable\r\n    * @param _borrowRate the rate at which the user has borrowed\r\n    * @param _originationFee the origination fee to be paid by the user\r\n    * @param _borrowBalanceIncrease the balance increase since the last borrow, 0 if it's the first time borrowing\r\n    * @param _referral the referral number of the action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Borrow(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _borrowRateMode,\r\n        uint256 _borrowRate,\r\n        uint256 _originationFee,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint16 indexed _referral,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted on repay\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user for which the repay has been executed\r\n    * @param _repayer the address of the user that has performed the repay action\r\n    * @param _amountMinusFees the amount repaid minus fees\r\n    * @param _fees the fees repaid\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Repay(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        address indexed _repayer,\r\n        uint256 _amountMinusFees,\r\n        uint256 _fees,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a user performs a rate swap\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user executing the swap\r\n    * @param _newRateMode the new interest rate mode\r\n    * @param _newRate the new borrow rate\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Swap(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _newRateMode,\r\n        uint256 _newRate,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a user enables a reserve as collateral\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    **/\r\n    event ReserveUsedAsCollateralEnabled(address indexed _reserve, address indexed _user);\r\n\r\n    /**\r\n    * @dev emitted when a user disables a reserve as collateral\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    **/\r\n    event ReserveUsedAsCollateralDisabled(address indexed _reserve, address indexed _user);\r\n\r\n    /**\r\n    * @dev emitted when the stable rate of a user gets rebalanced\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user for which the rebalance has been executed\r\n    * @param _newStableRate the new stable borrow rate after the rebalance\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _newStableRate,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a flashloan is executed\r\n    * @param _target the address of the flashLoanReceiver\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount requested\r\n    * @param _totalFee the total fee on the amount\r\n    * @param _protocolFee the part of the fee for the protocol\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event FlashLoan(\r\n        address indexed _target,\r\n        address indexed _reserve,\r\n        uint256 _amount,\r\n        uint256 _totalFee,\r\n        uint256 _protocolFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev these events are not emitted directly by the LendingPool\r\n    * but they are declared here as the LendingPoolLiquidationManager\r\n    * is executed using a delegateCall().\r\n    * This allows to have the events in the generated ABI for LendingPool.\r\n    **/\r\n\r\n    /**\r\n    * @dev emitted when a borrow fee is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _feeLiquidated the total fee liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event OriginationFeeLiquidated(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a borrower is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _purchaseAmount the total amount liquidated\r\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\r\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\r\n    * @param _liquidator the address of the liquidator\r\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event LiquidationCall(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _purchaseAmount,\r\n        uint256 _liquidatedCollateralAmount,\r\n        uint256 _accruedBorrowInterest,\r\n        address _liquidator,\r\n        bool _receiveAToken,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked by the\r\n    * aToken.sol contract\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyOverlyingAToken(address _reserve) {\r\n        require(\r\n            msg.sender == core.getReserveATokenAddress(_reserve),\r\n            \"The caller of this function can only be the aToken contract of this reserve\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the reserve is active\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyActiveReserve(address _reserve) {\r\n        requireReserveActiveInternal(_reserve);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the reserve is not freezed.\r\n    * A freezed reserve only allows redeems, repays, rebalances and liquidations.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyUnfreezedReserve(address _reserve) {\r\n        requireReserveNotFreezedInternal(_reserve);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the provided _amount input parameter\r\n    * is not zero.\r\n    * @param _amount the amount provided\r\n    **/\r\n    modifier onlyAmountGreaterThanZero(uint256 _amount) {\r\n        requireAmountGreaterThanZeroInternal(_amount);\r\n        _;\r\n    }\r\n\r\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\r\n\r\n    uint256 public constant LENDINGPOOL_REVISION = 0x2;\r\n\r\n    function getRevision() internal pure returns (uint256) {\r\n        return LENDINGPOOL_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\r\n    * AddressesProvider.\r\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider registry\r\n    **/\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\r\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\r\n        parametersProvider = LendingPoolParametersProvider(\r\n            addressesProvider.getLendingPoolParametersProvider()\r\n        );\r\n        feeProvider = IFeeProvider(addressesProvider.getFeeProvider());\r\n    }\r\n\r\n    /**\r\n    * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\r\n    * is minted.\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount to be deposited\r\n    * @param _referralCode integrators are assigned a referral code and can potentially receive rewards.\r\n    **/\r\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        AToken aToken = AToken(core.getReserveATokenAddress(_reserve));\r\n\r\n        bool isFirstDeposit = aToken.balanceOf(msg.sender) == 0;\r\n\r\n        core.updateStateOnDeposit(_reserve, msg.sender, _amount, isFirstDeposit);\r\n\r\n        //minting AToken to user 1:1 with the specific exchange rate\r\n        aToken.mintOnDeposit(msg.sender, _amount);\r\n\r\n        //transfer to the core contract\r\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, _amount);\r\n\r\n        //solium-disable-next-line\r\n        emit Deposit(_reserve, msg.sender, _amount, _referralCode, block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Redeems the underlying amount of assets requested by _user.\r\n    * This function is executed by the overlying aToken contract in response to a redeem action.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user performing the action\r\n    * @param _amount the underlying amount to be redeemed\r\n    **/\r\n    function redeemUnderlying(\r\n        address _reserve,\r\n        address payable _user,\r\n        uint256 _amount,\r\n        uint256 _aTokenBalanceAfterRedeem\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyOverlyingAToken(_reserve)\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        uint256 currentAvailableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n        require(\r\n            currentAvailableLiquidity >= _amount,\r\n            \"There is not enough liquidity available to redeem\"\r\n        );\r\n\r\n        core.updateStateOnRedeem(_reserve, _user, _amount, _aTokenBalanceAfterRedeem == 0);\r\n\r\n        core.transferToUser(_reserve, _user, _amount);\r\n\r\n        //solium-disable-next-line\r\n        emit RedeemUnderlying(_reserve, _user, _amount, block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev data structures for local computations in the borrow() method.\r\n    */\r\n\r\n    struct BorrowLocalVars {\r\n        uint256 principalBorrowBalance;\r\n        uint256 currentLtv;\r\n        uint256 currentLiquidationThreshold;\r\n        uint256 borrowFee;\r\n        uint256 requestedBorrowAmountETH;\r\n        uint256 amountOfCollateralNeededETH;\r\n        uint256 userCollateralBalanceETH;\r\n        uint256 userBorrowBalanceETH;\r\n        uint256 userTotalFeesETH;\r\n        uint256 borrowBalanceIncrease;\r\n        uint256 currentReserveStableRate;\r\n        uint256 availableLiquidity;\r\n        uint256 reserveDecimals;\r\n        uint256 finalUserBorrowRate;\r\n        CoreLibrary.InterestRateMode rateMode;\r\n        bool healthFactorBelowThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to borrow a specific amount of the reserve currency, provided that the borrower\r\n    * already deposited enough collateral.\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount to be borrowed\r\n    * @param _interestRateMode the interest rate mode at which the user wants to borrow. Can be 0 (STABLE) or 1 (VARIABLE)\r\n    **/\r\n    function borrow(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        BorrowLocalVars memory vars;\r\n\r\n        //check that the reserve is enabled for borrowing\r\n        require(core.isReserveBorrowingEnabled(_reserve), \"Reserve is not enabled for borrowing\");\r\n        //validate interest rate mode\r\n        require(\r\n            uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||\r\n                uint256(CoreLibrary.InterestRateMode.STABLE) == _interestRateMode,\r\n            \"Invalid interest rate mode selected\"\r\n        );\r\n\r\n        //cast the rateMode to coreLibrary.interestRateMode\r\n        vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);\r\n\r\n        //check that the amount is available in the reserve\r\n        vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n\r\n        require(\r\n            vars.availableLiquidity >= _amount,\r\n            \"There is not enough liquidity available in the reserve\"\r\n        );\r\n\r\n        (\r\n            ,\r\n            vars.userCollateralBalanceETH,\r\n            vars.userBorrowBalanceETH,\r\n            vars.userTotalFeesETH,\r\n            vars.currentLtv,\r\n            vars.currentLiquidationThreshold,\r\n            ,\r\n            vars.healthFactorBelowThreshold\r\n        ) = dataProvider.calculateUserGlobalData(msg.sender);\r\n\r\n        require(vars.userCollateralBalanceETH > 0, \"The collateral balance is 0\");\r\n\r\n        require(\r\n            !vars.healthFactorBelowThreshold,\r\n            \"The borrower can already be liquidated so he cannot borrow more\"\r\n        );\r\n\r\n        //calculating fees\r\n        vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);\r\n\r\n        require(vars.borrowFee > 0, \"The amount to borrow is too small\");\r\n\r\n        vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(\r\n            _reserve,\r\n            _amount,\r\n            vars.borrowFee,\r\n            vars.userBorrowBalanceETH,\r\n            vars.userTotalFeesETH,\r\n            vars.currentLtv\r\n        );\r\n\r\n        require(\r\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\r\n            \"There is not enough collateral to cover a new borrow\"\r\n        );\r\n\r\n        /**\r\n        * Following conditions need to be met if the user is borrowing at a stable rate:\r\n        * 1. Reserve must be enabled for stable rate borrowing\r\n        * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\r\n        *    they are borrowing, to prevent abuses.\r\n        * 3. Users will be able to borrow only a relatively small, configurable amount of the total\r\n        *    liquidity\r\n        **/\r\n\r\n        if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\r\n            require(\r\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),\r\n                \"User cannot borrow the selected amount with a stable rate\"\r\n            );\r\n\r\n            //calculate the max available loan size in stable rate mode as a percentage of the\r\n            //available liquidity\r\n            uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();\r\n            uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);\r\n\r\n            require(\r\n                _amount <= maxLoanSizeStable,\r\n                \"User is trying to borrow too much liquidity at a stable rate\"\r\n            );\r\n        }\r\n\r\n        //all conditions passed - borrow is accepted\r\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(\r\n            _reserve,\r\n            msg.sender,\r\n            _amount,\r\n            vars.borrowFee,\r\n            vars.rateMode\r\n        );\r\n\r\n        //if we reached this point, we can transfer\r\n        core.transferToUser(_reserve, msg.sender, _amount);\r\n\r\n        emit Borrow(\r\n            _reserve,\r\n            msg.sender,\r\n            _amount,\r\n            _interestRateMode,\r\n            vars.finalUserBorrowRate,\r\n            vars.borrowFee,\r\n            vars.borrowBalanceIncrease,\r\n            _referralCode,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\r\n    * @dev the target user is defined by _onBehalfOf. If there is no repayment on behalf of another account,\r\n    * _onBehalfOf must be equal to msg.sender.\r\n    * @param _reserve the address of the reserve on which the user borrowed\r\n    * @param _amount the amount to repay, or uint256(-1) if the user wants to repay everything\r\n    * @param _onBehalfOf the address for which msg.sender is repaying.\r\n    **/\r\n\r\n    struct RepayLocalVars {\r\n        uint256 principalBorrowBalance;\r\n        uint256 compoundedBorrowBalance;\r\n        uint256 borrowBalanceIncrease;\r\n        bool isETH;\r\n        uint256 paybackAmount;\r\n        uint256 paybackAmountMinusFees;\r\n        uint256 currentStableRate;\r\n        uint256 originationFee;\r\n    }\r\n\r\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        RepayLocalVars memory vars;\r\n\r\n        (\r\n            vars.principalBorrowBalance,\r\n            vars.compoundedBorrowBalance,\r\n            vars.borrowBalanceIncrease\r\n        ) = core.getUserBorrowBalances(_reserve, _onBehalfOf);\r\n\r\n        vars.originationFee = core.getUserOriginationFee(_reserve, _onBehalfOf);\r\n        vars.isETH = EthAddressLib.ethAddress() == _reserve;\r\n\r\n        require(vars.compoundedBorrowBalance > 0, \"The user does not have any borrow pending\");\r\n\r\n        require(\r\n            _amount != UINT_MAX_VALUE || msg.sender == _onBehalfOf,\r\n            \"To repay on behalf of an user an explicit amount to repay is needed.\"\r\n        );\r\n\r\n        //default to max amount\r\n        vars.paybackAmount = vars.compoundedBorrowBalance.add(vars.originationFee);\r\n\r\n        if (_amount != UINT_MAX_VALUE && _amount < vars.paybackAmount) {\r\n            vars.paybackAmount = _amount;\r\n        }\r\n\r\n        require(\r\n            !vars.isETH || msg.value >= vars.paybackAmount,\r\n            \"Invalid msg.value sent for the repayment\"\r\n        );\r\n\r\n        //if the amount is smaller than the origination fee, just transfer the amount to the fee destination address\r\n        if (vars.paybackAmount <= vars.originationFee) {\r\n            core.updateStateOnRepay(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                0,\r\n                vars.paybackAmount,\r\n                vars.borrowBalanceIncrease,\r\n                false\r\n            );\r\n\r\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.paybackAmount : 0)(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                vars.paybackAmount,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n\r\n            emit Repay(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                msg.sender,\r\n                0,\r\n                vars.paybackAmount,\r\n                vars.borrowBalanceIncrease,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n            return;\r\n        }\r\n\r\n        vars.paybackAmountMinusFees = vars.paybackAmount.sub(vars.originationFee);\r\n\r\n        core.updateStateOnRepay(\r\n            _reserve,\r\n            _onBehalfOf,\r\n            vars.paybackAmountMinusFees,\r\n            vars.originationFee,\r\n            vars.borrowBalanceIncrease,\r\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFees\r\n        );\r\n\r\n        //if the user didn't repay the origination fee, transfer the fee to the fee collection address\r\n        if(vars.originationFee > 0) {\r\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.originationFee : 0)(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                vars.originationFee,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n        }\r\n\r\n        //sending the total msg.value if the transfer is ETH.\r\n        //the transferToReserve() function will take care of sending the\r\n        //excess ETH back to the caller\r\n        core.transferToReserve.value(vars.isETH ? msg.value.sub(vars.originationFee) : 0)(\r\n            _reserve,\r\n            msg.sender,\r\n            vars.paybackAmountMinusFees\r\n        );\r\n\r\n        emit Repay(\r\n            _reserve,\r\n            _onBehalfOf,\r\n            msg.sender,\r\n            vars.paybackAmountMinusFees,\r\n            vars.originationFee,\r\n            vars.borrowBalanceIncrease,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\r\n    * @param _reserve the address of the reserve on which the user borrowed\r\n    **/\r\n    function swapBorrowRateMode(address _reserve)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n    {\r\n        (uint256 principalBorrowBalance, uint256 compoundedBorrowBalance, uint256 borrowBalanceIncrease) = core\r\n            .getUserBorrowBalances(_reserve, msg.sender);\r\n\r\n        require(\r\n            compoundedBorrowBalance > 0,\r\n            \"User does not have a borrow in progress on this reserve\"\r\n        );\r\n\r\n        CoreLibrary.InterestRateMode currentRateMode = core.getUserCurrentBorrowRateMode(\r\n            _reserve,\r\n            msg.sender\r\n        );\r\n\r\n        if (currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            /**\r\n            * user wants to swap to stable, before swapping we need to ensure that\r\n            * 1. stable borrow rate is enabled on the reserve\r\n            * 2. user is not trying to abuse the reserve by depositing\r\n            * more collateral than he is borrowing, artificially lowering\r\n            * the interest rate, borrowing at variable, and switching to stable\r\n            **/\r\n            require(\r\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, compoundedBorrowBalance),\r\n                \"User cannot borrow the selected amount at stable\"\r\n            );\r\n        }\r\n\r\n        (CoreLibrary.InterestRateMode newRateMode, uint256 newBorrowRate) = core\r\n            .updateStateOnSwapRate(\r\n            _reserve,\r\n            msg.sender,\r\n            principalBorrowBalance,\r\n            compoundedBorrowBalance,\r\n            borrowBalanceIncrease,\r\n            currentRateMode\r\n        );\r\n\r\n        emit Swap(\r\n            _reserve,\r\n            msg.sender,\r\n            uint256(newRateMode),\r\n            newBorrowRate,\r\n            borrowBalanceIncrease,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev rebalances the stable interest rate of a user if current liquidity rate > user stable rate.\r\n    * this is regulated by Aave to ensure that the protocol is not abused, and the user is paying a fair\r\n    * rate. Anyone can call this function though.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user to be rebalanced\r\n    **/\r\n    function rebalanceStableBorrowRate(address _reserve, address _user)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n    {\r\n        (, uint256 compoundedBalance, uint256 borrowBalanceIncrease) = core.getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        //step 1: user must be borrowing on _reserve at a stable rate\r\n        require(compoundedBalance > 0, \"User does not have any borrow for this reserve\");\r\n\r\n        require(\r\n            core.getUserCurrentBorrowRateMode(_reserve, _user) ==\r\n                CoreLibrary.InterestRateMode.STABLE,\r\n            \"The user borrow is variable and cannot be rebalanced\"\r\n        );\r\n\r\n        uint256 userCurrentStableRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\r\n        uint256 liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        uint256 reserveCurrentStableRate = core.getReserveCurrentStableBorrowRate(_reserve);\r\n        uint256 rebalanceDownRateThreshold = reserveCurrentStableRate.rayMul(\r\n            WadRayMath.ray().add(parametersProvider.getRebalanceDownRateDelta())\r\n        );\r\n\r\n        //step 2: we have two possible situations to rebalance:\r\n\r\n        //1. user stable borrow rate is below the current liquidity rate. The loan needs to be rebalanced,\r\n        //as this situation can be abused (user putting back the borrowed liquidity in the same reserve to earn on it)\r\n        //2. user stable rate is above the market avg borrow rate of a certain delta, and utilization rate is low.\r\n        //In this case, the user is paying an interest that is too high, and needs to be rescaled down.\r\n        if (\r\n            userCurrentStableRate < liquidityRate ||\r\n            userCurrentStableRate > rebalanceDownRateThreshold\r\n        ) {\r\n            uint256 newStableRate = core.updateStateOnRebalance(\r\n                _reserve,\r\n                _user,\r\n                borrowBalanceIncrease\r\n            );\r\n\r\n            emit RebalanceStableBorrowRate(\r\n                _reserve,\r\n                _user,\r\n                newStableRate,\r\n                borrowBalanceIncrease,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n\r\n            return;\r\n\r\n        }\r\n\r\n        revert(\"Interest rate rebalance conditions were not met\");\r\n    }\r\n\r\n    /**\r\n    * @dev allows depositors to enable or disable a specific deposit as collateral.\r\n    * @param _reserve the address of the reserve\r\n    * @param _useAsCollateral true if the user wants to user the deposit as collateral, false otherwise.\r\n    **/\r\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n    {\r\n        uint256 underlyingBalance = core.getUserUnderlyingAssetBalance(_reserve, msg.sender);\r\n\r\n        require(underlyingBalance > 0, \"User does not have any liquidity deposited\");\r\n\r\n        require(\r\n            dataProvider.balanceDecreaseAllowed(_reserve, msg.sender, underlyingBalance),\r\n            \"User deposit is already being used as collateral\"\r\n        );\r\n\r\n        core.setUserUseReserveAsCollateral(_reserve, msg.sender, _useAsCollateral);\r\n\r\n        if (_useAsCollateral) {\r\n            emit ReserveUsedAsCollateralEnabled(_reserve, msg.sender);\r\n        } else {\r\n            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev users can invoke this function to liquidate an undercollateralized position.\r\n    * @param _reserve the address of the collateral to liquidated\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _user the address of the borrower\r\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\r\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\r\n    * he wants to receive the underlying asset directly\r\n    **/\r\n    function liquidationCall(\r\n        address _collateral,\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _purchaseAmount,\r\n        bool _receiveAToken\r\n    ) external payable nonReentrant onlyActiveReserve(_reserve) onlyActiveReserve(_collateral) {\r\n        address liquidationManager = addressesProvider.getLendingPoolLiquidationManager();\r\n\r\n        //solium-disable-next-line\r\n        (bool success, bytes memory result) = liquidationManager.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"liquidationCall(address,address,address,uint256,bool)\",\r\n                _collateral,\r\n                _reserve,\r\n                _user,\r\n                _purchaseAmount,\r\n                _receiveAToken\r\n            )\r\n        );\r\n        require(success, \"Liquidation call failed\");\r\n\r\n        (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\r\n\r\n        if (returnCode != 0) {\r\n            //error found\r\n            revert(string(abi.encodePacked(\"Liquidation failed: \", returnMessage)));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\r\n    * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\r\n    * that must be kept into consideration. For further details please visit https://developers.aave.com\r\n    * @param _receiver The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _amount the amount requested for this flashloan\r\n    **/\r\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\r\n        public\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        //check that the reserve has enough available liquidity\r\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\r\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\r\n            ? address(core).balance\r\n            : IERC20(_reserve).balanceOf(address(core));\r\n\r\n        require(\r\n            availableLiquidityBefore >= _amount,\r\n            \"There is not enough liquidity available to borrow\"\r\n        );\r\n\r\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\r\n            .getFlashLoanFeesInBips();\r\n        //calculate amount fee\r\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\r\n\r\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\r\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\r\n        require(\r\n            amountFee > 0 && protocolFee > 0,\r\n            \"The requested amount is too small for a flashLoan.\"\r\n        );\r\n\r\n        //get the FlashLoanReceiver instance\r\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\r\n\r\n        address payable userPayable = address(uint160(_receiver));\r\n\r\n        //transfer funds to the receiver\r\n        core.transferToUser(_reserve, userPayable, _amount);\r\n\r\n        //execute action of the receiver\r\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\r\n\r\n        //check that the actual balance of the core contract includes the returned amount\r\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\r\n            ? address(core).balance\r\n            : IERC20(_reserve).balanceOf(address(core));\r\n\r\n        require(\r\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\r\n            \"The actual balance of the protocol is inconsistent\"\r\n        );\r\n\r\n        core.updateStateOnFlashLoan(\r\n            _reserve,\r\n            availableLiquidityBefore,\r\n            amountFee.sub(protocolFee),\r\n            protocolFee\r\n        );\r\n\r\n        //solium-disable-next-line\r\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev accessory functions to fetch data from the core contract\r\n    **/\r\n\r\n    function getReserveConfigurationData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            address interestRateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive\r\n        )\r\n    {\r\n        return dataProvider.getReserveConfigurationData(_reserve);\r\n    }\r\n\r\n    function getReserveData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,\r\n            uint256 availableLiquidity,\r\n            uint256 totalBorrowsStable,\r\n            uint256 totalBorrowsVariable,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 utilizationRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            address aTokenAddress,\r\n            uint40 lastUpdateTimestamp\r\n        )\r\n    {\r\n        return dataProvider.getReserveData(_reserve);\r\n    }\r\n\r\n    function getUserAccountData(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,\r\n            uint256 totalCollateralETH,\r\n            uint256 totalBorrowsETH,\r\n            uint256 totalFeesETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        return dataProvider.getUserAccountData(_user);\r\n    }\r\n\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentBorrowBalance,\r\n            uint256 principalBorrowBalance,\r\n            uint256 borrowRateMode,\r\n            uint256 borrowRate,\r\n            uint256 liquidityRate,\r\n            uint256 originationFee,\r\n            uint256 variableBorrowIndex,\r\n            uint256 lastUpdateTimestamp,\r\n            bool usageAsCollateralEnabled\r\n        )\r\n    {\r\n        return dataProvider.getUserReserveData(_reserve, _user);\r\n    }\r\n\r\n    function getReserves() external view returns (address[] memory) {\r\n        return core.getReserves();\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to save on code size for the onlyActiveReserve modifier\r\n    **/\r\n    function requireReserveActiveInternal(address _reserve) internal view {\r\n        require(core.getReserveIsActive(_reserve), \"Action requires an active reserve\");\r\n    }\r\n\r\n    /**\r\n    * @notice internal function to save on code size for the onlyUnfreezedReserve modifier\r\n    **/\r\n    function requireReserveNotFreezedInternal(address _reserve) internal view {\r\n        require(!core.getReserveIsFreezed(_reserve), \"Action requires an unfreezed reserve\");\r\n    }\r\n\r\n    /**\r\n    * @notice internal function to save on code size for the onlyAmountGreaterThanZero modifier\r\n    **/\r\n    function requireAmountGreaterThanZeroInternal(uint256 _amount) internal pure {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n    }\r\n}\r\n\r\n/**\r\n* @title LendingPoolLiquidationManager contract\r\n* @author Aave\r\n* @notice Implements the liquidation function.\r\n**/\r\ncontract LendingPoolLiquidationManager is ReentrancyGuard, VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using Address for address;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n    LendingPoolCore core;\r\n    LendingPoolDataProvider dataProvider;\r\n    LendingPoolParametersProvider parametersProvider;\r\n    IFeeProvider feeProvider;\r\n    address ethereumAddress;\r\n\r\n    uint256 constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 50;\r\n\r\n    /**\r\n    * @dev emitted when a borrow fee is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _feeLiquidated the total fee liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event OriginationFeeLiquidated(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a borrower is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _purchaseAmount the total amount liquidated\r\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\r\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\r\n    * @param _liquidator the address of the liquidator\r\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event LiquidationCall(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _purchaseAmount,\r\n        uint256 _liquidatedCollateralAmount,\r\n        uint256 _accruedBorrowInterest,\r\n        address _liquidator,\r\n        bool _receiveAToken,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    enum LiquidationErrors {\r\n        NO_ERROR,\r\n        NO_COLLATERAL_AVAILABLE,\r\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n        CURRRENCY_NOT_BORROWED,\r\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n        NOT_ENOUGH_LIQUIDITY\r\n    }\r\n\r\n    struct LiquidationCallLocalVars {\r\n        uint256 userCollateralBalance;\r\n        uint256 userCompoundedBorrowBalance;\r\n        uint256 borrowBalanceIncrease;\r\n        uint256 maxPrincipalAmountToLiquidate;\r\n        uint256 actualAmountToLiquidate;\r\n        uint256 liquidationRatio;\r\n        uint256 collateralPrice;\r\n        uint256 principalCurrencyPrice;\r\n        uint256 maxAmountCollateralToLiquidate;\r\n        uint256 originationFee;\r\n        uint256 feeLiquidated;\r\n        uint256 liquidatedCollateralForFee;\r\n        CoreLibrary.InterestRateMode borrowRateMode;\r\n        uint256 userStableRate;\r\n        bool isCollateralEnabled;\r\n        bool healthFactorBelowThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev as the contract extends the VersionedInitializable contract to match the state\r\n    * of the LendingPool contract, the getRevision() function is needed.\r\n    */\r\n    function getRevision() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev users can invoke this function to liquidate an undercollateralized position.\r\n    * @param _reserve the address of the collateral to liquidated\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _user the address of the borrower\r\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\r\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\r\n    * he wants to receive the underlying asset directly\r\n    **/\r\n    function liquidationCall(\r\n        address _collateral,\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _purchaseAmount,\r\n        bool _receiveAToken\r\n    ) external payable returns (uint256, string memory) {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        LiquidationCallLocalVars memory vars;\r\n\r\n        (, , , , , , , vars.healthFactorBelowThreshold) = dataProvider.calculateUserGlobalData(\r\n            _user\r\n        );\r\n\r\n        if (!vars.healthFactorBelowThreshold) {\r\n            return (\r\n                uint256(LiquidationErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\r\n                \"Health factor is not below the threshold\"\r\n            );\r\n        }\r\n\r\n        vars.userCollateralBalance = core.getUserUnderlyingAssetBalance(_collateral, _user);\r\n\r\n        //if _user hasn't deposited this specific collateral, nothing can be liquidated\r\n        if (vars.userCollateralBalance == 0) {\r\n            return (\r\n                uint256(LiquidationErrors.NO_COLLATERAL_AVAILABLE),\r\n                \"Invalid collateral to liquidate\"\r\n            );\r\n        }\r\n\r\n        vars.isCollateralEnabled =\r\n            core.isReserveUsageAsCollateralEnabled(_collateral) &&\r\n            core.isUserUseReserveAsCollateralEnabled(_collateral, _user);\r\n\r\n        //if _collateral isn't enabled as collateral by _user, it cannot be liquidated\r\n        if (!vars.isCollateralEnabled) {\r\n            return (\r\n                uint256(LiquidationErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\r\n                \"The collateral chosen cannot be liquidated\"\r\n            );\r\n        }\r\n\r\n        //if the user hasn't borrowed the specific currency defined by _reserve, it cannot be liquidated\r\n        (, vars.userCompoundedBorrowBalance, vars.borrowBalanceIncrease) = core\r\n            .getUserBorrowBalances(_reserve, _user);\r\n\r\n        if (vars.userCompoundedBorrowBalance == 0) {\r\n            return (\r\n                uint256(LiquidationErrors.CURRRENCY_NOT_BORROWED),\r\n                \"User did not borrow the specified currency\"\r\n            );\r\n        }\r\n\r\n        //all clear - calculate the max principal amount that can be liquidated\r\n        vars.maxPrincipalAmountToLiquidate = vars\r\n            .userCompoundedBorrowBalance\r\n            .mul(LIQUIDATION_CLOSE_FACTOR_PERCENT)\r\n            .div(100);\r\n\r\n        vars.actualAmountToLiquidate = _purchaseAmount > vars.maxPrincipalAmountToLiquidate\r\n            ? vars.maxPrincipalAmountToLiquidate\r\n            : _purchaseAmount;\r\n\r\n        (uint256 maxCollateralToLiquidate, uint256 principalAmountNeeded) = calculateAvailableCollateralToLiquidate(\r\n            _collateral,\r\n            _reserve,\r\n            vars.actualAmountToLiquidate,\r\n            vars.userCollateralBalance\r\n        );\r\n\r\n        vars.originationFee = core.getUserOriginationFee(_reserve, _user);\r\n\r\n        //if there is a fee to liquidate, calculate the maximum amount of fee that can be liquidated\r\n        if (vars.originationFee > 0) {\r\n            (\r\n                vars.liquidatedCollateralForFee,\r\n                vars.feeLiquidated\r\n            ) = calculateAvailableCollateralToLiquidate(\r\n                _collateral,\r\n                _reserve,\r\n                vars.originationFee,\r\n                vars.userCollateralBalance.sub(maxCollateralToLiquidate)\r\n            );\r\n        }\r\n\r\n        //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\r\n        //of _collateral to cover the actual amount that is being liquidated, hence we liquidate\r\n        //a smaller amount\r\n\r\n        if (principalAmountNeeded < vars.actualAmountToLiquidate) {\r\n            vars.actualAmountToLiquidate = principalAmountNeeded;\r\n        }\r\n\r\n        //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve\r\n        if (!_receiveAToken) {\r\n            uint256 currentAvailableCollateral = core.getReserveAvailableLiquidity(_collateral);\r\n            if (currentAvailableCollateral < maxCollateralToLiquidate) {\r\n                return (\r\n                    uint256(LiquidationErrors.NOT_ENOUGH_LIQUIDITY),\r\n                    \"There isn't enough liquidity available to liquidate\"\r\n                );\r\n            }\r\n        }\r\n\r\n        core.updateStateOnLiquidation(\r\n            _reserve,\r\n            _collateral,\r\n            _user,\r\n            vars.actualAmountToLiquidate,\r\n            maxCollateralToLiquidate,\r\n            vars.feeLiquidated,\r\n            vars.liquidatedCollateralForFee,\r\n            vars.borrowBalanceIncrease,\r\n            _receiveAToken\r\n        );\r\n\r\n        AToken collateralAtoken = AToken(core.getReserveATokenAddress(_collateral));\r\n\r\n        //if liquidator reclaims the aToken, he receives the equivalent atoken amount\r\n        if (_receiveAToken) {\r\n            collateralAtoken.transferOnLiquidation(_user, msg.sender, maxCollateralToLiquidate);\r\n        } else {\r\n            //otherwise receives the underlying asset\r\n            //burn the equivalent amount of atoken\r\n            collateralAtoken.burnOnLiquidation(_user, maxCollateralToLiquidate);\r\n            core.transferToUser(_collateral, msg.sender, maxCollateralToLiquidate);\r\n        }\r\n\r\n        //transfers the principal currency to the pool\r\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, vars.actualAmountToLiquidate);\r\n\r\n        if (vars.feeLiquidated > 0) {\r\n            //if there is enough collateral to liquidate the fee, first transfer burn an equivalent amount of\r\n            //aTokens of the user\r\n            collateralAtoken.burnOnLiquidation(_user, vars.liquidatedCollateralForFee);\r\n\r\n            //then liquidate the fee by transferring it to the fee collection address\r\n            core.liquidateFee(\r\n                _collateral,\r\n                vars.liquidatedCollateralForFee,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n\r\n            emit OriginationFeeLiquidated(\r\n                _collateral,\r\n                _reserve,\r\n                _user,\r\n                vars.feeLiquidated,\r\n                vars.liquidatedCollateralForFee,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n\r\n        }\r\n        emit LiquidationCall(\r\n            _collateral,\r\n            _reserve,\r\n            _user,\r\n            vars.actualAmountToLiquidate,\r\n            maxCollateralToLiquidate,\r\n            vars.borrowBalanceIncrease,\r\n            msg.sender,\r\n            _receiveAToken,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n\r\n        return (uint256(LiquidationErrors.NO_ERROR), \"No errors\");\r\n    }\r\n\r\n    struct AvailableCollateralToLiquidateLocalVars {\r\n        uint256 userCompoundedBorrowBalance;\r\n        uint256 liquidationBonus;\r\n        uint256 collateralPrice;\r\n        uint256 principalCurrencyPrice;\r\n        uint256 maxAmountCollateralToLiquidate;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates how much of a specific collateral can be liquidated, given\r\n    * a certain amount of principal currency. This function needs to be called after\r\n    * all the checks to validate the liquidation have been performed, otherwise it might fail.\r\n    * @param _collateral the collateral to be liquidated\r\n    * @param _principal the principal currency to be liquidated\r\n    * @param _purchaseAmount the amount of principal being liquidated\r\n    * @param _userCollateralBalance the collatera balance for the specific _collateral asset of the user being liquidated\r\n    * @return the maximum amount that is possible to liquidated given all the liquidation constraints (user balance, close factor) and\r\n    * the purchase amount\r\n    **/\r\n    function calculateAvailableCollateralToLiquidate(\r\n        address _collateral,\r\n        address _principal,\r\n        uint256 _purchaseAmount,\r\n        uint256 _userCollateralBalance\r\n    ) internal view returns (uint256 collateralAmount, uint256 principalAmountNeeded) {\r\n        collateralAmount = 0;\r\n        principalAmountNeeded = 0;\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        AvailableCollateralToLiquidateLocalVars memory vars;\r\n\r\n        vars.collateralPrice = oracle.getAssetPrice(_collateral);\r\n        vars.principalCurrencyPrice = oracle.getAssetPrice(_principal);\r\n        vars.liquidationBonus = core.getReserveLiquidationBonus(_collateral);\r\n\r\n        //this is the maximum possible amount of the selected collateral that can be liquidated, given the\r\n        //max amount of principal currency that is available for liquidation.\r\n        vars.maxAmountCollateralToLiquidate = vars\r\n            .principalCurrencyPrice\r\n            .mul(_purchaseAmount)\r\n            .div(vars.collateralPrice)\r\n            .mul(vars.liquidationBonus)\r\n            .div(100);\r\n\r\n        if (vars.maxAmountCollateralToLiquidate > _userCollateralBalance) {\r\n            collateralAmount = _userCollateralBalance;\r\n            principalAmountNeeded = vars\r\n                .collateralPrice\r\n                .mul(collateralAmount)\r\n                .div(vars.principalCurrencyPrice)\r\n                .mul(100)\r\n                .div(vars.liquidationBonus);\r\n        } else {\r\n            collateralAmount = vars.maxAmountCollateralToLiquidate;\r\n            principalAmountNeeded = _purchaseAmount;\r\n        }\r\n\r\n        return (collateralAmount, principalAmountNeeded);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract LendingPoolAddressesProvider\",\"name\":\"_addressesProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_underlyingAssetDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"BalanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"BurnOnLiquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"InterestRedirectionAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"InterestStreamRedirected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"MintOnDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_targetBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_targetIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalanceAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalanceRemoved\",\"type\":\"uint256\"}],\"name\":\"RedirectedBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_MAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"allowInterestRedirectionTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnOnLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getInterestRedirectionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRedirectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintOnDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"principalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"redirectInterestStream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"redirectInterestStreamOf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferOnLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AToken", "CompilerVersion": "v0.5.14+commit.1f1aaa4", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000024a42fd28c976a61df5d00d0599c34c4f90748c8000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000194161766520496e7465726573742062656172696e67204554480000000000000000000000000000000000000000000000000000000000000000000000000000046145544800000000000000000000000000000000000000000000000000000000", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://7029b8e2a8a6dcf81be1753ab59bc1690f3f41e58fae43086d4df87ae569744a"}