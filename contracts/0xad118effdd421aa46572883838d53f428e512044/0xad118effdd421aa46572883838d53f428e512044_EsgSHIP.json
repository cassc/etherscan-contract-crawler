{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/EsgSHIP.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./LendingWhiteList.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\ncontract EsgSHIP is owned, LendingWhiteList {\\n\\tusing SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    EnumerableSet.AddressSet private _set;\\n\\n    /// @notice ESG token\\n    EIP20Interface public esg;\\n\\n    /// @notice Emitted when referral set referral\\n    event SetReferral(address referralAddress);\\n\\n    /// @notice Emitted when ESG is staked  \\n    event EsgStaked(address account, uint amount);\\n\\n    /// @notice Emitted when ESG is withdrawn \\n    event EsgWithdrawn(address account, uint amount);\\n\\n    /// @notice Emitted when ESG is claimed \\n    event EsgClaimed(address account, uint amount);\\n\\n    // @notice The rate every day. \\n    uint256 public dayEsgRate; \\n\\n    // @notice A checkpoint for staking\\n    struct Checkpoint {\\n        uint256 deposit_time; //last check time\\n        uint256 total_staked;\\n        uint256 bonus_unclaimed;\\n    }\\n\\n    // @notice staking struct of every account\\n    mapping (address => Checkpoint) public stakings;\\n\\n    mapping (address => EnumerableSet.AddressSet) inviteelist;//1:n\\n\\n\\tstruct User {\\n        address referrer_addr;\\n    }\\n\\n    mapping (address => User) referrerlist;//1:1\\n\\n    // @notice total stake amount\\n    uint256 public total_deposited;\\n    uint256 public referrer_rate;\\n    uint256 public ship_rate;\\n    uint256 public referrer_limit_num;\\n    uint256 public referrer_reward_limit_num;\\n    uint256 public ship_reward_limit_num;\\n\\n    constructor(address esgAddress) public {\\n        owner = msg.sender;\\n\\t\\tdayEsgRate = 1.37e15;\\n\\t\\treferrer_rate = 2e17;\\n\\t    ship_rate = 8e16;\\n\\t    referrer_limit_num = 1e21;\\n\\t    referrer_reward_limit_num = 1e21;\\n\\t    ship_reward_limit_num = 1e23;\\n\\t\\tesg = EIP20Interface(esgAddress);\\n    }\\n\\n    function setInvitee(address inviteeAddress) public returns (bool) {\\n    \\trequire(inviteeAddress != address(0), \\\"inviteeAddress should not be 0x0.\\\");\\n\\n    \\tEnumerableSet.AddressSet storage es = inviteelist[msg.sender];\\n    \\tUser storage user = referrerlist[inviteeAddress];\\n    \\trequire(user.referrer_addr == address(0), \\\"This account had been invited!\\\");\\n\\n    \\tCheckpoint storage cpt = stakings[inviteeAddress];\\n    \\trequire(cpt.total_staked == 0, \\\"This account had staked!\\\");\\n\\n    \\tCheckpoint storage cp = stakings[msg.sender];\\n\\n    \\tif(isWhitelisted(msg.sender)){\\n    \\t\\tEnumerableSet.add(es, inviteeAddress);  \\t\\n\\t    \\tuser.referrer_addr = msg.sender;\\n\\t    }else{\\n\\t    \\tif(cp.total_staked >= referrer_limit_num){\\n\\t    \\t\\tEnumerableSet.add(es, inviteeAddress);\\n\\t\\t    \\tuser.referrer_addr = msg.sender;\\n\\t\\t    }else{\\n\\t\\t        return false;\\n\\t\\t    }\\n\\t    }\\n    \\temit SetReferral(inviteeAddress);\\n        return true;   \\n    }\\n\\n    function getInviteelist(address referrerAddress) public view returns (address[] memory) {\\n    \\trequire(referrerAddress != address(0), \\\"referrerAddress should not be 0x0.\\\");\\n    \\tEnumerableSet.AddressSet storage es = inviteelist[referrerAddress];\\n    \\tuint256 _length = EnumerableSet.length(es);\\n    \\taddress[] memory _inviteelist = new address[](_length);\\n    \\tfor(uint i=0; i<EnumerableSet.length(es); i++){\\n    \\t\\t_inviteelist[i] = EnumerableSet.at(es,i);\\n    \\t}\\n    \\treturn _inviteelist;\\n    }\\n\\n    function getReferrer(address inviteeAddress) public view returns (address) {\\n    \\trequire(inviteeAddress != address(0), \\\"inviteeAddress should not be 0x0.\\\");\\n    \\tUser storage user = referrerlist[inviteeAddress];\\n    \\treturn user.referrer_addr;\\n    }\\n\\n    /**\\n     * @notice Stake ESG token to contract \\n     * @param amount The amount of address to be staked \\n     * @return Success indicator for whether staked \\n     */\\n    function stake(uint256 amount) public returns (bool) {\\n\\t\\trequire(amount > 0, \\\"No zero.\\\");\\n\\t\\trequire(amount <= esg.balanceOf(msg.sender), \\\"Insufficient ESG token.\\\");\\n\\n\\t\\tCheckpoint storage cp = stakings[msg.sender];\\n\\n\\t\\tesg.transferFrom(msg.sender, address(this), amount);\\n\\n\\t\\tif(cp.deposit_time > 0)\\n\\t\\t{\\n\\t\\t\\tuint256 bonus = block.timestamp.sub(cp.deposit_time).mul(cp.total_staked).mul(dayEsgRate).div(1e18).div(86400);\\n\\t\\t\\tcp.bonus_unclaimed = cp.bonus_unclaimed.add(bonus);\\n\\t\\t\\tcp.total_staked = cp.total_staked.add(amount);\\n\\t\\t\\tcp.deposit_time = block.timestamp;\\n\\t\\t}else\\n\\t\\t{\\n\\t\\t\\tcp.total_staked = amount;\\n\\t\\t\\tcp.deposit_time = block.timestamp;\\n\\t\\t}\\n\\t    total_deposited = total_deposited.add(amount);\\n\\t\\temit EsgStaked(msg.sender, amount);\\n\\n\\t\\treturn true;\\n    }\\n\\n    /**\\n     * @notice withdraw all ESG token staked in contract \\n     * @return Success indicator for success \\n     */\\n    function withdraw() public returns (bool) {\\n    \\t\\n    \\tCheckpoint storage cp = stakings[msg.sender];\\n\\t\\tuint256 amount = cp.total_staked;\\n\\t\\tuint256 bonus = block.timestamp.sub(cp.deposit_time).mul(cp.total_staked).mul(dayEsgRate).div(1e18).div(86400);\\n\\t\\tcp.bonus_unclaimed = cp.bonus_unclaimed.add(bonus);\\n\\t\\tcp.total_staked = 0;\\n\\t\\tcp.deposit_time = 0;\\n\\t    total_deposited = total_deposited.sub(amount);\\n\\t\\t\\n\\t\\tesg.transfer(msg.sender, amount);\\n\\n\\t\\temit EsgWithdrawn(msg.sender, amount); \\n\\n\\t\\treturn true;\\n    }\\n\\n    /**\\n     * @notice claim all ESG token bonus in contract \\n     * @return Success indicator for success \\n     */\\n    function claim() public returns (bool) {\\n\\t\\tUser storage user = referrerlist[msg.sender];\\n    \\taddress _referrer_addr = user.referrer_addr;\\n    \\tuint256 incentive;\\n    \\tuint256 incentive_holder;\\n\\n\\t\\tCheckpoint storage cp = stakings[msg.sender];\\n\\t\\tCheckpoint storage cpt = stakings[_referrer_addr];\\n\\n\\t\\tuint256 amount = cp.bonus_unclaimed;\\n\\t\\tif(cp.deposit_time > 0)\\n\\t\\t{\\n\\t\\t\\tuint256 bonus = block.timestamp.sub(cp.deposit_time).mul(cp.total_staked).mul(dayEsgRate).div(1e18).div(86400);\\n\\t\\t\\tamount = amount.add(bonus);\\n\\t\\t\\tcp.bonus_unclaimed = 0; \\n\\t\\t\\tcp.deposit_time = block.timestamp;\\n\\t\\t\\t\\n\\t\\t}else{\\n\\t\\t\\t//has beed withdrawn\\n\\t\\t\\tcp.bonus_unclaimed = 0;\\n\\t\\t}\\n\\n\\t\\tif(total_deposited >= ship_reward_limit_num){\\n\\t\\t\\tincentive_holder = amount.mul(ship_rate).div(1e18);\\n\\t\\t\\tif(_referrer_addr != address(0)){\\n\\t\\t\\t\\tif(cpt.total_staked >= referrer_reward_limit_num){\\n\\t\\t\\t\\t\\tincentive = amount.mul(referrer_rate).div(1e18);\\n\\t\\t\\t\\t\\tesg.transfer(_referrer_addr, incentive);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tesg.transfer(owner, incentive_holder);\\n\\t\\t\\t\\tesg.transfer(msg.sender, amount);\\n    \\t\\t}else\\n\\t    \\t{\\n\\t    \\t\\tesg.transfer(owner, incentive_holder);\\n\\t    \\t\\tesg.transfer(msg.sender, amount.sub(incentive_holder));\\n\\t    \\t}\\n\\t\\t}else\\n\\t\\t{\\n\\t\\t\\tif(_referrer_addr != address(0)){\\n\\t\\t\\t\\tif(cpt.total_staked >= referrer_reward_limit_num){\\n\\t\\t\\t\\t\\tincentive = amount.mul(referrer_rate).div(1e18);\\n\\t\\t\\t\\t\\tesg.transfer(_referrer_addr, incentive);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tesg.transfer(msg.sender, amount);\\n    \\t\\t}else\\n\\t    \\t{\\n\\t    \\t\\tesg.transfer(msg.sender, amount);\\n\\t    \\t}\\n\\t\\t}\\n\\n\\t\\temit EsgClaimed (msg.sender, amount); \\n\\n\\t\\treturn true;\\n    }\\n\\n    // set the dayrate\\n    function setDayEsgRate(uint256 dayRateMantissa) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    dayEsgRate = dayRateMantissa;\\n    }\\n\\n    // set referrerRate\\n    function setReferrerRate(uint256 referrerRateMantissa) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    referrer_rate = referrerRateMantissa;\\n    }\\n\\n    // set shipRate\\n    function setShipRate(uint256 shipRateMantissa) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    ship_rate = shipRateMantissa;\\n    }\\n\\n    // set referrerLimitNum\\n    function setReferrerLimitNum(uint256 referrerLimitNum) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    referrer_limit_num = referrerLimitNum;\\n    }\\n\\n    // set referrerRewardLimitNum\\n    function setReferrerRewardLimitNum(uint256 referrerRewardLimitNum) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    referrer_reward_limit_num = referrerRewardLimitNum;\\n    }\\n\\n    // set shipRewardLimitNum\\n    function setShipRewardLimitNum(uint256 shipRewardLimitNum) public{\\n\\t    require(msg.sender == owner, \\\"only owner can set this value.\\\");\\n\\t    ship_reward_limit_num = shipRewardLimitNum;\\n    }\\n\\n    function _withdrawERC20Token(address tokenAddress) external onlyOwner {\\n        require(tokenAddress != address(0), \\\"invalid address\\\");\\n        uint256 tokenAmount = esg.balanceOf(address(this));\\n        if(tokenAmount > 0)\\n            esg.transfer(msg.sender, tokenAmount);\\n        else\\n            revert(\\\"insufficient ERC20 tokens\\\");\\n    }\\n\\n    /**\\n     * @notice Returns the balance of ESG an account has staked\\n     * @param account The address of the account \\n     * @return balance of ESG \\n     */\\n    function getStakingBalance(address account) external view returns (uint256) {\\n\\t\\tCheckpoint memory cp = stakings[account];\\n        return cp.total_staked;\\n    }\\n\\n    /**\\n     * @notice Return the unclaimed bonus ESG of staking \\n     * @param account The address of the account \\n     * @return The amount of unclaimed ESG \\n     */\\n    function getUnclaimedEsg(address account) public view returns (uint256) {\\n\\t\\tCheckpoint memory cp = stakings[account];\\n\\n\\t\\tuint256 amount = cp.bonus_unclaimed;\\n\\t\\tif(cp.deposit_time > 0)\\n\\t\\t{\\n\\t\\t\\tuint256 bonus = block.timestamp.sub(cp.deposit_time).mul(cp.total_staked).mul(dayEsgRate).div(1e18).div(86400);\\n\\t\\t\\tamount = amount.add(bonus);\\n\\t\\t}\\n\\t\\treturn amount;\\n    }\\n\\n    /**\\n     * @notice Return the APY of staking \\n     * @return The APY multiplied 1e18\\n     */\\n    function getStakingAPYMantissa() public view returns (uint256) {\\n        return dayEsgRate.mul(365);\\n    }\\n\\n    /**\\n     * @notice Return the address of the ESG token\\n     * @return The address of ESG \\n     */\\n    function getEsgAddress() public view returns (address) {\\n        return address(esg);\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/owned.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\ncontract owned {\\n    address public owner;\\n \\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n \\n    modifier onlyOwner {\\n        require (msg.sender == owner);\\n        _;\\n    }\\n \\n    function transferOwnership(address newOwner) onlyOwner public {\\n        if (newOwner != address(0)) {\\n        owner = newOwner;\\n      }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    /**\\n   * @dev gives square root of given x.\\n   */\\n  function sqrt(uint256 x) internal pure returns(uint256 y) {\\n        uint256 z = ((add(x, 1)) / 2);\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = ((add((x / z), z)) / 2);\\n        }\\n  }\\n\\n  /**\\n   * @dev gives square. multiplies x by x\\n   */\\n  function sq(uint256 x) internal pure returns(uint256) {\\n       return (mul(x, x));\\n  }\\n\\n  /**\\n   * @dev x to the power of y\\n   */\\n  function pwr(uint256 x, uint256 y) internal pure returns(uint256) {\\n    if (x == 0)\\n      return (0);\\n    else if (y == 0)\\n      return (1);\\n    else {\\n      uint256 z = x;\\n      for (uint256 i = 1; i < y; i++)\\n        z = mul(z, x);\\n      return (z);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"/contracts/LendingWhiteList.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\ncontract LendingWhiteList is owned {\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    EnumerableSet.AddressSet private _whitelist;\\n\\n    event AddedToWhitelist(address indexed account);\\n    event RemovedFromWhitelist(address indexed account);\\n\\n    constructor() public {\\n    }\\n\\n    modifier onlyWhitelisted {\\n        require(isWhitelisted(msg.sender), \\\"LendingWhiteList: caller is not in whitelist\\\");\\n        _;\\n    }\\n\\n    function add(address _address) public onlyOwner returns(bool) {\\n        require(_address != address(0), \\\"LendingWhiteList: _address is the zero address\\\");\\n        EnumerableSet.add(_whitelist, _address);\\n        emit AddedToWhitelist(_address);\\n        return true;\\n    }\\n\\n    function remove(address _address) public onlyOwner returns(bool) {\\n        require(_address != address(0), \\\"LendingWhiteList: _address is the zero address\\\");\\n        EnumerableSet.remove(_whitelist, _address);\\n        emit RemovedFromWhitelist(_address);\\n        return true;\\n    }\\n\\n    function isWhitelisted(address _address) public view returns(bool) {\\n        return EnumerableSet.contains(_whitelist, _address);\\n    }\\n}\\n\\n    \\n\"\r\n    },\r\n    \"/contracts/EnumerableSet.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.16;\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/EIP20Interface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"esgAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EsgClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EsgStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EsgWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"SetReferral\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"_withdrawERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dayEsgRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"esg\",\"outputs\":[{\"internalType\":\"contract EIP20Interface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEsgAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"getInviteelist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"getReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakingAPYMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStakingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUnclaimedEsg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrer_limit_num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrer_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrer_reward_limit_num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayRateMantissa\",\"type\":\"uint256\"}],\"name\":\"setDayEsgRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviteeAddress\",\"type\":\"address\"}],\"name\":\"setInvitee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referrerLimitNum\",\"type\":\"uint256\"}],\"name\":\"setReferrerLimitNum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referrerRateMantissa\",\"type\":\"uint256\"}],\"name\":\"setReferrerRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referrerRewardLimitNum\",\"type\":\"uint256\"}],\"name\":\"setReferrerRewardLimitNum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shipRateMantissa\",\"type\":\"uint256\"}],\"name\":\"setShipRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shipRewardLimitNum\",\"type\":\"uint256\"}],\"name\":\"setShipRewardLimitNum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ship_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ship_reward_limit_num\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus_unclaimed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EsgSHIP", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "00000000000000000000000055625424a8eff4f960421646d3f67466cab80dc9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}