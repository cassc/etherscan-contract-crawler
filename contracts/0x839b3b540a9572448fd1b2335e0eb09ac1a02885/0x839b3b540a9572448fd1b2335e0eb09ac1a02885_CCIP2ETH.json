{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CCIP2ETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL.ETH\\npragma solidity >0.8.0 <0.9.0;\\n\\nimport \\\"./Interface.sol\\\";\\n\\n/**\\n * @title Off-Chain ENS Records Manager\\n * @author freetib.eth, sshmatrix.eth [https://github.com/namesys-eth]\\n * Github : https://github.com/namesys-eth/ccip2-eth-resolver\\n * Client : https://namesys.eth.limo\\n */\\ncontract CCIP2ETH is iCCIP2ETH {\\n    /// @dev - Revert on fallback\\n    fallback() external payable {\\n        revert();\\n    }\\n\\n    /// @dev - Receive donation\\n    receive() external payable {\\n        emit ThankYou(msg.sender, msg.value);\\n    }\\n\\n    /// Events\\n    event ThankYou(address indexed addr, uint256 indexed value);\\n    event GatewayUpdated(address indexed oldAddr, address indexed newAddr);\\n    event RecordhashUpdated(address indexed owner, bytes32 indexed node, bytes contenthash);\\n    event UpdatedWrapper(address indexed newAddr, bool indexed status);\\n    event ApprovedSigner(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved);\\n    event InterfaceUpdated(bytes4 indexed sig, bool indexed status);\\n\\n    /// Errors\\n    error InvalidSignature(string _message);\\n    error InvalidRequest(string _message);\\n    error BadConfig(string _message);\\n    error NotAuthorised(string _message);\\n    error PlsFundDevs();\\n\\n    /// @dev - ENS Legacy Registry\\n    iENS public immutable ENS = iENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\n    /// @dev - CCIP-Read Gateways\\n    iGatewayManager public gateway;\\n    /// @dev - Deployed Chain ID\\n    string chainID;\\n    /// @dev - Fee to set ownerhash\\n    uint256 public ownerhashFees = 0;\\n\\n    /// Mappings\\n    /**\\n     * @dev - Domain-specific contenthash storing all other records\\n     * @notice - Should be in generic ENS contenthash format or base32/base36 string URL format\\n     */\\n    mapping(bytes32 => bytes) public recordhash;\\n    /// @dev - On-chain singular Manager database\\n    /// Note - Manager (= isApprovedSigner) is someone who can manage off-chain records for a domain on behalf of its owner\\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public isApprovedSigner;\\n    /// @dev - List of all wrapping contracts to be declared in contructor\\n    mapping(address => bool) public isWrapper;\\n\\n    /// Interfaces\\n    mapping(bytes4 => bool) public supportsInterface;\\n\\n    /// @dev - Constructor\\n    constructor(address _gateway) {\\n        gateway = iGatewayManager(_gateway);\\n        chainID = block.chainid == 1 ? \\\"1\\\" : \\\"5\\\"; // Set ChainID\\n        /// @dev - Sets ENS Mainnet wrapper as Wrapper\\n        isWrapper[0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401] = true;\\n        emit UpdatedWrapper(0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401, true);\\n\\n        /// @dev - Set necessary interfaces\\n        supportsInterface[iERC165.supportsInterface.selector] = true;\\n        supportsInterface[iENSIP10.resolve.selector] = true;\\n        supportsInterface[type(iERC173).interfaceId] = true;\\n        supportsInterface[iCCIP2ETH.setRecordhash.selector] = true;\\n        supportsInterface[iCCIP2ETH.setOwnerhash.selector] = true;\\n        supportsInterface[iCallbackType.signedRecord.selector] = true;\\n        supportsInterface[iCallbackType.signedRedirect.selector] = true;\\n    }\\n\\n    /**\\n     * @dev Gets recordhash for a node\\n     * @param _node - Namehash of domain.eth, or bytes32(address _Owner)\\n     * @return _recordhash - IPNS contenthash that is set as recordhash\\n     */\\n    function getRecordhash(bytes32 _node) external view returns (bytes memory _recordhash) {\\n        _recordhash = recordhash[_node];\\n        if (_recordhash.length == 0) {\\n            address _owner = ENS.owner(_node);\\n            if (isWrapper[_owner]) {\\n                _owner = iToken(_owner).ownerOf(uint256(_node));\\n            }\\n            _recordhash = recordhash[bytes32(uint256(uint160(_owner)))];\\n        }\\n        if (_recordhash.length == 32 && !gateway.isWeb2(_recordhash)) {\\n            _recordhash = abi.encodePacked(hex\\\"e5010172002408011220\\\", _recordhash);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets regular recordhash for a node\\n     * Note - Only ENS owner or manager of node can call\\n     * @param _node - Namehash of domain.eth\\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\\n     */\\n    function setRecordhash(bytes32 _node, bytes calldata _recordhash) external payable {\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\\n            revert NotAuthorised(\\\"NOT_APPROVED\\\");\\n        }\\n        recordhash[_node] = _recordhash;\\n        emit RecordhashUpdated(msg.sender, _node, _recordhash);\\n    }\\n\\n    /**\\n     * @dev Sets short recordhash for a node\\n     * Note - Without the constant prefix hex'e5010172002408011220'\\n     * Note - Only ENS owner or manager of node can call\\n     * @param _node - Namehash of domain.eth\\n     * @param _recordhash - Short IPNS contenthash to set as recordhash\\n     */\\n    function setShortRecordhash(bytes32 _node, bytes32 _recordhash) external payable {\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\\n            revert NotAuthorised(\\\"NOT_APPROVED\\\");\\n        }\\n        recordhash[_node] = abi.encodePacked(_recordhash);\\n        emit RecordhashUpdated(msg.sender, _node, abi.encodePacked(hex\\\"e5010172002408011220\\\", _recordhash));\\n    }\\n\\n    /**\\n     * @dev Sets ownerhash for an owner\\n     * Note - Wallet-specific fallback recordhash\\n     * @param _recordhash - Regular IPNS contenthash to set as ownerhash\\n     */\\n    function setOwnerhash(bytes calldata _recordhash) external payable {\\n        if (msg.value < ownerhashFees) {\\n            revert PlsFundDevs();\\n        }\\n        recordhash[bytes32(uint256(uint160(msg.sender)))] = _recordhash;\\n        emit RecordhashUpdated(msg.sender, bytes32(uint256(uint160(msg.sender))), _recordhash);\\n    }\\n\\n    /**\\n     * @dev Sets short ownerhash for an owner\\n     * Note - Without the constant prefix hex'e5010172002408011220'\\n     * Note - Wallet-specific fallback recordhash\\n     * @param _recordhash - Short IPNS contenthash to set as ownerhash\\n     */\\n    function setShortOwnerhash(bytes32 _recordhash) external payable {\\n        if (msg.value < ownerhashFees) {\\n            revert PlsFundDevs();\\n        }\\n        recordhash[bytes32(uint256(uint160(msg.sender)))] = abi.encodePacked(_recordhash);\\n        emit RecordhashUpdated(\\n            msg.sender, bytes32(uint256(uint160(msg.sender))), abi.encodePacked(hex\\\"e5010172002408011220\\\", _recordhash)\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets recordhash for a subnode\\n     * Note - Only ENS owner or manager of parent node can call\\n     * @param _node - Namehash of domain.eth\\n     * @param _subdomain - Subdomain labels; sub.domain.eth = \\\"sub\\\"\\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\\n     */\\n    function setSubRecordhash(bytes32 _node, string calldata _subdomain, bytes calldata _recordhash) external payable {\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\\n            revert NotAuthorised(\\\"NOT_APPROVED\\\");\\n        }\\n        bytes32 _namehash = keccak256(abi.encodePacked(_node, keccak256(bytes(_subdomain))));\\n        recordhash[_namehash] = _recordhash;\\n        emit RecordhashUpdated(msg.sender, _namehash, _recordhash);\\n    }\\n\\n    /**\\n     * @dev Sets recordhash for a subnode\\n     * Note - Only ENS owner or manager of parent node can call\\n     * @param _node - Namehash of domain.eth\\n     * @param _subdomain - Subdomain labels; a.b.c.domain.eth = [a, b, c]\\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\\n     */\\n    function setDeepSubRecordhash(bytes32 _node, string[] calldata _subdomain, bytes calldata _recordhash)\\n        external\\n        payable\\n    {\\n        bytes32 _namehash = _node;\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\\n            revert NotAuthorised(\\\"NOT_APPROVED\\\");\\n        }\\n        uint256 len = _subdomain.length;\\n        unchecked {\\n            while (len > 0) {\\n                _namehash = keccak256(abi.encodePacked(_namehash, keccak256(bytes(_subdomain[--len]))));\\n            }\\n        }\\n        recordhash[_namehash] = _recordhash;\\n        emit RecordhashUpdated(msg.sender, _namehash, _recordhash);\\n    }\\n\\n    /**\\n     * @dev EIP-2544/EIP-3668 core resolve() function; aka CCIP-Read\\n     * @param name - ENS domain to resolve; must be DNS encoded\\n     * @param request - Encoding-specific function to resolve\\n     * @return result - Triggers Off-chain Lookup\\n     * Note - Return value is not used\\n     */\\n    function resolve(bytes calldata name, bytes calldata request) external view returns (bytes memory) {\\n        unchecked {\\n            /// @dev - DNSDecode() routine\\n            uint256 index = 1;\\n            uint256 n = 1;\\n            uint256 len = uint8(bytes1(name[0]));\\n            bytes[] memory _labels = new bytes[](42);\\n            _labels[0] = name[1:n += len];\\n            string memory _path = string(_labels[0]);\\n            string memory _domain = _path;\\n            while (name[n] > 0x0) {\\n                len = uint8(bytes1(name[n:++n]));\\n                _labels[index] = name[n:n += len];\\n                _domain = string.concat(_domain, \\\".\\\", string(_labels[index]));\\n                _path = string.concat(string(_labels[index++]), \\\"/\\\", _path);\\n            }\\n            bytes32 _namehash = keccak256(abi.encodePacked(bytes32(0), keccak256(_labels[--index])));\\n            bytes32 _node;\\n            bytes memory _recordhash;\\n            // Evaluate 'closest-set' parent node\\n            while (index > 0) {\\n                _namehash = keccak256(abi.encodePacked(_namehash, keccak256(_labels[--index])));\\n                // Check if sub(domain) exists on-chain or off-chain\\n                if (ENS.recordExists(_namehash)) {\\n                    _node = _namehash;\\n                    _recordhash = recordhash[_namehash];\\n                } else if (bytes(recordhash[_namehash]).length > 0) {\\n                    _recordhash = recordhash[_namehash];\\n                }\\n            }\\n            address _owner = ENS.owner(_node);\\n            // Update ownership if domain is wrapped\\n            if (isWrapper[_owner]) {\\n                _owner = iToken(_owner).ownerOf(uint256(_node));\\n            }\\n            if (_recordhash.length == 0) {\\n                _recordhash = recordhash[bytes32(uint256(uint160(_owner)))];\\n            }\\n            string memory _recType = gateway.funcToJson(request); // Filename for the requested record\\n            bytes32 _checkhash =\\n                keccak256(abi.encodePacked(this, blockhash(block.number - 1), _owner, _domain, _recType, request));\\n            revert OffchainLookup(\\n                address(this),\\n                gateway.randomGateways(\\n                    _recordhash, string.concat(\\\"/.well-known/\\\", _path, \\\"/\\\", _recType), uint256(_checkhash)\\n                ), // Generate pseudo-random list of gateways for record resolution\\n                abi.encodePacked(uint16(block.timestamp / 60)), // Cache = 60 seconds\\n                iCCIP2ETH.__callback.selector, // Callback function\\n                abi.encode(_node, block.number - 1, _checkhash, _domain, _recType, _path, name, request)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Default Callback function\\n     * @param response - Response of CCIP-Read call\\n     * @param extradata - Extra data used by callback\\n     * @return result - Concludes Off-chain Lookup\\n     * Note - Return value is not used\\n     */\\n    function __callback(bytes calldata response, bytes calldata extradata)\\n        external\\n        view\\n        returns (bytes memory result)\\n    {\\n        /// Get signer-type from response identifier\\n        bytes4 _type = bytes4(response[:4]);\\n        if (!supportsInterface[_type]) {\\n            /// @dev Future features in __fallback\\n            return gateway.__fallback(response, extradata);\\n        }\\n        (\\n            bytes32 _node, // Namehash of base owned ENS domain\\n            uint256 _blocknumber, // Blocknumber for timeout checks\\n            bytes32 _checkhash, // Extra checkhash\\n            string memory _domain, // String-formatted complete 'a.b.c.domain.eth'\\n            string memory _recType, // Record type\\n            , // Complete reverse-DNS path for __fallback()\\n            , // DNS-encoded domain.eth\\n            bytes memory _request // Format: <bytes4> + <namehash> + <extradata>\\n        ) = abi.decode(extradata, (bytes32, uint256, bytes32, string, string, string, bytes, bytes));\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        /// @dev - Timeout in 6 blocks\\n        if (block.number > _blocknumber + 7) {\\n            revert InvalidRequest(\\\"BLOCK_TIMEOUT\\\");\\n        }\\n        /// @dev - Verify checkhash\\n        if (\\n            _checkhash\\n                != keccak256(abi.encodePacked(this, blockhash(_blocknumber), _owner, _domain, _recType, _request))\\n        ) {\\n            revert InvalidRequest(\\\"BAD_CHECKSUM\\\");\\n        }\\n        // Signer could be:\\n        // a) Owner\\n        // OR, b) On-chain approved manager\\n        // OR, c) Off-chain approved signer\\n        address _signer;\\n        /// Signature associated with the record\\n        bytes memory _recordSignature;\\n        /// Init off-chain manager's signature request\\n        string memory signRequest;\\n        /// Off-chain signature approving record signer (if signer != owner or on-chain manager)\\n        bytes memory _approvedSig;\\n        /// @dev CCIP-Read response decode\\n        (_signer, _recordSignature, _approvedSig, result) = abi.decode(response[4:], (address, bytes, bytes, bytes));\\n        if (_approvedSig.length < 64) {\\n            if (_signer != _owner && !isApprovedSigner[_owner][_node][_signer]) {\\n                revert NotAuthorised(\\\"NOT_APPROVED\\\");\\n            }\\n        } else if (!approvedSigner(_owner, _signer, _node, _approvedSig, _domain)) {\\n            revert NotAuthorised(\\\"BAD_APPROVAL\\\");\\n        }\\n        if (_type == iCallbackType.signedRecord.selector) {\\n            /// @dev If 'signedRecord()' bytes4 selector; handles signed records\\n            signRequest = string.concat(\\n                \\\"Requesting Signature To Update ENS Record\\\\n\\\",\\n                \\\"\\\\nOrigin: \\\",\\n                _domain,\\n                \\\"\\\\nRecord Type: \\\",\\n                _recType,\\n                \\\"\\\\nExtradata: 0x\\\",\\n                gateway.bytesToHexString(abi.encodePacked(keccak256(result)), 0),\\n                \\\"\\\\nSigned By: eip155:\\\",\\n                chainID,\\n                \\\":\\\",\\n                gateway.toChecksumAddress(_signer)\\n            );\\n            if (_signer != iCCIP2ETH(this).getSigner(signRequest, _recordSignature)) {\\n                revert InvalidRequest(\\\"BAD_SIGNED_RECORD\\\");\\n            }\\n        } else if (_type == iCallbackType.signedRedirect.selector) {\\n            /// @dev If 'signedRedirect()' bytes4 selector; handles redirected records\\n            if (result[0] == 0x0 || result[result.length - 1] != 0x0) {\\n                revert InvalidRequest(\\\"BAD_REDIRECT_REQUEST\\\");\\n            }\\n            // ENS dApp redirect\\n            // Result should be DNS encoded; result should NOT be ABI-encoded\\n            // Note Last byte is 0x00, meaning end of DNS-encoded stream\\n            (bytes4 _req, bytes32 _redirectNamehash, bytes memory _redirectRequest, string memory _redirectDomain) =\\n                iCCIP2ETH(this).redirectService(result, _request);\\n            signRequest = string.concat(\\n                \\\"Requesting Signature To Install dApp Service\\\\n\\\",\\n                \\\"\\\\nOrigin: \\\",\\n                _domain, // e.g. ens.domain.eth\\n                \\\"\\\\nApp: \\\",\\n                _redirectDomain, // e.g. app.ens.eth\\n                \\\"\\\\nExtradata: 0x\\\",\\n                gateway.bytesToHexString(abi.encodePacked(keccak256(result)), 0),\\n                \\\"\\\\nSigned By: eip155:\\\",\\n                chainID,\\n                \\\":\\\",\\n                gateway.toChecksumAddress(_signer)\\n            );\\n            if (_signer != iCCIP2ETH(this).getSigner(signRequest, _recordSignature)) {\\n                revert InvalidRequest(\\\"BAD_DAPP_SIGNATURE\\\");\\n            }\\n            address _resolver = ENS.resolver(_redirectNamehash); // Owned node\\n            if (iERC165(_resolver).supportsInterface(iENSIP10.resolve.selector)) {\\n                return iENSIP10(_resolver).resolve(result, _redirectRequest);\\n            } else if (iERC165(_resolver).supportsInterface(_req)) {\\n                bool ok;\\n                (ok, result) = _resolver.staticcall(_redirectRequest);\\n                if (!ok) {\\n                    revert InvalidRequest(\\\"BAD_RESOLVER\\\");\\n                }\\n            } else {\\n                revert InvalidRequest(\\\"BAD_FUNCTION\\\");\\n            }\\n        } else {\\n            /// @dev Future features in __fallback\\n            return gateway.__fallback(response, extradata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Redirects the CCIP-Read request to another ENS Domain\\n     * @param _encoded - ENS domain to resolve; must be DNS encoded\\n     * @param _requested - Originally requested encoding-specific function to resolve\\n     * @return _selector - Redirected function selector\\n     * @return _namehash - Redirected namehash\\n     * @return _redirectRequest - Redirected request\\n     * @return domain - String-formatted ENS domain\\n     */\\n    function redirectService(bytes calldata _encoded, bytes calldata _requested)\\n        external\\n        view\\n        returns (bytes4 _selector, bytes32 _namehash, bytes memory _redirectRequest, string memory domain)\\n    {\\n        uint256 index = 1;\\n        uint256 n = 1;\\n        uint256 len = uint8(bytes1(_encoded[0]));\\n        bytes[] memory _labels = new bytes[](42);\\n        _labels[0] = _encoded[1:n += len];\\n        domain = string(_labels[0]);\\n        while (_encoded[n] > 0x0) {\\n            len = uint8(bytes1(_encoded[n:++n]));\\n            _labels[index] = _encoded[n:n += len];\\n            domain = string.concat(domain, \\\".\\\", string(_labels[index]));\\n        }\\n        bytes32 _owned;\\n        _namehash = keccak256(abi.encodePacked(bytes32(0), keccak256(_labels[--index])));\\n        while (index > 0) {\\n            _namehash = keccak256(abi.encodePacked(_namehash, keccak256(_labels[--index])));\\n            if (ENS.recordExists(_namehash)) {\\n                _owned = _namehash;\\n            }\\n        }\\n        if (_owned == bytes32(0)) {\\n            revert InvalidRequest(\\\"NOT_REGISTERED\\\");\\n        }\\n        _selector = bytes4(_requested[:4]);\\n        _redirectRequest = abi.encodePacked(_selector, _namehash, _requested.length > 36 ? _requested[36:] : bytes(\\\"\\\"));\\n        _namehash = _owned;\\n    }\\n\\n    /**\\n     * @dev Checks for manager access to an ENS domain for record management\\n     * @param _owner - Owner of ENS domain\\n     * @param _approvedSigner - Manager address to check\\n     * @param _node - Namehash of ENS domain\\n     * @param _signature - Signature to verify\\n     * @param _domain - String-formatted ENS domain\\n     * @return  - Whether manager is approved by the owner\\n     */\\n    function approvedSigner(\\n        address _owner,\\n        address _approvedSigner,\\n        bytes32 _node,\\n        bytes memory _signature,\\n        string memory _domain\\n    ) public view returns (bool) {\\n        address _signer = iCCIP2ETH(this).getSigner(\\n            string.concat(\\n                \\\"Requesting Signature To Approve ENS Records Signer\\\\n\\\",\\n                \\\"\\\\nOrigin: \\\",\\n                _domain,\\n                \\\"\\\\nApproved Signer: eip155:\\\",\\n                chainID,\\n                \\\":\\\",\\n                gateway.toChecksumAddress(_approvedSigner),\\n                \\\"\\\\nApproved By: eip155:\\\",\\n                chainID,\\n                \\\":\\\",\\n                gateway.toChecksumAddress(_owner)\\n            ),\\n            _signature\\n        );\\n        return (_signer == _owner || isApprovedSigner[_owner][_node][_signer]);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid\\n     * @param _message - String-formatted message that was signed\\n     * @param _signature - Compact signature to verify\\n     * @return _signer - Signer of message\\n     * @notice - Signature Format:\\n     * a) 64 bytes - bytes32(r) + bytes32(vs) ~ compact, or\\n     * b) 65 bytes - bytes32(r) + bytes32(s) + uint8(v) ~ packed, or\\n     * c) 96 bytes - bytes32(r) + bytes32(s) + uint256(v) ~ longest\\n     */\\n    function getSigner(string calldata _message, bytes calldata _signature) external view returns (address _signer) {\\n        bytes32 r = bytes32(_signature[:32]);\\n        bytes32 s;\\n        uint8 v;\\n        uint256 len = _signature.length;\\n        if (len == 64) {\\n            bytes32 vs = bytes32(_signature[32:]);\\n            s = vs & bytes32(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n            v = uint8((uint256(vs) >> 255) + 27);\\n        } else if (len == 65) {\\n            s = bytes32(_signature[32:64]);\\n            v = uint8(bytes1(_signature[64:]));\\n        } else if (len == 96) {\\n            s = bytes32(_signature[32:64]);\\n            v = uint8(uint256(bytes32(_signature[64:])));\\n        } else {\\n            revert InvalidSignature(\\\"BAD_SIG_LENGTH\\\");\\n        }\\n        if (s > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert InvalidSignature(\\\"INVALID_S_VALUE\\\");\\n        }\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", gateway.uintToString(bytes(_message).length), _message)\\n        );\\n        _signer = ecrecover(digest, v, r, s);\\n        if (_signer == address(0)) {\\n            revert InvalidSignature(\\\"ZERO_ADDR\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets a signer (= manager) as approved to manage records for a node\\n     * @param _node - Namehash of ENS domain\\n     * @param _signer - Address of signer (= manager)\\n     * @param _approval - Status to set\\n     */\\n    function approve(bytes32 _node, address _signer, bool _approval) external {\\n        isApprovedSigner[msg.sender][_node][_signer] = _approval;\\n        emit ApprovedSigner(msg.sender, _node, _signer, _approval);\\n    }\\n\\n    /**\\n     * @dev Sets multiple signers (= managers) as approved to manage records for a node\\n     * @param _node - Namehash[] of ENS domains\\n     * @param _signer - Address[] of signers (= managers)\\n     * @param _approval - Status[] to set\\n     */\\n    function multiApprove(bytes32[] calldata _node, address[] calldata _signer, bool[] calldata _approval) external {\\n        uint256 len = _node.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            isApprovedSigner[msg.sender][_node[i]][_signer[i]] = _approval[i];\\n            emit ApprovedSigner(msg.sender, _node[i], _signer[i], _approval[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if a signer (= manager) is approved to manage records for a node\\n     * @param _node - Namehash of ENS domain\\n     * @param _signer - Address of signer (= manager)\\n     */\\n    function approved(bytes32 _node, address _signer) public view returns (bool) {\\n        address _owner = ENS.owner(_node);\\n        if (isWrapper[_owner]) {\\n            _owner = iToken(_owner).ownerOf(uint256(_node));\\n        }\\n        return _owner == _signer || isApprovedSigner[_owner][_node][_signer];\\n    }\\n\\n    /// @dev : Management functions\\n\\n    /// @dev - Checks for admin privileges\\n    modifier OnlyDev() {\\n        if (msg.sender != gateway.owner()) {\\n            revert NotAuthorised(\\\"NOT_DEV\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev - Returns owner of the contract\\n    function owner() public view returns (address) {\\n        return gateway.owner();\\n    }\\n\\n    /// @dev - Updates ChainID in case of a hardfork\\n    function updateChainID() public {\\n        chainID = gateway.uintToString(block.chainid);\\n    }\\n    /**\\n     * @dev Sets fees for ownerhash\\n     * Note - Set to 0 at launch\\n     * @param _wei - Fees in WEI per EOA\\n     */\\n\\n    function updateOwnerhashFees(uint256 _wei) external OnlyDev {\\n        ownerhashFees = _wei;\\n    }\\n\\n    /**\\n     * @dev Updates supported interfaces\\n     * @param _sig - 4-byte interface selector\\n     * @param _set - State to set for selector\\n     */\\n    function updateInterface(bytes4 _sig, bool _set) external OnlyDev {\\n        if (_sig == iCallbackType.signedRecord.selector || _sig == iENSIP10.resolve.selector) {\\n            revert BadConfig(\\\"LOCKED_CALLBACK\\\");\\n        }\\n        supportsInterface[_sig] = _set;\\n        emit InterfaceUpdated(_sig, _set);\\n    }\\n\\n    /**\\n     * @dev Set new Gateway Manager Contract\\n     * @param _gateway - Address of new Gateway Manager Contract\\n     */\\n    function updateGateway(address _gateway) external OnlyDev {\\n        if (_gateway.code.length == 0) {\\n            revert BadConfig(\\\"BAD_GATEWAY\\\");\\n        }\\n        if (msg.sender != iGatewayManager(_gateway).owner()) {\\n            revert NotAuthorised(\\\"BAD_OWNER\\\");\\n        }\\n        emit GatewayUpdated(address(gateway), _gateway);\\n        gateway = iGatewayManager(_gateway);\\n    }\\n\\n    /**\\n     * @dev Add or remove ENS wrapper\\n     * @param _addr - Address of ENS wrapper\\n     * @param _set - State to set for new ENS wrapper\\n     */\\n    function updateWrapper(address _addr, bool _set) external OnlyDev {\\n        if (_addr.code.length == 0) {\\n            revert BadConfig(\\\"BAD_WRAPPER\\\");\\n        }\\n        isWrapper[_addr] = _set;\\n        emit UpdatedWrapper(_addr, _set);\\n    }\\n\\n    /**\\n     * @dev Withdraw Ether to owner; to be used for tips or in case some Ether gets locked in the contract\\n     */\\n    function withdraw() external {\\n        payable(gateway.owner()).transfer(address(this).balance);\\n    }\\n\\n    /**\\n     * @dev To be used for tips or in case some fungible tokens get locked in the contract\\n     * @param _contract - Token contract address\\n     * @param _balance - Amount to release\\n     */\\n    function withdraw(address _contract, uint256 _balance) external {\\n        iToken(_contract).transferFrom(address(this), gateway.owner(), _balance);\\n    }\\n\\n    /**\\n     * @dev To be used for tips or in case some non-fungible tokens get locked in the contract\\n     * @param _contract - Token contract address\\n     * @param _token - Token ID to release\\n     */\\n    function safeWithdraw(address _contract, uint256 _token) external {\\n        iToken(_contract).safeTransferFrom(address(this), gateway.owner(), _token);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL.ETH\\npragma solidity >0.8.0 <0.9.0;\\n\\ninterface iERC165 {\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\ninterface iERC173 {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n    function transferOwnership(address _newOwner) external;\\n}\\n\\ninterface iENS {\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\ninterface iENSIP10 {\\n    error OffchainLookup(address _to, string[] _gateways, bytes _data, bytes4 _callbackFunction, bytes _extradata);\\n\\n    function resolve(bytes memory _name, bytes memory _data) external view returns (bytes memory);\\n}\\n\\ninterface iCCIP2ETH is iENSIP10 {\\n    function __callback(bytes calldata _response, bytes calldata _extraData)\\n        external\\n        view\\n        returns (bytes memory _result);\\n\\n    function getSigner(string calldata _signRequest, bytes calldata _signature)\\n        external\\n        view\\n        returns (address _signer);\\n    function setRecordhash(bytes32 _node, bytes calldata _recordhash) external payable;\\n    function setShortRecordhash(bytes32 _node, bytes32 _recordhash) external payable;\\n    function setSubRecordhash(bytes32 _node, string memory _subdomain, bytes calldata _recordhash) external payable;\\n    function setDeepSubRecordhash(bytes32 _node, string[] memory _subdomains, bytes calldata _recordhash)\\n        external\\n        payable;\\n    function setOwnerhash(bytes calldata _recordhash) external payable;\\n    function redirectService(bytes calldata _encoded, bytes calldata _requested)\\n        external\\n        view\\n        returns (bytes4 _selector, bytes32 _namehash, bytes memory _redirectRequest, string memory _domain);\\n}\\n\\ninterface iGatewayManager is iERC173 {\\n    function randomGateways(bytes calldata _recordhash, string memory _path, uint256 k)\\n        external\\n        view\\n        returns (string[] memory gateways);\\n    function uintToString(uint256 value) external pure returns (string memory);\\n    function bytesToHexString(bytes calldata _buffer, uint256 _start) external pure returns (string memory);\\n    function bytes32ToHexString(bytes32 _buffer) external pure returns (string memory);\\n    function funcToJson(bytes calldata _request) external view returns (string memory _jsonPath);\\n    function toChecksumAddress(address _addr) external pure returns (string memory);\\n    function __fallback(bytes calldata response, bytes calldata extradata)\\n        external\\n        view\\n        returns (bytes memory result);\\n    function addFuncMap(bytes4 _func, string calldata _name) external;\\n    function listWeb2Gateways() external view returns (string[] memory list);\\n    function addWeb2Gateway(string calldata _domain) external;\\n    function removeWeb2Gateway(uint256 _index) external;\\n    function replaceWeb2Gateway(uint256 _index, string calldata _domain) external;\\n    function listWeb3Gateways() external view returns (string[] memory list);\\n    function addWeb3Gateway(string calldata _domain) external;\\n    function removeWeb3Gateway(uint256 _index) external;\\n    function replaceWeb3Gateway(uint256 _index, string calldata _domain) external;\\n    function formatSubdomain(bytes calldata _recordhash) external pure returns (string memory result);\\n    function isWeb2(bytes calldata _recordhash) external pure returns (bool);\\n}\\n\\ninterface iResolver {\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n    function addr(bytes32 node) external view returns (address payable);\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n    function text(bytes32 node, string calldata key) external view returns (string memory value);\\n    function name(bytes32 node) external view returns (string memory);\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\\n    function zonehash(bytes32 node) external view returns (bytes memory);\\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) external view returns (bytes memory);\\n    function recordVersions(bytes32 node) external view returns (uint64);\\n    function approved(bytes32 _node, address _signer) external view returns (bool);\\n}\\n\\ninterface iOverloadResolver {\\n    function addr(bytes32 node, uint256 coinType) external view returns (bytes memory);\\n    function dnsRecord(bytes32 node, bytes memory name, uint16 resource) external view returns (bytes memory);\\n}\\n\\ninterface iToken {\\n    function ownerOf(uint256 id) external view returns (address);\\n    function transferFrom(address from, address to, uint256 bal) external;\\n    function safeTransferFrom(address from, address to, uint256 bal) external;\\n}\\n\\n// Note - Owner = Owner of domain.eth\\n// Note - Manager = On-/Off-Chain address approved by Owner\\n// Note - Signer = Record signer\\ninterface iCallbackType {\\n    function signedRecord(\\n        address recordSigner, // Owner OR On-Chain Manager OR Off-Chain Manager\\n        bytes memory recordSignature, // Signature from signer for result value\\n        bytes memory approvedSignature, // bytes length >0 & <64 IF signer is owner or on-chain approved manager\\n        bytes memory result // ABI-encoded result\\n    ) external view returns (bytes memory);\\n\\n    function signedRedirect(\\n        address recordSigner, // Owner OR On-Chain Manager OR Off-Chain Manager\\n        bytes memory recordSignature, // Signature from signer for redirect value\\n        bytes memory approvedSignature, // bytes length >0 & <64 IF signer is owner or on-chain approved manager\\n        bytes memory redirect // DNS-encoded sub/domain.eth to redirect\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"BadConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"InvalidRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"NotAuthorised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"_gateways\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"_callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"_extradata\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlsFundDevs\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovedSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"GatewayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"InterfaceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"contenthash\",\"type\":\"bytes\"}],\"name\":\"RecordhashUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ThankYou\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdatedWrapper\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ENS\",\"outputs\":[{\"internalType\":\"contract iENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approval\",\"type\":\"bool\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"approved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_approvedSigner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"_domain\",\"type\":\"string\"}],\"name\":\"approvedSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract iGatewayManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"}],\"name\":\"getRecordhash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_recordhash\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWrapper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_node\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_signer\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_approval\",\"type\":\"bool[]\"}],\"name\":\"multiApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerhashFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"recordhash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_encoded\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_requested\",\"type\":\"bytes\"}],\"name\":\"redirectService\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_namehash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_redirectRequest\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"safeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"string[]\",\"name\":\"_subdomain\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"_recordhash\",\"type\":\"bytes\"}],\"name\":\"setDeepSubRecordhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_recordhash\",\"type\":\"bytes\"}],\"name\":\"setOwnerhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_recordhash\",\"type\":\"bytes\"}],\"name\":\"setRecordhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_recordhash\",\"type\":\"bytes32\"}],\"name\":\"setShortOwnerhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_recordhash\",\"type\":\"bytes32\"}],\"name\":\"setShortRecordhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_subdomain\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_recordhash\",\"type\":\"bytes\"}],\"name\":\"setSubRecordhash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateChainID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"}],\"name\":\"updateGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_sig\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"updateInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"updateOwnerhashFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"updateWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CCIP2ETH", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009d79ff2ec00b812e32d9768d88782101cb08d875", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}