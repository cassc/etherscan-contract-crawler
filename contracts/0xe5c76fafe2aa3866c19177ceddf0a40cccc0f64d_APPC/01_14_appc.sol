// SPDX-License-Identifier: MIT
//                                                               ,,   ╗ææΦ╣M
//                                                      ,╓╗╗Φ╣╣╬╬╬`   ╟╬╬╬╬⌐
//                                               ,╓   ╣╬╬╣╬╬╬╬M  `    ╠╬╬╬╬⌐
//                  ╓,,               ,,       ║╬╬M  ²`  ╓╬╬╬╬H       ╠╬╬╬╬⌐
//                  ╣╬╬╬╬╬         ║╬╬╬╬╣µ     j╬╬⌐      ╓╬╬╬╬H       ╠╬╬╬╬⌐
//                 ║╬╬╣╬╬╬▌         ╬╬╬╬╬╬╣,   j╬╬⌐      ╓╬╬╬╬H       ╠╬╬╬╬⌐
//                ╓╬╬M ╣╬╬╬φ        ╬╬╣╬╬╬╬╬╣, j╬╬⌐      ╓╬╬╬╬H       ╠╬╬╬╬⌐
//               .╬╬M  ²╬╬╬╬µ       ╬╬M ╢╬╬╬╬╬Φ╗╬╬⌐      "╬╬╬╬H       ║╬╬╬╬æ
//               ╣╬╬╬╬╬╬╬╬╬╬╬       ╬╬M  `╢╬╬╬╬╬╬╬⌐      ╓╬╬╬╬#
//              ╣╬╬`     ╢╬╬╬╣      ╬╬M    `╢╬╬╬╬╬⌐      "`                 .,,,,
//             ╢╬╬╬       ╬╬╬╬æ     ╬╬¼       "╙╜╝            ,,,.        ╬╬╬╬╬╬╬╬╬╣µ
//                       ⁿ╜╜╜╝╝M   ╜╜╜╙                  ╓╗╣╬╬╬╬╬╬╬╣╗     ╬╬╬╬M ╙╬╬╬╬µ
//     ║╬╣Φæ╗╓,                               ,,╓╤     ╗╣╬╝"    ╙╬╬╬╬╬u   ╬╬╬╬M  ║╬╬╬▌
//     ║╬╬╬╬╢╣╬╬╣╦      ,╓╓╓╓,      ╓╦╗╗æµ    ╢╬▌    ╓╣╬╬M       ╙╬╬╬╬▌   ╬╬╬╬M ╓╬╬╣╜
//     ║╬╬╬╬  ║╬╬╬╣  ╓╣╬╬╬╣╝╝╣╬M    `╣╬╬╬╬µ  ╓╬╣    ╓╬╬╬╬         ╬╬╬╬▌   ╬╬╬╬M ``
//     ║╬╬╬╬  ╓╬╬╬╬  ╣╬╬╬╬            ╢╬╬╬╬╦╓╬╣     ╬╬╬╬╬        .╬╬╬╬`   ╬╬╬╬M
//     ║╬╬╬╬ ,╣╬╬╣┘  ╙╣╬╬╬╬æ╦,         ║╬╬╬╬╬╣      ╬╬╬╬╬        ╣╬╬╣`    ╬╬╬╬M
//     ║╬╬╬╬           ╙╣╬╬╬╬╬╬Φ,       ╙╬╬╬╬H      ║╬╬╬╬╬╗, ,╓æ╬╬╝^     ═╜╜╜╜╜¬
//     ║╬╬╬╬              "╙╣╬╬╬╬U      "╬╬╬╬H       `╝╣╬╬╬╬╬╣╝╜"
//     ╜╣╣╬╬         ╗,      ╬╬╬╬M      "╬╬╬╬U                           -╓╗╗╖╖╖╖╖,
//          `        ╙╣╬╣ΦΦ╣╣╬╬╣┘       ║╬╣╝╜╜              ,╓╗╗╗╦╓       ╬╬╬╬╣╣╬╬╬╬æ
//     ╓,               `"╙╙"`                          ,╗╣╬╣╝╝╣╬╬╬╬╣µ    ╬╬╬╬M  ╢╬╬╬▌
//     ║╬╬╬╬╣Φ╗µ                              ╗æΦM    ╓╣╬╬M     `╣╬╬╬╬φ   ╬╬╬╬M  ╣╬╬╬M
//     ║╬╬╬╬╙╢╬╬╬Φ     ╓╗æΦΦæ╖╦,    Φ╣╣╣╬φ    ╣╬M    ╣╬╬╬        ²╬╬╬╬╬   ╬╬╬╬M é╣╣╜`
//     ║╬╬╬╬  ╙╬╬╬╬  ║╬╬╬╬M╙╙╙╝M     ╢╬╬╬╬æ  ╣╬M    ╣╬╬╬M         ╬╬╬╬M   ╬╬╬╬M
//     ║╬╬╬╬  ╓╬╬╬╬  ╣╬╬╬╬,           ╙╬╬╬╬╣╣╬M     ╬╬╬╬╬        ╓╬╬╬╣    ╬╬╬╬M
//     ║╬╬╬╬ ═╣╣╝╜    ╢╬╬╬╬╬╣╦,        ╙╣╬╬╬╬M      ╬╬╬╬╬µ      ╓╣╬╬M     ╬╬╬╬φ
//     ║╬╬╬╬           `╙╢╬╬╬╬╬╬æ       j╬╬╬╬H      └╣╬╬╬╬╣╦╗╗æ╣╬╣╜      ""`````
//     ║╬╬╬╬               `╢╬╬╬╬M      "╬╬╬╬H        "╜╣╣╣╣╝╜╙`
//     "╙╜╝╣µ        ╣╦,    ╓╬╬╬╬`      "╬╬╬╬U                      ,¡╓╗╗╗æææ╗w
//                   '╜╣╬╬╬╬╬╬╣╜        ╝╜╜╙"`             ╓╗╗Φ╣M   ╙╬╬╬╬M╙╢╬╬╬╬
//                                                ,╓╗æ╣M    ╬╬╬╬M   ╓╬╬╬╬⌐ ╓╬╬╬╬M
//                                      ,,        ║╬╬╬╬     ╬╬╬╬M   ╓╬╬╬╬æΦ╣╬╬Ö
//                  ,╗Φ╣╣╬╬╣╣╣╣     ║╬╬╬╬         ║╬╬╬╬     ╬╬╬╬M   ╓╬╬╬╬M""╢╬╬╬æ
//                ╓╣╬╬╬╝╙````╙╝     ║╬╬╬╬         ║╬╬╬╬     ╬╬╬╬M   ╓╬╬╬╬⌐   ╬╬╬╬H
//                ╬╬╬╬╬             ║╬╬╬╬         ║╬╬╬╬     ╬╬╬╬M   ╓╬╬╬╬░  ║╬╬╬╣
//               ╓╬╬╬╬M             ║╬╬╬╬         ║╬╬╬╬    ╓╬╬╬╬M   ╓╬╬╬╬╬╬╬╬╣╝╜
//                ╬╬╬╬φ             ║╬╬╬╬         ╟╬╬╬╬æ╦╗╣M╬╬╬╣#   "``
//                ╙╬╬╬╬µ            ║╬╬╬╬     ╓    ╝╣╬╬╬╣╜  `
//                  ╢╬╬╬Φw,   ,╓æ   ║╬╬╬╬╣╣╣╬╬M
//                    ╙╝╣╬╬╬╬╬╬╣M   ╝╜╜╜╙"`
    


                                   
pragma solidity ^0.8.4;

import "openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";
import "openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";
import "openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "openzeppelin-contracts/contracts/utils/Counters.sol";

contract APPC is ERC721, ERC721URIStorage, Ownable, ERC721Burnable {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    mapping(uint => uint8) public tokenUses;
    mapping(uint => uint256) public tokenCredit;
    
    bool public socialCreditActive;
    bool public mintActive;

    uint256 public socialCreditUnitCost;
    uint256 public mintCost;
    uint256 public maxSupply;

    constructor(
        string memory _name,
        string memory _symbol,
        bool _socialCreditActive,
        bool _mintActive,
        uint256 _socialCreditUnitCost,
        uint256 _mintCost,
        uint256 _maxSupply
    ) ERC721(_name, _symbol) {
        socialCreditActive = _socialCreditActive;
        mintActive = _mintActive;
        socialCreditUnitCost = _socialCreditUnitCost;
        mintCost = _mintCost;
        maxSupply = _maxSupply;
    }

    //Pass in a mint token that you will use to mint an additional token with, each token can only be used twice to mint additional tokens.
    //Pass in an address to send the token you are minting to, this address must not be the address you are minting from.
    //The ether value of the transaction must be equal to the mint cost.
    function mint(address to, uint256 mintToken) public payable {
        require(mintActive == true, "Minting is not active");
        require(msg.value >= mintCost, "Insufficient funds");
        require(to != msg.sender, "Cannot mint to yourself");
        require(tokenUses[mintToken] <= 1, "Token has been used too many times");
        require(ownerOf(mintToken) == msg.sender, "You do not own this token");
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        require(tokenId <= maxSupply, "Token supply has reached max supply");
        _safeMint(to, tokenId);
        tokenUses[mintToken] += 1;
        tokenCredit[tokenId] = 10;
    }

    //Pass in a URI and the token ID you wish to assign the URI to. You must hold the token to assign a URI.
    function updateURI(uint256 tokenId, string memory uri) public {
        require(ownerOf(tokenId) == msg.sender, "You do not own this token");
        _setTokenURI(tokenId, uri);
    }

    //Pass in a token ID and the increment you wish to add to the token's credit. You must hold a token to add credit.
    //The ether value of the transaction must be equal to the credit increment times the unit cost of social credit.
    function increaseTokenCredit(uint256 _increment, uint _targetID) public payable {
        require(socialCreditActive == true, "Social Credit is not active");
        require(balanceOf(msg.sender) >= 1, "You do not hold a token");
        require(_increment * socialCreditUnitCost <= msg.value, "Insufficient funds");
        tokenCredit[_targetID] += _increment;
    }

    //Pass in a token ID and a decrement you wish to remove from the token's credit. You must hold a token to remove credit.
    //The ether value of the transaction must be equal to the decrement times the unit cost of social credit.
    function decreaseTokenCredit(uint256 _decrement, uint _targetID) public payable {
        require(socialCreditActive == true, "Social Credit is not active");
        require(balanceOf(msg.sender) >= 1, "You do not hold a token");
        require(_decrement * socialCreditUnitCost <= msg.value, "Insufficient funds");
        if (tokenCredit[_targetID] - _decrement <= 0) {
            tokenCredit[_targetID] = 0;
            _burn(_targetID);
        } else {
            tokenCredit[_targetID] -= _decrement;
        }
    }

    //Owner only function to withdraw ether from the contract.
    function withdraw() external onlyOwner() {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }

    //Owner only function to premint tokens.
    function preMint() public onlyOwner {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(msg.sender, tokenId);
        tokenCredit[tokenId] = 1111;
    }

    //Owner only function to update any token ID's URI.
    function executiveURIUpdate(uint256 tokenId, string memory uri) public onlyOwner {
        _setTokenURI(tokenId, uri);
    }

    //Owner only function to update the max supply.
    function updateMaxSupply(uint256 _maxSupply) public onlyOwner {
        maxSupply = _maxSupply;
    }

    //Owner only function to update the mint cost.
    function updateMintCost(uint256 _mintCost) public onlyOwner {
        mintCost = _mintCost;
    }

    //Owner only function to update the social credit unit cost.
    function updateSocialCreditUnitCost(uint256 _socialCreditUnitCost) public onlyOwner {
        socialCreditUnitCost = _socialCreditUnitCost;
    }

    //Owner only function to activate social credit.
    function activateSocialCredit() public onlyOwner {
        socialCreditActive = true;
    }

    //Owner only function to deactivate social credit.
    function deactivateSocialCredit() public onlyOwner {
        socialCreditActive = false;
    }

    //Owner only function to activate minting.
    function activateMint() public onlyOwner {
        mintActive = true;
    }

    //Owner only function to deactivate minting.
    function deactivateMint() public onlyOwner {
        mintActive = false;
    }

    

    // The following functions are overrides required by Solidity.

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}