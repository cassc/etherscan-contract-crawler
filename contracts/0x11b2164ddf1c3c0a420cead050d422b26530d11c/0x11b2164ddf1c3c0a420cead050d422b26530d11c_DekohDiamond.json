{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC5267Upgradeable {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC5267Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\\n *\\n * _Available since v3.4._\\n *\\n * @custom:storage-size 52\\n */\\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @custom:oz-renamed-from _HASHED_NAME\\n    bytes32 private _hashedName;\\n    /// @custom:oz-renamed-from _HASHED_VERSION\\n    bytes32 private _hashedVersion;\\n\\n    string private _name;\\n    string private _version;\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\\n        __EIP712_init_unchained(name, version);\\n    }\\n\\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\\n        _name = name;\\n        _version = version;\\n\\n        // Reset prior values in storage if upgrading\\n        _hashedName = 0;\\n        _hashedVersion = 0;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator();\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev See {EIP-5267}.\\n     *\\n     * _Available since v4.9._\\n     */\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        override\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\\n        require(_hashedName == 0 && _hashedVersion == 0, \\\"EIP712: Uninitialized\\\");\\n\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            _EIP712Name(),\\n            _EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Name() internal virtual view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Version() internal virtual view returns (string memory) {\\n        return _version;\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\\n     */\\n    function _EIP712NameHash() internal view returns (bytes32) {\\n        string memory name = _EIP712Name();\\n        if (bytes(name).length > 0) {\\n            return keccak256(bytes(name));\\n        } else {\\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\\n            bytes32 hashedName = _hashedName;\\n            if (hashedName != 0) {\\n                return hashedName;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\\n     */\\n    function _EIP712VersionHash() internal view returns (bytes32) {\\n        string memory version = _EIP712Version();\\n        if (bytes(version).length > 0) {\\n            return keccak256(bytes(version));\\n        } else {\\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\\n            bytes32 hashedVersion = _hashedVersion;\\n            if (hashedVersion != 0) {\\n                return hashedVersion;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[48] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\nimport \\\"./math/SignedMathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMathUpgradeable.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\n\\n/**\\n * @title AccessControl interface\\n */\\ninterface IAccessControl is IAccessControlInternal {\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function renounceRole(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC2981Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC2981 interface\\n */\\ninterface IERC2981Internal {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/IPausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IPausableInternal {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IPausableInternal } from './IPausableInternal.sol';\\nimport { PausableStorage } from './PausableStorage.sol';\\n\\n/**\\n * @title Internal functions for Pausable security control module.\\n */\\nabstract contract PausableInternal is IPausableInternal {\\n    modifier whenNotPaused() {\\n        if (_paused()) revert Pausable__Paused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!_paused()) revert Pausable__NotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice query whether contract is paused\\n     * @return status whether contract is paused\\n     */\\n    function _paused() internal view virtual returns (bool status) {\\n        status = PausableStorage.layout().paused;\\n    }\\n\\n    /**\\n     * @notice Triggers paused state, when contract is unpaused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage.layout().paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Triggers unpaused state, when contract is paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        delete PausableStorage.layout().paused;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/pausable/PausableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary PausableStorage {\\n    struct Layout {\\n        bool paused;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Pausable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/common/ERC2981/ERC2981Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ERC2981Storage } from './ERC2981Storage.sol';\\nimport { IERC2981Internal } from '../../../interfaces/IERC2981Internal.sol';\\n\\n/**\\n * @title ERC2981 internal functions\\n */\\nabstract contract ERC2981Internal is IERC2981Internal {\\n    /**\\n     * @notice calculate how much royalty is owed and to whom\\n     * @dev royalty must be paid in addition to, rather than deducted from, salePrice\\n     * @param tokenId the ERC721 or ERC1155 token id to query for royalty information\\n     * @param salePrice the sale price of the given asset\\n     * @return royaltyReceiver rightful recipient of royalty\\n     * @return royalty amount of royalty owed\\n     */\\n    function _royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) internal view virtual returns (address royaltyReceiver, uint256 royalty) {\\n        uint256 royaltyBPS = _getRoyaltyBPS(tokenId);\\n\\n        // intermediate multiplication overflow is theoretically possible here, but\\n        // not an issue in practice because of practical constraints of salePrice\\n        return (_getRoyaltyReceiver(tokenId), (royaltyBPS * salePrice) / 10000);\\n    }\\n\\n    /**\\n     * @notice query the royalty rate (denominated in basis points) for given token id\\n     * @dev implementation supports per-token-id values as well as a global default\\n     * @param tokenId token whose royalty rate to query\\n     * @return royaltyBPS royalty rate\\n     */\\n    function _getRoyaltyBPS(\\n        uint256 tokenId\\n    ) internal view virtual returns (uint16 royaltyBPS) {\\n        ERC2981Storage.Layout storage l = ERC2981Storage.layout();\\n        royaltyBPS = l.royaltiesBPS[tokenId];\\n\\n        if (royaltyBPS == 0) {\\n            royaltyBPS = l.defaultRoyaltyBPS;\\n        }\\n    }\\n\\n    /**\\n     * @notice query the royalty receiver for given token id\\n     * @dev implementation supports per-token-id values as well as a global default\\n     * @param tokenId token whose royalty receiver to query\\n     * @return royaltyReceiver royalty receiver\\n     */\\n    function _getRoyaltyReceiver(\\n        uint256 tokenId\\n    ) internal view virtual returns (address royaltyReceiver) {\\n        ERC2981Storage.Layout storage l = ERC2981Storage.layout();\\n        royaltyReceiver = l.royaltyReceivers[tokenId];\\n\\n        if (royaltyReceiver == address(0)) {\\n            royaltyReceiver = l.defaultRoyaltyReceiver;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/common/ERC2981/ERC2981Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC2981Storage {\\n    struct Layout {\\n        // token id -> royalty (denominated in basis points)\\n        mapping(uint256 => uint16) royaltiesBPS;\\n        uint16 defaultRoyaltyBPS;\\n        // token id -> receiver address\\n        mapping(uint256 => address) royaltyReceivers;\\n        address defaultRoyaltyReceiver;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC2981');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\nimport { AddressUtils } from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    error SafeERC20__ApproveFromNonZeroToNonZero();\\n    error SafeERC20__DecreaseAllowanceBelowZero();\\n    error SafeERC20__OperationFailed();\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            if (oldAllowance < value)\\n                revert SafeERC20__DecreaseAllowanceBelowZero();\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(\\n                    token.approve.selector,\\n                    spender,\\n                    newAllowance\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n\\n        if (returndata.length > 0) {\\n            if (!abi.decode(returndata, (bool)))\\n                revert SafeERC20__OperationFailed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dekoh/DekohDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IDiamondCut } from \\\"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\\\";\\nimport { Diamond } from \\\"hardhat-deploy/solc_0.8/diamond/Diamond.sol\\\";\\n\\ncontract DekohDiamond is Diamond {\\n\\n    /// @notice This construct a diamond contract\\n    /// @param _contractOwner the owner of the contract. With default DiamondCutFacet, this is the sole address allowed to make further cuts.\\n    /// @param _diamondCut the list of facet to add\\n    /// @param _initializations the list of initialization pair to execute. This allow to setup a contract with multiple level of independent initialization.\\n    constructor(\\n        address _contractOwner,\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        Initialization[] memory _initializations\\n    ) payable Diamond(_contractOwner, _diamondCut, _initializations)\\n  {\\n  }\\n}\"\r\n    },\r\n    \"contracts/dekoh/DekohDiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title DekohDiamondStorage\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Storage for the diamond. This storage should only be used for \\n/// admin level data like intialization status.\\n/// Put all other data into facets and their storage.\\nlibrary DekohDiamondStorage {\\n    struct Layout {\\n        /// @dev Set to true when version 1 has been initialized.\\n        bool initializedV1;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.rojistudios.dekoh.storage.DekohDiamondStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/dekoh/facets/init-v1/DekohInitV1Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.8.19;\\n\\nimport {LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\nimport {UsingDiamondOwner} from \\\"hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol\\\";\\n\\nimport { IDekohInitV1Facet } from './IDekohInitV1Facet.sol';\\nimport { RolesLib } from '../../../facets/RolesLib.sol';\\nimport { AccessControlLib } from '../../../facets/AccessControl/AccessControlLib.sol';\\n\\nimport { MetadataNameSymbolUpdateLibERC721A } from '../../../facets/MetadataNameSymbolUpdate/MetadataNameSymbolUpdateLibERC721A.sol';\\nimport { BasicTokenURIStorage } from '../../../facets/BasicTokenURI/BasicTokenURIStorage.sol';\\nimport { FakeERC173Storage } from '../../../facets/FakeERC173/FakeERC173Storage.sol';\\nimport { ERC712Lib } from '../../../facets/ERC712/ERC712Lib.sol';\\nimport { RoyaltiesERC2981Lib } from '../../../facets/RoyaltiesERC2981/RoyaltiesERC2981Lib.sol';\\nimport { OperatorFiltererLib } from '../../../facets/OperatorFilterer/OperatorFiltererLib.sol';\\nimport { ROJIInterfacesLib } from '../../../interfaces/ROJIInterfacesLib.sol';\\nimport { DekohDiamondStorage } from '../../DekohDiamondStorage.sol';\\nimport { OpenSeaContractStorage } from \\\"../../../facets/OpenSeaContract/OpenSeaContractStorage.sol\\\";\\nimport { ERC721AStorage } from \\\"../../../facets/ERC721A/ERC721AStorage.sol\\\";\\n\\n\\n\\n/// @title DekohInitV1Facet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Initializer facet to be used on the verse diamond.\\ncontract DekohInitV1Facet is UsingDiamondOwner, IDekohInitV1Facet   {\\n\\n\\n  address constant ANIMEMEELABS = 0x328424E95EC34CC062627508efE55ad01988adAb;\\n\\n  /// @inheritdoc IDekohInitV1Facet\\n  function dekohInitV1( address adminUser, address diamondOwner ) external /* onlyOwner */ {\\n\\n    if(DekohDiamondStorage.layout().initializedV1) {\\n      revert AlreadyInitialized();\\n    }\\n    DekohDiamondStorage.layout().initializedV1 = true;\\n\\n\\n    // all the interfaces\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_ERC721] = true;\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_ERC721_METADATA] = true;\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_ERC4494] = true;\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_ERC2981] = true;\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_ROJI_VERSIONED_CONTRACT] = true;\\n    LibDiamond.diamondStorage().supportedInterfaces[ROJIInterfacesLib.INTERFACE_ID_IERC4906] = true;\\n\\n    AccessControlLib.grantRole(RolesLib.ROLE_ACCESS_CONTROL_ADMIN, adminUser);\\n    AccessControlLib.grantRole(RolesLib.ROLE_FINANCE, adminUser);\\n    AccessControlLib.grantRole(RolesLib.ROLE_OPERATIONS, adminUser);\\n    AccessControlLib.grantRole(RolesLib.ROLE_METADATA_UPDATE, adminUser);\\n    AccessControlLib.grantRole(RolesLib.ROLE_ADMIN_MINTING, adminUser);\\n    AccessControlLib.grantRole(RolesLib.ROLE_ADMIN_BURNING, adminUser);\\n\\n    BasicTokenURIStorage.layout().baseTokenURI = \\\"https://static.rojiapi.com/meta-animemelabs-dekoh/tokens/\\\";\\n    ERC712Lib.init(\\\"Animeme Labs\\\", \\\"1\\\");\\n    ERC721AStorage.layout()._currentIndex = 1; // This works together with _startTokenId being hardcoded to 1\\n    FakeERC173Storage.layout().owner = ANIMEMEELABS;\\n    MetadataNameSymbolUpdateLibERC721A._updateNameAndSymbol(\\\"Dekoh\\\", \\\"DEKOH\\\");\\n    OpenSeaContractStorage.layout().contractURI = \\\"https://static.rojiapi.com/meta-animemelabs-dekoh/contract.json\\\";\\n    OperatorFiltererLib._init();\\n    RoyaltiesERC2981Lib._setDefaultRoyalty(ANIMEMEELABS, 750);\\n    \\n    // Make this the last one, just for giggles\\n    LibDiamond.diamondStorage().contractOwner = diamondOwner;\\n  }\\n}\"\r\n    },\r\n    \"contracts/dekoh/facets/init-v1/IDekohInitV1Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n\\n/// @title IDekohInitV1Facet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Initializer facet to be used for the DekohDiamond contract.\\ninterface IDekohInitV1Facet {\\n\\n  /// @dev Error thrown when `dekohInitV1` is called after initialization\\n  error AlreadyInitialized();\\n\\n  /// @dev Initializes the diamond contract.\\n  /// @param adminUser the admin user for the facets.\\n  /// @param diamondOwner the controller of the diamond, including upgrading facets.\\n  function dekohInitV1(address adminUser, address diamondOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/AccessControl/AccessControlFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IAccessControlFacet } from \\\"./IAccessControlFacet.sol\\\";\\n\\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\\nimport { AddressUtils } from '@solidstate/contracts/utils/AddressUtils.sol';\\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\\nimport { IAccessControlInternal } from '@solidstate/contracts/access/access_control/IAccessControlInternal.sol';\\nimport { AccessControlStorage } from '@solidstate/contracts/access/access_control/AccessControlStorage.sol';\\nimport { UsingAccessControl } from './UsingAccessControl.sol';\\nimport { AccessControlLib} from './AccessControlLib.sol';\\nimport { IAccessControl } from \\\"@solidstate/contracts/access/access_control/IAccessControl.sol\\\";\\n\\n/// @title AccessControlFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Implements the facet for access control. This version of access control is not tied to\\n/// the ROJIVerse access control.\\ncontract AccessControlFacet is UsingAccessControl, IAccessControlFacet  {\\n  \\n     /// @inheritdoc IAccessControl\\n    function grantRole(\\n        bytes32 role,\\n        address account\\n    ) external onlyAccessControlAdmin {\\n        AccessControlLib.grantRole(role, account);\\n    }\\n\\n     /// @inheritdoc IAccessControl\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool) {\\n        return AccessControlLib.hasRole(role, account);\\n    }\\n\\n     /// @inheritdoc IAccessControl\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\\n        return AccessControlLib.getRoleAdmin(role);\\n    }\\n\\n     /// @inheritdoc IAccessControl\\n    function revokeRole(\\n        bytes32 role,\\n        address account\\n    ) external  onlyAccessControlAdmin {\\n        AccessControlLib.revokeRole(role, account);\\n    }\\n\\n     /// @inheritdoc IAccessControl\\n    function renounceRole(bytes32 role) external {\\n        AccessControlLib.renounceRole(role);\\n    }\\n\\n    /**\\n     * @notice Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) external view returns (address) {\\n        return AccessControlLib.getRoleMember(role, index);\\n    }\\n\\n    /**\\n     * @notice Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\\n        return AccessControlLib.getRoleMemberCount(role);\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"contracts/facets/AccessControl/AccessControlLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\\nimport { AddressUtils } from '@solidstate/contracts/utils/AddressUtils.sol';\\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\\nimport { AccessControlStorage } from '@solidstate/contracts/access/access_control/AccessControlStorage.sol';\\nimport {IAccessControlInternal } from \\\"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\\\";\\n\\n/// @title AccessControlLib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Functionality for access control outside of ROJIVerse.\\nlibrary AccessControlLib {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n\\n    // /// @dev The admin role for Access Control\\n    // /// 0x0000000000000000000000000000000000000000000000000000000000000000\\n    // bytes32 internal constant ROLE_ACCESS_CONTROL_ADMIN = bytes32(0);\\n\\n  /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    // /**\\n    //  * @notice revert if sender does not have given role\\n    //  * @param role role to query\\n    //  */\\n    // function checkRole(bytes32 role) internal view virtual {\\n    //     checkRole(role, msg.sender);\\n    // }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function getRoleAdmin(\\n        bytes32 role\\n    ) internal view returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function grantRole(bytes32 role, address account) internal  {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function revokeRole(bytes32 role, address account) internal {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function renounceRole(bytes32 role) internal  {\\n        revokeRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice query role for member at given index\\n     * @param role role to query\\n     * @param index index to query\\n     */\\n    function getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) internal view  returns (address) {\\n        return AccessControlStorage.layout().roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @notice query role for member count\\n     * @param role role to query\\n     */\\n    function getRoleMemberCount(\\n        bytes32 role\\n    ) internal view  returns (uint256) {\\n        return AccessControlStorage.layout().roles[role].members.length();\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/AccessControl/IAccessControlFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IAccessControl } from \\\"@solidstate/contracts/access/access_control/IAccessControl.sol\\\";\\n\\n/// @title Exposes a contractURI property that is used by opensea to retrieve collection metadata.\\n/// @author Martin Wawrusch for Roji Inc.\\ninterface IAccessControlFacet is IAccessControl {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/AccessControl/UsingAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { AccessControlLib } from './AccessControlLib.sol';\\nimport { RolesLib } from '../RolesLib.sol';\\n\\ninterface IUsingAccessControl {\\n    /// @dev The caller is not authorized.\\n    error MissingRole(bytes32 role, address account);\\n\\n}\\n\\n/// @title UsingSecurity\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice This contract provides modifiers for access control. Inherit from it and use the appropriate modifier.\\nabstract contract UsingAccessControl is IUsingAccessControl {\\n\\n  /// @dev Returns the sender. This can be overridden if necessary for meta transactions.\\n  /// @return The sender. Defaults to `msg.sender`.\\n  function _msgSenderROJI() internal view virtual returns (address) {\\n      return msg.sender;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the ROJIVerse `role`.\\n  /// @param role The role to check for.\\n  /// This checks against the ROJIVerse access control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlRole(bytes32 role) {\\n      AccessControlLib.checkRole(role, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_ACCESS_CONTROL_ADMIN` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlAdmin() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_ACCESS_CONTROL_ADMIN, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_FINANCE` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlFinance() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_FINANCE, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_OPERATIONS` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlOperations() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_OPERATIONS, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_METADATA_UPDATE` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlMetadataUpdate() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_METADATA_UPDATE, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_ADMIN_MINTING` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlAdminMinting() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_ADMIN_MINTING, _msgSenderROJI());\\n      _;\\n  }\\n\\n  /// @dev Ensures that the current sender is in the `ROLE_ADMIN_BURNING` role.\\n  /// This checks against the contracts access control control. The sender is retrieved through\\n  /// `_msgSenderROJI()`, which can be overridden in decendent contracts.\\n  modifier onlyAccessControlAdminBurning() {\\n    AccessControlLib.checkRole(RolesLib.ROLE_ADMIN_BURNING, _msgSenderROJI());\\n      _;\\n  }\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/facets/AdminMinterERC721A/AdminMinterERC721AFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IAdminMinterERC721AFacet } from \\\"./IAdminMinterERC721AFacet.sol\\\";\\nimport { UsingPausable } from '../Pausable/UsingPausable.sol';\\nimport { UsingAccessControl } from '../AccessControl/UsingAccessControl.sol';\\nimport {ERC721AUpgradeableInternal, ERC721AStorage} from '../../facets/ERC721A/ERC721AUpgradeableInternal.sol';\\n\\n/// @title AdminMinterERC721AFacetAccessControl\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Minting facet implementation for 1155 NFTs for admins.\\ncontract AdminMinterERC721AFacetAccessControl is  ERC721AUpgradeableInternal, UsingPausable, UsingAccessControl, IAdminMinterERC721AFacet   {\\n\\n    /// @inheritdoc IAdminMinterERC721AFacet\\n    function adminMint(address to,\\n                  uint256 quanity\\n                 ) external onlyAccessControlAdminMinting   { \\n\\n        _safeMint(to, quanity, \\\"\\\");\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/facets/AdminMinterERC721A/IAdminMinterERC721AFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IAdminMinterERC721AFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Facet that allows admins to mint 1155 NFTs.\\ninterface IAdminMinterERC721AFacet  {\\n\\n    /// @notice Mints an 1155 NFT with the specified quantity.\\n    /// @param to The address that should receive the NFT. If this is a contract, then the contract must be ERC1155 receiver conforming.\\n    /// @param quanity The quanity of the tokens to mint.\\n    function adminMint(address to,\\n                uint256 quanity\\n                 ) external;\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/BasicTokenURI/BasicTokenURIFacetERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IBasicTokenURIFacet } from \\\"./IBasicTokenURIFacet.sol\\\";\\nimport { BasicTokenURIStorage }  from \\\"./BasicTokenURIStorage.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\nimport { ERC721AUpgradeableInternal } from \\\"../ERC721A/ERC721AUpgradeableInternal.sol\\\";\\nimport { StringsUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport { MetadataUpdate4906Lib } from '../MetadataUpdate4906/MetadataUpdate4906Lib.sol';\\n\\n/// @title BasicTokenURIStorage\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Implements the facet for a basic token URI storage implementation. See `setBaseTokenURI` for details.\\ncontract BasicTokenURIERC721AFacet is ERC721AUpgradeableInternal, UsingAccessControl, IBasicTokenURIFacet  {\\n   using StringsUpgradeable for uint256;\\n \\n    /// @inheritdoc IBasicTokenURIFacet\\n    function tokenURI(uint256 tokenId) public view returns (string memory)\\n    {\\n        if(!_exists(tokenId)) {revert URIQueryForNonexistentToken(); }\\n        return string(abi.encodePacked(BasicTokenURIStorage.layout().baseTokenURI, tokenId.toString(), \\\".json\\\"));\\n    }\\n\\n    /// @inheritdoc IBasicTokenURIFacet\\n    function baseTokenURI() public view returns (string memory) {\\n        return BasicTokenURIStorage.layout().baseTokenURI;\\n    }\\n\\n    /// @inheritdoc IBasicTokenURIFacet\\n    function setBaseTokenURI(string calldata baseTokenURI_) external onlyAccessControlAdmin {\\n        BasicTokenURIStorage.layout().baseTokenURI = baseTokenURI_;\\n\\n        if(_nextTokenId() > _startTokenId()) {\\n            MetadataUpdate4906Lib._notifyBatchMetadataUpdated(_startTokenId(), _nextTokenId() - 1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/BasicTokenURI/BasicTokenURIStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary BasicTokenURIStorage {\\n    struct Layout {\\n        string baseTokenURI;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.BasicTokenURIStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/facets/BasicTokenURI/IBasicTokenURIFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IBasicTokenURIFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Defines the facet for a basic token URI storage implementation. See `setBaseTokenURI` for details.\\ninterface IBasicTokenURIFacet {\\n    \\n    /// @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n    /// Throws `URIQueryForNonexistentToken` if `tokenId` does not exist.\\n    /// @param tokenId uint256 ID of the token to query.\\n    /// @return string URI of given token.\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    /// @dev Returns the baseTokenURI which is used to construct the tokenURI. See `setBaseTokenURI` for details.\\n    /// @return string The baseTokenURI.\\n    function baseTokenURI() external view returns (string memory);\\n\\n    /// @dev Sets the baseTokenURI.\\n    /// The {tokenURI}, by default, is composed of baseTokenURI + tokenId + .json.\\n    /// Requires `ROLE_ROJI_ADMIN` membership.\\n    /// @param baseTokenURI_ The new baseTokenURI, which must end with a forward slash.\\n    /// Example: https://myserver.com/metadata/\\n    function setBaseTokenURI(string calldata baseTokenURI_) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/DiamondOwner/DiamondOwnerFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IDiamondOwnerFacet } from \\\"./IDiamondOwnerFacet.sol\\\";\\nimport { LibDiamond} from \\\"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\\\";\\nimport { DiamondOwnerStorage } from \\\"./DiamondOwnerStorage.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title DiamondOwnerStorage\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Implements the facet for a basic token URI storage implementation. See `setBaseTokenURI` for details.\\n/// Requires the `DiamondOrProxyFacet` to be present.\\ncontract DiamondOwnerFacetAccessControl is UsingAccessControl, IDiamondOwnerFacet  {\\n \\n    /// @inheritdoc IDiamondOwnerFacet\\n    function diamondOwner() view external returns(address) {\\n        return LibDiamond.contractOwner();\\n    }\\n\\n    /// @inheritdoc IDiamondOwnerFacet\\n     function nomineeDiamondOwner() external view returns (address){\\n        return DiamondOwnerStorage.layout().nomineeDiamondOwner;\\n    }\\n\\n    /// @inheritdoc IDiamondOwnerFacet\\n    function acceptDiamondOwnership() external {\\n        if(DiamondOwnerStorage.layout().nomineeDiamondOwner == address(0x0)){\\n            revert NomineeIsNotSet();\\n        }\\n\\n        if(DiamondOwnerStorage.layout().nomineeDiamondOwner != _msgSenderROJI()) {\\n            revert SenderIsNotNominee(_msgSenderROJI(), DiamondOwnerStorage.layout().nomineeDiamondOwner);\\n        }\\n\\n        address previousOwner = LibDiamond.diamondStorage().contractOwner;\\n        LibDiamond.diamondStorage().contractOwner = DiamondOwnerStorage.layout().nomineeDiamondOwner;\\n        emit DiamondOwnershipTransferred(previousOwner, DiamondOwnerStorage.layout().nomineeDiamondOwner);\\n        \\n    }\\n    /// @inheritdoc IDiamondOwnerFacet\\n    /// @param account The proposed new owner of the diamond. Can be 0 address.\\n    function transferDiamondOwnership(address account) external  {\\n        LibDiamond.enforceIsContractOwner();\\n        DiamondOwnerStorage.layout().nomineeDiamondOwner = account;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/DiamondOwner/DiamondOwnerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary DiamondOwnerStorage {\\n    struct Layout {\\n      /// The nominated new owner of the diamond.\\n      address nomineeDiamondOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.DiamondOwnerStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/DiamondOwner/IDiamondOwnerFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IDiamondOwnerFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Defines the facet for a basic token URI storage implementation. See `setBaseTokenURI` for details.\\ninterface IDiamondOwnerFacet {\\n\\n    /// @notice The sender is not the nominee, which is a requirement to accept a nomination.\\n    error SenderIsNotNominee(address sender, address nominee);\\n\\n    /// @notice The nominee is not set, which is a requirement to accept a nomination.\\n    error NomineeIsNotSet();\\n\\n    /// @notice Emitted when ownership of the diamond changes\\n    /// @param previousOwner The previous owner of the diamond.\\n    /// @param newOwner The new owner of the diamond.\\n    event DiamondOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    \\n    /// @notice Get the address of the owner    \\n    /// @return The address of the owner.\\n    function diamondOwner() view external returns(address);\\n\\n    /// @notice Get the nominated owner who has permission to call acceptOwnership\\n    /// @return The address of the nominated owner.\\n    function nomineeDiamondOwner() external view returns (address);\\n\\n    /// @notice Accept transfer of contract ownership\\n    function acceptDiamondOwnership() external;\\n\\n    /// @notice Grants permission to `account` to accept the diamond ownership.\\n    /// This can only be called on the diamond, never on the proxy.\\n    /// Requires the caller to be the current owner.\\n    /// @param account The proposed new owner of the diamond.\\n    function transferDiamondOwnership(address account) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC712/ERC712Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IERC712Facet } from \\\"./IERC712Facet.sol\\\";\\nimport { ERC712Storage } from \\\"./ERC712Storage.sol\\\";\\nimport { ERC712Storage } from './ERC712Storage.sol';\\nimport { ERC712Lib } from './ERC712Lib.sol';\\n\\n/// @title ERC712Facet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Implements the EIP712 domain separator and eip712Domain (EIP-5267) methods.\\n/// This provides the foundation for ERC-712 support.\\ncontract ERC712Facet is  IERC712Facet {\\n    \\n    /// @inheritdoc IERC712Facet\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return ERC712Lib._domainSeparatorV4();\\n    }\\n\\n    /// @inheritdoc IERC712Facet\\n    function eip712Domain()\\n        public\\n        view        \\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\\n        require(ERC712Storage.layout()._hashedName == 0 && ERC712Storage.layout()._hashedVersion == 0, \\\"EIP712: Uninitialized\\\");\\n\\n        return (\\n            hex\\\"0f\\\", // 01111\\n            ERC712Lib._EIP712Name(),\\n            ERC712Lib._EIP712Version(),\\n            block.chainid,\\n            address(this),\\n            bytes32(0),\\n            new uint256[](0)\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC712/ERC712Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport { ECDSAUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport { ERC712Storage } from './ERC712Storage.sol';\\n\\n/// @title ERC712Lib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Contains utility functions for the ERC712 implementation.\\nlibrary ERC712Lib {\\n    bytes32 internal constant _TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @dev Initializes the storage with app name and version\\n    /// @param name The name of the app as used for the EIP712 domain separator.\\n    /// @param version The version of the app as used for the EIP712 domain separator.\\n    function init(string memory name, string memory version) internal {\\n        ERC712Storage.Layout storage l = ERC712Storage.layout();\\n        // l._hashedName = keccak256(bytes(l._name));\\n        // l._hashedVersion = keccak256(bytes(l._version));\\n\\n        l._name = name;\\n        l._version = version;\\n\\n        // Reset prior values in storage if upgrading\\n        l._hashedName = 0;\\n        l._hashedVersion = 0;\\n    }\\n\\n    /// @dev Returns the domain separator for the current chain.\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator();\\n    }\\n\\n    function _buildDomainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    /**\\n     * @dev The name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Name() internal view returns (string memory) {\\n        return ERC712Storage.layout()._name;\\n    }\\n\\n    /**\\n     * @dev The version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712Version() internal view returns (string memory) {\\n        return ERC712Storage.layout()._version;\\n    }\\n\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\\n     */\\n    function _EIP712NameHash() internal view returns (bytes32) {\\n        string memory name = _EIP712Name();\\n        if (bytes(name).length > 0) {\\n            return keccak256(bytes(name));\\n        } else {\\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\\n            bytes32 hashedName = ERC712Storage.layout()._hashedName;\\n            if (hashedName != 0) {\\n                return hashedName;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\\n     */\\n    function _EIP712VersionHash() internal view returns (bytes32) {\\n        string memory version = _EIP712Version();\\n        if (bytes(version).length > 0) {\\n            return keccak256(bytes(version));\\n        } else {\\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\\n            bytes32 hashedVersion = ERC712Storage.layout()._hashedVersion;\\n            if (hashedVersion != 0) {\\n                return hashedVersion;\\n            } else {\\n                return keccak256(\\\"\\\");\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/ERC712/ERC712Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title ERC712Storage\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Storage for the ERC712 implementation.\\n/// Based upon OpenZeppelin's ERC712 implementation.\\nlibrary ERC712Storage {\\n\\n    struct Layout {\\n        bytes32  _hashedName;\\n        bytes32 _hashedVersion;\\n        string  _name;\\n        string  _version;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.ERC712Storage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/facets/ERC712/IERC712Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IERC712Facet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Exports the EIP712 domain separator and eip712Domain (EIP-5267) methods.\\n/// This provides the foundation for ERC-712 support.\\ninterface IERC712Facet {\\n  /// @notice Returns the domain separator used in the encoding of the signature for permits, as defined by EIP-712\\n  /// @return the bytes32 domain separator\\n  function DOMAIN_SEPARATOR() external view returns(bytes32);\\n\\n  /// @dev See {EIP-5267}.\\n  function eip712Domain() external view returns (\\n      bytes1 fields,\\n      string memory name,\\n      string memory version,\\n      uint256 chainId,\\n      address verifyingContract,\\n      bytes32 salt,\\n      uint256[] memory extensions\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC721A/ERC721AStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary ERC721AStorage {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n    \\n    struct Layout {\\n        // =============================================================\\n        //                            STORAGE\\n        // =============================================================\\n\\n        // The next token ID to be minted.\\n        uint256 _currentIndex;\\n        // The number of tokens burned.\\n        uint256 _burnCounter;\\n        // Token name\\n        string _name;\\n        // Token symbol\\n        string _symbol;\\n        // Mapping from token ID to ownership details\\n        // An empty struct value does not necessarily mean the token is unowned.\\n        // See {_packedOwnershipOf} implementation for details.\\n        //\\n        // Bits Layout:\\n        // - [0..159]   `addr`\\n        // - [160..223] `startTimestamp`\\n        // - [224]      `burned`\\n        // - [225]      `nextInitialized`\\n        // - [232..255] `extraData`\\n        mapping(uint256 => uint256) _packedOwnerships;\\n        // Mapping owner address to address data.\\n        //\\n        // Bits Layout:\\n        // - [0..63]    `balance`\\n        // - [64..127]  `numberMinted`\\n        // - [128..191] `numberBurned`\\n        // - [192..255] `aux`\\n        mapping(address => uint256) _packedAddressData;\\n        // Mapping from token ID to approved address.\\n        mapping(uint256 => ERC721AStorage.TokenApprovalRef) _tokenApprovals;\\n        // Mapping from owner to operator approvals\\n        mapping(address => mapping(address => bool)) _operatorApprovals;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256('ERC721A.contracts.storage.ERC721A');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC721A/ERC721AUpgradeableFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport {ERC721AUpgradeableInternal, ERC721AStorage} from './ERC721AUpgradeableInternal.sol';\\nimport { Permit4494Lib } from '../Permit4494/Permit4494Lib.sol';\\nimport {  UsingOperatorFilterer } from '../OperatorFilterer/UsingOperatorFilterer.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721ReceiverUpgradeable {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721AUpgradeableFacet is ERC721AUpgradeableInternal, UsingOperatorFilterer {\\n    using ERC721AStorage for ERC721AStorage.Layout;\\n    \\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return ERC721AStorage.layout()._currentIndex - ERC721AStorage.layout()._burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);\\n        return ERC721AStorage.layout()._packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return ERC721AStorage.layout()._name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return ERC721AStorage.layout()._symbol;\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     */\\n    function approve(address to, uint256 tokenId) public payable  onlyAllowedOperatorApproval(to)  virtual {\\n        _approve(to, tokenId, true);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);\\n\\n        return ERC721AStorage.layout()._tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public  onlyAllowedOperatorApproval(operator)  virtual {\\n        ERC721AStorage.layout()._operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return ERC721AStorage.layout()._operatorApprovals[owner][operator];\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual  onlyAllowedOperator(from) {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        // Mask `from` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n        from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS));\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --ERC721AStorage.layout()._packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++ERC721AStorage.layout()._packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            ERC721AStorage.layout()._packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n        uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\\n        assembly {\\n            // Emit the `Transfer` event.\\n            log4(\\n                0, // Start of data (0, since no data).\\n                0, // End of data (0, since no data).\\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                from, // `from`.\\n                toMasked, // `to`.\\n                tokenId // `tokenId`.\\n            )\\n        }\\n        if (toMasked == 0) _revert(TransferToZeroAddress.selector);\\n\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual onlyAllowedOperator(from) {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual onlyAllowedOperator(from) {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            }\\n    }\\n\\n\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n        Permit4494Lib._handleAfterTokenTransfers(startTokenId, quantity);\\n\\n        super._afterTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual override {\\n\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC721A/ERC721AUpgradeableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport {ERC721AStorage} from './ERC721AStorage.sol';\\nimport {IERC721AUpgradeable} from './IERC721AUpgradeable.sol';\\n\\ninterface ERC721A__IERC721ReceiverUpgradeable {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721AUpgradeableInternal is IERC721AUpgradeable {\\n    using ERC721AStorage for ERC721AStorage.Layout;\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 internal constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 internal constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 internal constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 internal constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 internal constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 internal constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 internal constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 internal constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 internal constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 internal constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 internal constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 internal constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 internal constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 internal constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 1; // NOTE - CUSTOMIZED HERE\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return ERC721AStorage.layout()._currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return ERC721AStorage.layout()._currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return ERC721AStorage.layout()._burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return\\n            (ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return\\n            (ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = ERC721AStorage.layout()._packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        ERC721AStorage.layout()._packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(ERC721AStorage.layout()._packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Returns whether the ownership slot at `index` is initialized.\\n     * An uninitialized slot does not necessarily mean that the slot has no owner.\\n     */\\n    function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {\\n        return ERC721AStorage.layout()._packedOwnerships[index] != 0;\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (ERC721AStorage.layout()._packedOwnerships[index] == 0) {\\n            ERC721AStorage.layout()._packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) internal view returns (uint256 packed) {\\n        if (_startTokenId() <= tokenId) {\\n            packed = ERC721AStorage.layout()._packedOwnerships[tokenId];\\n            // If the data at the starting slot does not exist, start the scan.\\n            if (packed == 0) {\\n                if (tokenId >= ERC721AStorage.layout()._currentIndex) _revert(OwnerQueryForNonexistentToken.selector);\\n                // Invariant:\\n                // There will always be an initialized ownership slot\\n                // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                // before an unintialized ownership slot\\n                // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                // Hence, `tokenId` will not underflow.\\n                //\\n                // We can directly compare the packed value.\\n                // If the address is zero, packed will be zero.\\n                for (;;) {\\n                    unchecked {\\n                        packed = ERC721AStorage.layout()._packedOwnerships[--tokenId];\\n                    }\\n                    if (packed == 0) continue;\\n                    if (packed & _BITMASK_BURNED == 0) return packed;\\n                    // Otherwise, the token is burned, and we must revert.\\n                    // This handles the case of batch burned tokens, where only the burned bit\\n                    // of the starting slot is set, and remaining slots are left uninitialized.\\n                    _revert(OwnerQueryForNonexistentToken.selector);\\n                }\\n            }\\n            // Otherwise, the data exists and we can skip the scan.\\n            // This is possible because we have already achieved the target condition.\\n            // This saves 2143 gas on transfers of initialized tokens.\\n            // If the token is not burned, return `packed`. Otherwise, revert.\\n            if (packed & _BITMASK_BURNED == 0) return packed;\\n        }\\n        _revert(OwnerQueryForNonexistentToken.selector);\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) internal pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) internal view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) internal pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool result) {\\n        if (_startTokenId() <= tokenId) {\\n            if (tokenId < ERC721AStorage.layout()._currentIndex) {\\n                uint256 packed;\\n                while ((packed = ERC721AStorage.layout()._packedOwnerships[tokenId]) == 0) --tokenId;\\n                result = packed & _BITMASK_BURNED == 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) internal pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        internal\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        ERC721AStorage.TokenApprovalRef storage tokenApproval = ERC721AStorage.layout()._tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        try\\n            ERC721A__IERC721ReceiverUpgradeable(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data)\\n        returns (bytes4 retval) {\\n            return retval == ERC721A__IERC721ReceiverUpgradeable(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\\n            }\\n            assembly {\\n                revert(add(32, reason), mload(reason))\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = ERC721AStorage.layout()._currentIndex;\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            ERC721AStorage.layout()._packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            ERC721AStorage.layout()._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\\n\\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\\n\\n            uint256 end = startTokenId + quantity;\\n            uint256 tokenId = startTokenId;\\n\\n            do {\\n                assembly {\\n                    // Emit the `Transfer` event.\\n                    log4(\\n                        0, // Start of data (0, since no data).\\n                        0, // End of data (0, since no data).\\n                        _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                        0, // `address(0)`.\\n                        toMasked, // `to`.\\n                        tokenId // `tokenId`.\\n                    )\\n                }\\n                // The `!=` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n            } while (++tokenId != end);\\n\\n            ERC721AStorage.layout()._currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = ERC721AStorage.layout()._currentIndex;\\n        if (to == address(0)) _revert(MintToZeroAddress.selector);\\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            ERC721AStorage.layout()._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            ERC721AStorage.layout()._packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            ERC721AStorage.layout()._currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = ERC721AStorage.layout()._currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        _revert(TransferToNonERC721ReceiverImplementer.selector);\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (ERC721AStorage.layout()._currentIndex != end) _revert(bytes4(0));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                       APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _approve(to, tokenId, false);\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n    \\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        bool approvalCheck\\n    ) internal virtual {\\n        address owner = _ownerOf(tokenId);\\n\\n        if (approvalCheck && _msgSenderERC721A() != owner)\\n            if (!_isApprovedForAll(owner, _msgSenderERC721A())) {\\n                _revert(ApprovalCallerNotOwnerNorApproved.selector);\\n            }\\n\\n        ERC721AStorage.layout()._tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n    \\n    function _isApprovedForAll(address owner, address operator) internal view returns (bool) {\\n        return ERC721AStorage.layout()._operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!_isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            ERC721AStorage.layout()._packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            ERC721AStorage.layout()._packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            ERC721AStorage.layout()._burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = ERC721AStorage.layout()._packedOwnerships[index];\\n        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        ERC721AStorage.layout()._packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) internal view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /**\\n     * @dev For more efficient reverts.\\n     */\\n    function _revert(bytes4 errorSelector) internal pure {\\n        assembly {\\n            mstore(0x00, errorSelector)\\n            revert(0x00, 0x04)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/ERC721A/IERC721AUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721AUpgradeable {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"contracts/facets/FakeERC173/FakeERC173FacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IFakeERC173Facet } from \\\"./IFakeERC173Facet.sol\\\";\\nimport { FakeERC173Storage } from \\\"./FakeERC173Storage.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title FakeERC173FacetAccessControl\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Exposes an ERC173 ownership facet. The actual ownership is handled differently, this is only used for OpenSea and similar indexers\\ncontract FakeERC173FacetAccessControl is UsingAccessControl , IFakeERC173Facet   {\\n\\n    /// @inheritdoc IFakeERC173Facet\\n    function owner() view external returns(address) {\\n        return FakeERC173Storage.layout().owner;\\n    }\\n\\t\\n    /// @inheritdoc IFakeERC173Facet\\n    function transferOwnership(address _newOwner) external onlyAccessControlAdmin  {\\n        address previousOwner = FakeERC173Storage.layout().owner;\\n        FakeERC173Storage.layout().owner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/FakeERC173/FakeERC173Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary FakeERC173Storage {\\n    struct Layout {\\n      address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.FakeERC173Storage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/FakeERC173/IFakeERC173Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IFakeERC173Facet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Exposes an ERC173 ownership facet. The actual ownership is handled differently, this is only used for OpenSea and similar indexers\\ninterface IFakeERC173Facet {\\n    /// @dev This emits when ownership of a contract changes.    \\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner    \\n    /// @return The address of the owner.\\n    function owner() view external returns(address);\\n\\t\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract    \\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/MetadataNameSymbolUpdate/IMetadataNameSymbolUpdateFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IMetadataNameSymbolUpdateFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Allows updating the name and symbol of the contract. \\ninterface IMetadataNameSymbolUpdateFacet {\\n  /// Update the `name` and `symbol` of the NFT contract.\\n  /// When run in a proxy -> diamond scenario this is restricted to the proxy only and will revert on the diamond.\\n  /// @param name The new name of the contract.\\n  /// @param symbol The new symbol of the contract. It is recommended to keep the length at 11 characters or less, all caps.\\n  function updateNameAndSymbol(string memory name, string memory symbol) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/MetadataNameSymbolUpdate/MetadataNameSymbolUpdateFacetERC721AAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IMetadataNameSymbolUpdateFacet } from \\\"./IMetadataNameSymbolUpdateFacet.sol\\\";\\nimport { ERC721AStorage } from \\\"../ERC721A/ERC721AStorage.sol\\\";\\nimport { MetadataNameSymbolUpdateLibERC721A } from \\\"./MetadataNameSymbolUpdateLibERC721A.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title MetadataNameSymbolUpdateFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Allows updating the name and symbol of the contract. \\ncontract MetadataNameSymbolUpdateFacetERC721AAccessControl is  UsingAccessControl, IMetadataNameSymbolUpdateFacet  {\\n\\n    /// @inheritdoc IMetadataNameSymbolUpdateFacet\\n    function updateNameAndSymbol(string memory name, string memory symbol) external onlyAccessControlAdmin  {\\n        MetadataNameSymbolUpdateLibERC721A._updateNameAndSymbol(name, symbol);\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/MetadataNameSymbolUpdate/MetadataNameSymbolUpdateLibERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { ERC721AStorage } from \\\"../ERC721A/ERC721AStorage.sol\\\";\\n\\nlibrary MetadataNameSymbolUpdateLibERC721A   {\\n\\n    /// Updates the name and symbol of the ERC721A.\\n    function _updateNameAndSymbol(string memory name, string memory symbol) internal {\\n        ERC721AStorage.layout()._name = name;\\n        ERC721AStorage.layout()._symbol = symbol;\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/MetadataUpdate4906/IMetadataUpdate4906Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n// import { IERC4906 } from \\\"../../interfaces/IERC4906.sol\\\";\\n\\n/// @title Facet for notifying of metadata updates\\n/// @author Martin Wawrusch for Roji Inc.\\ninterface IMetadataUpdate4906Facet /* is IERC4906 */ {\\n\\n  /// @notice Notifies that the metadata for a token has been updated.\\n  /// \\n  /// @param tokenId The id of the token that was updated.\\n  function notifyMetadataUpdated(uint256 tokenId) external;\\n\\n  /// @notice Notifies that the metadata for a range of tokens has been updated.\\n  /// \\n  /// @param fromTokenId The first id of the range of tokens that were updated.\\n  /// @param toTokenId The last id of the range of tokens that were updated.\\n  function notifyBatchMetadataUpdated(uint256 fromTokenId, uint256 toTokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/MetadataUpdate4906/MetadataUpdate4906FacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IMetadataUpdate4906Facet } from \\\"./IMetadataUpdate4906Facet.sol\\\";\\nimport { MetadataUpdate4906Lib } from \\\"./MetadataUpdate4906Lib.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title Implementation of a facet for notifying of metadata updates secured via AccessControl\\n/// @author Martin Wawrusch for Roji Inc.\\ncontract MetadataUpdate4906FacetAccessControl is UsingAccessControl, IMetadataUpdate4906Facet   {\\n\\n  /// @inheritdoc IMetadataUpdate4906Facet\\n  function notifyMetadataUpdated(uint256 tokenId) external onlyAccessControlMetadataUpdate {\\n    MetadataUpdate4906Lib._notifyMetadataUpdated(tokenId);\\n  }\\n\\n  /// @inheritdoc IMetadataUpdate4906Facet\\n  function notifyBatchMetadataUpdated(uint256 fromTokenId, uint256 toTokenId) external onlyAccessControlMetadataUpdate {\\n    MetadataUpdate4906Lib._notifyBatchMetadataUpdated(fromTokenId, toTokenId);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/MetadataUpdate4906/MetadataUpdate4906Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary MetadataUpdate4906Lib {\\n\\n  /// @dev This event emits when the metadata of a token is changed.\\n  /// So that the third-party platforms such as NFT market could\\n  /// timely update the images and related attributes of the NFT.\\n  event MetadataUpdate(uint256 tokenId);\\n\\n  /// @dev This event emits when the metadata of a range of tokens is changed.\\n  /// So that the third-party platforms such as NFT market could\\n  /// timely update the images and related attributes of the NFTs.    \\n  event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\\n\\n\\n  /// @dev Notifies that the metadata for a token has been updated.\\n  /// \\n  /// @param tokenId The id of the token that was updated.\\n  function _notifyMetadataUpdated(uint256 tokenId) internal {\\n    emit MetadataUpdate(tokenId);\\n  }\\n\\n  /// @dev Notifies that the metadata for a range of tokens has been updated.\\n  /// @param fromTokenId The first id of the range of tokens that were updated.\\n  /// @param toTokenId The last id of the range of tokens that were updated.\\n  function _notifyBatchMetadataUpdated(uint256 fromTokenId, uint256 toTokenId) internal {\\n    emit BatchMetadataUpdate(fromTokenId, toTokenId);\\n  }\\n}\"\r\n    },\r\n    \"contracts/facets/OpenSeaContract/IOpenSeaContractFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title Exposes a contractURI property that is used by opensea to retrieve collection metadata.\\n/// @author Martin Wawrusch for Roji Inc.\\ninterface IOpenSeaContractFacet {\\n    /// @notice Emitted when the receiver has been updated for an NFT contract\\n    /// @param contractURI The new contract URI. This should point to some file, preferably stored on ipfs.\\n    event ContractURIUpdated( string contractURI);\\n\\n    /// @notice Sets the contract URI that is used by opensea to retrieve contract info.\\n    /// \\n    /// @param contractURI_ The new contract URI. Can be null.\\n    function setContractURI(string calldata contractURI_) external;\\n\\n    /// @notice Returns the contract URI as used by OpenSea.\\n    function contractURI() external view returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/OpenSeaContract/OpenSeaContractFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IOpenSeaContractFacet } from \\\"./IOpenSeaContractFacet.sol\\\";\\nimport { OpenSeaContractStorage } from \\\"./OpenSeaContractStorage.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title OpenSeaContractFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Exposes a contractURI property that is used by opensea to retrieve collection metadata.\\ncontract OpenSeaContractFacetAccessControl is UsingAccessControl, IOpenSeaContractFacet   {\\n\\n    /// @inheritdoc IOpenSeaContractFacet\\n    function setContractURI(string calldata contractURI_) external onlyAccessControlAdmin  {\\n        OpenSeaContractStorage.layout().contractURI = contractURI_;\\n        emit ContractURIUpdated(contractURI_);\\n    }\\n\\n    /// @inheritdoc IOpenSeaContractFacet\\n    function contractURI() public view returns (string memory) {\\n        return OpenSeaContractStorage.layout().contractURI;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/OpenSeaContract/OpenSeaContractStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nlibrary OpenSeaContractStorage {\\n    struct Layout {\\n      /// The optional opensea metatdata URI\\n      string contractURI;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.OpenSeaContractStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/OperatorFilterer/IOperatorFiltererFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\ninterface IOperatorFiltererFacet {\\n    /// @notice Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    /// @notice Registers the contract with the registry.\\n    /// This must be called from the proxy.\\n    /// \\n    /// @param subscriptionOrRegistrantToCopy Provide a valid subscription address to copy the subscriptions from or the 0 address.\\n    /// @param subscribe registers and subscribes\\n    function registerOperatorFilterer(address subscriptionOrRegistrantToCopy, bool subscribe) external;\\n\\n    /// @notice Unregisters the contract from the registry.\\n    function unregisterOperatorFilterer() external;\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/OperatorFilterer/OperatorFiltererFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n\\nimport { IOperatorFiltererFacet } from \\\"./IOperatorFiltererFacet.sol\\\";\\nimport { OperatorFiltererLib } from './OperatorFiltererLib.sol';\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\ncontract OperatorFiltererFacetAccessControl is UsingAccessControl, IOperatorFiltererFacet   {\\n\\n    /// @inheritdoc IOperatorFiltererFacet\\n    function registerOperatorFilterer(address subscriptionOrRegistrantToCopy, bool subscribe) external onlyAccessControlAdmin {\\n        OperatorFiltererLib._register(subscriptionOrRegistrantToCopy, subscribe);\\n    }\\n\\n\\n    /// @inheritdoc IOperatorFiltererFacet\\n    function unregisterOperatorFilterer() external onlyAccessControlAdmin {\\n        OperatorFiltererLib._unregister();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/OperatorFilterer/OperatorFiltererLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport {IOperatorFilterRegistry} from \\\"operator-filter-registry/src/IOperatorFilterRegistry.sol\\\";\\nimport { IOperatorFiltererFacet } from './IOperatorFiltererFacet.sol';\\n\\n/// @title OperatorFilterLib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Contains functionality to implement operator filtering.\\nlibrary OperatorFiltererLib {\\n\\n    IOperatorFilterRegistry constant OPERATOR_FILTER_REGISTRY = IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\\n    address constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\n    address constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\\n    /**\\n     * @dev A helper function to check if the operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting or\\n            // upgraded contracts may specify their own OperatorFilterRegistry implementations, which may behave\\n            // differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert IOperatorFiltererFacet.OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n\\n    /// @dev Initializes with the default registry and subscribes.\\n    function _init() internal {\\n        _register(CANONICAL_CORI_SUBSCRIPTION, true);\\n    }\\n\\n    /// @dev Registers the contract with the registry.\\n    /// This must be called from the proxy.\\n    /// \\n    /// @param subscriptionOrRegistrantToCopy Provide a valid subscription address to copy the subscriptions from or the 0 address.\\n    /// @param subscribe registers and subscribes\\n    function _register(address subscriptionOrRegistrantToCopy, bool subscribe) internal\\n    {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (!OPERATOR_FILTER_REGISTRY.isRegistered(address(this))) {\\n                if (subscribe) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    if (subscriptionOrRegistrantToCopy != address(0)) {\\n                        OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                    } else {\\n                        OPERATOR_FILTER_REGISTRY.register(address(this));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Unregisters the contract from the registry.\\n    function _unregister() internal {\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (OPERATOR_FILTER_REGISTRY.isRegistered(address(this))) {\\n                OPERATOR_FILTER_REGISTRY.unregister(address(this));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/OperatorFilterer/UsingOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { OperatorFiltererLib } from './OperatorFiltererLib.sol';\\n\\n\\n/// @title Internal contract that exposed the pausable modifier\\n/// @author Martin Wawrusch for Roji Inc.\\nabstract contract UsingOperatorFilterer {\\n\\n    /**\\n     * @dev A helper modifier to check if the operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            OperatorFiltererLib._checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper modifier to check if the operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        OperatorFiltererLib._checkFilterOperator(operator);\\n        _;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/facets/Pausable/IPausableFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IPausableFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice This facet defines the pausable functionality.\\ninterface IPausableFacet {\\n    /**\\n     * @notice query whether contract is paused\\n     * @return status whether contract is paused\\n     */\\n    function paused() external view returns (bool status);\\n\\n    /// @notice pauses the contract\\n    /// @dev requires that the contract is not paused\\n    function pause() external;\\n\\n    /// @notice unpauses the contract\\n    /// @dev requires that the contract is paused\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Pausable/PausableFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IPausableFacet } from \\\"./IPausableFacet.sol\\\";\\nimport { PausableInternal } from '@solidstate/contracts/security/pausable/PausableInternal.sol';\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title PausableFacetAccessControl\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice This facet implements the pausable functionality.\\n/// This implementation of the facet requires access control (`AccessControlFacet`).\\ncontract PausableFacetAccessControl is PausableInternal, UsingAccessControl, IPausableFacet   {\\n\\n    /**\\n     * @inheritdoc IPausableFacet\\n     */\\n    function paused() public view virtual returns (bool status) {\\n        status = _paused();\\n    }\\n\\n    /// @notice pauses the contract\\n    /// @dev requires that the contract is not paused\\n    function pause() external onlyAccessControlOperations {\\n      _pause();\\n    }\\n\\n    /// @notice unpauses the contract\\n    /// @dev requires that the contract is paused\\n    function unpause() external onlyAccessControlOperations {\\n      _unpause();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Pausable/UsingPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { PausableStorage } from '@solidstate/contracts/security/pausable/PausableStorage.sol';\\nimport { IPausableInternal } from '@solidstate/contracts/security/pausable/IPausableInternal.sol';\\n\\n/// @title Internal contract that exposed the pausable modifier\\n/// @author Martin Wawrusch for Roji Inc.\\nabstract contract UsingPausable is IPausableInternal  {\\n    /// @dev Reverts when the contract is paused.\\n    modifier whenNotPaused() {\\n        if( PausableStorage.layout().paused ) {\\n            revert Pausable__Paused();\\n        }\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/Permit4494/IPermit4494Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\ninterface IPermit4494Facet  {\\n  /// ERC165 bytes to add to interface array - set in parent contract\\n  ///\\n  /// _INTERFACE_ID_ERC4494 = 0x5604e225\\n\\n  /// @notice Function to approve by way of owner signature\\n  /// @param spender the address to approve\\n  /// @param tokenId the index of the NFT to approve the spender on\\n  /// @param deadline a timestamp expiry for the permit\\n  /// @param signature a traditional or EIP-2098 signature\\n  function permit(address spender, uint256 tokenId, uint256 deadline, bytes memory signature) external;\\n  /// @notice Returns the nonce of an NFT - useful for creating permits\\n  /// @param tokenId the index of the NFT to get the nonce of\\n  /// @return the uint256 representation of the nonce\\n  function nonces(uint256 tokenId) external view returns(uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Permit4494/Permit4494ERC721AFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IPermit4494Facet } from \\\"./IPermit4494Facet.sol\\\";\\nimport { Permit4494Storage } from \\\"./Permit4494Storage.sol\\\";\\nimport { ERC721AUpgradeableInternal } from \\\"../ERC721A/ERC721AUpgradeableInternal.sol\\\";\\nimport { ECDSA } from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { CountersUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport { EIP712Upgradeable } from  \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\\\";\\nimport { ERC721AStorage } from \\\"../ERC721A/ERC721AStorage.sol\\\";\\nimport { ERC712Lib } from '../ERC712/ERC712Lib.sol';\\nimport { Permit4494Lib } from './Permit4494Lib.sol';\\n\\n/// @title Permit4494ERC721AFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Requires the `ERC712Facet`.\\ncontract Permit4494ERC721AFacet is ERC721AUpgradeableInternal, IPermit4494Facet {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    /// @inheritdoc IPermit4494Facet\\n    function nonces(uint256 tokenId_) external view returns(uint256) {\\n        return Permit4494Storage.layout().nonces[tokenId_].current();\\n    }\\n\\n    /// @inheritdoc IPermit4494Facet\\n    function permit(\\n    address spender,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    bytes memory signature\\n  ) external  {\\n    // solhint-disable-next-line not-rely-on-time\\n    require(block.timestamp <= deadline, \\\"ERC721Permit: expired deadline\\\");\\n\\n    bytes32 structHash = keccak256(\\n      abi.encode(\\n        Permit4494Lib.PERMIT_4494_TYPEHASH,\\n        spender,\\n        tokenId,\\n         Permit4494Storage.layout().nonces[tokenId].current(),\\n        deadline\\n      )\\n    );\\n    bytes32 hash = ERC712Lib._hashTypedDataV4(structHash);\\n\\n    (address signer, ) = ECDSA.tryRecover(hash, signature);\\n    bool isValidEOASignature = signer != address(0) &&\\n      _isApprovedOrOwner(signer, tokenId);\\n\\n    require(\\n      isValidEOASignature ||\\n        Permit4494Lib._isValidContractERC1271Signature(_ownerOf(tokenId), hash, signature) ||\\n        Permit4494Lib._isValidContractERC1271Signature(_getApproved(tokenId), hash, signature),\\n      \\\"ERC721Permit: invalid signature\\\"\\n    );\\n\\n    _approve(spender, tokenId);\\n  }\\n\\n  function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n      if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);\\n\\n      return ERC721AStorage.layout()._tokenApprovals[tokenId].value;\\n  }\\n\\n  function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _getApproved(tokenId) == spender ||\\n            _isApprovedForAll(_ownerOf(tokenId), spender) ||\\n            _ownerOf(tokenId) == spender;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Permit4494/Permit4494Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { CountersUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport { IERC1271 } from \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\nimport { Permit4494Storage } from './Permit4494Storage.sol';\\n\\n/// @title Permit4494Lib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Contains utility functions for the permit implementation.\\nlibrary Permit4494Lib {\\n  using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n  bytes32 internal constant PERMIT_4494_TYPEHASH = \\n        keccak256(\\\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\\\");\\n\\n\\n  /// Must be called after the token transfer in the ERC721A implementation\\n  /// but BEFORE the base code.\\n  /// \\n  /// @param startTokenId The first token id of the transfer\\n  /// @param quantity The number of tokens transferred.\\n  function _handleAfterTokenTransfers( uint256 startTokenId,\\n        uint256 quantity) internal {  \\n    for (uint256 i = 0; i < quantity; i++) {\\n        Permit4494Storage.layout().nonces[startTokenId + i].increment();\\n    }\\n  }\\n\\n\\n\\n\\n    function _isValidContractERC1271Signature(\\n    address signer,\\n    bytes32 hash,\\n    bytes memory signature\\n  ) internal view returns (bool) {\\n    (bool success, bytes memory result) = signer.staticcall(\\n      abi.encodeWithSelector(\\n        IERC1271.isValidSignature.selector,\\n        hash,\\n        signature\\n      )\\n    );\\n    return (success &&\\n      result.length == 32 &&\\n      abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\\n  }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facets/Permit4494/Permit4494Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\nimport  \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\n\\nlibrary Permit4494Storage {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    struct Layout {\\n        mapping(uint256 => CountersUpgradeable.Counter) nonces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('io.roji.facets.storage.Permit4494Storage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/ROJIVersionedContract/IROJIVersionedContractFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n/// @title Versioned contract interface for ROJI.\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Returns the contract version, starting with 1, of the implementing contract.\\n/// When inheriting from this contract you need to support EIP-165 as well.\\n/// The interface id is\\n/// bytes4 private constant _INTERFACE_ID_ROJI_VERSIONED_CONTRACT = bytes4(0xa0a8e460);\\ninterface IROJIVersionedContractFacet {\\n\\n  /// @dev Returns the version of the underlying contract.\\n  function contractVersion() external pure returns (uint32);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/facets/ROJIVersionedContract/ROJIVersionedContractFacetV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IROJIVersionedContractFacet } from \\\"./IROJIVersionedContractFacet.sol\\\";\\n\\n/// @title Exposes the contract version.\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice This facet is hardcoded to 1 so include it in a dimamond if that diamond is in version 1.\\ncontract ROJIVersionedContractFacetV1 is IROJIVersionedContractFacet   {\\n\\n    /// @inheritdoc IROJIVersionedContractFacet\\n    function contractVersion() external pure returns (uint32) {\\n        return 1;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/facets/RolesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title RolesLib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice A collection of roles used within Animeme Labs contracts.\\nlibrary RolesLib {\\n    /// @dev Role used for anything touching finance (withdrawals, changing royalties etc)\\n    bytes32 internal constant ROLE_FINANCE = keccak256(\\\"ROLE_FINANCE\\\");\\n\\n    /// @dev Role used for anything touching operations (pause etc) but not the access control admin, which is reserved for ROLE_ACCESS_CONTROL_ADMIN\\n    bytes32 internal constant ROLE_OPERATIONS = keccak256(\\\"ROLE_OPERATIONS\\\");\\n\\n    /// @dev Role used to trigger the metadata update.\\n    bytes32 internal constant ROLE_METADATA_UPDATE = keccak256(\\\"ROLE_METADATA_UPDATE\\\");\\n\\n    /// @dev Role used for anything touching manual minting.\\n    bytes32 internal constant ROLE_ADMIN_MINTING = keccak256(\\\"ROLE_ADMIN_MINTING\\\");\\n\\n    /// @dev Role used for anything touching manual burning.\\n    bytes32 internal constant ROLE_ADMIN_BURNING = keccak256(\\\"ROLE_ADMIN_BURNING\\\");\\n\\n    /// @dev Core role for managing access control. Holders of this role cam obtain full access to all\\n    /// aspects of the contract.\\n    bytes32 internal constant ROLE_ACCESS_CONTROL_ADMIN = bytes32(0);\\n}\\n\"\r\n    },\r\n    \"contracts/facets/RoyaltiesERC2981/IRoyaltiesERC2981Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title EIP-2981: NFT Royalty Standard \\n/// @dev Interface for the NFT Royalty Standard\\n/// https://eips.ethereum.org/EIPS/eip-2981\\n/// @custom:security-contact security@roji.io\\ninterface IRoyaltiesERC2981Facet {\\n    /**\\n     * @dev Emitted when the defaultRoyaltyReceiver parameter is set to null.\\n     */\\n    error DefaultRoyaltyReceiverIsNull();\\n\\n    /**\\n     * @dev Emitted when the defaultRoyaltyBPS parameter is above 10000.\\n     */\\n    error RoyaltyBPSExceedsMax();\\n\\n    /// Emitted when the royalties tier has changed.\\n    /// @param oldDefaultRoyaltyReceiver The previous receiver.\\n    /// @param newDefaultRoyaltyReceiver The new receiver.\\n    /// @param oldDefaultRoyaltyBPS The previous BPS.\\n    /// @param newDefaultRoyaltyBPS The new BPS.\\n    event DefaultRoyaltyChanged(address indexed oldDefaultRoyaltyReceiver, \\n                                address indexed newDefaultRoyaltyReceiver,\\n                                uint16 oldDefaultRoyaltyBPS,\\n                                uint16 newDefaultRoyaltyBPS);\\n\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice ) external view returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n\\n    /// @notice Sets the default royalty receiver and default royalty base points (1/100 of a percent).\\n    /// @param defaultRoyaltyReceiver The account that receives the royalties.\\n    /// @param defaultRoyaltyBPS The base points (1/100 of a percent) of the default royalty.\\n    function setDefaultRoyalty(address defaultRoyaltyReceiver, uint16 defaultRoyaltyBPS) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/RoyaltiesERC2981/RoyaltiesERC2981FacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { ERC2981Storage } from '@solidstate/contracts/token/common/ERC2981/ERC2981Storage.sol';\\nimport { ERC2981Internal } from '@solidstate/contracts/token/common/ERC2981/ERC2981Internal.sol';\\n\\nimport { IRoyaltiesERC2981Facet } from \\\"./IRoyaltiesERC2981Facet.sol\\\";\\nimport { RoyaltiesERC2981Lib } from \\\"./RoyaltiesERC2981Lib.sol\\\";\\nimport { UsingAccessControl } from '../../facets/AccessControl/UsingAccessControl.sol';\\n\\n/// @title Implementation of the EIP-2981: NFT Royalty Standard\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @dev Inherits storage layout of ERC2981Storage. This facet uses access control.\\ncontract RoyaltiesERC2981FacetAccessControl is ERC2981Internal, UsingAccessControl, IRoyaltiesERC2981Facet   {\\n\\n\\n    /// @inheritdoc IRoyaltiesERC2981Facet\\n   function royaltyInfo(uint256 tokenId, uint256 salePrice) public view returns (address, uint256) {\\n        return _royaltyInfo(tokenId, salePrice);\\n    }\\n\\n    /// @inheritdoc IRoyaltiesERC2981Facet\\n    function setDefaultRoyalty(address defaultRoyaltyReceiver, uint16 defaultRoyaltyBPS) external onlyAccessControlFinance  {\\n        if(defaultRoyaltyReceiver == address(0x0)){\\n            revert DefaultRoyaltyReceiverIsNull();\\n        }\\n\\n        if(defaultRoyaltyBPS > 10000){\\n            revert RoyaltyBPSExceedsMax();\\n        }\\n\\n        emit DefaultRoyaltyChanged(ERC2981Storage.layout().defaultRoyaltyReceiver,\\n                                  defaultRoyaltyReceiver, \\n                                  ERC2981Storage.layout().defaultRoyaltyBPS,\\n                                  defaultRoyaltyBPS);\\n\\n        RoyaltiesERC2981Lib._setDefaultRoyalty(defaultRoyaltyReceiver, defaultRoyaltyBPS);\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/RoyaltiesERC2981/RoyaltiesERC2981Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { ERC2981Storage } from '@solidstate/contracts/token/common/ERC2981/ERC2981Storage.sol';\\nimport { ERC2981Internal } from '@solidstate/contracts/token/common/ERC2981/ERC2981Internal.sol';\\n\\nimport { IRoyaltiesERC2981Facet } from \\\"./IRoyaltiesERC2981Facet.sol\\\";\\n\\nlibrary RoyaltiesERC2981Lib {\\n    function _setDefaultRoyalty(address defaultRoyaltyReceiver, uint16 defaultRoyaltyBPS) internal {\\n        ERC2981Storage.layout().defaultRoyaltyBPS = defaultRoyaltyBPS;\\n        ERC2981Storage.layout().defaultRoyaltyReceiver = defaultRoyaltyReceiver;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Withdraw/IWithdrawFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title IWithdrawFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Provides the ability to withdraw funds from the contract. This is used as 'Black Hole Protection' to be able to refund users who inadvertently send funds or tokens to the contract.\\ninterface IWithdrawFacet {\\n\\n    /// @notice Withdraws ETH from the contract.\\n    /// @dev This is to be used to withdraw the ETH that was sent to the contract as payment for the NFTs.\\n    function withdraw() external;\\n\\n    /// @notice Withdraws ERC20 tokens from the contract.\\n    /// @param tokenAddress The address of the ERC20 token contract.\\n    /// @dev This is to be used to withdraw the ERC20 tokens (USDC, etc) that were sent to the contract as payment for the NFTs.\\n    function withdrawERC20(address tokenAddress) external;\\n\\n    /// @notice Blackhole protection against accidentally transferred NFTs.\\n    /// @param tokenAddress The address of the NFT contract.\\n    /// @param tokenId The ID of the NFT to withdraw.\\n    /// @dev This is a fallback in case the contract receives 721 NFTs directly.\\n    function withdrawERC721(address tokenAddress, uint256 tokenId) external;\\n\\n    /// @notice Blackhole protection against accidentally transferred NFTs.\\n    /// @param tokenAddress The address of the NFT contract.\\n    /// @param tokenId The ID of the NFT to withdraw.\\n    /// @param value The amount of ERC1155 tokens to withdraw.\\n    /// @dev This is a fallback in case the contract receives 721 NFTs directly.\\n    function withdrawERC1155(address tokenAddress, uint256 tokenId, uint256 value) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/facets/Withdraw/WithdrawFacetAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IWithdrawFacet } from \\\"./IWithdrawFacet.sol\\\";\\nimport { IERC20 } from \\\"@solidstate/contracts/interfaces/IERC20.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC1155 } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport { SafeERC20 } from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\nimport { UsingAccessControl } from \\\"../../facets/AccessControl/UsingAccessControl.sol\\\";\\n\\n/// @title WithdrawFacet\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Provides the ability to withdraw funds from the contract. This is used as 'Black Hole Protection' to be able to refund users who inadvertently send funds or tokens to the contract.\\n/// Access is restricted to the special ROLE_ROJI_BLACKHOLE_WITHDRAWER role to prevent abuse.\\ncontract WithdrawFacetAccessControl is UsingAccessControl , IWithdrawFacet   {\\n  using SafeERC20 for IERC20;\\n\\n    /// @inheritdoc IWithdrawFacet\\n    function withdraw() external onlyAccessControlFinance {\\n        // (bool sent, ) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        // require(sent, \\\"Failed to send ether\\\");\\n        payable(msg.sender).transfer(address(this).balance); \\n    }\\n\\n    /// @inheritdoc IWithdrawFacet\\n    function withdrawERC20(address tokenAddress) external onlyAccessControlFinance {\\n        IERC20 token = IERC20(tokenAddress);\\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\n    }\\n\\n    /// @inheritdoc IWithdrawFacet\\n    function withdrawERC721(address tokenAddress, uint256 tokenId) external onlyAccessControlFinance {\\n        IERC721 token = IERC721(tokenAddress);\\n        token.transferFrom(address(this), msg.sender, tokenId);\\n    }\\n\\n    /// @inheritdoc IWithdrawFacet\\n    function withdrawERC1155(address tokenAddress, uint256 tokenId, uint256 value) external onlyAccessControlFinance {\\n        IERC1155 token = IERC1155(tokenAddress);\\n        token.safeTransferFrom(address(this), msg.sender, tokenId, value, \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/imports.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n// The following is imported so Hardhat/typechain can recognize it.\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.4;\\n\\n/// @title EIP-2981: NFT Royalty Standard \\n/// @dev Interface for the NFT Royalty Standard\\n/// https://eips.ethereum.org/EIPS/eip-2981\\n/// @custom:security-contact security@roji.io\\ninterface IERC2981 {\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _salePrice\\n    ) external view returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.4;\\n\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 /* is IERC165, IERC721  */ {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.    \\n    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ROJIInterfacesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.19;\\n\\n/// @title ROJIInterfacesLib\\n/// @author Martin Wawrusch for Roji Inc.\\n/// @notice Exportes all interface IDs used by ROJI\\nlibrary ROJIInterfacesLib {\\n\\n  /// @dev Interface ID for ERC721 - NFTs\\n  bytes4 internal constant INTERFACE_ID_ERC721 = bytes4(0x80ac58cd);\\n  /// @dev Interface ID for ERC721_METADATA - NFT metadata\\n  bytes4 internal constant INTERFACE_ID_ERC721_METADATA = bytes4(0x5b5e139f);\\n  /// @dev Interface ID for ERC4494 721NFT Permit functionality\\n  bytes4 internal constant INTERFACE_ID_ERC4494 = bytes4(0x5604e225);\\n  /// @dev Interface ID for ERC2981 - royalties\\n  bytes4 internal constant INTERFACE_ID_ERC2981 = bytes4(0x2a55205a);\\n  /// @dev Interface ID for `IROJIVersionedContract`\\n  bytes4 internal constant INTERFACE_ID_ROJI_VERSIONED_CONTRACT = bytes4(0xa0a8e460);\\n\\n /// @dev Interface ID for ERC4494 721NFT Permit functionality\\n  bytes4 internal constant INTERFACE_ID_IERC4906 = bytes4(0x49064906);\\n \\n}\"\r\n    },\r\n    \"contracts/mocks/MockUSDC.sol\": {\r\n      \"content\": \"\\n\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.4;\\n\\n// import \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n// import \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\n\\n// contract MockUSDC is ERC20, ERC20Permit {\\n//     constructor() ERC20(\\\"MockUSDC\\\", \\\"USDC\\\") ERC20Permit(\\\"MockUSDC\\\") {}\\n\\n//     function mint(address to, uint256 amount) public {\\n//         _mint(to, amount);\\n//     }\\n// }\\n\\n\\nimport \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract MockUSDC is ERC20 {\\n\\n  constructor() ERC20(\\\"MOCK USDC\\\", \\\"USDC\\\", 6) {} \\n\\n  function mint(address to, uint256 amount) public {\\n    _mint(to, amount);\\n  }\\n\\n}\\n\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/diamond/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"./libraries/LibDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"./interfaces/IDiamondCut.sol\\\";\\n\\ncontract Diamond {\\n    struct Initialization {\\n        address initContract;\\n        bytes initData;\\n    }\\n\\n    /// @notice This construct a diamond contract\\n    /// @param _contractOwner the owner of the contract. With default DiamondCutFacet, this is the sole address allowed to make further cuts.\\n    /// @param _diamondCut the list of facet to add\\n    /// @param _initializations the list of initialization pair to execute. This allow to setup a contract with multiple level of independent initialization.\\n    constructor(\\n        address _contractOwner,\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        Initialization[] memory _initializations\\n    ) payable {\\n        if (_contractOwner != address(0)) {\\n            LibDiamond.setContractOwner(_contractOwner);\\n        }\\n\\n        LibDiamond.diamondCut(_diamondCut, address(0), \\\"\\\");\\n\\n        for (uint256 i = 0; i < _initializations.length; i++) {\\n            LibDiamond.initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\\n        }\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/LibDiamond.sol\\\";\\n\\ncontract UsingDiamondOwner {\\n    modifier onlyOwner() {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        require(msg.sender == ds.contractOwner, \\\"Only owner is allowed to perform this action\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"__CACHE_BREAKER__\": \"0x00000000d41867734bbee4c6863d9255b2b06ac1\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"initContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct Diamond.Initialization[]\",\"name\":\"_initializations\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DekohDiamond", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000328424e95ec34cc062627508efe55ad01988adab0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000064697054de83c08bc72a4370843f1127dce5642a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000001f57e829100000000000000000000000000000000000000000000000000000000000000000000000000000000429dbde7913c0ed51e4b21163760b92ee66ff5f50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000011f931c1c000000000000000000000000000000000000000000000000000000000000000000000000000000003bcf4185443a339517ad4e580067f178d1b68e1d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000005cdffacc60000000000000000000000000000000000000000000000000000000052ef6b2c00000000000000000000000000000000000000000000000000000000adfca15e000000000000000000000000000000000000000000000000000000007a0ed6270000000000000000000000000000000000000000000000000000000001ffc9a700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000e68d85348f227d2ebee814c38918f8a2d7d9b603000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a42a84809100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000148e2b0930000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064697054de83c08bc72a4370843f1127dce5642a00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000044f57e8291000000000000000000000000328424e95ec34cc062627508efe55ad01988adab000000000000000000000000328424e95ec34cc062627508efe55ad01988adab00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "1", "Implementation": "0x429dbde7913c0ed51e4b21163760b92ee66ff5f5", "SwarmSource": ""}