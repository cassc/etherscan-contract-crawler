{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \".deps/contracts/helpers/CoreskyRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {CoreskyRouterInterface} from \\\"../interfaces/CoreskyRouterInterface.sol\\\";\\nimport { SeaportInterface } from \\\"../interfaces/SeaportInterface.sol\\\";\\nimport { ReentrancyGuard } from \\\"../lib/ReentrancyGuard.sol\\\";\\nimport {ItemType} from \\\"../lib/ConsiderationEnums.sol\\\";\\nimport {\\nAdvancedOrder,\\nCriteriaResolver,\\nExecution,\\nFulfillmentComponent,\\nReceivedItem\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title  CoreskyRouter\\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\\n * @notice A utility contract for fulfilling orders with multiple\\n *         Seaport versions. DISCLAIMER: This contract only works when\\n *         all consideration items across all listings are native tokens.\\n */\\ncontract CoreskyRouter is CoreskyRouterInterface, ReentrancyGuard, Ownable {\\n\\n    //store the router address for exchange\\n    struct Market {\\n        address exchange;\\n        bool isActive;\\n    }\\n\\n    Market[] public markets;\\n    mapping(address => mapping(address => uint256)) private balance;\\n    /**\\n     * @dev Deploy contract with the supported Seaport contracts.\\n     * @param proxies The address of market exchange include seaport and coresky.\\n     */\\n    constructor(address[] memory proxies) {\\n        for (uint256 i = 0; i < proxies.length; i++) {\\n            markets.push(Market(proxies[i], true));\\n        }\\n    }\\n\\n    /**\\n     * @dev Fallback function to receive excess ether, in case total amount of\\n     *      ether sent is more than the amount required to fulfill the order.\\n     */\\n    receive() external payable override {\\n        _assertSeaportAllowed(msg.sender);\\n    }\\n\\n    function addMarket(address proxy) external onlyOwner {\\n        markets.push(Market(proxy, true));\\n    }\\n\\n    function updateMarketStatus(uint256 marketId, bool newStatus)\\n    external\\n    onlyOwner\\n    {\\n        Market storage market = markets[marketId];\\n        market.isActive = newStatus;\\n    }\\n\\n    /**\\n     * @notice Fulfill available advanced orders through multiple Seaport versions.\\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\\n     * @param params The parameters for fulfilling available advanced orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        FulfillAvailableAdvancedOrdersParams calldata params,\\n        address token,\\n        uint256 tokenAmount,\\n        address[] calldata conduits\\n    )\\n    public\\n    payable\\n    override\\n    returns (\\n        bool[][] memory availableOrders,\\n        Execution[][] memory executions\\n    )\\n    {\\n        // Ensure this function cannot be triggered during a reentrant call.\\n        _setReentrancyGuard(true);\\n\\n        _approveConduit(token, tokenAmount, conduits);\\n\\n        // Put the number of Seaport contracts on the stack.\\n        uint256 seaportContractsLength = params.seaportContracts.length;\\n\\n        // Set the availableOrders and executions arrays to the correct length.\\n        availableOrders = new bool[][](seaportContractsLength);\\n        executions = new Execution[][](seaportContractsLength);\\n\\n        // Track the number of order fulfillments left.\\n        uint256 fulfillmentsLeft = params.maximumFulfilled;\\n\\n        // To help avoid stack too deep errors, we format the calldata\\n        // params in a struct and put it on the stack.\\n        AdvancedOrder[] memory emptyAdvancedOrders;\\n        CriteriaResolver[] memory emptyCriteriaResolvers;\\n        FulfillmentComponent[][] memory emptyFulfillmentComponents;\\n        CalldataParams memory calldataParams = CalldataParams({\\n            advancedOrders: emptyAdvancedOrders,\\n            criteriaResolvers: emptyCriteriaResolvers,\\n            offerFulfillments: emptyFulfillmentComponents,\\n            considerationFulfillments: emptyFulfillmentComponents,\\n            fulfillerConduitKey: params.fulfillerConduitKey,\\n            recipient: params.recipient,\\n            maximumFulfilled: fulfillmentsLeft\\n        });\\n\\n        // If recipient is not provided assign to msg.sender.\\n        if (calldataParams.recipient == address(0)) {\\n            calldataParams.recipient = msg.sender;\\n        }\\n\\n        // Iterate through the provided Seaport contracts.\\n        for (uint256 i = 0; i < seaportContractsLength;) {\\n            // Ensure the provided Seaport contract is allowed.\\n            _assertSeaportAllowed(params.seaportContracts[i]);\\n\\n            // Put the order params on the stack.\\n            AdvancedOrderParams calldata orderParams =\\n                                params.advancedOrderParams[i];\\n\\n            // Assign the variables to the calldata params.\\n            calldataParams.advancedOrders = orderParams.advancedOrders;\\n            calldataParams.criteriaResolvers = orderParams.criteriaResolvers;\\n            calldataParams.offerFulfillments = orderParams.offerFulfillments;\\n            calldataParams.considerationFulfillments =\\n                            orderParams.considerationFulfillments;\\n\\n            // Execute the orders, collecting availableOrders and executions.\\n            // This is wrapped in a try/catch in case a single order is\\n            // executed that is no longer available, leading to a revert\\n            // with `NoSpecifiedOrdersAvailable()` that can be ignored.\\n            try SeaportInterface(params.seaportContracts[i])\\n            .fulfillAvailableAdvancedOrders{value: orderParams.etherValue}(\\n                calldataParams.advancedOrders,\\n                calldataParams.criteriaResolvers,\\n                calldataParams.offerFulfillments,\\n                calldataParams.considerationFulfillments,\\n                calldataParams.fulfillerConduitKey,\\n                calldataParams.recipient,\\n                calldataParams.maximumFulfilled\\n            ) returns (\\n                bool[] memory newAvailableOrders,\\n                Execution[] memory newExecutions\\n            ) {\\n                availableOrders[i] = newAvailableOrders;\\n                executions[i] = newExecutions;\\n\\n                // Subtract the number of orders fulfilled.\\n                uint256 newAvailableOrdersLength = newAvailableOrders.length;\\n                for (uint256 j = 0; j < newAvailableOrdersLength;) {\\n                    if (newAvailableOrders[j]) {\\n                        unchecked {\\n                            --fulfillmentsLeft;\\n                            ++j;\\n                        }\\n                    }\\n                }\\n\\n                // Break if the maximum number of executions has been reached.\\n                if (fulfillmentsLeft == 0) {\\n                    break;\\n                }\\n            } catch (bytes memory data) {\\n                // Set initial value of first four bytes of revert data\\n                // to the mask.\\n                bytes4 customErrorSelector = bytes4(0xffffffff);\\n\\n                // Utilize assembly to read first four bytes\\n                // (if present) directly.\\n                assembly {\\n                // Combine original mask with first four bytes of\\n                // revert data.\\n                    customErrorSelector :=\\n                    and(\\n                    // Data begins after length offset.\\n                        mload(add(data, 0x20)),\\n                        customErrorSelector\\n                    )\\n                }\\n\\n                // Pass through the custom error if the error is\\n                // not NoSpecifiedOrdersAvailable()\\n                if (customErrorSelector != NoSpecifiedOrdersAvailable.selector)\\n                {\\n                    assembly {\\n                        revert(add(data, 32), mload(data))\\n                    }\\n                }\\n            }\\n\\n            // Update fulfillments left.\\n            calldataParams.maximumFulfilled = fulfillmentsLeft;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Throw an error if no orders were fulfilled.\\n        if (fulfillmentsLeft == params.maximumFulfilled) {\\n            revert NoSpecifiedOrdersAvailable();\\n        }\\n\\n        // Return excess ether or token that may not have been used or was sent back.\\n        _returnTokens(token, tokenAmount, executions);\\n\\n        // Clear the reentrancy guard.\\n        _clearReentrancyGuard();\\n    }\\n\\n    function _approveConduit(address token, uint256 tokenAmount, address[]  calldata conduits) internal {\\n        if (msg.value == 0 && token == address(0)) {\\n            revert InValidTokenAndValue();\\n        }\\n        if (token != address(0) && tokenAmount>0) {\\n            for (uint256 i = 0; i < conduits.length; i++) {\\n                address conduit = conduits[i];\\n                _approveEthUSDT(token,conduit);\\n                IERC20(token).approve(conduit, tokenAmount);\\n                bool success = IERC20(token).transferFrom(msg.sender, address(this), tokenAmount);\\n                if (!success) {\\n                    revert TokenReturnTransferFailed(msg.sender, address(this), tokenAmount);\\n                }\\n                balance[msg.sender][token] += tokenAmount;\\n            }\\n        }\\n\\n    }\\n    /**\\n     * @dev Reverts if the provided market contract is not allowed.\\n     */\\n    function _assertSeaportAllowed(address market) internal view {\\n        bool exsitMarket;\\n        for (uint256 i = 0; i < markets.length; i++) {\\n            if (markets[i].exchange == market && markets[i].isActive) {\\n                exsitMarket = true;\\n            }\\n        }\\n        if (!exsitMarket) {\\n            revert SeaportNotAllowed(market);\\n        }\\n    }\\n\\n    function _returnTokens(address token, uint256 tokenAmount, Execution[][] memory executions) private {\\n        if (address(this).balance > 0) {\\n            _returnExcessEther();\\n        }\\n        //return erc20 token if has erc20\\n        if(token != address(0) && tokenAmount>0){\\n            uint256 _tokenLeftBalance = IERC20(token).balanceOf(address(this));\\n            if (_tokenLeftBalance>0) {\\n                _setExcessTokenAmount(token, executions);\\n                uint256 excessTokenAmount = _getExcessTokenAmount(token);\\n                if (excessTokenAmount > 0) {\\n                    bool sucess = IERC20(token).transfer(msg.sender, excessTokenAmount);\\n                    if (!sucess) {\\n                        revert TokenReturnTransferFailed(address(this), msg.sender, excessTokenAmount);\\n                    }\\n                    balance[msg.sender][token] -= excessTokenAmount;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _setExcessTokenAmount(address token, Execution[][] memory executions) private {\\n        uint256 transferAmount;\\n        for (uint256 i = 0; i < executions.length; i++) {\\n            for (uint256 j = 0; j < executions[i].length; j++) {\\n                ReceivedItem memory _execute = executions[i][j].item;\\n                if (token == _execute.token && ItemType.ERC20 == _execute.itemType) {\\n                    transferAmount += _execute.amount;\\n                }\\n            }\\n        }\\n        balance[msg.sender][token] -= transferAmount;\\n    }\\n\\n    function _getExcessTokenAmount(address token) view internal returns (uint256) {\\n        return balance[msg.sender][token];\\n    }\\n\\n    /**\\n     * @dev Function to return excess ether, in case total amount of\\n     *      ether sent is more than the amount required to fulfill the order.\\n     */\\n    function _returnExcessEther() private {\\n        // Send received funds back to msg.sender.\\n        (bool success, bytes memory data) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n\\n        // Revert with an error if the ether transfer failed.\\n        if (!success) {\\n            revert EtherReturnTransferFailed(msg.sender, address(this).balance, data);\\n        }\\n    }\\n\\n    // usdt token need approve zero first on ethereum mainnet.\\n    function _approveEthUSDT(address token, address conduit) private {\\n        if (1==block.chainid){\\n            if(token == address(0xdAC17F958D2ee523a2206206994597C13D831ec7)){\\n                IERC20(token).approve(conduit, 0);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/ConsiderationStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    BasicOrderType,\\n    ItemType,\\n    OrderType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    CalldataPointer,\\n    MemoryPointer\\n} from \\\"../helpers/PointerLibraries.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 counter;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item and has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the counter,\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be provided to the zone if the\\n *      order type is restricted and the zone is not the caller, or will be\\n *      provided to the offerer as context for contract order types.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\\n/**\\n * @dev Restricted orders are validated post-execution by calling validateOrder\\n *      on the zone. This struct provides context about the order fulfillment\\n *      and any supplied extraData, as well as all order hashes fulfilled in a\\n *      call to a match or fulfillAvailable method.\\n */\\nstruct ZoneParameters {\\n    bytes32 orderHash;\\n    address fulfiller;\\n    address offerer;\\n    SpentItem[] offer;\\n    ReceivedItem[] consideration;\\n    bytes extraData;\\n    bytes32[] orderHashes;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n}\\n\\n/**\\n * @dev Zones and contract offerers can communicate which schemas they implement\\n *      along with any associated metadata related to each schema.\\n */\\nstruct Schema {\\n    uint256 id;\\n    bytes metadata;\\n}\\n\\nusing StructPointers for OrderComponents global;\\nusing StructPointers for OfferItem global;\\nusing StructPointers for ConsiderationItem global;\\nusing StructPointers for SpentItem global;\\nusing StructPointers for ReceivedItem global;\\nusing StructPointers for BasicOrderParameters global;\\nusing StructPointers for AdditionalRecipient global;\\nusing StructPointers for OrderParameters global;\\nusing StructPointers for Order global;\\nusing StructPointers for AdvancedOrder global;\\nusing StructPointers for OrderStatus global;\\nusing StructPointers for CriteriaResolver global;\\nusing StructPointers for Fulfillment global;\\nusing StructPointers for FulfillmentComponent global;\\nusing StructPointers for Execution global;\\nusing StructPointers for ZoneParameters global;\\n\\n/**\\n * @dev This library provides a set of functions for converting structs to\\n *      pointers.\\n */\\nlibrary StructPointers {\\n    /**\\n     * @dev Get a MemoryPointer from OrderComponents.\\n     *\\n     * @param obj The OrderComponents object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderComponents memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderComponents.\\n     *\\n     * @param obj The OrderComponents object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderComponents calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OfferItem.\\n     *\\n     * @param obj The OfferItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OfferItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OfferItem.\\n     *\\n     * @param obj The OfferItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OfferItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ConsiderationItem.\\n     *\\n     * @param obj The ConsiderationItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ConsiderationItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ConsiderationItem.\\n     *\\n     * @param obj The ConsiderationItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ConsiderationItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from SpentItem.\\n     *\\n     * @param obj The SpentItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        SpentItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from SpentItem.\\n     *\\n     * @param obj The SpentItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        SpentItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ReceivedItem.\\n     *\\n     * @param obj The ReceivedItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ReceivedItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ReceivedItem.\\n     *\\n     * @param obj The ReceivedItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ReceivedItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from BasicOrderParameters.\\n     *\\n     * @param obj The BasicOrderParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        BasicOrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from BasicOrderParameters.\\n     *\\n     * @param obj The BasicOrderParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        BasicOrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from AdditionalRecipient.\\n     *\\n     * @param obj The AdditionalRecipient object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        AdditionalRecipient memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from AdditionalRecipient.\\n     *\\n     * @param obj The AdditionalRecipient object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        AdditionalRecipient calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OrderParameters.\\n     *\\n     * @param obj The OrderParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderParameters.\\n     *\\n     * @param obj The OrderParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Order.\\n     *\\n     * @param obj The Order object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Order memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Order.\\n     *\\n     * @param obj The Order object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Order calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from AdvancedOrder.\\n     *\\n     * @param obj The AdvancedOrder object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        AdvancedOrder memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from AdvancedOrder.\\n     *\\n     * @param obj The AdvancedOrder object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        AdvancedOrder calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OrderStatus.\\n     *\\n     * @param obj The OrderStatus object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderStatus memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderStatus.\\n     *\\n     * @param obj The OrderStatus object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderStatus calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from CriteriaResolver.\\n     *\\n     * @param obj The CriteriaResolver object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        CriteriaResolver memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from CriteriaResolver.\\n     *\\n     * @param obj The CriteriaResolver object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        CriteriaResolver calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Fulfillment.\\n     *\\n     * @param obj The Fulfillment object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Fulfillment memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Fulfillment.\\n     *\\n     * @param obj The Fulfillment object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Fulfillment calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from FulfillmentComponent.\\n     *\\n     * @param obj The FulfillmentComponent object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        FulfillmentComponent memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from FulfillmentComponent.\\n     *\\n     * @param obj The FulfillmentComponent object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        FulfillmentComponent calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Execution.\\n     *\\n     * @param obj The Execution object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Execution memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Execution.\\n     *\\n     * @param obj The Execution object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Execution calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ZoneParameters.\\n     *\\n     * @param obj The ZoneParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ZoneParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ZoneParameters.\\n     *\\n     * @param obj The ZoneParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ZoneParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/ConsiderationEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED,\\n\\n    // 4: contract order type\\n    CONTRACT\\n}\\n\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { ReentrancyErrors } from \\\"../interfaces/ReentrancyErrors.sol\\\";\\n\\nimport { LowLevelHelpers } from \\\"./LowLevelHelpers.sol\\\";\\n\\nimport {\\n    _revertInvalidMsgValue,\\n    _revertNoReentrantCalls\\n} from \\\"./ConsiderationErrors.sol\\\";\\n\\nimport {\\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS,\\n    _ENTERED,\\n    _NOT_ENTERED\\n} from \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title ReentrancyGuard\\n * @author 0age\\n * @notice ReentrancyGuard contains a storage variable and related functionality\\n *         for protecting against reentrancy.\\n */\\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\\n    // Prevent reentrant calls on protected functions.\\n    uint256 private _reentrancyGuard;\\n\\n    /**\\n     * @dev Initialize the reentrancy guard during deployment.\\n     */\\n    constructor() {\\n        // Initialize the reentrancy guard in a cleared state.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\\n     *      guard is not currently set and, if not, to set a sentinel value for\\n     *      the reentrancy guard based on whether or not native tokens may be\\n     *      received during execution or not.\\n     *\\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\\n     *                           be received during execution or not.\\n     */\\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\\n        // Ensure that the reentrancy guard is not already set.\\n        _assertNonReentrant();\\n\\n        // Set the reentrancy guard. A value of 2 indicates that native tokens\\n        // may not be accepted during execution, whereas a value of 3 indicates\\n        // that they will be accepted (with any remaining native tokens returned\\n        // to the caller).\\n        unchecked {\\n            _reentrancyGuard = _ENTERED + _cast(acceptNativeTokens);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to unset the reentrancy guard sentinel value.\\n     */\\n    function _clearReentrancyGuard() internal {\\n        // Clear the reentrancy guard.\\n        _reentrancyGuard = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that a sentinel value for the\\n            reentrancy guard is not currently set.\\n     */\\n    function _assertNonReentrant() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _NOT_ENTERED) {\\n            _revertNoReentrantCalls();\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to ensure that the sentinel value indicating\\n     *      native tokens may be received during execution is currently set.\\n     */\\n    function _assertAcceptingNativeTokens() internal view {\\n        // Ensure that the reentrancy guard is not currently set.\\n        if (_reentrancyGuard != _ENTERED_AND_ACCEPTING_NATIVE_TOKENS) {\\n            _revertInvalidMsgValue(msg.value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/interfaces/SeaportInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    AdvancedOrder,\\n    BasicOrderParameters,\\n    CriteriaResolver,\\n    Execution,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Order,\\n    OrderComponents\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title SeaportInterface\\n * @author 0age\\n * @custom:version 1.5\\n * @notice Seaport is a generalized native token/ERC20/ERC721/ERC1155\\n *         marketplace. It minimizes external calls to the greatest extent\\n *         possible and provides lightweight methods for common routes as well\\n *         as more flexible methods for composing advanced orders.\\n *\\n * @dev SeaportInterface contains all external function interfaces for Seaport.\\n */\\ninterface SeaportInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Seaport.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata order,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Seaport.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or\\n     *                    native tokens will not be reflected as part of this\\n     *                    array.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components. Any unspent offer item\\n     *         amounts will be transferred to the designated recipient (with the\\n     *         null address signifying to use the caller) and any unspent native\\n     *         tokens will be returned to the caller.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts, or the caller if the null address\\n     *                          is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments,\\n        address recipient\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata orders\\n    ) external returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration. Note that this function costs less gas than\\n     *         `fulfillBasicOrder` due to the zero bytes in the function\\n     *         selector (0x00000000) which also results in earlier function\\n     *         dispatch.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder_efficient_6GL6yc(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata order\\n    ) external view returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \".deps/contracts/interfaces/CoreskyRouterInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    AdvancedOrder,\\n    CriteriaResolver,\\n    FulfillmentComponent\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\nimport { Execution } from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title  CoreskyRouterInterface.sol\\n * @author Ryan Ghods (ralxz.eth), 0age (0age.eth), James Wenzel (emo.eth)\\n * @notice A utility contract for fulfilling orders with multiple\\n *         Seaport versions. DISCLAIMER: This contract only works when\\n *         all consideration items across all listings are native tokens.\\n */\\ninterface CoreskyRouterInterface {\\n    /**\\n     * @dev Revert with an error when attempting to fulfill any number of\\n     *      available orders when none are fulfillable.\\n     */\\n    error NoSpecifiedOrdersAvailable();\\n\\n    /**\\n     * @dev Advanced order parameters for use through the\\n     *      FulfillAvailableAdvancedOrdersParams struct.\\n     */\\n    struct AdvancedOrderParams {\\n        AdvancedOrder[] advancedOrders;\\n        CriteriaResolver[] criteriaResolvers;\\n        FulfillmentComponent[][] offerFulfillments;\\n        FulfillmentComponent[][] considerationFulfillments;\\n        uint256 etherValue; /// The ether value to send with the set of orders.\\n    }\\n\\n    /**\\n     * @dev Parameters for using fulfillAvailableAdvancedOrders\\n     *      through SeaportRouter.\\n     */\\n    struct FulfillAvailableAdvancedOrdersParams {\\n        address[] seaportContracts;\\n        AdvancedOrderParams[] advancedOrderParams;\\n        bytes32 fulfillerConduitKey;\\n        address recipient;\\n        uint256 maximumFulfilled;\\n    }\\n\\n    /**\\n     * @dev Calldata params for calling FulfillAvailableAdvancedOrders.\\n     */\\n    struct CalldataParams {\\n        AdvancedOrder[] advancedOrders;\\n        CriteriaResolver[] criteriaResolvers;\\n        FulfillmentComponent[][] offerFulfillments;\\n        FulfillmentComponent[][] considerationFulfillments;\\n        bytes32 fulfillerConduitKey;\\n        address recipient;\\n        uint256 maximumFulfilled;\\n    }\\n\\n    /**\\n     * @dev Revert with an error if a provided Seaport contract is not allowed\\n     *      to be used in the router.\\n     */\\n    error SeaportNotAllowed(address seaport);\\n\\n    /**\\n     * @dev Revert with an error if an ether transfer back to the fulfiller\\n     *      fails.\\n     */\\n    error EtherReturnTransferFailed(\\n        address recipient,\\n        uint256 amount,\\n        bytes returnData\\n    );\\n\\n    error TokenReturnTransferFailed(\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    error InValidTokenAndValue();\\n\\n    /**\\n     * @dev Fallback function to receive excess ether, in case total amount of\\n     *      ether sent is more than the amount required to fulfill the order.\\n     */\\n    receive() external payable;\\n\\n    /**\\n     * @notice Fulfill available advanced orders through multiple Seaport\\n     *         versions.\\n     *         See {SeaportInterface-fulfillAvailableAdvancedOrders}\\n     *\\n     * @param params The parameters for fulfilling available advanced orders.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        FulfillAvailableAdvancedOrdersParams calldata params,\\n        address token,\\n        uint256 tokenAmount,\\n        address[] calldata conduits\\n    )\\n        external\\n        payable\\n        returns (\\n            bool[][] memory availableOrders,\\n            Execution[][] memory executions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/ConsiderationConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\n// Declare constants for name, version, and reentrancy sentinel values.\\n\\n// Name is right padded, so it touches the length which is left padded. This\\n// enables writing both values at once. Length goes at byte 95 in memory, and\\n// name fills bytes 96-109, so both values can be written left-padded to 77.\\nuint256 constant NameLengthPtr = 0x4D;\\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\\n\\nuint256 constant information_version_offset = 0;\\nuint256 constant information_version_cd_offset = 0x60;\\nuint256 constant information_domainSeparator_offset = 0x20;\\nuint256 constant information_conduitController_offset = 0x40;\\nuint256 constant information_versionLengthPtr = 0x63;\\nuint256 constant information_versionWithLength = 0x03312e35; // 1.5\\nuint256 constant information_length = 0xa0;\\n\\nuint256 constant _NOT_ENTERED = 1;\\nuint256 constant _ENTERED = 2;\\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS = 3;\\n\\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts = (\\n    0x60\\n);\\n\\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\\n\\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\\n\\n// Common Offsets\\n// Offsets for identically positioned fields shared by:\\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\\n\\nuint256 constant Selector_length = 0x4;\\n\\nuint256 constant Common_token_offset = 0x20;\\nuint256 constant Common_identifier_offset = 0x40;\\nuint256 constant Common_amount_offset = 0x60;\\nuint256 constant Common_endAmount_offset = 0x80;\\n\\nuint256 constant SpentItem_size = 0x80;\\nuint256 constant SpentItem_size_shift = 0x7;\\n\\nuint256 constant OfferItem_size = 0xa0;\\nuint256 constant OfferItem_size_with_length = 0xc0;\\n\\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\\nuint256 constant ReceivedItem_size = 0xa0;\\nuint256 constant ReceivedItem_amount_offset = 0x60;\\nuint256 constant ReceivedItem_recipient_offset = 0x80;\\n\\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\\n\\nuint256 constant ConsiderationItem_size = 0xc0;\\nuint256 constant ConsiderationItem_size_with_length = 0xe0;\\n\\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\\n// Store the same constant in an abbreviated format for a line length fix.\\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\\n\\nuint256 constant Execution_offerer_offset = 0x20;\\nuint256 constant Execution_conduit_offset = 0x40;\\n\\n// uint256 constant OrderParameters_offerer_offset = 0x00;\\nuint256 constant OrderParameters_zone_offset = 0x20;\\nuint256 constant OrderParameters_offer_head_offset = 0x40;\\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\\n// uint256 constant OrderParameters_orderType_offset = 0x80;\\nuint256 constant OrderParameters_startTime_offset = 0xa0;\\nuint256 constant OrderParameters_endTime_offset = 0xc0;\\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\\n// uint256 constant OrderParameters_salt_offset = 0x100;\\nuint256 constant OrderParameters_conduit_offset = 0x120;\\nuint256 constant OrderParameters_counter_offset = 0x140;\\n\\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\\n\\nuint256 constant AdvancedOrder_head_size = 0xa0;\\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\\nuint256 constant AdvancedOrder_signature_offset = 0x60;\\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\\n\\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\\n\\nuint256 constant ThirtyOneBytes = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\nuint256 constant FourWords = 0x80;\\nuint256 constant FiveWords = 0xa0;\\n\\nuint256 constant OneWordShift = 0x5;\\nuint256 constant TwoWordsShift = 0x6;\\n\\nuint256 constant SixtyThreeBytes = 0x3f;\\nuint256 constant OnlyFullWordMask = 0xffffffe0;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\n\\n// uint256 constant BasicOrder_endAmount_cdPtr = 0x104;\\nuint256 constant BasicOrder_common_params_size = 0xa0;\\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\\nuint256 constant BasicOrder_receivedItemByteMap = (\\n    0x0000010102030000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BasicOrder_offeredItemByteMap = (\\n    0x0203020301010000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes32 constant OrdersMatchedTopic0 = (\\n    0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7\\n);\\n\\nuint256 constant EIP712_Order_size = 0x180;\\nuint256 constant EIP712_OfferItem_size = 0xc0;\\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\\nuint256 constant AdditionalRecipient_size = 0x40;\\nuint256 constant AdditionalRecipient_size_shift = 0x6;\\n\\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\\nuint256 constant EIP712_OrderHash_offset = 0x22;\\nuint256 constant EIP712_DigestPayload_size = 0x42;\\n\\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\\nuint256 constant EIP712_domainData_size = 0xa0;\\n\\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\\n// 768 for 24 siblings.\\n\\nuint256 constant BulkOrderProof_minSize = 0x63;\\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\\nuint256 constant BulkOrderProof_keyShift = 0xe8;\\nuint256 constant BulkOrderProof_keySize = 0x3;\\n\\nuint256 constant BulkOrder_Typehash_Height_One = (\\n    0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32\\n);\\nuint256 constant BulkOrder_Typehash_Height_Two = (\\n    0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30\\n);\\nuint256 constant BulkOrder_Typehash_Height_Three = (\\n    0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d\\n);\\nuint256 constant BulkOrder_Typehash_Height_Four = (\\n    0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1\\n);\\nuint256 constant BulkOrder_Typehash_Height_Five = (\\n    0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6\\n);\\nuint256 constant BulkOrder_Typehash_Height_Six = (\\n    0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55\\n);\\nuint256 constant BulkOrder_Typehash_Height_Seven = (\\n    0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c\\n);\\nuint256 constant BulkOrder_Typehash_Height_Eight = (\\n    0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14\\n);\\nuint256 constant BulkOrder_Typehash_Height_Nine = (\\n    0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a\\n);\\nuint256 constant BulkOrder_Typehash_Height_Ten = (\\n    0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05\\n);\\nuint256 constant BulkOrder_Typehash_Height_Eleven = (\\n    0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53\\n);\\nuint256 constant BulkOrder_Typehash_Height_Twelve = (\\n    0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f\\n);\\nuint256 constant BulkOrder_Typehash_Height_Thirteen = (\\n    0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e\\n);\\nuint256 constant BulkOrder_Typehash_Height_Fourteen = (\\n    0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590\\n);\\nuint256 constant BulkOrder_Typehash_Height_Fifteen = (\\n    0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9\\n);\\nuint256 constant BulkOrder_Typehash_Height_Sixteen = (\\n    0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8\\n);\\nuint256 constant BulkOrder_Typehash_Height_Seventeen = (\\n    0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222\\n);\\nuint256 constant BulkOrder_Typehash_Height_Eighteen = (\\n    0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877\\n);\\nuint256 constant BulkOrder_Typehash_Height_Nineteen = (\\n    0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d\\n);\\nuint256 constant BulkOrder_Typehash_Height_Twenty = (\\n    0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017\\n);\\nuint256 constant BulkOrder_Typehash_Height_TwentyOne = (\\n    0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719\\n);\\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo = (\\n    0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d\\n);\\nuint256 constant BulkOrder_Typehash_Height_TwentyThree = (\\n    0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76\\n);\\nuint256 constant BulkOrder_Typehash_Height_TwentyFour = (\\n    0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c\\n);\\n\\nuint256 constant receivedItemsHash_ptr = 0x60;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  data for OrderFulfilled\\n *\\n *   event OrderFulfilled(\\n *     bytes32 orderHash,\\n *     address indexed offerer,\\n *     address indexed zone,\\n *     address fulfiller,\\n *     SpentItem[] offer,\\n *       > (itemType, token, id, amount)\\n *     ReceivedItem[] consideration\\n *       > (itemType, token, id, amount, recipient)\\n *   )\\n *\\n *  - 0x00: orderHash\\n *  - 0x20: fulfiller\\n *  - 0x40: offer offset (0x80)\\n *  - 0x60: consideration offset (0x120)\\n *  - 0x80: offer.length (1)\\n *  - 0xa0: offerItemType\\n *  - 0xc0: offerToken\\n *  - 0xe0: offerIdentifier\\n *  - 0x100: offerAmount\\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\\n *  - 0x140: considerationItemType\\n *  - 0x160: considerationToken\\n *  - 0x180: considerationIdentifier\\n *  - 0x1a0: considerationAmount\\n *  - 0x1c0: considerationRecipient\\n *  - ...\\n */\\n\\n// Minimum length of the OrderFulfilled event data.\\n// Must be added to the size of the ReceivedItem array for additionalRecipients\\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\\nuint256 constant OrderFulfilled_selector = (\\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\\n);\\n\\n// Minimum offset in memory to OrderFulfilled event data.\\n// Must be added to the size of the EIP712 hash array for additionalRecipients\\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\\nuint256 constant OrderFulfilled_baseOffset = 0x180;\\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\\n\\n// Related constants used for restricted order checks on basic orders.\\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\\n\\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\\n\\n// BasicOrderParameters\\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\\nuint256 constant BasicOrder_parameters_ptr = 0x20;\\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for ConsiderationItem\\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\\n *   - 0xa0: itemType\\n *   - 0xc0: token\\n *   - 0xe0: identifier\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n *   - 0x140: recipient\\n */\\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for OfferItem\\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\\n *   - 0xa0:  itemType\\n *   - 0xc0:  token\\n *   - 0xe0:  identifier (reused for offeredItemsHash)\\n *   - 0x100: startAmount\\n *   - 0x120: endAmount\\n */\\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\\n\\n/*\\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\\n *  EIP712 data for Order\\n *   - 0x80:   Order EIP-712 typehash (constant)\\n *   - 0xa0:   orderParameters.offerer\\n *   - 0xc0:   orderParameters.zone\\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\\n *   - 0x120:  orderType\\n *   - 0x140:  startTime\\n *   - 0x160:  endTime\\n *   - 0x180:  zoneHash\\n *   - 0x1a0:  salt\\n *   - 0x1c0:  conduit\\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\\n */\\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\\nuint256 constant BasicOrder_signature_ptr = 0x260;\\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\\n\\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\\n\\nuint256 constant Counter_blockhash_shift = 0x80;\\n\\n// Signature-related\\nbytes32 constant EIP2098_allButHighestBitMask = (\\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n);\\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\\n    0x0000000000000000000000000000000000000000000000000000000101000000\\n);\\nuint256 constant ECDSA_MaxLength = 65;\\nuint256 constant ECDSA_signature_s_offset = 0x40;\\nuint256 constant ECDSA_signature_v_offset = 0x60;\\n\\nbytes32 constant EIP1271_isValidSignature_selector = (\\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\\n\\nuint256 constant EIP_712_PREFIX = (\\n    0x1901000000000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 0x3;\\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\\n\\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\\nuint256 constant Create2AddressDerivation_length = 0x55;\\n\\nuint256 constant MaskOverByteTwelve = (\\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\\n);\\nuint256 constant MaskOverLastTwentyBytes = (\\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\\n);\\nuint256 constant AddressDirtyUpperBitThreshold = (\\n    0x0000000000000000000000010000000000000000000000000000000000000000\\n);\\nuint256 constant MaskOverFirstFourBytes = (\\n    0xffffffff00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant Conduit_execute_signature = (\\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant MaxUint8 = 0xff;\\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\\n\\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\\n\\nuint256 constant OneConduitExecute_size = 0x104;\\n\\n// Sentinel value to indicate that the conduit accumulator is not armed.\\nuint256 constant AccumulatorDisarmed = 0x20;\\nuint256 constant AccumulatorArmed = 0x40;\\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\\nuint256 constant Accumulator_selector_ptr = 0x40;\\nuint256 constant Accumulator_array_offset_ptr = 0x44;\\nuint256 constant Accumulator_array_length_ptr = 0x64;\\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\\nuint256 constant Accumulator_array_offset = 0x20;\\n\\nuint256 constant Conduit_transferItem_size = 0xc0;\\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\\n\\nuint256 constant Ecrecover_precompile = 0x1;\\nuint256 constant Ecrecover_args_size = 0x80;\\nuint256 constant Signature_lower_v = 27;\\n\\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\\nuint256 constant NonMatchSelector_MagicMask = (\\n    0x4000000000000000000000000000000000000000000000000000000000\\n);\\n\\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\\n// indicates that a non match selector has been called.\\nuint256 constant NonMatchSelector_InvalidErrorValue = (\\n    0x4000000000000000000000000000000000000000000000000000000001\\n);\\n\\n/**\\n * @dev Selector and offsets for generateOrder\\n *\\n * function generateOrder(\\n *   address fulfiller,\\n *   SpentItem[] calldata minimumReceived,\\n *   SpentItem[] calldata maximumSpent,\\n *   bytes calldata context\\n * )\\n */\\nuint256 constant generateOrder_selector = 0x98919765;\\nuint256 constant generateOrder_selector_offset = 0x1c;\\nuint256 constant generateOrder_head_offset = 0x04;\\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\\nuint256 constant generateOrder_context_head_offset = 0x60;\\nuint256 constant generateOrder_base_tail_offset = 0x80;\\nuint256 constant generateOrder_maximum_returndatasize = 0xffff;\\n\\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\\nuint256 constant ratifyOrder_selector_offset = 0x1c;\\nuint256 constant ratifyOrder_head_offset = 0x04;\\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\\nuint256 constant ratifyOrder_context_head_offset = 0x40;\\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\\n\\nuint256 constant validateOrder_selector = 0x17b1f942;\\nuint256 constant validateOrder_selector_offset = 0x1c;\\nuint256 constant validateOrder_head_offset = 0x04;\\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\\n\\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\\nuint256 constant ZoneParameters_offerer_offset = 0x40;\\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\\nuint256 constant ZoneParameters_endTime_offset = 0x100;\\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x64;\\n\\n// ConsiderationDecoder Constants\\nuint256 constant OrderParameters_head_size = 0x0160;\\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\\n    0x0140\\n);\\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\\n\\nuint256 constant Order_signature_offset = 0x20;\\nuint256 constant Order_head_size = 0x40;\\n\\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\\n\\nuint256 constant CriteriaResolver_head_size = 0xa0;\\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\\n\\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\\nuint256 constant Fulfillment_head_size = 0x40;\\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\\n\\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\\n\"\r\n    },\r\n    \".deps/contracts/lib/ConsiderationErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { Side } from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    BadFraction_error_length,\\n    BadFraction_error_selector,\\n    CannotCancelOrder_error_length,\\n    CannotCancelOrder_error_selector,\\n    ConsiderationLengthNotEqualToTotalOriginal_error_length,\\n    ConsiderationLengthNotEqualToTotalOriginal_error_selector,\\n    ConsiderationNotMet_error_considerationIndex_ptr,\\n    ConsiderationNotMet_error_length,\\n    ConsiderationNotMet_error_orderIndex_ptr,\\n    ConsiderationNotMet_error_selector,\\n    ConsiderationNotMet_error_shortfallAmount_ptr,\\n    CriteriaNotEnabledForItem_error_length,\\n    CriteriaNotEnabledForItem_error_selector,\\n    Error_selector_offset,\\n    InsufficientNativeTokensSupplied_error_length,\\n    InsufficientNativeTokensSupplied_error_selector,\\n    InvalidBasicOrderParameterEncoding_error_length,\\n    InvalidBasicOrderParameterEncoding_error_selector,\\n    InvalidCallToConduit_error_conduit_ptr,\\n    InvalidCallToConduit_error_length,\\n    InvalidCallToConduit_error_selector,\\n    InvalidConduit_error_conduit_ptr,\\n    InvalidConduit_error_conduitKey_ptr,\\n    InvalidConduit_error_length,\\n    InvalidConduit_error_selector,\\n    InvalidContractOrder_error_length,\\n    InvalidContractOrder_error_orderHash_ptr,\\n    InvalidContractOrder_error_selector,\\n    InvalidERC721TransferAmount_error_amount_ptr,\\n    InvalidERC721TransferAmount_error_length,\\n    InvalidERC721TransferAmount_error_selector,\\n    InvalidMsgValue_error_length,\\n    InvalidMsgValue_error_selector,\\n    InvalidMsgValue_error_value_ptr,\\n    InvalidNativeOfferItem_error_length,\\n    InvalidNativeOfferItem_error_selector,\\n    InvalidProof_error_length,\\n    InvalidProof_error_selector,\\n    InvalidTime_error_endTime_ptr,\\n    InvalidTime_error_length,\\n    InvalidTime_error_selector,\\n    InvalidTime_error_startTime_ptr,\\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\\n    MismatchedOfferAndConsiderationComponents_error_length,\\n    MismatchedOfferAndConsiderationComponents_error_selector,\\n    MissingFulfillmentComponentOnAggregation_error_length,\\n    MissingFulfillmentComponentOnAggregation_error_selector,\\n    MissingFulfillmentComponentOnAggregation_error_side_ptr,\\n    MissingOriginalConsiderationItems_error_length,\\n    MissingOriginalConsiderationItems_error_selector,\\n    NoReentrantCalls_error_length,\\n    NoReentrantCalls_error_selector,\\n    NoSpecifiedOrdersAvailable_error_length,\\n    NoSpecifiedOrdersAvailable_error_selector,\\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\\n    OrderAlreadyFilled_error_length,\\n    OrderAlreadyFilled_error_orderHash_ptr,\\n    OrderAlreadyFilled_error_selector,\\n    OrderCriteriaResolverOutOfRange_error_length,\\n    OrderCriteriaResolverOutOfRange_error_selector,\\n    OrderCriteriaResolverOutOfRange_error_side_ptr,\\n    OrderIsCancelled_error_length,\\n    OrderIsCancelled_error_orderHash_ptr,\\n    OrderIsCancelled_error_selector,\\n    OrderPartiallyFilled_error_length,\\n    OrderPartiallyFilled_error_orderHash_ptr,\\n    OrderPartiallyFilled_error_selector,\\n    PartialFillsNotEnabledForOrder_error_length,\\n    PartialFillsNotEnabledForOrder_error_selector,\\n    UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\\n    UnresolvedConsiderationCriteria_error_length,\\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\\n    UnresolvedConsiderationCriteria_error_selector,\\n    UnresolvedOfferCriteria_error_length,\\n    UnresolvedOfferCriteria_error_offerIndex_ptr,\\n    UnresolvedOfferCriteria_error_orderIndex_ptr,\\n    UnresolvedOfferCriteria_error_selector,\\n    UnusedItemParameters_error_length,\\n    UnusedItemParameters_error_selector\\n} from \\\"./ConsiderationErrorConstants.sol\\\";\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"BadFraction\\\" error message.\\n */\\nfunction _revertBadFraction() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, BadFraction_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"BadFraction()\\\"))\\n        revert(Error_selector_offset, BadFraction_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"ConsiderationNotMet\\\" error\\n *      message, including the provided order index, consideration index, and\\n *      shortfall amount.\\n *\\n * @param orderIndex         The index of the order that did not meet the\\n *                           consideration criteria.\\n * @param considerationIndex The index of the consideration item that did not\\n *                           meet its criteria.\\n * @param shortfallAmount    The amount by which the consideration criteria were\\n *                           not met.\\n */\\nfunction _revertConsiderationNotMet(\\n    uint256 orderIndex,\\n    uint256 considerationIndex,\\n    uint256 shortfallAmount\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, ConsiderationNotMet_error_selector)\\n\\n        // Store arguments.\\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\\n        mstore(\\n            ConsiderationNotMet_error_considerationIndex_ptr,\\n            considerationIndex\\n        )\\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"ConsiderationNotMet(uint256,uint256,uint256)\\\",\\n        //     orderIndex,\\n        //     considerationIndex,\\n        //     shortfallAmount\\n        // ))\\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with a \\\"CriteriaNotEnabledForItem\\\" error\\n *      message.\\n */\\nfunction _revertCriteriaNotEnabledForItem() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"CriteriaNotEnabledForItem()\\\"))\\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an\\n *      \\\"InsufficientNativeTokensSupplied\\\" error message.\\n */\\nfunction _revertInsufficientNativeTokensSupplied() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InsufficientNativeTokensSupplied()\\\"))\\n        revert(\\n            Error_selector_offset,\\n            InsufficientNativeTokensSupplied_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an\\n *      \\\"InvalidBasicOrderParameterEncoding\\\" error message.\\n */\\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidBasicOrderParameterEncoding()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            InvalidBasicOrderParameterEncoding_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidCallToConduit\\\" error\\n *      message, including the provided address of the conduit that was called\\n *      improperly.\\n *\\n * @param conduit The address of the conduit that was called improperly.\\n */\\nfunction _revertInvalidCallToConduit(address conduit) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidCallToConduit_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidCallToConduit(address)\\\",\\n        //     conduit\\n        // ))\\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"CannotCancelOrder\\\" error\\n *      message.\\n */\\nfunction _revertCannotCancelOrder() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, CannotCancelOrder_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"CannotCancelOrder()\\\"))\\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidConduit\\\" error message,\\n *      including the provided key and address of the invalid conduit.\\n *\\n * @param conduitKey    The key of the invalid conduit.\\n * @param conduit       The address of the invalid conduit.\\n */\\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidConduit_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidConduit(bytes32,address)\\\",\\n        //     conduitKey,\\n        //     conduit\\n        // ))\\n        revert(Error_selector_offset, InvalidConduit_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidERC721TransferAmount\\\"\\n *      error message.\\n *\\n * @param amount The invalid amount.\\n */\\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidERC721TransferAmount_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidERC721TransferAmount(uint256)\\\",\\n        //     amount\\n        // ))\\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidMsgValue\\\" error message,\\n *      including the invalid value that was sent in the transaction's\\n *      `msg.value` field.\\n *\\n * @param value The invalid value that was sent in the transaction's `msg.value`\\n *              field.\\n */\\nfunction _revertInvalidMsgValue(uint256 value) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidMsgValue_error_selector)\\n\\n        // Store argument.\\n        mstore(InvalidMsgValue_error_value_ptr, value)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidMsgValue(uint256)\\\", value))\\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidNativeOfferItem\\\" error\\n *      message.\\n */\\nfunction _revertInvalidNativeOfferItem() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidNativeOfferItem_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidNativeOfferItem()\\\"))\\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidProof\\\" error message.\\n */\\nfunction _revertInvalidProof() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidProof_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"InvalidProof()\\\"))\\n        revert(Error_selector_offset, InvalidProof_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidContractOrder\\\" error\\n *      message.\\n *\\n * @param orderHash The hash of the contract order that caused the error.\\n */\\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidContractOrder_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidContractOrder(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts the current transaction with an \\\"InvalidTime\\\" error message.\\n *\\n * @param startTime       The time at which the order becomes active.\\n * @param endTime         The time at which the order becomes inactive.\\n */\\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, InvalidTime_error_selector)\\n\\n        // Store arguments.\\n        mstore(InvalidTime_error_startTime_ptr, startTime)\\n        mstore(InvalidTime_error_endTime_ptr, endTime)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"InvalidTime(uint256,uint256)\\\",\\n        //     startTime,\\n        //     endTime\\n        // ))\\n        revert(Error_selector_offset, InvalidTime_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a\\n *      \\\"MismatchedFulfillmentOfferAndConsiderationComponents\\\" error message.\\n *\\n * @param fulfillmentIndex         The index of the fulfillment that caused the\\n *                                 error.\\n */\\nfunction _revertMismatchedFulfillmentOfferAndConsiderationComponents(\\n    uint256 fulfillmentIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, MismatchedOfferAndConsiderationComponents_error_selector)\\n\\n        // Store fulfillment index argument.\\n        mstore(\\n            MismatchedOfferAndConsiderationComponents_error_idx_ptr,\\n            fulfillmentIndex\\n        )\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MismatchedFulfillmentOfferAndConsiderationComponents(uint256)\\\",\\n        //     fulfillmentIndex\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MismatchedOfferAndConsiderationComponents_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"MissingFulfillmentComponentOnAggregation\\\"\\n *       error message.\\n *\\n * @param side The side of the fulfillment component that is missing (0 for\\n *             offer, 1 for consideration).\\n *\\n */\\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\\n\\n        // Store argument.\\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MissingFulfillmentComponentOnAggregation(uint8)\\\",\\n        //     side\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MissingFulfillmentComponentOnAggregation_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"MissingOriginalConsiderationItems\\\" error\\n *      message.\\n */\\nfunction _revertMissingOriginalConsiderationItems() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"MissingOriginalConsiderationItems()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            MissingOriginalConsiderationItems_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"NoReentrantCalls\\\" error message.\\n */\\nfunction _revertNoReentrantCalls() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, NoReentrantCalls_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"NoReentrantCalls()\\\"))\\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"NoSpecifiedOrdersAvailable\\\" error message.\\n */\\nfunction _revertNoSpecifiedOrdersAvailable() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"NoSpecifiedOrdersAvailable()\\\"))\\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"OfferAndConsiderationRequiredOnFulfillment\\\"\\n *      error message.\\n */\\nfunction _revertOfferAndConsiderationRequiredOnFulfillment() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OfferAndConsiderationRequiredOnFulfillment_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OfferAndConsiderationRequiredOnFulfillment()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            OfferAndConsiderationRequiredOnFulfillment_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderAlreadyFilled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been filled.\\n */\\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderAlreadyFilled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderAlreadyFilled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderCriteriaResolverOutOfRange\\\" error\\n *      message.\\n *\\n * @param side The side of the criteria that is missing (0 for offer, 1 for\\n *             consideration).\\n *\\n */\\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderCriteriaResolverOutOfRange(uint8)\\\",\\n        //     side\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            OrderCriteriaResolverOutOfRange_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderIsCancelled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been cancelled.\\n */\\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderIsCancelled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderIsCancelled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"OrderPartiallyFilled\\\" error message.\\n *\\n * @param orderHash The hash of the order that has already been partially\\n *                  filled.\\n */\\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, OrderPartiallyFilled_error_selector)\\n\\n        // Store argument.\\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"OrderPartiallyFilled(bytes32)\\\",\\n        //     orderHash\\n        // ))\\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"PartialFillsNotEnabledForOrder\\\" error message.\\n */\\nfunction _revertPartialFillsNotEnabledForOrder() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"PartialFillsNotEnabledForOrder()\\\"))\\n        revert(\\n            Error_selector_offset,\\n            PartialFillsNotEnabledForOrder_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnresolvedConsiderationCriteria\\\" error\\n *      message.\\n */\\nfunction _revertUnresolvedConsiderationCriteria(\\n    uint256 orderIndex,\\n    uint256 considerationIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnresolvedConsiderationCriteria_error_selector)\\n\\n        // Store orderIndex and considerationIndex arguments.\\n        mstore(UnresolvedConsiderationCriteria_error_orderIndex_ptr, orderIndex)\\n        mstore(\\n            UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\\n            considerationIndex\\n        )\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"UnresolvedConsiderationCriteria(uint256, uint256)\\\",\\n        //     orderIndex,\\n        //     considerationIndex\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            UnresolvedConsiderationCriteria_error_length\\n        )\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnresolvedOfferCriteria\\\" error message.\\n */\\nfunction _revertUnresolvedOfferCriteria(\\n    uint256 orderIndex,\\n    uint256 offerIndex\\n) pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnresolvedOfferCriteria_error_selector)\\n\\n        // Store arguments.\\n        mstore(UnresolvedOfferCriteria_error_orderIndex_ptr, orderIndex)\\n        mstore(UnresolvedOfferCriteria_error_offerIndex_ptr, offerIndex)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"UnresolvedOfferCriteria(uint256, uint256)\\\",\\n        //     orderIndex,\\n        //     offerIndex\\n        // ))\\n        revert(Error_selector_offset, UnresolvedOfferCriteria_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with an \\\"UnusedItemParameters\\\" error message.\\n */\\nfunction _revertUnusedItemParameters() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, UnusedItemParameters_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\\"UnusedItemParameters()\\\"))\\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\\n    }\\n}\\n\\n/**\\n * @dev Reverts execution with a \\\"ConsiderationLengthNotEqualToTotalOriginal\\\"\\n *      error message.\\n */\\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\\n    assembly {\\n        // Store left-padded selector with push4 (reduces bytecode),\\n        // mem[28:32] = selector\\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\\n\\n        // revert(abi.encodeWithSignature(\\n        //     \\\"ConsiderationLengthNotEqualToTotalOriginal()\\\"\\n        // ))\\n        revert(\\n            Error_selector_offset,\\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\\n        )\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/LowLevelHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {\\n    CostPerWord,\\n    ExtraGasBuffer,\\n    FreeMemoryPointerSlot,\\n    MemoryExpansionCoefficientShift,\\n    OneWord,\\n    OneWordShift,\\n    ThirtyOneBytes\\n} from \\\"./ConsiderationConstants.sol\\\";\\n\\n/**\\n * @title LowLevelHelpers\\n * @author 0age\\n * @notice LowLevelHelpers contains logic for performing various low-level\\n *         operations.\\n */\\ncontract LowLevelHelpers {\\n    /**\\n     * @dev Internal view function to revert and pass along the revert reason if\\n     *      data was returned by the last call and that the size of that data\\n     *      does not exceed the currently allocated memory size.\\n     */\\n    function _revertWithReasonIfOneIsReturned() internal view {\\n        assembly {\\n            // If it returned a message, bubble it up as long as sufficient gas\\n            // remains to do so:\\n            if returndatasize() {\\n                // Ensure that sufficient gas is available to copy returndata\\n                // while expanding memory where necessary. Start by computing\\n                // the word size of returndata and allocated memory.\\n                let returnDataWords := shr(\\n                    OneWordShift,\\n                    add(returndatasize(), ThirtyOneBytes)\\n                )\\n\\n                // Note: use the free memory pointer in place of msize() to work\\n                // around a Yul warning that prevents accessing msize directly\\n                // when the IR pipeline is activated.\\n                let msizeWords := shr(\\n                    OneWordShift,\\n                    mload(FreeMemoryPointerSlot)\\n                )\\n\\n                // Next, compute the cost of the returndatacopy.\\n                let cost := mul(CostPerWord, returnDataWords)\\n\\n                // Then, compute cost of new memory allocation.\\n                if gt(returnDataWords, msizeWords) {\\n                    cost := add(\\n                        cost,\\n                        add(\\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\\n                            shr(\\n                                MemoryExpansionCoefficientShift,\\n                                sub(\\n                                    mul(returnDataWords, returnDataWords),\\n                                    mul(msizeWords, msizeWords)\\n                                )\\n                            )\\n                        )\\n                    )\\n                }\\n\\n                // Finally, add a small constant and compare to gas remaining;\\n                // bubble up the revert data if enough gas is still available.\\n                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                    // Copy returndata to memory; overwrite existing memory.\\n                    returndatacopy(0, 0, returndatasize())\\n\\n                    // Revert, specifying memory region with copied returndata.\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view function to branchlessly select either the caller (if\\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\\n     *      that recipient is a nonzero value).\\n     *\\n     * @param recipient The supplied recipient.\\n     *\\n     * @return updatedRecipient The updated recipient.\\n     */\\n    function _substituteCallerForEmptyRecipient(\\n        address recipient\\n    ) internal view returns (address updatedRecipient) {\\n        // Utilize assembly to perform a branchless operation on the recipient.\\n        assembly {\\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\\n     *\\n     * @param b The `bool` value to cast.\\n     *\\n     * @return u The `uint256` value.\\n     */\\n    function _cast(bool b) internal pure returns (uint256 u) {\\n        assembly {\\n            u := b\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/interfaces/ReentrancyErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ReentrancyErrors\\n * @author 0age\\n * @notice ReentrancyErrors contains errors related to reentrancy.\\n */\\ninterface ReentrancyErrors {\\n    /**\\n     * @dev Revert with an error when a caller attempts to reenter a protected\\n     *      function.\\n     */\\n    error NoReentrantCalls();\\n}\\n\"\r\n    },\r\n    \".deps/contracts/helpers/PointerLibraries.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ntype CalldataPointer is uint256;\\n\\ntype ReturndataPointer is uint256;\\n\\ntype MemoryPointer is uint256;\\n\\nusing CalldataPointerLib for CalldataPointer global;\\nusing MemoryPointerLib for MemoryPointer global;\\nusing ReturndataPointerLib for ReturndataPointer global;\\n\\nusing CalldataReaders for CalldataPointer global;\\nusing ReturndataReaders for ReturndataPointer global;\\nusing MemoryReaders for MemoryPointer global;\\nusing MemoryWriters for MemoryPointer global;\\n\\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\\nuint256 constant IdentityPrecompileAddress = 0x4;\\nuint256 constant OffsetOrLengthMask = 0xffffffff;\\nuint256 constant _OneWord = 0x20;\\nuint256 constant _FreeMemoryPointerSlot = 0x40;\\n\\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\\n///    and returns the memory pointer to the first byte of the allocated region.\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\\n    assembly {\\n        mPtr := mload(_FreeMemoryPointerSlot)\\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\\n    }\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\\n    FreeMemoryPPtr.write(mPtr);\\n}\\n\\nlibrary CalldataPointerLib {\\n    function lt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `cdPtr + headOffset`.\\n    function pptr(\\n        CalldataPointer cdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(\\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\\n    ///      first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\\n    function next(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        CalldataPointer cdPtr,\\n        uint256 _offset\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\\n    ///      `dst`.\\n    function copy(\\n        CalldataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            calldatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataPointerLib {\\n    function lt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `rdPtr + headOffset`.\\n    function pptr(\\n        ReturndataPointer rdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(\\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\\n    function next(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        ReturndataPointer rdPtr,\\n        uint256 _offset\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\\n    /// `dst`.\\n    function copy(\\n        ReturndataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            returndatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary MemoryPointerLib {\\n    function copy(\\n        MemoryPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal view {\\n        assembly {\\n            let success := staticcall(\\n                gas(),\\n                IdentityPrecompileAddress,\\n                src,\\n                size,\\n                dst,\\n                size\\n            )\\n            if or(iszero(returndatasize()), iszero(success)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function lt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    function hash(\\n        MemoryPointer ptr,\\n        uint256 length\\n    ) internal pure returns (bytes32 _hash) {\\n        assembly {\\n            _hash := keccak256(ptr, length)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer one word after `mPtr`.\\n    function next(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\\n    function offset(\\n        MemoryPointer mPtr,\\n        uint256 _offset\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\\n    ///    type's pointer stored at `mPtr + headOffset`.\\n    function pptr(\\n        MemoryPointer mPtr,\\n        uint256 headOffset\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\\n    }\\n\\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\\n    ///    `mPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.readMemoryPointer();\\n    }\\n}\\n\\nlibrary CalldataReaders {\\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\\n    ///    last 4 bytes.\\n    function readMaskedUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `cdPtr` in calldata.\\n    function readBool(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `cdPtr` in calldata.\\n    function readAddress(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\\n    function readBytes1(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\\n    function readBytes2(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\\n    function readBytes3(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\\n    function readBytes4(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\\n    function readBytes5(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\\n    function readBytes6(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\\n    function readBytes7(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\\n    function readBytes8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\\n    function readBytes9(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\\n    function readBytes10(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\\n    function readBytes11(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\\n    function readBytes12(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\\n    function readBytes13(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\\n    function readBytes14(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\\n    function readBytes15(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\\n    function readBytes16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\\n    function readBytes17(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\\n    function readBytes18(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\\n    function readBytes19(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\\n    function readBytes20(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\\n    function readBytes21(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\\n    function readBytes22(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\\n    function readBytes23(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\\n    function readBytes24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\\n    function readBytes25(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\\n    function readBytes26(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\\n    function readBytes27(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\\n    function readBytes28(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\\n    function readBytes29(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\\n    function readBytes30(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\\n    function readBytes31(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\\n    function readBytes32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\\n    function readUint8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\\n    function readUint16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\\n    function readUint24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\\n    function readUint32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\\n    function readUint40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\\n    function readUint48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\\n    function readUint56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\\n    function readUint64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\\n    function readUint72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\\n    function readUint80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\\n    function readUint88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\\n    function readUint96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\\n    function readUint104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\\n    function readUint112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\\n    function readUint120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\\n    function readUint128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\\n    function readUint136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\\n    function readUint144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\\n    function readUint152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\\n    function readUint160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\\n    function readUint168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\\n    function readUint176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\\n    function readUint184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\\n    function readUint192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\\n    function readUint200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\\n    function readUint208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\\n    function readUint216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\\n    function readUint224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\\n    function readUint232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\\n    function readUint240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\\n    function readUint248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\\n    function readUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `cdPtr` in calldata.\\n    function readInt8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `cdPtr` in calldata.\\n    function readInt16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `cdPtr` in calldata.\\n    function readInt24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `cdPtr` in calldata.\\n    function readInt32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `cdPtr` in calldata.\\n    function readInt40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `cdPtr` in calldata.\\n    function readInt48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `cdPtr` in calldata.\\n    function readInt56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `cdPtr` in calldata.\\n    function readInt64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `cdPtr` in calldata.\\n    function readInt72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `cdPtr` in calldata.\\n    function readInt80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `cdPtr` in calldata.\\n    function readInt88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `cdPtr` in calldata.\\n    function readInt96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `cdPtr` in calldata.\\n    function readInt104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `cdPtr` in calldata.\\n    function readInt112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `cdPtr` in calldata.\\n    function readInt120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `cdPtr` in calldata.\\n    function readInt128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `cdPtr` in calldata.\\n    function readInt136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `cdPtr` in calldata.\\n    function readInt144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `cdPtr` in calldata.\\n    function readInt152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `cdPtr` in calldata.\\n    function readInt160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `cdPtr` in calldata.\\n    function readInt168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `cdPtr` in calldata.\\n    function readInt176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `cdPtr` in calldata.\\n    function readInt184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `cdPtr` in calldata.\\n    function readInt192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `cdPtr` in calldata.\\n    function readInt200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `cdPtr` in calldata.\\n    function readInt208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `cdPtr` in calldata.\\n    function readInt216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `cdPtr` in calldata.\\n    function readInt224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `cdPtr` in calldata.\\n    function readInt232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `cdPtr` in calldata.\\n    function readInt240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `cdPtr` in calldata.\\n    function readInt248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `cdPtr` in calldata.\\n    function readInt256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataReaders {\\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `rdPtr` in returndata.\\n    function readBool(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `rdPtr` in returndata.\\n    function readAddress(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\\n    function readBytes1(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\\n    function readBytes2(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\\n    function readBytes3(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\\n    function readBytes4(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\\n    function readBytes5(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\\n    function readBytes6(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\\n    function readBytes7(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\\n    function readBytes8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\\n    function readBytes9(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\\n    function readBytes10(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\\n    function readBytes11(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\\n    function readBytes12(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\\n    function readBytes13(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\\n    function readBytes14(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\\n    function readBytes15(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\\n    function readBytes16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\\n    function readBytes17(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\\n    function readBytes18(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\\n    function readBytes19(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\\n    function readBytes20(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\\n    function readBytes21(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\\n    function readBytes22(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\\n    function readBytes23(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\\n    function readBytes24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\\n    function readBytes25(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\\n    function readBytes26(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\\n    function readBytes27(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\\n    function readBytes28(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\\n    function readBytes29(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\\n    function readBytes30(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\\n    function readBytes31(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\\n    function readBytes32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\\n    function readUint8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\\n    function readUint16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\\n    function readUint24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\\n    function readUint32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\\n    function readUint40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\\n    function readUint48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\\n    function readUint56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\\n    function readUint64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\\n    function readUint72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\\n    function readUint80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\\n    function readUint88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\\n    function readUint96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\\n    function readUint104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\\n    function readUint112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\\n    function readUint120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\\n    function readUint128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\\n    function readUint136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\\n    function readUint144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\\n    function readUint152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\\n    function readUint160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\\n    function readUint168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\\n    function readUint176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\\n    function readUint184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\\n    function readUint192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\\n    function readUint200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\\n    function readUint208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\\n    function readUint216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\\n    function readUint224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\\n    function readUint232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\\n    function readUint240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\\n    function readUint248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\\n    function readUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `rdPtr` in returndata.\\n    function readInt8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `rdPtr` in returndata.\\n    function readInt16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `rdPtr` in returndata.\\n    function readInt24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `rdPtr` in returndata.\\n    function readInt32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `rdPtr` in returndata.\\n    function readInt40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `rdPtr` in returndata.\\n    function readInt48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `rdPtr` in returndata.\\n    function readInt56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `rdPtr` in returndata.\\n    function readInt64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `rdPtr` in returndata.\\n    function readInt72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `rdPtr` in returndata.\\n    function readInt80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `rdPtr` in returndata.\\n    function readInt88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `rdPtr` in returndata.\\n    function readInt96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `rdPtr` in returndata.\\n    function readInt104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `rdPtr` in returndata.\\n    function readInt112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `rdPtr` in returndata.\\n    function readInt120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `rdPtr` in returndata.\\n    function readInt128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `rdPtr` in returndata.\\n    function readInt136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `rdPtr` in returndata.\\n    function readInt144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `rdPtr` in returndata.\\n    function readInt152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `rdPtr` in returndata.\\n    function readInt160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `rdPtr` in returndata.\\n    function readInt168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `rdPtr` in returndata.\\n    function readInt176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `rdPtr` in returndata.\\n    function readInt184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `rdPtr` in returndata.\\n    function readInt192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `rdPtr` in returndata.\\n    function readInt200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `rdPtr` in returndata.\\n    function readInt208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `rdPtr` in returndata.\\n    function readInt216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `rdPtr` in returndata.\\n    function readInt224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `rdPtr` in returndata.\\n    function readInt232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `rdPtr` in returndata.\\n    function readInt240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `rdPtr` in returndata.\\n    function readInt248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `rdPtr` in returndata.\\n    function readInt256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n}\\n\\nlibrary MemoryReaders {\\n    /// @dev Reads the memory pointer at `mPtr` in memory.\\n    function readMemoryPointer(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        value = mPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `mPtr` in memory.\\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `mPtr` in memory.\\n    function readAddress(\\n        MemoryPointer mPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `mPtr` in memory.\\n    function readBytes1(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `mPtr` in memory.\\n    function readBytes2(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `mPtr` in memory.\\n    function readBytes3(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `mPtr` in memory.\\n    function readBytes4(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `mPtr` in memory.\\n    function readBytes5(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `mPtr` in memory.\\n    function readBytes6(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `mPtr` in memory.\\n    function readBytes7(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `mPtr` in memory.\\n    function readBytes8(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `mPtr` in memory.\\n    function readBytes9(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `mPtr` in memory.\\n    function readBytes10(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `mPtr` in memory.\\n    function readBytes11(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `mPtr` in memory.\\n    function readBytes12(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `mPtr` in memory.\\n    function readBytes13(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `mPtr` in memory.\\n    function readBytes14(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `mPtr` in memory.\\n    function readBytes15(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `mPtr` in memory.\\n    function readBytes16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `mPtr` in memory.\\n    function readBytes17(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `mPtr` in memory.\\n    function readBytes18(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `mPtr` in memory.\\n    function readBytes19(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `mPtr` in memory.\\n    function readBytes20(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `mPtr` in memory.\\n    function readBytes21(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `mPtr` in memory.\\n    function readBytes22(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `mPtr` in memory.\\n    function readBytes23(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `mPtr` in memory.\\n    function readBytes24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `mPtr` in memory.\\n    function readBytes25(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `mPtr` in memory.\\n    function readBytes26(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `mPtr` in memory.\\n    function readBytes27(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `mPtr` in memory.\\n    function readBytes28(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `mPtr` in memory.\\n    function readBytes29(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `mPtr` in memory.\\n    function readBytes30(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `mPtr` in memory.\\n    function readBytes31(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `mPtr` in memory.\\n    function readBytes32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `mPtr` in memory.\\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `mPtr` in memory.\\n    function readUint16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `mPtr` in memory.\\n    function readUint24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `mPtr` in memory.\\n    function readUint32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `mPtr` in memory.\\n    function readUint40(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `mPtr` in memory.\\n    function readUint48(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `mPtr` in memory.\\n    function readUint56(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `mPtr` in memory.\\n    function readUint64(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `mPtr` in memory.\\n    function readUint72(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `mPtr` in memory.\\n    function readUint80(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `mPtr` in memory.\\n    function readUint88(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `mPtr` in memory.\\n    function readUint96(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `mPtr` in memory.\\n    function readUint104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `mPtr` in memory.\\n    function readUint112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `mPtr` in memory.\\n    function readUint120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `mPtr` in memory.\\n    function readUint128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `mPtr` in memory.\\n    function readUint136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `mPtr` in memory.\\n    function readUint144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `mPtr` in memory.\\n    function readUint152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `mPtr` in memory.\\n    function readUint160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `mPtr` in memory.\\n    function readUint168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `mPtr` in memory.\\n    function readUint176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `mPtr` in memory.\\n    function readUint184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `mPtr` in memory.\\n    function readUint192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `mPtr` in memory.\\n    function readUint200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `mPtr` in memory.\\n    function readUint208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `mPtr` in memory.\\n    function readUint216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `mPtr` in memory.\\n    function readUint224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `mPtr` in memory.\\n    function readUint232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `mPtr` in memory.\\n    function readUint240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `mPtr` in memory.\\n    function readUint248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `mPtr` in memory.\\n    function readUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `mPtr` in memory.\\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `mPtr` in memory.\\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `mPtr` in memory.\\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `mPtr` in memory.\\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `mPtr` in memory.\\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `mPtr` in memory.\\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `mPtr` in memory.\\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `mPtr` in memory.\\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `mPtr` in memory.\\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `mPtr` in memory.\\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `mPtr` in memory.\\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `mPtr` in memory.\\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `mPtr` in memory.\\n    function readInt104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `mPtr` in memory.\\n    function readInt112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `mPtr` in memory.\\n    function readInt120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `mPtr` in memory.\\n    function readInt128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `mPtr` in memory.\\n    function readInt136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `mPtr` in memory.\\n    function readInt144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `mPtr` in memory.\\n    function readInt152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `mPtr` in memory.\\n    function readInt160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `mPtr` in memory.\\n    function readInt168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `mPtr` in memory.\\n    function readInt176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `mPtr` in memory.\\n    function readInt184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `mPtr` in memory.\\n    function readInt192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `mPtr` in memory.\\n    function readInt200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `mPtr` in memory.\\n    function readInt208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `mPtr` in memory.\\n    function readInt216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `mPtr` in memory.\\n    function readInt224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `mPtr` in memory.\\n    function readInt232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `mPtr` in memory.\\n    function readInt240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `mPtr` in memory.\\n    function readInt248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `mPtr` in memory.\\n    function readInt256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n}\\n\\nlibrary MemoryWriters {\\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\\n        assembly {\\n            mstore(mPtr, valuePtr)\\n        }\\n    }\\n\\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, bool value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an address `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, address value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \".deps/contracts/lib/ConsiderationErrorConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nuint256 constant Error_selector_offset = 0x1c;\\n\\n/*\\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: side\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\\n    0x375c24c1\\n);\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\\n\\n/*\\n *  error OfferAndConsiderationRequiredOnFulfillment()\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\\n    0x98e9db6e\\n);\\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\\n\\n/*\\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\\n *      uint256 fulfillmentIndex\\n *  )\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: fulfillmentIndex\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\\n    0xbced929d\\n);\\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\\n\\n/*\\n *  error InvalidFulfillmentComponentData()\\n *    - Defined in FulfillmentApplicationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\\n\\n/*\\n *  error InexactFraction()\\n *    - Defined in AmountDerivationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\\nuint256 constant InexactFraction_error_length = 0x04;\\n\\n/*\\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: side\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\\n\\n/*\\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: offerIndex\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\\n\\n/*\\n *  error UnresolvedConsiderationCriteria(\\n *      uint256 orderIndex,\\n *      uint256 considerationIndex\\n *  )\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: considerationIndex\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\\nuint256 constant UnresolvedConsiderationCriteria_error_considerationIdx_ptr = (\\n    0x40\\n);\\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\\n\\n/*\\n *  error OfferCriteriaResolverOutOfRange()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\\n// uint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\\n\\n/*\\n *  error ConsiderationCriteriaResolverOutOfRange()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\\n    0x6088d7de\\n);\\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\\n    0x6088d7de\\n);\\n// uint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\\n\\n/*\\n *  error CriteriaNotEnabledForItem()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\\n\\n/*\\n *  error InvalidProof()\\n *    - Defined in CriteriaResolutionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidProof_error_selector = 0x09bde339;\\nuint256 constant InvalidProof_error_length = 0x04;\\n\\n/*\\n *  error InvalidRestrictedOrder(bytes32 orderHash)\\n *    - Defined in ZoneInteractionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\\n\\n/*\\n *  error InvalidContractOrder(bytes32 orderHash)\\n *    - Defined in ZoneInteractionErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\\nuint256 constant InvalidContractOrder_error_length = 0x24;\\n\\n/*\\n *  error BadSignatureV(uint8 v)\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: v\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\\nuint256 constant BadSignatureV_error_length = 0x24;\\n\\n/*\\n *  error InvalidSigner()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\\nuint256 constant InvalidSigner_error_length = 0x04;\\n\\n/*\\n *  error InvalidSignature()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\\nuint256 constant InvalidSignature_error_length = 0x04;\\n\\n/*\\n *  error BadContractSignature()\\n *    - Defined in SignatureVerificationErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\\nuint256 constant BadContractSignature_error_length = 0x04;\\n\\n/*\\n *  error InvalidERC721TransferAmount(uint256 amount)\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: amount\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\\n\\n/*\\n *  error MissingItemAmount()\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\\nuint256 constant MissingItemAmount_error_length = 0x04;\\n\\n/*\\n *  error UnusedItemParameters()\\n *    - Defined in TokenTransferrerErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\\nuint256 constant UnusedItemParameters_error_length = 0x04;\\n\\n/*\\n *  error NoReentrantCalls()\\n *    - Defined in ReentrancyErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\\nuint256 constant NoReentrantCalls_error_length = 0x04;\\n\\n/*\\n *  error OrderAlreadyFilled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\\n\\n/*\\n *  error InvalidTime(uint256 startTime, uint256 endTime)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: startTime\\n *    - 0x40: endTime\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\\nuint256 constant InvalidTime_error_length = 0x44;\\n\\n/*\\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: conduitKey\\n *    - 0x40: conduit\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\\nuint256 constant InvalidConduit_error_length = 0x44;\\n\\n/*\\n *  error MissingOriginalConsiderationItems()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\\n\\n/*\\n *  error InvalidCallToConduit(address conduit)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: conduit\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\\nuint256 constant InvalidCallToConduit_error_length = 0x24;\\n\\n/*\\n *  error ConsiderationNotMet(\\n *      uint256 orderIndex,\\n *      uint256 considerationIndex,\\n *      uint256 shortfallAmount\\n *  )\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderIndex\\n *    - 0x40: considerationIndex\\n *    - 0x60: shortfallAmount\\n * Revert buffer is memory[0x1c:0x80]\\n */\\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\\nuint256 constant ConsiderationNotMet_error_length = 0x64;\\n\\n/*\\n *  error InsufficientNativeTokensSupplied()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\\n\\n/*\\n *  error NativeTokenTransferGenericFailure(address account, uint256 amount)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: account\\n *    - 0x40: amount\\n * Revert buffer is memory[0x1c:0x60]\\n */\\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\\n\\n/*\\n *  error PartialFillsNotEnabledForOrder()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\\n\\n/*\\n *  error OrderIsCancelled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderIsCancelled_error_length = 0x24;\\n\\n/*\\n *  error OrderPartiallyFilled(bytes32 orderHash)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: orderHash\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\\n\\n/*\\n *  error CannotCancelOrder()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\\nuint256 constant CannotCancelOrder_error_length = 0x04;\\n\\n/*\\n *  error BadFraction()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant BadFraction_error_selector = 0x5a052b32;\\nuint256 constant BadFraction_error_length = 0x04;\\n\\n/*\\n *  error InvalidMsgValue(uint256 value)\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: value\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\\nuint256 constant InvalidMsgValue_error_length = 0x24;\\n\\n/*\\n *  error InvalidBasicOrderParameterEncoding()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\\n\\n/*\\n *  error NoSpecifiedOrdersAvailable()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\\n\\n/*\\n *  error InvalidNativeOfferItem()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\\n\\n/*\\n *  error ConsiderationLengthNotEqualToTotalOriginal()\\n *    - Defined in ConsiderationEventsAndErrors.sol\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n * Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\\n    0x2165628a\\n);\\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\\n\\n/*\\n *  error Panic(uint256 code)\\n *    - Built-in Solidity error\\n *  Memory layout:\\n *    - 0x00: Left-padded selector (data begins at 0x1c)\\n *    - 0x20: code\\n * Revert buffer is memory[0x1c:0x40]\\n */\\nuint256 constant Panic_error_selector = 0x4e487b71;\\nuint256 constant Panic_error_code_ptr = 0x20;\\nuint256 constant Panic_error_length = 0x24;\\n\\nuint256 constant Panic_arithmetic = 0x11;\\n// uint256 constant Panic_resource = 0x41;\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"proxies\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"EtherReturnTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InValidTokenAndValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seaport\",\"type\":\"address\"}],\"name\":\"SeaportNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReturnTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"addMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"seaportContracts\",\"type\":\"address[]\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"advancedOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"offerFulfillments\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"considerationFulfillments\",\"type\":\"tuple[][]\"},{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"}],\"internalType\":\"struct CoreskyRouterInterface.AdvancedOrderParams[]\",\"name\":\"advancedOrderParams\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"internalType\":\"struct CoreskyRouterInterface.FulfillAvailableAdvancedOrdersParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"conduits\",\"type\":\"address[]\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[][]\",\"name\":\"availableOrders\",\"type\":\"bool[][]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[][]\",\"name\":\"executions\",\"type\":\"tuple[][]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"updateMarketStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CoreskyRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000006c3852cbef3e08e8df289169ede58100000000000000000000000000000000000001ad428e4906ae43d8f9852d0dd600000000000000000000000000000000000000adc04c56bf30ac9d3c0aaf14dc000000000000000000000000179886f229f9cd52016c6dbf4be66e18111ec6ab", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7415794ce7b30dc1c98278a2f85d612a1540dd8c38629f3a44ebab5614560ca4"}