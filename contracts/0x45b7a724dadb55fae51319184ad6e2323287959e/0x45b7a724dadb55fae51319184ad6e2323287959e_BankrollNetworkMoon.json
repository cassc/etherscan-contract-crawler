{"SourceCode": "/*\r\n    SPDX-License-Identifier: MIT\r\n    A Bankteller Production\r\n    Bankroll Network\r\n    Copyright 2020\r\n*/\r\npragma solidity ^0.4.25;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not current owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Non-zero address required\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n}\r\n\r\ncontract UniSwapV2LiteRouter {\r\n    //function ethToTokenSwapInput(uint256 min_tokens) public payable returns (uint256);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] amounts);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] path)\r\n        external\r\n        view\r\n        returns (uint256[] amounts);\r\n}\r\n\r\n/*\r\n * @dev Moon is a perpetual rewards contract\r\n */\r\n\r\ncontract BankrollNetworkMoon is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0, \"Insufficient tokens\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends() > 0, \"Insufficient dividends\");\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n    event onLeaderBoard(\r\n        address indexed customerAddress,\r\n        uint256 invested,\r\n        uint256 tokens,\r\n        uint256 soldTokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingeth,\r\n        uint256 tokensMinted,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethEarned,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethReinvested,\r\n        uint256 tokensMinted,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethWithdrawn,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onClaim(\r\n        address indexed customerAddress,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onUpdateIntervals(uint256 payout, uint256 fund);\r\n\r\n    event onCollateraltoReward(\r\n        uint256 collateralAmount,\r\n        uint256 rewardAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onEthtoCollateral(\r\n        uint256 ethAmount,\r\n        uint256 tokenAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onRewardtoCollateral(\r\n        uint256 ethAmount,\r\n        uint256 tokenAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onBalance(uint256 balance, uint256 rewardBalance, uint256 timestamp);\r\n\r\n    event onDonation(address indexed from, uint256 amount, uint256 timestamp);\r\n\r\n    event onRouterUpdate(address oldAddress, address newAddress);\r\n\r\n    event onFlushUpdate(uint256 oldFlushSize, uint256 newFlushSize);\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint256 invested;\r\n        uint256 reinvested;\r\n        uint256 withdrawn;\r\n        uint256 rewarded;\r\n        uint256 contributed;\r\n        uint256 transferredTokens;\r\n        uint256 receivedTokens;\r\n        uint256 xInvested;\r\n        uint256 xReinvested;\r\n        uint256 xRewarded;\r\n        uint256 xContributed;\r\n        uint256 xWithdrawn;\r\n        uint256 xTransferredTokens;\r\n        uint256 xReceivedTokens;\r\n    }\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 15% dividends for token purchase\r\n    uint8 internal constant entryFee_ = 10;\r\n\r\n    /// @dev 5% dividends for token selling\r\n    uint8 internal constant exitFee_ = 10;\r\n\r\n    uint8 internal constant instantFee = 20;\r\n\r\n    uint8 constant payoutRate_ = 2;\r\n\r\n    uint256 internal constant magnitude = 2**64;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) private tokenBalanceLedger_;\r\n    mapping(address => int256) private payoutsTo_;\r\n    mapping(address => Stats) private stats;\r\n    //on chain referral tracking\r\n    uint256 private tokenSupply_;\r\n    uint256 private profitPerShare_;\r\n    uint256 public totalDeposits;\r\n    uint256 internal lastBalance_;\r\n\r\n    uint256 public players;\r\n    uint256 public totalTxs;\r\n    uint256 public collateralBuffer_;\r\n    uint256 public lastPayout;\r\n    uint256 public lastFunding;\r\n    uint256 public totalClaims;\r\n\r\n    uint256 public balanceInterval = 6 hours;\r\n    uint256 public payoutInterval = 2 seconds;\r\n    uint256 public fundingInterval = 2 seconds;\r\n    uint256 public flushSize = 0.00000000001 ether;\r\n\r\n    address public swapAddress;\r\n    address public rewardAddress;\r\n    address public collateralAddress;\r\n\r\n    Token private rewardToken;\r\n    Token private collateralToken;\r\n    UniSwapV2LiteRouter private swap;\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(\r\n        address _collateralAddress,\r\n        address _rewardAddress,\r\n        address _swapAddress\r\n    ) public Ownable() {\r\n        rewardAddress = _rewardAddress;\r\n        rewardToken = Token(_rewardAddress);\r\n\r\n        collateralAddress = _collateralAddress;\r\n        collateralToken = Token(_collateralAddress);\r\n\r\n        swapAddress = _swapAddress;\r\n        swap = UniSwapV2LiteRouter(_swapAddress);\r\n\r\n        lastPayout = now;\r\n        lastFunding = now;\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy() public payable returns (uint256) {\r\n        return buyFor(msg.sender);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress) public payable returns (uint256) {\r\n        require(msg.value > 0, \"Non-zero amount required\");\r\n\r\n        //Convert ETH to collateral\r\n        uint256 _buy_amount = ethToCollateral(msg.value);\r\n\r\n        totalDeposits += _buy_amount;\r\n        uint256 amount = purchaseTokens(_customerAddress, _buy_amount);\r\n\r\n        emit onLeaderBoard(\r\n            _customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to handle eth that was send straight to the contract\r\n     *  Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function() public payable {\r\n        //Just bounce\r\n        require(false, \"This contract does not except ETH\");\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() public onlyStronghands {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends();\r\n        // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens, now);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(\r\n            stats[_customerAddress].reinvested,\r\n            _dividends\r\n        );\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        emit onLeaderBoard(\r\n            _customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() public onlyStronghands {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends();\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n\r\n        // lambo delivery service\r\n        collateralToken.transfer(_customerAddress, _dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(\r\n            stats[_customerAddress].withdrawn,\r\n            _dividends\r\n        );\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends, now);\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Liquifies STCK to collateral tokens.\r\n    function sell(uint256 _amountOfTokens) public onlyBagholders {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(\r\n            _amountOfTokens <= tokenBalanceLedger_[_customerAddress],\r\n            \"Amount of tokens is greater than balance\"\r\n        );\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) /\r\n            100;\r\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _amountOfTokens\r\n        );\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256)(\r\n            profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude)\r\n        );\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n        //drip and buybacks applied after supply is updated\r\n        allocateFees(_undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\r\n\r\n        emit onLeaderBoard(\r\n            _customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from the caller to a new holder.\r\n     *  Zero fees\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        external\r\n        onlyBagholders\r\n        returns (bool)\r\n    {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(\r\n            _amountOfTokens <= tokenBalanceLedger_[_customerAddress],\r\n            \"Amount of tokens is greater than balance\"\r\n        );\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _amountOfTokens\r\n        );\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(\r\n            tokenBalanceLedger_[_toAddress],\r\n            _amountOfTokens\r\n        );\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256)(\r\n            profitPerShare_ * _amountOfTokens\r\n        );\r\n        payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _amountOfTokens);\r\n\r\n        /* Members\r\n            A player can be initialized by buying or receiving and we want to add the user ASAP\r\n         */\r\n        if (\r\n            stats[_toAddress].invested == 0 &&\r\n            stats[_toAddress].receivedTokens == 0\r\n        ) {\r\n            players += 1;\r\n        }\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _amountOfTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onTransfer(_customerAddress, _toAddress, _amountOfTokens, now);\r\n\r\n        emit onLeaderBoard(\r\n            _customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        emit onLeaderBoard(\r\n            _toAddress,\r\n            stats[_toAddress].invested,\r\n            tokenBalanceLedger_[_toAddress],\r\n            stats[_toAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current collateral stored in the contract\r\n     */\r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return collateralToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Method to view the current collateral stored in the contract\r\n     */\r\n    function totalRewardTokenBalance() public view returns (uint256) {\r\n        return rewardToken.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function tokenBalance(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _customerAddress.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            (uint256)(\r\n                (int256)(\r\n                    profitPerShare_ * tokenBalanceLedger_[_customerAddress]\r\n                ) - payoutsTo_[_customerAddress]\r\n            ) / magnitude;\r\n    }\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.add(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethToSpend)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //Get the amount of the token in ETH and compare to the swapSize\r\n        address[] memory path = new address[](2);\r\n        path[0] = swap.WETH();\r\n        path[1] = collateralAddress;\r\n\r\n        uint256[] memory amounts = swap.getAmountsOut(_ethToSpend, path);\r\n\r\n        uint256 _dividends = SafeMath.div(\r\n            SafeMath.mul(amounts[1], entryFee_),\r\n            100\r\n        );\r\n        uint256 _taxedeth = SafeMath.sub(amounts[1], _dividends);\r\n        uint256 _amountOfTokens = _taxedeth;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateethReceived(uint256 _tokensToSell)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            _tokensToSell <= tokenSupply_,\r\n            \"Tokens to sell greater than supply\"\r\n        );\r\n        uint256 _eth = _tokensToSell;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n        return _taxedeth;\r\n    }\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256[14] memory)\r\n    {\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[14] memory statArray = [\r\n            s.invested,\r\n            s.withdrawn,\r\n            s.rewarded,\r\n            s.contributed,\r\n            s.transferredTokens,\r\n            s.receivedTokens,\r\n            s.xInvested,\r\n            s.xRewarded,\r\n            s.xContributed,\r\n            s.xWithdrawn,\r\n            s.xTransferredTokens,\r\n            s.xReceivedTokens,\r\n            s.reinvested,\r\n            s.xReinvested\r\n        ];\r\n        return statArray;\r\n    }\r\n\r\n    /// @dev Calculate daily estimate of collateral tokens awarded\r\n    function dailyEstimate(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 share = totalRewardTokenBalance().mul(payoutRate_).div(100);\r\n\r\n        \r\n        uint256 amount = (tokenSupply_ > 0)\r\n                ? share.mul(tokenBalanceLedger_[_customerAddress]).div(\r\n                    tokenSupply_\r\n                )\r\n                : 0;\r\n\r\n        if (amount > 0){\r\n            address[] memory path = new address[](3);\r\n            path[0] = rewardAddress;\r\n            path[1] = swap.WETH();\r\n            path[2] = collateralAddress;\r\n\r\n            \r\n            uint256[] memory amounts = swap.getAmountsOut(amount, path);\r\n            return amounts[2];\r\n        }\r\n        \r\n        return  0;      \r\n    }\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Distribute undividend in and out fees across drip pools and instant divs\r\n    function allocateFees(uint256 fee) private {\r\n        uint256 _share = fee.div(100);\r\n        uint256 _instant = _share.mul(instantFee);\r\n        uint256 _collateral = fee.safeSub(_instant);\r\n\r\n        //Apply divs\r\n        profitPerShare_ = SafeMath.add(\r\n            profitPerShare_,\r\n            (_instant * magnitude) / tokenSupply_\r\n        );\r\n\r\n        //Add to dividend drip pools\r\n        collateralBuffer_ += _collateral;\r\n    }\r\n\r\n    // @dev Distribute drip pools\r\n    function distribute() private {\r\n        if (now.safeSub(lastBalance_) > balanceInterval) {\r\n            emit onBalance(totalTokenBalance(), totalRewardTokenBalance(), now);\r\n            lastBalance_ = now;\r\n        }\r\n\r\n        if (now.safeSub(lastPayout) > payoutInterval && totalRewardTokenBalance() > 0) {\r\n            //Don't distribute if we don't have  sufficient profit\r\n            //A portion of the dividend is paid out according to the rate\r\n            uint256 share = totalRewardTokenBalance()\r\n                .mul(payoutRate_)\r\n                .div(100)\r\n                .div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            uint256 profit = share * now.safeSub(lastPayout);\r\n\r\n            //Get the amount of the token in ETH and compare to the swapSize\r\n            address[] memory path = new address[](2);\r\n            path[0] = rewardAddress;\r\n            path[1] = swap.WETH();\r\n\r\n            if (profit > 0){\r\n                uint256[] memory amounts = swap.getAmountsOut(profit, path);\r\n\r\n                if (amounts[1] > flushSize) {\r\n                    profit = rewardToCollateral(profit);\r\n\r\n                    totalClaims += profit;\r\n\r\n                    //Apply reward bonus as collateral bonus divs\r\n                    profitPerShare_ = SafeMath.add(\r\n                        profitPerShare_,\r\n                        (profit * magnitude) / tokenSupply_\r\n                    );\r\n\r\n                    lastPayout = now;\r\n                } else {\r\n                    fundRewardPool();\r\n                }\r\n            } else {\r\n                fundRewardPool();\r\n            }\r\n        } else {\r\n            fundRewardPool();\r\n        }\r\n    }\r\n\r\n    /// @dev Fund reward pool using the router; initial time and size logic gates and orchestration\r\n    function fundRewardPool() private {\r\n        //Only buy once\r\n        if (SafeMath.safeSub(now, lastFunding) >= fundingInterval) {\r\n            //Get the amount of the token in ETH and compare to the swapSize\r\n            address[] memory path = new address[](2);\r\n            path[0] = collateralAddress;\r\n            path[1] = swap.WETH();\r\n\r\n            if (collateralBuffer_ > 0){\r\n                uint256[] memory amounts = swap.getAmountsOut(\r\n                    collateralBuffer_,\r\n                    path\r\n                );\r\n\r\n                if (amounts[1] >= flushSize) {\r\n                    uint256 amount = collateralBuffer_;\r\n\r\n                    //reset Collector\r\n                    collateralBuffer_ = 0;\r\n\r\n                    //reward token buyback; tokens come to address(this) in the rewardsToken\r\n                    collateralToReward(amount);\r\n\r\n                    lastFunding = now;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //Execute the buyback against the router using WETH as a bridge\r\n    function collateralToReward(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](3);\r\n        path[0] = collateralAddress;\r\n        path[1] = swap.WETH();\r\n        path[2] = rewardAddress;\r\n\r\n        //Need to be able to approve the collateral token for transfer\r\n        require(\r\n            collateralToken.approve(swapAddress, amount),\r\n            \"Amount approved not available\"\r\n        );\r\n\r\n        uint256[] memory amounts = swap.swapExactTokensForTokens(\r\n            amount,\r\n            1,\r\n            path,\r\n            address(this),\r\n            now + 24 hours\r\n        );\r\n\r\n        //2nd index is token amount\r\n        emit onCollateraltoReward(amount, amounts[2], now);\r\n\r\n        return amounts[2];\r\n    }\r\n\r\n    function rewardToCollateral(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](3);\r\n        path[0] = rewardAddress;\r\n        path[1] = swap.WETH();\r\n        path[2] = collateralAddress;\r\n\r\n        //Need to be able to approve the collateral token for transfer\r\n        require(\r\n            rewardToken.approve(swapAddress, amount),\r\n            \"Amount approved not available\"\r\n        );\r\n\r\n        uint256[] memory amounts = swap.swapExactTokensForTokens(\r\n            amount,\r\n            1,\r\n            path,\r\n            address(this),\r\n            now + 24 hours\r\n        );\r\n\r\n        //2nd index is token amount\r\n        emit onRewardtoCollateral(amount, amounts[2], now);\r\n\r\n        return amounts[2];\r\n    }\r\n\r\n    /// @dev ETH to tokens\r\n    function ethToCollateral(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = swap.WETH();\r\n        path[1] = collateralAddress;\r\n\r\n        uint256[] memory amounts = swap.swapExactETHForTokens.value(amount)(\r\n            1,\r\n            path,\r\n            address(this),\r\n            now + 24 hours\r\n        );\r\n\r\n        //2nd index is token amount\r\n        emit onEthtoCollateral(amount, amounts[1], now);\r\n\r\n        return amounts[1];\r\n    }\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingtokens)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        /* Members */\r\n        if (\r\n            stats[_customerAddress].invested == 0 &&\r\n            stats[_customerAddress].receivedTokens == 0\r\n        ) {\r\n            players += 1;\r\n        }\r\n\r\n        totalTxs += 1;\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_incomingtokens, entryFee_) /\r\n            100;\r\n        uint256 _amountOfTokens = SafeMath.sub(\r\n            _incomingtokens,\r\n            _undividedDividends\r\n        );\r\n\r\n        // fire event\r\n        emit onTokenPurchase(\r\n            _customerAddress,\r\n            _incomingtokens,\r\n            _amountOfTokens,\r\n            now\r\n        );\r\n\r\n        // yes we know that the safemath function automatically rules out the \"greater then\" equation.\r\n        require(\r\n            _amountOfTokens > 0 &&\r\n                SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_,\r\n            \"Tokens need to be positive\"\r\n        );\r\n\r\n        // we can't give people infinite eth\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ += _amountOfTokens;\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _amountOfTokens\r\n        );\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256)(profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n        //drip and buybacks; instant requires being called after supply is updated\r\n        allocateFees(_undividedDividends);\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested += _incomingtokens;\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /*==========================================\r\n    =            ADMIN FUNCTIONS               =\r\n    ==========================================*/\r\n\r\n    /**\r\n     * @dev Update the router address to account for movement in liquidity long term\r\n     */\r\n    function updateSwapRouter(address _swapAddress) public onlyOwner() {\r\n        emit onRouterUpdate(swapAddress, _swapAddress);\r\n        swapAddress = _swapAddress;\r\n        swap = UniSwapV2LiteRouter(_swapAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the flushSize (how often buy backs happen in terms of amount of ETH accumulated)\r\n     */\r\n    function updateFlushSize(uint256 _flushSize) public onlyOwner() {\r\n        require(\r\n            _flushSize >= 0.01 ether && _flushSize <= 5 ether,\r\n            \"Flush size is out of range\"\r\n        );\r\n\r\n        emit onFlushUpdate(flushSize, _flushSize);\r\n        flushSize = _flushSize;\r\n    }\r\n\r\n    /**\r\n     * @dev Update Intervals\r\n     */\r\n    function updateIntervals(uint256 _payout, uint256 _fund)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        require(\r\n            _payout >= 2 seconds && _payout <= 24 hours,\r\n            \"Interval out of range\"\r\n        );\r\n        require(\r\n            _fund >= 2 seconds && _fund <= 24 hours,\r\n            \"Interval out of range\"\r\n        );\r\n\r\n        payoutInterval = _payout;\r\n        fundingInterval = _fund;\r\n\r\n        emit onUpdateIntervals(_payout, _fund);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /* @dev Subtracts two numbers, else returns zero */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b > a) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[14]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralBuffer_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRewardTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flushSize\",\"type\":\"uint256\"}],\"name\":\"updateFlushSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payout\",\"type\":\"uint256\"},{\"name\":\"_fund\",\"type\":\"uint256\"}],\"name\":\"updateIntervals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateethReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapAddress\",\"type\":\"address\"}],\"name\":\"updateSwapRouter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"flushSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"name\":\"_rewardAddress\",\"type\":\"address\"},{\"name\":\"_swapAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"uint256\"}],\"name\":\"onUpdateIntervals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onCollateraltoReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onEthtoCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onRewardtoCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"onRouterUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldFlushSize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFlushSize\",\"type\":\"uint256\"}],\"name\":\"onFlushUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "BankrollNetworkMoon", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006b785a0322126826d8226d77e173d75dafb84d11000000000000000000000000d46ba6d942050d489dbd938a2c909a5d5039a161000000000000000000000000f164fc0ec4e93095b804a4795bbe1e041497b92a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://482d734678c5be92bb1fe9f41696b55df17f49cfa7e27880516a14cf59a502cd"}