{"SourceCode": "{\"DraggableShares.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.8;\\n\\nimport \\\"./ERC20Recoverable.sol\\\";\\nimport \\\"./ERC20Draggable.sol\\\";\\n\\n/**\\n * @title Draggable CompanyName AG Shares\\n * @author Luzius Meisser, luzius@aktionariat.com\\n *\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027.\\n * The shareholder agreement is partially enforced through this smart contract. The agreement\\n * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\\n * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\\n * the acquirer to offer the same conditions to everyone when acquiring the company, and to\\n * facilitate an update of the shareholder agreement even if a minority of the shareholders that\\n * are bound to this agreement disagree. The name \\\"draggable\\\" stems from the convention of calling\\n * the right to drag a minority along with a sale of the company \\\"drag-along\\\" rights. The name is\\n * chosen to ensure that token holders are aware that they are bound to such an agreement.\\n *\\n * The percentage of token holders that must agree with an update of the terms is defined by the\\n * constant UPDATE_QUORUM. The percentage of yes-votes that is needed to successfully complete an\\n * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\\n * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\\n * number of votes cast during the voting period, not taking into account those who did not bother\\n * to vote.\\n */\\n\\ncontract DraggableShares is ERC20Recoverable, ERC20Draggable {\\n\\n    string public terms;\\n\\n    constructor(string memory _terms, address wrappedToken, uint256 quorumBps, uint256 votePeriodSeconds)\\n        ERC20Draggable(wrappedToken, quorumBps, votePeriodSeconds) {\\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\\n    }\\n\\n    function transfer(address to, uint256 value) override(ERC20Recoverable, ERC20) public returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    function getClaimDeleter() public view override returns (address) {\\n        return IRecoverable(address(wrapped)).getClaimDeleter();\\n    }\\n\\n    function getCollateralRate(address collateralType) public view override returns (uint256) {\\n        uint256 rate = super.getCollateralRate(collateralType);\\n        if (rate \\u003e 0) {\\n            return rate;\\n        } else if (collateralType == address(wrapped)) {\\n            return unwrapConversionFactor;\\n        } else {\\n            // If the wrapped contract allows for a specific collateral, we should too.\\n            // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\\n            return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * unwrapConversionFactor;\\n        }\\n    }\\n\\n}\\n\\nabstract contract IRecoverable {\\n    function getCollateralRate(address) public virtual view returns (uint256);\\n    function getClaimDeleter() public virtual view returns (address);\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied and adjusted from OpenZeppelin\\n// Adjustments:\\n// - modifications to support ERC-677\\n// - removed require messages to save space\\n// - removed unnecessary require statements\\n// - removed GSN Context\\n// - upgraded to 0.8 to drop SafeMath\\n// - let name() and symbol() be implemented by subclass\\n// - infinite allowance support, with 2^255 and above considered infinite\\n\\npragma solidity \\u003e=0.8;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC677Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    uint8 public override decimals;\\n\\n    constructor(uint8 _decimals) {\\n        decimals = _decimals;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\n        if (currentAllowance \\u003c (1 \\u003c\\u003c 255)){\\n            // Only decrease the allowance if it was not set to \\u0027infinite\\u0027\\n            // Documented in /doc/infiniteallowance.md\\n            _approve(sender, msg.sender, currentAllowance - amount);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(recipient != address(0));\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\\n    function transferAndCall(address recipient, uint amount, bytes calldata data) public returns (bool) {\\n        bool success = transfer(recipient, amount);\\n        if (success){\\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\\n        }\\n        return success;\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address recipient, uint256 amount) internal virtual {\\n        require(recipient != address(0));\\n\\n        _beforeTokenTransfer(address(0), recipient, amount);\\n\\n        _totalSupply += amount;\\n        _balances[recipient] += amount;\\n        emit Transfer(address(0), recipient, amount);\\n    }\\n\\n     /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _totalSupply -= amount;\\n        _balances[account] -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal;\\n}\"},\"ERC20Draggable.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.8;\\n\\n/**\\n * @title CompanyName Shareholder Agreement\\n * @author Luzius Meisser, luzius@aktionariat.com\\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\\n *\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027\\n * of the \\u0027DraggableCompanyNameShares\\u0027 contract. The agreement is partially enforced\\n * through the Swiss legal system, and partially enforced through this smart contract.\\n * In particular, this smart contract implements a drag-along clause which allows the\\n * majority of token holders to force the minority sell their shares along with them in\\n * case of an acquisition. That\\u0027s why the tokens are called \\\"Draggable CompanyName AG Shares.\\\"\\n */\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC677Receiver.sol\\\";\\n\\ncontract ERC20Draggable is ERC20, IERC677Receiver {\\n\\n    IERC20 public wrapped;                              // The wrapped contract\\n    IOfferFactory public constant factory = IOfferFactory(0xf9f92751F272f0872e2EDb6a280b0990F3e2b8A3);\\n\\n    uint256 private constant MIGRATION_QUORUM = 8000;\\n\\n    // If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\\n    uint256 public unwrapConversionFactor = 0;\\n\\n    // The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\\n    IOffer public offer;\\n\\n    uint256 public quorum; // BPS (out of 10\\u0027000)\\n    uint256 public votePeriod; // Seconds\\n\\n    event MigrationSucceeded(address newContractAddress);\\n\\n    constructor(\\n        address wrappedToken,\\n        uint256 quorum_,\\n        uint256 votePeriod_\\n    ) ERC20(0) {\\n        wrapped = IERC20(wrappedToken);\\n        quorum = quorum_;\\n        votePeriod = votePeriod_;\\n    }\\n\\n    function disableRecovery() public {\\n        IRecoveryDisabler(address(wrapped)).setRecoverable(false);\\n    }\\n\\n    function name() public override view returns (string memory){\\n        if (isBinding()){\\n            return string(abi.encodePacked(\\\"Draggable \\\", wrapped.name()));\\n        } else {\\n            return string(abi.encodePacked(\\\"Wrapped \\\", wrapped.name()));\\n        }\\n    }\\n\\n    function symbol() public override view returns (string memory){\\n        if (isBinding()){\\n            return string(abi.encodePacked(\\\"D\\\", wrapped.symbol()));\\n        } else {\\n            return string(abi.encodePacked(\\\"W\\\", wrapped.symbol()));\\n        }\\n    }\\n\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) override public returns (bool) {\\n        require(msg.sender == address(wrapped));\\n        _mint(from, amount);\\n        return true;\\n    }\\n\\n    /** Increases the number of drag-along tokens. Requires minter to deposit an equal amount of share tokens */\\n    function wrap(address shareholder, uint256 amount) public {\\n        require(wrapped.transferFrom(msg.sender, address(this), amount));\\n        _mint(shareholder, amount);\\n    }\\n\\n    /**\\n     * Indicates that the token holders are bound to the token terms and that:\\n     * - Conversions back to the wrapped token (unwrap) are not allowed\\n     * - The drag-along can be performed by making an according offer\\n     * - They can be migrated to a new version of this contract in accordance with the terms\\n     */\\n    function isBinding() public view returns (bool) {\\n        return unwrapConversionFactor == 0;\\n    }\\n\\n    /**\\n     * Deactivates the drag-along mechanism and enables the unwrap function.\\n     */\\n    function deactivate(uint256 factor) internal {\\n        require(factor \\u003e= 1, \\\"factor\\\");\\n        unwrapConversionFactor = factor;\\n    }\\n\\n    /** Decrease the number of drag-along tokens. The user gets back their shares in return */\\n    function unwrap(uint256 amount) public {\\n        require(!isBinding());\\n        unwrap(msg.sender, amount, unwrapConversionFactor);\\n    }\\n    \\n    function unwrap(address owner, uint256 amount, uint256 factor) internal {\\n        _burn(owner, amount);\\n        require(wrapped.transfer(owner, amount * factor));\\n    }\\n\\n    /**\\n     * Burns both the token itself as well as the wrapped token!\\n     * If you want to get out of the shareholder agreement, use unwrap after it has been\\n     * deactivated by a majority vote or acquisition.\\n     *\\n     * Burning only works if wrapped token supports burning. Also, the exact meaning of this\\n     * operation might depend on the circumstances. Burning and reussing the wrapped token\\n     * does not free the sender from the legal obligations of the shareholder agreement.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(msg.sender, amount);\\n        uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\\n        IBurnable(address(wrapped)).burn(amount * factor);\\n    }\\n\\n    function makeAcquisitionOffer(bytes32 salt, uint256 pricePerShare, address currency) public payable {\\n        require(isBinding());\\n        address newOffer = factory.create{value: msg.value}(salt, msg.sender, pricePerShare, currency, quorum, votePeriod);\\n        if (offerExists()) {\\n            require(IOffer(newOffer).isWellFunded());\\n            offer.contest(newOffer);\\n        }\\n        offer = IOffer(newOffer);\\n    }\\n\\n    function drag(address buyer, address currency) public {\\n        require(msg.sender == address(offer));\\n        unwrap(buyer, balanceOf(buyer), 1);\\n        replaceWrapped(currency, buyer);\\n    }\\n\\n    function notifyOfferEnded() public {\\n        if (msg.sender == address(offer)){\\n            offer = IOffer(address(0));\\n        }\\n    }\\n\\n    function replaceWrapped(address newWrapped, address oldWrappedDestination) internal {\\n        require(isBinding());\\n        // Free all old wrapped tokens we have\\n        require(wrapped.transfer(oldWrappedDestination, wrapped.balanceOf(address(this))));\\n        // Count the new wrapped tokens\\n        wrapped = IERC20(newWrapped);\\n        deactivate(wrapped.balanceOf(address(this)) / totalSupply());\\n    }\\n\\n    function migrate() public {\\n        address successor = msg.sender;\\n        require(!offerExists()); // if you have 80%, you can easily cancel the offer first if necessary\\n        require(balanceOf(successor) * 10000 \\u003e= totalSupply() * MIGRATION_QUORUM, \\\"quorum\\\");\\n        replaceWrapped(successor, successor);\\n        emit MigrationSucceeded(successor);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\\n        if (offerExists()) {\\n            offer.notifyMoved(from, to, amount);\\n        }\\n    }\\n\\n    function offerExists() internal view returns (bool) {\\n        return address(offer) != address(0);\\n    }\\n\\n}\\n\\nabstract contract IRecoveryDisabler {\\n    function setRecoverable(bool enabled) public virtual;\\n}\\n\\nabstract contract IBurnable {\\n    function burn(uint256) virtual public;\\n}\\n\\nabstract contract IOffer {\\n    function isWellFunded() virtual public returns (bool);\\n    function contest(address newOffer) virtual public;\\n    function notifyMoved(address from, address to, uint256 value) virtual public;\\n}\\n\\nabstract contract IOfferFactory {\\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) virtual public payable returns (address);\\n}\"},\"ERC20Recoverable.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.8;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title Recoverable\\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\\n * as it can be claimed at anytime by the rightful owner.\\n * Furthermore, if \\\"getClaimDeleter\\\" is defined in the subclass, the returned address is allowed to\\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\\n * function.\\n */\\n\\nabstract contract ERC20Recoverable is ERC20 {\\n\\n    // A struct that represents a claim made\\n    struct Claim {\\n        address claimant; // the person who created the claim\\n        uint256 collateral; // the amount of collateral deposited\\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\\n        address currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\\n    }\\n\\n    uint256 public constant claimPeriod = 180 days;\\n\\n    mapping(address =\\u003e Claim) public claims; // there can be at most one claim per address, here address is claimed address\\n    mapping(address =\\u003e bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\\n\\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\\n    address public customCollateralAddress;\\n    uint256 public customCollateralRate;\\n\\n    /**\\n     * Returns the collateral rate for the given collateral type and 0 if that type\\n     * of collateral is not accepted. By default, only the token itself is accepted at\\n     * a rate of 1:1.\\n     *\\n     * Subclasses should override this method if they want to add additional types of\\n     * collateral.\\n     */\\n    function getCollateralRate(address collateralType) public virtual view returns (uint256) {\\n        if (collateralType == address(this)) {\\n            return 1;\\n        } else if (collateralType == customCollateralAddress) {\\n            return customCollateralRate;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * Allows subclasses to set a custom collateral besides the token itself.\\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\\n     * throws an exception or returns false on failure.\\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\\n     */\\n    function _setCustomClaimCollateral(address collateral, uint256 rate) internal {\\n        customCollateralAddress = collateral;\\n        if (customCollateralAddress == address(0)) {\\n            customCollateralRate = 0; // disabled\\n        } else {\\n            require(rate \\u003e 0, \\\"zero\\\");\\n            customCollateralRate = rate;\\n        }\\n        emit CustomClaimCollateralChanged(collateral, rate);\\n    }\\n\\n    function getClaimDeleter() virtual public view returns (address);\\n\\n    function setRecoverable(bool enabled) public {\\n        recoveryDisabled[msg.sender] = !enabled;\\n    }\\n\\n    /**\\n     * Some users might want to disable claims for their address completely.\\n     * For example if they use a deep cold storage solution or paper wallet.\\n     */\\n    function isRecoveryEnabled(address target) public view returns (bool) {\\n        return !recoveryDisabled[target];\\n    }\\n\\n    event ClaimMade(address indexed lostAddress, address indexed claimant, uint256 balance);\\n    event ClaimCleared(address indexed lostAddress, uint256 collateral);\\n    event ClaimDeleted(address indexed lostAddress, address indexed claimant, uint256 collateral);\\n    event ClaimResolved(address indexed lostAddress, address indexed claimant, uint256 collateral);\\n    event CustomClaimCollateralChanged(address newCustomCollateralAddress, uint256 newCustomCollareralRate);\\n\\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\\n    * 2) The \\\"lost\\\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\\n    *    whenever someone transfers funds to let claims be resolved automatically when the \\\"lost\\\" private key is\\n    *    used again.\\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\\n    *    rightful owner of the deposit.\\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\\n    * through a shareholder register).\\n    */\\n    function declareLost(address collateralType, address lostAddress) public {\\n        require(isRecoveryEnabled(lostAddress), \\\"disabled\\\");\\n        uint256 collateralRate = getCollateralRate(collateralType);\\n        require(collateralRate \\u003e 0, \\\"bad collateral\\\");\\n        address claimant = msg.sender;\\n        uint256 balance = balanceOf(lostAddress);\\n        uint256 collateral = balance * collateralRate;\\n        IERC20 currency = IERC20(collateralType);\\n        require(balance \\u003e 0, \\\"empty\\\");\\n        require(claims[lostAddress].collateral == 0, \\\"already claimed\\\");\\n        require(currency.transferFrom(claimant, address(this), collateral));\\n\\n        claims[lostAddress] = Claim({\\n            claimant: claimant,\\n            collateral: collateral,\\n            timestamp: block.timestamp,\\n            currencyUsed: collateralType\\n        });\\n\\n        emit ClaimMade(lostAddress, claimant, balance);\\n    }\\n\\n    function getClaimant(address lostAddress) public view returns (address) {\\n        return claims[lostAddress].claimant;\\n    }\\n\\n    function getCollateral(address lostAddress) public view returns (uint256) {\\n        return claims[lostAddress].collateral;\\n    }\\n\\n    function getCollateralType(address lostAddress) public view returns (address) {\\n        return claims[lostAddress].currencyUsed;\\n    }\\n\\n    function getTimeStamp(address lostAddress) public view returns (uint256) {\\n        return claims[lostAddress].timestamp;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) override virtual public returns (bool) {\\n        require(super.transfer(recipient, amount));\\n        clearClaim();\\n        return true;\\n    }\\n\\n    /**\\n     * Clears a claim after the key has been found again and assigns the collateral to the \\\"lost\\\" address.\\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\\n     */\\n    function clearClaim() public {\\n        if (claims[msg.sender].collateral != 0) {\\n            uint256 collateral = claims[msg.sender].collateral;\\n            IERC20 currency = IERC20(claims[msg.sender].currencyUsed);\\n            delete claims[msg.sender];\\n            require(currency.transfer(msg.sender, collateral));\\n            emit ClaimCleared(msg.sender, collateral);\\n        }\\n    }\\n\\n   /**\\n    * After the claim period has passed, the claimant can call this function to send the\\n    * tokens on the lost address as well as the collateral to himself.\\n    */\\n    function recover(address lostAddress) public {\\n        Claim memory claim = claims[lostAddress];\\n        uint256 collateral = claim.collateral;\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        require(collateral != 0, \\\"not found\\\");\\n        require(claim.claimant == msg.sender, \\\"not claimant\\\");\\n        require(claim.timestamp + claimPeriod \\u003c= block.timestamp, \\\"too early\\\");\\n        address claimant = claim.claimant;\\n        delete claims[lostAddress];\\n        require(currency.transfer(claimant, collateral));\\n        _transfer(lostAddress, claimant, balanceOf(lostAddress));\\n        emit ClaimResolved(lostAddress, claimant, collateral);\\n    }\\n\\n    /**\\n     * This function is to be executed by the claim deleter only in case a dispute needs to be resolved manually.\\n     */\\n    function deleteClaim(address lostAddress) public {\\n        require(msg.sender == getClaimDeleter(), \\\"no access\\\");\\n        Claim memory claim = claims[lostAddress];\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        require(claim.collateral != 0, \\\"not found\\\");\\n        delete claims[lostAddress];\\n        require(currency.transfer(claim.claimant, claim.collateral));\\n        emit ClaimDeleted(lostAddress, claim.claimant, claim.collateral);\\n    }\\n\\n}\"},\"IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity \\u003e=0.8;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.8;\\n\\ninterface IERC677Receiver {\\n    \\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_terms\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votePeriodSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCustomCollateralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomCollareralRate\",\"type\":\"uint256\"}],\"name\":\"CustomClaimCollateralChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"MigrationSucceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyUsed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"declareLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"deleteClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"drag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IOfferFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimDeleter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getClaimant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateralType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBinding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isRecoveryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"makeAcquisitionOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyOfferEnded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"contract IOffer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setRecoverable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unwrapConversionFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapped\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DraggableShares", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000026ee6205797827d2e88fc6fb83d2608a069d0a830000000000000000000000000000000000000000000000000000000000001d4c00000000000000000000000000000000000000000000000000000000004f1a00000000000000000000000000000000000000000000000000000000000000001a677265656e636f6e73656e7375732e63682f696e766573746f72000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fbfc55c14d93a81fe424fb6ff1b39f2ab3e544d5924da8c9430beef205843029"}