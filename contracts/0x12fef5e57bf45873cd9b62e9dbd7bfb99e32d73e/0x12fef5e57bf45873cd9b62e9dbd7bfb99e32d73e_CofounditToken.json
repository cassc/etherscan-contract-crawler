{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\ncontract owned {\r\n\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract tokenRecipient { \r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \r\n} \r\n\r\ncontract IERC20Token {     \r\n\r\n\t/// @return total amount of tokens     \r\n\tfunction totalSupply() constant returns (uint256 totalSupply);     \r\n\r\n\t/// @param _owner The address from which the balance will be retrieved     \r\n\t/// @return The balance     \r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {}     \r\n\r\n\t/// @notice send `_value` token to `_to` from `msg.sender`     \r\n\t/// @param _to The address of the recipient     \r\n\t/// @param _value The amount of token to be transferred     \r\n\t/// @return Whether the transfer was successful or not     \r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {}     \r\n\r\n\t/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`     \r\n\t/// @param _from The address of the sender     \r\n\t/// @param _to The address of the recipient     \r\n\t/// @param _value The amount of token to be transferred     \r\n\t/// @return Whether the transfer was successful or not     \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}     \r\n\r\n\t/// @notice `msg.sender` approves `_addr` to spend `_value` tokens     \r\n\t/// @param _spender The address of the account able to transfer the tokens     \r\n\t/// @param _value The amount of wei to be approved for transfer     \r\n\t/// @return Whether the approval was successful or not     \r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {}     \r\n\r\n\t/// @param _owner The address of the account owning tokens     \r\n\t/// @param _spender The address of the account able to transfer the tokens     \r\n\t/// @return Amount of remaining tokens allowed to spent     \r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}       \r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);     \r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value); \r\n} \r\n\r\ncontract CofounditToken is IERC20Token, owned{         \r\n\r\n\t/* Public variables of the token */     \r\n\tstring public standard = \"Cofoundit token v1.0\";     \r\n\tstring public name = \"Cofoundit\";     \r\n\tstring public symbol = \"CFI\";     \r\n\tuint8 public decimals = 18;     \r\n\taddress public icoContractAddress;     \r\n\tuint256 public tokenFrozenUntilBlock;     \r\n\r\n\t/* Private variables of the token */     \r\n\tuint256 supply = 0;     \r\n\tmapping (address => uint256) balances;     \r\n\tmapping (address => mapping (address => uint256)) allowances;     \r\n\tmapping (address => bool) restrictedAddresses;     \r\n\r\n\t/* Events */       \r\n\tevent Mint(address indexed _to, uint256 _value);     \r\n\tevent TokenFrozen(uint256 _frozenUntilBlock, string _reason);     \r\n\r\n\t/* Initializes contract and  sets restricted addresses */     \r\n\tfunction CofounditToken(address _icoAddress) {         \r\n\t\trestrictedAddresses[0x0] = true;\t\t\t// Users cannot send tokens to 0x0 address         \r\n\t\trestrictedAddresses[_icoAddress] = true;\t// Users cannot send tokens to ico contract         \r\n\t\trestrictedAddresses[address(this)] = true;\t// Users cannot sent tokens to this contracts address                 \r\n\t\ticoContractAddress = _icoAddress;\t\t\t// Sets ico contract address from where mints will happen     \r\n\t}         \r\n\r\n\t/* Get total supply of issued coins */     \r\n\tfunction totalSupply() constant returns (uint256 totalSupply) {         \r\n\t\treturn supply;     \r\n\t}         \r\n\r\n\t/* Get balance of specific address */     \r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {         \r\n\t\treturn balances[_owner];     \r\n\t}     \r\n\r\n\t/* Send coins */     \r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t// Throw is token is frozen in case of emergency         \r\n\t\tif (restrictedAddresses[_to]) throw;                // Prevent transfer to restricted addresses         \r\n\t\tif (balances[msg.sender] < _value) throw;           // Check if the sender has enough         \r\n\t\tif (balances[_to] + _value < balances[_to]) throw;  // Check for overflows         \r\n\t\tbalances[msg.sender] -= _value;                     // Subtract from the sender         \r\n\t\tbalances[_to] += _value;                            // Add the same to the recipient         \r\n\t\tTransfer(msg.sender, _to, _value);                  // Notify anyone listening that this transfer took place         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t/* Allow another contract to spend some tokens in your behalf */     \r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t// Throw is token is frozen in case of emergency         \r\n\t\tallowances[msg.sender][_spender] = _value;          // Set allowance         \r\n\t\tApproval(msg.sender, _spender, _value);             // Raise Approval event         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t/* Approve and then comunicate the approved contract in a single tx */     \r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {            \r\n\t\ttokenRecipient spender = tokenRecipient(_spender);              // Cast spender to tokenRecipient contract         \r\n\t\tapprove(_spender, _value);                                      // Set approval to contract for _value         \r\n\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t/* A contract attempts to get the coins */     \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t// Throw is token is frozen in case of emergency         \r\n\t\tif (restrictedAddresses[_to]) throw;                // Prevent transfer to restricted addresses         \r\n\t\tif (balances[_from] < _value) throw;                // Check if the sender has enough         \r\n\t\tif (balances[_to] + _value < balances[_to]) throw;  // Check for overflows         \r\n\t\tif (_value > allowances[_from][msg.sender]) throw;  // Check allowance         \r\n\t\tbalances[_from] -= _value;                          // Subtract from the sender         \r\n\t\tbalances[_to] += _value;                            // Add the same to the recipient         \r\n\t\tallowances[_from][msg.sender] -= _value;            // Deduct allowance for this address         \r\n\t\tTransfer(_from, _to, _value);                       // Notify anyone listening that this transfer took place         \r\n\t\treturn true;     \r\n\t}         \r\n\r\n\t/* Get the ammount of remaining tokens to spend */     \r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {         \r\n\t\treturn allowances[_owner][_spender];     \r\n\t}         \r\n\r\n\t/* Create new tokens*/     \r\n\tfunction mintTokens(address _to, uint256 _amount, string _reason) {         \r\n\t\tif (msg.sender != icoContractAddress) throw;\t\t\t// Check if minter is ico Contract address         \r\n\t\tif (restrictedAddresses[_to]) throw;                    // Prevent transfer to restricted addresses         \r\n\t\tif (_amount == 0 || sha3(_reason) == sha3(\"\")) throw;   // Check if values are not null;         \r\n\t\tif (balances[_to] + _amount < balances[_to]) throw;     // Check for overflows         \r\n\t\tsupply += _amount;                                      // Update total supply         \r\n\t\tbalances[_to] += _amount;                    \t\t    // Set minted coins to target         \r\n\t\tMint(_to, _amount);                          \t\t    // Create Mint event         \r\n\t\tTransfer(0x0, _to, _amount);                            // Create Transfer event from 0x     \r\n\t}     \r\n\r\n\t/* Stops all token transfers in case of emergency */     \r\n\tfunction freezeTransfersUntil(uint256 _frozenUntilBlock, string _reason) onlyOwner {     \t\r\n\t\ttokenFrozenUntilBlock = _frozenUntilBlock;     \t\r\n\t\tTokenFrozen(_frozenUntilBlock, _reason);     \r\n\t}     \r\n\t\r\n\t/* Owner can add new restricted address or removes one */\r\n\tfunction editRestrictedAddress(address _newRestrictedAddress) onlyOwner {\r\n\t\trestrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];\r\n\t}\r\n\r\n\tfunction isRestrictedAddress(address _querryAddress) constant returns (bool answer){\r\n\t\treturn restrictedAddresses[_querryAddress];\r\n\t}\r\n\r\n\t/* This unnamed function is called whenever someone tries to send ether to it */     \r\n\r\n\tfunction () {         \r\n\t\tthrow;     // Prevents accidental sending of ether     \r\n\t} \r\n\r\n\t//\r\n\t/* This part is here only for testing and will not be included into final version */\r\n\t//\r\n\r\n\t//function changeICOAddress(address _newAddress) onlyOwner{\r\n\t//\ticoContractAddress = _newAddress;\r\n\t//}\r\n\r\n\t//function killContract() onlyOwner{\r\n\t//\tselfdestruct(msg.sender);\r\n\t//}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"isRestrictedAddress\",\"outputs\":[{\"name\":\"answer\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRestrictedAddress\",\"type\":\"address\"}],\"name\":\"editRestrictedAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozenUntilBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_frozenUntilBlock\",\"type\":\"uint256\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"freezeTransfersUntil\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_icoAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_frozenUntilBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"TokenFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "CofounditToken", "CompilerVersion": "v0.4.11+commit.68ef5810", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055ae5792903b179915e10065e26610435832a3f7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://7b8828bd901d750e8fea582c32421353d39be9eb7ffb4dcba86aa9ef5260afb0"}