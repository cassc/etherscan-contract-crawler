{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n// \u0417\u0430\u0449\u0438\u0442\u0430 \u043e\u0442 \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u044b\u0445 \u0432\u044b\u0437\u043e\u0432\u043e\u0432)\r\n// \u0417\u0430\u0449\u0438\u0442\u0430 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432)\r\n// \u0421\u043c\u0430\u0440\u0442-\u041a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0421\u0423\u0421 - (\u0423) - \u0421\u0438\u0441\u0442\u0435\u043c\u0430 \u0423\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0421\u0440\u0435\u0434\u0441\u0442\u0432)\r\n// \u041f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d - \u0431\u0435\u0437 \u043a\u0430\u043a\u0438\u0445-\u043b\u0438\u0431\u043e \u0432\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0439 \u0441\u043e \u0441\u0442\u043e\u0440\u043e\u043d\u044b - \u0434\u0430\u0436\u0435 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430)\r\n// \u0412\u044b \u0434\u0435\u043b\u0430\u0435\u0442\u0435 \u043e\u043f\u043b\u0430\u0442\u0443 \u043d\u0430 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442 \u0438 \u0447\u0435\u0440\u0435\u0437 \u043a\u0430\u043a\u043e\u0435-\u0442\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u0430\u043c \u0447\u0430\u0441\u0442\u044f\u043c\u0438 \u043f\u043e\u0441\u044b\u043b\u0430\u0435\u0442\u0441\u044f 150% \u0432\u0430\u0448\u0435\u0439 \u043e\u043f\u043b\u0430\u0442\u044b \u0432\u043c\u0435\u0441\u0442\u0435 \u0441 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0435\u0439)\r\n// \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0446\u0435\u043f\u043e\u0447\u043a\u0430 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 - \u0432\u0441\u0435\u043c \u043f\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u0432\u044b\u043f\u043b\u0430\u0447\u0438\u0432\u0430\u044e\u0442\u0441\u044f 150% \u043e\u0442 \u0441\u0443\u043c\u043c\u044b \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u043b\u0430\u0442\u0435\u0436\u0430)\r\n// \u041a\u0430\u0436\u0434\u044b\u0439 \u0432\u043e\u0448\u0435\u0434\u0448\u0438\u0439 \u0447\u0435\u0440\u0435\u0437 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0437\u0430\u0446\u0438\u044e \u043f\u043b\u0430\u0442\u0438\u0442 \u0442\u0435\u043c - \u043a\u0442\u043e \u0432\u043d\u0430\u0447\u0430\u043b\u0435 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 - \u0438 \u0434\u043e \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0438\u0437 \u0432\u0430\u0441 \u0440\u0430\u043d\u043e \u0438\u043b\u0438 \u043f\u043e\u0437\u0434\u043d\u043e \u0434\u043e\u0439\u0434\u0451\u0442 \u043e\u0447\u0435\u0440\u0435\u0434\u044c \u0432\u044b\u043f\u043b\u0430\u0442\u044b \u0432\u0430\u043c 150%)\r\n// \u0415\u0441\u0442\u044c \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f - 3% \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0443 - 1% \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430 \u0434\u043b\u044f \u0431\u043e\u043d\u0443\u0441\u043e\u0432 - 5% \u043f\u043e 1% \u043d\u0430 5 \u0443\u0440\u043e\u0432\u043d\u0435\u0439 \u043d\u0438\u0436\u0435)\r\n// \u0421\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u0438 \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441\u0435 \u0432 \u0438\u0442\u043e\u0433\u0435 \u0431\u0443\u0434\u0443\u0442 \u043d\u0430\u0431\u0438\u0440\u0430\u0442\u044c\u0441\u044f \u0438\u0437\u043b\u0438\u0448\u043d\u0438\u0435 \u0441\u0443\u043c\u043c\u044b - \u0438 \u043e\u043d\u0438 \u0431\u0443\u0434\u0443\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c\u0441\u044f \u043a \u043f\u0435\u0440\u0432\u044b\u043c 2-\u043c \u0443\u0440\u043e\u0432\u043d\u044f\u043c \u0432 \u0432\u0438\u0434\u0435 \u0431\u043e\u043d\u0443\u0441\u0430 +0.5 \u044d\u0444\u0438\u0440\u0430)\r\ncontract SUS is ReentrancyGuard {\r\n\r\n    address public owner;   //\u0432\u043b\u0430\u0434\u0435\u043b\u0435\u0446)\r\n    using Address for address payable;  // \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u044b\u0435 \u0432\u044b\u043f\u043b\u0430\u0442\u044b)\r\n    // \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u0440\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0438 \u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432)\r\n    event UtilizeReceived(address indexed sender, uint256 value, uint256 indexed level, uint256 queueIndex);\r\n    event UtilizePayOut(address indexed sender, uint256 value, uint256 indexed level, uint256 queueIndex);\r\n    // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043b\u0443\u0447\u0430 \u0438\u0437 \u0430\u0434\u0440\u0435\u0441\u0430 \u0438 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432)\r\n    struct Ray {\r\n        address addr;\r\n        uint256 utilize;\r\n    }\r\n    // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u043e\u0432 \u043b\u0443\u0447\u0430)\r\n    struct Range {\r\n        // \u043f\u0435\u0440\u0432\u044b\u0439 \u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 \u0434\u043b\u044f \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u043e\u0447\u0435\u0440\u0435\u0434\u0438)\r\n        uint256 firstIndex;\r\n        uint256 lastIndex;        \r\n        uint256 leftFunds;  // \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0435\u0441\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u043e 150%        \r\n        uint256 currentFunds;   // \u0442\u0435\u043a\u0443\u0449\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\r\n    }\r\n\r\n    mapping(uint256 => Range) public range; // \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d - \u043c\u0430\u0441\u0441\u0438\u0432 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u0434\u0430\u043d\u043d\u044b\u0445)\r\n    // \u043b\u0443\u0447 - \u043c\u0430\u0441\u0441\u0438\u0432 \u0443\u0440\u043e\u0432\u043d\u0435\u0439 \u0438 \u0432 \u043d\u0451\u043c \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u044d\u0442\u043e\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\u043c)\r\n    mapping(uint256 => mapping(uint256 => Ray)) public ray;\r\n    \r\n    uint256 public sumFunds; // \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432)\r\n\r\n    // \u041a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b)\r\n    uint256 private constant MAX_ITERATIONS = 24;    \r\n    uint256 private constant GAS_PER_ITERATION = 178000;\r\n    uint256 private constant GAS_MIN_UTILIZE = 387100;\r\n    uint256 private constant GAS_POSSIBLE_FEE = 141780;\r\n    uint256 private constant BONUS = 500000000 gwei;\r\n\r\n    // \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 - \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e 1 \u0440\u0430\u0437 \u043f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430)\r\n    constructor() {\r\n        // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430 \u043a\u0430\u043a \u0441\u043e\u0437\u0434\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u0430)\r\n        owner = msg.sender;\r\n        // \u0441\u0440\u0430\u0437\u0443 \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043f\u0435\u0440\u0432\u044b\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b \u0438 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430 \u0432 \u043d\u0430\u0447\u0430\u043b\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u0438)\r\n        ray[0][0] = Ray(msg.sender, 8710000 gwei);\r\n        ray[1][0] = Ray(msg.sender, 18781000 gwei);\r\n        ray[2][0] = Ray(msg.sender, 87178000 gwei);\r\n        ray[3][0] = Ray(msg.sender, 871780000 gwei);\r\n        ray[4][0] = Ray(msg.sender, 8717800000 gwei);\r\n        ray[5][0] = Ray(msg.sender, 87178000000 gwei);\r\n        ray[6][0] = Ray(msg.sender, 871780000000 gwei);\r\n        ray[7][0] = Ray(msg.sender, 8717800000000 gwei);\r\n        ray[8][0] = Ray(msg.sender, 87178000000000 gwei);\r\n        ray[9][0] = Ray(msg.sender, 871780000000000 gwei);        \r\n        // \u0432\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u044b (\u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u0435\u0441\u043b\u0438 \u0438\u0437\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u0442\u043e\u043b\u044c\u043a\u043e 1 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a)\r\n        // range[0].lastIndex = 1;        \r\n    }\r\n\r\n    // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0442\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u0439)\r\n    receive() external payable nonReentrant {\r\n\r\n        // \u0435\u0441\u043b\u0438 \u043c\u0435\u043d\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 0.000871 ether - \u0442\u043e\u0433\u0434\u0430 \u043f\u0440\u043e\u0441\u0442\u043e \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441\u0435)\r\n        if (msg.value > 871000 gwei) {\r\n\r\n            uint256 level;  // \u0443\u0440\u043e\u0432\u043d\u0438)\r\n            uint256 gasPrice = tx.gasprice;     // \u0446\u0435\u043d\u0430 \u0433\u0430\u0437\u0430)\r\n            // \u0441\u0440\u0430\u0437\u0443 \u0436\u0435 \u043a \u0443\u0442\u0438\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u0443\u044e \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044e \u043f\u043e \u0433\u0430\u0437\u0443)\r\n            // \u044d\u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0442\u043e\u0433\u043e - \u0447\u0442\u043e\u0431\u044b \u0441\u0440\u0430\u0437\u0443 \u0441\u043c\u0435\u043d\u0438\u0442\u044c \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043d\u0430 +1 - \u0435\u0441\u043b\u0438 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u044f + \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f \u0432\u044b\u0445\u043e\u0434\u0438\u0442 \u0437\u0430 \u0440\u0430\u043c\u043a\u0438 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u044f)\r\n            uint256 value = msg.value + GAS_PER_ITERATION * gasPrice;   // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0443\u0442\u0438\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043f\u043b\u044e\u0441 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f)\r\n\r\n            // \u0440\u0430\u0441\u043f\u0435\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u0440\u043e\u0432\u043d\u044f\u043c \u043e\u0442 0.000871 ether \u0438 \u043a\u0440\u0430\u0442\u043d\u043e\u0435 10)\r\n            if (value <= 8710000 gwei) { // (0) > 0.000871 <= 0.00871 ether (4-0)\r\n                level = 0;\r\n            } else if (value <= 87100000 gwei) {    // (1) > 0.00871 <= 0.0871 ether (5-0)\r\n                level = 1;\r\n            } else if (value <= 871000000 gwei) {   // (2) > 0.0871 <= 0.871 ether (6-0)\r\n                level = 2;\r\n            } else if (value <= 8710000000 gwei) {  // (3) > 0.871 <= 8.71 ether (7-0)\r\n                level = 3;\r\n            } else if (value <= 87100000000 gwei) { // (4) > 8.71 <= 87.1 ether (8-0)\r\n                level = 4;\r\n            } else if (value <= 871000000000 gwei) {    // (5) > 87.1 <= 871 ether (9-0)\r\n                level = 5;\r\n            } else if (value <= 8710000000000 gwei) {   // (6) > 871 <= 8710 ether (10-0)\r\n                level = 6;\r\n            } else if (value <= 87100000000000 gwei) {  // (7) > 8710 <= 87100 ether (11-0)\r\n                level = 7;\r\n            } else if (value <= 871000000000000 gwei) { // (8) > 87100 <= 871000 ether (12-0)\r\n                level = 8;\r\n            } else if (value <= 8710000000000000 gwei) {    // (9) > 871000 <= 8710000 ether (13-0)\r\n                level = 9;\r\n            } else {\r\n                // \u0432\u043e\u0437\u0432\u0440\u0430\u0442 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 - \u0435\u0441\u043b\u0438 \u043e\u043d\u0438 \u0432\u044b\u0448\u0435 8710000 ether)\r\n                address payable receiver = payable(msg.sender);\r\n                Address.sendValue(receiver, msg.value); // \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\r\n                return;\r\n            }\r\n\r\n            // \u0435\u0441\u043b\u0438 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u0430\u043b\u0430 \u0441 \u0443\u0447\u0451\u0442\u043e\u043c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0439 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0438 - \u0442\u043e\u0433\u0434\u0430 \u043f\u0440\u043e\u0441\u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c)\r\n            if (msg.value < GAS_MIN_UTILIZE * gasPrice) { // 387100)\r\n                \r\n                // \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0430\u044f \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f - \u043d\u0430 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c)\r\n                uint256 gasCost = GAS_POSSIBLE_FEE * gasPrice;  // 141780)\r\n                \r\n                range[level].lastIndex++;\r\n                // \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043f\u043b\u044e\u0441 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0430\u044f \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f)\r\n                value = msg.value + gasCost;\r\n                // \u0432 \u0442\u0435\u043a\u0443\u0449\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430)\r\n                range[level].currentFunds += msg.value;\r\n                // \u0432 \u043e\u0431\u0449\u0443\u044e \u0441\u0443\u043c\u043c\u0443 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430)\r\n                sumFunds += msg.value;\r\n\r\n                // \u0432 \u043a\u043e\u043d\u0435\u0446 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u044d\u0442\u043e\u0433\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430)\r\n                ray[level][range[level].lastIndex] = Ray({addr: msg.sender, utilize: value});\r\n                emit UtilizeReceived(msg.sender, value, level, range[level].lastIndex);\r\n\r\n            } else {    //\u0432 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u043b\u043e\u0433\u0438\u043a\u0443)\r\n                processUtilize(msg.value, gasPrice, level);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n    \r\n    // \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0438 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c)\r\n    function processUtilize(uint256 value, uint256 gasPrice, uint256 level) private {\r\n\r\n        uint256 maxCounter;\r\n        uint256 counterIt = 1;        \r\n        uint256 gasCost;\r\n        uint256 levelFee;\r\n        uint256 lowerLevelFee = value / 100; // \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f 1%)\r\n        uint256 ownerFee = 0;\r\n        uint256 leftCur = range[level].leftFunds; // \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \u0434\u043e\u043f\u043b\u0430\u0442\u0438\u0442\u044c \u043f\u0435\u0440\u0432\u043e\u043c\u0443 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0443 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438)\r\n        uint256 valueMsg;\r\n\r\n        // \u0443\u0431\u0438\u0440\u0430\u0435\u043c \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044e \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0443 3% \u043d\u0430 0 \u0438 1 \u0443\u0440\u043e\u0432\u043d\u0435)\r\n        if (level > 1) {\r\n            ownerFee = calculateFee(value, 3); // 3% \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0443)\r\n            address payable _owner = payable(owner);\r\n            Address.sendValue(_owner, ownerFee);\r\n        }        \r\n\r\n        // \u043d\u0430 5 \u043d\u0438\u0436\u043d\u0438\u0445 \u0443\u0440\u043e\u0432\u043d\u0435\u0439 \u043a \u0442\u0435\u043a\u0443\u0449\u0438\u043c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 1% - \u0441 \u0443\u0441\u043b\u043e\u0432\u0438\u0435\u043c - \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0441\u043f\u0443\u0441\u0442\u0438\u0442\u044c\u0441\u044f \u043d\u0438\u0436\u0435 \u043d\u0443\u043b\u0435\u0432\u043e\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f)\r\n        for (uint256 i = 1; i <= 5 && level > 1 && level >= i; i++) {\r\n            levelFee += lowerLevelFee;\r\n            range[level - i].currentFunds += lowerLevelFee;\r\n        }\r\n\r\n        // \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0432\u043b\u043e\u0436\u0435\u043d\u0438\u0439 - \u043c\u0438\u043d\u0443\u0441 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0443 \u0438 1% \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441)\r\n        sumFunds += value - lowerLevelFee - ownerFee;\r\n\r\n        // \u0442\u0435\u043a\u0443\u0449\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043f\u043b\u044e\u0441 \u043e\u0441\u0442\u0430\u0432\u0448\u0430\u044f\u0441\u044f \u0441\u0443\u043c\u043c\u0430)        \r\n        value = value - ownerFee - levelFee - lowerLevelFee;       \r\n\r\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439)\r\n        maxCounter = calculateMaxIterations(msg.value, gasPrice);\r\n        range[level].lastIndex++;   // \u0438\u043d\u043a\u0440\u0435\u043c\u0435\u043d\u0442 \u043a\u0440\u0430\u0439\u043d\u0435\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430)\r\n\r\n        // \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430)\r\n        value += range[level].currentFunds;\r\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u0443\u044e \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044e - \u0442\u043e\u0447\u043d\u0443\u044e \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u0441\u044f - \u0438\u0437-\u0437\u0430 \u0440\u0430\u043d\u0435\u0433\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c)\r\n        gasCost = maxCounter * GAS_PER_ITERATION * gasPrice;\r\n\r\n        // \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u044f \u043f\u043e \u0433\u0430\u0437\u0443 \u043f\u043b\u044e\u0441 \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430)\r\n        valueMsg = msg.value + gasCost;\r\n\r\n        // \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u043a\u043e\u043d\u0435\u0446 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430)\r\n        ray[level][range[level].lastIndex] = Ray({addr: msg.sender, utilize: valueMsg});\r\n        // \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432 \u0441\u043e\u0431\u044b\u0442\u0438\u0435 UtilizeReceived)\r\n        emit UtilizeReceived(msg.sender, valueMsg, level, range[level].lastIndex);\r\n\r\n        // \u0435\u0441\u043b\u0438 \u043e\u0441\u0442\u0430\u0442\u043e\u043a \u0431\u044b\u043b \u0432\u0435\u0441\u044c \u043f\u043e\u0433\u0430\u0448\u0435\u043d \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c\u0443 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0443 - \u0442\u043e \u0434\u043b\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0432\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u043f\u044f\u0442\u044c 150% \u0435\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u0438)\r\n        if (leftCur == 0) {\r\n            leftCur = calculate150(ray[level][range[level].firstIndex].utilize);\r\n        }\r\n\r\n        // \u0432\u044b\u043f\u043b\u0430\u0442\u0430 \u043f\u043e \u0442\u0435\u043a\u0443\u0449\u0435\u043c\u0443 \u0443\u0440\u043e\u0432\u043d\u044e \u0438 \u043d\u0438\u0436\u0435 \u043f\u043e \u0443\u0440\u043e\u0432\u043d\u044f\u043c - \u043f\u043e\u043a\u0430 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439)\r\n        for (uint256 i = 0; level >= i && counterIt < maxCounter; i++) {\r\n            \r\n            // \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0432\u044b\u043f\u043b\u0430\u0442\u044b)\r\n            counterIt = processPayOut(value, sumFunds, leftCur, level - i, counterIt, maxCounter);\r\n\r\n            if (counterIt < maxCounter && level - i > 0) {\r\n                uint256 levelDown = level - i - 1;\r\n                value = range[levelDown].currentFunds;\r\n                leftCur = range[levelDown].leftFunds;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0432\u044b\u043f\u043b\u0430\u0442\u044b)\r\n    function processPayOut(uint256 value, uint256 sumF, uint256 leftCur, uint256 level, uint256 counterIt, uint256 maxCounter) private returns (uint256) {\r\n\r\n        // \u0434\u0435\u043b\u0430\u0435\u043c \u0432\u044b\u043f\u043b\u0430\u0442\u0443 \u0432\u0441\u0435\u043c \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430\u043c \u043f\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u0438 - \u043f\u043e \u0442\u0435\u043a\u0443\u0449\u0435\u043c\u0443 \u0438\u043d\u0434\u0435\u043a\u0441\u0443 - \u0441 \u0443\u0447\u0451\u0442\u043e\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432)\r\n        while (counterIt < maxCounter && value >= leftCur && range[level].firstIndex <= range[level].lastIndex) {\r\n\r\n            value -= leftCur;\r\n            // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 - \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0432\u044b\u0439\u0442\u0438 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0438 \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u043d\u0435 \u0432\u044b\u0434\u0430\u043b\u043e \u043e\u0448\u0438\u0431\u043a\u0443)\r\n            sumF = sumF > leftCur ? sumF - leftCur : 0;\r\n\r\n            // \u0435\u0441\u043b\u0438 \u0438\u043d\u0434\u0435\u043a\u0441 \u0440\u0430\u0432\u0435\u043d 0 \u0438\u043b\u0438 1 \u0438 \u0433\u0430\u0437 \u0431\u043e\u043b\u044c\u0448\u0435 \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e 1 \u044d\u0444\u0438\u0440\u0443 - \u0438\u0437\u0431\u044b\u0442\u043e\u043a \u0433\u0430\u0437\u0430 \u0438\u0434\u0451\u0442 \u0432 \u0431\u043e\u043d\u0443\u0441)\r\n            // \u0431\u043e\u043d\u0443\u0441 \u043f\u0435\u0440\u0432\u044b\u043c \u0434\u0432\u0443\u043c \u0443\u0440\u043e\u0432\u043d\u044f\u043c +0.5 \u044d\u0444\u0438\u0440\u0430 - \u0438 \u043d\u0435 \u0432\u0430\u0436\u043d\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0431\u044b\u043b\u043e \u0443\u0442\u0438\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043e)\r\n            if ( level < 2 && address(this).balance > sumF  && address(this).balance - sumF >= 1 ether) {\r\n                leftCur += BONUS; // 0.5 ether\r\n            }\r\n\r\n            address payable receivePayout = payable(ray[level][range[level].firstIndex].addr);\r\n            Address.sendValue(receivePayout, leftCur); // \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435)\r\n            // \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432 \u0441\u043e\u0431\u044b\u0442\u0438\u0435 UtilizePayOut)\r\n            emit UtilizePayOut(ray[level][range[level].firstIndex].addr, leftCur, level, range[level].firstIndex);\r\n            // \u0435\u0441\u043b\u0438 \u0432\u044b\u043f\u043b\u0430\u0442\u0430 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0430 \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e - \u0442\u043e \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0430 \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438)\r\n            delete ray[level][range[level].firstIndex];\r\n            range[level].firstIndex++;\r\n            counterIt++;\r\n\r\n            // \u0441\u0440\u0430\u0437\u0443 \u0436\u0435 \u0437\u0430\u0434\u0430\u0451\u043c \u043e\u0441\u0442\u0430\u0432\u0448\u0435\u0435\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0443 \u0440\u0430\u0432\u043d\u043e\u0435 150% \u0435\u0433\u043e \u0443\u0442\u0438\u043b\u0438\u0437\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u043c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c)\r\n            // \u0438 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 - \u0447\u0442\u043e \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u043a\u0442\u043e-\u0442\u043e \u0435\u0441\u0442\u044c \u0435\u0449\u0451)\r\n            if (range[level].firstIndex <= range[level].lastIndex) {\r\n                leftCur = calculate150(ray[level][range[level].firstIndex].utilize);\r\n            } else {\r\n                leftCur = 0;\r\n            }\r\n\r\n        }\r\n\r\n        // \u0435\u0441\u043b\u0438 \u043e\u0431\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u0432\u044b\u043f\u043b\u0430\u0442\u044b \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0443 \u0435\u0449\u0451 \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043b\u0430 150% - \u0432\u0441\u0451 \u0440\u0430\u0432\u043d\u043e \u0432\u044b\u043f\u043b\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u0447\u0430\u0441\u0442\u044c - \u0447\u0442\u043e \u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \u0432 \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u0445)\r\n        if (counterIt < maxCounter && range[level].firstIndex <= range[level].lastIndex) {\r\n\r\n            // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 - \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0432\u044b\u0439\u0442\u0438 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0438 \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u043d\u0435 \u0432\u044b\u0434\u0430\u043b\u043e \u043e\u0448\u0438\u0431\u043a\u0443)\r\n            leftCur = leftCur > value ? leftCur - value : 0;\r\n\r\n            // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 - \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0432\u044b\u0439\u0442\u0438 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0438 \u0442\u0435\u043c \u0441\u0430\u043c\u044b\u043c \u043d\u0435 \u0432\u044b\u0434\u0430\u043b\u043e \u043e\u0448\u0438\u0431\u043a\u0443)\r\n            sumF = sumF > value ? sumF - value : 0;\r\n\r\n            // \u043f\u0435\u0440\u0432\u044b\u043c \u0434\u0432\u0443\u043c \u0443\u0440\u043e\u0432\u043d\u044f\u043c \u0431\u043e\u043d\u0443\u0441 +0.5 \u044d\u0444\u0438\u0440 - \u0435\u0441\u043b\u0438 \u043d\u0430 \u0431\u0430\u043b\u0430\u043d\u0441\u0435 \u0432\u044b\u0448\u0435 1 \u044d\u0444\u0438\u0440\u0430)\r\n            if (level < 2 && address(this).balance > sumF && address(this).balance - sumF >= 1 ether) {\r\n                value += BONUS;\r\n            }\r\n\r\n            address payable receivePayoutLeft = payable(ray[level][range[level].firstIndex].addr);\r\n            Address.sendValue(receivePayoutLeft, value); // \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430)                    \r\n            // \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432 \u0441\u043e\u0431\u044b\u0442\u0438\u0435 UtilizePayOut)\r\n            emit UtilizePayOut(ray[level][range[level].firstIndex].addr, value, level, range[level].firstIndex);\r\n\r\n            // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u043e\u043c\u0443 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0430 \u0432\u0441\u044f \u043e\u043f\u043b\u0430\u0442\u0430 \u0438 \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043d\u0435 \u043e\u0441\u0442\u0430\u043b\u043e\u0441\u044c - \u0442\u043e\u0433\u0434\u0430 \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438)\r\n            if (leftCur == 0) {\r\n                delete ray[level][range[level].firstIndex];\r\n                range[level].firstIndex++;\r\n            }\r\n\r\n            counterIt++;\r\n            value = 0;  // \u0442\u0430\u043a \u043a\u0430\u043a \u043c\u044b \u0432\u044b\u043f\u043b\u0430\u0442\u0438\u043b\u0438 \u043e\u0441\u0442\u0430\u0442\u043e\u043a - \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u044b\u043b \u0432 \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u0445 - \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0434\u0435\u043b\u0430\u0435\u043c \u0432 \u043d\u043e\u043b\u044c)\r\n\r\n        }\r\n\r\n        // \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u043d\u0443\u0436\u043d\u044b\u0435 \u043d\u0430\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0442\u0435\u043a\u0443\u0449\u0438\u043c \u0438 \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u043c\u0441\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c)\r\n        range[level].currentFunds = value;        \r\n        range[level].leftFunds = leftCur;\r\n\r\n        sumFunds = sumF;    // \u041e\u0431\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u043f\u043e \u0432\u0441\u0435\u043c \u0443\u0440\u043e\u0432\u043d\u044f\u043c)\r\n        return counterIt;   // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u043d\u044b\u0445 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439)\r\n\r\n    }\r\n\r\n    // \u0431\u0430\u043b\u0430\u043d\u0441)\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function calculateFee(uint256 value, uint256 fee) private pure returns (uint256) {\r\n        return value * fee / 100; // \u0440\u0430\u0441\u0447\u0451\u0442 \u043a\u043e\u043c\u0438\u0441\u0441\u0438\u0438 fee%)\r\n    }\r\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 150%)\r\n    function calculate150(uint256 value) private pure returns (uint256) {\r\n        return value * 3 / 2; // 150%)\r\n    }\r\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439)\r\n    function calculateMaxIterations(uint256 value, uint256 gasPrice) private pure returns (uint256) {\r\n\r\n        // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 - \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0431\u044b\u043b\u043e \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u043e\u043b\u044c)\r\n        if (gasPrice == 0) {\r\n            gasPrice = 1 gwei;\r\n        }\r\n        \r\n        uint256 gasAmount = value / gasPrice;\r\n        uint256 possibleIterations = gasAmount / GAS_PER_ITERATION;\r\n        \r\n        if (possibleIterations > MAX_ITERATIONS) {\r\n            return MAX_ITERATIONS;  // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c)\r\n        } else {\r\n            return possibleIterations;  // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c)\r\n        }\r\n\r\n    }\r\n\r\n    // \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443 \u0443\u0440\u043e\u0432\u043d\u044f \u0438 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c\u0443 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0443)\r\n    function getRayData(uint8 level, uint256 from, uint256 to) public view returns (Ray[] memory) {\r\n        \r\n        if (from < range[level].firstIndex || from > range[level].lastIndex) {\r\n            from = range[level].firstIndex;\r\n        }\r\n        if (to < range[level].firstIndex || to > range[level].lastIndex) {\r\n            to = range[level].lastIndex;\r\n        }\r\n        \r\n        Ray[] memory result;\r\n        // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445)\r\n        if (from <= to) {\r\n\r\n            result = new Ray[](to - from + 1);\r\n            for (uint256 i = from; i <= to; i++) {\r\n                result[i - from] = ray[level][i];\r\n            }\r\n        }\r\n        \r\n        return result;\r\n\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueIndex\",\"type\":\"uint256\"}],\"name\":\"UtilizePayOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueIndex\",\"type\":\"uint256\"}],\"name\":\"UtilizeReceived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getRayData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"utilize\",\"type\":\"uint256\"}],\"internalType\":\"struct SUS.Ray[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"range\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentFunds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"utilize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SUS", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f429a2d14414e41026acf0b9257f707e440273532c3b341f8eee15b42b4a907"}