{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IControlledToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/** @title IControlledToken\\n * @author Asymetrix Protocol Inc Team\\n * @notice ERC20 Tokens with a controller for minting & burning.\\n */\\ninterface IControlledToken is IERC20Upgradeable {\\n    /**\\n        @notice Interface to the contract responsible for controlling mint/burn\\n    */\\n    function controller() external view returns (address);\\n\\n    /**\\n     * @notice Allows the controller to mint tokens for a user account\\n     * @dev    May be overridden to provide more granular control over minting\\n     * @param user Address of the receiver of the minted tokens\\n     * @param amount Amount of tokens to mint\\n     */\\n    function controllerMint(address user, uint256 amount) external;\\n\\n    /**\\n     * @notice Allows the controller to burn tokens from a user account\\n     * @dev    May be overridden to provide more granular control over burning\\n     * @param user Address of the holder account to burn tokens from\\n     * @param amount Amount of tokens to burn\\n     */\\n    function controllerBurn(address user, uint256 amount) external;\\n\\n    /**\\n     * @notice Allows an operator via the controller to burn tokens on behalf of\\n     *         a user account\\n     * @dev    May be overridden to provide more granular control over\\n     *         operator-burning\\n     * @param operator Address of the operator performing the burn action via\\n     *        the controller contract\\n     * @param user Address of the holder account to burn tokens from\\n     * @param amount Amount of tokens to burn\\n     */\\n    function controllerBurnFrom(address operator, address user, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/ITicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../libraries/TwabLib.sol\\\";\\n\\nimport \\\"./IControlledToken.sol\\\";\\n\\ninterface ITicket is IControlledToken {\\n    /**\\n     * @notice A struct containing details for an Account.\\n     * @param balance The current balance for an Account.\\n     * @param nextTwabIndex The next available index to store a new twab.\\n     * @param cardinality The number of recorded twabs (plus one!).\\n     */\\n    struct AccountDetails {\\n        uint224 balance;\\n        uint16 nextTwabIndex;\\n        uint16 cardinality;\\n    }\\n\\n    /**\\n     * @notice Combines account details with their twab history.\\n     * @param details The account details.\\n     * @param twabs The history of twabs for this account.\\n     */\\n    struct Account {\\n        AccountDetails details;\\n        ObservationLib.Observation[65535] twabs;\\n    }\\n\\n    /**\\n     * @notice Emitted when TWAB balance has been delegated to another user.\\n     * @param delegator Address of the delegator.\\n     * @param delegate Address of the delegate.\\n     */\\n    event Delegated(address indexed delegator, address indexed delegate);\\n\\n    /**\\n     * @notice Emitted when ticket is initialized.\\n     * @param name Ticket name (eg: Asymetrix Protocol Dai Ticket (Compound)).\\n     * @param symbol Ticket symbol (eg: AsxDAI).\\n     * @param decimals Ticket decimals.\\n     * @param controller Token controller address.\\n     */\\n    event TicketInitialized(string name, string symbol, uint8 decimals, address indexed controller);\\n\\n    /**\\n     * @notice Emitted when a new TWAB has been recorded.\\n     * @param delegate The recipient of the ticket power (may be the same as the\\n     *                 user).\\n     * @param newTwab Updated TWAB of a ticket holder after a successful TWAB\\n     *                recording.\\n     */\\n    event NewUserTwab(address indexed delegate, ObservationLib.Observation newTwab);\\n\\n    /**\\n     * @notice Emitted when a new total supply TWAB has been recorded.\\n     * @param newTotalSupplyTwab Updated TWAB of tickets total supply after a\\n     *                           successful total supply TWAB recording.\\n     */\\n    event NewTotalSupplyTwab(ObservationLib.Observation newTotalSupplyTwab);\\n\\n    /**\\n     * @notice Retrieves the address of the delegate to whom `user` has\\n     *         delegated their tickets.\\n     * @dev Address of the delegate will be the zero address if `user` has not\\n     *      delegated their tickets.\\n     * @param user Address of the delegator.\\n     * @return Address of the delegate.\\n     */\\n    function delegateOf(address user) external view returns (address);\\n\\n    /**\\n     * @notice Delegate time-weighted average balances to an alternative address.\\n     * @dev    Transfers (including mints) trigger the storage of a TWAB in\\n     *         delegate(s) account, instead of the targetted sender and/or\\n     *         recipient address(s).\\n     * @dev    To reset the delegate, pass the zero address (0x000.000) as `to`\\n     *         parameter.\\n     * @dev    Current delegate address should be different from the new\\n     *         delegate address `to`.\\n     * @param  to Recipient of delegated TWAB.\\n     */\\n    function delegate(address to) external;\\n\\n    /**\\n     * @notice Allows the controller to delegate on a users behalf.\\n     * @param user The user for whom to delegate\\n     * @param delegate The new delegate\\n     */\\n    function controllerDelegateFor(address user, address delegate) external;\\n\\n    /**\\n     * @notice Allows a user to delegate via signature\\n     * @param user The user who is delegating\\n     * @param delegate The new delegate\\n     * @param deadline The timestamp by which this must be submitted\\n     * @param v The v portion of the ECDSA sig\\n     * @param r The r portion of the ECDSA sig\\n     * @param s The s portion of the ECDSA sig\\n     */\\n    function delegateWithSignature(\\n        address user,\\n        address delegate,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Gets a users twab context.  This is a struct with their balance,\\n     *         next twab index, and cardinality.\\n     * @param user The user for whom to fetch the TWAB context.\\n     * @return The TWAB context, which includes { balance, nextTwabIndex,\\n     *         cardinality }\\n     */\\n    function getAccountDetails(address user) external view returns (TwabLib.AccountDetails memory);\\n\\n    /**\\n     * @notice Gets the TWAB at a specific index for a user.\\n     * @param user The user for whom to fetch the TWAB.\\n     * @param index The index of the TWAB to fetch.\\n     * @return The TWAB, which includes the twab amount and the timestamp.\\n     */\\n    function getTwab(address user, uint16 index) external view returns (ObservationLib.Observation memory);\\n\\n    /**\\n     * @notice Retrieves `user` TWAB balance.\\n     * @param user Address of the user whose TWAB is being fetched.\\n     * @param timestamp Timestamp at which we want to retrieve the TWAB balance.\\n     * @return The TWAB balance at the given timestamp.\\n     */\\n    function getBalanceAt(address user, uint64 timestamp) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves `user` TWAB balances.\\n     * @param user Address of the user whose TWABs are being fetched.\\n     * @param timestamps Timestamps range at which we want to retrieve the\\n     *                   TWAB balances.\\n     * @return `user` TWAB balances.\\n     */\\n    function getBalancesAt(address user, uint64[] calldata timestamps) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Retrieves the average balance held by a user for a given time\\n     *         frame.\\n     * @param user The user whose balance is checked.\\n     * @param startTime The start time of the time frame.\\n     * @param endTime The end time of the time frame.\\n     * @return The average balance that the user held during the time frame.\\n     */\\n    function getAverageBalanceBetween(address user, uint64 startTime, uint64 endTime) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the average balances held by a user for a given time\\n     *         frame.\\n     * @param user The user whose balance is checked.\\n     * @param startTimes The start time of the time frame.\\n     * @param endTimes The end time of the time frame.\\n     * @return The average balance that the user held during the time frame.\\n     */\\n    function getAverageBalancesBetween(\\n        address user,\\n        uint64[] calldata startTimes,\\n        uint64[] calldata endTimes\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Retrieves the total supply TWAB balance at the given timestamp.\\n     * @param timestamp Timestamp at which we want to retrieve the total supply\\n     *                  TWAB balance.\\n     * @return The total supply TWAB balance at the given timestamp.\\n     */\\n    function getTotalSupplyAt(uint64 timestamp) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the total supply TWAB balance between the given\\n     *         timestamps range.\\n     * @param timestamps Timestamps range at which we want to retrieve the total\\n     *                   supply TWAB balance.\\n     * @return Total supply TWAB balances.\\n     */\\n    function getTotalSuppliesAt(uint64[] calldata timestamps) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Retrieves the average total supply balance for a set of given\\n     *         time frames.\\n     * @param startTimes Array of start times.\\n     * @param endTimes Array of end times.\\n     * @return The average total supplies held during the time frame.\\n     */\\n    function getAverageTotalSuppliesBetween(\\n        uint64[] calldata startTimes,\\n        uint64[] calldata endTimes\\n    ) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/ExtendedSafeCastLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added\\n * overflow checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This\\n * can easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller\\n * types, by performing all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary ExtendedSafeCastLib {\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 _value) internal pure returns (uint104) {\\n        require(_value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(_value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 _value) internal pure returns (uint208) {\\n        require(_value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(_value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 _value) internal pure returns (uint224) {\\n        require(_value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(_value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/ObservationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\nimport \\\"./OverflowSafeComparatorLib.sol\\\";\\nimport \\\"./RingBufferLib.sol\\\";\\n\\n/**\\n * @title Observation Library\\n * @notice This library allows one to store an array of timestamped values and\\n *         efficiently binary search them.\\n * @dev Largely pulled from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/c05a0e2c8c08c460fb4d05cfdda30b3ad8deeaac/contracts/libraries/Oracle.sol\\n * @author Asymetrix Protocol Inc.\\n */\\nlibrary ObservationLib {\\n    using OverflowSafeComparatorLib for uint32;\\n    using SafeCastUpgradeable for uint256;\\n\\n    /// @notice The maximum number of observations\\n    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\\n\\n    /**\\n     * @notice Observation, which includes an amount and timestamp.\\n     * @param amount `amount` at `timestamp`.\\n     * @param timestamp Recorded `timestamp`.\\n     */\\n    struct Observation {\\n        uint224 amount;\\n        uint32 timestamp;\\n    }\\n\\n    /**\\n     * @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.\\n     * The result may be the same Observation, or adjacent Observations.\\n     * @dev The answer must be contained in the array used when the target is located within the stored Observation.\\n     * boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.\\n     * @dev  If `_newestObservationIndex` is less than `_oldestObservationIndex`, it means that we've wrapped around the circular buffer.\\n     *       So the most recent observation will be at `_oldestObservationIndex + _cardinality - 1`, at the beginning of the circular buffer.\\n     * @param _observations List of Observations to search through.\\n     * @param _newestObservationIndex Index of the newest Observation. Right side of the circular buffer.\\n     * @param _oldestObservationIndex Index of the oldest Observation. Left side of the circular buffer.\\n     * @param _target Timestamp at which we are searching the Observation.\\n     * @param _cardinality Cardinality of the circular buffer we are searching through.\\n     * @param _time Timestamp at which we perform the binary search.\\n     * @return beforeOrAt Observation recorded before, or at, the target.\\n     * @return atOrAfter Observation recorded at, or after, the target.\\n     */\\n    function binarySearch(\\n        Observation[MAX_CARDINALITY] storage _observations,\\n        uint24 _newestObservationIndex,\\n        uint24 _oldestObservationIndex,\\n        uint32 _target,\\n        uint24 _cardinality,\\n        uint32 _time\\n    ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        uint256 leftSide = _oldestObservationIndex;\\n        uint256 rightSide = _newestObservationIndex < leftSide ? leftSide + _cardinality - 1 : _newestObservationIndex;\\n        uint256 currentIndex;\\n\\n        while (true) {\\n            // We start our search in the middle of the `leftSide` and `rightSide`.\\n            // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.\\n            currentIndex = (leftSide + rightSide) / 2;\\n\\n            beforeOrAt = _observations[uint24(RingBufferLib.wrap(currentIndex, _cardinality))];\\n            uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;\\n\\n            // We've landed on an uninitialized timestamp, keep searching higher (more recently).\\n            if (beforeOrAtTimestamp == 0) {\\n                leftSide = currentIndex + 1;\\n                continue;\\n            }\\n\\n            atOrAfter = _observations[uint24(RingBufferLib.nextIndex(currentIndex, _cardinality))];\\n\\n            bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);\\n\\n            // Check if we've found the corresponding Observation.\\n            if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {\\n                break;\\n            }\\n\\n            // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.\\n            if (!targetAtOrAfter) {\\n                rightSide = currentIndex - 1;\\n            } else {\\n                // Otherwise, we keep searching higher. To the left of the current index.\\n                leftSide = currentIndex + 1;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/OverflowSafeComparatorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/// @title OverflowSafeComparatorLib library to share comparator functions between contracts\\n/// @dev Code taken from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/3e88af408132fc957e3e406f65a0ce2b1ca06c3d/contracts/libraries/Oracle.sol\\n/// @author Asymetrix Protocol Inc.\\nlibrary OverflowSafeComparatorLib {\\n    /// @notice 32-bit timestamps comparator.\\n    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n    /// @param _b Timestamp to compare against `_a`.\\n    /// @param _timestamp A timestamp truncated to 32 bits.\\n    /// @return bool Whether `_a` is chronologically < `_b`.\\n    function lt(uint32 _a, uint32 _b, uint32 _timestamp) internal pure returns (bool) {\\n        // No need to adjust if there hasn't been an overflow\\n        if (_a <= _timestamp && _b <= _timestamp) return _a < _b;\\n\\n        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2 ** 32;\\n        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2 ** 32;\\n\\n        return aAdjusted < bAdjusted;\\n    }\\n\\n    /// @notice 32-bit timestamps comparator.\\n    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n    /// @param _b Timestamp to compare against `_a`.\\n    /// @param _timestamp A timestamp truncated to 32 bits.\\n    /// @return bool Whether `_a` is chronologically <= `_b`.\\n    function lte(uint32 _a, uint32 _b, uint32 _timestamp) internal pure returns (bool) {\\n        // No need to adjust if there hasn't been an overflow\\n        if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;\\n\\n        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2 ** 32;\\n        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2 ** 32;\\n\\n        return aAdjusted <= bAdjusted;\\n    }\\n\\n    /// @notice 32-bit timestamp subtractor\\n    /// @dev safe for 0 or 1 overflows, where `_a` and `_b` must be chronologically before or equal to time\\n    /// @param _a The subtraction left operand\\n    /// @param _b The subtraction right operand\\n    /// @param _timestamp The current time.  Expected to be chronologically after both.\\n    /// @return The difference between a and b, adjusted for overflow\\n    function checkedSub(uint32 _a, uint32 _b, uint32 _timestamp) internal pure returns (uint32) {\\n        // No need to adjust if there hasn't been an overflow\\n\\n        if (_a <= _timestamp && _b <= _timestamp) return _a - _b;\\n\\n        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2 ** 32;\\n        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2 ** 32;\\n\\n        return uint32(aAdjusted - bAdjusted);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/RingBufferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nlibrary RingBufferLib {\\n    /**\\n     * @notice Returns wrapped TWAB index.\\n     * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.\\n     * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,\\n     *       it will return 0 and will point to the first element of the array.\\n     * @param _index Index used to navigate through the TWAB circular buffer.\\n     * @param _cardinality TWAB buffer cardinality.\\n     * @return TWAB index.\\n     */\\n    function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n        return _index % _cardinality;\\n    }\\n\\n    /**\\n     * @notice Computes the negative offset from the given index, wrapped by the cardinality.\\n     * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.\\n     * @param _index The index from which to offset\\n     * @param _amount The number of indices to offset.  This is subtracted from the given index.\\n     * @param _cardinality The number of elements in the ring buffer\\n     * @return Offsetted index.\\n     */\\n    function offset(uint256 _index, uint256 _amount, uint256 _cardinality) internal pure returns (uint256) {\\n        return wrap(_index + _cardinality - _amount, _cardinality);\\n    }\\n\\n    /// @notice Returns the index of the last recorded TWAB\\n    /// @param _nextIndex The next available twab index.  This will be recorded to next.\\n    /// @param _cardinality The cardinality of the TWAB history.\\n    /// @return The index of the last recorded TWAB\\n    function newestIndex(uint256 _nextIndex, uint256 _cardinality) internal pure returns (uint256) {\\n        if (_cardinality == 0) {\\n            return 0;\\n        }\\n\\n        return wrap(_nextIndex + _cardinality - 1, _cardinality);\\n    }\\n\\n    /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality\\n    /// @param _index The index to increment\\n    /// @param _cardinality The number of elements in the Ring Buffer\\n    /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality\\n    function nextIndex(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n        return wrap(_index + 1, _cardinality);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/libraries/TwabLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./ExtendedSafeCastLib.sol\\\";\\nimport \\\"./OverflowSafeComparatorLib.sol\\\";\\nimport \\\"./RingBufferLib.sol\\\";\\nimport \\\"./ObservationLib.sol\\\";\\n\\n/**\\n  * @title  Asymetrix Protocol V1 TwabLib (Library)\\n  * @author Asymetrix Protocol Inc Team\\n  * @dev    Time-Weighted Average Balance Library for ERC20 tokens.\\n  * @notice This TwabLib adds on-chain historical lookups to a user(s) time-weighted average balance.\\n            Each user is mapped to an Account struct containing the TWAB history (ring buffer) and\\n            ring buffer parameters. Every token.transfer() creates a new TWAB checkpoint. The new TWAB\\n            checkpoint is stored in the circular ring buffer, as either a new checkpoint or rewriting\\n            a previous checkpoint with new parameters. The TwabLib (using existing blocktimes of 1block/15sec)\\n            guarantees minimum 7.4 years of search history.\\n */\\nlibrary TwabLib {\\n    using OverflowSafeComparatorLib for uint32;\\n    using ExtendedSafeCastLib for uint256;\\n\\n    /**\\n      * @notice Sets max ring buffer length in the Account.twabs Observation list.\\n                As users transfer/mint/burn tickets new Observation checkpoints are\\n                recorded. The current max cardinality guarantees a seven year minimum,\\n                of accurate historical lookups with current estimates of 1 new block\\n                every 15 seconds - assuming each block contains a transfer to trigger an\\n                observation write to storage.\\n      * @dev    The user Account.AccountDetails.cardinality parameter can NOT exceed\\n                the max cardinality variable. Preventing \\\"corrupted\\\" ring buffer lookup\\n                pointers and new observation checkpoints.\\n\\n                The MAX_CARDINALITY in fact guarantees at least 7.4 years of records:\\n                If 14 = block time in seconds\\n                (2**24) * 14 = 234881024 seconds of history\\n                234881024 / (365 * 24 * 60 * 60) ~= 7.44 years\\n    */\\n    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\\n\\n    /** @notice Struct ring buffer parameters for single user Account\\n      * @param balance       Current balance for an Account\\n      * @param nextTwabIndex Next uninitialized or updatable ring buffer checkpoint storage slot\\n      * @param cardinality   Current total \\\"initialized\\\" ring buffer checkpoints for single user AccountDetails.\\n                             Used to set initial boundary conditions for an efficient binary search.\\n    */\\n    struct AccountDetails {\\n        uint208 balance;\\n        uint24 nextTwabIndex;\\n        uint24 cardinality;\\n    }\\n\\n    /// @notice Combines account details with their twab history\\n    /// @param details The account details\\n    /// @param twabs The history of twabs for this account\\n    struct Account {\\n        AccountDetails details;\\n        ObservationLib.Observation[MAX_CARDINALITY] twabs;\\n    }\\n\\n    /// @notice Increases an account's balance and records a new twab.\\n    /// @param _account The account whose balance will be increased\\n    /// @param _amount The amount to increase the balance by\\n    /// @param _currentTime The current time\\n    /// @return accountDetails The new AccountDetails\\n    /// @return twab The user's latest TWAB\\n    /// @return isNew Whether the TWAB is new\\n    function increaseBalance(\\n        Account storage _account,\\n        uint208 _amount,\\n        uint32 _currentTime\\n    ) internal returns (AccountDetails memory accountDetails, ObservationLib.Observation memory twab, bool isNew) {\\n        AccountDetails memory _accountDetails = _account.details;\\n        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\\n        accountDetails.balance = _accountDetails.balance + _amount;\\n    }\\n\\n    /** @notice Calculates the next TWAB checkpoint for an account with a decreasing balance.\\n     * @dev    With Account struct and amount decreasing calculates the next TWAB observable checkpoint.\\n     * @param _account        Account whose balance will be decreased\\n     * @param _amount         Amount to decrease the balance by\\n     * @param _revertMessage  Revert message for insufficient balance\\n     * @return accountDetails Updated Account.details struct\\n     * @return twab           TWAB observation (with decreasing average)\\n     * @return isNew          Whether TWAB is new or calling twice in the same block\\n     */\\n    function decreaseBalance(\\n        Account storage _account,\\n        uint208 _amount,\\n        string memory _revertMessage,\\n        uint32 _currentTime\\n    ) internal returns (AccountDetails memory accountDetails, ObservationLib.Observation memory twab, bool isNew) {\\n        AccountDetails memory _accountDetails = _account.details;\\n\\n        require(_accountDetails.balance >= _amount, _revertMessage);\\n\\n        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\\n        unchecked {\\n            accountDetails.balance -= _amount;\\n        }\\n    }\\n\\n    /** @notice Calculates the average balance held by a user for a given time frame.\\n      * @dev    Finds the average balance between start and end timestamp epochs.\\n                Validates the supplied end time is within the range of elapsed time i.e. less then timestamp of now.\\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails User AccountDetails struct loaded in memory\\n      * @param _startTime      Start of timestamp range as an epoch\\n      * @param _endTime        End of timestamp range as an epoch\\n      * @param _currentTime    Block.timestamp\\n      * @return Average balance of user held between epoch timestamps start and end\\n    */\\n    function getAverageBalanceBetween(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        uint32 _startTime,\\n        uint32 _endTime,\\n        uint32 _currentTime\\n    ) internal view returns (uint256) {\\n        uint32 endTime = _endTime > _currentTime ? _currentTime : _endTime;\\n\\n        return _getAverageBalanceBetween(_twabs, _accountDetails, _startTime, endTime, _currentTime);\\n    }\\n\\n    /// @notice Retrieves the oldest TWAB\\n    /// @param _twabs The storage array of twabs\\n    /// @param _accountDetails The TWAB account details\\n    /// @return index The index of the oldest TWAB in the twabs array\\n    /// @return twab The oldest TWAB\\n    function oldestTwab(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails\\n    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\\n        index = _accountDetails.nextTwabIndex;\\n        twab = _twabs[index];\\n\\n        // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0\\n        if (twab.timestamp == 0) {\\n            index = 0;\\n            twab = _twabs[0];\\n        }\\n    }\\n\\n    /// @notice Retrieves the newest TWAB\\n    /// @param _twabs The storage array of twabs\\n    /// @param _accountDetails The TWAB account details\\n    /// @return index The index of the newest TWAB in the twabs array\\n    /// @return twab The newest TWAB\\n    function newestTwab(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails\\n    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\\n        index = uint24(RingBufferLib.newestIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));\\n        twab = _twabs[index];\\n    }\\n\\n    /// @notice Retrieves amount at `_targetTime` timestamp\\n    /// @param _twabs List of TWABs to search through.\\n    /// @param _accountDetails Accounts details\\n    /// @param _targetTime Timestamp at which the reserved TWAB should be for.\\n    /// @return uint256 TWAB amount at `_targetTime`.\\n    function getBalanceAt(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        uint32 _targetTime,\\n        uint32 _currentTime\\n    ) internal view returns (uint256) {\\n        uint32 timeToTarget = _targetTime > _currentTime ? _currentTime : _targetTime;\\n        return _getBalanceAt(_twabs, _accountDetails, timeToTarget, _currentTime);\\n    }\\n\\n    /// @notice Calculates the average balance held by a user for a given time frame.\\n    /// @param _startTime The start time of the time frame.\\n    /// @param _endTime The end time of the time frame.\\n    /// @return The average balance that the user held during the time frame.\\n    function _getAverageBalanceBetween(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        uint32 _startTime,\\n        uint32 _endTime,\\n        uint32 _currentTime\\n    ) private view returns (uint256) {\\n        (uint24 oldestTwabIndex, ObservationLib.Observation memory oldTwab) = oldestTwab(_twabs, _accountDetails);\\n\\n        (uint24 newestTwabIndex, ObservationLib.Observation memory newTwab) = newestTwab(_twabs, _accountDetails);\\n\\n        ObservationLib.Observation memory startTwab = _calculateTwab(\\n            _twabs,\\n            _accountDetails,\\n            newTwab,\\n            oldTwab,\\n            newestTwabIndex,\\n            oldestTwabIndex,\\n            _startTime,\\n            _currentTime\\n        );\\n\\n        ObservationLib.Observation memory endTwab = _calculateTwab(\\n            _twabs,\\n            _accountDetails,\\n            newTwab,\\n            oldTwab,\\n            newestTwabIndex,\\n            oldestTwabIndex,\\n            _endTime,\\n            _currentTime\\n        );\\n\\n        // Difference in amount / time\\n        return\\n            (endTwab.amount - startTwab.amount) /\\n            OverflowSafeComparatorLib.checkedSub(endTwab.timestamp, startTwab.timestamp, _currentTime);\\n    }\\n\\n    /** @notice Searches TWAB history and calculate the difference between amount(s)/timestamp(s) to return average balance\\n                between the Observations closes to the supplied targetTime.\\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails User AccountDetails struct loaded in memory\\n      * @param _targetTime     Target timestamp to filter Observations in the ring buffer binary search\\n      * @param _currentTime    Block.timestamp\\n      * @return uint256 Time-weighted average amount between two closest observations.\\n    */\\n    function _getBalanceAt(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        uint32 _targetTime,\\n        uint32 _currentTime\\n    ) private view returns (uint256) {\\n        uint24 newestTwabIndex;\\n        ObservationLib.Observation memory afterOrAt;\\n        ObservationLib.Observation memory beforeOrAt;\\n        (newestTwabIndex, beforeOrAt) = newestTwab(_twabs, _accountDetails);\\n\\n        // If `_targetTime` is chronologically after the newest TWAB, we can simply return the current balance\\n        if (beforeOrAt.timestamp.lte(_targetTime, _currentTime)) {\\n            return _accountDetails.balance;\\n        }\\n\\n        uint24 oldestTwabIndex;\\n        // Now, set before to the oldest TWAB\\n        (oldestTwabIndex, beforeOrAt) = oldestTwab(_twabs, _accountDetails);\\n\\n        // If `_targetTime` is chronologically before the oldest TWAB, we can early return\\n        if (_targetTime.lt(beforeOrAt.timestamp, _currentTime)) {\\n            return 0;\\n        }\\n\\n        // Otherwise, we perform the `binarySearch`\\n        (beforeOrAt, afterOrAt) = ObservationLib.binarySearch(\\n            _twabs,\\n            newestTwabIndex,\\n            oldestTwabIndex,\\n            _targetTime,\\n            _accountDetails.cardinality,\\n            _currentTime\\n        );\\n\\n        // Sum the difference in amounts and divide by the difference in timestamps.\\n        // The time-weighted average balance uses time measured between two epoch timestamps as\\n        // a constaint on the measurement when calculating the time weighted average balance.\\n        return\\n            (afterOrAt.amount - beforeOrAt.amount) /\\n            OverflowSafeComparatorLib.checkedSub(afterOrAt.timestamp, beforeOrAt.timestamp, _currentTime);\\n    }\\n\\n    /** @notice Calculates a user TWAB for a target timestamp using the historical TWAB records.\\n                The balance is linearly interpolated: amount differences / timestamp differences\\n                using the simple (after.amount - before.amount / end.timestamp - start.timestamp) formula.\\n    /** @dev    Binary search in _calculateTwab fails when searching out of bounds. Thus, before\\n                searching we exclude target timestamps out of range of newest/oldest TWAB(s).\\n                IF a search is before or after the range we \\\"extrapolate\\\" a Observation from the expected state.\\n      * @param _twabs           Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails  User AccountDetails struct loaded in memory\\n      * @param _newestTwab      Newest TWAB in history (end of ring buffer)\\n      * @param _oldestTwab      Olderst TWAB in history (end of ring buffer)\\n      * @param _newestTwabIndex Pointer in ring buffer to newest TWAB\\n      * @param _oldestTwabIndex Pointer in ring buffer to oldest TWAB\\n      * @param _targetTimestamp Epoch timestamp to calculate for time (T) in the TWAB\\n      * @param _time            Block.timestamp\\n      * @return accountDetails Updated Account.details struct\\n    */\\n    function _calculateTwab(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        ObservationLib.Observation memory _newestTwab,\\n        ObservationLib.Observation memory _oldestTwab,\\n        uint24 _newestTwabIndex,\\n        uint24 _oldestTwabIndex,\\n        uint32 _targetTimestamp,\\n        uint32 _time\\n    ) private view returns (ObservationLib.Observation memory) {\\n        // If `_targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one\\n        if (_newestTwab.timestamp.lt(_targetTimestamp, _time)) {\\n            return _computeNextTwab(_newestTwab, _accountDetails.balance, _targetTimestamp);\\n        }\\n\\n        if (_newestTwab.timestamp == _targetTimestamp) {\\n            return _newestTwab;\\n        }\\n\\n        if (_oldestTwab.timestamp == _targetTimestamp) {\\n            return _oldestTwab;\\n        }\\n\\n        // If `_targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab\\n        if (_targetTimestamp.lt(_oldestTwab.timestamp, _time)) {\\n            return ObservationLib.Observation({ amount: 0, timestamp: _targetTimestamp });\\n        }\\n\\n        // Otherwise, both timestamps must be surrounded by twabs.\\n        (\\n            ObservationLib.Observation memory beforeOrAtStart,\\n            ObservationLib.Observation memory afterOrAtStart\\n        ) = ObservationLib.binarySearch(\\n                _twabs,\\n                _newestTwabIndex,\\n                _oldestTwabIndex,\\n                _targetTimestamp,\\n                _accountDetails.cardinality,\\n                _time\\n            );\\n\\n        uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) /\\n            OverflowSafeComparatorLib.checkedSub(afterOrAtStart.timestamp, beforeOrAtStart.timestamp, _time);\\n\\n        return _computeNextTwab(beforeOrAtStart, heldBalance, _targetTimestamp);\\n    }\\n\\n    /**\\n     * @notice Calculates the next TWAB using the newestTwab and updated balance.\\n     * @dev    Storage of the TWAB obersation is managed by the calling function and not _computeNextTwab.\\n     * @param _currentTwab    Newest Observation in the Account.twabs list\\n     * @param _currentBalance User balance at time of most recent (newest) checkpoint write\\n     * @param _time           Current block.timestamp\\n     * @return TWAB Observation\\n     */\\n    function _computeNextTwab(\\n        ObservationLib.Observation memory _currentTwab,\\n        uint224 _currentBalance,\\n        uint32 _time\\n    ) private pure returns (ObservationLib.Observation memory) {\\n        // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)\\n        return\\n            ObservationLib.Observation({\\n                amount: _currentTwab.amount + _currentBalance * (_time.checkedSub(_currentTwab.timestamp, _time)),\\n                timestamp: _time\\n            });\\n    }\\n\\n    /// @notice Sets a new TWAB Observation at the next available index and returns the new account details.\\n    /// @dev Note that if _currentTime is before the last observation timestamp, it appears as an overflow\\n    /// @param _twabs The twabs array to insert into\\n    /// @param _accountDetails The current account details\\n    /// @param _currentTime The current time\\n    /// @return accountDetails The new account details\\n    /// @return twab The newest twab (may or may not be brand-new)\\n    /// @return isNew Whether the newest twab was created by this call\\n    function _nextTwab(\\n        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n        AccountDetails memory _accountDetails,\\n        uint32 _currentTime\\n    ) private returns (AccountDetails memory accountDetails, ObservationLib.Observation memory twab, bool isNew) {\\n        (, ObservationLib.Observation memory _newestTwab) = newestTwab(_twabs, _accountDetails);\\n\\n        // if we're in the same block, return\\n        if (_newestTwab.timestamp == _currentTime) {\\n            return (_accountDetails, _newestTwab, false);\\n        }\\n\\n        ObservationLib.Observation memory newTwab = _computeNextTwab(\\n            _newestTwab,\\n            _accountDetails.balance,\\n            _currentTime\\n        );\\n\\n        _twabs[_accountDetails.nextTwabIndex] = newTwab;\\n\\n        AccountDetails memory nextAccountDetails = push(_accountDetails);\\n\\n        return (nextAccountDetails, newTwab, true);\\n    }\\n\\n    /// @notice \\\"Pushes\\\" a new element on the AccountDetails ring buffer, and returns the new AccountDetails\\n    /// @param _accountDetails The account details from which to pull the cardinality and next index\\n    /// @return The new AccountDetails\\n    function push(AccountDetails memory _accountDetails) internal pure returns (AccountDetails memory) {\\n        _accountDetails.nextTwabIndex = uint24(RingBufferLib.nextIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));\\n\\n        // Prevent the Account specific cardinality from exceeding the MAX_CARDINALITY.\\n        // The ring buffer length is limited by MAX_CARDINALITY. IF the account.cardinality\\n        // exceeds the max cardinality, new observations would be incorrectly set or the\\n        // observation would be out of \\\"bounds\\\" of the ring buffer. Once reached the\\n        // AccountDetails.cardinality will continue to be equal to max cardinality.\\n        if (_accountDetails.cardinality < MAX_CARDINALITY) {\\n            _accountDetails.cardinality += 1;\\n        }\\n\\n        return _accountDetails;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IOracle\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all custom oracles should implement.\\n */\\ninterface IOracle {\\n    /**\\n     * @notice Returns the latest answer.\\n     * @return _answer The latest answer.\\n     */\\n    function latestAnswer() external view returns (int256 _answer);\\n\\n    /**\\n     * @notice Returns the data from the latest round.\\n     * @return _roundId The round ID.\\n     * @return _answer The answer from the latest round.\\n     * @return _startedAt Timestamp of when the round started.\\n     * @return _updatedAt Timestamp of when the round was updated.\\n     * @return _answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed.\\n     */\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 _roundId, int256 _answer, uint256 _startedAt, uint256 _updatedAt, uint80 _answeredInRound);\\n\\n    /**\\n     * @notice Returns the number of decimals in the answer.\\n     * @return The number of decimals in the answer.\\n     */\\n    function decimals() external pure returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IRewardsBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IRewardsBooster\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface of the RewardsBooster contract.\\n */\\ninterface IRewardsBooster {\\n    /**\\n     * @notice Initial parameters structure.\\n     * @param ticket A Ticket contract address.\\n     * @param stEthOracle An oracle for stETH token.\\n     * @param asxOracle An oracle for ASX token that returns price of ASX token in WETH.\\n     * @param nonfungiblePositionManager A NonfungiblePositionManager contract address.\\n     * @param uniswapWrapper A wrapper contract address that helps to interact with Uniswap V3.\\n     * @param weth WETH token address.\\n     * @param asx ASX token address.\\n     * @param maxBoost A maximum possible boost coefficient. Is used when lock (position) is created by a user.\\n     * @param minBoostThreshold A threshold (in %) that all of the user's locks (positions) together must overcome for a\\n     *                          boost to be awarded during a rewards claim on the StakePrizePool contract.\\n     * @param maxBoostThreshold A threshold (in %) that all of the user's locks (positions) together must achieve to get\\n     *                          the maximum boost during a rewards claim on the StakePrizePool contract.\\n     * @param slippageTolerance A slippage tolerance to apply in time of swap of ETH/WETH for ASX.\\n     */\\n    struct InitParams {\\n        address ticket;\\n        address stEthOracle;\\n        address asxOracle;\\n        address nonfungiblePositionManager;\\n        address uniswapWrapper;\\n        address weth;\\n        address asx;\\n        uint16 maxBoost;\\n        uint16 minBoostThreshold;\\n        uint16 maxBoostThreshold;\\n        uint16 slippageTolerance;\\n    }\\n\\n    /**\\n     * @notice Staking pool structure.\\n     * @param isFungible Indicates if pool accepts fungible ERC-20 or non fungible ERC-721 tokens.\\n     * @param stakeToken Token address to stake in the staking pool.\\n     * @param stakeTokenValuer Valuer for the staked token.\\n     * @param liquidityPool Liquidity pool where liquidity is stored.\\n     * @param validator Validator whose main role is to execute different validations in time of stakes and unstakes.\\n     * @param minLockDuration Minimum look duration in the staking pool.\\n     * @param maxLockDuration Maximum look duration in the staking pool.\\n     * @param lockDurationSettingsNumber An amount of settings in the mapping with lock duration settings.\\n     */\\n    struct Pool {\\n        uint256 isFungible;\\n        address stakeToken;\\n        address stakeTokenValuer;\\n        address liquidityPool;\\n        address validator;\\n        uint32 minLockDuration;\\n        uint32 maxLockDuration;\\n        uint8 lockDurationSettingsNumber;\\n    }\\n\\n    /**\\n     * @notice User structure.\\n     * @param initializedLocksNumber Number of locks (positions) created and initialized by user.\\n     */\\n    struct User {\\n        uint8 initializedLocksNumber;\\n    }\\n\\n    /**\\n     * @notice Lock (position) structure.\\n     * @param amountOrId Amount of ERC-20 locked tokens (or ERC-721 NFT locked position ID).\\n     * @param createdAt Timestamp when the lock (position) was created.\\n     * @param updatedAt Timestamp when the lock (position) was updated last ime.\\n     * @param duration Duration of the lock (position).\\n     * @param maxBoost A maximum possible boost coefficient for user. Is set when lock (position) is created by a user.\\n     * @param isInitialized Indicates if the lock (position) is initialized or not.\\n     */\\n    struct Lock {\\n        uint256 amountOrId;\\n        uint32 createdAt;\\n        uint32 updatedAt;\\n        uint32 duration;\\n        uint16 maxBoost;\\n        bool isInitialized;\\n    }\\n\\n    /**\\n     * @notice LockDurationSettings structure.\\n     * @param lowerLockDuration Lower lock duration (in seconds).\\n     * @param upperLockDuration Upper lock duration (in seconds).\\n     * @param additionalBoost An additional boost that will be applied for locks that are in range of above durations.\\n     */\\n    struct LockDurationSettings {\\n        uint32 lowerLockDuration;\\n        uint32 upperLockDuration;\\n        uint16 additionalBoost;\\n    }\\n\\n    /**\\n     * @notice Event emitted when a new lock (position) is created by a user.\\n     * @param _pid Staking pool ID.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid Lock (position) ID.\\n     * @param _lock Lock (position) structure.\\n     */\\n    event LockCreated(uint8 indexed _pid, address indexed _user, uint8 indexed _lid, Lock _lock);\\n\\n    /**\\n     * @notice Event emitted when a lock (position) is closed by a user.\\n     * @param _pid Staking pool ID.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid Lock (position) ID.\\n     */\\n    event LockClosed(uint8 indexed _pid, address indexed _user, uint8 indexed _lid);\\n\\n    /**\\n     * @notice Event emitted when a lock duration was extended.\\n     * @param _pid Staking pool ID where to extend a lock duration for the position.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid An ID of the lock (position) where to extend a lock duration.\\n     * @param _newDuration A new duration (in seconds) for the lock of the position.\\n     */\\n    event LockExtended(uint8 indexed _pid, address indexed _user, uint8 indexed _lid, uint32 _newDuration);\\n\\n    /**\\n     * @notice Event emitted when a new staking pool was added by an owner.\\n     * @param _pid Staking pool ID.\\n     * @param _pool Staking pool structure.\\n     */\\n    event PoolCreated(uint8 indexed _pid, Pool _pool);\\n\\n    /**\\n     * @notice Event emitted when accidentally transferred to this contract token (including ETH) was withdrawn\\n     *         (rescued) by an owner.\\n     * @param token A token that was withdraw. If token address is equal to zero address - ETH was withdrawn.\\n     * @param amountOrId An amount of native/ERC-20 tokens or ID of ERC-721 NFT token that was withdraw.\\n     * @param isFungible Indicates if token that was withdraw is fungible ERC-20 token.\\n     * @param recipient A recipient of withdrawn tokens.\\n     */\\n    event Rescued(address indexed token, uint256 amountOrId, bool indexed isFungible, address indexed recipient);\\n\\n    /**\\n     * @notice Calculates a boost coefficient for the array of users.\\n     * @param _users An array users to calculate boost coefficient for.\\n     * @return An array with boost coefficients for the users.\\n     * @return An array with flags that indicate if a user is able to use this coefficient to multiply his rewards.\\n     */\\n    function getBoostBatch(address[] calldata _users) external view returns (uint32[] memory, bool[] memory);\\n\\n    /**\\n     * @notice Calculates a boost coefficient for a user.\\n     * @param _user A user to calculate boost coefficient for.\\n     * @return A boost coefficient for a user.\\n     * @return A flag that indicates if a user is able to use this coefficient to multiply his rewards.\\n     */\\n    function getBoost(address _user) external view returns (uint32, bool);\\n\\n    /**\\n     * @notice Returns staking pool info by its ID.\\n     * @param _pid Staking pool ID.\\n     * @return Staking pool info.\\n     */\\n    function getPoolInfo(uint8 _pid) external view returns (Pool memory);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IValidator\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all validators should implement.\\n */\\ninterface IValidator {\\n    /**\\n     * @notice Validates if stake parameters are valid.\\n     * @param _pid Staking pool ID.\\n     * @param _amountOrId Amount of ERC-20 LP tokens or ID of ERC-721 NFT token to validate.\\n     */\\n    function validateStake(uint8 _pid, uint256 _amountOrId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IValuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IValuer\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all valuers should implement.\\n */\\ninterface IValuer {\\n    /**\\n     * @notice Returns the value of ERC-20 LP tokens (or ERC-721 NFT position) in USD in the liquidity pool.\\n     * @param _amountOrId An amount of ERC-20 LP tokens (or ERC-721 NFT position ID) to value.\\n     * @return _value The value of ERC-20 LP tokens (or ERC-721 NFT position) in USD.\\n     */\\n    function value(uint256 _amountOrId) external view returns (uint256 _value);\\n\\n    /**\\n     * @notice Returns token amounts inside the position in USD.\\n     * @param _id Id of the Uniswap V3 position.\\n     * @return _value0 The first token amount in USD.\\n     * @return _value1 The second token amount in USD.\\n     */\\n    function getTokenAmountsInUSD(uint256 _id) external view returns (uint256 _value0, uint256 _value1);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 Wrapped ETH (WETH) Interface\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface defines the functions for interacting with the Wrapped ETH (WETH) contract.\\n */\\ninterface IWETH {\\n    /**\\n     * @notice Withdraws WETH and receives ETH.\\n     * @param wethAmount The amount of WETH to burn, represented in wei.\\n     */\\n    function withdraw(uint wethAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/libraries/RewardsBoosterErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 RewardsBoosterErrors library\\n * @author Asymetrix Protocol Inc Team\\n * @notice A library with errors for rewards booster contracts.\\n */\\nlibrary RewardsBoosterErrors {\\n    error WrongLockDurtionSettingsNumber();\\n    error WrongBalancerPoolTokensNumber();\\n    error WrongLockDurtionSettings();\\n    error TooSmallBoostThreshold();\\n    error NoEmptySlotsInThisPool();\\n    error InvalidStakeArguments();\\n    error WrongValidityDuration();\\n    error TooBigBoostThreshold();\\n    error TooMuchLocksCreated();\\n    error StakeTokenWithdraw();\\n    error LockIsNotFinished();\\n    error WrongLockDurtion();\\n    error NotExistingPool();\\n    error NotExistingLock();\\n    error LengthsMismatch();\\n    error NotContract();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error StalePrice();\\n    error WrongTick();\\n    error WrongTokensRatio();\\n    error WrongMaxTokenDominance();\\n    error StubMethod();\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/RewardsBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport { INonfungiblePositionManager } from \\\"../vendor/uniswap-v3/interfaces/INonfungiblePositionManager.sol\\\";\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { RewardsBoosterErrors } from \\\"./libraries/RewardsBoosterErrors.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { IRewardsBooster } from \\\"./interfaces/IRewardsBooster.sol\\\";\\nimport { IValidator } from \\\"./interfaces/IValidator.sol\\\";\\nimport { ITicket } from \\\"../core/interfaces/ITicket.sol\\\";\\nimport { IValuer } from \\\"./interfaces/IValuer.sol\\\";\\nimport { IOracle } from \\\"./interfaces/IOracle.sol\\\";\\nimport { Buyback } from \\\"../vesting/Buyback.sol\\\";\\nimport { IWETH } from \\\"./interfaces/IWETH.sol\\\";\\n\\n/**\\n * @title Asymetrix Protocol V2 RewardsBooster\\n * @author Asymetrix Protocol Inc Team\\n * @notice A contract where users can create locks (positions) to boost their incentivization rewards in the\\n *         StakePrizePool contract. This contract supports Balancer Weighted pools and Uniswap V3 pools.\\n */\\ncontract RewardsBooster is Buyback, IRewardsBooster, IERC721Receiver {\\n    using SafeERC20 for IERC20;\\n\\n    mapping(uint8 => Pool) private pools;\\n    mapping(uint8 => mapping(uint8 => LockDurationSettings)) private lockDurationSettings;\\n    mapping(uint8 => mapping(address => User)) private users;\\n    mapping(uint8 => mapping(address => Lock[])) private locks;\\n    mapping(address => uint256) private stakeTokens;\\n    ITicket private ticket;\\n    IOracle private stEthOracle;\\n    INonfungiblePositionManager private nonfungiblePositionManager;\\n    uint16 private minBoostThreshold;\\n    uint16 private maxBoostThreshold;\\n    uint16 private maxBoost;\\n    uint8 private poolsNumber;\\n\\n    uint8 public constant MAX_LOCKS_NUMBER = 10;\\n\\n    uint256 private constant STAKE_TOKEN = 1;\\n\\n    uint256 private constant NON_FUNGIBLE = 0;\\n    uint256 private constant FUNGIBLE = 1;\\n\\n    /**\\n     * @notice Checks if staking pool exists.\\n     * @param _pid Staking pool ID which to check for existence.\\n     */\\n    modifier onlyExistingPool(uint8 _pid) {\\n        if (_pid >= poolsNumber) revert RewardsBoosterErrors.NotExistingPool();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Checks if lock (position) exists for the user in the specified staking pool.\\n     * @param _pid Staking pool ID where to check lock (position) existence.\\n     * @param _user A user for whom to check lock (position) existence.\\n     * @param _lid An ID of the lock (position) which to check for existence.\\n     */\\n    modifier onlyExistingLock(\\n        uint8 _pid,\\n        address _user,\\n        uint8 _lid\\n    ) {\\n        if (_lid >= uint8(locks[_pid][_user].length) || !locks[_pid][_user][_lid].isInitialized)\\n            revert RewardsBoosterErrors.NotExistingLock();\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initialize the RewardsBooster contract.\\n     * @param _initParams Initial parameters for RewardsBooster deployment.\\n     */\\n    function initialize(InitParams memory _initParams) external initializer {\\n        __Buyback_init(\\n            _initParams.uniswapWrapper,\\n            _initParams.asxOracle,\\n            _initParams.weth,\\n            _initParams.asx,\\n            _initParams.slippageTolerance\\n        );\\n\\n        _setTicket(_initParams.ticket);\\n        _setStEthOracle(_initParams.stEthOracle);\\n        _setNonfungiblePositionManager(_initParams.nonfungiblePositionManager);\\n        _setMaxBoost(_initParams.maxBoost);\\n        _setMaxBoostThreshold(_initParams.maxBoostThreshold);\\n        _setMinBoostThreshold(_initParams.minBoostThreshold);\\n    }\\n\\n    /**\\n     * @notice Allows this contract to receive native token (ETH).\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Accepts deposits (ERC-20 LP or ERC-721 NFT positions) of an authorized pool from users and stakes them in\\n     *         the contract in the specified staking pool to boost rewards of esASX in the StakePrizePoolV2.\\n     * @param _amountOrId An amount of ERC-20 LP tokens (or ERC-721 NFT position ID) to stake.\\n     * @param _lockDuration A duration (in seconds) for the lock of the position.\\n     */\\n    function stake(uint8 _pid, uint256 _amountOrId, uint32 _lockDuration) external onlyExistingPool(_pid) {\\n        Pool memory _pool = pools[_pid];\\n\\n        IValidator(_pool.validator).validateStake(_pid, _amountOrId);\\n\\n        if (_lockDuration < _pool.minLockDuration || _lockDuration > _pool.maxLockDuration)\\n            revert RewardsBoosterErrors.WrongLockDurtion();\\n\\n        uint8 _lid;\\n        Lock memory _lock;\\n\\n        if (users[_pid][msg.sender].initializedLocksNumber == MAX_LOCKS_NUMBER)\\n            revert RewardsBoosterErrors.NoEmptySlotsInThisPool();\\n\\n        uint8 _locksLength = uint8(locks[_pid][msg.sender].length);\\n\\n        if (_locksLength < MAX_LOCKS_NUMBER) {\\n            _lid = _locksLength;\\n            _lock = _pushLock(_pid, _lid, _amountOrId, _lockDuration, true);\\n        } else {\\n            for (; _lid < MAX_LOCKS_NUMBER; ++_lid) {\\n                if (!locks[_pid][msg.sender][_lid].isInitialized) {\\n                    _lock = _pushLock(_pid, _lid, _amountOrId, _lockDuration, false);\\n\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (_pool.isFungible == FUNGIBLE) {\\n            IERC20(_pool.stakeToken).safeTransferFrom(msg.sender, address(this), _amountOrId);\\n        } else {\\n            IERC721(_pool.stakeToken).safeTransferFrom(msg.sender, address(this), _amountOrId);\\n        }\\n\\n        emit LockCreated(_pid, msg.sender, _lid, _lock);\\n    }\\n\\n    /**\\n     * @notice Unstakes users' deposits (ERC-20 LP or ERC-721 NFT positions) from the specified staking pool and returns\\n     *         them to users. Additionally, collects fees from Uniswap V3 ASX/WETH locks (psotions), unwraps WETH, swaps\\n     *         ETH for ASX, and burns all ASX.\\n     * @param _pid Staking pool ID where to unstake.\\n     * @param _lid An ID of the lock (position) which to unstake.\\n     */\\n    function unstake(uint8 _pid, uint8 _lid) external onlyExistingPool(_pid) onlyExistingLock(_pid, msg.sender, _lid) {\\n        Lock memory _lock = locks[_pid][msg.sender][_lid];\\n\\n        if (!_isFinishedLock(_lock)) revert RewardsBoosterErrors.LockIsNotFinished();\\n\\n        Pool memory _pool = pools[_pid];\\n\\n        if (_pool.stakeToken == address(nonfungiblePositionManager)) {\\n            uint256[] memory _ids = new uint256[](1);\\n\\n            _ids[0] = _lock.amountOrId;\\n\\n            buybackAndBurnAsx(_ids);\\n        }\\n\\n        delete locks[_pid][msg.sender][_lid];\\n\\n        --users[_pid][msg.sender].initializedLocksNumber;\\n\\n        if (_pool.isFungible == FUNGIBLE) {\\n            IERC20(_pool.stakeToken).safeTransfer(msg.sender, _lock.amountOrId);\\n        } else {\\n            IERC721(_pool.stakeToken).safeTransferFrom(address(this), msg.sender, _lock.amountOrId);\\n        }\\n\\n        emit LockClosed(_pid, msg.sender, _lid);\\n    }\\n\\n    /**\\n     * @notice Extends a lock duration for the position where the lock was already finished. Only the lock (position)\\n     *         creator can extend its lock duration. Additionally, collects fees from Uniswap V3 ASX/WETH locks\\n     *         (psotions), unwraps WETH, swaps ETH for ASX, and burns all ASX.\\n     * @param _pid Staking pool ID where to extend a lock duration for the position.\\n     * @param _lid An ID of the lock (position) where to extend a lock duration.\\n     * @param _newLockDuration A new duration (in seconds) for the lock of the position.\\n     */\\n    function extendLock(\\n        uint8 _pid,\\n        uint8 _lid,\\n        uint32 _newLockDuration\\n    ) external onlyExistingPool(_pid) onlyExistingLock(_pid, msg.sender, _lid) {\\n        Pool memory _pool = pools[_pid];\\n\\n        if (_newLockDuration < _pool.minLockDuration || _newLockDuration > _pool.maxLockDuration)\\n            revert RewardsBoosterErrors.WrongLockDurtion();\\n\\n        Lock memory _lock = locks[_pid][msg.sender][_lid];\\n\\n        if (!_isFinishedLock(_lock)) revert RewardsBoosterErrors.LockIsNotFinished();\\n\\n        if (pools[_pid].stakeToken == address(nonfungiblePositionManager)) {\\n            uint256[] memory _ids = new uint256[](1);\\n\\n            _ids[0] = _lock.amountOrId;\\n\\n            buybackAndBurnAsx(_ids);\\n        }\\n\\n        locks[_pid][msg.sender][_lid].duration = _newLockDuration;\\n        locks[_pid][msg.sender][_lid].updatedAt = uint32(block.timestamp);\\n\\n        emit LockExtended(_pid, msg.sender, _lid, _newLockDuration);\\n    }\\n\\n    /**\\n     * @notice Creates a new staking pool by an owner.\\n     * @param _stakeToken Token address to stake in the staking pool.\\n     * @param _stakeTokenValuer Valuer for the staked token.\\n     * @param _liquidityPool Liquidity pool where liquidity is stored.\\n     * @param _validator Validator whose main role is to execute different validations in time of stakes and unstakes.\\n     * @param _isFungible Indicates if staking pool accepts fungible ERC-20 or non fungible ERC-721 tokens.\\n     * @param _lockDurationSettings An array with LockDurationSettings structures which will be applied additionally to\\n     *                              users' lock durations coefficients.\\n     * @return Newly created staking pool ID.\\n     */\\n    function createPool(\\n        address _stakeToken,\\n        address _stakeTokenValuer,\\n        address _liquidityPool,\\n        address _validator,\\n        bool _isFungible,\\n        LockDurationSettings[] memory _lockDurationSettings\\n    ) external onlyOwner returns (uint256) {\\n        _onlyContract(_stakeToken);\\n        _onlyContract(_stakeTokenValuer);\\n        _onlyContract(_liquidityPool);\\n        _onlyContract(_validator);\\n\\n        uint8 _pid = poolsNumber;\\n\\n        pools[_pid] = Pool({\\n            isFungible: _isFungible ? FUNGIBLE : NON_FUNGIBLE,\\n            stakeToken: _stakeToken,\\n            stakeTokenValuer: _stakeTokenValuer,\\n            liquidityPool: _liquidityPool,\\n            validator: _validator,\\n            minLockDuration: 0,\\n            maxLockDuration: 0,\\n            lockDurationSettingsNumber: 0\\n        });\\n\\n        _setLockDurationSettings(_pid, _lockDurationSettings);\\n\\n        stakeTokens[_stakeToken] = STAKE_TOKEN;\\n        ++poolsNumber;\\n\\n        emit PoolCreated(_pid, pools[_pid]);\\n\\n        return _pid;\\n    }\\n\\n    /**\\n     * @notice Sets a new Ticket contract by an owner.\\n     * @param _newTicket A new Ticket contract address.\\n     */\\n    function setTicket(address _newTicket) external onlyOwner {\\n        _setTicket(_newTicket);\\n    }\\n\\n    /**\\n     * @notice Sets a new oracle for stETH token by an owner.\\n     * @param _newStEthOracle A new oracle for stETH token.\\n     */\\n    function setStEthOracle(address _newStEthOracle) external onlyOwner {\\n        _setStEthOracle(_newStEthOracle);\\n    }\\n\\n    /**\\n     * @notice Sets a new NonfungiblePositionManager contract by an owner.\\n     * @param _newNonfungiblePositionManager A new NonfungiblePositionManager contract address.\\n     */\\n    function setNonfungiblePositionManager(address _newNonfungiblePositionManager) external onlyOwner {\\n        _setNonfungiblePositionManager(_newNonfungiblePositionManager);\\n    }\\n\\n    /**\\n     * @notice Sets a new minimum boost threshold by an owner.\\n     * @param _newMinBoostThreshold A threshold (in %) that all of the user's locks (positions) together must overcome\\n     *                              for a boost to be awarded during a rewards claim on the StakePrizePool contract.\\n     */\\n    function setMinBoostThreshold(uint16 _newMinBoostThreshold) external onlyOwner {\\n        _setMinBoostThreshold(_newMinBoostThreshold);\\n    }\\n\\n    /**\\n     * @notice Sets a new maximum boost threshold by an owner.\\n     * @param _newMaxBoostThreshold A threshold (in %) that all of the user's locks (positions) together must achieve to\\n     *                              get the maximum boost during a rewards claim on the StakePrizePool contract.\\n     */\\n    function setMaxBoostThreshold(uint16 _newMaxBoostThreshold) external onlyOwner {\\n        _setMaxBoostThreshold(_newMaxBoostThreshold);\\n    }\\n\\n    /**\\n     * @notice Sets a new maximum possible boost coefficient by an owner.\\n     * @param _newMaxBoost A new maximum possible boost coefficient that is used when lock (position) is created by a\\n     *                     user.\\n     */\\n    function setMaxBoost(uint16 _newMaxBoost) external onlyOwner {\\n        _setMaxBoost(_newMaxBoost);\\n    }\\n\\n    /**\\n     * @notice Sets a new valuer for the stake token in the specified staking pool.\\n     * @param _pid Staking pool ID where to set new stake token valuer.\\n     * @param _newStakeTokenValuer A new valuer for the stake token in the staking pool.\\n     */\\n    function setStakeTokenValuer(uint8 _pid, address _newStakeTokenValuer) external onlyOwner onlyExistingPool(_pid) {\\n        _onlyContract(_newStakeTokenValuer);\\n\\n        pools[_pid].stakeTokenValuer = _newStakeTokenValuer;\\n    }\\n\\n    /**\\n     * @notice Sets a new validator in the specified staking pool by an owner.\\n     * @param _pid Staking pool ID where to set new validator.\\n     * @param _newValidator A new validator whose main role is to execute different validations in time of stakes and\\n     *                      unstakes.\\n     */\\n    function setValidator(uint8 _pid, address _newValidator) external onlyOwner onlyExistingPool(_pid) {\\n        _onlyContract(_newValidator);\\n\\n        pools[_pid].validator = _newValidator;\\n    }\\n\\n    /**\\n     * @notice Sets a new array with LockDurationSettings structures by an owner.\\n     * @param _pid Staking pool ID where to set new lock duration settings.\\n     * @param _lockDurationSettings An array with LockDurationSettings structures which will be applied additionally to\\n     *                              users' lock durations coefficients.\\n     */\\n    function setLockDurationSettings(\\n        uint8 _pid,\\n        LockDurationSettings[] memory _lockDurationSettings\\n    ) external onlyOwner onlyExistingPool(_pid) {\\n        _setLockDurationSettings(_pid, _lockDurationSettings);\\n    }\\n\\n    /**\\n     * @notice Rescues accidentally transferred to this contract tokens. Callable only by an owner.\\n     * @param _token A token address to withdraw. If equals to zero address - withdraws ETH.\\n     * @param _amountOrId An amount of native/ERC-20 tokens or ID of ERC-721 NFT token to withdraw.\\n     * @param _isFungible Indicates if token to withdraw is fungible ERC-20 token.\\n     * @param _recipient A recipient of withdrawn tokens.\\n     */\\n    function rescue(address _token, uint256 _amountOrId, bool _isFungible, address _recipient) external onlyOwner {\\n        if (_amountOrId == 0) revert RewardsBoosterErrors.ZeroAmount();\\n        if (_recipient == address(0)) revert RewardsBoosterErrors.ZeroAddress();\\n\\n        if (_token == address(0)) {\\n            payable(_recipient).transfer(_amountOrId);\\n        } else if (stakeTokens[_token] != STAKE_TOKEN) {\\n            if (_isFungible) {\\n                IERC20(_token).safeTransfer(_recipient, _amountOrId);\\n            } else {\\n                IERC721(_token).safeTransferFrom(address(this), _recipient, _amountOrId, \\\"\\\");\\n            }\\n        } else {\\n            revert RewardsBoosterErrors.StakeTokenWithdraw();\\n        }\\n\\n        emit Rescued(_token, _amountOrId, _isFungible, _recipient);\\n    }\\n\\n    /**\\n     * @notice Collects fees from Uniswap V3 ASX/WETH pool, unwraps WETH, swaps ETH for ASX, and burns all ASX. Callable\\n     *         only by the owner.\\n     * @param _ids An array of Uniswap V3 positions (NFTs) IDs from which to collect fees.\\n     */\\n    function buybackAndBurnAsx(uint256[] memory _ids) public {\\n        uint8 _length = uint8(_ids.length);\\n        uint256 _totalWethAmount;\\n        uint256 _totalAsxAmount;\\n\\n        for (uint8 _i; _i < _length; ++_i) {\\n            (uint256 _wethAmount, uint256 _asxAmount) = _collectUniswapV3Fees(_ids[_i]);\\n\\n            _totalWethAmount += _wethAmount;\\n            _totalAsxAmount += _asxAmount;\\n        }\\n\\n        IWETH(weth).withdraw(_totalWethAmount);\\n        _buybackAndBurn(address(this).balance, _totalAsxAmount);\\n    }\\n\\n    /// @inheritdoc IRewardsBooster\\n    function getBoostBatch(\\n        address[] calldata _users\\n    ) external view returns (uint32[] memory _coefficients, bool[] memory _eligibility) {\\n        _coefficients = new uint32[](_users.length);\\n        _eligibility = new bool[](_users.length);\\n\\n        for (uint i; i < _users.length; ++i) {\\n            (uint32 _coefficient, bool _isEligible) = getBoost(_users[i]);\\n\\n            _coefficients[i] = _coefficient;\\n            _eligibility[i] = _isEligible;\\n        }\\n\\n        return (_coefficients, _eligibility);\\n    }\\n\\n    /// @inheritdoc IRewardsBooster\\n    function getBoost(address _user) public view returns (uint32, bool) {\\n        uint8 _poolsNumber = poolsNumber;\\n        (uint256 _lockedLiquidityTotalValue, uint256[][] memory _lockedLiquidityValues) = _getLockedLiqudityValue(\\n            _user,\\n            _poolsNumber\\n        );\\n        uint256 _lockedStEthValue = _getLockedStEthValue(_user);\\n\\n        if (_lockedLiquidityTotalValue == 0 || _lockedStEthValue == 0) return (100, false);\\n\\n        uint32 _lockedLiquidityRatio = uint32((_lockedLiquidityTotalValue * ONE_HUNDRED_PERCENTS) / _lockedStEthValue);\\n        (uint32 _lockedLiquidityBoost, uint32 _lockDurationBoost) = _getBoost(\\n            _user,\\n            _lockedLiquidityRatio,\\n            _poolsNumber,\\n            _lockedLiquidityTotalValue,\\n            _lockedLiquidityValues\\n        );\\n\\n        if (_lockedLiquidityRatio >= minBoostThreshold) {\\n            // \u0421an use boost\\n            return (_lockedLiquidityBoost + _lockDurationBoost, true);\\n        } else {\\n            // \u0421an't use boost\\n            return (_lockDurationBoost, false);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the value (in USD) of each locked and active position of a user + the total value of all\\n     *         user's locked positions.\\n     * @param _user A user to calculate locked positions value (in USD) for.\\n     * @return _lockedLiquidityTotalValue A total value (in USD) of all user's locked and active positions.\\n     * @return _lockedLiquidityValues An array of values (in USD) for the user's staking pools and locked and active\\n     *                                positions in them.\\n     */\\n    function getLockedLiqudityValue(\\n        address _user\\n    ) external view returns (uint256 _lockedLiquidityTotalValue, uint256[][] memory _lockedLiquidityValues) {\\n        return _getLockedLiqudityValue(_user, poolsNumber);\\n    }\\n\\n    /// @inheritdoc IRewardsBooster\\n    function getPoolInfo(uint8 _pid) external view returns (Pool memory) {\\n        return pools[_pid];\\n    }\\n\\n    /**\\n     * @notice Returns all lock duration settings in the staking pool.\\n     * @param _pid Staking pool ID.\\n     * @return All lock duration settings in the staking pool.\\n     */\\n    function getLockDurationSettings(uint8 _pid) external view returns (LockDurationSettings[] memory) {\\n        uint8 _lockDurationSettingsNumber = pools[_pid].lockDurationSettingsNumber;\\n        LockDurationSettings[] memory _lockDurationSettings = new LockDurationSettings[](_lockDurationSettingsNumber);\\n\\n        for (uint8 _i; _i < _lockDurationSettingsNumber; ++_i) {\\n            _lockDurationSettings[_i] = lockDurationSettings[_pid][_i];\\n        }\\n\\n        return _lockDurationSettings;\\n    }\\n\\n    /**\\n     * @notice Returns lock duration settings in the staking pool by their IDs.\\n     * @param _pid Staking pool ID.\\n     * @param _ldsid Lock duration settings ID.\\n     * @return Lock duration settings.\\n     */\\n    function getLockDurationSettings(uint8 _pid, uint8 _ldsid) external view returns (LockDurationSettings memory) {\\n        return lockDurationSettings[_pid][_ldsid];\\n    }\\n\\n    /**\\n     * @notice Returns user info by staking pool ID and user's address.\\n     * @param _pid Staking pool ID.\\n     * @param _user User address to fetch info about.\\n     * @return User info.\\n     */\\n    function getUserInfo(uint8 _pid, address _user) external view returns (User memory) {\\n        return users[_pid][_user];\\n    }\\n\\n    /**\\n     * @notice Returns lock (position) info by staking pool ID, user's address, and lock's (position's) ID.\\n     * @param _pid Staking pool ID.\\n     * @param _user User address to fetch lock (position) info about.\\n     * @param _lid Lock (position) ID.\\n     * @return Lock (position) info.\\n     */\\n    function getLockInfo(\\n        uint8 _pid,\\n        address _user,\\n        uint8 _lid\\n    ) external view onlyExistingPool(_pid) onlyExistingLock(_pid, _user, _lid) returns (Lock memory) {\\n        return locks[_pid][_user][_lid];\\n    }\\n\\n    /**\\n     * @notice Returns info about all initialized locks (positions) by staking pool ID and user's address.\\n     * @param _pid Staking pool ID.\\n     * @param _user User address to fetch info about all initialized locks (positions).\\n     * @return _locks Info about all initialized locks (positions) by staking pool ID and user's address.\\n     * @return _lids corresponding ids of the lock\\n     */\\n    function getInitializedLocksInfo(\\n        uint8 _pid,\\n        address _user\\n    ) external view returns (Lock[] memory _locks, uint8[] memory _lids) {\\n        uint8 _locksLength = uint8(locks[_pid][_user].length);\\n        uint8 _j;\\n\\n        uint8 _initializedLocksNumber = users[_pid][_user].initializedLocksNumber;\\n\\n        _locks = new Lock[](_initializedLocksNumber);\\n        _lids = new uint8[](_initializedLocksNumber);\\n\\n        for (uint8 _lid; _lid < _locksLength; ++_lid) {\\n            if (locks[_pid][_user][_lid].isInitialized) {\\n                _lids[_j] = _lid;\\n                _locks[_j] = locks[_pid][_user][_lid];\\n                _j++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns an indicator that token can be staked in one of the staking pools.\\n     * @param _token An address of the token to check.\\n     * @return An indicator that token can be staked in one of the staking pools.\\n     */\\n    function isStakeToken(address _token) external view returns (bool) {\\n        return stakeTokens[_token] == STAKE_TOKEN;\\n    }\\n\\n    /**\\n     * @notice Returns Ticket contract address.\\n     * @return Ticket contract address.\\n     */\\n    function getTicket() external view returns (ITicket) {\\n        return ticket;\\n    }\\n\\n    /**\\n     * @notice Returns stETH oracle address.\\n     * @return stETH oracle address.\\n     */\\n    function getStEthOracle() external view returns (IOracle) {\\n        return stEthOracle;\\n    }\\n\\n    /**\\n     * @notice Returns NonfungiblePositionManager contract address.\\n     * @return NonfungiblePositionManager contract address.\\n     */\\n    function getNonfungiblePositionManager() external view returns (INonfungiblePositionManager) {\\n        return nonfungiblePositionManager;\\n    }\\n\\n    /**\\n     * @notice Returns minumum boost threshold percentage.\\n     * @return Minimum boost threshold percentage.\\n     */\\n    function getMinBoostThreshold() external view returns (uint16) {\\n        return minBoostThreshold;\\n    }\\n\\n    /**\\n     * @notice Returns maximum boost threshold percentage.\\n     * @return Maximum boost threshold percentage.\\n     */\\n    function getMaxBoostThreshold() external view returns (uint16) {\\n        return maxBoostThreshold;\\n    }\\n\\n    /**\\n     * @notice Returns staking pools number.\\n     * @return Staking pools number.\\n     */\\n    function getPoolsNumber() external view returns (uint8) {\\n        return poolsNumber;\\n    }\\n\\n    /**\\n     * @notice Returns current max boost coefficient.\\n     * @return Current max boost coefficient.\\n     */\\n    function getMaxBoost() external view returns (uint16) {\\n        return maxBoost;\\n    }\\n\\n    /// @inheritdoc IERC721Receiver\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @notice Sets a new array with LockDurationSettings structures for the staking pool.\\n     * @param _pid Staking pool ID.\\n     * @param _lds An array with LockDurationSettings structures which will be applied additionally to users' lock\\n     *             durations coefficients.\\n     */\\n    function _setLockDurationSettings(uint8 _pid, LockDurationSettings[] memory _lds) internal {\\n        uint8 _lockDurationSettingsNumber = pools[_pid].lockDurationSettingsNumber;\\n\\n        for (uint8 _i; _i < _lockDurationSettingsNumber; ++_i) {\\n            delete lockDurationSettings[_pid][_i];\\n        }\\n\\n        uint8 _newLockDurationSettingsNumber = uint8(_lds.length);\\n\\n        if (_newLockDurationSettingsNumber == 0) revert RewardsBoosterErrors.WrongLockDurtionSettingsNumber();\\n\\n        for (uint8 _i; _i < _newLockDurationSettingsNumber; ++_i) {\\n            if (_lds[_i].lowerLockDuration > _lds[_i].upperLockDuration)\\n                revert RewardsBoosterErrors.WrongLockDurtionSettings();\\n\\n            if (_i > 0 && _lds[_i - 1].upperLockDuration != _lds[_i].lowerLockDuration - 1)\\n                revert RewardsBoosterErrors.WrongLockDurtionSettings();\\n\\n            if (_i > 0 && _lds[_i - 1].additionalBoost >= _lds[_i].additionalBoost)\\n                revert RewardsBoosterErrors.WrongLockDurtionSettings();\\n\\n            lockDurationSettings[_pid][_i] = _lds[_i];\\n        }\\n\\n        pools[_pid].lockDurationSettingsNumber = _newLockDurationSettingsNumber;\\n        pools[_pid].minLockDuration = _lds[0].lowerLockDuration;\\n        pools[_pid].maxLockDuration = _lds[_newLockDurationSettingsNumber - 1].upperLockDuration;\\n    }\\n\\n    /**\\n     * @notice Pushes a lock (position) at the end of the array with locks (positions) or just inserts using _lid.\\n     * @param _pid Staking pool ID where to stake.\\n     * @param _lid An ID of the lock (position) where to stake.\\n     * @param _amountOrId An amount of ERC-20 LP tokens (or ERC-721 NFT position ID) to stake.\\n     * @param _lockDuration A duration (in seconds) for the lock of the position.\\n     * @param _push A flag that indicates if a lock (position) should be pushed at the end of the array with locks\\n     *              (positions) or just inserted using _lid.\\n     */\\n    function _pushLock(\\n        uint8 _pid,\\n        uint8 _lid,\\n        uint256 _amountOrId,\\n        uint32 _lockDuration,\\n        bool _push\\n    ) internal returns (Lock memory) {\\n        Lock memory _lock = Lock({\\n            amountOrId: _amountOrId,\\n            createdAt: uint32(block.timestamp),\\n            updatedAt: uint32(block.timestamp),\\n            duration: _lockDuration,\\n            maxBoost: maxBoost,\\n            isInitialized: true\\n        });\\n\\n        if (_push) {\\n            locks[_pid][msg.sender].push(_lock);\\n        } else {\\n            locks[_pid][msg.sender][_lid] = _lock;\\n        }\\n\\n        users[_pid][msg.sender].initializedLocksNumber += 1;\\n\\n        return _lock;\\n    }\\n\\n    /**\\n     * @notice Collects fees from Uniswap V3 ASX/WETH pool.\\n     * @param _id An ID of Uniswap V3 position (ERC-721 NFT) from which to collect fees.\\n     * @return _wethAmount An amount of collected WETH tokens.\\n     * @return _asxAmount An amount of collected ASX tokens.\\n     */\\n    function _collectUniswapV3Fees(uint256 _id) internal returns (uint256 _wethAmount, uint256 _asxAmount) {\\n        INonfungiblePositionManager.CollectParams memory _collectParams = INonfungiblePositionManager.CollectParams({\\n            tokenId: _id,\\n            recipient: address(this),\\n            amount0Max: type(uint128).max,\\n            amount1Max: type(uint128).max\\n        });\\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\\n        (_asxAmount, _wethAmount) = _nonfungiblePositionManager.collect(_collectParams);\\n    }\\n\\n    /**\\n     * @notice Returns whether the lock (position) is finished or not.\\n     * @param _lock A lock (position) to check whether it is finished or not.\\n     * @return Flag whether the lock (position) is finished or not.\\n     */\\n    function _isFinishedLock(Lock memory _lock) internal view returns (bool) {\\n        return uint32(block.timestamp) >= _lock.updatedAt + _lock.duration;\\n    }\\n\\n    /**\\n     * @notice Calculates the value (in USD) of each locked and active position of a user + the total value of all\\n     *         user's locked positions.\\n     * @param _user A user to calculate locked positions value (in USD) for.\\n     * @param _poolsNumber A number of staking pools.\\n     * @return _lockedLiquidityTotalValue A total value (in USD) of all user's locked and active positions.\\n     * @return _lockedLiquidityValues An array of values (in USD) for the user's staking pools and locked and active\\n     *                                positions in them.\\n     */\\n    function _getLockedLiqudityValue(\\n        address _user,\\n        uint8 _poolsNumber\\n    ) internal view returns (uint256 _lockedLiquidityTotalValue, uint256[][] memory _lockedLiquidityValues) {\\n        _lockedLiquidityValues = new uint256[][](_poolsNumber);\\n\\n        for (uint8 _pid; _pid < _poolsNumber; ++_pid) {\\n            uint8 _locksNumber = uint8(Math.min(MAX_LOCKS_NUMBER, uint8(locks[_pid][_user].length)));\\n            Pool memory _pool = pools[_pid];\\n\\n            _lockedLiquidityValues[_pid] = new uint256[](_locksNumber);\\n\\n            for (uint8 _lid; _lid < _locksNumber; ++_lid) {\\n                Lock memory _lock = locks[_pid][_user][_lid];\\n\\n                if (!_isFinishedLock(_lock)) {\\n                    uint256 _value = IValuer(_pool.stakeTokenValuer).value(_lock.amountOrId);\\n\\n                    _lockedLiquidityTotalValue += _value;\\n                    _lockedLiquidityValues[_pid][_lid] = _value;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the value (in USD) of the user's position (in stETH) in the StakePrizePool contract.\\n     * @param _user A user to calculate stETH position value (in USD) for.\\n     * return _lockedStEthValue A value (in USD) of the user's position (in stETH) in the StakePrizePool contract.\\n     */\\n    function _getLockedStEthValue(address _user) internal view returns (uint256 _lockedStEthValue) {\\n        IOracle _stEthOracle = stEthOracle;\\n        uint256 _stEthPrice = (uint256(_stEthOracle.latestAnswer()) * 1e18) / 10 ** _stEthOracle.decimals();\\n\\n        _lockedStEthValue = (_stEthPrice * ticket.getBalanceAt(_user, uint64(block.timestamp))) / 1e18;\\n    }\\n\\n    /**\\n     * @notice Calculates a boost coefficient for a user.\\n     * @param _user A user to calculate boost coefficient for.\\n     * @param _lockedLiquidityRatio A ratio of user's locked liquidity (in USD) in the booster to locked stETH (in USD)\\n     *                              in the StakePrizePool.\\n     * @param _poolsNumber A number of staking pools.\\n     * @param _lockedLiquidityTotalValue A total value (in USD) of all user's locked positions.\\n     * @param _lockedLiquidityValues An array of values (in USD) for the user's staking pools and locked positions in\\n     *                               them.\\n     * @return _lockedLiquidityBoost The boost for the user's locked liquidity in all positions between all staking\\n     *                               pools.\\n     * @return _lockDurationBoost The boost for the duration of all locks (positions) of the user.\\n     */\\n    function _getBoost(\\n        address _user,\\n        uint32 _lockedLiquidityRatio,\\n        uint8 _poolsNumber,\\n        uint256 _lockedLiquidityTotalValue,\\n        uint256[][] memory _lockedLiquidityValues\\n    ) internal view returns (uint32 _lockedLiquidityBoost, uint32 _lockDurationBoost) {\\n        uint16 _halfMaxBoost = maxBoost >> 1;\\n\\n        if (_lockedLiquidityRatio >= minBoostThreshold) {\\n            _lockedLiquidityBoost += _getLockedLiqudityValueBoostCoefficient(_lockedLiquidityRatio, maxBoostThreshold);\\n\\n            if (_lockedLiquidityBoost > _halfMaxBoost) _lockedLiquidityBoost = _halfMaxBoost;\\n        }\\n\\n        for (uint8 _pid; _pid < _poolsNumber; ++_pid) {\\n            uint8 _locksNumber = uint8(Math.min(MAX_LOCKS_NUMBER, uint8(locks[_pid][_user].length)));\\n            Pool memory _pool = pools[_pid];\\n\\n            for (uint8 _lid; _lid < _locksNumber; ++_lid) {\\n                Lock memory _lock = locks[_pid][_user][_lid];\\n\\n                if (!_isFinishedLock(_lock)) {\\n                    uint256 _percent = Math.ceilDiv(\\n                        (_lockedLiquidityValues[_pid][_lid] * ONE_HUNDRED_PERCENTS),\\n                        _lockedLiquidityTotalValue\\n                    );\\n                    uint32 _lockDurationBoostCoefficient = _getLockDurationBoostCoefficient(_pool, _lock);\\n                    uint32 _additionalLockDurationBoostCoefficient = _getAdditionalLockDurationBoostCoefficient(\\n                        _pid,\\n                        _pool.lockDurationSettingsNumber,\\n                        _lock.duration\\n                    );\\n\\n                    _lockDurationBoost += uint32(\\n                        Math.ceilDiv(\\n                            ((_lockDurationBoostCoefficient * 100) + (_additionalLockDurationBoostCoefficient * 100)) *\\n                                _percent,\\n                            ONE_HUNDRED_PERCENTS\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n\\n        _lockDurationBoost = uint32(_lockDurationBoost / 100);\\n    }\\n\\n    /**\\n     * @notice Calculates additional boost coefficient for lock duration that will be added to previously calculated\\n     *         user's boost coefficient for lock duration.\\n     * @param _pid Staking pool ID.\\n     * @param _lockDurationSettingsNumber An amount of settings in the mapping with lock duration settings.\\n     * @param _lockDuration A duration of user's lock (in seconds).\\n     * @return Additional boost coefficient for lock duration that will be added to previously calculated user's boost\\n     *         coefficient for lock duration.\\n     */\\n    function _getAdditionalLockDurationBoostCoefficient(\\n        uint8 _pid,\\n        uint8 _lockDurationSettingsNumber,\\n        uint32 _lockDuration\\n    ) internal view returns (uint16) {\\n        for (uint8 _i; _i < _lockDurationSettingsNumber; ++_i) {\\n            LockDurationSettings memory _lockDurationSettings = lockDurationSettings[_pid][_i];\\n\\n            if (\\n                _lockDuration >= _lockDurationSettings.lowerLockDuration &&\\n                _lockDuration <= _lockDurationSettings.upperLockDuration\\n            ) {\\n                return _lockDurationSettings.additionalBoost;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Calculates the boost coefficient for the user's locked liquidity value ratio.\\n     * @param _lockedLiquidityRatio A ratio of user's locked liquidity (in USD) in the booster to locked stETH (in USD)\\n     *                              in the StakePrizePool.\\n     * @param _maxBoostThreshold A threshold (in %) that all of the user's locks (positions) together must achieve to\\n     *                           get the maximum boost during a rewards claim on the StakePrizePool contract.\\n     * @return _lockedLiqudityValueBoostCoefficient The boost coefficient for the user's locked liquidity value ratio.\\n     */\\n    function _getLockedLiqudityValueBoostCoefficient(\\n        uint32 _lockedLiquidityRatio,\\n        uint16 _maxBoostThreshold\\n    ) internal view returns (uint16 _lockedLiqudityValueBoostCoefficient) {\\n        _lockedLiqudityValueBoostCoefficient = uint16(\\n            (((uint256(_lockedLiquidityRatio) * 1e18) / _maxBoostThreshold) * (ONE_HUNDRED_PERCENTS >> 1) * maxBoost) /\\n                1e18 /\\n                ONE_HUNDRED_PERCENTS\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculates the boost for the user's lock (position) in the specified staking pool.\\n     * @param _pool A staking pool is used to get the maximum lock (position) duration.\\n     * @param _lock A user's lock (position) for which to calculate the boost.\\n     * @return _lockDurationBoostCoefficient A boost coefficient for the specified lock (position) in the specified\\n     *                                       staking pool.\\n     */\\n    function _getLockDurationBoostCoefficient(\\n        Pool memory _pool,\\n        Lock memory _lock\\n    ) internal view returns (uint16 _lockDurationBoostCoefficient) {\\n        _lockDurationBoostCoefficient = uint16(\\n            Math.ceilDiv(\\n                ((((uint256(_lock.duration) * 1e18) / _pool.maxLockDuration) * (ONE_HUNDRED_PERCENTS >> 1) * maxBoost) /\\n                    1e18),\\n                ONE_HUNDRED_PERCENTS\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets a new Ticket contract.\\n     * @param _newTicket A new Ticket contract address.\\n     */\\n    function _setTicket(address _newTicket) private {\\n        _onlyContract(_newTicket);\\n\\n        ticket = ITicket(_newTicket);\\n    }\\n\\n    /**\\n     * @notice Sets a new oracle for stETH token.\\n     * @param _newStEthOracle A new oracle for stETH token.\\n     */\\n    function _setStEthOracle(address _newStEthOracle) private {\\n        _onlyContract(_newStEthOracle);\\n\\n        stEthOracle = IOracle(_newStEthOracle);\\n    }\\n\\n    /**\\n     * @notice Sets a new NonfungiblePositionManager contract.\\n     * @param _newNonfungiblePositionManager A new NonfungiblePositionManager contract address.\\n     */\\n    function _setNonfungiblePositionManager(address _newNonfungiblePositionManager) private {\\n        _onlyContract(_newNonfungiblePositionManager);\\n\\n        nonfungiblePositionManager = INonfungiblePositionManager(_newNonfungiblePositionManager);\\n    }\\n\\n    /**\\n     * @notice Sets a new minimum boost threshold.\\n     * @param _newMinBoostThreshold A threshold (in %) that all of the user's locks (positions) together must overcome\\n     *                              for a boost to be awarded during a rewards claim on the StakePrizePool contract.\\n     */\\n    function _setMinBoostThreshold(uint16 _newMinBoostThreshold) private {\\n        if (_newMinBoostThreshold > maxBoostThreshold) revert RewardsBoosterErrors.TooBigBoostThreshold();\\n\\n        minBoostThreshold = _newMinBoostThreshold;\\n    }\\n\\n    /**\\n     * @notice Sets a new maximum boost threshold.\\n     * @param _newMaxBoostThreshold A threshold (in %) that all of the user's locks (positions) together must achieve to\\n     *                              get the maximum boost during a rewards claim on the StakePrizePool contract.\\n     */\\n    function _setMaxBoostThreshold(uint16 _newMaxBoostThreshold) private {\\n        if (_newMaxBoostThreshold < minBoostThreshold) revert RewardsBoosterErrors.TooSmallBoostThreshold();\\n        if (_newMaxBoostThreshold > ONE_HUNDRED_PERCENTS) revert RewardsBoosterErrors.TooBigBoostThreshold();\\n\\n        maxBoostThreshold = _newMaxBoostThreshold;\\n    }\\n\\n    /**\\n     * @notice Sets a new maximum possible boost coefficient.\\n     * @param _newMaxBoost A new maximum possible boost coefficient that is used when lock (position) is created by a\\n     *                     user.\\n     */\\n    function _setMaxBoost(uint16 _newMaxBoost) private {\\n        maxBoost = _newMaxBoost;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/uniswap-v3/interfaces/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.5.0;\\n\\n/// @title Non-fungible token for positions\\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\\n/// and authorized.\\ninterface INonfungiblePositionManager {\\n    // details about the uniswap position\\n    struct Position {\\n        // the nonce for permits\\n        uint96 nonce;\\n        // the address that is approved for spending this token\\n        address operator;\\n        // the first token in the pool\\n        address token0;\\n        // the second token in the pool\\n        address token1;\\n        // the pool's fee\\n        uint24 fee;\\n        // the tick range of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // the liquidity of the position\\n        uint128 liquidity;\\n        // the fee growth of the aggregate position as of the last action on the individual position\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // how many uncollected tokens are owed to the position, as of the last computation\\n        uint128 tokensOwed0;\\n        uint128 tokensOwed1;\\n    }\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    /// @notice Returns the position information associated with a given token ID.\\n    /// @dev Throws if the token ID is not valid.\\n    /// @param tokenId The ID of the token that represents the position.\\n    /// @return The position information associated with a given token ID.\\n    function positions(uint256 tokenId) external view returns (Position memory);\\n\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n    /// recipient The account that should receive the tokens,\\n    /// amount0Max The maximum amount of token0 to collect,\\n    /// amount1Max The maximum amount of token1 to collect\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\n}\\n\"\r\n    },\r\n    \"contracts/vesting/Buyback.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { ERC20BurnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { AddressUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { ESASXErrors } from \\\"./libraries/ESASXErrors.sol\\\";\\nimport { UniswapWrapper } from \\\"./UniswapWrapper.sol\\\";\\nimport { IOracle } from \\\"./interfaces/IOracle.sol\\\";\\n\\n/**\\n * @title Asymetrix Protocol V2 abstract Buyback contract\\n * @author Asymetrix Protocol Inc Team\\n * @notice Implements internal method to swap ETH for ASX and burn specified ASX amount + some external owner's methods.\\n */\\nabstract contract Buyback is Initializable, OwnableUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    UniswapWrapper private uniswapWrapper;\\n    IOracle internal asxOracle;\\n    address internal weth;\\n    address internal asx;\\n    uint16 private slippageTolerance;\\n\\n    uint24 public constant UNISWAP_V3_POOL_FEE = 3000; // 0.3000%\\n    uint16 public constant ONE_HUNDRED_PERCENTS = 10000; // 100.00%\\n\\n    /**\\n     * @notice Initialize the Buyback abstract contract.\\n     * @param _uniswapWrapper A wrapper contract address that helps to interact with Uniswap V3.\\n     * @param _asxOracle An oracle for ASX token that returns price of ASX token in ETH.\\n     * @param _weth WETH token address.\\n     * @param _asx ASX token address.\\n     * @param _slippageTolerance A slippage tolerance to apply in time of swap of ETH for ASX.\\n     */\\n    function __Buyback_init(\\n        address _uniswapWrapper,\\n        address _asxOracle,\\n        address _weth,\\n        address _asx,\\n        uint16 _slippageTolerance\\n    ) internal onlyInitializing {\\n        __Ownable_init();\\n\\n        _setUniswapWrapper(_uniswapWrapper);\\n        _setAsxOracle(_asxOracle);\\n        _onlyContract(_weth);\\n        _onlyContract(_asx);\\n\\n        weth = _weth;\\n        asx = _asx;\\n\\n        _setSlippageTolerance(_slippageTolerance);\\n    }\\n\\n    /**\\n     * @notice Sets a new UniswapWrapper contract by an owner.\\n     * @param _newUniswapWrapper A new UniswapWrapper contract address.\\n     */\\n    function setUniswapWrapper(address _newUniswapWrapper) external onlyOwner {\\n        _setUniswapWrapper(_newUniswapWrapper);\\n    }\\n\\n    /**\\n     * @notice Sets a new oracle for ASX token that returns price of ASX token in ETH by an owner.\\n     * @param _newAsxOracle A new oracle for ASX token that returns price of ASX token in ETH.\\n     */\\n    function setAsxOracle(address _newAsxOracle) external onlyOwner {\\n        _setAsxOracle(_newAsxOracle);\\n    }\\n\\n    /**\\n     * @notice Sets a new slippage tolerance by an owner.\\n     * @param _newSlippageTolerance A new slippage tolerance.\\n     */\\n    function setSlippageTolerance(uint16 _newSlippageTolerance) external onlyOwner {\\n        _setSlippageTolerance(_newSlippageTolerance);\\n    }\\n\\n    /**\\n     * @notice Returns UniswapWrapper contract address.\\n     * @return UniswapWrapper contract address.\\n     */\\n    function getUniswapWrapper() external view returns (UniswapWrapper) {\\n        return uniswapWrapper;\\n    }\\n\\n    /**\\n     * @notice Returns ASX oracle address.\\n     * @return ASX oracle address.\\n     */\\n    function getAsxOracle() external view returns (IOracle) {\\n        return asxOracle;\\n    }\\n\\n    /**\\n     * @notice Returns WETH token address.\\n     * @return WETH token address.\\n     */\\n    function getWeth() external view returns (address) {\\n        return weth;\\n    }\\n\\n    /**\\n     * @notice Returns ASX token address.\\n     * @return ASX token address.\\n     */\\n    function getAsx() external view returns (address) {\\n        return asx;\\n    }\\n\\n    /**\\n     * @notice Returns slippage tolerance.\\n     * @return Slippage tolerance.\\n     */\\n    function getSlippageTolerance() external view returns (uint16) {\\n        return slippageTolerance;\\n    }\\n\\n    /**\\n     * @notice Swaps ETH for ASX and burns output ASX tokens.\\n     * @param _ethAmount An amount of ETH to swap for ASX.\\n     * @param _asxAmount An amount of ASX to burn with swapped ASX.\\n     */\\n    function _buybackAndBurn(uint256 _ethAmount, uint256 _asxAmount) internal {\\n        uint256 _swappedAsxAmount;\\n        address _asx = asx;\\n\\n        if (_ethAmount > 0) {\\n            IOracle _asxOracle = asxOracle;\\n            uint256 _asxPriceInEth = (uint256(_asxOracle.latestAnswer()) * 1e18) / 10 ** _asxOracle.decimals();\\n            uint256 _amountOut = _ethAmount / _asxPriceInEth;\\n            uint256 _amountOutMin = _amountOut - ((_amountOut * slippageTolerance) / ONE_HUNDRED_PERCENTS);\\n\\n            _swappedAsxAmount = uniswapWrapper.swapSingle{ value: _ethAmount }(\\n                _asx,\\n                UNISWAP_V3_POOL_FEE,\\n                _ethAmount,\\n                _amountOutMin\\n            );\\n        }\\n\\n        uint256 _asxAmountToBurn = _swappedAsxAmount + _asxAmount;\\n\\n        if (_asxAmountToBurn > 0) ERC20BurnableUpgradeable(_asx).burn(_asxAmountToBurn);\\n    }\\n\\n    /**\\n     * @notice Sets a new UniswapWrapper contract.\\n     * @param _newUniswapWrapper A new UniswapWrapper contract address.\\n     */\\n    function _setUniswapWrapper(address _newUniswapWrapper) private {\\n        _onlyContract(_newUniswapWrapper);\\n\\n        uniswapWrapper = UniswapWrapper(_newUniswapWrapper);\\n    }\\n\\n    /**\\n     * @notice Sets a new oracle for ASX token that reruns price of ASX token in ETH.\\n     * @param _newAsxOracle A new oracle for ASX token that reruns price of ASX token in ETH.\\n     */\\n    function _setAsxOracle(address _newAsxOracle) private {\\n        _onlyContract(_newAsxOracle);\\n\\n        asxOracle = IOracle(_newAsxOracle);\\n    }\\n\\n    /**\\n     * @notice Sets slippage tolerance.\\n     * @param _newSlippageTolerance new slippage tolerance for a vesting EsASXVesting.\\n     */\\n    function _setSlippageTolerance(uint16 _newSlippageTolerance) private {\\n        if (_newSlippageTolerance == 0 || _newSlippageTolerance > ONE_HUNDRED_PERCENTS)\\n            revert ESASXErrors.InvalidSlippageTolerance();\\n\\n        slippageTolerance = _newSlippageTolerance;\\n    }\\n\\n    /**\\n     * @notice Checks if an address is a contract.\\n     * @param _contract An address to check.\\n     */\\n    function _onlyContract(address _contract) internal view {\\n        if (!_contract.isContract()) revert ESASXErrors.NotContract();\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/vesting/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IOracle\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all custom oracles should implement.\\n */\\ninterface IOracle {\\n    /**\\n     * @notice Returns the latest answer in ETH.\\n     * @return _answer The latest answer in ETH.\\n     */\\n    function latestAnswer() external view returns (int256 _answer);\\n\\n    /**\\n     * @notice Returns the data from the latest round.\\n     * @return _roundId The round ID.\\n     * @return _answer The answer from the latest round.\\n     * @return _startedAt Timestamp of when the round started.\\n     * @return _updatedAt Timestamp of when the round was updated.\\n     * @return _answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed.\\n     */\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 _roundId, int256 _answer, uint256 _startedAt, uint256 _updatedAt, uint80 _answeredInRound);\\n\\n    /**\\n     * @notice Returns the number of decimals in the answer.\\n     * @return The number of decimals in the answer.\\n     */\\n    function decimals() external pure returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/vesting/libraries/ESASXErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 Errors library\\n * @author Asymetrix Protocol Inc Team\\n * @notice A library with Asymetrix Protocol V2 ESASX errors.\\n */\\nlibrary ESASXErrors {\\n    error InvalidAddress();\\n    error WrongVestingPeriod();\\n    error WrongVestingAmount();\\n    error NotExistingVP();\\n    error InvalidLength();\\n    error InvalidRange();\\n    error OutOfBounds();\\n    error NothingToRelease();\\n    error NotEnoughUnlockedASX();\\n    error NotEnoughUnlockedESASX();\\n    error NotEnoughASXWithDiscount();\\n    error NotEnoughETH();\\n    error WrongETHAmount();\\n    error InvalidEsASXAmount();\\n    error InvalidSlippageTolerance();\\n    error NotContract();\\n    error WrongBalancerPoolTokensNumber();\\n    error NonTransferable();\\n}\\n\"\r\n    },\r\n    \"contracts/vesting/UniswapWrapper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport { ISwapRouter } from \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ESASXErrors } from \\\"./libraries/ESASXErrors.sol\\\";\\n\\n/**\\n * @title Asymetrix Protocol V2 UniswapWrapper contract\\n * @author Asymetrix Protocol Inc Team\\n * @notice Implements helper functions for Uniswap V3 interactions.\\n */\\ncontract UniswapWrapper {\\n    ISwapRouter public immutable router;\\n    address public immutable weth;\\n\\n    uint16 public constant DEADLINE = 1000;\\n\\n    /**\\n     * @notice \u0421onstructor of this UniswapWrapper contract.\\n     * @dev Sets _router, uniswap router contract address, and _weth, WETH token contract address.\\n     * @param _router uniswap router contract address.\\n     * @param _weth WETH token contract address.\\n     */\\n    constructor(address _router, address _weth) {\\n        if (_router == address(0)) revert ESASXErrors.InvalidAddress();\\n        if (_weth == address(0)) revert ESASXErrors.InvalidAddress();\\n\\n        router = ISwapRouter(_router);\\n        weth = _weth;\\n    }\\n\\n    /**\\n     * @notice Swaps ETH for out tokens using Uniswap V3.\\n     * @param _tokenOut An address of a token out.\\n     * @param _fee A fee of the pool.\\n     * @param _amountIn An amount of ETH to swap.\\n     * @param _amountOutMinimum A min amount of a token out to receive.\\n     * @return amountOut An amount of a token out to receive.\\n     */\\n    function swapSingle(\\n        address _tokenOut,\\n        uint24 _fee,\\n        uint256 _amountIn,\\n        uint256 _amountOutMinimum\\n    ) external payable returns (uint256) {\\n        if (msg.value != _amountIn) revert ESASXErrors.WrongETHAmount();\\n\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n            tokenIn: weth,\\n            tokenOut: _tokenOut,\\n            fee: _fee,\\n            recipient: msg.sender,\\n            deadline: block.timestamp + DEADLINE,\\n            amountIn: _amountIn,\\n            amountOutMinimum: _amountOutMinimum,\\n            sqrtPriceLimitX96: 0\\n        });\\n\\n        return router.exactInputSingle{ value: msg.value }(params);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSlippageTolerance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockIsNotFinished\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoEmptySlotsInThisPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExistingLock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExistingPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakeTokenWithdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooBigBoostThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooSmallBoostThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongLockDurtion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongLockDurtionSettings\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongLockDurtionSettingsNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"}],\"name\":\"LockClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"createdAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"updatedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxBoost\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IRewardsBooster.Lock\",\"name\":\"_lock\",\"type\":\"tuple\"}],\"name\":\"LockCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_newDuration\",\"type\":\"uint32\"}],\"name\":\"LockExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"isFungible\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeTokenValuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"lockDurationSettingsNumber\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct IRewardsBooster.Pool\",\"name\":\"_pool\",\"type\":\"tuple\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isFungible\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Rescued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LOCKS_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED_PERCENTS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"buybackAndBurnAsx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeTokenValuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isFungible\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lowerLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"upperLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"additionalBoost\",\"type\":\"uint16\"}],\"internalType\":\"struct IRewardsBooster.LockDurationSettings[]\",\"name\":\"_lockDurationSettings\",\"type\":\"tuple[]\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_newLockDuration\",\"type\":\"uint32\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsx\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsxOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getBoost\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"getBoostBatch\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_coefficients\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"_eligibility\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getInitializedLocksInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"createdAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"updatedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxBoost\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"}],\"internalType\":\"struct IRewardsBooster.Lock[]\",\"name\":\"_locks\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_lids\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"getLockDurationSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lowerLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"upperLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"additionalBoost\",\"type\":\"uint16\"}],\"internalType\":\"struct IRewardsBooster.LockDurationSettings[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_ldsid\",\"type\":\"uint8\"}],\"name\":\"getLockDurationSettings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lowerLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"upperLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"additionalBoost\",\"type\":\"uint16\"}],\"internalType\":\"struct IRewardsBooster.LockDurationSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"createdAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"updatedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxBoost\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isInitialized\",\"type\":\"bool\"}],\"internalType\":\"struct IRewardsBooster.Lock\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockedLiqudityValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockedLiquidityTotalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"_lockedLiquidityValues\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBoost\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBoostThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinBoostThreshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNonfungiblePositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"isFungible\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeTokenValuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"lockDurationSettingsNumber\",\"type\":\"uint8\"}],\"internalType\":\"struct IRewardsBooster.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolsNumber\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSlippageTolerance\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStEthOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTicket\",\"outputs\":[{\"internalType\":\"contract ITicket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapWrapper\",\"outputs\":[{\"internalType\":\"contract UniswapWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"initializedLocksNumber\",\"type\":\"uint8\"}],\"internalType\":\"struct IRewardsBooster.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ticket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stEthOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asxOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nonfungiblePositionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapWrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asx\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"maxBoost\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minBoostThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxBoostThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"slippageTolerance\",\"type\":\"uint16\"}],\"internalType\":\"struct IRewardsBooster.InitParams\",\"name\":\"_initParams\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isStakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isFungible\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAsxOracle\",\"type\":\"address\"}],\"name\":\"setAsxOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"lowerLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"upperLockDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"additionalBoost\",\"type\":\"uint16\"}],\"internalType\":\"struct IRewardsBooster.LockDurationSettings[]\",\"name\":\"_lockDurationSettings\",\"type\":\"tuple[]\"}],\"name\":\"setLockDurationSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newMaxBoost\",\"type\":\"uint16\"}],\"name\":\"setMaxBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newMaxBoostThreshold\",\"type\":\"uint16\"}],\"name\":\"setMaxBoostThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newMinBoostThreshold\",\"type\":\"uint16\"}],\"name\":\"setMinBoostThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newNonfungiblePositionManager\",\"type\":\"address\"}],\"name\":\"setNonfungiblePositionManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newSlippageTolerance\",\"type\":\"uint16\"}],\"name\":\"setSlippageTolerance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newStEthOracle\",\"type\":\"address\"}],\"name\":\"setStEthOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_newStakeTokenValuer\",\"type\":\"address\"}],\"name\":\"setStakeTokenValuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTicket\",\"type\":\"address\"}],\"name\":\"setTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newUniswapWrapper\",\"type\":\"address\"}],\"name\":\"setUniswapWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amountOrId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_lockDuration\",\"type\":\"uint32\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_lid\",\"type\":\"uint8\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RewardsBooster", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}