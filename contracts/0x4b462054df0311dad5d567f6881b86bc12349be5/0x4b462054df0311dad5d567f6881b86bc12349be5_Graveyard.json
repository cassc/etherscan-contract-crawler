{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Graveyard.sol\": {\r\n      \"content\": \"// * \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 *\\n// |                                                                                   |\\n// |    SSSSS K    K EEEEEE L      EEEEEE PPPPP  H    H U    U N     N K    K  SSSSS   |\\n// |   S      K   K  E      L      E      P    P H    H U    U N N   N K   K  S        |\\n// |    SSSS  KKKK   EEE    L      EEE    PPPPP  HHHHHH U    U N  N  N KKKK    SSSS    |\\n// |        S K   K  E      L      E      P      H    H U    U N   N N K   K       S   |\\n// |   SSSSS  K    K EEEEEE LLLLLL EEEEEE P      H    H  UUUU  N     N K    K SSSSS    |\\n// |                                                                                   |\\n// | * AN ETHEREUM-BASED INDENTITY PLATFORM BROUGHT TO YOU BY NEUROMANTIC INDUSTRIES * |\\n// |                                                                                   |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@                              |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@                              |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,,,,,@@@                           |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@@@@@@@@,,,,,,,,,,@@@@@@,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,@@@@@@,,,,,,,,,,,,,,,,,@@@                        |\\n// |                       @@@,,,,,,,@@@@@@,,,,,,,,,,,,,,,,,@@@                        |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,,,,,@@@                           |\\n// |                          @@@,,,,,,,,,,,,,,,,,,,,@@@@@@@                           |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@@@@                           |\\n// |                             @@@@@@@@@@@@@@@@@@@@@@@@@@@                           |\\n// |                             @@@@,,,,,,,,,,,,,,,,@@@@,,,@@@                        |\\n// |                                 @@@@@@@@@@@@@@@@,,,,@@@                           |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                              @@@,,,,@@@                           |\\n// |                                           @@@,,,,,,,,,,@@@                        |\\n// |                                                                                   |\\n// |                                                                                   |\\n// |   for more information visit skelephunks.com  |  follow @skelephunks on twitter   |\\n// |                                                                                   |\\n// * \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 *\\n   \\n   \\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //                                           |  The Graveyard is a place you can send a Skelephunk    //\\n    //  The Skelephunks Graveyard Contract       |  and get back a fresh mint from the \\\"Crypt\\\" reserves.  //\\n    //  By Autopsyop,for Neuromantic Industries  |  This is called \\\"burying\\\" instead of burning a token.  //\\n    //  Part of the Skelephunks Platform         |  Once a token is buried it can also be purchased at    //\\n    //                                           |  mint price or reserved to swap in for your next bury  //                                                 //  \\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////                                    \\n\\n\\n// SPDX-License-Identifier: MIT\\n// ************************* ERROR CODES ***************************/\\n// aa: already authorized\\n// na: must be authorized\\n// oa: Must be owner or authorized address\\n// as: skelephunksContract is already set to that value\\n// rs: no skelephunks contract linked\\n// os: you can only send skelephunks to the Graveyard\\n// ap: Paused already set to that value\\n// ao: minterOnly already set to that value\\n// ar: allowRemint already set to that value\\n// am: already reminted more than that\\n// ge: the graveyard is empty\\n// aw: per-wallet maximum already set to that value\\n// au: useSnapshot is already set to that value\\n// nb: token is not buried\\n// tr: token is reserved\\n// al: allowReservations is already set to that value\\n// nr: reservations are not currently allowed\\n// ur: address has nothing reserved\\n// nm: no mints left in crypt\\n// mr: maximum remints already granted\\n// mx: wallet has already max reminted\\n// sn: token was minted after snapshot\\n// cb: the graveyard cannot bury your skelephunk at this time\\n// nc: contracts are not allowed to send tokens to the graveyard\\n// a$: allowPurchase is already set to that value\\n// a@: purchasePrice already set to that value\\n// np: purchasing not currently allowed\\n// pr: Poor\\n// cf: could not forward payment to the skelephunks contract\\n// *****************************************************************/\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface ISkelephunks is IERC721{\\n    function mintedAt(uint256 _tokenId) external view returns (uint256);\\n    function minterOf(uint256 _tokenId) external view returns (address);\\n    function getGenderAndDirection(uint256 _tokenId) external view returns (uint256);\\n    function tokenOfOwnerByIndex( address _owner, uint256 _index) external view returns (uint256);\\n    function numMintedReserve() external view returns (uint256);\\n    function maxReserveSupply() external view returns (uint256);\\n    function mintReserve(address _to, uint256 _quantity, uint256 _genderDirection) external;\\n    function mintPrice () external view returns (uint256);\\n    function owner () external view returns (address);\\n}\\n\\ncontract Graveyard is IERC721Receiver, Ownable {\\n// packed storage variables\\n    uint256 public snapshot;\\n\\n    uint64 private purchasePrice;\\n    uint16 public totalRemints;\\n    uint16 private maxRemints;\\n    uint16 public totalBurials;\\n    uint16 private maxRemintsPerWallet;\\n    uint8 public holdLengthMinutes;// max 256 minutes \\n    bool public paused;\\n    bool public minterOnly;\\n    bool public allowRemint;\\n    bool public useSnapshot;\\n    bool public allowReservations;\\n    bool public allowPurchase;\\n\\n    ISkelephunks public skelephunksContract;\\n\\n    mapping (address => bool) private authorizedAddresses;\\n\\n    mapping (address => uint16) public totalRemintsByWallet;\\n\\n    mapping ( address => uint16 ) private reservations;\\n\\n    mapping ( uint16 => uint256 ) private expirations;\\n    constructor () {\\n        paused = false;\\n\\n        allowRemint = true;\\n        minterOnly = false;\\n        maxRemints = 0;\\n        maxRemintsPerWallet = 0;\\n\\n        useSnapshot = true;\\n        snapshot = block.timestamp;\\n\\n        allowReservations = false;\\n        holdLengthMinutes = 60;//1 hour hold for reservations\\n\\n        allowPurchase = false;\\n        skelephunksContract = ISkelephunks(address(0x7db8cD89308A295bb2D7F809B05DB6389e9a6d88));// MAINNET\\n        // skelephunksContract = ISkelephunks(address(0xbaC6C9F6b0d7be7a46EDb82237991Fb990459748));// GOERLI\\n        transferOwnership( skelephunksContract.owner() );\\n    }\\n\\n    /**\\n        authorized addresses can exhume buried skelephunks\\n    **/\\n    function setAuthorization( \\n        address _addr,\\n        bool _auth\\n    ) public onlyOwner {\\n        require(authorizedAddresses[_addr]!=_auth,\\\"aa\\\");\\n        authorizedAddresses[_addr] = _auth;\\n\\n    }\\n    function isAuthorized(\\n        address _addr\\n    ) public view returns (bool){\\n        return authorizedAddresses[_addr];\\n    }\\n    modifier onlyAuthorized{\\n        require(authorizedAddresses[msg.sender],\\\"na\\\");\\n        _;\\n    }\\n    modifier ownerOrAuthorized{\\n        require( owner() == msg.sender || isAuthorized(msg.sender), \\\"oa\\\");\\n        _;\\n    }\\n    /**\\n        The skele contract\\n    **/    \\n\\n    function setSkelephunksContract( \\n        address _contract \\n    ) external onlyOwner {\\n        require(address(skelephunksContract)!= _contract, \\\"as\\\");\\n        skelephunksContract = ISkelephunks( _contract );\\n    }\\n    /**\\n        function requires the skele contract\\n    **/    \\n    modifier requiresSkelephunks {\\n        require( ISkelephunks(address(0)) != skelephunksContract , \\\"rs\\\" );\\n        _;\\n    }\\n    /**\\n        Redeem for mint requires the crypt to have supply // protect the final 666\\n    **/\\n    function getMaxCryptMints(\\n    ) private view returns (uint16){\\n        return  uint16(skelephunksContract.maxReserveSupply() - skelephunksContract.numMintedReserve() - 666);\\n    }\\n    function cryptHasMints(\\n    ) private view returns (bool){\\n        return 0 != getMaxCryptMints() ;\\n    }\\n\\n    /**\\n        function will only receive ERC721 from skele contract\\n    **/\\n    modifier onlyReceiveSkelephunks {\\n        require( address(msg.sender) == address(skelephunksContract), \\\"os\\\" );\\n        _;\\n    }\\n    /**\\n        pause stuff \\n    **/\\n\\n    function setPaused(\\n        bool _paused\\n    ) public onlyOwner {\\n        require( paused != _paused, \\\"ap\\\" );\\n        paused = _paused;\\n    }\\n\\n    modifier pausable {\\n      require(!paused);\\n      _;\\n   }\\n\\n    /**\\n        only accept ERC721 from skele minter \\n    **/\\n\\n    function setMinterOnly( \\n        bool _minterOnly \\n    ) public onlyOwner {\\n        require( minterOnly != _minterOnly, \\\"ao\\\" );\\n        minterOnly = _minterOnly;\\n    }\\n\\n\\n    /**\\n        allowRemints \\n    **/\\n\\n    function setAllowRemint( \\n        bool _allow \\n    ) public onlyOwner {\\n        require( allowRemint != _allow, \\\"ar\\\" );\\n        allowRemint = _allow;\\n    }\\n\\n    /**\\n        buried tokens\\n    **/    \\n    function isBuried(\\n        uint16 _tokenId\\n    ) public view requiresSkelephunks returns ( bool ){\\n        return skelephunksContract.ownerOf(_tokenId) == address(this);\\n    }\\n\\n    /**\\n        remints\\n    **/\\n    function getMaxRemints(\\n    ) public view returns (uint16){\\n        if(!allowRemint){\\n            return 0;\\n        }\\n        if(maxRemints == 0){\\n            return getMaxCryptMints();\\n        }\\n        return maxRemints;\\n    }\\n\\n    function setMaxRemints( \\n        uint16 _max \\n    ) public onlyOwner {\\n        require( _max == 0 || _max > totalRemints, \\\"am\\\" );\\n        maxRemints = _max;\\n    }\\n\\n    /**\\n       Number of tokens currently owned by the Graveyard\\n    **/    \\n    function getNumBuried(\\n    ) public view returns ( uint16 ){\\n        return uint16(skelephunksContract.balanceOf( address( this ) ));\\n    }\\n\\n    modifier notEmpty {\\n        require(0 < getNumBuried(), \\\"ge\\\");\\n        _;\\n    }\\n\\n    function getMaxRemintsPerWallet(\\n    )public view returns (uint16){\\n        if(maxRemintsPerWallet == 0){\\n            return getRemainingRemints();\\n        }\\n        return maxRemintsPerWallet;\\n    }\\n    function setMaxRemintsPerWallet( \\n        uint16 _max \\n    ) public onlyOwner {\\n        require(maxRemintsPerWallet != _max, \\\"aw\\\");\\n        maxRemintsPerWallet = _max;\\n    }\\n\\n    function getRemainingRemints(\\n    ) public view returns (uint16) {\\n        if (!cryptHasMints() || !allowRemint){\\n            return 0;\\n        }\\n        if (maxRemints == 0){\\n            return getMaxCryptMints();\\n        }\\n        return maxRemints - totalRemints;\\n    }\\n\\n    function getRemainingRemintsForWallet(\\n        address _wallet\\n    ) public view returns(uint16){\\n        if (!cryptHasMints() || !allowRemint){\\n            return 0;\\n        }\\n        if (maxRemintsPerWallet == 0){\\n            return getMaxRemints();\\n        }\\n        return maxRemintsPerWallet - totalRemintsByWallet[_wallet];\\n    }\\n\\n    /**\\n       snapshot (timestamp) - no new tokens after this timestamp can be buried\\n    **/  \\n\\n    function setUseSnapshot(\\n        bool _bool\\n    ) public onlyOwner {\\n        require (useSnapshot != _bool, \\\"au\\\" );\\n        useSnapshot = _bool;\\n    }\\n    function takeSnapshot( \\n        uint256 _timestamp \\n    ) public onlyOwner {\\n        useSnapshot = true;\\n        if (_timestamp == 0) {\\n            snapshot = block.timestamp;\\n        } else {\\n            snapshot = _timestamp;\\n        }\\n    }\\n\\n    /**\\n       reservation hold period (seconds) - for how long is a reservation exclusive\\n    **/  \\n    \\n    function setHoldLengthMinutes(\\n        uint8 _mins\\n    ) public onlyOwner {\\n        holdLengthMinutes = _mins;\\n    }\\n\\n    /**\\n       an available token is buried and outside of any reservation window\\n    **/  \\n    function tokenIsAvailable(\\n        uint16 _tokenId\\n    ) public view returns (bool) {\\n        return isBuried(_tokenId) && !isReserved(_tokenId);\\n    }\\n\\n    function requireAvailable(\\n        uint16 _tokenId\\n    ) private view {\\n        require(isBuried(_tokenId), \\\"nb\\\");\\n        require(!isReserved(_tokenId) || reservations[msg.sender] == _tokenId, \\\"tr\\\");\\n\\n    }\\n    function setAllowReservations(\\n        bool _allow\\n    )public onlyOwner{\\n        require(allowReservations != _allow, \\\"al\\\");\\n        allowReservations = _allow;\\n    }\\n\\n    /**\\n       a reserved token will be sent upon redeem instead of a new mint\\n    **/  \\n    function isReserved(\\n        uint16 _tokenId\\n    ) public view returns (bool){\\n        return block.timestamp < expirations[ _tokenId ];\\n    }\\n    /**\\n       you can only reserve one token at a time\\n    **/  \\n    function reserveToken( \\n        uint16 _tokenId \\n    ) public pausable notEmpty{\\n        requireAvailable(_tokenId);\\n        require(allowReservations, \\\"nr\\\");\\n        if(0 < getReservationFor(msg.sender)){\\n            unlockToken(getReservationFor(msg.sender));\\n        }\\n        reservations[msg.sender] = _tokenId;\\n        lockToken(_tokenId);\\n    }\\n    function lockToken (\\n        uint16 _tokenId\\n    ) private {\\n            expirations[_tokenId] = block.timestamp + holdLengthMinutes*60 ;\\n    }\\n    function getReservationFor(\\n        address _wallet\\n    ) public view returns (uint16) {\\n        return reservations[_wallet];\\n    }\\n    \\n    function unlockToken(\\n        uint16 _tokenId\\n    ) private{\\n        delete expirations[_tokenId];\\n    }\\n\\n    function clearMyReservation(\\n    ) public pausable {\\n        clearReservationFrom(msg.sender);\\n    }\\n    function clearReservationFrom(\\n        address _address\\n    ) private {\\n        require( getReservationFor( _address ) != 0, \\\"ur\\\" );\\n        unlockToken(reservations[_address]);\\n        delete reservations[_address];\\n    }\\n\\n    /**\\n       a buried token is owned by this contract, and can be reserved for redemption or purchased\\n    **/  \\n\\n    function buriedTokenByIndex(\\n        uint16 _index\\n    ) public view requiresSkelephunks returns (uint16) {\\n        return uint16(skelephunksContract.tokenOfOwnerByIndex(address(this), uint256(_index)));\\n    }\\n\\n    /**\\n       an exhumed token was buried but later transferred out to a new owner\\n    **/  \\n    function exhumeToken(\\n        address _to, \\n        uint16 _tokenId\\n    ) private notEmpty requiresSkelephunks {\\n        skelephunksContract.safeTransferFrom(address(this), _to, _tokenId);\\n    }\\n\\n    function exhumeTo(\\n        address _to,\\n        uint16 _tokenId\\n    ) public ownerOrAuthorized {\\n        requireAvailable(_tokenId);\\n        exhumeToken(_to,_tokenId);\\n    }\\n/**\\n    exhume all tokens to a single address\\n    if _reserved is false, skip reserved tokens\\n**/\\n    function exhumeAllTo(\\n        address _to,\\n        bool _includeReserved\\n    ) public onlyOwner notEmpty {\\n        uint16 num = getNumBuried();\\n        for (uint16 i = 0; i < num ; i++ ){\\n            uint16 tokenId = buriedTokenByIndex(i);\\n            if(_includeReserved || tokenIsAvailable(tokenId)){\\n                exhumeToken( _to, tokenId);\\n            }\\n        }\\n    }\\n\\n    function exhumeReserved(\\n        address _to\\n    ) private notEmpty{\\n        require(getReservationFor(_to) != 0, \\\"ur\\\" );\\n        exhumeToken(_to,getReservationFor(_to));\\n        clearReservationFrom(_to);\\n    }\\n\\n    function exhumeRandom(\\n        address _to\\n    ) private requiresSkelephunks notEmpty{\\n        uint256 random = uint256(\\n            keccak256(\\n                abi.encode(\\n                    _to,\\n                    tx.gasprice,\\n                    block.number,\\n                    block.timestamp,\\n                    block.prevrandao,\\n                    blockhash(block.number - 1),\\n                    address(this),\\n                    getNumBuried()\\n                )\\n            )\\n        );\\n        uint16 index = uint16(getNumBuried() == 1 ? 0 : random % (getNumBuried() - 1)); // max index was just buried\\n        uint16 tokenID = uint16(skelephunksContract.tokenOfOwnerByIndex(address(this),index));\\n        exhumeToken(_to,tokenID);\\n    }\\n\\n    /**\\n       the graveyard enables a wallet to exhange a skelephunk for a new mint from the reserves\\n    **/  \\n    function remintFromCrypt(\\n        address _to, \\n        uint8 _gad\\n    ) private requiresSkelephunks {\\n        require( cryptHasMints(),\\\"nm\\\");\\n        require( totalRemints < getRemainingRemints(), \\\"mr\\\" );\\n        require( 0 < getRemainingRemintsForWallet(_to), \\\"mx\\\");\\n        skelephunksContract.mintReserve(_to, 1, _gad);\\n        totalRemints++;\\n        totalRemintsByWallet[ _to ]++;\\n    }\\n\\n    function burySkelephunk(\\n        uint16 _tokenId, \\n        address _wallet \\n    ) private requiresSkelephunks{\\n        require( !useSnapshot || 0 == snapshot || skelephunksContract.mintedAt( _tokenId ) < snapshot, \\\"sn\\\" );\\n    \\n        if(_wallet == owner()){\\n            // contract owner can send without reward to populate the graveyard\\n        }else if( 0 < getReservationFor(_wallet)){ // settle reservations first\\n            exhumeReserved(_wallet); \\n        }else if (// if remints are available and allowed, send a new mint from the crypt\\n            allowRemint &&\\n            cryptHasMints() && \\n            0 < getRemainingRemints() && \\n            0 < getRemainingRemintsForWallet(_wallet) && \\n            (!minterOnly || skelephunksContract.minterOf( _tokenId ) == _wallet)\\n        ){\\n            remintFromCrypt(_wallet,uint8(skelephunksContract.getGenderAndDirection(uint256(_tokenId))));\\n        }else if(1 < getNumBuried()){// otherwise, send a random buried token\\n            exhumeRandom(_wallet);\\n        }else{\\n            revert(\\\"cb\\\");\\n        }\\n        totalBurials++;\\n    }\\n\\n    function onERC721Received(\\n        address, \\n        address _from, \\n        uint256 _tokenId, \\n        bytes calldata \\n    ) external onlyReceiveSkelephunks returns (bytes4) {\\n        require(_from == tx.origin, \\\"nc\\\");\\n        burySkelephunk(uint16(_tokenId), _from);\\n        return this.onERC721Received.selector;\\n    }\\n\\n\\n    /**\\n       the graveyard enables a wallet to purchase a previously buried skelephunk at mint price\\n    **/  \\n    function setAllowPurchase (\\n        bool _allow\\n    ) public onlyOwner{\\n        require(allowPurchase !=_allow, \\\"a$\\\");\\n        allowPurchase = _allow;\\n    }\\n\\n    function setPurchasePrice(\\n        uint64 _price\\n    ) public onlyOwner {\\n        require(purchasePrice != _price, \\\"a@\\\");\\n        purchasePrice = _price;\\n    }\\n    function getPurchasePrice(\\n\\n    )public view returns (uint64){\\n        if(purchasePrice == 0){\\n            return uint64(skelephunksContract.mintPrice());\\n        }else{\\n            return purchasePrice;\\n        }\\n    }\\n    function buyBuriedSkelephunk (\\n        uint16 _tokenId\\n    ) public payable pausable requiresSkelephunks{\\n        uint64 price = getPurchasePrice();\\n        require( allowPurchase, \\\"np\\\");\\n        require( price <= msg.value, \\\"pr\\\");\\n        requireAvailable(_tokenId);\\n        (bool outcome,) = address(skelephunksContract).call{value: price}(\\\"\\\");\\n        require(outcome,\\\"cf\\\");\\n        exhumeToken(msg.sender,_tokenId);\\n        uint256 refund = msg.value - price;\\n        if(0 < refund){\\n            payable(msg.sender).transfer(refund);//give back change for overpayment\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowPurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowRemint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowReservations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"buriedTokenByIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"buyBuriedSkelephunk\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearMyReservation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_includeReserved\",\"type\":\"bool\"}],\"name\":\"exhumeAllTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"exhumeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxRemints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxRemintsPerWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumBuried\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPurchasePrice\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRemainingRemints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getRemainingRemintsForWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getReservationFor\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdLengthMinutes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"isBuried\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"isReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"reserveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowRemint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowReservations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_auth\",\"type\":\"bool\"}],\"name\":\"setAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_mins\",\"type\":\"uint8\"}],\"name\":\"setHoldLengthMinutes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_max\",\"type\":\"uint16\"}],\"name\":\"setMaxRemints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_max\",\"type\":\"uint16\"}],\"name\":\"setMaxRemintsPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_minterOnly\",\"type\":\"bool\"}],\"name\":\"setMinterOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_price\",\"type\":\"uint64\"}],\"name\":\"setPurchasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setSkelephunksContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setUseSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skelephunksContract\",\"outputs\":[{\"internalType\":\"contract ISkelephunks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"takeSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"tokenIsAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurials\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRemints\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRemintsByWallet\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useSnapshot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Graveyard", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}