// SPDX-License-Identifier: GPL-2.0-or-later
/* Created by & Property of EtherLotto*/
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract EtherLotto is ERC1155, Ownable, ERC1155Supply, VRFConsumerBaseV2, ReentrancyGuard {
    /* Created by & Property of EtherLotto*/

     /* -- Random Number Variables Chainlink VRF -- */
    VRFCoordinatorV2Interface COORDINATOR;
    uint64 s_subscriptionId;
    address vrfCoordinator = 0x271682DEB8C4E0901D1a1550aD2e64D568E69909;
    bytes32 keyHash = 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805;
    uint32 callbackGasLimit = 100000;
    uint16 requestConfirmations = 3;
    uint32 numWords =  1;
    uint256[] public s_randomWords;
    uint256 public randomNumber;
    uint256 public s_requestId;
    address s_owner;
    mapping(uint256 => address) public entries;
    mapping(bytes32 => uint256[]) public addressEntries;
    mapping (uint256 => uint256[]) public pastWinningNumbers;
    mapping (uint256 => address[]) public historyOfWinningAddresses;
    uint256 public entriesCounter;
    uint256[] public arrayofWinningTickets;
    uint256 public numberOfWinners = 3;
    uint256 public prizePercentagePerWinner = 25; 
    uint256 public pricePerTicket = 1000000000000000; //0.001 eth
    address public ETLottoWallet = 0x2Dd8c943142D4B0ca81eC44CEECd24Ca69b904Ea;
    /* ---- */
    
    /* -- NFT Variables -- */
     using Strings for uint256;
    uint256 public currentTicket = 1;
    bool public isTicketSalesActive = false;
    using SafeMath for uint256;
    uint256 public maxTicketsPerTX = 5;
    string public baseUri = "";
    /* ---- */

    event Attest(address indexed to, uint256[] indexed tokenID);
    event Revoke(address indexed to, uint256[] indexed tokenID);

    constructor(uint64 subscriptionId) ERC1155("EtherLotto") VRFConsumerBaseV2(vrfCoordinator){
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    s_owner = msg.sender;
    s_subscriptionId = subscriptionId;
    }

    /* Random Number Selector Functions */
    function requestRandomWords() external onlyOwner {
    s_requestId = COORDINATOR.requestRandomWords(
      keyHash,
      s_subscriptionId,
      requestConfirmations,
      callbackGasLimit,
      numWords
    );
    }
    function fulfillRandomWords(
    uint256, /* requestId */
    uint256[] memory randomWords
    ) internal override {
    s_randomWords = randomWords;
    randomNumber = s_randomWords[0];
    }
    
    function SelectandRewardWinners() external payable onlyOwner nonReentrant {
    isTicketSalesActive = false;
    uint256[] memory expandedValues;
    expandedValues = new uint256[](numberOfWinners);
    /* Selects Random Numbers based off Random Number Generated by Chainlink VRF*/
    for (uint256 i = 0; i < numberOfWinners ; i++) {
        expandedValues[i] = uint256(keccak256(abi.encode(randomNumber, i)));
        expandedValues[i] = (expandedValues[i] % entriesCounter);
    }
    /* Setting Winning tickets into Array */
    arrayofWinningTickets = expandedValues;
    pastWinningNumbers[currentTicket] = expandedValues;
    uint256 prizeFunds = address(this).balance/uint256(100)*(prizePercentagePerWinner);
    /* Transfer Prize Money to each Winner */
    for(uint256 i = 0; i < arrayofWinningTickets.length; i++){
        historyOfWinningAddresses[currentTicket].push(findOwner(arrayofWinningTickets[i]));
        payable(findOwner(arrayofWinningTickets[i])).transfer(prizeFunds);
    }
    payable(ETLottoWallet).transfer(prizeFunds);
    }
    
    function setVRFCoordinator(address _newVRFCoordinator) external onlyOwner {
    vrfCoordinator = _newVRFCoordinator;
    }

    function setKeyhash(bytes32 _newKeyHash) external onlyOwner{
        keyHash = _newKeyHash;
    }

    function changeSubscriptionId(uint64 _newSubscriptionID) external onlyOwner{
        s_subscriptionId = _newSubscriptionID;
    }

    function setLottoWallet(address _ETLottoWallet) external onlyOwner{
        ETLottoWallet = _ETLottoWallet;
    }

    /* ---- */

    /* NFT Functions */
    function setURI(string memory newuri) public onlyOwner {
        _setURI(newuri);
    }

    function setBaseURI(string memory newBaseUri) external onlyOwner {
        baseUri = newBaseUri;
    }

    function uri(uint id) public view virtual override returns (string memory) {
        return string(abi.encodePacked(baseUri, id.toString(), ".json"));
    }

    function setCurrentTicketID(uint256 _newTicketID) external onlyOwner {
    currentTicket = _newTicketID;
    }

    function setTicketPrice(uint256 _newTicketPrice) external onlyOwner {
    pricePerTicket = _newTicketPrice;
    }

    function setPrizePercentagePerWinner(uint256 _newPrizePercentagePerWinner) external onlyOwner {
    prizePercentagePerWinner = _newPrizePercentagePerWinner;
    }

    function setAmountOfWinners(uint256 _newAmountofWinners) external onlyOwner {
        numberOfWinners = _newAmountofWinners;
    }

    function activateTicketSales() external onlyOwner {
    isTicketSalesActive = !isTicketSalesActive;
    }

    function myTicketNumbers(address yourAddress) public view virtual returns (uint256[] memory){
        bytes32 usersKeyHash = keccak256(abi.encodePacked(yourAddress, currentTicket));
        return addressEntries[usersKeyHash];
    }

    function lastWeeksWinningNumbers() public view virtual returns (uint256[] memory) {
    return arrayofWinningTickets;
    }

    function pastWinnersAddress(uint256 week) public view virtual returns (address[] memory){
        require(week <= currentTicket, "The week you have requested has not happened yet.");
        address[] memory WinningPlayers;
        WinningPlayers = historyOfWinningAddresses[week];
        return WinningPlayers;
    }

    function findPastWinningNumbers(uint256 week) public view virtual returns (uint256[] memory) {
    require(week <= currentTicket, "The Week you have requested has not happened yet or is currently happening.");
    return pastWinningNumbers[week];
    }

    function myPastNumbers(uint256 week, address wallet) public view virtual returns (uint256[] memory){
        require(week <= currentTicket, "The Week you have requested has not happened yet.");
        bytes32 usersKeyHash = keccak256(abi.encodePacked(wallet, week));
        uint256[] memory result = addressEntries[usersKeyHash];
        return result;
    }

    function checkNumbers(uint256 week, address wallet) public view virtual returns(bool){
        require(week <= currentTicket, "The Week you have requested has not happened yet.");
        bool result = false;
         bytes32 usersKeyHash = keccak256(abi.encodePacked(wallet, week));
        for(uint256 i = 0; i < pastWinningNumbers[week].length; i++){
            for(uint256 x = 0; x < addressEntries[usersKeyHash].length; x++){
                if(addressEntries[usersKeyHash][x] == pastWinningNumbers[week][i]){
                    result = true;
                }
             }
            }
            return result;
        }

    function prizePool() public view virtual returns (uint256){
        //Repersented in WEI
        uint256 currentPrizePool = (3 * (address(this).balance/100*prizePercentagePerWinner));
        return currentPrizePool;
    }

    function findOwner(uint256 tokenID) public view virtual returns (address){
    /*If this Function Fails, a Owner cannot be determined.
    If used in the Reward Function, the Funds will be Returned to the ETLOTTOWALLET and
    the Funds will then be sent to the Winner Manually this will likely never happen
    but that explains why ownerOfTicket is set to the ETLOTTO address when initialized*/
    address ownerOfTicket = ETLottoWallet; 
     require(tokenID < entriesCounter, "This Ticket has not been Purchased yet");
    if(entries[tokenID]!= address(0)){
        ownerOfTicket = entries[tokenID];
    }
    else if(tokenID < maxTicketsPerTX){
            for(int i = int((tokenID - 1)); i >= 0; i--){
            if(entries[uint256(i)]!= address(0)){
                ownerOfTicket = entries[uint256(i)];
                break;
            }
        }
    }else{
        for(uint256 i = (tokenID - 1); i >= (tokenID - 4); i--){
            if(entries[i]!= address(0)){
                ownerOfTicket = entries[i];
                break;
            }
        }
    }
    return ownerOfTicket;
    }

    function purchaseTicket(uint256 amount) external payable {
        /* Created by & Property of EtherLotto*/
        require(amount > 0, "Amount must be greater than 0.");
        require(isTicketSalesActive, "Ticket Sales are currently closed.");
        require(amount <= maxTicketsPerTX, "Only 5 Tickets per Ticket Sheet.");
        require(msg.value >= pricePerTicket.mul(amount),
         "0.0001 eth per Ticket"
        );
        bytes32 usersKeyHash = keccak256(abi.encodePacked(msg.sender, currentTicket));
        uint256 tempEntries = entriesCounter;
        for(uint256 i = 0; i < amount; i++){
        addressEntries[usersKeyHash].push(tempEntries);
         tempEntries++;
        }
        _mint(msg.sender, currentTicket, amount,"");
        entries[entriesCounter] = msg.sender;
        entriesCounter += amount;
    }

        function startNextWeeksLottery() external payable onlyOwner {
        /* Created by & Property of EtherLotto*/
        currentTicket++;
        _mint(msg.sender, currentTicket, 1,"");
        entriesCounter = 0;
        isTicketSalesActive = true;
    }

    function manualWithdraw(address payable _to, uint _amount) public onlyOwner nonReentrant {
        _to.transfer(_amount);
    }


    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal
        override(ERC1155, ERC1155Supply)
    {
        require(from == address(0) || to == address(0), "Tickets are Non-Transferable");
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }

     function _afterTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override virtual {
        if(from == address(0)){
            emit Attest(to, ids);
        }else if (to == address(0)){
            emit Revoke(to, ids);
        }
    }
    /* ---- */
    /* Created by & Property of EtherLotto*/
}




/* Created by & Property of EtherLotto*/