{"SourceCode": "// File: contracts/MultiSigInterface.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\n// File: contracts/MultiSigToolsWithReward.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\ncontract RewardInterface{\r\n  function reward(address payable to, uint256 amount) public;\r\n}\r\n\r\n//We do not inherit from MultiSigTools\r\ncontract MultiSigToolsWithReward{\r\n  MultiSigInterface public multisig_contract;\r\n  RewardInterface public reward_contract;\r\n\r\n  constructor(address _contract, address _rewarder) public{\r\n    require(_contract!= address(0x0));\r\n    reward_contract = RewardInterface(_rewarder);\r\n\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    uint256 gas_start = gasleft();\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n    uint256 gasused = (gas_start - gasleft()) * tx.gasprice;\r\n    if(reward_contract != RewardInterface(0x0)){\r\n      reward_contract.reward(tx.origin, gasused);\r\n    }\r\n  }\r\n\r\n  modifier is_majority_sig_with_hash(uint64 id, string memory name, bytes32 hash) {\r\n    uint256 gas_start = gasleft();\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n    uint256 gasused = (gas_start - gasleft()) * tx.gasprice;\r\n    if(reward_contract != RewardInterface(0x0)){\r\n      reward_contract.reward(tx.origin, gasused);\r\n    }\r\n  }\r\n\r\n  event ChangeRewarder(address _old, address _new);\r\n  function changeRewarder(uint64 id, address _rewarder) public only_signer\r\n  is_majority_sig(id, \"changeRewarder\"){\r\n    address old = address(reward_contract);\r\n    reward_contract = RewardInterface(_rewarder);\r\n    emit ChangeRewarder(old, _rewarder);\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\n\r\n// File: contracts/erc20/IERC20.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/utils/TokenClaimer.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        uint balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\n// File: contracts/MultiSigBody.sol\r\n\r\npragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n\r\ncontract MultiSigBody is MultiSigToolsWithReward, TokenClaimer{\r\n\r\n  constructor(address _multisig, address _reward) MultiSigToolsWithReward(_multisig, _reward) public{}\r\n\r\n  function call_contract(uint64 id, address _addr, bytes memory _data, uint256 _value)\r\n    public only_signer is_majority_sig(id, \"call_contract\"){\r\n    (bool success,) = _addr.call.value(_value)(_data);\r\n    require(success, \"MultisigBody call failed\");\r\n  }\r\n\r\n  function claimStdTokens(uint64 id, address _token, address payable to)\r\n  public only_signer is_majority_sig(id, \"claimStdTokens\"){\r\n    _claimStdTokens(_token, to);\r\n  }\r\n\r\n  event RecvETH(uint256 v);\r\n  function() external payable{\r\n    emit RecvETH(msg.value);\r\n  }\r\n}\r\n\r\ncontract MultiSigBodyFactory{\r\n\r\n  event NewMultiSigBody(address addr, address _multisig);\r\n  function createMultiSig(address _multisig, address _reward) public returns(address){\r\n    MultiSigBody ms = new MultiSigBody(_multisig, _reward);\r\n    emit NewMultiSigBody(address(ms), _multisig);\r\n    return address(ms);\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimStdTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transfer_multisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"call_contract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_rewarder\",\"type\":\"address\"}],\"name\":\"changeRewarder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"},{\"name\":\"_reward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"RecvETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ChangeRewarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"TransferMultiSig\",\"type\":\"event\"}]", "ContractName": "MultiSigBody", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006eef7326b056f72cb5b4f6bb8e9998d7667637260000000000000000000000008ed2fa61f77290a1a9759011708ea9f0fd385b51", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://81c2ccdfcddde2a2cdba03192cd8d64d64ae40f50270b1b062c0da50ba0b9ade"}