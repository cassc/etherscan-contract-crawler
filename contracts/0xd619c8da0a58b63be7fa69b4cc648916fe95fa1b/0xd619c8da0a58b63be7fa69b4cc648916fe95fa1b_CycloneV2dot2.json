{"SourceCode": "// File: contracts/math/SafeMath.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n\r\n  /*@CTK SafeMath_mul\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a * b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  /*@CTK SafeMath_div\r\n    @tag spec\r\n    @pre b != 0\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a / b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  /*@CTK SafeMath_sub\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a - b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  /*@CTK SafeMath_add\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a + b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/token/IERC20Basic.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract IERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IERC20.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20 is IERC20Basic {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IMintableToken.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\ncontract IMintableToken is IERC20 {\r\n    function mint(address, uint) external returns (bool);\r\n    function burn(uint) external returns (bool);\r\n\r\n    event Minted(address indexed to, uint256 amount);\r\n    event Burned(address indexed from, uint256 amount);\r\n    event MinterAdded(address indexed minter);\r\n    event MinterRemoved(address indexed minter);\r\n}\r\n\r\n// File: contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/zksnarklib/MerkleTreeWithHistory.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\nlibrary Hasher {\r\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) public pure returns (uint256 xL, uint256 xR);\r\n}\r\n\r\ncontract MerkleTreeWithHistory {\r\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\r\n\r\n  uint32 public levels;\r\n\r\n  // the following variables are made public for easier testing and debugging and\r\n  // are not supposed to be accessed in regular code\r\n  bytes32[] public filledSubtrees;\r\n  bytes32[] public zeros;\r\n  uint32 public currentRootIndex = 0;\r\n  uint32 public nextIndex = 0;\r\n  uint32 public constant ROOT_HISTORY_SIZE = 100;\r\n  bytes32[ROOT_HISTORY_SIZE] public roots;\r\n\r\n  constructor(uint32 _treeLevels) public {\r\n    require(_treeLevels > 0, \"_treeLevels should be greater than zero\");\r\n    require(_treeLevels < 32, \"_treeLevels should be less than 32\");\r\n    levels = _treeLevels;\r\n\r\n    bytes32 currentZero = bytes32(ZERO_VALUE);\r\n    zeros.push(currentZero);\r\n    filledSubtrees.push(currentZero);\r\n\r\n    for (uint32 i = 1; i < levels; i++) {\r\n      currentZero = hashLeftRight(currentZero, currentZero);\r\n      zeros.push(currentZero);\r\n      filledSubtrees.push(currentZero);\r\n    }\r\n\r\n    roots[0] = hashLeftRight(currentZero, currentZero);\r\n  }\r\n\r\n  /**\r\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\r\n  */\r\n  function hashLeftRight(bytes32 _left, bytes32 _right) public pure returns (bytes32) {\r\n    require(uint256(_left) < FIELD_SIZE, \"_left should be inside the field\");\r\n    require(uint256(_right) < FIELD_SIZE, \"_right should be inside the field\");\r\n    uint256 R = uint256(_left);\r\n    uint256 C = 0;\r\n    (R, C) = Hasher.MiMCSponge(R, C);\r\n    R = addmod(R, uint256(_right), FIELD_SIZE);\r\n    (R, C) = Hasher.MiMCSponge(R, C);\r\n    return bytes32(R);\r\n  }\r\n\r\n  function _insert(bytes32 _leaf) internal returns(uint32 index) {\r\n    uint32 currentIndex = nextIndex;\r\n    require(currentIndex != uint32(2)**levels, \"Merkle tree is full. No more leafs can be added\");\r\n    nextIndex += 1;\r\n    bytes32 currentLevelHash = _leaf;\r\n    bytes32 left;\r\n    bytes32 right;\r\n\r\n    for (uint32 i = 0; i < levels; i++) {\r\n      if (currentIndex % 2 == 0) {\r\n        left = currentLevelHash;\r\n        right = zeros[i];\r\n\r\n        filledSubtrees[i] = currentLevelHash;\r\n      } else {\r\n        left = filledSubtrees[i];\r\n        right = currentLevelHash;\r\n      }\r\n\r\n      currentLevelHash = hashLeftRight(left, right);\r\n\r\n      currentIndex /= 2;\r\n    }\r\n\r\n    currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\r\n    roots[currentRootIndex] = currentLevelHash;\r\n    return nextIndex - 1;\r\n  }\r\n\r\n  /**\r\n    @dev Whether the root is present in the root history\r\n  */\r\n  function isKnownRoot(bytes32 _root) public view returns(bool) {\r\n    if (_root == 0) {\r\n      return false;\r\n    }\r\n    uint32 i = currentRootIndex;\r\n    do {\r\n      if (_root == roots[i]) {\r\n        return true;\r\n      }\r\n      if (i == 0) {\r\n        i = ROOT_HISTORY_SIZE;\r\n      }\r\n      i--;\r\n    } while (i != currentRootIndex);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n    @dev Returns the last root\r\n  */\r\n  function getLastRoot() public view returns(bytes32) {\r\n    return roots[currentRootIndex];\r\n  }\r\n}\r\n\r\n// File: contracts/zksnarklib/IVerifier.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\ncontract IVerifier {\r\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) public returns(bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/CycloneV2dot2.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CycloneV2dot2 is MerkleTreeWithHistory, ReentrancyGuard {\r\n\r\n  using SafeMath for uint256;\r\n  uint256 public tokenDenomination; // (10K or 100k or 1M) * 10^18\r\n  uint256 public coinDenomination;\r\n  uint256 public initCYCDenomination;\r\n  mapping(bytes32 => bool) public nullifierHashes;\r\n  mapping(bytes32 => bool) public commitments; // we store all commitments just to prevent accidental deposits with the same commitment\r\n  IVerifier public verifier;\r\n  IERC20 public token;\r\n  IMintableToken public cycToken;\r\n  address public treasury;\r\n  address public govDAO;\r\n  uint256 public numOfShares;\r\n  uint256 public lastRewardBlock;\r\n  uint256 public rewardPerBlock;\r\n  uint256 public accumulateCYC;\r\n  uint256 public anonymityFee;\r\n\r\n  modifier onlyGovDAO {\r\n    // Start with an governance DAO address and will transfer to a governance DAO, e.g., Timelock + GovernorAlpha, after launch\r\n    require(msg.sender == govDAO, \"Only Governance DAO can call this function.\");\r\n    _;\r\n  }\r\n\r\n  event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp, uint256 cycDenomination, uint256 anonymityFee);\r\n  event Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 reward, uint256 relayerFee);\r\n  event RewardPerBlockUpdated(uint256 oldValue, uint256 newValue);\r\n  event AnonymityFeeUpdated(uint256 oldValue, uint256 newValue);\r\n\r\n  /**\r\n    @dev The constructor\r\n    @param _verifier the address of SNARK verifier for this contract\r\n    @param _merkleTreeHeight the height of deposits' Merkle Tree\r\n    @param _govDAO governance DAO address\r\n  */\r\n  constructor(\r\n    address _govDAO,\r\n    IERC20 _token,\r\n    IMintableToken _cycToken,\r\n    address _treasury,\r\n    uint256 _initCYCDenomination,\r\n    uint256 _coinDenomination,\r\n    uint256 _tokenDenomination,\r\n    uint256 _startBlock,\r\n    IVerifier _verifier,\r\n    uint32 _merkleTreeHeight\r\n  ) MerkleTreeWithHistory(_merkleTreeHeight) public {\r\n    require(address(_token) != address(_cycToken), \"token cannot be identical to CYC token\");\r\n    verifier = _verifier;\r\n    treasury = _treasury;\r\n    cycToken = _cycToken;\r\n    token = _token;\r\n    govDAO = _govDAO;\r\n    if (_startBlock < block.number) {\r\n      lastRewardBlock = block.number;\r\n    } else {\r\n      lastRewardBlock = _startBlock;\r\n    }\r\n    initCYCDenomination = _initCYCDenomination;\r\n    coinDenomination = _coinDenomination;\r\n    tokenDenomination = _tokenDenomination;\r\n    numOfShares = 0;\r\n  }\r\n\r\n  function calcAccumulateCYC() internal view returns (uint256) {\r\n    uint256 reward = block.number.sub(lastRewardBlock).mul(rewardPerBlock);\r\n    uint256 remaining = cycToken.balanceOf(address(this)).sub(accumulateCYC);\r\n    if (remaining < reward) {\r\n      reward = remaining;\r\n    }\r\n    return accumulateCYC.add(reward);\r\n  }\r\n\r\n  function updateBlockReward() public {\r\n    uint256 blockNumber = block.number;\r\n    if (blockNumber <= lastRewardBlock) {\r\n      return;\r\n    }\r\n    if (rewardPerBlock != 0) {\r\n      accumulateCYC = calcAccumulateCYC();\r\n    }\r\n    // always update lastRewardBlock no matter there is sufficient reward or not\r\n    lastRewardBlock = blockNumber;\r\n  }\r\n\r\n  function cycDenomination() public view returns (uint256) {\r\n    if (numOfShares == 0) {\r\n      return initCYCDenomination;\r\n    }\r\n    uint256 blockNumber = block.number;\r\n    uint256 accCYC = accumulateCYC;\r\n    if (blockNumber > lastRewardBlock && rewardPerBlock > 0) {\r\n      accCYC = calcAccumulateCYC();\r\n    }\r\n    return accCYC.add(numOfShares - 1).div(numOfShares);\r\n  }\r\n\r\n  /**\r\n    @dev Deposit funds into the contract. The caller must send (for Coin) or approve (for ERC20) value equal to or `denomination` of this instance.\r\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\r\n  */\r\n  function deposit(bytes32 _commitment) external payable nonReentrant {\r\n    require(!commitments[_commitment], \"The commitment has been submitted\");\r\n    require(msg.value >= coinDenomination, \"insufficient coin amount\");\r\n    uint256 refund = msg.value - coinDenomination;\r\n    uint32 insertedIndex = _insert(_commitment);\r\n    commitments[_commitment] = true;\r\n    updateBlockReward();\r\n    uint256 cycDeno = cycDenomination();\r\n    uint256 fee = anonymityFee;\r\n    if (cycDeno.add(fee) > 0) {\r\n      require(cycToken.transferFrom(msg.sender, address(this), cycDeno.add(fee)), \"insufficient CYC allowance\");\r\n    }\r\n    if (fee > 0) {\r\n      address t = treasury;\r\n      if (t == address(0)) {\r\n        require(cycToken.burn(fee), \"failed to burn anonymity fee\");\r\n      } else {\r\n        require(safeTransfer(cycToken, t, fee), \"failed to transfer anonymity fee\");\r\n      }\r\n    }\r\n    uint256 td = tokenDenomination;\r\n    if (td > 0) {\r\n      require(token.transferFrom(msg.sender, address(this), td), \"insufficient allowance\");\r\n    }\r\n    accumulateCYC += cycDeno;\r\n    numOfShares += 1;\r\n    if (refund > 0) {\r\n      (bool success, ) = msg.sender.call.value(refund)(\"\");\r\n      require(success, \"failed to refund\");\r\n    }\r\n    emit Deposit(_commitment, insertedIndex, block.timestamp, cycDeno, fee);\r\n  }\r\n\r\n  /**\r\n    @dev Withdraw a deposit from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\r\n    `input` array consists of:\r\n      - merkle root of all deposits in the contract\r\n      - hash of unique deposit nullifier to prevent double spends\r\n      - the recipient of funds\r\n      - optional fee that goes to the transaction sender (usually a relay)\r\n  */\r\n  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _relayerFee, uint256 _refund) external payable nonReentrant {\r\n    require(_refund == 0, \"refund is not zero\");\r\n    require(!Address.isContract(_recipient), \"recipient of cannot be contract\");\r\n    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");\r\n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\r\n    require(verifier.verifyProof(_proof, [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _relayerFee, _refund]), \"Invalid withdraw proof\");\r\n\r\n    nullifierHashes[_nullifierHash] = true;\r\n    uint256 td = tokenDenomination;\r\n    if (td > 0) {\r\n      require(safeTransfer(token, _recipient, td), \"failed to withdraw token\");\r\n    }\r\n    updateBlockReward();\r\n    uint256 relayerFee = 0;\r\n    // numOfShares should be larger than 0\r\n    uint256 cycDeno = accumulateCYC.div(numOfShares);\r\n    if (cycDeno > 0) {\r\n      accumulateCYC -= cycDeno;\r\n      require(safeTransfer(cycToken, _recipient, cycDeno), \"failed to reward CYC\");\r\n    }\r\n    uint256 cd = coinDenomination;\r\n    if (_relayerFee > cd) {\r\n      _relayerFee = cd;\r\n    }\r\n    if (_relayerFee > 0) {\r\n      (bool success,) = _relayer.call.value(_relayerFee)(\"\");\r\n      require(success, \"failed to send relayer fee\");\r\n      cd -= _relayerFee;\r\n    }\r\n    if (cd > 0) {\r\n      (bool success,) = _recipient.call.value(cd)(\"\");\r\n      require(success, \"failed to withdraw coin\");\r\n    }\r\n    numOfShares -= 1;\r\n    emit Withdrawal(_recipient, _nullifierHash, _relayer, cycDeno, relayerFee);\r\n  }\r\n\r\n  /** @dev whether a note is already spent */\r\n  function isSpent(bytes32 _nullifierHash) public view returns(bool) {\r\n    return nullifierHashes[_nullifierHash];\r\n  }\r\n\r\n  /** @dev whether an array of notes is already spent */\r\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns(bool[] memory spent) {\r\n    spent = new bool[](_nullifierHashes.length);\r\n    for(uint i = 0; i < _nullifierHashes.length; i++) {\r\n      if (isSpent(_nullifierHashes[i])) {\r\n        spent[i] = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n    @dev allow governance DAO to update SNARK verification keys. This is needed to\r\n    update keys if tornado.cash update their keys in production.\r\n  */\r\n  function updateVerifier(address _newVerifier) external onlyGovDAO {\r\n    verifier = IVerifier(_newVerifier);\r\n  }\r\n\r\n  /** @dev governance DAO can change his address */\r\n  function changeGovDAO(address _newGovDAO) external onlyGovDAO {\r\n    govDAO = _newGovDAO;\r\n  }\r\n\r\n  function setRewardPerBlock(uint256 _rewardPerBlock) public onlyGovDAO {\r\n    updateBlockReward();\r\n    emit RewardPerBlockUpdated(rewardPerBlock, _rewardPerBlock);\r\n    rewardPerBlock = _rewardPerBlock;\r\n  }\r\n\r\n  function setAnonymityFee(uint256 _fee) public onlyGovDAO {\r\n    emit AnonymityFeeUpdated(anonymityFee, _fee);\r\n    anonymityFee = _fee;\r\n  }\r\n\r\n  // Safe transfer function, just in case if rounding error causes pool to not have enough CYCs.\r\n  function safeTransfer(IERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n    uint256 balance = _token.balanceOf(address(this));\r\n    if (_amount > balance) {\r\n      return _token.transfer(_to, balance);\r\n    }\r\n    return _token.transfer(_to, _amount);\r\n  }\r\n\r\n  function version() public pure returns(string memory) {\r\n    return \"2.2\";\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_govDAO\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IMintableToken\",\"name\":\"_cycToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initCYCDenomination\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_coinDenomination\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenDenomination\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"contract IVerifier\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_merkleTreeHeight\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"AnonymityFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"leafIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycDenomination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"anonymityFee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"RewardPerBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nullifierHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIELD_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accumulateCYC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anonymityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovDAO\",\"type\":\"address\"}],\"name\":\"changeGovDAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinDenomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycDenomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycToken\",\"outputs\":[{\"internalType\":\"contract IMintableToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_commitment\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filledSubtrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"govDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_left\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initCYCDenomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_nullifierHashes\",\"type\":\"bytes32[]\"}],\"name\":\"isSpentArray\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"spent\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nullifierHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setAnonymityFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDenomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateBlockReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVerifier\",\"type\":\"address\"}],\"name\":\"updateVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zeros\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CycloneV2dot2", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000095541045f8ee77ca825f50f21bfb1a9fd1e6bb9200000000000000000000000000000000000000000000000000000000000000000000000000000000000000008861cff2366c1128fd699b68304ad99a0764ef9a00000000000000000000000092d221682384a3ad3549b8b8ea992c9048cf222800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000badc7e0000000000000000000000007c994fb3a8c208c1750df937d473040c604292d60000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "Hasher:949452e32db13a5771445cf20b304474b866202b", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://531943d2b3b8387402b223b88881314e80deba75b26402bd25719f7474e5bc62"}