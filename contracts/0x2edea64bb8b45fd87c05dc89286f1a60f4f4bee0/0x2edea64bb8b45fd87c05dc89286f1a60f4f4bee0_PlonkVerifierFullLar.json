{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/verifiers/PlonkVerifierFullLarge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n// Copyright 2023 Consensys Software Inc.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//     http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n// Code generated by gnark DO NOT EDIT\\n\\npragma solidity 0.8.19;\\n\\n/// @custom:security-contact security-report@linea.build\\ncontract PlonkVerifierFullLarge {\\n  uint256 private constant R_MOD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n  uint256 private constant P_MOD = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n  uint256 private constant G2_SRS_0_X_0 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\n  uint256 private constant G2_SRS_0_X_1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\n  uint256 private constant G2_SRS_0_Y_0 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\\n  uint256 private constant G2_SRS_0_Y_1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\\n\\n  uint256 private constant G2_SRS_1_X_0 = 15805639136721018565402881920352193254830339253282065586954346329754995870280;\\n  uint256 private constant G2_SRS_1_X_1 = 19089565590083334368588890253123139704298730990782503769911324779715431555531;\\n  uint256 private constant G2_SRS_1_Y_0 = 9779648407879205346559610309258181044130619080926897934572699915909528404984;\\n  uint256 private constant G2_SRS_1_Y_1 = 6779728121489434657638426458390319301070371227460768374343986326751507916979;\\n\\n  uint256 private constant G1_SRS_X = 14312776538779914388377568895031746459131577658076416373430523308756343304251;\\n  uint256 private constant G1_SRS_Y = 11763105256161367503191792604679297387056316997144156930871823008787082098465;\\n\\n  // ----------------------- vk ---------------------\\n  uint256 private constant VK_DOMAIN_SIZE = 33554432;\\n  uint256 private constant VK_INV_DOMAIN_SIZE =\\n    21888242219518804655518433051623070663413851959604507555939307129453691614729;\\n  uint256 private constant VK_OMEGA = 19200870435978225707111062059747084165650991997241425080699860725083300967194;\\n  uint256 private constant VK_QL_COM_X = 2617274548392742086221675718626108495580026445070702085720764759729742274702;\\n  uint256 private constant VK_QL_COM_Y = 16696221030853986682145642215315444470616356869040362015848133367005921991713;\\n  uint256 private constant VK_QR_COM_X = 6599909786844147782492564629557938752442410610222054180395266325750294784951;\\n  uint256 private constant VK_QR_COM_Y = 5225078811817232704589429416798470098477940842060066773305168115364589978443;\\n  uint256 private constant VK_QM_COM_X = 17454191387944269420175451539985259436690291522981315783219623265844345698589;\\n  uint256 private constant VK_QM_COM_Y = 6344287208388560201036176432800485063911887048288125973141558199297133878560;\\n  uint256 private constant VK_QO_COM_X = 4186355463394989186018043938805143942119056490323755572549347888893923999534;\\n  uint256 private constant VK_QO_COM_Y = 20591595451129030413827017459038770099256001732943107721845648951826987370169;\\n  uint256 private constant VK_QK_COM_X = 5536275240059164571547993327712000084952803616534576176688932386504246289843;\\n  uint256 private constant VK_QK_COM_Y = 14389474271467577609153928352406972536897125704947519940961967277462468271069;\\n\\n  uint256 private constant VK_S1_COM_X = 19806530398402103017065614807436031199081816179718497416540441929750669732322;\\n  uint256 private constant VK_S1_COM_Y = 1875788724587211523576551515973730113019833445297013205719390132403927822045;\\n\\n  uint256 private constant VK_S2_COM_X = 15421368547520933544640960982107364216216385878450673366232497427772343129971;\\n  uint256 private constant VK_S2_COM_Y = 3673614483211913823278220451052207055479420783453522585058927154945462754484;\\n\\n  uint256 private constant VK_S3_COM_X = 8663469170362401223692002888778803117359367518633208360124789216459246427152;\\n  uint256 private constant VK_S3_COM_Y = 16540939699758428504236764361691843983238893645937191471155459538113395017943;\\n\\n  uint256 private constant VK_COSET_SHIFT = 5;\\n\\n  uint256 private constant VK_QCP_0_X = 18110014477997347336338979058973643058842551209195781046856529522527916786447;\\n  uint256 private constant VK_QCP_0_Y = 19639708061888844973927170488633495563380979556086718140567617121712219973256;\\n\\n  uint256 private constant VK_INDEX_COMMIT_API0 = 20184838;\\n\\n  uint256 private constant VK_NB_CUSTOM_GATES = 1;\\n\\n  // ------------------------------------------------\\n\\n  // offset proof\\n  uint256 private constant PROOF_L_COM_X = 0x00;\\n  uint256 private constant PROOF_L_COM_Y = 0x20;\\n  uint256 private constant PROOF_R_COM_X = 0x40;\\n  uint256 private constant PROOF_R_COM_Y = 0x60;\\n  uint256 private constant PROOF_O_COM_X = 0x80;\\n  uint256 private constant PROOF_O_COM_Y = 0xa0;\\n\\n  // h = h_0 + x^{n+2}h_1 + x^{2(n+2)}h_2\\n  uint256 private constant PROOF_H_0_X = 0xc0;\\n  uint256 private constant PROOF_H_0_Y = 0xe0;\\n  uint256 private constant PROOF_H_1_X = 0x100;\\n  uint256 private constant PROOF_H_1_Y = 0x120;\\n  uint256 private constant PROOF_H_2_X = 0x140;\\n  uint256 private constant PROOF_H_2_Y = 0x160;\\n\\n  // wire values at zeta\\n  uint256 private constant PROOF_L_AT_ZETA = 0x180;\\n  uint256 private constant PROOF_R_AT_ZETA = 0x1a0;\\n  uint256 private constant PROOF_O_AT_ZETA = 0x1c0;\\n\\n  //uint256[STATE_WIDTH-1] permutation_polynomials_at_zeta; // S\u03c31(zeta),S\u03c32(zeta)\\n  uint256 private constant PROOF_S1_AT_ZETA = 0x1e0; // S\u03c31(zeta)\\n  uint256 private constant PROOF_S2_AT_ZETA = 0x200; // S\u03c32(zeta)\\n\\n  //Bn254.G1Point grand_product_commitment;                 // [z(x)]\\n  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_X = 0x220;\\n  uint256 private constant PROOF_GRAND_PRODUCT_COMMITMENT_Y = 0x240;\\n\\n  uint256 private constant PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA = 0x260; // z(w*zeta)\\n  uint256 private constant PROOF_QUOTIENT_POLYNOMIAL_AT_ZETA = 0x280; // t(zeta)\\n  uint256 private constant PROOF_LINEARISED_POLYNOMIAL_AT_ZETA = 0x2a0; // r(zeta)\\n\\n  // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp\\n  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_X = 0x2c0; // [Wzeta]\\n  uint256 private constant PROOF_BATCH_OPENING_AT_ZETA_Y = 0x2e0;\\n\\n  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_X = 0x300;\\n  uint256 private constant PROOF_OPENING_AT_ZETA_OMEGA_Y = 0x320;\\n\\n  uint256 private constant PROOF_OPENING_QCP_AT_ZETA = 0x340;\\n  uint256 private constant PROOF_COMMITMENTS_WIRES_CUSTOM_GATES = 0x360;\\n\\n  // -> next part of proof is\\n  // [ openings_selector_commits || commitments_wires_commit_api]\\n\\n  // -------- offset state\\n\\n  // challenges to check the claimed quotient\\n  uint256 private constant STATE_ALPHA = 0x00;\\n  uint256 private constant STATE_BETA = 0x20;\\n  uint256 private constant STATE_GAMMA = 0x40;\\n  uint256 private constant STATE_ZETA = 0x60;\\n\\n  // reusable value\\n  uint256 private constant STATE_ALPHA_SQUARE_LAGRANGE_0 = 0x80;\\n\\n  // commitment to H\\n  uint256 private constant STATE_FOLDED_H_X = 0xa0;\\n  uint256 private constant STATE_FOLDED_H_Y = 0xc0;\\n\\n  // commitment to the linearised polynomial\\n  uint256 private constant STATE_LINEARISED_POLYNOMIAL_X = 0xe0;\\n  uint256 private constant STATE_LINEARISED_POLYNOMIAL_Y = 0x100;\\n\\n  // Folded proof for the opening of H, linearised poly, l, r, o, s_1, s_2, qcp\\n  uint256 private constant STATE_FOLDED_CLAIMED_VALUES = 0x120;\\n\\n  // folded digests of H, linearised poly, l, r, o, s_1, s_2, qcp\\n  uint256 private constant STATE_FOLDED_DIGESTS_X = 0x140;\\n  uint256 private constant STATE_FOLDED_DIGESTS_Y = 0x160;\\n\\n  uint256 private constant STATE_PI = 0x180;\\n\\n  uint256 private constant STATE_ZETA_POWER_N_MINUS_ONE = 0x1a0;\\n\\n  uint256 private constant STATE_GAMMA_KZG = 0x1c0;\\n\\n  uint256 private constant STATE_SUCCESS = 0x1e0;\\n  uint256 private constant STATE_CHECK_VAR = 0x200; // /!\\\\ this slot is used for debugging only\\n\\n  uint256 private constant STATE_LAST_MEM = 0x220;\\n\\n  // -------- errors\\n  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)\\n\\n  // -------- utils (for hash_fr)\\n  uint256 private constant HASH_FR_BB = 340282366920938463463374607431768211456; // 2**128\\n  uint256 private constant HASH_FR_ZERO_UINT256 = 0;\\n\\n  uint8 private constant HASH_FR_LEN_IN_BYTES = 48;\\n  uint8 private constant HASH_FR_SIZE_DOMAIN = 11;\\n  uint8 private constant HASH_FR_ONE = 1;\\n  uint8 private constant HASH_FR_TWO = 2;\\n\\n  /// Verify a Plonk proof.\\n  /// Reverts if the proof or the public inputs are malformed.\\n  /// @param proof serialised plonk proof (using gnark's MarshalSolidity)\\n  /// @param public_inputs (must be reduced)\\n  /// @return success true if the proof passes false otherwise\\n  function Verify(bytes calldata proof, uint256[] calldata public_inputs) public view returns (bool success) {\\n    assembly {\\n      let mem := mload(0x40)\\n      let freeMem := add(mem, STATE_LAST_MEM)\\n\\n      // sanity checks\\n      check_inputs_size(public_inputs.length, public_inputs.offset)\\n      check_proof_size(proof.length)\\n      check_proof_openings_size(proof.offset)\\n\\n      // compute the challenges\\n      let prev_challenge_non_reduced\\n      prev_challenge_non_reduced := derive_gamma(proof.offset, public_inputs.length, public_inputs.offset)\\n      prev_challenge_non_reduced := derive_beta(prev_challenge_non_reduced)\\n      prev_challenge_non_reduced := derive_alpha(proof.offset, prev_challenge_non_reduced)\\n      derive_zeta(proof.offset, prev_challenge_non_reduced)\\n\\n      // evaluation of Z=X\u207f-1 at \u03b6, we save this value\\n      let zeta := mload(add(mem, STATE_ZETA))\\n      let zeta_power_n_minus_one := addmod(pow(zeta, VK_DOMAIN_SIZE, freeMem), sub(R_MOD, 1), R_MOD)\\n      mstore(add(mem, STATE_ZETA_POWER_N_MINUS_ONE), zeta_power_n_minus_one)\\n\\n      // public inputs contribution\\n      let l_pi := sum_pi_wo_api_commit(public_inputs.offset, public_inputs.length, freeMem)\\n      let l_wocommit := sum_pi_commit(proof.offset, public_inputs.length, freeMem)\\n      l_pi := addmod(l_wocommit, l_pi, R_MOD)\\n      mstore(add(mem, STATE_PI), l_pi)\\n\\n      compute_alpha_square_lagrange_0()\\n      verify_quotient_poly_eval_at_zeta(proof.offset)\\n      fold_h(proof.offset)\\n      compute_commitment_linearised_polynomial(proof.offset)\\n      compute_gamma_kzg(proof.offset)\\n      fold_state(proof.offset)\\n      batch_verify_multi_points(proof.offset)\\n\\n      success := mload(add(mem, STATE_SUCCESS))\\n\\n      // Beginning errors -------------------------------------------------\\n\\n      /// Called when an operation on Bn254 fails\\n      /// @dev for instance when calling EcMul on a point not on Bn254.\\n      function error_ec_op() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0x12)\\n        mstore(add(ptError, 0x44), \\\"error ec operation\\\")\\n        revert(ptError, 0x64)\\n      }\\n\\n      /// Called when one of the public inputs is not reduced.\\n      function error_inputs_size() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0x18)\\n        mstore(add(ptError, 0x44), \\\"inputs are bigger than r\\\")\\n        revert(ptError, 0x64)\\n      }\\n\\n      /// Called when the size proof is not as expected\\n      /// @dev to avoid overflow attack for instance\\n      function error_proof_size() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0x10)\\n        mstore(add(ptError, 0x44), \\\"wrong proof size\\\")\\n        revert(ptError, 0x64)\\n      }\\n\\n      /// Called when one the openings is bigger than r\\n      /// The openings are the claimed evalutions of a polynomial\\n      /// in a Kzg proof.\\n      function error_proof_openings_size() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0x16)\\n        mstore(add(ptError, 0x44), \\\"openings bigger than r\\\")\\n        revert(ptError, 0x64)\\n      }\\n\\n      function error_verify() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0xc)\\n        mstore(add(ptError, 0x44), \\\"error verify\\\")\\n        revert(ptError, 0x64)\\n      }\\n\\n      function error_random_generation() {\\n        let ptError := mload(0x40)\\n        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)\\n        mstore(add(ptError, 0x4), 0x20)\\n        mstore(add(ptError, 0x24), 0x14)\\n        mstore(add(ptError, 0x44), \\\"error random gen kzg\\\")\\n        revert(ptError, 0x64)\\n      }\\n      // end errors -------------------------------------------------\\n\\n      // Beginning checks -------------------------------------------------\\n\\n      /// Checks that the public inputs are < R_MOD.\\n      /// @param s number of public inputs\\n      /// @param p pointer to the public inputs array\\n      function check_inputs_size(s, p) {\\n        let input_checks := 1\\n        for {\\n          let i\\n        } lt(i, s) {\\n          i := add(i, 1)\\n        } {\\n          input_checks := and(input_checks, lt(calldataload(p), R_MOD))\\n          p := add(p, 0x20)\\n        }\\n        if iszero(input_checks) {\\n          error_inputs_size()\\n        }\\n      }\\n\\n      /// Checks if the proof is of the correct size\\n      /// @param actual_proof_size size of the proof (not the expected size)\\n      function check_proof_size(actual_proof_size) {\\n        let expected_proof_size := add(0x340, mul(VK_NB_CUSTOM_GATES, 0x60))\\n        if iszero(eq(actual_proof_size, expected_proof_size)) {\\n          error_proof_size()\\n        }\\n      }\\n\\n      /// Checks if the multiple openings of the polynomials are < R_MOD.\\n      /// @param aproof pointer to the beginning of the proof\\n      /// @dev the 'a' prepending proof is to have a local name\\n      function check_proof_openings_size(aproof) {\\n        let openings_check := 1\\n\\n        // linearised polynomial at zeta\\n        let p := add(aproof, PROOF_LINEARISED_POLYNOMIAL_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // quotient polynomial at zeta\\n        p := add(aproof, PROOF_QUOTIENT_POLYNOMIAL_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_L_AT_ZETA\\n        p := add(aproof, PROOF_L_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_R_AT_ZETA\\n        p := add(aproof, PROOF_R_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_O_AT_ZETA\\n        p := add(aproof, PROOF_O_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_S1_AT_ZETA\\n        p := add(aproof, PROOF_S1_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_S2_AT_ZETA\\n        p := add(aproof, PROOF_S2_AT_ZETA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA\\n        p := add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)\\n        openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n\\n        // PROOF_OPENING_QCP_AT_ZETA\\n\\n        p := add(aproof, PROOF_OPENING_QCP_AT_ZETA)\\n        for {\\n          let i := 0\\n        } lt(i, VK_NB_CUSTOM_GATES) {\\n          i := add(i, 1)\\n        } {\\n          openings_check := and(openings_check, lt(calldataload(p), R_MOD))\\n          p := add(p, 0x20)\\n        }\\n\\n        if iszero(openings_check) {\\n          error_proof_openings_size()\\n        }\\n      }\\n      // end checks -------------------------------------------------\\n\\n      // Beginning challenges -------------------------------------------------\\n\\n      /// Derive gamma as Sha256(<transcript>)\\n      /// @param aproof pointer to the proof\\n      /// @param nb_pi number of public inputs\\n      /// @param pi pointer to the array of public inputs\\n      /// @return the challenge gamma, not reduced\\n      /// @notice The transcript is the concatenation (in this order) of:\\n      /// * the word \\\"gamma\\\" in ascii, equal to [0x67,0x61,0x6d, 0x6d, 0x61] and encoded as a uint256.\\n      /// * the commitments to the permutation polynomials S1, S2, S3, where we concatenate the coordinates of those points\\n      /// * the commitments of Ql, Qr, Qm, Qo, Qk\\n      /// * the public inputs\\n      /// * the commitments of the wires related to the custom gates (commitments_wires_commit_api)\\n      /// * commitments to L, R, O (proof_<l,r,o>_com_<x,y>)\\n      /// The data described above is written starting at mPtr. \\\"gamma\\\" lies on 5 bytes,\\n      /// and is encoded as a uint256 number n. In basis b = 256, the number looks like this\\n      /// [0 0 0 .. 0x67 0x61 0x6d, 0x6d, 0x61]. The first non zero entry is at position 27=0x1b\\n      /// Gamma reduced (the actual challenge) is stored at add(state, state_gamma)\\n      function derive_gamma(aproof, nb_pi, pi) -> gamma_not_reduced {\\n        let state := mload(0x40)\\n        let mPtr := add(state, STATE_LAST_MEM)\\n\\n        // gamma\\n        // gamma in ascii is [0x67,0x61,0x6d, 0x6d, 0x61]\\n        // (same for alpha, beta, zeta)\\n        mstore(mPtr, 0x67616d6d61) // \\\"gamma\\\"\\n\\n        mstore(add(mPtr, 0x20), VK_S1_COM_X)\\n        mstore(add(mPtr, 0x40), VK_S1_COM_Y)\\n        mstore(add(mPtr, 0x60), VK_S2_COM_X)\\n        mstore(add(mPtr, 0x80), VK_S2_COM_Y)\\n        mstore(add(mPtr, 0xa0), VK_S3_COM_X)\\n        mstore(add(mPtr, 0xc0), VK_S3_COM_Y)\\n        mstore(add(mPtr, 0xe0), VK_QL_COM_X)\\n        mstore(add(mPtr, 0x100), VK_QL_COM_Y)\\n        mstore(add(mPtr, 0x120), VK_QR_COM_X)\\n        mstore(add(mPtr, 0x140), VK_QR_COM_Y)\\n        mstore(add(mPtr, 0x160), VK_QM_COM_X)\\n        mstore(add(mPtr, 0x180), VK_QM_COM_Y)\\n        mstore(add(mPtr, 0x1a0), VK_QO_COM_X)\\n        mstore(add(mPtr, 0x1c0), VK_QO_COM_Y)\\n        mstore(add(mPtr, 0x1e0), VK_QK_COM_X)\\n        mstore(add(mPtr, 0x200), VK_QK_COM_Y)\\n\\n        mstore(add(mPtr, 0x220), VK_QCP_0_X)\\n        mstore(add(mPtr, 0x240), VK_QCP_0_Y)\\n\\n        // public inputs\\n        let _mPtr := add(mPtr, 0x260)\\n        let size_pi_in_bytes := mul(nb_pi, 0x20)\\n        calldatacopy(_mPtr, pi, size_pi_in_bytes)\\n        _mPtr := add(_mPtr, size_pi_in_bytes)\\n\\n        // commitments to l, r, o\\n        let size_commitments_lro_in_bytes := 0xc0\\n        calldatacopy(_mPtr, aproof, size_commitments_lro_in_bytes)\\n        _mPtr := add(_mPtr, size_commitments_lro_in_bytes)\\n\\n        // total size is :\\n        // sizegamma(=0x5) + 11*64(=0x2c0)\\n        // + nb_public_inputs*0x20\\n        // + nb_custom gates*0x40\\n        let size := add(0x2c5, size_pi_in_bytes)\\n\\n        size := add(size, mul(VK_NB_CUSTOM_GATES, 0x40))\\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1b), size, mPtr, 0x20) //0x1b -> 000..\\\"gamma\\\"\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n        gamma_not_reduced := mload(mPtr)\\n        mstore(add(state, STATE_GAMMA), mod(gamma_not_reduced, R_MOD))\\n      }\\n\\n      /// derive beta as Sha256<transcript>\\n      /// @param gamma_not_reduced the previous challenge (gamma) not reduced\\n      /// @return beta_not_reduced the next challenge, beta, not reduced\\n      /// @notice the transcript consists of the previous challenge only.\\n      /// The reduced version of beta is stored at add(state, state_beta)\\n      function derive_beta(gamma_not_reduced) -> beta_not_reduced {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n\\n        // beta\\n        mstore(mPtr, 0x62657461) // \\\"beta\\\"\\n        mstore(add(mPtr, 0x20), gamma_not_reduced)\\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1c), 0x24, mPtr, 0x20) //0x1b -> 000..\\\"gamma\\\"\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n        beta_not_reduced := mload(mPtr)\\n        mstore(add(state, STATE_BETA), mod(beta_not_reduced, R_MOD))\\n      }\\n\\n      /// derive alpha as sha256<transcript>\\n      /// @param aproof pointer to the proof object\\n      /// @param beta_not_reduced the previous challenge (beta) not reduced\\n      /// @return alpha_not_reduced the next challenge, alpha, not reduced\\n      /// @notice the transcript consists of the previous challenge (beta)\\n      /// not reduced, the commitments to the wires associated to the QCP_i,\\n      /// and the commitment to the grand product polynomial\\n      function derive_alpha(aproof, beta_not_reduced) -> alpha_not_reduced {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n        let full_size := 0x65 // size(\\\"alpha\\\") + 0x20 (previous challenge)\\n\\n        // alpha\\n        mstore(mPtr, 0x616C706861) // \\\"alpha\\\"\\n        let _mPtr := add(mPtr, 0x20)\\n        mstore(_mPtr, beta_not_reduced)\\n        _mPtr := add(_mPtr, 0x20)\\n\\n        // Bsb22Commitments\\n        let proof_bsb_commitments := add(aproof, PROOF_COMMITMENTS_WIRES_CUSTOM_GATES)\\n        let size_bsb_commitments := mul(0x40, VK_NB_CUSTOM_GATES)\\n        calldatacopy(_mPtr, proof_bsb_commitments, size_bsb_commitments)\\n        _mPtr := add(_mPtr, size_bsb_commitments)\\n        full_size := add(full_size, size_bsb_commitments)\\n\\n        // [Z], the commitment to the grand product polynomial\\n        calldatacopy(_mPtr, add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), 0x40)\\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1b), full_size, mPtr, 0x20)\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n\\n        alpha_not_reduced := mload(mPtr)\\n        mstore(add(state, STATE_ALPHA), mod(alpha_not_reduced, R_MOD))\\n      }\\n\\n      /// derive zeta as sha256<transcript>\\n      /// @param aproof pointer to the proof object\\n      /// @param alpha_not_reduced the previous challenge (alpha) not reduced\\n      /// The transcript consists of the previous challenge and the commitment to\\n      /// the quotient polynomial h.\\n      function derive_zeta(aproof, alpha_not_reduced) {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n\\n        // zeta\\n        mstore(mPtr, 0x7a657461) // \\\"zeta\\\"\\n        mstore(add(mPtr, 0x20), alpha_not_reduced)\\n        calldatacopy(add(mPtr, 0x40), add(aproof, PROOF_H_0_X), 0xc0)\\n        let l_success := staticcall(gas(), 0x2, add(mPtr, 0x1c), 0xe4, mPtr, 0x20)\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n        let zeta_not_reduced := mload(mPtr)\\n        mstore(add(state, STATE_ZETA), mod(zeta_not_reduced, R_MOD))\\n      }\\n      // END challenges -------------------------------------------------\\n\\n      // BEGINNING compute_pi -------------------------------------------------\\n\\n      /// sum_pi_wo_api_commit computes the public inputs contributions,\\n      /// except for the public inputs coming from the custom gate\\n      /// @param ins pointer to the public inputs\\n      /// @param n number of public inputs\\n      /// @param mPtr free memory\\n      /// @return pi_wo_commit public inputs contribution (except the public inputs coming from the custom gate)\\n      function sum_pi_wo_api_commit(ins, n, mPtr) -> pi_wo_commit {\\n        let state := mload(0x40)\\n        let z := mload(add(state, STATE_ZETA))\\n        let zpnmo := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))\\n\\n        let li := mPtr\\n        batch_compute_lagranges_at_z(z, zpnmo, n, li)\\n\\n        let tmp := 0\\n        for {\\n          let i := 0\\n        } lt(i, n) {\\n          i := add(i, 1)\\n        } {\\n          tmp := mulmod(mload(li), calldataload(ins), R_MOD)\\n          pi_wo_commit := addmod(pi_wo_commit, tmp, R_MOD)\\n          li := add(li, 0x20)\\n          ins := add(ins, 0x20)\\n        }\\n      }\\n\\n      /// batch_compute_lagranges_at_z computes [L_0(z), .., L_{n-1}(z)]\\n      /// @param z point at which the Lagranges are evaluated\\n      /// @param zpnmo \u03b6\u207f-1\\n      /// @param n number of public inputs (number of Lagranges to compute)\\n      /// @param mPtr pointer to which the results are stored\\n      function batch_compute_lagranges_at_z(z, zpnmo, n, mPtr) {\\n        let zn := mulmod(zpnmo, VK_INV_DOMAIN_SIZE, R_MOD) // 1/n * (\u03b6\u207f - 1)\\n\\n        let _w := 1\\n        let _mPtr := mPtr\\n        for {\\n          let i := 0\\n        } lt(i, n) {\\n          i := add(i, 1)\\n        } {\\n          mstore(_mPtr, addmod(z, sub(R_MOD, _w), R_MOD))\\n          _w := mulmod(_w, VK_OMEGA, R_MOD)\\n          _mPtr := add(_mPtr, 0x20)\\n        }\\n        batch_invert(mPtr, n, _mPtr)\\n        _mPtr := mPtr\\n        _w := 1\\n        for {\\n          let i := 0\\n        } lt(i, n) {\\n          i := add(i, 1)\\n        } {\\n          mstore(_mPtr, mulmod(mulmod(mload(_mPtr), zn, R_MOD), _w, R_MOD))\\n          _mPtr := add(_mPtr, 0x20)\\n          _w := mulmod(_w, VK_OMEGA, R_MOD)\\n        }\\n      }\\n\\n      /// @notice Montgomery trick for batch inversion mod R_MOD\\n      /// @param ins pointer to the data to batch invert\\n      /// @param number of elements to batch invert\\n      /// @param mPtr free memory\\n      function batch_invert(ins, nb_ins, mPtr) {\\n        mstore(mPtr, 1)\\n        let offset := 0\\n        for {\\n          let i := 0\\n        } lt(i, nb_ins) {\\n          i := add(i, 1)\\n        } {\\n          let prev := mload(add(mPtr, offset))\\n          let cur := mload(add(ins, offset))\\n          cur := mulmod(prev, cur, R_MOD)\\n          offset := add(offset, 0x20)\\n          mstore(add(mPtr, offset), cur)\\n        }\\n        ins := add(ins, sub(offset, 0x20))\\n        mPtr := add(mPtr, offset)\\n        let inv := pow(mload(mPtr), sub(R_MOD, 2), add(mPtr, 0x20))\\n        for {\\n          let i := 0\\n        } lt(i, nb_ins) {\\n          i := add(i, 1)\\n        } {\\n          mPtr := sub(mPtr, 0x20)\\n          let tmp := mload(ins)\\n          let cur := mulmod(inv, mload(mPtr), R_MOD)\\n          mstore(ins, cur)\\n          inv := mulmod(inv, tmp, R_MOD)\\n          ins := sub(ins, 0x20)\\n        }\\n      }\\n\\n      /// Public inputs (the ones coming from the custom gate) contribution\\n      /// @param aproof pointer to the proof\\n      /// @param nb_public_inputs number of public inputs\\n      /// @param mPtr pointer to free memory\\n      /// @return pi_commit custom gate public inputs contribution\\n      function sum_pi_commit(aproof, nb_public_inputs, mPtr) -> pi_commit {\\n        let state := mload(0x40)\\n        let z := mload(add(state, STATE_ZETA))\\n        let zpnmo := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))\\n\\n        let p := add(aproof, PROOF_COMMITMENTS_WIRES_CUSTOM_GATES)\\n\\n        let h_fr, ith_lagrange\\n\\n        h_fr := hash_fr(calldataload(p), calldataload(add(p, 0x20)), mPtr)\\n        ith_lagrange := compute_ith_lagrange_at_z(z, zpnmo, add(nb_public_inputs, VK_INDEX_COMMIT_API0), mPtr)\\n        pi_commit := addmod(pi_commit, mulmod(h_fr, ith_lagrange, R_MOD), R_MOD)\\n        p := add(p, 0x40)\\n      }\\n\\n      /// Computes L_i(zeta) =  \u03c9\u2071/n * (\u03b6\u207f-1)/(\u03b6-\u03c9\u2071) where:\\n      /// @param z zeta\\n      /// @param zpmno \u03b6\u207f-1\\n      /// @param i i-th lagrange\\n      /// @param mPtr free memory\\n      /// @return res = \u03c9\u2071/n * (\u03b6\u207f-1)/(\u03b6-\u03c9\u2071)\\n      function compute_ith_lagrange_at_z(z, zpnmo, i, mPtr) -> res {\\n        let w := pow(VK_OMEGA, i, mPtr) // w**i\\n        i := addmod(z, sub(R_MOD, w), R_MOD) // z-w**i\\n        w := mulmod(w, VK_INV_DOMAIN_SIZE, R_MOD) // w**i/n\\n        i := pow(i, sub(R_MOD, 2), mPtr) // (z-w**i)**-1\\n        w := mulmod(w, i, R_MOD) // w**i/n*(z-w)**-1\\n        res := mulmod(w, zpnmo, R_MOD)\\n      }\\n\\n      /// @dev https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06#section-5.2\\n      /// @param x x coordinate of a point on Bn254(\ud835\udd3d_p)\\n      /// @param y y coordinate of a point on Bn254(\ud835\udd3d_p)\\n      /// @param mPtr free memory\\n      /// @return res an element mod R_MOD\\n      function hash_fr(x, y, mPtr) -> res {\\n        // [0x00, .. , 0x00 || x, y, || 0, 48, 0, dst, HASH_FR_SIZE_DOMAIN]\\n        // <-  64 bytes  ->  <-64b -> <-       1 bytes each     ->\\n\\n        // [0x00, .., 0x00] 64 bytes of zero\\n        mstore(mPtr, HASH_FR_ZERO_UINT256)\\n        mstore(add(mPtr, 0x20), HASH_FR_ZERO_UINT256)\\n\\n        // msg =  x || y , both on 32 bytes\\n        mstore(add(mPtr, 0x40), x)\\n        mstore(add(mPtr, 0x60), y)\\n\\n        // 0 || 48 || 0 all on 1 byte\\n        mstore8(add(mPtr, 0x80), 0)\\n        mstore8(add(mPtr, 0x81), HASH_FR_LEN_IN_BYTES)\\n        mstore8(add(mPtr, 0x82), 0)\\n\\n        // \\\"BSB22-Plonk\\\" = [42, 53, 42, 32, 32, 2d, 50, 6c, 6f, 6e, 6b,]\\n        mstore8(add(mPtr, 0x83), 0x42)\\n        mstore8(add(mPtr, 0x84), 0x53)\\n        mstore8(add(mPtr, 0x85), 0x42)\\n        mstore8(add(mPtr, 0x86), 0x32)\\n        mstore8(add(mPtr, 0x87), 0x32)\\n        mstore8(add(mPtr, 0x88), 0x2d)\\n        mstore8(add(mPtr, 0x89), 0x50)\\n        mstore8(add(mPtr, 0x8a), 0x6c)\\n        mstore8(add(mPtr, 0x8b), 0x6f)\\n        mstore8(add(mPtr, 0x8c), 0x6e)\\n        mstore8(add(mPtr, 0x8d), 0x6b)\\n\\n        // size domain\\n        mstore8(add(mPtr, 0x8e), HASH_FR_SIZE_DOMAIN)\\n\\n        let l_success := staticcall(gas(), 0x2, mPtr, 0x8f, mPtr, 0x20)\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n\\n        let b0 := mload(mPtr)\\n\\n        // [b0         || one || dst || HASH_FR_SIZE_DOMAIN]\\n        // <-64bytes ->  <-    1 byte each      ->\\n        mstore8(add(mPtr, 0x20), HASH_FR_ONE) // 1\\n\\n        mstore8(add(mPtr, 0x21), 0x42) // dst\\n        mstore8(add(mPtr, 0x22), 0x53)\\n        mstore8(add(mPtr, 0x23), 0x42)\\n        mstore8(add(mPtr, 0x24), 0x32)\\n        mstore8(add(mPtr, 0x25), 0x32)\\n        mstore8(add(mPtr, 0x26), 0x2d)\\n        mstore8(add(mPtr, 0x27), 0x50)\\n        mstore8(add(mPtr, 0x28), 0x6c)\\n        mstore8(add(mPtr, 0x29), 0x6f)\\n        mstore8(add(mPtr, 0x2a), 0x6e)\\n        mstore8(add(mPtr, 0x2b), 0x6b)\\n\\n        mstore8(add(mPtr, 0x2c), HASH_FR_SIZE_DOMAIN) // size domain\\n        l_success := staticcall(gas(), 0x2, mPtr, 0x2d, mPtr, 0x20)\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n\\n        // b1 is located at mPtr. We store b2 at add(mPtr, 0x20)\\n\\n        // [b0^b1      || two || dst || HASH_FR_SIZE_DOMAIN]\\n        // <-64bytes ->  <-    1 byte each      ->\\n        mstore(add(mPtr, 0x20), xor(mload(mPtr), b0))\\n        mstore8(add(mPtr, 0x40), HASH_FR_TWO)\\n\\n        mstore8(add(mPtr, 0x41), 0x42) // dst\\n        mstore8(add(mPtr, 0x42), 0x53)\\n        mstore8(add(mPtr, 0x43), 0x42)\\n        mstore8(add(mPtr, 0x44), 0x32)\\n        mstore8(add(mPtr, 0x45), 0x32)\\n        mstore8(add(mPtr, 0x46), 0x2d)\\n        mstore8(add(mPtr, 0x47), 0x50)\\n        mstore8(add(mPtr, 0x48), 0x6c)\\n        mstore8(add(mPtr, 0x49), 0x6f)\\n        mstore8(add(mPtr, 0x4a), 0x6e)\\n        mstore8(add(mPtr, 0x4b), 0x6b)\\n\\n        mstore8(add(mPtr, 0x4c), HASH_FR_SIZE_DOMAIN) // size domain\\n\\n        let offset := add(mPtr, 0x20)\\n        l_success := staticcall(gas(), 0x2, offset, 0x2d, offset, 0x20)\\n        if iszero(l_success) {\\n          error_verify()\\n        }\\n\\n        // at this point we have mPtr = [ b1 || b2] where b1 is on 32byes and b2 in 16bytes.\\n        // we interpret it as a big integer mod r in big endian (similar to regular decimal notation)\\n        // the result is then 2**(8*16)*mPtr[32:] + mPtr[32:48]\\n        res := mulmod(mload(mPtr), HASH_FR_BB, R_MOD) // <- res = 2**128 * mPtr[:32]\\n        let b1 := shr(128, mload(add(mPtr, 0x20))) // b1 <- [0, 0, .., 0 ||  b2[:16] ]\\n        res := addmod(res, b1, R_MOD)\\n      }\\n\\n      // END compute_pi -------------------------------------------------\\n\\n      /// @notice compute \u03b1\u00b2 * 1/n * (\u03b6{n}-1)/(\u03b6 - 1) where\\n      /// *  \u03b1 = challenge derived in derive_gamma_beta_alpha_zeta\\n      /// * n = vk_domain_size\\n      /// * \u03c9 = vk_omega (generator of the multiplicative cyclic group of order n in (\u2124/r\u2124)*)\\n      /// * \u03b6 = zeta (challenge derived with Fiat Shamir)\\n      function compute_alpha_square_lagrange_0() {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n\\n        let res := mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE))\\n        let den := addmod(mload(add(state, STATE_ZETA)), sub(R_MOD, 1), R_MOD)\\n        den := pow(den, sub(R_MOD, 2), mPtr)\\n        den := mulmod(den, VK_INV_DOMAIN_SIZE, R_MOD)\\n        res := mulmod(den, res, R_MOD)\\n\\n        let l_alpha := mload(add(state, STATE_ALPHA))\\n        res := mulmod(res, l_alpha, R_MOD)\\n        res := mulmod(res, l_alpha, R_MOD)\\n        mstore(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0), res)\\n      }\\n\\n      /// @notice follows alg. p.13 of https://eprint.iacr.org/2019/953.pdf\\n      /// with t\u2081 = t\u2082 = 1, and the proofs are ([digest] + [quotient] +purported evaluation):\\n      /// * [state_folded_state_digests], [proof_batch_opening_at_zeta_x], state_folded_evals\\n      /// * [proof_grand_product_commitment], [proof_opening_at_zeta_omega_x], [proof_grand_product_at_zeta_omega]\\n      /// @param aproof pointer to the proof\\n      function batch_verify_multi_points(aproof) {\\n        let state := mload(0x40)\\n        let mPtr := add(state, STATE_LAST_MEM)\\n\\n        // derive a random number. As there is no random generator, we\\n        // do an FS like challenge derivation, depending on both digests and\\n        // \u03b6 to ensure that the prover cannot control the random numger.\\n        // Note: adding the other point \u03b6\u03c9 is not needed, as \u03c9 is known beforehand.\\n        mstore(mPtr, mload(add(state, STATE_FOLDED_DIGESTS_X)))\\n        mstore(add(mPtr, 0x20), mload(add(state, STATE_FOLDED_DIGESTS_Y)))\\n        mstore(add(mPtr, 0x40), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X)))\\n        mstore(add(mPtr, 0x60), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_Y)))\\n        mstore(add(mPtr, 0x80), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X)))\\n        mstore(add(mPtr, 0xa0), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_Y)))\\n        mstore(add(mPtr, 0xc0), calldataload(add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X)))\\n        mstore(add(mPtr, 0xe0), calldataload(add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_Y)))\\n        mstore(add(mPtr, 0x100), mload(add(state, STATE_ZETA)))\\n        mstore(add(mPtr, 0x120), mload(add(state, STATE_GAMMA_KZG)))\\n        let random := staticcall(gas(), 0x2, mPtr, 0x140, mPtr, 0x20)\\n        if iszero(random) {\\n          error_random_generation()\\n        }\\n        random := mod(mload(mPtr), R_MOD) // use the same variable as we are one variable away from getting stack-too-deep error...\\n\\n        let folded_quotients := mPtr\\n        mPtr := add(folded_quotients, 0x40)\\n        mstore(folded_quotients, calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X)))\\n        mstore(add(folded_quotients, 0x20), calldataload(add(aproof, PROOF_BATCH_OPENING_AT_ZETA_Y)))\\n        point_acc_mul_calldata(folded_quotients, add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X), random, mPtr)\\n\\n        let folded_digests := add(state, STATE_FOLDED_DIGESTS_X)\\n        point_acc_mul_calldata(folded_digests, add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X), random, mPtr)\\n\\n        let folded_evals := add(state, STATE_FOLDED_CLAIMED_VALUES)\\n        fr_acc_mul_calldata(folded_evals, add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA), random)\\n\\n        let folded_evals_commit := mPtr\\n        mPtr := add(folded_evals_commit, 0x40)\\n        mstore(folded_evals_commit, G1_SRS_X)\\n        mstore(add(folded_evals_commit, 0x20), G1_SRS_Y)\\n        mstore(add(folded_evals_commit, 0x40), mload(folded_evals))\\n        let check_staticcall := staticcall(gas(), 7, folded_evals_commit, 0x60, folded_evals_commit, 0x40)\\n        if iszero(check_staticcall) {\\n          error_verify()\\n        }\\n\\n        let folded_evals_commit_y := add(folded_evals_commit, 0x20)\\n        mstore(folded_evals_commit_y, sub(P_MOD, mload(folded_evals_commit_y)))\\n        point_add(folded_digests, folded_digests, folded_evals_commit, mPtr)\\n\\n        let folded_points_quotients := mPtr\\n        mPtr := add(mPtr, 0x40)\\n        point_mul_calldata(\\n          folded_points_quotients,\\n          add(aproof, PROOF_BATCH_OPENING_AT_ZETA_X),\\n          mload(add(state, STATE_ZETA)),\\n          mPtr\\n        )\\n        let zeta_omega := mulmod(mload(add(state, STATE_ZETA)), VK_OMEGA, R_MOD)\\n        random := mulmod(random, zeta_omega, R_MOD)\\n        point_acc_mul_calldata(folded_points_quotients, add(aproof, PROOF_OPENING_AT_ZETA_OMEGA_X), random, mPtr)\\n\\n        point_add(folded_digests, folded_digests, folded_points_quotients, mPtr)\\n\\n        let folded_quotients_y := add(folded_quotients, 0x20)\\n        mstore(folded_quotients_y, sub(P_MOD, mload(folded_quotients_y)))\\n\\n        mstore(mPtr, mload(folded_digests))\\n        mstore(add(mPtr, 0x20), mload(add(folded_digests, 0x20)))\\n        mstore(add(mPtr, 0x40), G2_SRS_0_X_0) // the 4 lines are the canonical G2 point on BN254\\n        mstore(add(mPtr, 0x60), G2_SRS_0_X_1)\\n        mstore(add(mPtr, 0x80), G2_SRS_0_Y_0)\\n        mstore(add(mPtr, 0xa0), G2_SRS_0_Y_1)\\n        mstore(add(mPtr, 0xc0), mload(folded_quotients))\\n        mstore(add(mPtr, 0xe0), mload(add(folded_quotients, 0x20)))\\n        mstore(add(mPtr, 0x100), G2_SRS_1_X_0)\\n        mstore(add(mPtr, 0x120), G2_SRS_1_X_1)\\n        mstore(add(mPtr, 0x140), G2_SRS_1_Y_0)\\n        mstore(add(mPtr, 0x160), G2_SRS_1_Y_1)\\n        check_pairing_kzg(mPtr)\\n      }\\n\\n      /// @notice check_pairing_kzg checks the result of the final pairing product of the batched\\n      /// kzg verification. The purpose of this function is to avoid exhausting the stack\\n      /// in the function batch_verify_multi_points.\\n      /// @param mPtr pointer storing the tuple of pairs\\n      function check_pairing_kzg(mPtr) {\\n        let state := mload(0x40)\\n\\n        // TODO test the staticcall using the method from audit_4-5\\n        let l_success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)\\n        let res_pairing := mload(0x00)\\n        let s_success := mload(add(state, STATE_SUCCESS))\\n        res_pairing := and(and(res_pairing, l_success), s_success)\\n        mstore(add(state, STATE_SUCCESS), res_pairing)\\n      }\\n\\n      /// @notice Fold the opening proofs at \u03b6:\\n      /// * at state+state_folded_digest we store: [H] + \u03b3[Linearised_polynomial]+\u03b3\u00b2[L] + \u03b3\u00b3[R] + \u03b3\u2074[O] + \u03b3\u2075[S\u2081] +\u03b3\u2076[S\u2082] + \u2211\u1d62\u03b3\u2076\u207a\u2071[Pi_{i}]\\n      /// * at state+state_folded_claimed_values we store: H(\u03b6) + \u03b3Linearised_polynomial(\u03b6)+\u03b3\u00b2L(\u03b6) + \u03b3\u00b3R(\u03b6)+ \u03b3\u2074O(\u03b6) + \u03b3\u2075S\u2081(\u03b6) +\u03b3\u2076S\u2082(\u03b6) + \u2211\u1d62\u03b3\u2076\u207a\u2071Pi_{i}(\u03b6)\\n      /// @param aproof pointer to the proof\\n      /// acc_gamma stores the \u03b3\u2071\\n      function fold_state(aproof) {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n        let mPtr20 := add(mPtr, 0x20)\\n        let mPtr40 := add(mPtr, 0x40)\\n\\n        let l_gamma_kzg := mload(add(state, STATE_GAMMA_KZG))\\n        let acc_gamma := l_gamma_kzg\\n        let state_folded_digests := add(state, STATE_FOLDED_DIGESTS_X)\\n\\n        mstore(add(state, STATE_FOLDED_DIGESTS_X), mload(add(state, STATE_FOLDED_H_X)))\\n        mstore(add(state, STATE_FOLDED_DIGESTS_Y), mload(add(state, STATE_FOLDED_H_Y)))\\n        mstore(add(state, STATE_FOLDED_CLAIMED_VALUES), calldataload(add(aproof, PROOF_QUOTIENT_POLYNOMIAL_AT_ZETA)))\\n\\n        point_acc_mul(state_folded_digests, add(state, STATE_LINEARISED_POLYNOMIAL_X), acc_gamma, mPtr)\\n        fr_acc_mul_calldata(\\n          add(state, STATE_FOLDED_CLAIMED_VALUES),\\n          add(aproof, PROOF_LINEARISED_POLYNOMIAL_AT_ZETA),\\n          acc_gamma\\n        )\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        point_acc_mul_calldata(add(state, STATE_FOLDED_DIGESTS_X), add(aproof, PROOF_L_COM_X), acc_gamma, mPtr)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_L_AT_ZETA), acc_gamma)\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        point_acc_mul_calldata(state_folded_digests, add(aproof, PROOF_R_COM_X), acc_gamma, mPtr)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_R_AT_ZETA), acc_gamma)\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        point_acc_mul_calldata(state_folded_digests, add(aproof, PROOF_O_COM_X), acc_gamma, mPtr)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_O_AT_ZETA), acc_gamma)\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        mstore(mPtr, VK_S1_COM_X)\\n        mstore(mPtr20, VK_S1_COM_Y)\\n        point_acc_mul(state_folded_digests, mPtr, acc_gamma, mPtr40)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S1_AT_ZETA), acc_gamma)\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        mstore(mPtr, VK_S2_COM_X)\\n        mstore(mPtr20, VK_S2_COM_Y)\\n        point_acc_mul(state_folded_digests, mPtr, acc_gamma, mPtr40)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), add(aproof, PROOF_S2_AT_ZETA), acc_gamma)\\n        let poscaz := add(aproof, PROOF_OPENING_QCP_AT_ZETA)\\n\\n        acc_gamma := mulmod(acc_gamma, l_gamma_kzg, R_MOD)\\n        mstore(mPtr, VK_QCP_0_X)\\n        mstore(mPtr20, VK_QCP_0_Y)\\n        point_acc_mul(state_folded_digests, mPtr, acc_gamma, mPtr40)\\n        fr_acc_mul_calldata(add(state, STATE_FOLDED_CLAIMED_VALUES), poscaz, acc_gamma)\\n        poscaz := add(poscaz, 0x20)\\n      }\\n\\n      /// @notice generate the challenge (using Fiat Shamir) to fold the opening proofs\\n      /// at \u03b6.\\n      /// The process for deriving \u03b3 is the same as in derive_gamma but this time the inputs are\\n      /// in this order (the [] means it's a commitment):\\n      /// * \u03b6\\n      /// * [H] ( = H\u2081 + \u03b6\u1d50\u207a\u00b2*H\u2082 + \u03b6\u00b2\u207d\u1d50\u207a\u00b2\u207e*H\u2083 )\\n      /// * [Linearised polynomial]\\n      /// * [L], [R], [O]\\n      /// * [S\u2081] [S\u2082]\\n      /// * [Pi_{i}] (wires associated to custom gates)\\n      /// Then there are the purported evaluations of the previous committed polynomials:\\n      /// * H(\u03b6)\\n      /// * Linearised_polynomial(\u03b6)\\n      /// * L(\u03b6), R(\u03b6), O(\u03b6), S\u2081(\u03b6), S\u2082(\u03b6)\\n      /// * Pi_{i}(\u03b6)\\n      /// * Z(\u03b6\u03c9)\\n      /// @param aproof pointer to the proof\\n      function compute_gamma_kzg(aproof) {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n        mstore(mPtr, 0x67616d6d61) // \\\"gamma\\\"\\n        mstore(add(mPtr, 0x20), mload(add(state, STATE_ZETA)))\\n        mstore(add(mPtr, 0x40), mload(add(state, STATE_FOLDED_H_X)))\\n        mstore(add(mPtr, 0x60), mload(add(state, STATE_FOLDED_H_Y)))\\n        mstore(add(mPtr, 0x80), mload(add(state, STATE_LINEARISED_POLYNOMIAL_X)))\\n        mstore(add(mPtr, 0xa0), mload(add(state, STATE_LINEARISED_POLYNOMIAL_Y)))\\n        calldatacopy(add(mPtr, 0xc0), add(aproof, PROOF_L_COM_X), 0xc0)\\n        mstore(add(mPtr, 0x180), VK_S1_COM_X)\\n        mstore(add(mPtr, 0x1a0), VK_S1_COM_Y)\\n        mstore(add(mPtr, 0x1c0), VK_S2_COM_X)\\n        mstore(add(mPtr, 0x1e0), VK_S2_COM_Y)\\n\\n        let offset := 0x200\\n\\n        mstore(add(mPtr, offset), VK_QCP_0_X)\\n        mstore(add(mPtr, add(offset, 0x20)), VK_QCP_0_Y)\\n        offset := add(offset, 0x40)\\n\\n        mstore(add(mPtr, offset), calldataload(add(aproof, PROOF_QUOTIENT_POLYNOMIAL_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0x20)), calldataload(add(aproof, PROOF_LINEARISED_POLYNOMIAL_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0x40)), calldataload(add(aproof, PROOF_L_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0x60)), calldataload(add(aproof, PROOF_R_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0x80)), calldataload(add(aproof, PROOF_O_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0xa0)), calldataload(add(aproof, PROOF_S1_AT_ZETA)))\\n        mstore(add(mPtr, add(offset, 0xc0)), calldataload(add(aproof, PROOF_S2_AT_ZETA)))\\n\\n        let _mPtr := add(mPtr, add(offset, 0xe0))\\n\\n        let _poscaz := add(aproof, PROOF_OPENING_QCP_AT_ZETA)\\n        for {\\n          let i := 0\\n        } lt(i, VK_NB_CUSTOM_GATES) {\\n          i := add(i, 1)\\n        } {\\n          mstore(_mPtr, calldataload(_poscaz))\\n          _poscaz := add(_poscaz, 0x20)\\n          _mPtr := add(_mPtr, 0x20)\\n        }\\n\\n        mstore(_mPtr, calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)))\\n\\n        let start_input := 0x1b // 00..\\\"gamma\\\"\\n        let size_input := add(0x17, mul(VK_NB_CUSTOM_GATES, 3)) // number of 32bytes elmts = 0x17 (zeta+2*7+7 for the digests+openings) + 2*VK_NB_CUSTOM_GATES (for the commitments of the selectors) + VK_NB_CUSTOM_GATES (for the openings of the selectors)\\n        size_input := add(0x5, mul(size_input, 0x20)) // size in bytes: 15*32 bytes + 5 bytes for gamma\\n        let check_staticcall := staticcall(\\n          gas(),\\n          0x2,\\n          add(mPtr, start_input),\\n          size_input,\\n          add(state, STATE_GAMMA_KZG),\\n          0x20\\n        )\\n        if iszero(check_staticcall) {\\n          error_verify()\\n        }\\n        mstore(add(state, STATE_GAMMA_KZG), mod(mload(add(state, STATE_GAMMA_KZG)), R_MOD))\\n      }\\n\\n      function compute_commitment_linearised_polynomial_ec(aproof, s1, s2) {\\n        let state := mload(0x40)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n\\n        mstore(mPtr, VK_QL_COM_X)\\n        mstore(add(mPtr, 0x20), VK_QL_COM_Y)\\n        point_mul(\\n          add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n          mPtr,\\n          calldataload(add(aproof, PROOF_L_AT_ZETA)),\\n          add(mPtr, 0x40)\\n        )\\n\\n        mstore(mPtr, VK_QR_COM_X)\\n        mstore(add(mPtr, 0x20), VK_QR_COM_Y)\\n        point_acc_mul(\\n          add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n          mPtr,\\n          calldataload(add(aproof, PROOF_R_AT_ZETA)),\\n          add(mPtr, 0x40)\\n        )\\n\\n        let rl := mulmod(calldataload(add(aproof, PROOF_L_AT_ZETA)), calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)\\n        mstore(mPtr, VK_QM_COM_X)\\n        mstore(add(mPtr, 0x20), VK_QM_COM_Y)\\n        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, rl, add(mPtr, 0x40))\\n\\n        mstore(mPtr, VK_QO_COM_X)\\n        mstore(add(mPtr, 0x20), VK_QO_COM_Y)\\n        point_acc_mul(\\n          add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n          mPtr,\\n          calldataload(add(aproof, PROOF_O_AT_ZETA)),\\n          add(mPtr, 0x40)\\n        )\\n\\n        mstore(mPtr, VK_QK_COM_X)\\n        mstore(add(mPtr, 0x20), VK_QK_COM_Y)\\n        point_add(\\n          add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n          add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n          mPtr,\\n          add(mPtr, 0x40)\\n        )\\n\\n        let commits_api_at_zeta := add(aproof, PROOF_OPENING_QCP_AT_ZETA)\\n        let commits_api := add(aproof, PROOF_COMMITMENTS_WIRES_CUSTOM_GATES)\\n        for {\\n          let i := 0\\n        } lt(i, VK_NB_CUSTOM_GATES) {\\n          i := add(i, 1)\\n        } {\\n          mstore(mPtr, calldataload(commits_api))\\n          mstore(add(mPtr, 0x20), calldataload(add(commits_api, 0x20)))\\n          point_acc_mul(\\n            add(state, STATE_LINEARISED_POLYNOMIAL_X),\\n            mPtr,\\n            calldataload(commits_api_at_zeta),\\n            add(mPtr, 0x40)\\n          )\\n          commits_api_at_zeta := add(commits_api_at_zeta, 0x20)\\n          commits_api := add(commits_api, 0x40)\\n        }\\n\\n        mstore(mPtr, VK_S3_COM_X)\\n        mstore(add(mPtr, 0x20), VK_S3_COM_Y)\\n        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, s1, add(mPtr, 0x40))\\n\\n        mstore(mPtr, calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_X)))\\n        mstore(add(mPtr, 0x20), calldataload(add(aproof, PROOF_GRAND_PRODUCT_COMMITMENT_Y)))\\n        point_acc_mul(add(state, STATE_LINEARISED_POLYNOMIAL_X), mPtr, s2, add(mPtr, 0x40))\\n      }\\n\\n      /// @notice Compute the commitment to the linearized polynomial equal to\\n      ///\\tL(\u03b6)[Q\u2097]+r(\u03b6)[Q\u1d63]+R(\u03b6)L(\u03b6)[Q\u2098]+O(\u03b6)[Q\u2092]+[Q\u2096]+\u03a3\u1d62qc'\u1d62(\u03b6)[BsbCommitment\u1d62] +\\n      ///\\t\u03b1*( Z(\u03bc\u03b6)(L(\u03b6)+\u03b2*S\u2081(\u03b6)+\u03b3)*(R(\u03b6)+\u03b2*S\u2082(\u03b6)+\u03b3)[S\u2083]-[Z](L(\u03b6)+\u03b2*id_{1}(\u03b6)+\u03b3)*(R(\u03b6)+\u03b2*id_{2(\u03b6)+\u03b3)*(O(\u03b6)+\u03b2*id_{3}(\u03b6)+\u03b3) ) +\\n      ///\\t\u03b1\u00b2*L\u2081(\u03b6)[Z]\\n      /// where\\n      /// * id_1 = id, id_2 = vk_coset_shift*id, id_3 = vk_coset_shift^{2}*id\\n      /// * the [] means that it's a commitment (i.e. a point on Bn254(F_p))\\n      /// @param aproof pointer to the proof\\n      function compute_commitment_linearised_polynomial(aproof) {\\n        let state := mload(0x40)\\n        let l_beta := mload(add(state, STATE_BETA))\\n        let l_gamma := mload(add(state, STATE_GAMMA))\\n        let l_zeta := mload(add(state, STATE_ZETA))\\n        let l_alpha := mload(add(state, STATE_ALPHA))\\n\\n        let u := mulmod(calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), l_beta, R_MOD)\\n        let v := mulmod(l_beta, calldataload(add(aproof, PROOF_S1_AT_ZETA)), R_MOD)\\n        v := addmod(v, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)\\n        v := addmod(v, l_gamma, R_MOD)\\n\\n        let w := mulmod(l_beta, calldataload(add(aproof, PROOF_S2_AT_ZETA)), R_MOD)\\n        w := addmod(w, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)\\n        w := addmod(w, l_gamma, R_MOD)\\n\\n        let s1 := mulmod(u, v, R_MOD)\\n        s1 := mulmod(s1, w, R_MOD)\\n        s1 := mulmod(s1, l_alpha, R_MOD)\\n\\n        let coset_square := mulmod(VK_COSET_SHIFT, VK_COSET_SHIFT, R_MOD)\\n        let betazeta := mulmod(l_beta, l_zeta, R_MOD)\\n        u := addmod(betazeta, calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD)\\n        u := addmod(u, l_gamma, R_MOD)\\n\\n        v := mulmod(betazeta, VK_COSET_SHIFT, R_MOD)\\n        v := addmod(v, calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD)\\n        v := addmod(v, l_gamma, R_MOD)\\n\\n        w := mulmod(betazeta, coset_square, R_MOD)\\n        w := addmod(w, calldataload(add(aproof, PROOF_O_AT_ZETA)), R_MOD)\\n        w := addmod(w, l_gamma, R_MOD)\\n\\n        let s2 := mulmod(u, v, R_MOD)\\n        s2 := mulmod(s2, w, R_MOD)\\n        s2 := sub(R_MOD, s2)\\n        s2 := mulmod(s2, l_alpha, R_MOD)\\n        s2 := addmod(s2, mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0)), R_MOD)\\n\\n        // at this stage:\\n        // * s\u2081 = \u03b1*Z(\u03bc\u03b6)(l(\u03b6)+\u03b2*s\u2081(\u03b6)+\u03b3)*(r(\u03b6)+\u03b2*s\u2082(\u03b6)+\u03b3)*\u03b2\\n        // * s\u2082 = -\u03b1*(l(\u03b6)+\u03b2*\u03b6+\u03b3)*(r(\u03b6)+\u03b2*u*\u03b6+\u03b3)*(o(\u03b6)+\u03b2*u\u00b2*\u03b6+\u03b3) + \u03b1\u00b2*L\u2081(\u03b6)\\n\\n        compute_commitment_linearised_polynomial_ec(aproof, s1, s2)\\n      }\\n\\n      /// @notice compute H\u2081 + \u03b6\u1d50\u207a\u00b2*H\u2082 + \u03b6\u00b2\u207d\u1d50\u207a\u00b2\u207e*H\u2083 and store the result at\\n      /// state + state_folded_h\\n      /// @param aproof pointer to the proof\\n      function fold_h(aproof) {\\n        let state := mload(0x40)\\n        let n_plus_two := add(VK_DOMAIN_SIZE, 2)\\n        let mPtr := add(mload(0x40), STATE_LAST_MEM)\\n        let zeta_power_n_plus_two := pow(mload(add(state, STATE_ZETA)), n_plus_two, mPtr)\\n        point_mul_calldata(add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_2_X), zeta_power_n_plus_two, mPtr)\\n        point_add_calldata(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_1_X), mPtr)\\n        point_mul(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), zeta_power_n_plus_two, mPtr)\\n        point_add_calldata(add(state, STATE_FOLDED_H_X), add(state, STATE_FOLDED_H_X), add(aproof, PROOF_H_0_X), mPtr)\\n      }\\n\\n      /// @notice check that\\n      ///\\tL(\u03b6)Q\u2097(\u03b6)+r(\u03b6)Q\u1d63(\u03b6)+R(\u03b6)L(\u03b6)Q\u2098(\u03b6)+O(\u03b6)Q\u2092(\u03b6)+Q\u2096(\u03b6)+\u03a3\u1d62qc'\u1d62(\u03b6)BsbCommitment\u1d62(\u03b6) +\\n      ///  \u03b1*( Z(\u03bc\u03b6)(l(\u03b6)+\u03b2*s\u2081(\u03b6)+\u03b3)*(r(\u03b6)+\u03b2*s\u2082(\u03b6)+\u03b3)*\u03b2*s\u2083(X)-Z(X)(l(\u03b6)+\u03b2*id_1(\u03b6)+\u03b3)*(r(\u03b6)+\u03b2*id_2(\u03b6)+\u03b3)*(o(\u03b6)+\u03b2*id_3(\u03b6)+\u03b3) ) )\\n      /// + \u03b1\u00b2*L\u2081(\u03b6) =\\n      /// (\u03b6\u207f-1)H(\u03b6)\\n      /// @param aproof pointer to the proof\\n      function verify_quotient_poly_eval_at_zeta(aproof) {\\n        let state := mload(0x40)\\n\\n        // (l(\u03b6)+\u03b2*s1(\u03b6)+\u03b3)\\n        let s1 := add(mload(0x40), STATE_LAST_MEM)\\n        mstore(s1, mulmod(calldataload(add(aproof, PROOF_S1_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD))\\n        mstore(s1, addmod(mload(s1), mload(add(state, STATE_GAMMA)), R_MOD))\\n        mstore(s1, addmod(mload(s1), calldataload(add(aproof, PROOF_L_AT_ZETA)), R_MOD))\\n\\n        // (r(\u03b6)+\u03b2*s2(\u03b6)+\u03b3)\\n        let s2 := add(s1, 0x20)\\n        mstore(s2, mulmod(calldataload(add(aproof, PROOF_S2_AT_ZETA)), mload(add(state, STATE_BETA)), R_MOD))\\n        mstore(s2, addmod(mload(s2), mload(add(state, STATE_GAMMA)), R_MOD))\\n        mstore(s2, addmod(mload(s2), calldataload(add(aproof, PROOF_R_AT_ZETA)), R_MOD))\\n        // _s2 := mload(s2)\\n\\n        // (o(\u03b6)+\u03b3)\\n        let o := add(s1, 0x40)\\n        mstore(o, addmod(calldataload(add(aproof, PROOF_O_AT_ZETA)), mload(add(state, STATE_GAMMA)), R_MOD))\\n\\n        //  \u03b1*(Z(\u03bc\u03b6))*(l(\u03b6)+\u03b2*s1(\u03b6)+\u03b3)*(r(\u03b6)+\u03b2*s2(\u03b6)+\u03b3)*(o(\u03b6)+\u03b3)\\n        mstore(s1, mulmod(mload(s1), mload(s2), R_MOD))\\n        mstore(s1, mulmod(mload(s1), mload(o), R_MOD))\\n        mstore(s1, mulmod(mload(s1), mload(add(state, STATE_ALPHA)), R_MOD))\\n        mstore(s1, mulmod(mload(s1), calldataload(add(aproof, PROOF_GRAND_PRODUCT_AT_ZETA_OMEGA)), R_MOD))\\n\\n        let computed_quotient := add(s1, 0x60)\\n\\n        // linearizedpolynomial + pi(zeta)\\n        mstore(\\n          computed_quotient,\\n          addmod(calldataload(add(aproof, PROOF_LINEARISED_POLYNOMIAL_AT_ZETA)), mload(add(state, STATE_PI)), R_MOD)\\n        )\\n        mstore(computed_quotient, addmod(mload(computed_quotient), mload(s1), R_MOD))\\n        mstore(\\n          computed_quotient,\\n          addmod(mload(computed_quotient), sub(R_MOD, mload(add(state, STATE_ALPHA_SQUARE_LAGRANGE_0))), R_MOD)\\n        )\\n        mstore(\\n          s2,\\n          mulmod(\\n            calldataload(add(aproof, PROOF_QUOTIENT_POLYNOMIAL_AT_ZETA)),\\n            mload(add(state, STATE_ZETA_POWER_N_MINUS_ONE)),\\n            R_MOD\\n          )\\n        )\\n\\n        mstore(add(state, STATE_SUCCESS), eq(mload(computed_quotient), mload(s2)))\\n      }\\n\\n      // BEGINNING utils math functions -------------------------------------------------\\n\\n      /// @param dst pointer storing the result\\n      /// @param p pointer to the first point\\n      /// @param q pointer to the second point\\n      /// @param mPtr pointer to free memory\\n      function point_add(dst, p, q, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, mload(p))\\n        mstore(add(mPtr, 0x20), mload(add(p, 0x20)))\\n        mstore(add(mPtr, 0x40), mload(q))\\n        mstore(add(mPtr, 0x60), mload(add(q, 0x20)))\\n        let l_success := staticcall(gas(), 6, mPtr, 0x80, dst, 0x40)\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @param dst pointer storing the result\\n      /// @param p pointer to the first point (calldata)\\n      /// @param q pointer to the second point (calladata)\\n      /// @param mPtr pointer to free memory\\n      function point_add_calldata(dst, p, q, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, mload(p))\\n        mstore(add(mPtr, 0x20), mload(add(p, 0x20)))\\n        mstore(add(mPtr, 0x40), calldataload(q))\\n        mstore(add(mPtr, 0x60), calldataload(add(q, 0x20)))\\n        let l_success := staticcall(gas(), 6, mPtr, 0x80, dst, 0x40)\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @parma dst pointer storing the result\\n      /// @param src pointer to a point on Bn254(\ud835\udd3d_p)\\n      /// @param s scalar\\n      /// @param mPtr free memory\\n      function point_mul(dst, src, s, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, mload(src))\\n        mstore(add(mPtr, 0x20), mload(add(src, 0x20)))\\n        mstore(add(mPtr, 0x40), s)\\n        let l_success := staticcall(gas(), 7, mPtr, 0x60, dst, 0x40)\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @parma dst pointer storing the result\\n      /// @param src pointer to a point on Bn254(\ud835\udd3d_p) on calldata\\n      /// @param s scalar\\n      /// @param mPtr free memory\\n      function point_mul_calldata(dst, src, s, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, calldataload(src))\\n        mstore(add(mPtr, 0x20), calldataload(add(src, 0x20)))\\n        mstore(add(mPtr, 0x40), s)\\n        let l_success := staticcall(gas(), 7, mPtr, 0x60, dst, 0x40)\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @notice dst <- dst + [s]src (Elliptic curve)\\n      /// @param dst pointer accumulator point storing the result\\n      /// @param src pointer to the point to multiply and add\\n      /// @param s scalar\\n      /// @param mPtr free memory\\n      function point_acc_mul(dst, src, s, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, mload(src))\\n        mstore(add(mPtr, 0x20), mload(add(src, 0x20)))\\n        mstore(add(mPtr, 0x40), s)\\n        let l_success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n        mstore(add(mPtr, 0x40), mload(dst))\\n        mstore(add(mPtr, 0x60), mload(add(dst, 0x20)))\\n        l_success := and(l_success, staticcall(gas(), 6, mPtr, 0x80, dst, 0x40))\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @notice dst <- dst + [s]src (Elliptic curve)\\n      /// @param dst pointer accumulator point storing the result\\n      /// @param src pointer to the point to multiply and add (on calldata)\\n      /// @param s scalar\\n      /// @mPtr free memory\\n      function point_acc_mul_calldata(dst, src, s, mPtr) {\\n        let state := mload(0x40)\\n        mstore(mPtr, calldataload(src))\\n        mstore(add(mPtr, 0x20), calldataload(add(src, 0x20)))\\n        mstore(add(mPtr, 0x40), s)\\n        let l_success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n        mstore(add(mPtr, 0x40), mload(dst))\\n        mstore(add(mPtr, 0x60), mload(add(dst, 0x20)))\\n        l_success := and(l_success, staticcall(gas(), 6, mPtr, 0x80, dst, 0x40))\\n        if iszero(l_success) {\\n          error_ec_op()\\n        }\\n      }\\n\\n      /// @notice dst <- dst + src*s (Fr) dst,src are addresses, s is a value\\n      /// @param dst pointer storing the result\\n      /// @param src pointer to the scalar to multiply and add (on calldata)\\n      /// @param s scalar\\n      function fr_acc_mul_calldata(dst, src, s) {\\n        let tmp := mulmod(calldataload(src), s, R_MOD)\\n        mstore(dst, addmod(mload(dst), tmp, R_MOD))\\n      }\\n\\n      /// @param x element to exponentiate\\n      /// @param e exponent\\n      /// @param mPtr free memory\\n      /// @return res x ** e mod r\\n      function pow(x, e, mPtr) -> res {\\n        mstore(mPtr, 0x20)\\n        mstore(add(mPtr, 0x20), 0x20)\\n        mstore(add(mPtr, 0x40), 0x20)\\n        mstore(add(mPtr, 0x60), x)\\n        mstore(add(mPtr, 0x80), e)\\n        mstore(add(mPtr, 0xa0), R_MOD)\\n        let check_staticcall := staticcall(gas(), 0x05, mPtr, 0xc0, mPtr, 0x20)\\n        if eq(check_staticcall, 0) {\\n          error_verify()\\n        }\\n        res := mload(mPtr)\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"public_inputs\",\"type\":\"uint256[]\"}],\"name\":\"Verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PlonkVerifierFullLarge", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}