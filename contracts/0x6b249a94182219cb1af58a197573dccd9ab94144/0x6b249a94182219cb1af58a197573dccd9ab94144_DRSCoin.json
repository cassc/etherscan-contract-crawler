{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/library/TimeUtils.sol\r\n\r\nlibrary TimeUtils {\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n    struct _DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function parseTimestampToYM(uint timestamp) internal pure returns (uint16, uint8) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        uint16 year;\r\n        uint8 month;\r\n\r\n        // Year\r\n        year = getYear(timestamp);\r\n        buf = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for(i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, year);\r\n            if(secondsInMonth + secondsAccountedFor > timestamp) {\r\n                month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        return (year, month);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        // Hour\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n        // Minute\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n        // Second\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\n// File: contracts/interface/DRSCoinInterface.sol\r\n\r\ninterface DRSCoinInterface {\r\n    function mint(address _to, uint256 _amount) external;\r\n    function profitEth() external payable;\r\n}\r\n\r\n// File: contracts/DRSCoin.sol\r\n\r\ncontract DRSCoin {\r\n    using SafeMath for uint256;\r\n    using TimeUtils for uint;\r\n\r\n    struct MonthInfo {\r\n        uint256 ethIncome;\r\n        uint256 totalTokenSupply;\r\n    }\r\n\r\n    string constant tokenName = \"DRSCoin\";\r\n    string constant tokenSymbol = \"DRS\";\r\n    uint8 constant decimalUnits = 18;\r\n\r\n    uint256 public constant tokenExchangeInitRate = 500; // 500 tokens per 1 ETH initial\r\n    uint256 public constant tokenExchangeLeastRate = 10; // 10 tokens per 1 ETH at least\r\n    uint256 public constant tokenReduceValue = 5000000;\r\n    uint256 public constant coinReduceRate = 90;\r\n\r\n    uint256 constant private proposingPeriod = 2 days;\r\n    // uint256 constant private proposingPeriod = 2 seconds;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 public tokenReduceAmount;\r\n    uint256 public tokenExchangeRate; // DRSCoin / eth\r\n    uint256 public nextReduceSupply;  // next DRSCoin reduction supply\r\n\r\n    address public owner;\r\n\r\n    mapping(address => bool) restrictedAddresses;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    mapping(address => uint32) public lastRefundMonth;\r\n\r\n    mapping(address => uint256) public refundEth;  //record the user profit\r\n\r\n    mapping(uint32 => MonthInfo) monthInfos;\r\n\r\n    mapping(address => bool) allowedGameAddress;\r\n\r\n    mapping(address => uint256) proposedGames;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    event Mint(address indexed _to, uint256 _value);\r\n\r\n    // event Info(uint256 _value);\r\n\r\n    /* This notifies clients about the amount burnt */\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    event Profit(address indexed from, uint256 year, uint256 month, uint256 value);\r\n\r\n    event Withdraw(address indexed from, uint256 value);\r\n\r\n    modifier onlyOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedGameAddress {\r\n        require(allowedGameAddress[msg.sender], \"only allowed games permit to call\");\r\n        _;\r\n    }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    constructor() public\r\n    {\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\r\n\r\n        tokenReduceAmount = tokenReduceValue.mul(uint256(10) ** uint256(decimals));\r\n        tokenExchangeRate = tokenExchangeInitRate;          // Set initial token exchange rate\r\n        nextReduceSupply = tokenReduceAmount;               // Set next token reduction supply\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // _startMonth included\r\n    // _nowMonth excluded\r\n    function settleEth(address _addr, uint32 _startMonth, uint32 _nowMonth) internal {\r\n        require(_nowMonth >= _startMonth);\r\n\r\n        // _startMonth == 0 means new address\r\n        if(_startMonth == 0) {\r\n            lastRefundMonth[_addr] = _nowMonth;\r\n            return;\r\n        }\r\n\r\n        if(_nowMonth == _startMonth) {\r\n            lastRefundMonth[_addr] = _nowMonth;\r\n            return;\r\n        }\r\n\r\n        uint256 _balance = balanceOf[_addr];\r\n        if(_balance == 0) {\r\n            lastRefundMonth[_addr] = _nowMonth;\r\n            return;\r\n        }\r\n\r\n        uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _balance);\r\n        refundEth[_addr] = refundEth[_addr].add(_unpaidPerfit);\r\n\r\n        lastRefundMonth[_addr] = _nowMonth;\r\n        return;\r\n    }\r\n\r\n    function getCurrentMonth() internal view returns(uint32) {\r\n        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\r\n        return _year * 12 + _month - 1;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns(bool success) {\r\n        require(_value > 0);\r\n        require(balanceOf[msg.sender] >= _value);              // Check if the sender has enough\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows\r\n        require(!restrictedAddresses[msg.sender]);\r\n        require(!restrictedAddresses[_to]);\r\n\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        // settle msg.sender's eth\r\n        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\r\n\r\n        // settle _to's eth\r\n        settleEth(_to, lastRefundMonth[_to], _nowMonth);\r\n\r\n        // transfer token\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                 // Add the same to the recipient\r\n        emit Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns(bool success) {\r\n        allowance[msg.sender][_spender] = _value;                 // Set allowance\r\n        emit Approval(msg.sender, _spender, _value);              // Raise Approval event\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\r\n        require(balanceOf[_from] >= _value);                  // Check if the sender has enough\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);   // Check for overflows\r\n        require(_value <= allowance[_from][msg.sender]);      // Check allowance\r\n        require(!restrictedAddresses[_from]);\r\n        require(!restrictedAddresses[msg.sender]);\r\n        require(!restrictedAddresses[_to]);\r\n\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        // settle _from's eth\r\n        settleEth(_from, lastRefundMonth[_from], _nowMonth);\r\n\r\n        // settle _to's eth\r\n        settleEth(_to, lastRefundMonth[_to], _nowMonth);\r\n\r\n        // transfer token\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].add(_value);        // Add the same to the recipient\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function getUnpaidPerfit(uint32 _startMonth, uint32 _endMonth, uint256 _tokenAmount) internal view returns(uint256)\r\n    {\r\n        require(_startMonth > 0);\r\n        require(_endMonth >= _startMonth);\r\n\r\n        if(_startMonth == _endMonth) {\r\n            return 0;\r\n        }\r\n\r\n        if(_tokenAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _profit = 0;\r\n\r\n        uint256 _income;\r\n        uint256 _totalSupply;\r\n        for(uint32 j = _startMonth; j < _endMonth; j++) {\r\n            _income = monthInfos[j].ethIncome;\r\n            _totalSupply = monthInfos[j].totalTokenSupply;\r\n            if(_income > 0 && _totalSupply > 0) {\r\n                _profit = _profit.add(_income.mul(_tokenAmount).div(_totalSupply));\r\n            }\r\n        }\r\n\r\n        return _profit;\r\n    }\r\n\r\n    function totalSupply() constant public returns(uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function tokenExchangeRate() constant public returns(uint256) {\r\n        return tokenExchangeRate;\r\n    }\r\n\r\n    function nextReduceSupply() constant public returns(uint256) {\r\n        return nextReduceSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns(uint256) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns(uint256) {\r\n        return allowance[_owner][_spender];\r\n    }\r\n\r\n    function() public payable {\r\n        revert();\r\n    }\r\n\r\n    /* Owner can add new restricted address or removes one */\r\n    function editRestrictedAddress(address _newRestrictedAddress) public onlyOwner {\r\n        restrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];\r\n    }\r\n\r\n    function isRestrictedAddress(address _querryAddress) constant public returns(bool) {\r\n        return restrictedAddresses[_querryAddress];\r\n    }\r\n\r\n    function getMintAmount(uint256 _eth) private view returns(uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) {\r\n        _nextReduceSupply = nextReduceSupply;\r\n        _tokenExchangeRate = tokenExchangeRate;\r\n\r\n        _amount = 0;\r\n        uint256 _part = _nextReduceSupply.sub(totalSupply);  // calculate how many DRSCoin can mint in this period\r\n        while(_part <= _eth.mul(_tokenExchangeRate)) {\r\n            _eth = _eth.sub(_part.div(_tokenExchangeRate));  // sub eth amount\r\n            _amount = _amount.add(_part);                    // add DRSCoin mint in this small part\r\n\r\n            _part = tokenReduceAmount;\r\n            _nextReduceSupply = _nextReduceSupply.add(tokenReduceAmount);\r\n\r\n            if(_tokenExchangeRate > tokenExchangeLeastRate) {\r\n                _tokenExchangeRate = _tokenExchangeRate.mul(coinReduceRate).div(100);\r\n                if(_tokenExchangeRate < tokenExchangeLeastRate) {\r\n                    _tokenExchangeRate = tokenExchangeLeastRate;\r\n                }\r\n            }\r\n        }\r\n\r\n        _amount = _amount.add(_eth.mul(_tokenExchangeRate));\r\n\r\n        return (_amount, _nextReduceSupply, _tokenExchangeRate);\r\n    }\r\n\r\n    function mint(address _to, uint256 _eth) external onlyAllowedGameAddress {\r\n        require(_eth > 0);\r\n\r\n        (uint256 _amount, uint256 _nextReduceSupply, uint256 _tokenExchangeRate) = getMintAmount(_eth);\r\n\r\n        require(_amount > 0);\r\n        require(totalSupply + _amount > totalSupply);\r\n        require(balanceOf[_to] + _amount > balanceOf[_to]);     // Check for overflows\r\n\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        // settle _to's eth\r\n        settleEth(_to, lastRefundMonth[_to], _nowMonth);\r\n\r\n        totalSupply = _amount.add(totalSupply);                 // Update total supply\r\n        balanceOf[_to] = _amount.add(balanceOf[_to]);           // Set minted coins to target\r\n\r\n        // add current month's totalTokenSupply\r\n        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\r\n\r\n        if(_nextReduceSupply != nextReduceSupply) {\r\n            nextReduceSupply = _nextReduceSupply;\r\n        }\r\n        if(_tokenExchangeRate != tokenExchangeRate) {\r\n            tokenExchangeRate = _tokenExchangeRate;\r\n        }\r\n\r\n        emit Mint(_to, _amount);                                // Create Mint event\r\n        emit Transfer(0x0, _to, _amount);                       // Create Transfer event from 0x\r\n    }\r\n\r\n    function burn(uint256 _value) public returns(bool success) {\r\n        require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough\r\n        require(_value > 0);\r\n\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        // settle msg.sender's eth\r\n        settleEth(msg.sender, lastRefundMonth[msg.sender], _nowMonth);\r\n\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender\r\n        totalSupply = totalSupply.sub(_value);                                // Updates totalSupply\r\n\r\n        // update current month's totalTokenSupply\r\n        monthInfos[_nowMonth].totalTokenSupply = totalSupply;\r\n\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function addGame(address gameAddress) public onlyOwner {\r\n        require(!allowedGameAddress[gameAddress], \"game already in allow list\");\r\n        require(proposedGames[gameAddress] > 0, \"game must be in proposed list first\");\r\n        require(now > proposedGames[gameAddress].add(proposingPeriod), \"game must be debated for 2 days\");\r\n\r\n        // add gameAddress to allowedGameAddress\r\n        allowedGameAddress[gameAddress] = true;\r\n\r\n        // delete gameAddress from proposedGames\r\n        proposedGames[gameAddress] = 0;\r\n    }\r\n\r\n    function proposeGame(address gameAddress) public onlyOwner {\r\n        require(!allowedGameAddress[gameAddress], \"game already in allow list\");\r\n        require(proposedGames[gameAddress] == 0, \"game already in proposed list\");\r\n\r\n        // add gameAddress to proposedGames\r\n        proposedGames[gameAddress] = now;\r\n    }\r\n\r\n    function deleteGame (address gameAddress) public onlyOwner {\r\n        require(allowedGameAddress[gameAddress] || proposedGames[gameAddress] > 0, \"game must in allow list or proposed list\");\r\n\r\n        // delete gameAddress from allowedGameAddress\r\n        allowedGameAddress[gameAddress] = false;\r\n\r\n        // delete gameAddress from proposedGames\r\n        proposedGames[gameAddress] = 0;\r\n    }\r\n\r\n    function gameCountdown(address gameAddress) public view returns(uint256) {\r\n        require(proposedGames[gameAddress] > 0, \"game not in proposed list\");\r\n\r\n        uint256 proposedTime = proposedGames[gameAddress];\r\n\r\n        if(now < proposedTime.add(proposingPeriod)) {\r\n            return proposedTime.add(proposingPeriod).sub(now);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function profitEth() external payable onlyAllowedGameAddress {\r\n        (uint16 _year, uint8 _month) = now.parseTimestampToYM();\r\n        uint32 _nowMonth = _year * 12 + _month - 1;\r\n\r\n        uint256 _ethIncome = monthInfos[_nowMonth].ethIncome.add(msg.value);\r\n\r\n        monthInfos[_nowMonth].ethIncome = _ethIncome;\r\n\r\n        if(monthInfos[_nowMonth].totalTokenSupply == 0) {\r\n            monthInfos[_nowMonth].totalTokenSupply = totalSupply;\r\n        }\r\n\r\n        emit Profit(msg.sender, _year, _month, _ethIncome);\r\n    }\r\n\r\n    function withdraw() public {\r\n        require(!restrictedAddresses[msg.sender]);  // check if msg.sender is restricted\r\n\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        uint32 _startMonth = lastRefundMonth[msg.sender];\r\n        require(_startMonth > 0);\r\n\r\n        settleEth(msg.sender, _startMonth, _nowMonth);\r\n\r\n        uint256 _profit = refundEth[msg.sender];\r\n        require(_profit > 0);\r\n\r\n        refundEth[msg.sender] = 0;\r\n        msg.sender.transfer(_profit);\r\n\r\n        emit Withdraw(msg.sender, _profit);\r\n    }\r\n\r\n    function getEthPerfit(address _addr) public view returns(uint256) {\r\n        uint32 _nowMonth = getCurrentMonth();\r\n\r\n        uint32 _startMonth = lastRefundMonth[_addr];\r\n        // new user\r\n        if(_startMonth == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _tokenAmount = balanceOf[_addr];\r\n\r\n        uint256 _perfit = refundEth[_addr];\r\n\r\n        if(_startMonth < _nowMonth && _tokenAmount > 0) {\r\n            uint256 _unpaidPerfit = getUnpaidPerfit(_startMonth, _nowMonth, _tokenAmount);\r\n            _perfit = _perfit.add(_unpaidPerfit);\r\n        }\r\n\r\n        return _perfit;\r\n    }\r\n}\r\n\r\n// contract DRSCoinTestContract {\r\n//     DRSCoinInterface public drsCoin;\r\n\r\n//     constructor(address _drsCoin) public {\r\n//         drsCoin = DRSCoinInterface(_drsCoin);\r\n//     }\r\n\r\n//     function mintDRSCoin(address _addr, uint256 _amount) public {\r\n//         drsCoin.mint(_addr, _amount);\r\n//     }\r\n// }", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_querryAddress\",\"type\":\"address\"}],\"name\":\"isRestrictedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getEthPerfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRestrictedAddress\",\"type\":\"address\"}],\"name\":\"editRestrictedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReduceAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"proposeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"deleteGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"profitEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeLeastRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReduceValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinReduceRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeInitRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"addGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRefundMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"gameCountdown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextReduceSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"year\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"month\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Profit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]", "ContractName": "DRSCoin", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://910b50d5c20ae3fd54f77f2fea46b716d72b2bfaa1a8a4531218d37da17ee409"}