{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ethereum/CreatorVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {CrossDomainOrigin} from \\\"src/shared/CrossDomainOrigin.sol\\\";\\nimport {ICreatorVerifier} from \\\"src/ethereum/ICreatorVerifier.sol\\\";\\nimport {ICreatorRegistry} from \\\"src/ethereum/ICreatorRegistry.sol\\\";\\nimport {IEditionConverter} from \\\"src/op/IEditionConverter.sol\\\";\\nimport {ICrossDomainMessenger} from \\\"src/shared/ICrossDomainMessenger.sol\\\";\\n\\ncontract CreatorVerifier is ICreatorVerifier {\\n    address private _creatorRegistry;\\n    address private _editionConverter;\\n\\n    modifier onlyNftCreator(address nftContract_, uint256 tokenId_) {\\n        if (ICreatorRegistry(_creatorRegistry).getCreatorOf(nftContract_, tokenId_) != msg.sender) {\\n            revert CallerNotNftCreator(nftContract_, tokenId_);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(address creatorRegistry_, address editionConverter_) {\\n        _creatorRegistry = creatorRegistry_;\\n        _editionConverter = editionConverter_;\\n    }\\n\\n    function claimProceedsAndCreateEditions(\\n        address originalNftContract_,\\n        uint256 originalNftTokenId_,\\n        uint256 editionNftChainId_,\\n        string calldata collectionImageUri_,\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external override onlyNftCreator(originalNftContract_, originalNftTokenId_) {\\n        bytes memory message = abi.encodeCall(\\n            IEditionConverter.convertToEditions,\\n            (block.chainid, originalNftContract_, originalNftTokenId_, msg.sender, collectionImageUri_, name_, symbol_)\\n        );\\n\\n        ICrossDomainMessenger(CrossDomainOrigin.crossDomainMessenger(editionNftChainId_)).sendMessage(\\n            _editionConverter,\\n            message,\\n            // The first 1.92M gas is free\\n            // https://community.optimism.io/docs/developers/bridge/messaging/#for-l1-%E2%87%92-l2-transactions\\n            1920000\\n        );\\n\\n        emit ClaimProceedsAndCreateEditions(originalNftContract_, originalNftTokenId_);\\n    }\\n\\n    function creatorRegistry() external view override returns (address) {\\n        return _creatorRegistry;\\n    }\\n\\n    function editionConverter() external view override returns (address) {\\n        return _editionConverter;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/shared/CrossDomainOrigin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\n// Reference: https://github.com/ethereum-optimism/optimism-tutorial/blob/main/cross-dom-comm/contracts/Greeter.sol\\n\\nimport {ICrossDomainMessenger} from \\\"src/shared/ICrossDomainMessenger.sol\\\";\\n\\nlibrary CrossDomainOrigin {\\n    /**\\n     * Returns the CrossDomainMessenger for the given destinationOpChainId_\\n     *\\n     */\\n    function crossDomainMessenger(uint256 crossDomainChainId_) internal view returns (address cdmAddr) {\\n        // Get the cross domain messenger's address each time.\\n        // This is less resource intensive than writing to storage.\\n\\n        // Mainnet -> Optimism\\n        if (block.chainid == 1 && crossDomainChainId_ == 10) cdmAddr = 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1;\\n\\n        // Mainnet -> Base\\n        if (block.chainid == 1 && crossDomainChainId_ == 8453) cdmAddr = 0x866E82a600A1414e583f7F13623F1aC5d58b0Afa;\\n\\n        // Mainnet -> Zora\\n        if (block.chainid == 1 && crossDomainChainId_ == 7777777) cdmAddr = 0xdC40a14d9abd6F410226f1E6de71aE03441ca506;\\n\\n        // Goerli -> Goerli Optimism\\n        if (block.chainid == 5 && crossDomainChainId_ == 420) cdmAddr = 0x5086d1eEF304eb5284A0f6720f79403b4e9bE294;\\n\\n        // Goerli -> Goerli Base\\n        if (block.chainid == 5 && crossDomainChainId_ == 84531) cdmAddr = 0x8e5693140eA606bcEB98761d9beB1BC87383706D;\\n\\n        // Goerli -> Goerli Zora\\n        if (block.chainid == 5 && crossDomainChainId_ == 999) cdmAddr = 0xD87342e16352D33170557A7dA1e5fB966a60FafC;\\n\\n        // Op Stack\\n        if (\\n            // Optimism -> Mainnet\\n            (block.chainid == 10 && crossDomainChainId_ == 1)\\n            // Base -> Mainnet\\n            || (block.chainid == 8453 && crossDomainChainId_ == 1)\\n            // Zora -> Mainnet\\n            || (block.chainid == 7777777 && crossDomainChainId_ == 1)\\n            // Goerli Optimism -> Goerli\\n            || (block.chainid == 420 && crossDomainChainId_ == 5)\\n            // Goerli Base -> Goerli\\n            || (block.chainid == 84531 && crossDomainChainId_ == 5)\\n            // Goerli Zora -> Goerli\\n            || (block.chainid == 999 && crossDomainChainId_ == 5)\\n        ) cdmAddr = 0x4200000000000000000000000000000000000007;\\n    }\\n\\n    function getCrossDomainMessageSender(uint256 crossDomainChainId_) internal view returns (address) {\\n        // Get the cross domain messenger's address each time.\\n        // This is less resource intensive than writing to storage.\\n        address cdmAddr = crossDomainMessenger(crossDomainChainId_);\\n\\n        // If this isn't a cross domain message\\n        if (msg.sender != cdmAddr) {\\n            revert(\\\"Not crosschain call\\\");\\n        }\\n\\n        // If it is a cross domain message, find out where it is from\\n        return ICrossDomainMessenger(cdmAddr).xDomainMessageSender();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ethereum/ICreatorVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface ICreatorVerifier {\\n    event ClaimProceedsAndCreateEditions(address indexed originalNftContract, uint256 indexed originalNftTokenId);\\n\\n    error CallerNotNftCreator(address nftContract, uint256 tokenId);\\n\\n    function claimProceedsAndCreateEditions(\\n        address originalNftContract_,\\n        uint256 originalNftTokenId_,\\n        uint256 editionNftChainId_,\\n        string calldata collectionImageUri_,\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n\\n    function creatorRegistry() external view returns (address);\\n\\n    function editionConverter() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/ethereum/ICreatorRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface ICreatorRegistry {\\n    function getCreatorOf(address nftContract_, uint256 tokenId_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/op/IEditionConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface IEditionConverter {\\n    error CallerNotNftCreatorVerifier();\\n\\n    error EditionNftContractNotRegistered(\\n        uint256 originalNftChainId_, address originalNftContract_, uint256 originalNftTokenId_\\n    );\\n\\n    function convertToEditions(\\n        uint256 originalNftChainId_,\\n        address originalNftContract_,\\n        uint256 originalNftTokenId_,\\n        address creator_,\\n        string calldata collectionImageUri_,\\n        string calldata name_,\\n        string calldata symbol_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/shared/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface ICrossDomainMessenger {\\n    /**\\n     *\\n     * Events *\\n     *\\n     */\\n\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /**\\n     *\\n     * Variables *\\n     *\\n     */\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /**\\n     *\\n     * Public Functions *\\n     *\\n     */\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-math/lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"prb-math/=lib/prb-math/src/\",\r\n      \"prb-test/=lib/prb-math/lib/prb-test/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@prb/math/=lib/prb-math/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creatorRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"editionConverter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CallerNotNftCreator\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalNftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"originalNftTokenId\",\"type\":\"uint256\"}],\"name\":\"ClaimProceedsAndCreateEditions\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalNftContract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originalNftTokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"editionNftChainId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"collectionImageUri_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"name\":\"claimProceedsAndCreateEditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionConverter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CreatorVerifier", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fbf8d8811b128571f24a98a7a01dbc391c6532b800000000000000000000000074b92f22bcb3ea996d6b027da62361f02c6a631e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}