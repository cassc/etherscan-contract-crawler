{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LCPoolPCv3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\nimport \\\"./interfaces/INonfungiblePositionManager.sol\\\";\\r\\nimport \\\"./interfaces/IPancakeV3Factory.sol\\\";\\r\\nimport \\\"./interfaces/IMasterChefv3.sol\\\";\\r\\nimport \\\"./interfaces/IERC721Receiver.sol\\\";\\r\\nimport \\\"./interfaces/ISwapPlusv1.sol\\\";\\r\\nimport \\\"./interfaces/IFeeTierStrate.sol\\\";\\r\\nimport \\\"./interfaces/ILCPoolPCv3Ledger.sol\\\";\\r\\n\\r\\nimport \\\"./utils/Ownable.sol\\\";\\r\\nimport \\\"./utils/SafeERC20.sol\\\";\\r\\n\\r\\ncontract LCPoolPCv3 is Ownable, IERC721Receiver {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  address public nftManager;\\r\\n  address public nftFactory;\\r\\n  address public v3MasterChef;\\r\\n  address public WETH;\\r\\n  address public rewardToken;\\r\\n  address public swapRouter;\\r\\n  address public feeStrate;\\r\\n  address public ledger;\\r\\n\\r\\n  int24 private constant MIN_TICK = -887272;\\r\\n  int24 private constant MAX_TICK = -MIN_TICK;\\r\\n  uint256 private constant coreDecimal = 1000000;\\r\\n  bool public reinvestAble = true;\\r\\n  uint256 public reinvestEdge = 100;\\r\\n\\r\\n  struct Operator {\\r\\n    address account;\\r\\n    address[2] pair;\\r\\n    uint256 meta; // fee\\r\\n    uint256 basketId;\\r\\n    address token;\\r\\n    uint256 amount;\\r\\n  }\\r\\n\\r\\n  struct swapPath {\\r\\n    ISwapPlusv1.swapBlock[] path;\\r\\n  }\\r\\n\\r\\n  mapping (address => bool) public managers;\\r\\n  mapping (address => bool) public operators;\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"LC pool: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  event Deposit(uint256 nftId, uint256 liquiidty);\\r\\n  event Withdraw(uint256 nftId, uint256 liquiidty, uint256 amountOut);\\r\\n  event ReInvest(address token0, address token1, uint24 fee, uint256 nftId, uint256 reward, uint256 extraLp);\\r\\n  event RemovePool(address operator, address from, uint256 tokenId, address token0, address token1, uint24 fee, bytes data);\\r\\n  event LcFee(address account, address token, uint256 amount);\\r\\n  event ClaimReward(address account, uint256 nftId, uint256 basketId, uint256 extraLp, uint256 reward);\\r\\n\\r\\n  constructor (\\r\\n    address _nftManager,\\r\\n    address _nftFactory,\\r\\n    address _v3MasterChef,\\r\\n    address _swapRouter,\\r\\n    address _feeStrate,\\r\\n    address _ledger,\\r\\n    address _WETH,\\r\\n    address _reward\\r\\n  ) {\\r\\n    require(_nftManager != address(0), \\\"LC pool: nft manager\\\");\\r\\n    require(_nftFactory != address(0), \\\"LC pool: factory\\\");\\r\\n    require(_v3MasterChef != address(0), \\\"LC pool: master chef\\\");\\r\\n    require(_swapRouter != address(0), \\\"LC pool: swap router\\\");\\r\\n    require(_feeStrate != address(0), \\\"LC pool: feeStrate\\\");\\r\\n    require(_ledger != address(0), \\\"LC pool: ledger\\\");\\r\\n    require(_WETH != address(0), \\\"LC pool: WETH\\\");\\r\\n    require(_reward != address(0), \\\"LC pool: reward\\\");\\r\\n\\r\\n    nftManager = _nftManager;\\r\\n    nftFactory = _nftFactory;\\r\\n    v3MasterChef = _v3MasterChef;\\r\\n    swapRouter = _swapRouter;\\r\\n    feeStrate = _feeStrate;\\r\\n    ledger = _ledger;\\r\\n    WETH = _WETH;\\r\\n    rewardToken = _reward;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public virtual override returns (bytes4) {\\r\\n    ( , , address token0, address token1, uint24 fee, , , , , , , ) = INonfungiblePositionManager(nftManager).positions(tokenId);\\r\\n    emit RemovePool(operator, from, tokenId, token0, token1, fee, data);\\r\\n    return this.onERC721Received.selector;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * mtoken     0: tokenMReward, 1: tM'\\r\\n   * percent    0: tM->t0%       1: tM->t1%\\r\\n   * paths      0: tIn->tM,      1: tM->t0,  2: tM->t1\\r\\n   * minAmounts 0: lpMin0        1: lpMin1\\r\\n   */\\r\\n  // function deposit(uint256 tokenId, uint256 basketId, uint256 liquidity, uint256 reward, uint256 exRate) public payable {\\r\\n  function deposit(\\r\\n    Operator calldata info,\\r\\n    address[2][2] calldata mtoken,\\r\\n    uint256[2][2] calldata percent,\\r\\n    swapPath[3] calldata paths,\\r\\n    swapPath[3] calldata rpaths,\\r\\n    uint256[2][2] calldata minAmounts\\r\\n  ) public payable returns(uint256, uint256) {\\r\\n    require(msg.sender == info.account || operators[msg.sender], \\\"LC pool: no access\\\");\\r\\n    uint256[] memory dpvar = new uint256[](4);\\r\\n    dpvar[0] = 0; // reward\\r\\n    dpvar[1] = 0; // exLp\\r\\n    dpvar[2] = 0; // rewardReserve\\r\\n    dpvar[3] = 0; // iAmount\\r\\n    if (info.token != address(0)) {  // If address is not null, send this amount to contract.\\r\\n      dpvar[3] = IERC20(info.token).balanceOf(address(this));\\r\\n      IERC20(info.token).safeTransferFrom(info.account, address(this), info.amount);\\r\\n      dpvar[3] = IERC20(info.token).balanceOf(address(this)) - dpvar[3];\\r\\n    }\\r\\n    else {\\r\\n      IWETH(WETH).deposit{value: msg.value}();\\r\\n      dpvar[3] = msg.value;\\r\\n    }\\r\\n    \\r\\n    // return extraLp, reward, reserved reward, claim extra lp, claim reward amount\\r\\n    (dpvar[1], dpvar[0], dpvar[2], ,) = _reinvest(info, mtoken[1], percent[1], rpaths, minAmounts[1], false);\\r\\n\\r\\n    dpvar[3] = _distributeFee(info.basketId, (info.token==address(0)?WETH:info.token), dpvar[3], 1);\\r\\n    (uint256 tokenId, uint256 liquidity) = _deposit(info, dpvar[3], mtoken[0], percent[0], paths, minAmounts[0]);\\r\\n    ILCPoolPCv3Ledger(ledger).updateInfo(info.account, tokenId, info.basketId, liquidity, dpvar[0], dpvar[2], dpvar[1], true);\\r\\n\\r\\n    return (tokenId, liquidity);\\r\\n  }\\r\\n\\r\\n  function withdraw(\\r\\n    address receiver,\\r\\n    Operator calldata info,\\r\\n    address[2][2] calldata mtoken,\\r\\n    uint256[2] calldata percent,\\r\\n    swapPath[3] calldata paths,\\r\\n    swapPath[3] calldata rpaths,\\r\\n    uint256[2][2] calldata minAmounts\\r\\n  ) public returns(uint256) {\\r\\n    require(receiver == info.account || operators[msg.sender], \\\"LC pool: no access\\\");\\r\\n    // 0: reward\\r\\n    // 1: exLp\\r\\n    // 2: rewardReserve\\r\\n    // 3: tokenId\\r\\n    // 4: outAmount\\r\\n    // 5: claim extra lp\\r\\n    // 6: claim reward amount\\r\\n    // 7: withdrawn liquidity amount\\r\\n    // 8: current reward\\r\\n    uint256[] memory wvar = new uint256[](9);\\r\\n    \\r\\n    // return extraLp, reward, reserved reward, claim extra lp, claim reward amount\\r\\n    (wvar[1], wvar[0], wvar[2], wvar[5], wvar[6]) = _reinvest(info, mtoken[1], percent, rpaths, minAmounts[1], true);\\r\\n    wvar[8] = IERC20(rewardToken).balanceOf(address(this));\\r\\n    if (wvar[8] < wvar[6]) {\\r\\n      wvar[6] = wvar[8];\\r\\n    }\\r\\n    if (wvar[6] > 0) {\\r\\n      IERC20(rewardToken).safeTransfer(info.account, wvar[6]);\\r\\n    }\\r\\n\\r\\n    bool isCoin = false;\\r\\n    if (info.token == address(0)) {\\r\\n      isCoin = true;\\r\\n    }\\r\\n    // return tokenId, withdraw liquidity amount, receive token amount\\r\\n    (wvar[3], wvar[7], wvar[4]) = _withdraw(info, wvar[5], mtoken[0], paths, minAmounts[0]);\\r\\n    ILCPoolPCv3Ledger(ledger).updateInfo(info.account, wvar[3], info.basketId, wvar[7], wvar[0], wvar[2], wvar[1], false);\\r\\n\\r\\n    wvar[4] = _distributeFee(info.basketId, isCoin?WETH:info.token, wvar[4], 0);\\r\\n\\r\\n    if (wvar[4] > 0) {\\r\\n      if (isCoin) {\\r\\n        IWETH(WETH).withdraw(wvar[4]);\\r\\n        (bool success, ) = payable(receiver).call{value: wvar[4]}(\\\"\\\");\\r\\n        require(success, \\\"LC pool: Failed receipt\\\");\\r\\n      }\\r\\n      else {\\r\\n        IERC20(info.token).safeTransfer(receiver, wvar[4]);\\r\\n      }\\r\\n    }\\r\\n    if (wvar[5] > 0 || wvar[6] > 0) {\\r\\n      emit ClaimReward(info.account, wvar[3], info.basketId, wvar[5], wvar[6]);\\r\\n    }\\r\\n    return wvar[4];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * tokens   0: token0,  1: token1,\\r\\n   * mtokens  0: tokenM,  1: tM'\\r\\n   * paths    0: t->tM,   1: tM->t0,   2: tM->t1\\r\\n   * percents 0: tM->t0%  1: tM->t1%\\r\\n   * return amount0, amount1\\r\\n   */\\r\\n  function _depositSwap(\\r\\n    address tokenIn,\\r\\n    uint256 amountIn,\\r\\n    address[2] memory tokens,\\r\\n    address[2] calldata mTokens,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths\\r\\n  ) internal returns(uint256, uint256) {\\r\\n    uint256[2] memory outs;\\r\\n    outs[0] = amountIn;\\r\\n    outs[1] = amountIn;\\r\\n    uint256 amountM = amountIn;\\r\\n    if (tokenIn == address(0)) tokenIn = WETH;\\r\\n\\r\\n    if (paths[0].path.length > 0) {\\r\\n      _approveTokenIfNeeded(tokenIn, swapRouter, amountM);\\r\\n      (, amountM) = ISwapPlusv1(swapRouter).swap(tokenIn, amountM, mTokens[0], address(this), paths[0].path);\\r\\n    }\\r\\n    if (paths[1].path.length > 0) {\\r\\n      _approveTokenIfNeeded(mTokens[0], swapRouter, amountM);\\r\\n      (, outs[0]) = ISwapPlusv1(swapRouter).swap(mTokens[0], amountM*percents[0]/coreDecimal, tokens[0], address(this), paths[1].path);\\r\\n      amountM -= amountM*percents[0]/coreDecimal;\\r\\n      outs[1] = amountM;\\r\\n    }\\r\\n    if (paths[2].path.length > 0) {\\r\\n      if (mTokens[0] == mTokens[1]) {\\r\\n        _approveTokenIfNeeded(mTokens[1], swapRouter, amountM);\\r\\n        (, outs[1]) = ISwapPlusv1(swapRouter).swap(mTokens[1], amountM, tokens[1], address(this), paths[2].path);\\r\\n      }\\r\\n      else {\\r\\n        _approveTokenIfNeeded(mTokens[1], swapRouter, outs[0]);\\r\\n        (, outs[1]) = ISwapPlusv1(swapRouter).swap(mTokens[1], outs[0]*percents[1]/coreDecimal, tokens[1], address(this), paths[2].path);\\r\\n        outs[0] -= outs[0]*percents[1]/coreDecimal;\\r\\n      }\\r\\n    }\\r\\n    return (outs[0], outs[1]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return extraLp, reward, reserved reward, claim extra lp, claim reward amount\\r\\n   */\\r\\n  function _reinvest(\\r\\n    Operator calldata info,\\r\\n    address[2] calldata mtoken,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths,\\r\\n    uint256[2] calldata minAmounts,\\r\\n    bool claimReward\\r\\n  ) internal returns(uint256, uint256, uint256, uint256, uint256) {\\r\\n    uint256[] memory rvar = new uint256[](8);\\r\\n    rvar[0] = ILCPoolPCv3Ledger(ledger).poolToNftId(info.pair[0], info.pair[1], uint24(info.meta)); // tokenId\\r\\n    rvar[1] = IERC20(rewardToken).balanceOf(address(this)); // reward\\r\\n    rvar[2] = 0; // extraLp\\r\\n    rvar[6] = 0; // claim extra lp\\r\\n    rvar[7] = 0; // claim reward amount\\r\\n    if (rvar[0] != 0) {\\r\\n      if (IMasterChefv3(v3MasterChef).pendingCake(rvar[0]) > 0) {\\r\\n        IMasterChefv3(v3MasterChef).harvest(rvar[0], address(this));\\r\\n      }\\r\\n    }\\r\\n    rvar[1] = IERC20(rewardToken).balanceOf(address(this)) - rvar[1];\\r\\n    if (claimReward && rvar[0] != 0) {\\r\\n      (rvar[6], rvar[7]) = ILCPoolPCv3Ledger(ledger).getSingleReward(info.account, rvar[0], info.basketId, rvar[1], false);\\r\\n    }\\r\\n    rvar[1] += ILCPoolPCv3Ledger(ledger).getLastRewardAmount(rvar[0]);\\r\\n\\r\\n    rvar[1] = _distributeFee(info.basketId, rewardToken, rvar[1], 2);\\r\\n    rvar[1] = rvar[1] >= rvar[7] ? rvar[1] - rvar[7] : 0;\\r\\n    rvar[3] = rvar[1]; // reserveReward\\r\\n\\r\\n    if (reinvestAble && rvar[0] != 0 && rvar[1] >= reinvestEdge) {\\r\\n      rvar[3] = IERC20(rewardToken).balanceOf(address(this));\\r\\n      (rvar[4], rvar[5]) = _depositSwap(rewardToken, rvar[1], info.pair, mtoken, percents, paths);\\r\\n      (rvar[2], , ) = _increaseLiquidity(rvar[0], rvar[4], rvar[5], minAmounts[0], minAmounts[1]);\\r\\n      rvar[3] = rvar[1] + IERC20(rewardToken).balanceOf(address(this)) - rvar[3];\\r\\n      emit ReInvest(info.pair[0], info.pair[1], uint24(info.meta), rvar[0], rvar[1], rvar[2]);\\r\\n    }\\r\\n    return (rvar[2], rvar[1], rvar[3], rvar[6], rvar[7]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return tokenId, liquidity\\r\\n   */\\r\\n  function _deposit(\\r\\n    Operator calldata info,\\r\\n    uint256 iAmount,\\r\\n    address[2] calldata mtoken,\\r\\n    uint256[2] calldata percents,\\r\\n    swapPath[3] calldata paths,\\r\\n    uint256[2] calldata minAmounts\\r\\n  ) internal returns(uint256, uint256) {\\r\\n    (uint256 amount0, uint256 amount1) = _depositSwap(info.token, iAmount, info.pair, mtoken, percents, paths);\\r\\n    uint256 tokenId = ILCPoolPCv3Ledger(ledger).poolToNftId(info.pair[0], info.pair[1], uint24(info.meta)); // tokenId\\r\\n    uint128 liquidity = 0;\\r\\n    uint256[] memory amount = new uint256[](2);\\r\\n    if (tokenId == 0) {\\r\\n      (tokenId, liquidity, amount[0], amount[1]) = _mintNewPosition(info.pair[0], info.pair[1], uint24(info.meta), amount0, amount1, minAmounts[0], minAmounts[1]);\\r\\n    }\\r\\n    else {\\r\\n      (liquidity, amount[0], amount[1]) = _increaseLiquidity(tokenId, amount0, amount1, minAmounts[0], minAmounts[1]);\\r\\n    }\\r\\n    _refundReserveToken(info.account, info.pair[0], info.pair[1], amount0-amount[0], amount1-amount[1]);\\r\\n    emit Deposit(tokenId, liquidity);\\r\\n    return (tokenId, uint256(liquidity));\\r\\n  }\\r\\n\\r\\n  function _mintNewPosition(\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint24 fee,\\r\\n    uint256 amount0ToAdd,\\r\\n    uint256 amount1ToAdd,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min\\r\\n  ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) {\\r\\n    _approveTokenIfNeeded(token0, nftManager, amount0ToAdd);\\r\\n    _approveTokenIfNeeded(token1, nftManager, amount1ToAdd);\\r\\n\\r\\n    int24 tickSpacing = IPancakeV3Factory(nftFactory).feeAmountTickSpacing(fee);\\r\\n\\r\\n    INonfungiblePositionManager.MintParams\\r\\n      memory params = INonfungiblePositionManager.MintParams({\\r\\n        token0: token0,\\r\\n        token1: token1,\\r\\n        fee: fee,\\r\\n        tickLower: (MIN_TICK / tickSpacing) * tickSpacing,\\r\\n        tickUpper: (MAX_TICK / tickSpacing) * tickSpacing,\\r\\n        amount0Desired: amount0ToAdd,\\r\\n        amount1Desired: amount1ToAdd,\\r\\n        amount0Min: amount0Min,\\r\\n        amount1Min: amount1Min,\\r\\n        recipient: address(this),\\r\\n        deadline: block.timestamp\\r\\n      });\\r\\n\\r\\n    (tokenId, liquidity, amount0, amount1) = INonfungiblePositionManager(nftManager).mint(params);\\r\\n    INonfungiblePositionManager(nftManager).safeTransferFrom(address(this), v3MasterChef, tokenId);\\r\\n    ILCPoolPCv3Ledger(ledger).setPoolToNftId(token0, token1, fee, tokenId);\\r\\n  }\\r\\n\\r\\n  function _increaseLiquidity(\\r\\n    uint256 tokenId,\\r\\n    uint256 amount0ToAdd,\\r\\n    uint256 amount1ToAdd,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min\\r\\n  ) internal returns (uint128 liquidity, uint256 amount0, uint256 amount1) {\\r\\n    ( , , address token0, address token1, , , , , , , , ) = INonfungiblePositionManager(nftManager).positions(tokenId);\\r\\n\\r\\n    _approveTokenIfNeeded(token0, v3MasterChef, amount0ToAdd);\\r\\n    _approveTokenIfNeeded(token1, v3MasterChef, amount1ToAdd);\\r\\n\\r\\n    INonfungiblePositionManagerStruct.IncreaseLiquidityParams memory params = INonfungiblePositionManagerStruct\\r\\n      .IncreaseLiquidityParams({\\r\\n        tokenId: tokenId,\\r\\n        amount0Desired: amount0ToAdd,\\r\\n        amount1Desired: amount1ToAdd,\\r\\n        amount0Min: amount0Min,\\r\\n        amount1Min: amount1Min,\\r\\n        deadline: block.timestamp\\r\\n      });\\r\\n\\r\\n    (liquidity, amount0, amount1) = IMasterChefv3(v3MasterChef).increaseLiquidity(params);\\r\\n  }\\r\\n\\r\\n  function _refundReserveToken(address account, address token0, address token1, uint256 amount0, uint256 amount1) internal {\\r\\n    if (amount0 > 0) {\\r\\n      IERC20(token0).safeTransfer(account, amount0);\\r\\n    }\\r\\n    if (amount1 > 0) {\\r\\n      IERC20(token1).safeTransfer(account, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _withdrawSwap(\\r\\n    address tokenOut,\\r\\n    address[2] memory tokens,\\r\\n    uint256[2] memory amount,\\r\\n    address[2] memory mTokens,\\r\\n    swapPath[3] memory paths\\r\\n  ) internal returns(uint256) {\\r\\n    uint256 amountM0 = amount[0];\\r\\n    uint256 amountM1 = amount[1];\\r\\n    if (paths[2].path.length > 0) {\\r\\n      _approveTokenIfNeeded(tokens[1], swapRouter, amount[1]);\\r\\n      (, amountM1) = ISwapPlusv1(swapRouter).swap(tokens[1], amount[1], mTokens[1], address(this), paths[2].path);\\r\\n    }\\r\\n\\r\\n    if (paths[1].path.length == 0) {\\r\\n      return amount[0] + amountM1;\\r\\n    }\\r\\n    else {\\r\\n      if (mTokens[1] == tokens[0]) {\\r\\n        amount[0] += amountM1;\\r\\n      }\\r\\n      _approveTokenIfNeeded(tokens[0], swapRouter, amount[0]);\\r\\n      (, amountM0) = ISwapPlusv1(swapRouter).swap(tokens[0], amount[0], mTokens[0], address(this), paths[1].path);\\r\\n    }\\r\\n\\r\\n    if (paths[0].path.length == 0) {\\r\\n      if (mTokens[0] == mTokens[1]) return amountM0+amountM1;\\r\\n      else return amountM0;\\r\\n    }\\r\\n    else {\\r\\n      _approveTokenIfNeeded(mTokens[0], swapRouter, amountM0+amountM1);\\r\\n      (, amountM0) = ISwapPlusv1(swapRouter).swap(mTokens[0], amountM0+amountM1, tokenOut, address(this), paths[0].path);\\r\\n      return amountM0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * return tokenId, withdraw liquidity amount, receive token amount\\r\\n   */\\r\\n  function _withdraw(\\r\\n    Operator calldata info,\\r\\n    uint256 extraLp,\\r\\n    address[2] memory mtoken,\\r\\n    swapPath[3] memory paths,\\r\\n    uint256[2] memory minAmounts\\r\\n  ) internal returns(uint256, uint256, uint256) {\\r\\n    uint256 tokenId = ILCPoolPCv3Ledger(ledger).poolToNftId(info.pair[0], info.pair[1], uint24(info.meta));\\r\\n    if (tokenId == 0) {\\r\\n      return (0, 0, 0);\\r\\n    }\\r\\n    else {\\r\\n      uint256 withdrawAmount = info.amount;\\r\\n      uint256 userLiquidity = ILCPoolPCv3Ledger(ledger).getUserLiquidity(info.account, tokenId, info.basketId);\\r\\n      if (userLiquidity < withdrawAmount) {\\r\\n        withdrawAmount = userLiquidity;\\r\\n      }\\r\\n      uint256[] memory amount = new uint256[](3);\\r\\n      withdrawAmount += extraLp;\\r\\n      (, , , , , , , uint128 liquidity0, , , ,) = INonfungiblePositionManager(nftManager).positions(tokenId);\\r\\n      if (uint256(liquidity0) < withdrawAmount) {\\r\\n        withdrawAmount = uint256(liquidity0);\\r\\n      }\\r\\n      if (withdrawAmount > 0) {\\r\\n        (amount[0], amount[1]) = _decreaseLiquidity(tokenId, uint128(withdrawAmount), minAmounts[0], minAmounts[1]);\\r\\n        amount[2] = _withdrawSwap(info.token, info.pair, [amount[0], amount[1]], mtoken, paths);\\r\\n        emit Withdraw(tokenId, withdrawAmount, amount[2]);\\r\\n        return (tokenId, withdrawAmount, amount[2]);\\r\\n      }\\r\\n      else {\\r\\n        return (tokenId, withdrawAmount, 0);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _decreaseLiquidity(\\r\\n    uint256 tokenId,\\r\\n    uint128 liquidity,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min\\r\\n  ) internal returns (uint256, uint256) {\\r\\n    INonfungiblePositionManagerStruct.DecreaseLiquidityParams\\r\\n      memory params = INonfungiblePositionManagerStruct\\r\\n        .DecreaseLiquidityParams({\\r\\n          tokenId: tokenId,\\r\\n          liquidity: liquidity,\\r\\n          amount0Min: amount0Min,\\r\\n          amount1Min: amount1Min,\\r\\n          deadline: block.timestamp\\r\\n        });\\r\\n\\r\\n    IMasterChefv3(v3MasterChef).decreaseLiquidity(params);\\r\\n\\r\\n    INonfungiblePositionManagerStruct.CollectParams memory cparams = INonfungiblePositionManagerStruct\\r\\n      .CollectParams({\\r\\n        tokenId: tokenId,\\r\\n        recipient: address(this),\\r\\n        amount0Max: type(uint128).max,\\r\\n        amount1Max: type(uint128).max\\r\\n      });\\r\\n    return IMasterChefv3(v3MasterChef).collect(cparams);\\r\\n  }\\r\\n\\r\\n  // mode 0: withdraw 1: deposit 2: reward\\r\\n  function _distributeFee(uint256 basketId, address token, uint256 amount, uint256 mode) internal returns(uint256) {\\r\\n    uint256[] memory fvar = new uint256[](4);\\r\\n    fvar[0] = 0; // totalFee\\r\\n    fvar[1] = 0; // baseFee\\r\\n    if (mode == 0) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getWithdrawFee(basketId);\\r\\n    }\\r\\n    else if (mode == 1) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getDepositFee(basketId);\\r\\n    }\\r\\n    else if (mode == 2) {\\r\\n      (fvar[0], fvar[1]) = IFeeTierStrate(feeStrate).getTotalFee(basketId);\\r\\n    }\\r\\n\\r\\n    fvar[2] = amount; // rewardReserve\\r\\n    require(fvar[1] > 0, \\\"LC pool: wrong fee configure\\\");\\r\\n    fvar[3] = amount * fvar[0] / fvar[1]; // rewardLc\\r\\n\\r\\n    if (fvar[3] > 0) {\\r\\n      uint256[] memory feeIndexs = IFeeTierStrate(feeStrate).getAllTier();\\r\\n      uint256 len = feeIndexs.length;\\r\\n      uint256 maxFee = IFeeTierStrate(feeStrate).getMaxFee();\\r\\n      for (uint256 i=0; i<len; i++) {\\r\\n        (address feeAccount, ,uint256 fee) = IFeeTierStrate(feeStrate).getTier(feeIndexs[i]);\\r\\n        uint256 feeAmount = fvar[3] * fee / maxFee;\\r\\n        if (feeAmount > 0 && fvar[2] >= feeAmount && IERC20(token).balanceOf(address(this)) > feeAmount) {\\r\\n          IERC20(token).safeTransfer(feeAccount, feeAmount);\\r\\n          emit LcFee(feeAccount, token, feeAmount);\\r\\n          fvar[2] -= feeAmount;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return fvar[2];\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setOperator(address account, bool access) public onlyManager {\\r\\n    operators[account] = access;\\r\\n  }\\r\\n\\r\\n  function setFeeStrate(address _feeStrate) external onlyManager {\\r\\n    require(_feeStrate != address(0), \\\"LC pool: Fee Strate\\\");\\r\\n    feeStrate = _feeStrate;\\r\\n  }\\r\\n\\r\\n  function setSwapRouter(address _swapRouter) external onlyManager {\\r\\n    require(_swapRouter != address(0), \\\"LC pool: Swap Router\\\");\\r\\n    swapRouter = _swapRouter;\\r\\n  }\\r\\n\\r\\n  function setReinvestInfo(bool able, uint256 edge) public onlyManager {\\r\\n    reinvestAble = able;\\r\\n    reinvestEdge = edge;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\r\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\r\\n      IERC20(token).safeApprove(spender, 0);\\r\\n      IERC20(token).safeApprove(spender, type(uint256).max);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"./draft-IERC20Permit.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n  function deposit() external payable;\\r\\n  function withdraw(uint amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/ISwapPlusv1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ISwapPlusv1 {\\r\\n  struct swapRouter {\\r\\n    string platform;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 amountOutMin;\\r\\n    uint256 meta; // fee, flag(stable), 0=v2\\r\\n    uint256 percent;\\r\\n  }\\r\\n  struct swapLine {\\r\\n    swapRouter[] swaps;\\r\\n  }\\r\\n  struct swapBlock {\\r\\n    swapLine[] lines;\\r\\n  }\\r\\n\\r\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IPancakeV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IPancakeV3Factory {\\r\\n  function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/INonfungiblePositionManagerStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface INonfungiblePositionManagerStruct {\\r\\n  struct IncreaseLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    uint256 amount0Desired;\\r\\n    uint256 amount1Desired;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  struct DecreaseLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    uint128 liquidity;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  struct CollectParams {\\r\\n    uint256 tokenId;\\r\\n    address recipient;\\r\\n    uint128 amount0Max;\\r\\n    uint128 amount1Max;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface INonfungiblePositionManager {\\r\\n  event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n  event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n  event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\\r\\n\\r\\n  function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint96 nonce,\\r\\n      address operator,\\r\\n      address token0,\\r\\n      address token1,\\r\\n      uint24 fee,\\r\\n      int24 tickLower,\\r\\n      int24 tickUpper,\\r\\n      uint128 liquidity,\\r\\n      uint256 feeGrowthInside0LastX128,\\r\\n      uint256 feeGrowthInside1LastX128,\\r\\n      uint128 tokensOwed0,\\r\\n      uint128 tokensOwed1\\r\\n    );\\r\\n\\r\\n  struct MintParams {\\r\\n    address token0;\\r\\n    address token1;\\r\\n    uint24 fee;\\r\\n    int24 tickLower;\\r\\n    int24 tickUpper;\\r\\n    uint256 amount0Desired;\\r\\n    uint256 amount1Desired;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    address recipient;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  function mint(MintParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n      uint256 tokenId,\\r\\n      uint128 liquidity,\\r\\n      uint256 amount0,\\r\\n      uint256 amount1\\r\\n    );\\r\\n\\r\\n  struct IncreaseLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    uint256 amount0Desired;\\r\\n    uint256 amount1Desired;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n      uint128 liquidity,\\r\\n      uint256 amount0,\\r\\n      uint256 amount1\\r\\n    );\\r\\n\\r\\n  struct DecreaseLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    uint128 liquidity;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  function decreaseLiquidity(DecreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n  struct CollectParams {\\r\\n    uint256 tokenId;\\r\\n    address recipient;\\r\\n    uint128 amount0Max;\\r\\n    uint128 amount1Max;\\r\\n  }\\r\\n\\r\\n  function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\r\\n  function burn(uint256 tokenId) external payable;\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IMasterChefv3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./INonfungiblePositionManagerStruct.sol\\\";\\r\\n\\r\\ninterface IMasterChefv3 is INonfungiblePositionManagerStruct {\\r\\n  function decreaseLiquidity(\\r\\n    DecreaseLiquidityParams memory params\\r\\n  ) external payable returns (uint256 amount0, uint256 amount1);\\r\\n  \\r\\n  function increaseLiquidity(\\r\\n    IncreaseLiquidityParams memory params\\r\\n  ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);\\r\\n\\r\\n  function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n  function withdraw(uint256 _tokenId, address _to) external returns (uint256 reward);\\r\\n\\r\\n  function harvest(uint256 _tokenId, address _to) external returns (uint256 reward);\\r\\n\\r\\n  function pendingCake(uint256 _tokenId) external view returns (uint256 reward);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ILCPoolPCv3Ledger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ILCPoolPCv3Ledger {\\r\\n  // token0 -> token1 -> fee -> nftId\\r\\n  function poolToNftId(address token0, address token1, uint24 fee) external view returns(uint256);\\r\\n  function setPoolToNftId(address token0, address token1, uint24 fee, uint256 id) external;\\r\\n\\r\\n  function getLastRewardAmount(uint256 tokenId) external view returns(uint256);\\r\\n  function getUserLiquidity(address account, uint256 tokenId, uint256 basketId) external view returns(uint256);\\r\\n\\r\\n  function updateInfo(\\r\\n    address acc,\\r\\n    uint256 tId,\\r\\n    uint256 bId,\\r\\n    uint256 liquidity,\\r\\n    uint256 reward,\\r\\n    uint256 rewardAfter,\\r\\n    uint256 exLp,\\r\\n    bool increase\\r\\n  ) external;\\r\\n\\r\\n  function getSingleReward(address acc, uint256 tId, uint256 bId, uint256 currentReward, bool cutfee)\\r\\n    external view returns(uint256, uint256);\\r\\n  function getReward(address account, uint256[] memory tokenId, uint256[] memory basketIds) external view\\r\\n    returns(uint256[] memory, uint256[] memory);\\r\\n  function poolInfoLength(uint256 tokenId) external view returns(uint256);\\r\\n  function reInvestInfoLength(uint256 tokenId) external view returns(uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IFeeTierStrate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IFeeTierStrate {\\r\\n  function getMaxFee() external view returns(uint256);\\r\\n  function getDepositFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getTotalFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getWithdrawFee(uint256 id) external view returns(uint256, uint256);\\r\\n  function getAllTier() external view returns(uint256[] memory);\\r\\n  function getTier(uint256 index) external view returns(address, string memory, uint256);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n  function onERC721Received(\\r\\n    address operator,\\r\\n    address from,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external returns (bytes4);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v3MasterChef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ledger\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reward\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extraLp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquiidty\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LcFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extraLp\",\"type\":\"uint256\"}],\"name\":\"ReInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RemovePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquiidty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"pair\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LCPoolPCv3.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"address[2][2]\",\"name\":\"mtoken\",\"type\":\"address[2][2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"percent\",\"type\":\"uint256[2][2]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolPCv3.swapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolPCv3.swapPath[3]\",\"name\":\"rpaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"minAmounts\",\"type\":\"uint256[2][2]\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeStrate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ledger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestAble\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestEdge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeStrate\",\"type\":\"address\"}],\"name\":\"setFeeStrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"able\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"edge\",\"type\":\"uint256\"}],\"name\":\"setReinvestInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"v3MasterChef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"pair\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LCPoolPCv3.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"address[2][2]\",\"name\":\"mtoken\",\"type\":\"address[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"percent\",\"type\":\"uint256[2]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolPCv3.swapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LCPoolPCv3.swapPath[3]\",\"name\":\"rpaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"minAmounts\",\"type\":\"uint256[2][2]\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LCPoolPCv3", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000046a15b0b27311cedf172ab29e4f4766fbe7f43640000000000000000000000000bfbcf9fa4f9c56b0f40a671ad40e0805a091865000000000000000000000000556b9306565093c855aea9ae92a594704c2cd59e00000000000000000000000091f6aa43c190e317e4d02698127aa7a629cf4b23000000000000000000000000471200ce99a9608b5676660c98d31167825af1de00000000000000000000000018387dfc5cf69164aeb086e8fa5aa29a0dc44fb2000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000152649ea73beab28c5b49b26eb48f7ead6d4c898", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}