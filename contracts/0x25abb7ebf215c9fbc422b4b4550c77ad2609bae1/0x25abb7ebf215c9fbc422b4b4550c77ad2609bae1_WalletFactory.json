{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/WalletDeploymentLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/Create2.sol\\\";\\nimport \\\"../thirdparty/proxies/WalletProxy.sol\\\";\\n\\n\\n/// @title WalletDeploymentLib\\n/// @dev Functionality to compute wallet addresses and to deploy wallets\\n/// @author Brecht Devos - <brecht@loopring.org>\\ncontract WalletDeploymentLib\\n{\\n    address public immutable walletImplementation;\\n\\n    string  public constant WALLET_CREATION = \\\"WALLET_CREATION\\\";\\n\\n    constructor(\\n        address _walletImplementation\\n        )\\n    {\\n        walletImplementation = _walletImplementation;\\n    }\\n\\n    function getWalletCode()\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            type(WalletProxy).creationCode,\\n            abi.encode(walletImplementation)\\n        );\\n    }\\n\\n    function computeWalletSalt(\\n        address owner,\\n        uint    salt\\n        )\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                WALLET_CREATION,\\n                owner,\\n                salt\\n            )\\n        );\\n    }\\n\\n    function _deploy(\\n        address owner,\\n        uint    salt\\n        )\\n        internal\\n        returns (address payable wallet)\\n    {\\n        wallet = Create2.deploy(\\n            computeWalletSalt(owner, salt),\\n            getWalletCode()\\n        );\\n    }\\n\\n    function _computeWalletAddress(\\n        address owner,\\n        uint    salt,\\n        address deployer\\n        )\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return Create2.computeAddress(\\n            computeWalletSalt(owner, salt),\\n            getWalletCode(),\\n            deployer\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/WalletFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../iface/ILoopringWalletV2.sol\\\";\\nimport \\\"../lib/EIP712.sol\\\";\\nimport \\\"../lib/SignatureUtil.sol\\\";\\nimport \\\"./WalletDeploymentLib.sol\\\";\\nimport \\\"../lib/Ownable.sol\\\";\\nimport \\\"../lib/AddressSet.sol\\\";\\n\\n\\n/// @title WalletFactory\\n/// @dev A factory contract to create a new wallet by deploying a proxy\\n///      in front of a real wallet.\\n/// @author Daniel Wang - <daniel@loopring.org>\\ncontract WalletFactory is WalletDeploymentLib, Ownable, AddressSet\\n{\\n\\n    bytes32 internal constant OPERATOR = keccak256(\\\"__OPERATOR__\\\");\\n    using SignatureUtil for bytes32;\\n\\n    event WalletCreated (address wallet, address owner);\\n\\n    event OperatorRemoved  (address indexed operator);\\n    event OperatorAdded(address indexed operator);\\n\\n    bytes32             public immutable DOMAIN_SEPARATOR;\\n\\n    bytes32 public constant CREATE_WALLET_TYPEHASH = keccak256(\\n        \\\"createWallet(address owner,address[] guardians,uint256 quota,address inheritor,address feeRecipient,address feeToken,uint256 maxFeeAmount,uint256 salt)\\\");\\n\\n    ///////////////////////////////// opeartor ///////////////////\\n    modifier onlyOperator\\n    {\\n        require(isOperator(msg.sender), \\\"DISALLOWED_ON_IMPLEMENTATION_CONTRACT\\\");\\n        _;\\n    }\\n\\n    function isOperator(address addr)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return isAddressInSet(OPERATOR, addr);\\n    }\\n\\n    /// @dev Gets the operators.\\n    /// @return The list of operators.\\n    function operators()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return addressesInSet(OPERATOR);\\n    }\\n\\n    /// @dev Gets the number of operators.\\n    /// @return The numer of operators.\\n    function numOperators()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return numAddressesInSet(OPERATOR);\\n    }\\n\\n    /// @dev Adds a new operator.\\n    /// @param operator The new address to add.\\n    function addOperator(address operator)\\n        public\\n        onlyOwner\\n    {\\n        addOperatorInternal(operator);\\n    }\\n\\n    /// @dev Removes a operator.\\n    /// @param operator The operator to remove.\\n    function removeOperator(address operator)\\n        public\\n        onlyOwner\\n    {\\n        removeAddressFromSet(OPERATOR, operator);\\n        emit OperatorRemoved(operator);\\n    }\\n\\n    function addOperatorInternal(address operator)\\n        internal\\n    {\\n        addAddressToSet(OPERATOR, operator, true);\\n        emit OperatorAdded(operator);\\n    }\\n\\n    struct WalletConfig\\n    {\\n        address   owner;\\n        address[] guardians;\\n        uint      quota;\\n        address   inheritor;\\n        address   feeRecipient;\\n        address   feeToken;\\n        uint      maxFeeAmount;\\n        uint      salt;\\n        bytes     signature;\\n    }\\n\\n    struct WalletConfigV2\\n    {\\n        address   owner;\\n        address   initOwner;\\n        address[] guardians;\\n        uint      quota;\\n        address   inheritor;\\n        address   feeRecipient;\\n        address   feeToken;\\n        uint      maxFeeAmount;\\n        uint      salt;\\n    }\\n\\n    constructor(\\n        address        _walletImplementation\\n        )\\n        WalletDeploymentLib(_walletImplementation)\\n    {\\n        DOMAIN_SEPARATOR = EIP712.hash(\\n            EIP712.Domain(\\\"WalletFactory\\\", \\\"2.0.0\\\", address(this))\\n        );\\n    }\\n\\n    /// @dev Create a new wallet by deploying a proxy.\\n    /// @param config The wallet's config.\\n    /// @param feeAmount The fee amount actually paid.\\n    /// @return wallet The new wallet address\\n    function createWallet(\\n        WalletConfig calldata config,\\n        uint                  feeAmount\\n        )\\n        onlyOperator\\n        external\\n        returns (address wallet)\\n    {\\n        require(feeAmount <= config.maxFeeAmount, \\\"INVALID_FEE_AMOUNT\\\");\\n\\n        _validateConfig(config);\\n        wallet = _deploy(config.owner, config.salt);\\n        _initializeWallet(wallet, config, feeAmount);\\n    }\\n\\n    /// @dev Create a new wallet by deploying a proxy.\\n    /// @param config The wallet's config.\\n    /// @param feeAmount The fee amount actually paid.\\n    /// @return wallet The new wallet address\\n    function createWalletByOperator(\\n        WalletConfigV2 calldata config,\\n        uint                  feeAmount\\n        )\\n        onlyOperator\\n        external\\n        returns (address wallet)\\n    {\\n        require(feeAmount <= config.maxFeeAmount, \\\"INVALID_FEE_AMOUNT\\\");\\n\\n        require(config.owner != address(0), \\\"INVALID_OWNER\\\");\\n        wallet = _deploy(config.initOwner, config.salt);\\n        ILoopringWalletV2(wallet).initialize(\\n            config.owner,\\n            config.guardians,\\n            config.quota,\\n            config.inheritor,\\n            config.feeRecipient,\\n            config.feeToken,\\n            feeAmount\\n        );\\n\\n        emit WalletCreated(wallet, config.owner);\\n    }\\n\\n    /// @dev Computes the wallet address\\n    /// @param salt The initial wallet owner.\\n    /// @param salt A salt.\\n    /// @return wallet The wallet address\\n    function computeWalletAddress(\\n        address owner,\\n        uint    salt\\n        )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return _computeWalletAddress(\\n            owner,\\n            salt,\\n            address(this)\\n        );\\n    }\\n\\n    // --- Internal functions ---\\n\\n    function _initializeWallet(\\n        address               wallet,\\n        WalletConfig calldata config,\\n        uint                  feeAmount\\n        )\\n        internal\\n    {\\n        ILoopringWalletV2(wallet).initialize(\\n            config.owner,\\n            config.guardians,\\n            config.quota,\\n            config.inheritor,\\n            config.feeRecipient,\\n            config.feeToken,\\n            feeAmount\\n        );\\n\\n        emit WalletCreated(wallet, config.owner);\\n    }\\n\\n    function _validateConfig(\\n        WalletConfig calldata config\\n        )\\n        private\\n        view\\n    {\\n        require(config.owner != address(0), \\\"INVALID_OWNER\\\");\\n\\n        bytes32 dataHash = keccak256(\\n            abi.encode(\\n                CREATE_WALLET_TYPEHASH,\\n                config.owner,\\n                keccak256(abi.encodePacked(config.guardians)),\\n                config.quota,\\n                config.inheritor,\\n                config.feeRecipient,\\n                config.feeToken,\\n                config.maxFeeAmount,\\n                config.salt\\n            )\\n        );\\n\\n        bytes32 signHash = EIP712.hashPacked(DOMAIN_SEPARATOR, dataHash);\\n        require(signHash.verifySignature(config.owner, config.signature), \\\"INVALID_SIGNATURE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/iface/ILoopringWalletV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Loopring SmartWallet V2 interface\\n/// @author Brecht Devos - <brecht@loopring.org>\\nabstract contract ILoopringWalletV2\\n{\\n    /// @dev Initializes the smart wallet.\\n    /// @param owner The wallet owner address.\\n    /// @param guardians The initial wallet guardians.\\n    /// @param quota The initial wallet quota.\\n    /// @param inheritor The inheritor of the wallet.\\n    /// @param feeRecipient The address receiving the fee for creating the wallet.\\n    /// @param feeToken The token to use for the fee payment.\\n    /// @param feeAmount The amount of tokens paid to the fee recipient.\\n    function initialize(\\n        address             owner,\\n        address[] calldata  guardians,\\n        uint                quota,\\n        address             inheritor,\\n        address             feeRecipient,\\n        address             feeToken,\\n        uint                feeAmount\\n        )\\n        external\\n        virtual;\\n\\n    /// @dev Returns the timestamp the wallet was created.\\n    /// @return The timestamp the wallet was created.\\n    function getCreationTimestamp()\\n        public\\n        view\\n        virtual\\n        returns (uint64);\\n\\n    /// @dev Returns the current wallet owner.\\n    /// @return The current wallet owner.\\n    function getOwner()\\n        public\\n        view\\n        virtual\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title AddressSet\\n/// @author Daniel Wang - <daniel@loopring.org>\\ncontract AddressSet\\n{\\n    struct Set\\n    {\\n        address[] addresses;\\n        mapping (address => uint) positions;\\n        uint count;\\n    }\\n    mapping (bytes32 => Set) private sets;\\n\\n    function addAddressToSet(\\n        bytes32 key,\\n        address addr,\\n        bool    maintainList\\n        ) internal\\n    {\\n        Set storage set = sets[key];\\n        require(set.positions[addr] == 0, \\\"ALREADY_IN_SET\\\");\\n\\n        if (maintainList) {\\n            require(set.addresses.length == set.count, \\\"PREVIOUSLY_NOT_MAINTAILED\\\");\\n            set.addresses.push(addr);\\n        } else {\\n            require(set.addresses.length == 0, \\\"MUST_MAINTAIN\\\");\\n        }\\n\\n        set.count += 1;\\n        set.positions[addr] = set.count;\\n    }\\n\\n    function removeAddressFromSet(\\n        bytes32 key,\\n        address addr\\n        )\\n        internal\\n    {\\n        Set storage set = sets[key];\\n        uint pos = set.positions[addr];\\n        require(pos != 0, \\\"NOT_IN_SET\\\");\\n\\n        delete set.positions[addr];\\n        set.count -= 1;\\n\\n        if (set.addresses.length > 0) {\\n            address lastAddr = set.addresses[set.count];\\n            if (lastAddr != addr) {\\n                set.addresses[pos - 1] = lastAddr;\\n                set.positions[lastAddr] = pos;\\n            }\\n            set.addresses.pop();\\n        }\\n    }\\n\\n    function removeSet(bytes32 key)\\n        internal\\n    {\\n        delete sets[key];\\n    }\\n\\n    function isAddressInSet(\\n        bytes32 key,\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return sets[key].positions[addr] != 0;\\n    }\\n\\n    function numAddressesInSet(bytes32 key)\\n        internal\\n        view\\n        returns (uint)\\n    {\\n        Set storage set = sets[key];\\n        return set.count;\\n    }\\n\\n    function addressesInSet(bytes32 key)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        Set storage set = sets[key];\\n        require(set.count == set.addresses.length, \\\"NOT_MAINTAINED\\\");\\n        return sets[key].addresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for addresses\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @author Brecht Devos - <brecht@loopring.org>\\nlibrary AddressUtil\\n{\\n    using AddressUtil for *;\\n\\n    function isContract(\\n        address addr\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(addr) }\\n        return (codehash != 0x0 &&\\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n\\n    function toPayable(\\n        address addr\\n        )\\n        internal\\n        pure\\n        returns (address payable)\\n    {\\n        return payable(addr);\\n    }\\n\\n    // Works like address.send but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETH(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        address payable recipient = to.toPayable();\\n        /* solium-disable-next-line */\\n        (success,) = recipient.call{value: amount, gas: gasLimit}(\\\"\\\");\\n    }\\n\\n    // Works like address.transfer but with a customizable gas limit\\n    // Make sure your code is safe for reentrancy when using this function!\\n    function sendETHAndVerify(\\n        address to,\\n        uint    amount,\\n        uint    gasLimit\\n        )\\n        internal\\n        returns (bool success)\\n    {\\n        success = to.sendETH(amount, gasLimit);\\n        require(success, \\\"TRANSFER_FAILURE\\\");\\n    }\\n\\n    // Works like call but is slightly more efficient when data\\n    // needs to be copied from memory to do the call.\\n    function fastCall(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        if (to != address(0)) {\\n            assembly {\\n                // Do the call\\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\\n                // Copy the return data\\n                let size := returndatasize()\\n                returnData := mload(0x40)\\n                mstore(returnData, size)\\n                returndatacopy(add(returnData, 32), 0, size)\\n                // Update free memory pointer\\n                mstore(0x40, add(returnData, add(32, size)))\\n            }\\n        }\\n    }\\n\\n    // Like fastCall, but throws when the call is unsuccessful.\\n    function fastCallAndVerify(\\n        address to,\\n        uint    gasLimit,\\n        uint    value,\\n        bytes   memory data\\n        )\\n        internal\\n        returns (bytes memory returnData)\\n    {\\n        bool success;\\n        (success, returnData) = fastCall(to, gasLimit, value, data);\\n        if (!success) {\\n            assembly {\\n                revert(add(returnData, 32), mload(returnData))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n\\nlibrary EIP712\\n{\\n    struct Domain {\\n        string  name;\\n        string  version;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    string constant internal EIP191_HEADER = \\\"\\\\x19\\\\x01\\\";\\n\\n    function hash(Domain memory domain)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        uint _chainid;\\n        assembly { _chainid := chainid() }\\n\\n        return keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(domain.name)),\\n                keccak256(bytes(domain.version)),\\n                _chainid,\\n                domain.verifyingContract\\n            )\\n        );\\n    }\\n\\n    function hashPacked(\\n        bytes32 domainSeparator,\\n        bytes32 dataHash\\n        )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                EIP191_HEADER,\\n                domainSeparator,\\n                dataHash\\n            )\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/ERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function isValidSignature(\\n        bytes32      _hash,\\n        bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MathUint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Utility Functions for uint\\n/// @author Daniel Wang - <daniel@loopring.org>\\nlibrary MathUint\\n{\\n    function mul(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a * b;\\n        require(a == 0 || c / a == b, \\\"MUL_OVERFLOW\\\");\\n    }\\n\\n    function sub(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        require(b <= a, \\\"SUB_UNDERFLOW\\\");\\n        return a - b;\\n    }\\n\\n    function add(\\n        uint a,\\n        uint b\\n        )\\n        internal\\n        pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\n\\n\\n/// @title Ownable\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @dev The Ownable contract has an owner address, and provides basic\\n///      authorization control functions, this simplifies the implementation of\\n///      \\\"user permissions\\\".\\ncontract Ownable\\n{\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev The Ownable constructor sets the original `owner` of the contract\\n    ///      to the sender.\\n    constructor()\\n    {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner()\\n    {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    /// @dev Allows the current owner to transfer control of the contract to a\\n    ///      new owner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(\\n        address newOwner\\n        )\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(newOwner != address(0), \\\"ZERO_ADDRESS\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function renounceOwnership()\\n        public\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SignatureUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright 2017 Loopring Technology Limited.\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../thirdparty/BytesUtil.sol\\\";\\nimport \\\"./AddressUtil.sol\\\";\\nimport \\\"./ERC1271.sol\\\";\\nimport \\\"./MathUint.sol\\\";\\n\\n\\n/// @title SignatureUtil\\n/// @author Daniel Wang - <daniel@loopring.org>\\n/// @dev This method supports multihash standard. Each signature's last byte indicates\\n///      the signature's type.\\nlibrary SignatureUtil\\n{\\n    using BytesUtil     for bytes;\\n    using MathUint      for uint;\\n    using AddressUtil   for address;\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP_712,\\n        ETH_SIGN,\\n        WALLET   // deprecated\\n    }\\n\\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\\n\\n    function verifySignatures(\\n        bytes32          signHash,\\n        address[] memory signers,\\n        bytes[]   memory signatures\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(signers.length == signatures.length, \\\"BAD_SIGNATURE_DATA\\\");\\n        address lastSigner;\\n        for (uint i = 0; i < signers.length; i++) {\\n            require(signers[i] > lastSigner, \\\"INVALID_SIGNERS_ORDER\\\");\\n            lastSigner = signers[i];\\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function verifySignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n        return signer.isContract()?\\n            verifyERC1271Signature(signHash, signer, signature):\\n            verifyEOASignature(signHash, signer, signature);\\n    }\\n\\n    function recoverECDSASigner(\\n        bytes32      signHash,\\n        bytes memory signature\\n        )\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (signature.length != 65) {\\n            return address(0);\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8   v;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := and(mload(add(signature, 0x41)), 0xff)\\n        }\\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n        if (v == 27 || v == 28) {\\n            return ecrecover(signHash, v, r, s);\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    function verifyEOASignature(\\n        bytes32        signHash,\\n        address        signer,\\n        bytes   memory signature\\n        )\\n        private\\n        pure\\n        returns (bool success)\\n    {\\n        if (signer == address(0)) {\\n            return false;\\n        }\\n\\n\\trequire(signature.length == 65 || signature.length == 66, \\\"INVALID_SIGNATURE_LENGTH\\\");\\n\\n\\tbool trimmed = false;\\n\\tif (signature.length == 66) {\\n\\t    // Strip off the last byte of the signature by updating the length\\n\\t    assembly {\\n\\t\\tmstore(signature, 65)\\n\\t    }\\n\\n\\t    trimmed = true;\\n\\t}\\n\\n\\tsuccess = (signer == recoverECDSASigner(signHash, signature));\\n\\tif (!success) {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", signHash)\\n            );\\n            success = (signer == recoverECDSASigner(hash, signature));\\n        }\\n\\n\\tif (trimmed) {\\n\\t    // Restore the signature length\\n\\t    assembly {\\n\\t\\tmstore(signature, 66)\\n\\t    }\\n\\t}\\n    }\\n\\n    function verifyERC1271Signature(\\n        bytes32 signHash,\\n        address signer,\\n        bytes   memory signature\\n        )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ERC1271.isValidSignature.selector,\\n            signHash,\\n            signature\\n        );\\n        (bool success, bytes memory result) = signer.staticcall(callData);\\n        return (\\n            success &&\\n            result.length == 32 &&\\n            result.toBytes4(0) == ERC1271_MAGICVALUE\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/BytesUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\npragma solidity ^0.7.0;\\n\\nlibrary BytesUtil {\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\\n        require(_bytes.length >= (_start + 20));\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\\n        require(_bytes.length >= (_start + 1));\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\\n        require(_bytes.length >= (_start + 2));\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\\n        require(_bytes.length >= (_start + 3));\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\\n        require(_bytes.length >= (_start + 4));\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\\n        require(_bytes.length >= (_start + 8));\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\\n        require(_bytes.length >= (_start + 12));\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\\n        require(_bytes.length >= (_start + 16));\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\\n        require(_bytes.length >= (_start + 32));\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\\n        require(_bytes.length >= (_start + 4));\\n        bytes4 tempBytes4;\\n\\n        assembly {\\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes4;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\\n        require(_bytes.length >= (_start + 32));\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function fastSHA256(\\n        bytes memory data\\n        )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32[] memory result = new bytes32[](1);\\n        bool success;\\n        assembly {\\n             let ptr := add(data, 32)\\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\\n        }\\n        require(success, \\\"SHA256_FAILED\\\");\\n        return result[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/970f687f04d20e01138a3e8ccf9278b1d4b3997b/contracts/utils/Create2.sol\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}. Note that\\n     * a contract cannot be deployed twice using the same salt.\\n     */\\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address payable) {\\n        address payable addr;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"CREATE2_FAILED\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\\n     * or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\\n        return computeAddress(salt, bytecode, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\\n        );\\n        return address(bytes20(_data << 96));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/thirdparty/proxies/WalletProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n// Taken from: https://github.com/gnosis/safe-contracts/blob/development/contracts/proxies/GnosisSafeProxy.sol\\npragma solidity ^0.7.0;\\n\\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\\n/// @author Richard Meissner - <richard@gnosis.io>\\ninterface IProxy {\\n    function masterCopy() external view returns (address);\\n}\\n\\n/// @title WalletProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\\n/// @author Stefan George - <stefan@gnosis.io>\\n/// @author Richard Meissner - <richard@gnosis.io>\\ncontract WalletProxy {\\n\\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\\n    address internal masterCopy;\\n\\n    /// @dev Constructor function sets address of master copy contract.\\n    /// @param _masterCopy Master copy address.\\n    constructor(address _masterCopy)\\n    {\\n        require(_masterCopy != address(0), \\\"Invalid master copy address provided\\\");\\n        masterCopy = _masterCopy;\\n    }\\n\\n    /// @dev Fallback function forwards all transactions and returns all received return data.\\n    fallback()\\n        payable\\n        external\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let _masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\\n            // 0xa619486e == keccak(\\\"masterCopy()\\\"). The value is right padded to 32-bytes with 0s\\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\\n                mstore(0, _masterCopy)\\n                return(0, 0x20)\\n            }\\n            calldatacopy(0, 0, calldatasize())\\n            let success := delegatecall(gas(), _masterCopy, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if eq(success, 0) { revert(0, returndatasize()) }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREATE_WALLET_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_CREATION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"computeWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"computeWalletSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inheritor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletFactory.WalletConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inheritor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct WalletFactory.WalletConfigV2\",\"name\":\"config\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"createWalletByOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWalletCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOperators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WalletFactory", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "00000000000000000000000023a19a97a2da581e3d66ef5fd1eea15024f55611", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}