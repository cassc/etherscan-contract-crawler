{"SourceCode": "{\"contract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeTransfer.sol\\\";\\n\\ncontract Sandwich {\\n    using SafeTransfer for IERC20;\\n\\n    // Authorized\\n    address internal immutable user;\\n\\n    // transfer(address,uint256)\\n    bytes4 internal constant ERC20_TRANSFER_ID = 0xa9059cbb;\\n\\n    // swap(uint256,uint256,address,bytes)\\n    bytes4 internal constant PAIR_SWAP_ID = 0x022c0d9f;\\n\\n    // Contructor sets the only user\\n    receive() external payable {}\\n\\n    constructor(address _owner) {\\n        user = _owner;\\n    }\\n\\n    // *** Receive profits from contract *** //\\n    function recoverERC20(address token) public {\\n        require(msg.sender == user, \\\"shoo\\\");\\n        IERC20(token).safeTransfer(\\n            msg.sender,\\n            IERC20(token).balanceOf(address(this))\\n        );\\n    }\\n\\n    /*\\n        Fallback function where you do your frontslice and backslice\\n\\n        NO UNCLE BLOCK PROTECTION IN PLACE, USE AT YOUR OWN RISK\\n\\n        Payload structure (abi encodePacked)\\n\\n        - token: address        - Address of the token you\\u0027re swapping\\n        - pair: address         - Univ2 pair you\\u0027re sandwiching on\\n        - amountIn: uint128     - Amount you\\u0027re giving via swap\\n        - amountOut: uint128    - Amount you\\u0027re receiving via swap\\n        - tokenOutNo: uint8     - Is the token you\\u0027re giving token0 or token1? (On univ2 pair)\\n\\n        Note: This fallback function generates some dangling bits\\n    */\\n    fallback() external payable {\\n        // Assembly cannot read immutable variables\\n        address memUser = user;\\n\\n        assembly {\\n            // You can only access teh fallback function if you\\u0027re authorized\\n            if iszero(eq(caller(), memUser)) {\\n                // Ohm (3, 3) makes your code more efficient\\n                // WGMI\\n                revert(3, 3)\\n            }\\n\\n            // Extract out teh variables\\n            // We don\\u0027t have function signatures sweet saving EVEN MORE GAS\\n\\n            // bytes20\\n            let token := shr(96, calldataload(0x00))\\n            // bytes20\\n            let pair := shr(96, calldataload(0x14))\\n            // uint128\\n            let amountIn := shr(128, calldataload(0x28))\\n            // uint128\\n            let amountOut := shr(128, calldataload(0x38))\\n            // uint8\\n            let tokenOutNo := shr(248, calldataload(0x48))\\n\\n            // **** calls token.transfer(pair, amountIn) ****\\n\\n            // transfer function signature\\n            mstore(0x7c, ERC20_TRANSFER_ID)\\n            // destination\\n            mstore(0x80, pair)\\n            // amount\\n            mstore(0xa0, amountIn)\\n\\n            let s1 := call(sub(gas(), 5000), token, 0, 0x7c, 0x44, 0, 0)\\n            if iszero(s1) {\\n                // WGMI\\n                revert(3, 3)\\n            }\\n\\n            // ************\\n            /* \\n                calls pair.swap(\\n                    tokenOutNo == 0 ? amountOut : 0,\\n                    tokenOutNo == 1 ? amountOut : 0,\\n                    address(this),\\n                    new bytes(0)\\n                )\\n            */\\n\\n            // swap function signature\\n            mstore(0x7c, PAIR_SWAP_ID)\\n            // tokenOutNo == 0 ? ....\\n            switch tokenOutNo\\n            case 0 {\\n                mstore(0x80, amountOut)\\n                mstore(0xa0, 0)\\n            }\\n            case 1 {\\n                mstore(0x80, 0)\\n                mstore(0xa0, amountOut)\\n            }\\n            // address(this)\\n            mstore(0xc0, address())\\n            // empty bytes\\n            mstore(0xe0, 0x80)\\n\\n            let s2 := call(sub(gas(), 5000), pair, 0, 0x7c, 0xa4, 0, 0)\\n            if iszero(s2) {\\n                revert(3, 3)\\n            }\\n        }\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"},\"SafeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\nlibrary SafeTransfer {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(s, \\\"safeTransferFrom failed\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(s, \\\"safeTransfer failed\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\\n        );\\n        require(s, \\\"safeApprove failed\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool s, ) = to.call{value: value}(new bytes(0));\\n        require(s, \\\"safeTransferETH failed\\\");\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Sandwich", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d9046c5d48ac38926978fc6193ae481e39c19810", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34c1f31921b3adae8d8658e49b31bf8c51b90eb3b551218f17220a7a7668fa81"}