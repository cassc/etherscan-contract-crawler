{"SourceCode": "pragma solidity ^0.5.10;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n\r\n    /**\r\n     * @dev Reclaim all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function reclaimToken(IERC20 token) external onlyOwner {\r\n        address payable owner = address(uint160(owner()));\r\n\r\n        if (address(token) == address(0)) {\r\n            owner.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(owner, balance);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\ncontract AdminRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event AdminAdded(address indexed account);\r\n    event AdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _admins;\r\n\r\n    constructor () internal {\r\n        _addAdmin(msg.sender);\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isAdmin(address account) public view returns (bool) {\r\n        return _admins.has(account);\r\n    }\r\n\r\n    function addAdmin(address account) public onlyOwner {\r\n        _addAdmin(account);\r\n    }\r\n\r\n    function renounceAdmin() public {\r\n        _removeAdmin(msg.sender);\r\n    }\r\n\r\n    function removeAdmin(address account) public onlyOwner {\r\n        _removeAdmin(account);\r\n    }\r\n\r\n    function _addAdmin(address account) internal {\r\n        _admins.add(account);\r\n        emit AdminAdded(account);\r\n    }\r\n\r\n    function _removeAdmin(address account) internal {\r\n        _admins.remove(account);\r\n        emit AdminRemoved(account);\r\n    }\r\n}\r\n\r\n\r\n//TODO referral\r\ncontract SNKGame is AdminRole, CanReclaimToken {\r\n    using SafeMath for uint;\r\n\r\n    address payable public dividendManagerAddress;\r\n\r\n    struct Node {\r\n        mapping (bool => uint) children;\r\n        uint parent;\r\n        bool side;\r\n        uint height;\r\n        uint count;\r\n        uint dupes;\r\n    }\r\n\r\n    struct Game {\r\n        mapping(uint => Node) bets;\r\n        uint res;\r\n        uint resPos;\r\n        uint amount;\r\n\r\n        mapping(uint => address[]) users; //betValue => users\r\n        mapping(uint => mapping(address => uint)) betUsers; // betValue => user => userBetAmount\r\n        mapping(address => uint[]) userBets; //user => userBetValue\r\n        mapping(address => bool) executed; //user => prizeExecuted\r\n\r\n        uint winnersAmount;\r\n        uint prizePool;\r\n        //        uint winnersCount;\r\n        uint lastLeftPos;\r\n        uint lastRightPos;\r\n        uint lastLeftValue;\r\n        uint lastRightValue;\r\n        bool allDone;\r\n    }\r\n\r\n    mapping (uint => Game) public games;\r\n\r\n    uint public gameStep;\r\n    uint public closeBetsTime;\r\n    uint public gamesStart;\r\n    uint public betValue;\r\n\r\n\r\n\r\n    event NewBet(address indexed user, uint indexed game, uint bet, uint value);\r\n    event ResultSet(uint indexed game, uint res, uint lastLeftValue, uint lastRightValue, uint amount);\r\n    event PrizeTaken(address indexed user, uint game, uint amount);\r\n\r\n    constructor(address payable _dividendManagerAddress, uint _betValue) public {\r\n        require(_dividendManagerAddress != address(0));\r\n        dividendManagerAddress = _dividendManagerAddress;\r\n\r\n        gameStep = 10 minutes;\r\n        closeBetsTime = 3 minutes;\r\n        gamesStart = 1568332800; //Friday, 13 September 2019 \u0433., 0:00:00\r\n        betValue = _betValue;\r\n    }\r\n\r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    function makeBet(uint _game, uint _bet) public payable {\r\n        require(_bet > 0);\r\n        require(betValue == 0 ? msg.value > 0 : msg.value == betValue);\r\n        if (_game == 0) {\r\n            _game = getCurrentGameId();\r\n        }\r\n        require(now < getGameTime(_game) - closeBetsTime);\r\n\r\n        _makeBet(games[_game], _bet);\r\n\r\n        emit NewBet(msg.sender, _game, _bet, msg.value);\r\n    }\r\n\r\n    function setRes(uint _game, uint _res) onlyAdmin public {\r\n        insertResult(_game, _res);\r\n        setLastLeftRight(_game);\r\n        shiftLeftRight(_game);\r\n        setWinnersAmount(_game, 0, 0);\r\n    }\r\n\r\n    function insertResult(uint _game, uint _res) onlyAdmin public {\r\n        //require(getGameTime(_game) < now);\r\n        _insertResult(games[_game], _res);\r\n    }\r\n\r\n    function setLastLeftRight(uint _game) onlyAdmin public {\r\n        _setLastLeftRight(games[_game]);\r\n    }\r\n\r\n    function shiftLeftRight(uint _game) onlyAdmin public {\r\n        _shiftLeftRight(games[_game]);\r\n    }\r\n\r\n\r\n    function setWinnersAmount(uint _game, uint _start, uint _stop) onlyAdmin public {\r\n        _setWinnersAmount(games[_game], _start, _stop);\r\n        if (games[_game].allDone) {\r\n            emit ResultSet(_game, games[_game].res, games[_game].lastLeftValue, games[_game].lastRightValue, games[_game].amount);\r\n        }\r\n    }\r\n\r\n    function isPrizeTaken(uint _game, address _user) public view returns (bool){\r\n        return games[_game].executed[_user];\r\n    }\r\n    function isMyPrizeTaken(uint _game) public view returns (bool){\r\n        return isPrizeTaken(_game, msg.sender);\r\n    }\r\n\r\n\r\n    function checkPrize(uint _game, address _user) public view returns (uint) {\r\n        if (games[_game].executed[_user]) {\r\n            return 0;\r\n        }\r\n        return _getPrizeAmount(games[_game], _user);\r\n    }\r\n\r\n    function checkMyPrize(uint _game) public view returns (uint) {\r\n        return checkPrize(_game, msg.sender);\r\n    }\r\n\r\n    function getPrize(uint _game, address payable _user) public {\r\n        uint amount = _getPrize(games[_game], _user);\r\n        emit PrizeTaken(_user, _game, amount);\r\n    }\r\n\r\n    function getMyPrize(uint _game) public {\r\n        getPrize(_game, msg.sender);\r\n    }\r\n\r\n    function getGameTime(uint _id) public view returns (uint) {\r\n        return gamesStart + (gameStep * _id);\r\n    }\r\n\r\n    function setDividendManager(address payable _dividendManagerAddress) onlyOwner external  {\r\n        require(_dividendManagerAddress != address(0));\r\n        dividendManagerAddress = _dividendManagerAddress;\r\n    }\r\n    \r\n    function setBetValue(uint _betValue) onlyOwner external  {\r\n        betValue = _betValue;\r\n    }\r\n\r\n    function getCurrentGameId() public view returns (uint) {\r\n        return (now - gamesStart) / gameStep + 1;\r\n    }\r\n\r\n    function getNextGameId() external view returns (uint) {\r\n        return (now - gamesStart) / gameStep + 2;\r\n    }\r\n\r\n    function getUserBetValues(uint _game, address _user) public view returns (uint[] memory values) {\r\n        // values = new uint[](games[_game].userBets[msg.sender].length);\r\n        // for (uint i = 0; i < games[_game].userBets[msg.sender].length; i++) {\r\n        //     values[i] = games[_game].userBets[msg.sender][i];\r\n        // }\r\n        return games[_game].userBets[_user];\r\n    }\r\n    function getUserBetValues(uint _game) external view returns (uint[] memory values) {\r\n        return getUserBetValues(_game, msg.sender);\r\n    }\r\n\r\n    function getUserBetAmounts(uint _game, address _user) public view returns (uint[] memory amounts) {\r\n        amounts = new uint[](games[_game].userBets[_user].length);\r\n        for (uint i = 0; i < games[_game].userBets[_user].length; i++) {\r\n            amounts[i] = games[_game].betUsers[ games[_game].userBets[_user][i] ][_user];\r\n        }\r\n    }\r\n    function getUserBetAmounts(uint _game) external view returns (uint[] memory values) {\r\n        return getUserBetAmounts(_game, msg.sender);\r\n    }\r\n\r\n\r\n    //INTERNAL FUNCTIONS\r\n\r\n    function _makeBet(Game storage game, uint _bet) internal {\r\n        if (game.betUsers[_bet][msg.sender] == 0) {\r\n            _insert(game, _bet);\r\n            game.users[_bet].push(msg.sender);\r\n            game.userBets[msg.sender].push(_bet);\r\n        }\r\n\r\n        game.amount = game.amount.add(msg.value);\r\n        game.betUsers[_bet][msg.sender] = game.betUsers[_bet][msg.sender].add(msg.value);\r\n    }\r\n\r\n\r\n    function _insertResult(Game storage game, uint _res) internal {\r\n        _insert(game, _res);\r\n        game.res = _res;\r\n        game.resPos = _getPos(game, _res);\r\n    }\r\n\r\n\r\n    function _setLastLeftRight(Game storage game) internal returns (bool) {\r\n        require(game.res > 0);\r\n\r\n        //JackPot\r\n        if (game.bets[game.res].dupes > 0) {\r\n            game.lastLeftPos = game.resPos;\r\n            game.lastRightPos = game.resPos;\r\n            game.lastLeftValue = game.res;\r\n            game.lastRightValue = game.res;\r\n            return true;\r\n        }\r\n\r\n        uint lastPos = _count(game) - 1;\r\n\r\n        if (lastPos < 19) { //1 winner\r\n            //\u0435\u0441\u043b\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u0438\u043b\u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0442\u043e \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e\u0431\u0435\u0434\u0438\u0442\u0435\u043b\u044f \u0441\u043b\u0435\u0432\u0430 \u0438\u043b\u0438 \u0441\u043f\u0440\u0430\u0432\u0430\r\n            if (game.resPos == 0 || game.resPos == lastPos) {\r\n                game.lastLeftPos = game.resPos == 0 ? 1 : lastPos - 1;\r\n                game.lastRightPos = game.lastLeftPos;\r\n            } else {\r\n                uint leftBet =  _select_at(game, game.resPos - 1);\r\n                uint rightBet = _select_at(game, game.resPos + 1);\r\n                uint leftBetDif = game.res - leftBet;\r\n                uint rightBetDif = rightBet - game.res;\r\n\r\n                if (leftBetDif == rightBetDif) {\r\n                    game.lastLeftPos = game.resPos - 1;\r\n                    game.lastRightPos = game.resPos + 1;\r\n                }\r\n\r\n                if (leftBetDif > rightBetDif) {\r\n                    game.lastLeftPos = game.resPos + 1;\r\n                    game.lastRightPos = game.resPos + 1;\r\n                }\r\n\r\n                if (leftBetDif < rightBetDif) {\r\n                    //\u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u043e\u0432 \u0432 resPos \u043d\u0435\u0442, \u0442.\u043a. \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043b\u0438 \u0432\u044b\u0448\u0435 \u0432 \u0434\u0436\u0435\u043a\u043f\u043e\u0442\u0435\r\n                    game.lastLeftPos = game.resPos - 1;\r\n                    game.lastRightPos = game.resPos - 1;\r\n                }\r\n            }\r\n        } else {\r\n            uint winnersCount = lastPos.add(1).mul(10).div(100);\r\n            uint halfWinners = winnersCount.div(2);\r\n\r\n            if (game.resPos < halfWinners) {\r\n                game.lastLeftPos = 0;\r\n                game.lastRightPos = game.lastLeftPos + winnersCount;\r\n            } else {\r\n                if (game.resPos + halfWinners > lastPos) {\r\n                    game.lastRightPos = lastPos;\r\n                    game.lastLeftPos = lastPos - winnersCount;\r\n                } else {\r\n                    game.lastLeftPos = game.resPos - halfWinners;\r\n                    game.lastRightPos = game.lastLeftPos + winnersCount;\r\n                }\r\n            }\r\n        }\r\n\r\n        game.lastLeftValue = _select_at(game, game.lastLeftPos);\r\n        game.lastRightValue = _select_at(game, game.lastRightPos);\r\n\r\n\r\n        //\u043d\u0435 \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u044b \u0434\u043b\u044f left - dupes \u0434\u043b\u044f right + dupes, \u043d\u043e \u043e\u043d\u0438 \u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u044b \u043d\u0430\u043c\r\n        game.lastLeftPos = _getPos(game, game.lastLeftValue);\r\n        game.lastRightPos = _getPos(game, game.lastRightValue);// + games[_game].bets[games[_game].lastRightValue].dupes;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function _shiftRight(Game storage game, uint leftBetDif, uint rightBetDif, uint _val, uint lastPos) internal {\r\n        uint gleft = gasleft();\r\n        uint gasused = 0;\r\n        uint lastRightValue = game.lastRightValue;\r\n        uint lastRightPos = game.lastRightPos;\r\n        uint lastLeftValue = game.lastLeftValue;\r\n        uint lastLeftPos = game.lastLeftPos;\r\n        while (leftBetDif > rightBetDif) {\r\n\r\n            lastRightValue = _val;\r\n            lastRightPos = lastRightPos + 1 + game.bets[_val].dupes;\r\n\r\n            lastLeftValue = _select_at(game, lastLeftValue + 1);\r\n            lastLeftPos = _getPos(game, lastLeftValue);\r\n\r\n            if (lastRightPos == lastPos) break;\r\n            if (lastLeftPos >= game.resPos) break;\r\n\r\n            _val = _select_at(game, lastRightPos + 1);\r\n            leftBetDif = game.res - lastLeftValue;\r\n            rightBetDif = _val - game.res;\r\n\r\n            if (gasused == 0) {\r\n                gasused = gleft - gasleft() + 100000;\r\n            }\r\n            if (gasleft() < gasused) break;\r\n        }\r\n\r\n        game.lastRightValue = lastRightValue;\r\n        game.lastRightPos = lastRightPos;\r\n        game.lastLeftValue = lastLeftValue;\r\n        game.lastLeftPos = lastLeftPos;\r\n    }\r\n\r\n\r\n    function _shiftLeft(Game storage game, uint leftBetDif, uint rightBetDif, uint _val) internal {\r\n        uint gleft = gasleft();\r\n        uint gasused = 0;\r\n        uint lastRightValue = game.lastRightValue;\r\n        uint lastRightPos = game.lastRightPos;\r\n        uint lastLeftValue = game.lastLeftValue;\r\n        uint lastLeftPos = game.lastLeftPos;\r\n        while (rightBetDif > leftBetDif) {\r\n            lastLeftValue = _val;\r\n            lastLeftPos = lastLeftPos - game.bets[lastLeftValue].dupes - 1;\r\n\r\n            lastRightPos = lastRightPos - game.bets[lastRightValue].dupes - 1;\r\n            lastRightValue = _select_at(game, lastRightPos);\r\n\r\n            if (lastLeftPos - game.bets[lastLeftValue].dupes == 0) break;\r\n            if (lastRightPos <= game.resPos) break;\r\n\r\n            _val = _select_at(game, lastLeftPos - game.bets[lastLeftValue].dupes - 1);\r\n            leftBetDif = game.res - lastLeftValue;\r\n            rightBetDif = _val - game.res;\r\n\r\n            if (gasused == 0) {\r\n                gasused = gleft - gasleft() + 100000;\r\n            }\r\n            if (gasleft() < gasused) break;\r\n        }\r\n\r\n        game.lastRightValue = lastRightValue;\r\n        game.lastRightPos = lastRightPos;\r\n        game.lastLeftValue = lastLeftValue;\r\n        game.lastLeftPos = lastLeftPos;\r\n    }\r\n\r\n    function _shiftLeftRight(Game storage game) internal returns (bool) {\r\n        uint leftBetDif = game.res - game.lastLeftValue;\r\n        uint rightBetDif = game.lastRightValue - game.res;\r\n        if (rightBetDif == leftBetDif) return true;\r\n\r\n        uint _val;\r\n\r\n\r\n        if (leftBetDif > rightBetDif) {\r\n            uint lastPos = _count(game) - 1;\r\n            if (game.lastRightPos == lastPos) return true;\r\n            if (game.lastLeftPos >= game.resPos) return true;\r\n            // \u0432 lastRightPos \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0434\u0443\u0431\u043b\u044f \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u043e\u0441\u0442\u043e +1\r\n            _val = _select_at(game, game.lastRightPos + 1);\r\n            rightBetDif = _val - game.res;\r\n\r\n            _shiftRight(game, leftBetDif, rightBetDif, _val, lastPos);\r\n\r\n        } else {\r\n            if (game.lastLeftPos - game.bets[game.lastLeftValue].dupes == 0) return true;\r\n            if (game.lastRightPos <= game.resPos) return true;\r\n            //\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0434\u0443\u0431\u043b\u044f \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043c\u0438\u043d\u0443\u0441 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u044b\r\n            _val = _select_at(game, game.lastLeftPos - game.bets[game.lastLeftValue].dupes - 1);\r\n            leftBetDif = game.res - _val;\r\n\r\n            _shiftLeft(game, leftBetDif, rightBetDif, _val);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //\u043f\u0440\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0441\u0442\u0430\u0440\u0442 \u0438 \u0441\u0442\u043e\u043f \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u044b (\u0441\u0442\u0430\u0440\u0442 = \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430)\r\n    function _setWinnersAmount(Game storage game, uint _start, uint _stop) internal {\r\n        uint _bet;\r\n        uint _betAmount;\r\n        if (game.lastLeftPos == game.lastRightPos) {\r\n            _bet = _select_at(game, game.lastLeftPos);\r\n            game.winnersAmount = _getBetAmount(game, _bet);\r\n            game.allDone = true;\r\n        } else {\r\n            _start = _start > 0 ? _start : game.lastLeftPos;\r\n            _stop = _stop > 0 ? _stop : game.lastRightPos;\r\n            uint i = _start;\r\n            uint winnersAmount;\r\n            while(i <= _stop) {\r\n                if (i == game.resPos) {\r\n                    i++;\r\n                    continue;\r\n                }\r\n                _bet = _select_at(game, i);\r\n                _betAmount = _getBetAmount(game, _bet);\r\n                winnersAmount = winnersAmount.add(_betAmount);\r\n                //\u0432\u0435\u0440\u0438\u043c \u0447\u0442\u043e \u0441\u0442\u0430\u0440\u0442 == \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\r\n                if (i != _start && game.bets[_bet].dupes > 0) {\r\n                    i += game.bets[_bet].dupes;\r\n                }\r\n\r\n                if (i >= game.lastRightPos) game.allDone = true;\r\n                i++;\r\n            }\r\n            // \u044d\u0442\u043e \u0441\u0443\u043c\u043c\u0430 \u0441\u0442\u0430\u0432\u043e\u043a \u043f\u043e\u0431\u0435\u0434\u0438\u0442\u0435\u043b\u0435\u0439!\r\n            game.winnersAmount = winnersAmount;\r\n        }\r\n\r\n        if (game.allDone) {\r\n            uint profit = game.amount - game.winnersAmount;\r\n            if (profit > 0) {\r\n                uint ownerPercent = profit.div(10); //10% fee\r\n                game.prizePool = profit.sub(ownerPercent);\r\n                dividendManagerAddress.transfer(ownerPercent);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function _getBetAmount(Game storage game, uint _bet) internal view returns (uint amount) {\r\n        for (uint i = 0; i < game.users[_bet].length; i++) {\r\n            amount = amount.add(game.betUsers[_bet][game.users[_bet][i]]);\r\n        }\r\n    }\r\n\r\n    function _getPrize(Game storage game, address payable user) internal returns (uint amount) {\r\n        require(game.allDone);\r\n        require(!game.executed[user]);\r\n        game.executed[user] = true;\r\n        amount = _getPrizeAmount(game, user);\r\n\r\n        require(amount > 0);\r\n        user.transfer(amount);\r\n\r\n    }\r\n\r\n    function _getPrizeAmount(Game storage game, address user) internal view returns (uint amount){\r\n        amount = _getUserAmount(game, user);\r\n        if (amount > 0 && game.prizePool > 0) {\r\n            // \u0434\u043e\u043b\u044f \u0441\u0443\u043c\u043c\u044b \u0441\u0442\u0430\u0432\u043e\u043a \u0438\u0433\u0440\u043e\u043a\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0432\u043e\u0448\u043b\u0438 \u0432 \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u0431\u0435\u0434\u0438\u0432\u0448\u0438\u0445 \u043e\u0442 \u043e\u0431\u0449\u0435\u0439 \u0441\u0443\u043c\u043c\u044b \u0441\u0442\u0430\u0432\u043e\u043a \u043f\u043e\u0431\u0435\u0434\u0438\u0442\u0435\u043b\u0435\u0439\r\n            amount = amount.add(game.prizePool.mul(amount).div(game.winnersAmount));\r\n        }\r\n    }\r\n\r\n    function _getUserAmount(Game storage game, address user) internal view returns (uint amount){\r\n        amount = 0;\r\n        for (uint i = 0; i < game.userBets[user].length; i++) {\r\n            if (game.userBets[user][i] >= game.lastLeftValue &&\r\n                game.userBets[user][i] <= game.lastRightValue)\r\n            {\r\n                amount += game.betUsers[game.userBets[user][i]][user];\r\n            }\r\n        }\r\n    }\r\n\r\n    //AVL FUNCTIONS\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function getPos(uint _game, uint _value) public view returns (uint) {\r\n        return _getPos(games[_game], _value);\r\n    }\r\n\r\n    function select_at(uint _game, uint pos) public view returns (uint) {\r\n        return _select_at(games[_game], pos);\r\n    }\r\n\r\n    function count(uint _game) public view returns (uint) {\r\n        return _count(games[_game]);\r\n    }\r\n\r\n\r\n\r\n    //internal\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function _insert(Game storage game, uint _value) internal {\r\n        if (_value==0)\r\n            game.bets[_value].dupes++;\r\n        else{\r\n            insert_helper(game, 0, true, _value);\r\n        }\r\n    }\r\n\r\n    //\u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c \u0434\u0443\u043f\u0431\u043b\u0438\u043a\u0430\u0442\u044b, \u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u043f\u043e\u0441\u043b\u0434\u0435\u043d\u0435\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\r\n    function _getPos(Game storage game, uint _value) internal view returns (uint) {\r\n        uint c = _count(game);\r\n        if (c == 0) return 0; //err\r\n        if (game.bets[_value].count == 0) return 0; //err\r\n\r\n        uint _first = _select_at(game, 0);\r\n        uint _last = _select_at(game, c-1);\r\n\r\n        // Shortcut for the actual value\r\n        if (_value > _last || _value < _first) return 0; //err\r\n        if (_value == _first) return 0;\r\n        if (_value == _last) return c - 1;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = c-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            uint _val = _select_at(game, mid);\r\n            if (_val <= _value) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n\r\n    function _select_at(Game storage game, uint pos) internal view returns (uint value){\r\n        uint zeroes=game.bets[0].dupes;\r\n        // Node memory left_node;\r\n        uint left_count;\r\n        if (pos<zeroes) {\r\n            return 0;\r\n        }\r\n        uint pos_new=pos-zeroes;\r\n        uint cur=game.bets[0].children[true];\r\n        Node storage cur_node=game.bets[cur];\r\n        while(true){\r\n            uint left=cur_node.children[false];\r\n            uint cur_num=cur_node.dupes+1;\r\n            if (left!=0) {\r\n\r\n                left_count=game.bets[left].count;\r\n            }\r\n            else {\r\n                left_count=0;\r\n            }\r\n            if (pos_new<left_count) {\r\n                cur=left;\r\n                cur_node=game.bets[left];\r\n            }\r\n            else if (pos_new<left_count+cur_num){\r\n                return cur;\r\n            }\r\n            else {\r\n                cur=cur_node.children[true];\r\n                cur_node=game.bets[cur];\r\n                pos_new-=left_count+cur_num;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function _count(Game storage game) internal view returns (uint){\r\n        Node storage root=game.bets[0];\r\n        Node storage child=game.bets[root.children[true]];\r\n        return root.dupes+child.count;\r\n    }\r\n\r\n\r\n    function insert_helper(Game storage game, uint p_value, bool side, uint value) private {\r\n        Node storage root=game.bets[p_value];\r\n        uint c_value=root.children[side];\r\n        if (c_value==0){\r\n            root.children[side]=value;\r\n            Node storage child=game.bets[value];\r\n            child.parent=p_value;\r\n            child.side=side;\r\n            child.height=1;\r\n            child.count=1;\r\n            update_counts(game, value);\r\n            rebalance_insert(game, value);\r\n        }\r\n        else if (c_value==value){\r\n            game.bets[c_value].dupes++;\r\n            update_count(game, value);\r\n            update_counts(game, value);\r\n        }\r\n        else{\r\n            bool side_new=(value >= c_value);\r\n            insert_helper(game, c_value,side_new,value);\r\n        }\r\n    }\r\n\r\n\r\n    function update_count(Game storage game, uint value) private {\r\n        Node storage n=game.bets[value];\r\n        n.count=1+game.bets[n.children[false]].count+game.bets[n.children[true]].count+n.dupes;\r\n    }\r\n\r\n\r\n    function update_counts(Game storage game, uint value) private {\r\n        uint parent=game.bets[value].parent;\r\n        while (parent!=0) {\r\n            update_count(game, parent);\r\n            parent=game.bets[parent].parent;\r\n        }\r\n    }\r\n\r\n\r\n    function rebalance_insert(Game storage game, uint n_value) private {\r\n        update_height(game, n_value);\r\n        Node storage n=game.bets[n_value];\r\n        uint p_value=n.parent;\r\n        if (p_value!=0) {\r\n            int p_bf=balance_factor(game, p_value);\r\n            bool side=n.side;\r\n            int sign;\r\n            if (side)\r\n                sign=-1;\r\n            else\r\n                sign=1;\r\n            if (p_bf == sign*2) {\r\n                if (balance_factor(game, n_value) == (-1 * sign))\r\n                    rotate(game, n_value,side);\r\n                rotate(game, p_value,!side);\r\n            }\r\n            else if (p_bf != 0)\r\n                rebalance_insert(game, p_value);\r\n        }\r\n    }\r\n\r\n\r\n    function update_height(Game storage game, uint value) private {\r\n        Node storage n=game.bets[value];\r\n        uint height_left=game.bets[n.children[false]].height;\r\n        uint height_right=game.bets[n.children[true]].height;\r\n        if (height_left>height_right)\r\n            n.height=height_left+1;\r\n        else\r\n            n.height=height_right+1;\r\n    }\r\n\r\n\r\n    function balance_factor(Game storage game, uint value) private view returns (int bf) {\r\n        Node storage n=game.bets[value];\r\n        return int(game.bets[n.children[false]].height)-int(game.bets[n.children[true]].height);\r\n    }\r\n\r\n\r\n    function rotate(Game storage game, uint value,bool dir) private {\r\n        bool other_dir=!dir;\r\n        Node storage n=game.bets[value];\r\n        bool side=n.side;\r\n        uint parent=n.parent;\r\n        uint value_new=n.children[other_dir];\r\n        Node storage n_new=game.bets[value_new];\r\n        uint orphan=n_new.children[dir];\r\n        Node storage p=game.bets[parent];\r\n        Node storage o=game.bets[orphan];\r\n        p.children[side]=value_new;\r\n        n_new.side=side;\r\n        n_new.parent=parent;\r\n        n_new.children[dir]=value;\r\n        n.parent=value_new;\r\n        n.side=dir;\r\n        n.children[other_dir]=orphan;\r\n        o.parent=value;\r\n        o.side=other_dir;\r\n        update_height(game, value);\r\n        update_height(game, value_new);\r\n        update_count(game, value);\r\n        update_count(game, value_new);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dividendManagerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PrizeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastLeftValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRightValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ResultSet\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"checkMyPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeBetsTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendManagerAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resPos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnersAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastLeftPos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRightPos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastLeftValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRightValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allDone\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamesStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentGameId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGameTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"getMyPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextGameId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getPos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserBetAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"getUserBetAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"getUserBetValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserBetValues\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_res\",\"type\":\"uint256\"}],\"name\":\"insertResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"isMyPrizeTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isPrizeTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"makeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"select_at\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"setBetValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_dividendManagerAddress\",\"type\":\"address\"}],\"name\":\"setDividendManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"setLastLeftRight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_res\",\"type\":\"uint256\"}],\"name\":\"setRes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stop\",\"type\":\"uint256\"}],\"name\":\"setWinnersAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"shiftLeftRight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SNKGame", "CompilerVersion": "v0.5.12+commit.7709ece9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000351c25f77444890aa546281d4b9077d0099ae0ff000000000000000000000000000000000000000000000000002386f26fc10000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://61ed0d9d01233320fabbd0efe0cf8009bfab38d485d6148f33c25a12271ffc31"}