{"SourceCode": "pragma solidity 0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Migratable\r\n * @dev an interface for joyso to migrate to the new version\r\n */\r\ncontract Migratable {\r\n    function migrate(address user, uint256 amount, address tokenAddr) external payable returns (bool);\r\n}\r\n\r\n/**\r\n * @title JoysoDataDecoder\r\n * @author Will, Emn178\r\n * @notice decode the joyso compressed data\r\n */\r\ncontract JoysoDataDecoder {\r\n    function decodeOrderUserId(uint256 data) internal pure returns (uint256) {\r\n        return data & 0x00000000000000000000000000000000000000000000000000000000ffffffff;\r\n    }\r\n\r\n    function retrieveV(uint256 data) internal pure returns (uint256) {\r\n        // [24..24] v 0:27 1:28\r\n        return data & 0x000000000000000000000000f000000000000000000000000000000000000000 == 0 ? 27 : 28;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Joyso\r\n * @notice joyso main contract\r\n * @author Will, Emn178\r\n */\r\ncontract Joyso is Ownable, JoysoDataDecoder {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant USER_MASK = 0x00000000000000000000000000000000000000000000000000000000ffffffff;\r\n    uint256 private constant PAYMENT_METHOD_MASK = 0x00000000000000000000000f0000000000000000000000000000000000000000;\r\n    uint256 private constant WITHDRAW_TOKEN_MASK = 0x0000000000000000000000000000000000000000000000000000ffff00000000;\r\n    uint256 private constant V_MASK = 0x000000000000000000000000f000000000000000000000000000000000000000;\r\n    uint256 private constant TOKEN_SELL_MASK = 0x000000000000000000000000000000000000000000000000ffff000000000000;\r\n    uint256 private constant TOKEN_BUY_MASK = 0x0000000000000000000000000000000000000000000000000000ffff00000000;\r\n    uint256 private constant SIGN_MASK = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\r\n    uint256 private constant MATCH_SIGN_MASK = 0xfffffffffffffffffffffff00000000000000000000000000000000000000000;\r\n    uint256 private constant TOKEN_JOY_PRICE_MASK = 0x0000000000000000000000000fffffffffffffffffffffff0000000000000000;\r\n    uint256 private constant JOY_PRICE_MASK = 0x0000000000000000fffffff00000000000000000000000000000000000000000;\r\n    uint256 private constant IS_BUY_MASK = 0x00000000000000000000000f0000000000000000000000000000000000000000;\r\n    uint256 private constant TAKER_FEE_MASK = 0x00000000ffff0000000000000000000000000000000000000000000000000000;\r\n    uint256 private constant MAKER_FEE_MASK = 0x000000000000ffff000000000000000000000000000000000000000000000000;\r\n\r\n    uint256 private constant PAY_BY_TOKEN = 0x0000000000000000000000020000000000000000000000000000000000000000;\r\n    uint256 private constant PAY_BY_JOY = 0x0000000000000000000000010000000000000000000000000000000000000000;\r\n    uint256 private constant ORDER_ISBUY = 0x0000000000000000000000010000000000000000000000000000000000000000;\r\n\r\n    mapping (address => mapping (address => uint256)) private balances;\r\n    mapping (address => uint256) public userLock;\r\n    mapping (address => uint256) public userNonce;\r\n    mapping (bytes32 => uint256) public orderFills;\r\n    mapping (bytes32 => bool) public usedHash;\r\n    mapping (address => bool) public isAdmin;\r\n    mapping (uint256 => address) public tokenId2Address;\r\n    mapping (uint256 => address) public userId2Address;\r\n    mapping (address => uint256) public userAddress2Id;\r\n    mapping (address => uint256) public tokenAddress2Id;\r\n\r\n    address public joysoWallet;\r\n    address public joyToken;\r\n    uint256 public lockPeriod = 30 days;\r\n    uint256 public userCount;\r\n    bool public tradeEventEnabled = true;\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == owner || isAdmin[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    //events\r\n    event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n    event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n    event NewUser(address user, uint256 id);\r\n    event Lock(address user, uint256 timeLock);\r\n\r\n    // for debug\r\n    event TradeSuccess(address user, uint256 baseAmount, uint256 tokenAmount, bool isBuy, uint256 fee);\r\n\r\n    function Joyso(address _joysoWallet, address _joyToken) public {\r\n        joysoWallet = _joysoWallet;\r\n        addUser(_joysoWallet);\r\n        joyToken = _joyToken;\r\n        tokenAddress2Id[joyToken] = 1;\r\n        tokenAddress2Id[0] = 0; // ether address is Id 0\r\n        tokenId2Address[0] = 0;\r\n        tokenId2Address[1] = joyToken;\r\n    }\r\n\r\n    /**\r\n     * @notice deposit token into the contract\r\n     * @notice Be sure to Approve the contract to move your erc20 token\r\n     * @param token The address of deposited token\r\n     * @param amount The amount of token to deposit\r\n     */\r\n    function depositToken(address token, uint256 amount) external {\r\n        require(amount > 0);\r\n        require(tokenAddress2Id[token] != 0);\r\n        addUser(msg.sender);\r\n        require(ERC20(token).transferFrom(msg.sender, this, amount));\r\n        balances[token][msg.sender] = balances[token][msg.sender].add(amount);\r\n        Deposit(\r\n            token,\r\n            msg.sender,\r\n            amount,\r\n            balances[token][msg.sender]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice deposit Ether into the contract\r\n     */\r\n    function depositEther() external payable {\r\n        require(msg.value > 0);\r\n        addUser(msg.sender);\r\n        balances[0][msg.sender] = balances[0][msg.sender].add(msg.value);\r\n        Deposit(\r\n            0,\r\n            msg.sender,\r\n            msg.value,\r\n            balances[0][msg.sender]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw funds directly from contract\r\n     * @notice must claim by lockme first, after a period of time it would be valid\r\n     * @param token The address of withdrawed token, using address(0) to withdraw Ether\r\n     * @param amount The amount of token to withdraw\r\n     */\r\n    function withdraw(address token, uint256 amount) external {\r\n        require(amount > 0);\r\n        require(getTime() > userLock[msg.sender] && userLock[msg.sender] != 0);\r\n        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\r\n        if (token == 0) {\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(msg.sender, amount));\r\n        }\r\n        Withdraw(\r\n            token,\r\n            msg.sender,\r\n            amount,\r\n            balances[token][msg.sender]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This function is used to claim to withdraw the funds\r\n     * @notice The matching server will automaticlly remove all un-touched orders\r\n     * @notice After a period of time, the claimed user can withdraw funds directly from contract without admins involved.\r\n     */\r\n    function lockMe() external {\r\n        require(userAddress2Id[msg.sender] != 0);\r\n        userLock[msg.sender] = getTime() + lockPeriod;\r\n        Lock(msg.sender, userLock[msg.sender]);\r\n    }\r\n\r\n    /**\r\n     * @notice This function is used to revoke the claim of lockMe\r\n     */\r\n    function unlockMe() external {\r\n        require(userAddress2Id[msg.sender] != 0);\r\n        userLock[msg.sender] = 0;\r\n        Lock(msg.sender, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice set tradeEventEnabled, only owner\r\n     * @param enabled Set tradeEventEnabled if enabled\r\n     */\r\n    function setTradeEventEnabled(bool enabled) external onlyOwner {\r\n        tradeEventEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * @notice add/remove a address to admin list, only owner\r\n     * @param admin The address of the admin\r\n     * @param isAdd Set the address's status in admin list\r\n     */\r\n    function addToAdmin(address admin, bool isAdd) external onlyOwner {\r\n        isAdmin[admin] = isAdd;\r\n    }\r\n\r\n    /**\r\n     * @notice collect the fee to owner's address, only owner\r\n     */\r\n    function collectFee(address token) external onlyOwner {\r\n        uint256 amount = balances[token][joysoWallet];\r\n        require(amount > 0);\r\n        balances[token][joysoWallet] = 0;\r\n        if (token == 0) {\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(msg.sender, amount));\r\n        }\r\n        Withdraw(\r\n            token,\r\n            joysoWallet,\r\n            amount,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice change lock period, only owner\r\n     * @dev can change from 1 days to 30 days, initial is 30 days\r\n     */\r\n    function changeLockPeriod(uint256 periodInDays) external onlyOwner {\r\n        require(periodInDays <= 30 && periodInDays >= 1);\r\n        lockPeriod = periodInDays * 1 days;\r\n    }\r\n\r\n    /**\r\n     * @notice add a new token into the token list, only admins\r\n     * @dev index 0 & 1 are saved for Ether and JOY\r\n     * @dev both index & token can not be redundant, and no removed mathod\r\n     * @param tokenAddress token's address\r\n     * @param index chosen index of the token\r\n     */\r\n    function registerToken(address tokenAddress, uint256 index) external onlyAdmin {\r\n        require(index > 1);\r\n        require(tokenAddress2Id[tokenAddress] == 0);\r\n        require(tokenId2Address[index] == 0);\r\n        tokenAddress2Id[tokenAddress] = index;\r\n        tokenId2Address[index] = tokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw with admins involved, only admin\r\n     * @param inputs array of inputs, must have 5 elements\r\n     * @dev inputs encoding please reference github wiki\r\n     */\r\n    function withdrawByAdmin_Unau(uint256[] inputs) external onlyAdmin {\r\n        uint256 amount = inputs[0];\r\n        uint256 gasFee = inputs[1];\r\n        uint256 data = inputs[2];\r\n        uint256 paymentMethod = data & PAYMENT_METHOD_MASK;\r\n        address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];\r\n        address user = userId2Address[data & USER_MASK];\r\n        bytes32 hash = keccak256(\r\n            this,\r\n            amount,\r\n            gasFee,\r\n            data & SIGN_MASK | uint256(token)\r\n        );\r\n        require(!usedHash[hash]);\r\n        require(\r\n            verify(\r\n                hash,\r\n                user,\r\n                uint8(data & V_MASK == 0 ? 27 : 28),\r\n                bytes32(inputs[3]),\r\n                bytes32(inputs[4])\r\n            )\r\n        );\r\n\r\n        address gasToken = 0;\r\n        if (paymentMethod == PAY_BY_JOY) { // pay fee by JOY\r\n            gasToken = joyToken;\r\n        } else if (paymentMethod == PAY_BY_TOKEN) { // pay fee by tx token\r\n            gasToken = token;\r\n        }\r\n\r\n        if (gasToken == token) { // pay by ether or token\r\n            balances[token][user] = balances[token][user].sub(amount.add(gasFee));\r\n        } else {\r\n            balances[token][user] = balances[token][user].sub(amount);\r\n            balances[gasToken][user] = balances[gasToken][user].sub(gasFee);\r\n        }\r\n        balances[gasToken][joysoWallet] = balances[gasToken][joysoWallet].add(gasFee);\r\n\r\n        usedHash[hash] = true;\r\n\r\n        if (token == 0) {\r\n            user.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(user, amount));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice match orders with admins involved, only admin\r\n     * @param inputs Array of input orders, each order have 6 elements. Inputs must conatin at least 2 orders.\r\n     * @dev inputs encoding please reference github wiki\r\n     */\r\n    function matchByAdmin_TwH36(uint256[] inputs) external onlyAdmin {\r\n        uint256 data = inputs[3];\r\n        address user = userId2Address[data & USER_MASK];\r\n        // check taker order nonce\r\n        require(data >> 224 > userNonce[user]);\r\n        address token;\r\n        bool isBuy;\r\n        (token, isBuy) = decodeOrderTokenAndIsBuy(data);\r\n        bytes32 orderHash = keccak256(\r\n            this,\r\n            inputs[0],\r\n            inputs[1],\r\n            inputs[2],\r\n            data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token)\r\n        );\r\n        require(\r\n            verify(\r\n                orderHash,\r\n                user,\r\n                uint8(data & V_MASK == 0 ? 27 : 28),\r\n                bytes32(inputs[4]),\r\n                bytes32(inputs[5])\r\n            )\r\n        );\r\n\r\n        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0]; // taker order token execute\r\n        tokenExecute = tokenExecute.sub(orderFills[orderHash]);\r\n        require(tokenExecute != 0); // the taker order should remain something to trade\r\n        uint256 etherExecute = 0;  // taker order ether execute\r\n\r\n        isBuy = !isBuy;\r\n        for (uint256 i = 6; i < inputs.length; i += 6) {\r\n            //check price, maker price should lower than taker price\r\n            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));\r\n\r\n            data = inputs[i + 3];\r\n            user = userId2Address[data & USER_MASK];\r\n            // check maker order nonce\r\n            require(data >> 224 > userNonce[user]);\r\n            bytes32 makerOrderHash = keccak256(\r\n                this,\r\n                inputs[i],\r\n                inputs[i + 1],\r\n                inputs[i + 2],\r\n                data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token)\r\n            );\r\n            require(\r\n                verify(\r\n                    makerOrderHash,\r\n                    user,\r\n                    uint8(data & V_MASK == 0 ? 27 : 28),\r\n                    bytes32(inputs[i + 4]),\r\n                    bytes32(inputs[i + 5])\r\n                )\r\n            );\r\n            (tokenExecute, etherExecute) = internalTrade(\r\n                inputs[i],\r\n                inputs[i + 1],\r\n                inputs[i + 2],\r\n                data,\r\n                tokenExecute,\r\n                etherExecute,\r\n                isBuy,\r\n                token,\r\n                0,\r\n                makerOrderHash\r\n            );\r\n        }\r\n\r\n        isBuy = !isBuy;\r\n        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);\r\n        tokenExecute = tokenExecute.sub(orderFills[orderHash]);\r\n        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);\r\n    }\r\n\r\n    /**\r\n     * @notice match token orders with admins involved, only admin\r\n     * @param inputs Array of input orders, each order have 6 elements. Inputs must conatin at least 2 orders.\r\n     * @dev inputs encoding please reference github wiki\r\n     */\r\n    function matchTokenOrderByAdmin_k44j(uint256[] inputs) external onlyAdmin {\r\n        address user = userId2Address[decodeOrderUserId(inputs[3])];\r\n        // check taker order nonce\r\n        require(inputs[3] >> 224 > userNonce[user]);\r\n        address token;\r\n        address base;\r\n        bool isBuy;\r\n        (token, base, isBuy) = decodeTokenOrderTokenAndIsBuy(inputs[3]);\r\n        bytes32 orderHash = getTokenOrderDataHash(inputs, 0, inputs[3], token, base);\r\n        require(\r\n            verify(\r\n                orderHash,\r\n                user,\r\n                uint8(retrieveV(inputs[3])),\r\n                bytes32(inputs[4]),\r\n                bytes32(inputs[5])\r\n            )\r\n        );\r\n        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0]; // taker order token execute\r\n        tokenExecute = tokenExecute.sub(orderFills[orderHash]);\r\n        require(tokenExecute != 0); // the taker order should remain something to trade\r\n        uint256 baseExecute = 0;  // taker order ether execute\r\n\r\n        isBuy = !isBuy;\r\n        for (uint256 i = 6; i < inputs.length; i += 6) {\r\n            //check price, taker price should better than maker price\r\n            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));\r\n\r\n            user = userId2Address[decodeOrderUserId(inputs[i + 3])];\r\n            // check maker order nonce\r\n            require(inputs[i + 3] >> 224 > userNonce[user]);\r\n            bytes32 makerOrderHash = getTokenOrderDataHash(inputs, i, inputs[i + 3], token, base);\r\n            require(\r\n                verify(\r\n                    makerOrderHash,\r\n                    user,\r\n                    uint8(retrieveV(inputs[i + 3])),\r\n                    bytes32(inputs[i + 4]),\r\n                    bytes32(inputs[i + 5])\r\n                )\r\n            );\r\n            (tokenExecute, baseExecute) = internalTrade(\r\n                inputs[i],\r\n                inputs[i + 1],\r\n                inputs[i + 2],\r\n                inputs[i + 3],\r\n                tokenExecute,\r\n                baseExecute,\r\n                isBuy,\r\n                token,\r\n                base,\r\n                makerOrderHash\r\n            );\r\n        }\r\n\r\n        isBuy = !isBuy;\r\n        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);\r\n        tokenExecute = tokenExecute.sub(orderFills[orderHash]);\r\n        processTakerOrder(inputs[2], inputs[3], tokenExecute, baseExecute, isBuy, token, base, orderHash);\r\n    }\r\n\r\n    /**\r\n     * @notice update user on-chain nonce with admins involved, only admin\r\n     * @param inputs Array of input data, must have 4 elements.\r\n     * @dev inputs encoding please reference github wiki\r\n     */\r\n    function cancelByAdmin(uint256[] inputs) external onlyAdmin {\r\n        uint256 data = inputs[1];\r\n        uint256 nonce = data >> 224;\r\n        address user = userId2Address[data & USER_MASK];\r\n        require(nonce > userNonce[user]);\r\n        uint256 gasFee = inputs[0];\r\n        require(\r\n            verify(\r\n                keccak256(this, gasFee, data & SIGN_MASK),\r\n                user,\r\n                uint8(retrieveV(data)),\r\n                bytes32(inputs[2]),\r\n                bytes32(inputs[3])\r\n            )\r\n        );\r\n\r\n        // update balance\r\n        address gasToken = 0;\r\n        if (data & PAYMENT_METHOD_MASK == PAY_BY_JOY) {\r\n            gasToken = joyToken;\r\n        }\r\n        require(balances[gasToken][user] >= gasFee);\r\n        balances[gasToken][user] = balances[gasToken][user].sub(gasFee);\r\n        balances[gasToken][joysoWallet] = balances[gasToken][joysoWallet].add(gasFee);\r\n\r\n        // update user nonce\r\n        userNonce[user] = nonce;\r\n    }\r\n\r\n    /**\r\n     * @notice batch send the current balance to the new version contract\r\n     * @param inputs Array of input data\r\n     * @dev inputs encoding please reference github wiki\r\n     */\r\n    function migrateByAdmin_DQV(uint256[] inputs) external onlyAdmin {\r\n        uint256 data = inputs[2];\r\n        address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];\r\n        address newContract = address(inputs[0]);\r\n        for (uint256 i = 1; i < inputs.length; i += 4) {\r\n            uint256 gasFee = inputs[i];\r\n            data = inputs[i + 1];\r\n            address user = userId2Address[data & USER_MASK];\r\n            bytes32 hash = keccak256(\r\n                this,\r\n                gasFee,\r\n                data & SIGN_MASK | uint256(token),\r\n                newContract\r\n            );\r\n            require(\r\n                verify(\r\n                    hash,\r\n                    user,\r\n                    uint8(data & V_MASK == 0 ? 27 : 28),\r\n                    bytes32(inputs[i + 2]),\r\n                    bytes32(inputs[i + 3])\r\n                )\r\n            );\r\n            if (gasFee > 0) {\r\n                uint256 paymentMethod = data & PAYMENT_METHOD_MASK;\r\n                if (paymentMethod == PAY_BY_JOY) {\r\n                    balances[joyToken][user] = balances[joyToken][user].sub(gasFee);\r\n                    balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);\r\n                } else if (paymentMethod == PAY_BY_TOKEN) {\r\n                    balances[token][user] = balances[token][user].sub(gasFee);\r\n                    balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);\r\n                } else {\r\n                    balances[0][user] = balances[0][user].sub(gasFee);\r\n                    balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);\r\n                }\r\n            }\r\n            uint256 amount = balances[token][user];\r\n            balances[token][user] = 0;\r\n            if (token == 0) {\r\n                Migratable(newContract).migrate.value(amount)(user, amount, token);\r\n            } else {\r\n                ERC20(token).approve(newContract, amount);\r\n                Migratable(newContract).migrate(user, amount, token);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice transfer token from admin to users\r\n     * @param token address of token\r\n     * @param account receiver's address\r\n     * @param amount amount to transfer\r\n     */\r\n    function transferForAdmin(address token, address account, uint256 amount) onlyAdmin external {\r\n        require(tokenAddress2Id[token] != 0);\r\n        require(userAddress2Id[msg.sender] != 0);\r\n        addUser(account);\r\n        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\r\n        balances[token][account] = balances[token][account].add(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice get balance information\r\n     * @param token address of token\r\n     * @param account address of user\r\n     */\r\n    function getBalance(address token, address account) external view returns (uint256) {\r\n        return balances[token][account];\r\n    }\r\n\r\n    /**\r\n     * @dev get tokenId and check the order is a buy order or not, internal\r\n     *      tokenId take 4 bytes\r\n     *      isBuy is true means this order is buying token\r\n     */\r\n    function decodeOrderTokenAndIsBuy(uint256 data) internal view returns (address token, bool isBuy) {\r\n        uint256 tokenId = (data & TOKEN_SELL_MASK) >> 48;\r\n        if (tokenId == 0) {\r\n            token = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32];\r\n            isBuy = true;\r\n        } else {\r\n            token = tokenId2Address[tokenId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev decode token oreder data, internal\r\n     */\r\n    function decodeTokenOrderTokenAndIsBuy(uint256 data) internal view returns (address token, address base, bool isBuy) {\r\n        isBuy = data & IS_BUY_MASK == ORDER_ISBUY;\r\n        if (isBuy) {\r\n            token = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32];\r\n            base = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48];\r\n        } else {\r\n            token = tokenId2Address[(data & TOKEN_SELL_MASK) >> 48];\r\n            base = tokenId2Address[(data & TOKEN_BUY_MASK) >> 32];\r\n        }\r\n    }\r\n\r\n    function getTime() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * @dev get token order's hash for user to sign, internal\r\n     * @param inputs forword tokenOrderMatch's input to this function\r\n     * @param offset offset of the order in inputs\r\n     */\r\n    function getTokenOrderDataHash(uint256[] inputs, uint256 offset, uint256 data, address token, address base) internal view returns (bytes32) {\r\n        return keccak256(\r\n            this,\r\n            inputs[offset],\r\n            inputs[offset + 1],\r\n            inputs[offset + 2],\r\n            data & SIGN_MASK | uint256(token),\r\n            base,\r\n            (data & TOKEN_JOY_PRICE_MASK) >> 64\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev check if the provided signature is valid, internal\r\n     * @param hash signed information\r\n     * @param sender signer address\r\n     * @param v sig_v\r\n     * @param r sig_r\r\n     * @param s sig_s\r\n     */\r\n    function verify(bytes32 hash, address sender, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {\r\n        return ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == sender;\r\n    }\r\n\r\n    /**\r\n     * @dev give a new user an id, intrnal\r\n     */\r\n    function addUser(address _address) internal {\r\n        if (userAddress2Id[_address] != 0) {\r\n            return;\r\n        }\r\n        userCount += 1;\r\n        userAddress2Id[_address] = userCount;\r\n        userId2Address[userCount] = _address;\r\n        NewUser(_address, userCount);\r\n    }\r\n\r\n    function processTakerOrder(\r\n        uint256 gasFee,\r\n        uint256 data,\r\n        uint256 tokenExecute,\r\n        uint256 baseExecute,\r\n        bool isBuy,\r\n        address token,\r\n        address base,\r\n        bytes32 orderHash\r\n    )\r\n        internal\r\n    {\r\n        uint256 fee = calculateFee(gasFee, data, baseExecute, orderHash, true, base == 0);\r\n        updateUserBalance(data, isBuy, baseExecute, tokenExecute, fee, token, base);\r\n        orderFills[orderHash] = orderFills[orderHash].add(tokenExecute);\r\n        if (tradeEventEnabled) {\r\n            TradeSuccess(userId2Address[data & USER_MASK], baseExecute, tokenExecute, isBuy, fee);\r\n        }\r\n    }\r\n\r\n    function internalTrade(\r\n        uint256 amountSell,\r\n        uint256 amountBuy,\r\n        uint256 gasFee,\r\n        uint256 data,\r\n        uint256 _remainingToken,\r\n        uint256 _baseExecute,\r\n        bool isBuy,\r\n        address token,\r\n        address base,\r\n        bytes32 orderHash\r\n    )\r\n        internal returns (uint256 remainingToken, uint256 baseExecute)\r\n    {\r\n        uint256 tokenGet = calculateTokenGet(amountSell, amountBuy, _remainingToken, isBuy, orderHash);\r\n        uint256 baseGet = calculateBaseGet(amountSell, amountBuy, isBuy, tokenGet);\r\n        uint256 fee = calculateFee(gasFee, data, baseGet, orderHash, false, base == 0);\r\n        updateUserBalance(data, isBuy, baseGet, tokenGet, fee, token, base);\r\n        orderFills[orderHash] = orderFills[orderHash].add(tokenGet);\r\n        remainingToken = _remainingToken.sub(tokenGet);\r\n        baseExecute = _baseExecute.add(baseGet);\r\n        if (tradeEventEnabled) {\r\n            TradeSuccess(\r\n                userId2Address[data & USER_MASK],\r\n                baseGet,\r\n                tokenGet,\r\n                isBuy,\r\n                fee\r\n            );\r\n        }\r\n    }\r\n\r\n    function updateUserBalance(\r\n        uint256 data,\r\n        bool isBuy,\r\n        uint256 baseGet,\r\n        uint256 tokenGet,\r\n        uint256 fee,\r\n        address token,\r\n        address base\r\n    )\r\n        internal\r\n    {\r\n        address user = userId2Address[data & USER_MASK];\r\n        uint256 baseFee = fee;\r\n        uint256 joyFee = 0;\r\n        if ((base == 0 ? (data & JOY_PRICE_MASK) >> 164 : (data & TOKEN_JOY_PRICE_MASK) >> 64) != 0) {\r\n            joyFee = fee;\r\n            baseFee = 0;\r\n        }\r\n\r\n        if (isBuy) { // buy token, sell ether\r\n            balances[base][user] = balances[base][user].sub(baseGet).sub(baseFee);\r\n            balances[token][user] = balances[token][user].add(tokenGet);\r\n        } else {\r\n            balances[base][user] = balances[base][user].add(baseGet).sub(baseFee);\r\n            balances[token][user] = balances[token][user].sub(tokenGet);\r\n        }\r\n\r\n        if (joyFee != 0) {\r\n            balances[joyToken][user] = balances[joyToken][user].sub(joyFee);\r\n            balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(joyFee);\r\n        } else {\r\n            balances[base][joysoWallet] = balances[base][joysoWallet].add(baseFee);\r\n        }\r\n    }\r\n\r\n    function calculateFee(\r\n        uint256 gasFee,\r\n        uint256 data,\r\n        uint256 baseGet,\r\n        bytes32 orderHash,\r\n        bool isTaker,\r\n        bool isEthOrder\r\n    )\r\n        internal view returns (uint256)\r\n    {\r\n        uint256 fee = orderFills[orderHash] == 0 ? gasFee : 0;\r\n        uint256 txFee = baseGet.mul(isTaker ? (data & TAKER_FEE_MASK) >> 208 : (data & MAKER_FEE_MASK) >> 192) / 10000;\r\n        uint256 joyPrice = isEthOrder ? (data & JOY_PRICE_MASK) >> 164 : (data & TOKEN_JOY_PRICE_MASK) >> 64;\r\n        if (joyPrice != 0) {\r\n            txFee = isEthOrder ? txFee / (10 ** 5) / joyPrice : txFee * (10 ** 12) / joyPrice;\r\n        }\r\n        return fee.add(txFee);\r\n    }\r\n\r\n    function calculateBaseGet(\r\n        uint256 amountSell,\r\n        uint256 amountBuy,\r\n        bool isBuy,\r\n        uint256 tokenGet\r\n    )\r\n        internal pure returns (uint256)\r\n    {\r\n        return isBuy ? tokenGet.mul(amountSell) / amountBuy : tokenGet.mul(amountBuy) / amountSell;\r\n    }\r\n\r\n    function calculateTokenGet(\r\n        uint256 amountSell,\r\n        uint256 amountBuy,\r\n        uint256 remainingToken,\r\n        bool isBuy,\r\n        bytes32 orderHash\r\n    )\r\n        internal view returns (uint256)\r\n    {\r\n        uint256 makerRemainingToken = isBuy ? amountBuy : amountSell;\r\n        makerRemainingToken = makerRemainingToken.sub(orderFills[orderHash]);\r\n        require(makerRemainingToken > 0); // the maker order should remain something to trade\r\n        return makerRemainingToken >= remainingToken ? remainingToken : makerRemainingToken;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"matchTokenOrderByAdmin_k44j\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"matchByAdmin_TwH36\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"withdrawByAdmin_Unau\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"migrateByAdmin_DQV\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"registerToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferForAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"addToAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joysoWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockMe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userId2Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTradeEventEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"periodInDays\",\"type\":\"uint256\"}],\"name\":\"changeLockPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAddress2Id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeEventEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"cancelByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockMe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenId2Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAddress2Id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_joysoWallet\",\"type\":\"address\"},{\"name\":\"_joyToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeLock\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TradeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "Joyso", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003a6386e7701bf9c0d5b983d5e0bcec78331749d9000000000000000000000000dde12a12a6f67156e0da672be05c374e1b0a3e57", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f67563a032c9aaab5411af776dbcc7191cdc32a8b278f4bc888d81efca9b7e54"}