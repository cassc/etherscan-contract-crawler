{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v2-migration/V2ToV3Rollover.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./V2ToV3RolloverBase.sol\\\";\\n\\nimport \\\"../interfaces/IMigration.sol\\\";\\n\\nimport \\\"../libraries/FeeLookups.sol\\\";\\n\\nimport {\\n    R_UnknownCaller,\\n    R_UnknownBorrower,\\n    R_InsufficientFunds,\\n    R_InsufficientAllowance,\\n    R_Paused,\\n    R_ZeroAddress\\n} from \\\"../errors/RolloverErrors.sol\\\";\\n\\n/**\\n * @title V2ToV3Rollover\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * This contract is used to rollover a loan from the legacy V2 lending protocol to the new\\n * V3 lending protocol. The rollover mechanism takes out a flash loan for the principal +\\n * interest of the old loan from Balancer pool, repays the V2 loan, and starts a new loan on V3.\\n * This migration contract can only used with specific loan terms signed by a lender not from a\\n * collection wide offer. To perform a rollover with items, use V2ToV3RolloverWithItems contract.\\n *\\n * It is required that the V2 protocol has zero fees enabled. This contract only works with\\n * ERC721 collateral.\\n */\\ncontract V2ToV3Rollover is IMigration, V2ToV3RolloverBase, FeeLookups {\\n    using SafeERC20 for IERC20;\\n\\n    constructor(IVault _vault, OperationContracts memory _opContracts) V2ToV3RolloverBase(_vault, _opContracts) {}\\n\\n    /**\\n     * @notice Rollover a loan from V2 to V3. Validates new loan terms against the old terms.\\n     *         Takes out Flash Loan for principal + interest, repays old loan, and starts new\\n     *         loan on V3.\\n     *\\n     * @param loanId                 The ID of the loan to be rolled over.\\n     * @param newLoanTerms           The terms of the new loan.\\n     * @param lender                 The address of the lender.\\n     * @param nonce                  The nonce of the new loan.\\n     * @param v                      The v value of signature for new loan.\\n     * @param r                      The r value of signature for new loan.\\n     * @param s                      The s value of signature for new loan.\\n     */\\n    function migrateLoan(\\n        uint256 loanId,\\n        LoanLibrary.LoanTerms calldata newLoanTerms,\\n        address lender,\\n        uint160 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override whenBorrowerReset {\\n        if (paused) revert R_Paused();\\n\\n        LoanLibraryV2.LoanTerms memory loanTerms = loanCoreV2.getLoan(loanId).terms;\\n\\n        (address _borrower) = _validateRollover(\\n            loanTerms,\\n            newLoanTerms,\\n            loanId // same as borrowerNoteId\\n        );\\n\\n        // cache borrower address for flash loan callback\\n        borrower = _borrower;\\n\\n        IERC20[] memory assets = new IERC20[](1);\\n        assets[0] = IERC20(loanTerms.payableCurrency);\\n\\n        uint256[] memory amounts = new uint256[](1);\\n        amounts[0] = repaymentControllerV2.getFullInterestAmount(loanTerms.principal, loanTerms.interestRate);\\n\\n        bytes memory params = abi.encode(\\n            OperationData(\\n                {\\n                    loanId: loanId,\\n                    borrower: _borrower,\\n                    newLoanTerms: newLoanTerms,\\n                    lender: lender,\\n                    nonce: nonce,\\n                    v: v,\\n                    r: r,\\n                    s: s\\n                }\\n            )\\n        );\\n\\n        // Flash loan based on principal + interest\\n        VAULT.flashLoan(this, assets, amounts, params);\\n    }\\n\\n    /**\\n     * @notice Callback function for flash loan.\\n     *\\n     * @dev The caller of this function must be the lending pool.\\n     *\\n     * @param assets                 The ERC20 address that was borrowed in Flash Loan.\\n     * @param amounts                The amount that was borrowed in Flash Loan.\\n     * @param feeAmounts             The fees that are due to the lending pool.\\n     * @param params                 The data to be executed after receiving Flash Loan.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata feeAmounts,\\n        bytes calldata params\\n    ) external nonReentrant {\\n        if (msg.sender != address(VAULT)) revert R_UnknownCaller(msg.sender, address(VAULT));\\n\\n        OperationData memory opData = abi.decode(params, (OperationData));\\n\\n        // verify this contract started the flash loan\\n        if (opData.borrower != borrower) revert R_UnknownBorrower(opData.borrower, borrower);\\n        // borrower must be set\\n        if (borrower == address(0)) revert R_ZeroAddress(\\\"borrower\\\");\\n\\n        _executeOperation(assets, amounts, feeAmounts, opData);\\n    }\\n\\n    /**\\n     * @notice Executes repayment of old loan and initialization of new loan. Any funds\\n     *         that are not covered by closing out the old loan must be covered by the borrower.\\n     *\\n     * @param assets                 The ERC20 that was borrowed in Flash Loan.\\n     * @param amounts                The amount that was borrowed in Flash Loan.\\n     * @param premiums               The fees that are due back to the lending pool.\\n     * @param opData                 The data to be executed after receiving Flash Loan.\\n     */\\n    function _executeOperation(\\n        IERC20[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] memory premiums,\\n        OperationData memory opData\\n    ) internal {\\n        // Get loan details\\n        LoanLibraryV2.LoanData memory loanData = loanCoreV2.getLoan(opData.loanId);\\n\\n        // Do accounting to figure out amount each party needs to receive\\n        (uint256 flashAmountDue, uint256 needFromBorrower, uint256 leftoverPrincipal) = _ensureFunds(\\n            amounts[0], // principal + interest\\n            premiums[0], // flash loan fee\\n            uint256(feeControllerV3.getLendingFee(FL_01)), // borrower origination fee\\n            opData.newLoanTerms.principal // new loan terms principal\\n        );\\n\\n        IERC20 asset = assets[0];\\n\\n        if (needFromBorrower > 0) {\\n            if (asset.balanceOf(opData.borrower) < needFromBorrower) {\\n                revert R_InsufficientFunds(opData.borrower, needFromBorrower, asset.balanceOf(opData.borrower));\\n            }\\n            if (asset.allowance(opData.borrower, address(this)) < needFromBorrower) {\\n                revert R_InsufficientAllowance(\\n                    opData.borrower,\\n                    needFromBorrower,\\n                    asset.allowance(opData.borrower, address(this))\\n                );\\n            }\\n        }\\n\\n        _repayLoan(loanData, opData.loanId, opData.borrower);\\n\\n        {\\n            uint256 newLoanId = _initializeNewLoan(\\n                opData.borrower,\\n                opData.lender,\\n                opData\\n            );\\n\\n            emit V2V3Rollover(\\n                opData.lender,\\n                opData.borrower,\\n                loanData.terms.collateralId,\\n                newLoanId\\n            );\\n        }\\n\\n        if (leftoverPrincipal > 0) {\\n            asset.safeTransfer(opData.borrower, leftoverPrincipal);\\n        } else if (needFromBorrower > 0) {\\n            asset.safeTransferFrom(opData.borrower, address(this), needFromBorrower);\\n        }\\n\\n        // Make flash loan repayment\\n        // Balancer requires a transfer back the vault\\n        asset.safeTransfer(address(VAULT), flashAmountDue);\\n    }\\n\\n    /**\\n     * @notice Helper function to initialize the new loan. Approves the V3 Loan Core contract\\n     *         to take the collateral, then starts the new loan. Once the new loan is started,\\n     *         the borrowerNote is sent to the borrower.\\n     *\\n     * @param opDataBorrower           The address of the borrower from the opData.\\n     * @param lender                   The address of the new lender.\\n     * @param opData                   The data used to initiate new V3 loan.\\n     *\\n     * @return newLoanId               V3 loanId for the new loan that is started.\\n     */\\n    function _initializeNewLoan(\\n        address opDataBorrower,\\n        address lender,\\n        OperationData memory opData\\n    ) internal returns (uint256) {\\n        uint256 collateralId = opData.newLoanTerms.collateralId;\\n\\n        // approve targetLoanCore to take collateral\\n        IERC721(opData.newLoanTerms.collateralAddress).approve(address(loanCoreV3), collateralId);\\n\\n        // start new loan\\n        // stand in for borrower to meet OriginationController's requirements\\n        uint256 newLoanId = originationControllerV3.initializeLoan(\\n            opData.newLoanTerms,\\n            address(this),\\n            lender,\\n            IOriginationController.Signature({\\n                v: opData.v,\\n                r: opData.r,\\n                s: opData.s,\\n                extraData: \\\"0x\\\"\\n            }),\\n            opData.nonce\\n        );\\n\\n        // send the V3 borrowerNote to the caller of the rollover function\\n        borrowerNoteV3.safeTransferFrom(address(this), opDataBorrower, newLoanId);\\n\\n        return newLoanId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2-migration/V2ToV3RolloverBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IMigrationBase.sol\\\";\\n\\nimport {\\n    R_FundsConflict,\\n    R_NotCollateralOwner,\\n    R_CallerNotBorrower,\\n    R_BorrowerNotReset,\\n    R_CurrencyMismatch,\\n    R_CollateralMismatch,\\n    R_CollateralIdMismatch,\\n    R_NoTokenBalance,\\n    R_StateAlreadySet,\\n    R_ZeroAddress\\n} from \\\"../errors/RolloverErrors.sol\\\";\\n\\n/**\\n * @title V2ToV3RolloverBase\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * This contract holds the common logic for the V2ToV3Rollover and V2ToV3RolloverWithItems contracts.\\n */\\nabstract contract V2ToV3RolloverBase is IMigrationBase, ReentrancyGuard, ERC721Holder, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    event V2V3Rollover(\\n        address indexed lender,\\n        address indexed borrower,\\n        uint256 collateralTokenId,\\n        uint256 newLoanId\\n    );\\n\\n    struct OperationContracts {\\n        ILoanCoreV2 loanCoreV2;\\n        IERC721 borrowerNoteV2;\\n        IRepaymentControllerV2 repaymentControllerV2;\\n        IFeeController feeControllerV3;\\n        IOriginationController originationControllerV3;\\n        ILoanCore loanCoreV3;\\n        IERC721 borrowerNoteV3;\\n    }\\n\\n    // Balancer vault contract\\n    /* solhint-disable var-name-mixedcase */\\n    IVault public immutable VAULT; // 0xBA12222222228d8Ba445958a75a0704d566BF2C8\\n\\n    /// @notice lending protocol contract references\\n    ILoanCoreV2 public immutable loanCoreV2;\\n    IERC721 public immutable borrowerNoteV2;\\n    IRepaymentControllerV2 public immutable repaymentControllerV2;\\n    IFeeController public immutable feeControllerV3;\\n    IOriginationController public immutable originationControllerV3;\\n    ILoanCore public immutable loanCoreV3;\\n    IERC721 public immutable borrowerNoteV3;\\n\\n    /// @notice State variable used for checking the inheriting contract initiated the flash\\n    ///         loan. When a rollover function is called the borrowers address is cached here\\n    ///         and checked against the opData in the flash loan callback.\\n    address public borrower;\\n\\n    /// @notice state variable for pausing the contract\\n    bool public paused;\\n\\n    constructor(IVault _vault, OperationContracts memory _opContracts) {\\n        // input sanitization\\n        if (address(_vault) == address(0)) revert R_ZeroAddress(\\\"vault\\\");\\n        if (address(_opContracts.loanCoreV2) == address(0)) revert R_ZeroAddress(\\\"loanCoreV2\\\");\\n        if (address(_opContracts.borrowerNoteV2) == address(0)) revert R_ZeroAddress(\\\"borrowerNoteV2\\\");\\n        if (address(_opContracts.repaymentControllerV2) == address(0)) revert R_ZeroAddress(\\\"repaymentControllerV2\\\");\\n        if (address(_opContracts.feeControllerV3) == address(0)) revert R_ZeroAddress(\\\"feeControllerV3\\\");\\n        if (address(_opContracts.originationControllerV3) == address(0)) revert R_ZeroAddress(\\\"originationControllerV3\\\");\\n        if (address(_opContracts.loanCoreV3) == address(0)) revert R_ZeroAddress(\\\"loanCoreV3\\\");\\n        if (address(_opContracts.borrowerNoteV3) == address(0)) revert R_ZeroAddress(\\\"borrowerNoteV3\\\");\\n\\n        // Set Balancer vault address\\n        VAULT = _vault;\\n\\n        // Set lending protocol contract references\\n        loanCoreV2 = ILoanCoreV2(_opContracts.loanCoreV2);\\n        borrowerNoteV2 = IERC721(_opContracts.borrowerNoteV2);\\n        repaymentControllerV2 = IRepaymentControllerV2(_opContracts.repaymentControllerV2);\\n        feeControllerV3 = IFeeController(_opContracts.feeControllerV3);\\n        originationControllerV3 = IOriginationController(_opContracts.originationControllerV3);\\n        loanCoreV3 = ILoanCore(_opContracts.loanCoreV3);\\n        borrowerNoteV3 = IERC721(_opContracts.borrowerNoteV3);\\n    }\\n\\n    /**\\n     * @notice This helper function to calculate the net amounts required to repay the flash loan.\\n     *         This function will return the total amount due back to the lending pool. The amount\\n     *         that needs to be paid by the borrower, in the case that the new loan does not cover\\n     *         the flashAmountDue. Lastly, the amount that will be sent back to the borrower, in\\n     *         the case that the new loan covers more than the flashAmountDue. There cannot be a\\n     *         case where both needFromBorrower and leftoverPrincipal are non-zero.\\n     *\\n     * @param amount                  The amount that was borrowed in Flash Loan.\\n     * @param premium                 The fees that are due back to the lending pool.\\n     * @param originationFee          The origination fee for the new loan.\\n     * @param newPrincipal            The principal of the new loan.\\n     *\\n     * @return flashAmountDue         The total amount due back to the lending pool.\\n     * @return needFromBorrower       The amount borrower owes if new loan cannot repay flash loan.\\n     * @return leftoverPrincipal      The amount to send to borrower if new loan amount is more than\\n     *                                amount required to repay flash loan.\\n     */\\n    function _ensureFunds(\\n        uint256 amount,\\n        uint256 premium,\\n        uint256 originationFee,\\n        uint256 newPrincipal\\n    ) internal pure returns (uint256 flashAmountDue, uint256 needFromBorrower, uint256 leftoverPrincipal) {\\n        // total amount due to flash loan contract\\n        flashAmountDue = amount + premium;\\n        // amount that will be received when starting the new loan\\n        uint256 willReceive = newPrincipal - ((newPrincipal * originationFee) / 1e4);\\n\\n        if (flashAmountDue > willReceive) {\\n            // Not enough - have borrower pay the difference\\n            unchecked {\\n                needFromBorrower = flashAmountDue - willReceive;\\n            }\\n        } else if (willReceive > flashAmountDue) {\\n            // Too much - will send extra to borrower\\n            unchecked {\\n                leftoverPrincipal = willReceive - flashAmountDue;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to repay the loan. Takes the borrowerNote from the borrower, approves\\n     *         the V2 repayment controller to spend the payable currency received from flash loan.\\n     *         Repays the loan, and ensures this contract holds the collateral after the loan is repaid.\\n     *\\n     * @param loanData                 The loan data for the loan to be repaid.\\n     * @param borrowerNoteId           ID of the borrowerNote for the loan to be repaid.\\n     * @param opDataBorrower           The address of the borrower.\\n     */\\n    function _repayLoan(\\n        LoanLibraryV2.LoanData memory loanData,\\n        uint256 borrowerNoteId,\\n        address opDataBorrower\\n    ) internal {\\n        // take BorrowerNote from borrower so that this contract receives collateral\\n        // borrower must approve this withdrawal\\n        borrowerNoteV2.transferFrom(opDataBorrower, address(this), borrowerNoteId);\\n\\n        // approve repayment\\n        uint256 totalRepayment = repaymentControllerV2.getFullInterestAmount(\\n            loanData.terms.principal,\\n            loanData.terms.interestRate\\n        );\\n\\n        IERC20(loanData.terms.payableCurrency).approve(\\n            address(repaymentControllerV2),\\n            totalRepayment\\n        );\\n\\n        // repay loan\\n        repaymentControllerV2.repay(borrowerNoteId);\\n\\n        // contract now has collateral but has lost funds\\n        address collateralOwner = IERC721(loanData.terms.collateralAddress).ownerOf(loanData.terms.collateralId);\\n        if (collateralOwner != address(this)) revert R_NotCollateralOwner(collateralOwner);\\n    }\\n\\n    /**\\n     * @notice Validates that the rollover is valid. The borrower from the old loan must be the caller.\\n     *         The new loan must have the same currency as the old loan. The new loan must use the same\\n     *         collateral as the old loan. If any of these conditionals are not met, the transaction\\n     *         will revert.\\n     *\\n     * @param sourceLoanTerms           The terms of the V2 loan.\\n     * @param newLoanTerms              The terms of the V3 loan.\\n     * @param borrowerNoteId            The ID of the borrowerNote for the old loan.\\n     *\\n     * @return _borrower                Caller and the owner of borrowerNote address.\\n     */\\n    function _validateRollover(\\n        LoanLibraryV2.LoanTerms memory sourceLoanTerms,\\n        LoanLibrary.LoanTerms memory newLoanTerms,\\n        uint256 borrowerNoteId\\n    ) internal view returns (address _borrower) {\\n        _borrower = borrowerNoteV2.ownerOf(borrowerNoteId);\\n\\n        if (_borrower != msg.sender) revert R_CallerNotBorrower(msg.sender, _borrower);\\n\\n        if (sourceLoanTerms.payableCurrency != newLoanTerms.payableCurrency) {\\n            revert R_CurrencyMismatch(sourceLoanTerms.payableCurrency, newLoanTerms.payableCurrency);\\n        }\\n\\n        if (sourceLoanTerms.collateralAddress != newLoanTerms.collateralAddress) {\\n            revert R_CollateralMismatch(sourceLoanTerms.collateralAddress, newLoanTerms.collateralAddress);\\n        }\\n\\n        if (sourceLoanTerms.collateralId != newLoanTerms.collateralId) {\\n            revert R_CollateralIdMismatch(sourceLoanTerms.collateralId, newLoanTerms.collateralId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to be used by the contract owner to pause the contract.\\n     *\\n     * @dev This function is only to be used if a vulnerability is found or the contract\\n     *      is no longer being used.\\n     *\\n     * @param _pause              The state to set the contract to.\\n     */\\n    function pause(bool _pause) external override onlyOwner {\\n        if (paused == _pause) revert R_StateAlreadySet();\\n\\n        paused = _pause;\\n\\n        emit PausedStateChanged(_pause);\\n    }\\n\\n    /**\\n     * @notice Function to be used by the contract owner to withdraw any ERC20 tokens that\\n     *         are sent to the contract and get stuck.\\n     */\\n    function flushToken(IERC20 token, address to) external override onlyOwner {\\n        uint256 balance = token.balanceOf(address(this));\\n        if (balance == 0) revert R_NoTokenBalance();\\n\\n        token.safeTransfer(to, balance);\\n    }\\n\\n    /**\\n     * @notice This function ensures that at the start of every flash loan sequence, the borrower\\n     *         state is reset to address(0). The rollover functions that inherit this modifier set\\n     *         the borrower state while executing the rollover operations. At the end of the rollover\\n     *         the borrower state is reset to address(0).\\n     */\\n    modifier whenBorrowerReset() {\\n        if (borrower != address(0)) revert R_BorrowerNotReset(borrower);\\n\\n        _;\\n\\n        borrower = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMigration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILoanCore.sol\\\";\\n\\ninterface IMigration {\\n    struct OperationData {\\n        uint256 loanId;\\n        address borrower;\\n        LoanLibrary.LoanTerms newLoanTerms;\\n        address lender;\\n        uint160 nonce;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function migrateLoan(\\n        uint256 loanId,\\n        LoanLibrary.LoanTerms calldata newLoanTerms,\\n        address lender,\\n        uint160 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FeeLookups.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title FeeLookups\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * Enumerates unique identifiers for fee identifiers\\n * that the lending protocol uses.\\n */\\nabstract contract FeeLookups {\\n    /// @dev Origination fees: amount in bps, payable in loan token\\n    bytes32 public constant FL_01 = keccak256(\\\"BORROWER_ORIGINATION_FEE\\\");\\n    bytes32 public constant FL_02 = keccak256(\\\"LENDER_ORIGINATION_FEE\\\");\\n\\n    /// @dev Rollover fees: amount in bps, payable in loan token\\n    bytes32 public constant FL_03 = keccak256(\\\"BORROWER_ROLLOVER_FEE\\\");\\n    bytes32 public constant FL_04 = keccak256(\\\"LENDER_ROLLOVER_FEE\\\");\\n\\n    /// @dev Loan closure fees: amount in bps, payable in loan token\\n    bytes32 public constant FL_05 = keccak256(\\\"LENDER_DEFAULT_FEE\\\");\\n    bytes32 public constant FL_06 = keccak256(\\\"LENDER_INTEREST_FEE\\\");\\n    bytes32 public constant FL_07 = keccak256(\\\"LENDER_PRINCIPAL_FEE\\\");\\n    bytes32 public constant FL_08 = keccak256(\\\"LENDER_REDEEM_FEE\\\");\\n}\\n\"\r\n    },\r\n    \"contracts/errors/RolloverErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title RolloverErrors\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * This file contains all custom errors for V2 -> V3 rollover contracts. All errors are\\n * prefixed by \\\"R_\\\" for Rollover. Errors are located in one place to make it possible to\\n * holistically look at all V2 -> V3 rollover failure cases.\\n */\\n\\n// ================================== V2 To V3 Rollover ====================================\\n\\n/**\\n * @notice The flash loan callback caller is not recognized. The caller must be the flash\\n *         loan provider.\\n *\\n * @param caller                  The address of the caller.\\n * @param lendingPool             Expected address of the flash loan provider.\\n */\\nerror R_UnknownCaller(address caller, address lendingPool);\\n\\n/**\\n * @notice The balance of the borrower is insufficient to repay the difference between\\n *         the V2 loan and the V3 loan principal minus fees.\\n *\\n * @param borrower                The address of the borrower.\\n * @param amount                  The difference amount.\\n * @param balance                 Current balance of the borrower.\\n */\\nerror R_InsufficientFunds(address borrower, uint256 amount, uint256 balance);\\n\\n/**\\n * @notice The allowance of the borrower to the V2 -> V3 rollover contract is insufficient\\n *          to repay the difference between the V2 loan and the V3 loan principal minus fees.\\n *\\n * @param borrower                The address of the borrower.\\n * @param amount                  The difference amount.\\n * @param allowance               Current allowance of the borrower.\\n */\\nerror R_InsufficientAllowance(address borrower, uint256 amount, uint256 allowance);\\n\\n/**\\n * @notice An accounting check to verify that either the leftover V3 loan principal is\\n *         zero or the amount needed from the borrower to cover any difference is zero.\\n *         Either there is leftover principal that needs to be sent to the borrower, or\\n *         the borrower needs to send funds to cover the difference between the V2 repayment\\n *         amount and the new V3 loan principal minus any fees.\\n *\\n * @param leftoverPrincipal       The leftover principal from the V3 loan.\\n * @param needFromBorrower        The amount needed from the borrower to cover the difference.\\n */\\nerror R_FundsConflict(uint256 leftoverPrincipal, uint256 needFromBorrower);\\n\\n/**\\n * @notice After repaying the V2 loan, the V2 -> V3 rollover contract must be the owner of\\n *         the collateral token.\\n *\\n * @param owner                   The owner of the collateral token.\\n */\\nerror R_NotCollateralOwner(address owner);\\n\\n/**\\n * @notice Only the holder of the borrowerNote can rollover their loan.\\n *\\n * @param caller                  The address of the caller.\\n * @param borrower                Holder of the borrower notes address\\n */\\nerror R_CallerNotBorrower(address caller, address borrower);\\n\\n/**\\n * @notice The V2 and V3 payable currency tokens must be the same so that the flash loan can\\n *         be repaid.\\n *\\n * @param v2Currency              The V2 payable currency address.\\n * @param v3Currency              The V3 payable currency address.\\n */\\nerror R_CurrencyMismatch(address v2Currency, address v3Currency);\\n\\n/**\\n * @notice The V2 and V3 collateral tokens must be the same.\\n *\\n * @param v2Collateral            The V2 collateral token address.\\n * @param v3Collateral            The V3 collateral token address.\\n */\\nerror R_CollateralMismatch(address v2Collateral, address v3Collateral);\\n\\n/**\\n * @notice The V2 and V3 collateral token IDs must be the same.\\n *\\n * @param v2CollateralId          The V2 collateral token ID.\\n * @param v3CollateralId          The V3 collateral token ID.\\n */\\nerror R_CollateralIdMismatch(uint256 v2CollateralId, uint256 v3CollateralId);\\n\\n/**\\n * @notice The rollover contract does not hold a balance for the token specified to flush.\\n */\\nerror R_NoTokenBalance();\\n\\n/**\\n * @notice Contract is paused, rollover operations are blocked.\\n */\\nerror R_Paused();\\n\\n/**\\n * @notice The rollover contract is already in the specified pause state.\\n */\\nerror R_StateAlreadySet();\\n\\n/**\\n * @notice Cannot pass the zero address as an argument.\\n *\\n * @param name                    The name of the contract.\\n */\\nerror R_ZeroAddress(string name);\\n\\n/**\\n * @notice The borrower address saved in the rollover contract is not the same as the\\n *         borrower address provided in the flash loan operation data. The initiator of\\n *         the flash loan must be the rollover contract.\\n *\\n * @param providedBorrower        Borrower address passed in the flash loan operation data.\\n * @param cachedBorrower          Borrower address saved in the rollover contract.\\n */\\nerror R_UnknownBorrower(address providedBorrower, address cachedBorrower);\\n\\n/**\\n * @notice The borrower state must be address(0) to initiate a rollover sequence.\\n *\\n * @param borrower                The borrower address.\\n */\\nerror R_BorrowerNotReset(address borrower);\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMigrationBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./ILoanCore.sol\\\";\\nimport \\\"./IOriginationController.sol\\\";\\nimport \\\"./IFeeController.sol\\\";\\n\\nimport \\\"../external/interfaces/IFlashLoanRecipient.sol\\\";\\n\\nimport \\\"../v2-migration/v2-contracts/v2-interfaces/ILoanCoreV2.sol\\\";\\nimport \\\"../v2-migration/v2-contracts/v2-interfaces/IRepaymentControllerV2.sol\\\";\\n\\ninterface IMigrationBase is IFlashLoanRecipient {\\n    event PausedStateChanged(bool isPaused);\\n\\n    function flushToken(IERC20 token, address to) external;\\n\\n    function pause(bool _pause) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoanCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../libraries/LoanLibrary.sol\\\";\\nimport \\\"./IPromissoryNote.sol\\\";\\n\\ninterface ILoanCore {\\n\\n    // ================ Data Types =================\\n\\n    struct AffiliateSplit {\\n        address affiliate;\\n        uint96 splitBps;\\n    }\\n\\n    struct NoteReceipt {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    // ================ Events =================\\n\\n    event LoanStarted(uint256 loanId, address lender, address borrower);\\n    event LoanRepaid(uint256 loanId);\\n    event ForceRepay(uint256 loanId);\\n    event LoanRolledOver(uint256 oldLoanId, uint256 newLoanId);\\n    event LoanClaimed(uint256 loanId);\\n    event NoteRedeemed(address indexed token, address indexed caller, address indexed to, uint256 tokenId, uint256 amount);\\n    event NonceUsed(address indexed user, uint160 nonce);\\n\\n    event FeesWithdrawn(address indexed token, address indexed caller, address indexed to, uint256 amount);\\n    event AffiliateSet(bytes32 indexed code, address indexed affiliate, uint96 splitBps);\\n\\n    // ============== Lifecycle Operations ==============\\n\\n    function startLoan(\\n        address lender,\\n        address borrower,\\n        LoanLibrary.LoanTerms calldata terms,\\n        uint256 _amountFromLender,\\n        uint256 _amountToBorrower,\\n        LoanLibrary.FeeSnapshot calldata feeSnapshot\\n    ) external returns (uint256 loanId);\\n\\n    function repay(\\n        uint256 loanId,\\n        address payer,\\n        uint256 _amountFromPayer,\\n        uint256 _amountToLender\\n    ) external;\\n\\n    function forceRepay(\\n        uint256 loanId,\\n        address payer,\\n        uint256 _amountFromPayer,\\n        uint256 _amountToLender\\n    ) external;\\n\\n    function claim(\\n        uint256 loanId,\\n        uint256 _amountFromLender\\n    ) external;\\n\\n    function redeemNote(\\n        uint256 loanId,\\n        uint256 _amountFromLender,\\n        address to\\n    ) external;\\n\\n    function rollover(\\n        uint256 oldLoanId,\\n        address borrower,\\n        address lender,\\n        LoanLibrary.LoanTerms calldata terms,\\n        uint256 _settledAmount,\\n        uint256 _amountToOldLender,\\n        uint256 _amountToLender,\\n        uint256 _amountToBorrower\\n    ) external returns (uint256 newLoanId);\\n\\n    // ============== Nonce Management ==============\\n\\n    function consumeNonce(address user, uint160 nonce) external;\\n\\n    function cancelNonce(uint160 nonce) external;\\n\\n    // ============== Fee Management ==============\\n\\n    function withdraw(address token, uint256 amount, address to) external;\\n\\n    function withdrawProtocolFees(address token, address to) external;\\n\\n    // ============== Admin Operations ==============\\n\\n    function setAffiliateSplits(bytes32[] calldata codes, AffiliateSplit[] calldata splits) external;\\n\\n    // ============== View Functions ==============\\n\\n    function getLoan(uint256 loanId) external view returns (LoanLibrary.LoanData calldata loanData);\\n\\n    function getNoteReceipt(uint256 loanId) external view returns (address token, uint256 amount);\\n\\n    function isNonceUsed(address user, uint160 nonce) external view returns (bool);\\n\\n    function borrowerNote() external view returns (IPromissoryNote);\\n\\n    function lenderNote() external view returns (IPromissoryNote);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOriginationController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../libraries/LoanLibrary.sol\\\";\\n\\ninterface IOriginationController {\\n    // ================ Data Types =============\\n\\n    struct Currency {\\n        bool isAllowed;\\n        uint256 minPrincipal;\\n    }\\n\\n    enum Side {\\n        BORROW,\\n        LEND\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes extraData;\\n    }\\n\\n    struct RolloverAmounts {\\n        uint256 needFromBorrower;\\n        uint256 leftoverPrincipal;\\n        uint256 amountFromLender;\\n        uint256 amountToOldLender;\\n        uint256 amountToLender;\\n        uint256 amountToBorrower;\\n    }\\n\\n    // ================ Events =================\\n\\n    event Approval(address indexed owner, address indexed signer, bool isApproved);\\n    event SetAllowedVerifier(address indexed verifier, bool isAllowed);\\n    event SetAllowedCurrency(address indexed currency, bool isAllowed, uint256 minPrincipal);\\n    event SetAllowedCollateral(address indexed collateral, bool isAllowed);\\n\\n    // ============== Origination Operations ==============\\n\\n    function initializeLoan(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address borrower,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce\\n    ) external returns (uint256 loanId);\\n\\n    function initializeLoanWithItems(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address borrower,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        LoanLibrary.Predicate[] calldata itemPredicates\\n    ) external returns (uint256 loanId);\\n\\n    function initializeLoanWithCollateralPermit(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address borrower,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        Signature calldata collateralSig,\\n        uint256 permitDeadline\\n    ) external returns (uint256 loanId);\\n\\n    function initializeLoanWithCollateralPermitAndItems(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address borrower,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        Signature calldata collateralSig,\\n        uint256 permitDeadline,\\n        LoanLibrary.Predicate[] calldata itemPredicates\\n    ) external returns (uint256 loanId);\\n\\n    function rolloverLoan(\\n        uint256 oldLoanId,\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce\\n    ) external returns (uint256 newLoanId);\\n\\n    function rolloverLoanWithItems(\\n        uint256 oldLoanId,\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        address lender,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        LoanLibrary.Predicate[] calldata itemPredicates\\n    ) external returns (uint256 newLoanId);\\n\\n    // ================ Permission Management =================\\n\\n    function approve(address signer, bool approved) external;\\n\\n    function isApproved(address owner, address signer) external returns (bool);\\n\\n    function isSelfOrApproved(address target, address signer) external returns (bool);\\n\\n    function isApprovedForContract(\\n        address target,\\n        Signature calldata sig,\\n        bytes32 sighash\\n    ) external returns (bool);\\n\\n    // ============== Signature Verification ==============\\n\\n    function recoverTokenSignature(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        Side side\\n    ) external view returns (bytes32 sighash, address signer);\\n\\n    function recoverItemsSignature(\\n        LoanLibrary.LoanTerms calldata loanTerms,\\n        Signature calldata sig,\\n        uint160 nonce,\\n        Side side,\\n        bytes32 itemsHash\\n    ) external view returns (bytes32 sighash, address signer);\\n\\n    // ============== Admin Operations ==============\\n\\n    function setAllowedPayableCurrencies(address[] memory _tokenAddress, Currency[] calldata currencyData) external;\\n\\n    function setAllowedCollateralAddresses(address[] memory _tokenAddress, bool[] calldata isAllowed) external;\\n\\n    function setAllowedVerifiers(address[] calldata verifiers, bool[] calldata isAllowed) external;\\n\\n    function isAllowedCurrency(address token) external view returns (bool);\\n\\n    function isAllowedCollateral(address token) external view returns (bool);\\n\\n    function isAllowedVerifier(address verifier) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\ninterface IFeeController {\\n    // ================ Structs ================\\n\\n    struct FeesOrigination {\\n        uint16 borrowerOriginationFee;\\n        uint16 lenderOriginationFee;\\n        uint16 lenderDefaultFee;\\n        uint16 lenderInterestFee;\\n        uint16 lenderPrincipalFee;\\n    }\\n\\n    struct FeesRollover {\\n        uint16 borrowerRolloverFee;\\n        uint16 lenderRolloverFee;\\n    }\\n\\n    // ================ Events =================\\n\\n    event SetLendingFee(bytes32 indexed id, uint16 fee);\\n\\n    event SetVaultMintFee(uint64 fee);\\n\\n    // ================ Getter/Setter =================\\n\\n    function setLendingFee(bytes32 id, uint16 fee) external;\\n\\n    function setVaultMintFee(uint64 fee) external;\\n\\n    function getLendingFee(bytes32 id) external view returns (uint16);\\n\\n    function getVaultMintFee() external view returns (uint64);\\n\\n    function getFeesOrigination() external view returns (FeesOrigination memory);\\n\\n    function getFeesRollover() external view returns (FeesRollover memory);\\n\\n    function getMaxLendingFee(bytes32 id) external view returns (uint16);\\n\\n    function getMaxVaultMintFee() external view returns (uint64);\\n}\"\r\n    },\r\n    \"contracts/external/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\\ninterface IVault {\\n    /**\\n     * @dev copied from @balancer-labs/v2-vault/contracts/interfaces/IVault.sol,\\n     *      which uses an incompatible compiler version. Only necessary selectors\\n     *      (flashLoan) included.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/v2-migration/v2-contracts/v2-interfaces/ILoanCoreV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"../LoanLibraryV2.sol\\\";\\n\\nimport \\\"./IPromissoryNoteV2.sol\\\";\\nimport \\\"./IFeeControllerV2.sol\\\";\\n\\ninterface ILoanCoreV2 {\\n    // ================ Events =================\\n\\n    event LoanCreated(LoanLibraryV2.LoanTerms terms, uint256 loanId);\\n    event LoanStarted(uint256 loanId, address lender, address borrower);\\n    event LoanRepaid(uint256 loanId);\\n    event LoanRolledOver(uint256 oldLoanId, uint256 newLoanId);\\n    event InstallmentPaymentReceived(uint256 loanId, uint256 repaidAmount, uint256 remBalance);\\n    event LoanClaimed(uint256 loanId);\\n    event FeesClaimed(address token, address to, uint256 amount);\\n    event SetFeeController(address feeController);\\n    event NonceUsed(address indexed user, uint160 nonce);\\n\\n    // ============== Lifecycle Operations ==============\\n\\n    function startLoan(\\n        address lender,\\n        address borrower,\\n        LoanLibraryV2.LoanTerms calldata terms\\n    ) external returns (uint256 loanId);\\n\\n    function repay(uint256 loanId) external;\\n\\n    function repayPart(\\n        uint256 _loanId,\\n        uint256 _currentMissedPayments,\\n        uint256 _paymentToPrincipal,\\n        uint256 _paymentToInterest,\\n        uint256 _paymentToLateFees,\\n        address _caller\\n    ) external;\\n\\n    function claim(uint256 loanId, uint256 currentInstallmentPeriod) external;\\n\\n    function rollover(\\n        uint256 oldLoanId,\\n        address borrower,\\n        address lender,\\n        LoanLibraryV2.LoanTerms calldata terms,\\n        uint256 _settledAmount,\\n        uint256 _amountToOldLender,\\n        uint256 _amountToLender,\\n        uint256 _amountToBorrower\\n    ) external returns (uint256 newLoanId);\\n\\n    // ============== Nonce Management ==============\\n\\n    function consumeNonce(address user, uint160 nonce) external;\\n\\n    function cancelNonce(uint160 nonce) external;\\n\\n    // ============== View Functions ==============\\n\\n    function getLoan(uint256 loanId) external view returns (LoanLibraryV2.LoanData calldata loanData);\\n\\n    function isNonceUsed(address user, uint160 nonce) external view returns (bool);\\n\\n    function borrowerNote() external returns (IPromissoryNoteV2);\\n\\n    function lenderNote() external returns (IPromissoryNoteV2);\\n\\n    function feeController() external returns (IFeeControllerV2);\\n}\"\r\n    },\r\n    \"contracts/v2-migration/v2-contracts/v2-interfaces/IRepaymentControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\ninterface IRepaymentControllerV2 {\\n    // ============== Lifeycle Operations ==============\\n\\n    function repay(uint256 loanId) external;\\n\\n    function claim(uint256 loanId) external;\\n\\n    function repayPartMinimum(uint256 loanId) external;\\n\\n    function repayPart(uint256 loanId, uint256 amount) external;\\n\\n    function closeLoan(uint256 loanId) external;\\n\\n    // ============== View Functions ==============\\n\\n    function getInstallmentMinPayment(uint256 loanId)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function amountToCloseLoan(uint256 loanId) external returns (uint256, uint256);\\n\\n    function getFullInterestAmount(uint256 principal, uint256 interestRate) external pure returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LoanLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title LoanLibrary\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * Contains all data types used across Arcade lending contracts.\\n */\\nlibrary LoanLibrary {\\n    /**\\n     * @dev Enum describing the current state of a loan.\\n     * State change flow:\\n     * Created -> Active -> Repaid\\n     *                   -> Defaulted\\n     */\\n    enum LoanState {\\n        // We need a default that is not 'Created' - this is the zero value\\n        DUMMY_DO_NOT_USE,\\n        // The loan has been initialized, funds have been delivered to the borrower and the collateral is held.\\n        Active,\\n        // The loan has been repaid, and the collateral has been returned to the borrower. This is a terminal state.\\n        Repaid,\\n        // The loan was delinquent and collateral claimed by the lender. This is a terminal state.\\n        Defaulted\\n    }\\n\\n    /**\\n     * @dev The raw terms of a loan.\\n     */\\n    struct LoanTerms {\\n        // Interest expressed as a rate, unlike V1 gross value.\\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\\n        // This represents the rate over the lifetime of the loan, not APR.\\n        // 0.01% is the minimum interest rate allowed by the protocol.\\n        uint256 proratedInterestRate;\\n        /// @dev Full-slot variables\\n        // The amount of principal in terms of the payableCurrency.\\n        uint256 principal;\\n        // The token ID of the address holding the collateral.\\n        /// @dev Can be an AssetVault, or the NFT contract for unbundled collateral\\n        address collateralAddress;\\n        /// @dev Packed variables\\n        // The number of seconds representing relative due date of the loan.\\n        /// @dev Max is 94,608,000, fits in 96 bits\\n        uint96 durationSecs;\\n        // The token ID of the collateral.\\n        uint256 collateralId;\\n        // The payable currency for the loan principal and interest.\\n        address payableCurrency;\\n        // Timestamp for when signature for terms expires\\n        uint96 deadline;\\n        // Affiliate code used to start the loan.\\n        bytes32 affiliateCode;\\n    }\\n\\n    /**\\n     * @dev Modification of loan terms, used for signing only.\\n     *      Instead of a collateralId, a list of predicates\\n     *      is defined by 'bytes' in items.\\n     */\\n    struct LoanTermsWithItems {\\n        // Interest expressed as a rate, unlike V1 gross value.\\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\\n        // This represents the rate over the lifetime of the loan, not APR.\\n        // 0.01% is the minimum interest rate allowed by the protocol.\\n        uint256 proratedInterestRate;\\n        /// @dev Full-slot variables\\n        // The amount of principal in terms of the payableCurrency.\\n        uint256 principal;\\n        // The tokenID of the address holding the collateral\\n        address collateralAddress;\\n        /// @dev Packed variables\\n        // The number of seconds representing relative due date of the loan.\\n        /// @dev Max is 94,608,000, fits in 96 bits\\n        uint96 durationSecs;\\n        // An encoded list of predicates, along with their verifiers.\\n        bytes items;\\n        // The payable currency for the loan principal and interest.\\n        address payableCurrency;\\n        // Timestamp for when signature for terms expires\\n        uint96 deadline;\\n        // Affiliate code used to start the loan.\\n        bytes32 affiliateCode;\\n    }\\n\\n    /**\\n     * @dev Predicate for item-based verifications\\n     */\\n    struct Predicate {\\n        // The encoded predicate, to decoded and parsed by the verifier contract.\\n        bytes data;\\n        // The verifier contract.\\n        address verifier;\\n    }\\n\\n    /**\\n     * @dev Snapshot of lending fees at the time of loan creation.\\n     */\\n    struct FeeSnapshot {\\n        // The fee taken when lender claims defaulted collateral.\\n        uint16 lenderDefaultFee;\\n        // The fee taken from the borrower's interest repayment.\\n        uint16 lenderInterestFee;\\n        // The fee taken from the borrower's principal repayment.\\n        uint16 lenderPrincipalFee;\\n    }\\n\\n    /**\\n     * @dev The data of a loan. This is stored once the loan is Active\\n     */\\n    struct LoanData {\\n        /// @dev Packed variables\\n        // The current state of the loan.\\n        LoanState state;\\n        // Start date of the loan, using block.timestamp.\\n        uint160 startDate;\\n        /// @dev Full-slot variables\\n        // The raw terms of the loan.\\n        LoanTerms terms;\\n        // Record of lending fees at the time of loan creation.\\n        FeeSnapshot feeSnapshot;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPromissoryNote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\nimport \\\"./INFTWithDescriptor.sol\\\";\\n\\ninterface IPromissoryNote is INFTWithDescriptor, IERC721Enumerable {\\n    // ============== Token Operations ==============\\n\\n    function mint(address to, uint256 loanId) external returns (uint256);\\n\\n    function burn(uint256 tokenId) external;\\n\\n    // ============== Initializer ==============\\n\\n    function initialize(address loanCore) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTWithDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\ninterface INFTWithDescriptor {\\n    // ============= Events ==============\\n\\n    event SetDescriptor(address indexed caller, address indexed descriptor);\\n\\n    // ================ Resource Metadata ================\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function setDescriptor(address descriptor) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v2-migration/v2-contracts/LoanLibraryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title LoanLibrary\\n * @author Non-Fungible Technologies, Inc.\\n *\\n * Contains all data types used across Arcade lending contracts.\\n */\\nlibrary LoanLibraryV2 {\\n    /**\\n     * @dev Enum describing the current state of a loan.\\n     * State change flow:\\n     * Created -> Active -> Repaid\\n     *                   -> Defaulted\\n     */\\n    enum LoanState {\\n        // We need a default that is not 'Created' - this is the zero value\\n        DUMMY_DO_NOT_USE,\\n        // The loan has been initialized, funds have been delivered to the borrower and the collateral is held.\\n        Active,\\n        // The loan has been repaid, and the collateral has been returned to the borrower. This is a terminal state.\\n        Repaid,\\n        // The loan was delinquent and collateral claimed by the lender. This is a terminal state.\\n        Defaulted\\n    }\\n\\n    /**\\n     * @dev The raw terms of a loan.\\n     */\\n    struct LoanTerms {\\n        /// @dev Packed variables\\n        // The number of seconds representing relative due date of the loan.\\n        /// @dev Max is 94,608,000, fits in 32 bits\\n        uint32 durationSecs;\\n        // Timestamp for when signature for terms expires\\n        uint32 deadline;\\n        // Total number of installment periods within the loan duration.\\n        /// @dev Max is 1,000,000, fits in 24 bits\\n        uint24 numInstallments;\\n        // Interest expressed as a rate, unlike V1 gross value.\\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\\n        // This represents the rate over the lifetime of the loan, not APR.\\n        // 0.01% is the minimum interest rate allowed by the protocol.\\n        /// @dev Max is 10,000%, fits in 160 bits\\n        uint160 interestRate;\\n        /// @dev Full-slot variables\\n        // The amount of principal in terms of the payableCurrency.\\n        uint256 principal;\\n        // The token ID of the address holding the collateral.\\n        /// @dev Can be an AssetVault, or the NFT contract for unbundled collateral\\n        address collateralAddress;\\n        // The token ID of the collateral.\\n        uint256 collateralId;\\n        // The payable currency for the loan principal and interest.\\n        address payableCurrency;\\n    }\\n\\n    /**\\n     * @dev Modification of loan terms, used for signing only.\\n     *      Instead of a collateralId, a list of predicates\\n     *      is defined by 'bytes' in items.\\n     */\\n    struct LoanTermsWithItems {\\n        /// @dev Packed variables\\n        // The number of seconds representing relative due date of the loan.\\n        /// @dev Max is 94,608,000, fits in 32 bits\\n        uint32 durationSecs;\\n        // Timestamp for when signature for terms expires\\n        uint32 deadline;\\n        // Total number of installment periods within the loan duration.\\n        /// @dev Max is 1,000,000, fits in 24 bits\\n        uint24 numInstallments;\\n        // Interest expressed as a rate, unlike V1 gross value.\\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\\n        // This represents the rate over the lifetime of the loan, not APR.\\n        // 0.01% is the minimum interest rate allowed by the protocol.\\n        /// @dev Max is 10,000%, fits in 160 bits\\n        uint160 interestRate;\\n        /// @dev Full-slot variables\\n        uint256 principal;\\n        // The tokenID of the address holding the collateral\\n        /// @dev Must be an AssetVault for LoanTermsWithItems\\n        address collateralAddress;\\n        // An encoded list of predicates\\n        bytes items;\\n        // The payable currency for the loan principal and interest\\n        address payableCurrency;\\n    }\\n\\n    /**\\n     * @dev Predicate for item-based verifications\\n     */\\n    struct Predicate {\\n        // The encoded predicate, to decoded and parsed by the verifier contract\\n        bytes data;\\n        // The verifier contract\\n        address verifier;\\n    }\\n\\n    /**\\n     * @dev The data of a loan. This is stored once the loan is Active\\n     */\\n    struct LoanData {\\n        /// @dev Packed variables\\n        // The current state of the loan\\n        LoanState state;\\n        // Number of installment payments made on the loan\\n        uint24 numInstallmentsPaid;\\n        // installment loan specific\\n        // Start date of the loan, using block.timestamp - for determining installment period\\n        uint160 startDate;\\n        /// @dev Full-slot variables\\n        // The raw terms of the loan\\n        LoanTerms terms;\\n        // Remaining balance of the loan. Starts as equal to principal. Can reduce based on\\n        // payments made, can increased based on compounded interest from missed payments and late fees\\n        uint256 balance;\\n        // Amount paid in total by the borrower\\n        uint256 balancePaid;\\n        // Total amount of late fees accrued\\n        uint256 lateFeesAccrued;\\n    }\\n}\"\r\n    },\r\n    \"contracts/v2-migration/v2-contracts/v2-interfaces/IPromissoryNoteV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IPromissoryNoteV2 is IERC721Enumerable {\\n    // ============== Token Operations ==============\\n\\n    function mint(address to, uint256 loanId) external returns (uint256);\\n\\n    function burn(uint256 tokenId) external;\\n\\n    function setPaused(bool paused) external;\\n\\n    // ============== Initializer ==============\\n\\n    function initialize(address loanCore) external;\\n}\"\r\n    },\r\n    \"contracts/v2-migration/v2-contracts/v2-interfaces/IFeeControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\ninterface IFeeControllerV2 {\\n    // ================ Events =================\\n\\n    event UpdateOriginationFee(uint256 _newFee);\\n    event UpdateRolloverFee(uint256 _newFee);\\n    event UpdateCollateralSaleFee(uint256 _newFee);\\n    event UpdatePayLaterFee(uint256 _newFee);\\n\\n    // ================ Fee Setters =================\\n\\n    function setOriginationFee(uint256 _originationFee) external;\\n\\n    function setRolloverFee(uint256 _rolloverFee) external;\\n\\n    function setCollateralSaleFee(uint256 _collateralSaleFee) external;\\n\\n    function setPayLaterFee(uint256 _payLaterFee) external;\\n\\n    // ================ Fee Getters =================\\n\\n    function getOriginationFee() external view returns (uint256);\\n\\n    function getRolloverFee() external view returns (uint256);\\n\\n    function getCollateralSaleFee() external view returns (uint256);\\n\\n    function getPayLaterFee() external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract ILoanCoreV2\",\"name\":\"loanCoreV2\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"borrowerNoteV2\",\"type\":\"address\"},{\"internalType\":\"contract IRepaymentControllerV2\",\"name\":\"repaymentControllerV2\",\"type\":\"address\"},{\"internalType\":\"contract IFeeController\",\"name\":\"feeControllerV3\",\"type\":\"address\"},{\"internalType\":\"contract IOriginationController\",\"name\":\"originationControllerV3\",\"type\":\"address\"},{\"internalType\":\"contract ILoanCore\",\"name\":\"loanCoreV3\",\"type\":\"address\"},{\"internalType\":\"contract IERC721\",\"name\":\"borrowerNoteV3\",\"type\":\"address\"}],\"internalType\":\"struct V2ToV3RolloverBase.OperationContracts\",\"name\":\"_opContracts\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"R_BorrowerNotReset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"R_CallerNotBorrower\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v2CollateralId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3CollateralId\",\"type\":\"uint256\"}],\"name\":\"R_CollateralIdMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"v2Collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"v3Collateral\",\"type\":\"address\"}],\"name\":\"R_CollateralMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"v2Currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"v3Currency\",\"type\":\"address\"}],\"name\":\"R_CurrencyMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"R_InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"R_InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"R_NoTokenBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"R_NotCollateralOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"R_Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"R_StateAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"providedBorrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cachedBorrower\",\"type\":\"address\"}],\"name\":\"R_UnknownBorrower\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lendingPool\",\"type\":\"address\"}],\"name\":\"R_UnknownCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"R_ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PausedStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoanId\",\"type\":\"uint256\"}],\"name\":\"V2V3Rollover\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FL_01\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_02\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_03\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_04\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_05\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_06\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_07\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FL_08\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrower\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerNoteV2\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerNoteV3\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeControllerV3\",\"outputs\":[{\"internalType\":\"contract IFeeController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"flushToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanCoreV2\",\"outputs\":[{\"internalType\":\"contract ILoanCoreV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanCoreV3\",\"outputs\":[{\"internalType\":\"contract ILoanCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"proratedInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"durationSecs\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"collateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payableCurrency\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"deadline\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"affiliateCode\",\"type\":\"bytes32\"}],\"internalType\":\"struct LoanLibrary.LoanTerms\",\"name\":\"newLoanTerms\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"nonce\",\"type\":\"uint160\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"migrateLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originationControllerV3\",\"outputs\":[{\"internalType\":\"contract IOriginationController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repaymentControllerV2\",\"outputs\":[{\"internalType\":\"contract IRepaymentControllerV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "V2ToV3Rollover", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c800000000000000000000000081b2f8fc75bab64a6b144aa6d2faa127b4fa7fd9000000000000000000000000337104a4f06260ff327d6734c555a0f5d8f863aa000000000000000000000000b39dab85fa05c381767ff992ccde4c94619993d4000000000000000000000000f764442856eb3fe68a0828e07246a4b395e800fa000000000000000000000000b7bfcca7d7ff0f371867b770856fac184b18587800000000000000000000000089bc08ba00f135d608bc335f6b33d7a9abcc98af000000000000000000000000e5b12befaf3a91065da7fdd461ded2d8f8ecb7be", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}