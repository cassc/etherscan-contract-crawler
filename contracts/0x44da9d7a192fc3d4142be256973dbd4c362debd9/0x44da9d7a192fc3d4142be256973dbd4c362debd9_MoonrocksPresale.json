{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MoonrocksPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (\\n        uint amountToken,\\n        uint amountETH,\\n        uint liquidity\\n    );\\n}\\n\\ninterface IMoonrocks {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function enableTrading() external;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract MoonrocksPresale is Ownable {\\n    using SafeMath for uint256;\\n\\n    bool public isInit;\\n    bool public isDeposit;\\n    bool public isRefund;\\n    bool public isFinish;\\n    bool public burnTokens = true;\\n    address public creatorWallet;\\n    address public weth;\\n    uint8 public tokenDecimals = 18;\\n    uint256 public ethRaised;\\n    uint256 public percentageRaised;\\n    uint256 public tokensSold;\\n\\n    struct Pool {\\n        uint64 startTime;\\n        uint64 endTime;\\n        uint256 tokenDeposit;\\n        uint256 tokensForSale;\\n        uint256 tokensForLiquidity;\\n        uint8 liquidityPortion;\\n        uint256 hardCap;\\n        uint256 softCap;\\n        uint256 maxBuy;\\n        uint256 minBuy;\\n    }\\n\\n    IMoonrocks public tokenInstance;\\n    IUniswapV2Factory public UniswapV2Factory;\\n    IUniswapV2Router02 public UniswapV2Router02;\\n    Pool public pool;\\n\\n    mapping(address => uint256) public ethContribution;\\n\\n    modifier onlyActive {\\n        require(block.timestamp >= pool.startTime, \\\"Sale must be active.\\\");\\n        require(block.timestamp <= pool.endTime, \\\"Sale must be active.\\\");\\n        _;\\n    }\\n\\n    modifier onlyInactive {\\n        require(\\n            block.timestamp < pool.startTime ||\\n            block.timestamp > pool.endTime ||\\n            ethRaised >= pool.softCap, \\\"Sale must be inactive.\\\"\\n            );\\n        _;\\n    }\\n\\n    modifier onlyRefund {\\n        require(\\n            isRefund == true ||\\n            (block.timestamp > pool.endTime && ethRaised < pool.softCap), \\\"Refund unavailable.\\\"\\n            );\\n        _;\\n    }\\n\\n    constructor(\\n        IMoonrocks _tokenInstance,\\n        address _uniswapv2Router,\\n        address _uniswapv2Factory,\\n        address _weth\\n    ) {\\n        require(_uniswapv2Router != address(0), \\\"Invalid router address\\\");\\n        require(_uniswapv2Factory != address(0), \\\"Invalid factory address\\\");\\n\\n        isInit = false;\\n        isDeposit = false;\\n        isFinish = false;\\n        isRefund = false;\\n        ethRaised = 0;\\n\\n        weth = _weth;\\n        tokenInstance = _tokenInstance;\\n        creatorWallet = address(payable(msg.sender));\\n        UniswapV2Router02 = IUniswapV2Router02(_uniswapv2Router);\\n        UniswapV2Factory = IUniswapV2Factory(_uniswapv2Factory);\\n\\n        tokenInstance.approve(_uniswapv2Router, tokenInstance.totalSupply());\\n    }\\n\\n    event Liquified(address indexed _token, address indexed _router, address indexed _pair);\\n    event Canceled(address indexed _inititator, address indexed _token, address indexed _presale);\\n    event Bought(address indexed _buyer, uint256 _tokenAmount);\\n    event Refunded(address indexed _refunder, uint256 _tokenAmount);\\n    event Deposited(address indexed _initiator, uint256 _totalDeposit);\\n    event Claimed(address indexed _participent, uint256 _tokenAmount);\\n    event RefundedRemainder(address indexed _initiator, uint256 _amount);\\n    event BurntRemainder(address indexed _initiator, uint256 _amount);\\n    event Withdraw(address indexed _creator, uint256 _amount);\\n\\n    /*\\n    * Reverts ethers sent to this address whenever requirements are not met\\n    */\\n    receive() external payable {\\n        if(block.timestamp >= pool.startTime && block.timestamp <= pool.endTime){\\n            buyTokens(_msgSender());\\n        } else {\\n            revert(\\\"Presale is closed\\\");\\n        }\\n    }\\n\\n    /*\\n    * Initiates the arguments of the sale\\n    @dev arguments must be pa   ssed in wei (amount*10**18)\\n    */\\n    function initSale(\\n        uint64 _startTime,\\n        uint64 _endTime,\\n        uint256 _tokenDeposit,\\n        uint256 _tokensForSale,\\n        uint256 _tokensForLiquidity,\\n        uint8 _liquidityPortion,\\n        uint256 _hardCap,\\n        uint256 _softCap,\\n        uint256 _maxBuy,\\n        uint256 _minBuy\\n        ) external onlyOwner onlyInactive {\\n\\n        require(isInit == false, \\\"Sale no initialized\\\");\\n        require(_startTime >= block.timestamp, \\\"Invalid start time.\\\");\\n        require(_endTime > block.timestamp, \\\"Invalid end time.\\\");\\n        require(_tokenDeposit > 0, \\\"Invalid token deposit.\\\");\\n        require(_tokensForSale < _tokenDeposit, \\\"Invalid tokens for sale.\\\");\\n        require(_tokensForLiquidity < _tokenDeposit, \\\"Invalid tokens for liquidity.\\\");\\n        require(_softCap >= _hardCap / 2, \\\"SC must be >= HC/2.\\\");\\n        require(_liquidityPortion >= 50, \\\"Liquidity must be >=50.\\\");\\n        require(_liquidityPortion <= 100, \\\"Invalid liquidity.\\\");\\n        require(_minBuy < _maxBuy, \\\"Min buy must greater than max.\\\");\\n        require(_minBuy > 0, \\\"Min buy must exceed 0.\\\");\\n\\n        Pool memory newPool = Pool(\\n            _startTime,\\n            _endTime,\\n            _tokenDeposit,\\n            _tokensForSale,\\n            _tokensForLiquidity,\\n            _liquidityPortion,\\n            _hardCap,\\n            _softCap,\\n            _maxBuy,\\n            _minBuy\\n        );\\n\\n        pool = newPool;\\n\\n        isInit = true;\\n    }\\n\\n    /*\\n    * Once called the owner deposits tokens into pool\\n    */\\n    function deposit() external onlyOwner {\\n        require(!isDeposit, \\\"Tokens already deposited.\\\");\\n        require(isInit, \\\"Not initialized yet.\\\");\\n\\n        uint256 totalDeposit = _getTokenDeposit();\\n\\n        isDeposit = true;\\n\\n        require(tokenInstance.transferFrom(msg.sender, address(this), totalDeposit), \\\"Deposit failed.\\\");\\n\\n        emit Deposited(msg.sender, totalDeposit);\\n    }\\n\\n    /*\\n    * Finish the sale - Create Uniswap v2 pair, add liquidity, take fees, withrdawal funds, burn/refund unused tokens\\n    */\\n    function finishSale() external onlyOwner onlyInactive {\\n        require(ethRaised >= pool.softCap, \\\"Soft Cap is not met.\\\");\\n        require(block.timestamp > pool.startTime, \\\"Can not finish before start\\\");\\n        require(!isFinish, \\\"Sale already launched.\\\");\\n        require(!isRefund, \\\"Refund process.\\\");\\n\\n        percentageRaised = _getPercentageFromValue(ethRaised, pool.hardCap);\\n        tokensSold = _getValueFromPercentage(percentageRaised, pool.tokensForSale);\\n        uint256 tokensForLiquidity = _getValueFromPercentage(percentageRaised, pool.tokensForLiquidity);\\n        isFinish = true;\\n\\n        //add liquidity\\n        (uint amountToken, uint amountETH, ) = UniswapV2Router02.addLiquidityETH{value : _getLiquidityEth()}(\\n            address(tokenInstance),\\n            tokensForLiquidity,\\n            tokensForLiquidity,\\n            _getLiquidityEth(),\\n            owner(),\\n            block.timestamp + 600\\n        );\\n\\n        require(amountToken == tokensForLiquidity && amountETH == _getLiquidityEth(), \\\"Providing liquidity failed.\\\");\\n\\n        emit Liquified(\\n            address(tokenInstance),\\n            address(UniswapV2Router02),\\n            UniswapV2Factory.getPair(address(tokenInstance), weth)\\n        );\\n\\n        //withrawal eth\\n        uint256 ownerShareEth = _getOwnerEth();\\n\\n        if (ownerShareEth > 0) {\\n            payable(creatorWallet).transfer(ownerShareEth);\\n        }\\n\\n        //If HC is not reached, burn or refund the remainder\\n        if (ethRaised < pool.hardCap) {\\n            uint256 remainder = _getUserTokens(pool.hardCap - ethRaised) + (pool.tokensForLiquidity - tokensForLiquidity);\\n            if(burnTokens == true){\\n                require(tokenInstance.transfer(\\n                    0x000000000000000000000000000000000000dEaD,\\n                    remainder), \\\"Unable to burn.\\\"\\n                );\\n                emit BurntRemainder(msg.sender, remainder);\\n            } else {\\n                require(tokenInstance.transfer(creatorWallet, remainder), \\\"Refund failed.\\\");\\n                emit RefundedRemainder(msg.sender, remainder);\\n            }\\n        }\\n\\n        tokenInstance.enableTrading();\\n    }\\n\\n    /*\\n    * The owner can decide to close the sale if it is still active\\n    NOTE: Creator may call this function even if the Hard Cap is reached, to prevent it use:\\n     require(ethRaised < pool.hardCap)\\n    */\\n    function cancelSale() external onlyOwner onlyActive {\\n        require(!isFinish, \\\"Sale finished.\\\");\\n        pool.endTime = 0;\\n        isRefund = true;\\n\\n        if (tokenInstance.balanceOf(address(this)) > 0) {\\n            uint256 tokenDeposit = _getTokenDeposit();\\n            tokenInstance.transfer(msg.sender, tokenDeposit);\\n            emit Withdraw(msg.sender, tokenDeposit);\\n        }\\n        emit Canceled(msg.sender, address(tokenInstance), address(this));\\n    }\\n\\n    /*\\n    * Allows participents to claim the tokens they purchased\\n    */\\n    function claimTokens() external onlyInactive {\\n        require(isFinish, \\\"Sale is still active.\\\");\\n        require(!isRefund, \\\"Refund process.\\\");\\n        require(ethContribution[msg.sender] > 0, \\\"No tokens to be claimed.\\\");\\n\\n        uint256 tokensAmount = _getUserTokens(ethContribution[msg.sender]);\\n        ethContribution[msg.sender] = 0;\\n        require(tokenInstance.transfer(msg.sender, tokensAmount), \\\"Claim failed.\\\");\\n        emit Claimed(msg.sender, tokensAmount);\\n    }\\n\\n    /*\\n    * Refunds the Eth to participents\\n    */\\n    function refund() external onlyInactive onlyRefund {\\n        uint256 refundAmount = ethContribution[msg.sender];\\n\\n        require(refundAmount > 0, \\\"No refund amount\\\");\\n        require(address(this).balance >= refundAmount, \\\"No amount available\\\");\\n\\n        ethContribution[msg.sender] = 0;\\n        address payable refunder = payable(msg.sender);\\n        refunder.transfer(refundAmount);\\n        emit Refunded(refunder, refundAmount);\\n    }\\n\\n    /*\\n    * Allows the specified contributor to buy tokens by sending Ether\\n    */\\n    function buyTokens(address _contributor) public payable onlyActive {\\n        require(!isFinish, \\\"Sale finished.\\\");\\n        require(isDeposit, \\\"Tokens not deposited.\\\");\\n        require(_contributor != address(0), \\\"Transfer to 0 address.\\\");\\n        require(msg.value != 0, \\\"Wei Amount is 0\\\");\\n\\n        if (ethRaised > pool.hardCap - pool.minBuy) {\\n            require(msg.value == pool.hardCap - ethRaised, \\\"Value must be the remainder.\\\");\\n        } else {\\n            require(msg.value >= pool.minBuy, \\\"Min buy is not met.\\\");\\n        }\\n\\n        require(msg.value + ethContribution[_contributor] <= pool.maxBuy, \\\"Max buy limit exceeded.\\\");\\n        require(ethRaised + msg.value <= pool.hardCap, \\\"HC Reached.\\\");\\n\\n        ethRaised += msg.value;\\n        ethContribution[msg.sender] += msg.value;\\n    }\\n\\n    /*\\n    * Withdrawal tokens on refund\\n    */\\n    function withrawTokens() external onlyOwner onlyInactive onlyRefund {\\n        if (tokenInstance.balanceOf(address(this)) > 0) {\\n            uint256 tokenDeposit = _getTokenDeposit();\\n            require(tokenInstance.transfer(msg.sender, tokenDeposit), \\\"Withdraw failed.\\\");\\n            emit Withdraw(msg.sender, tokenDeposit);\\n        }\\n    }\\n\\n    /*\\n    * Internal functions, called when calculating balances\\n    */\\n    function _getUserTokens(uint256 _amount) internal view returns (uint256) {\\n        return _amount.mul(tokensSold).div(ethRaised);\\n    }\\n\\n    /*\\n    * Calculate the amount of ETH reserved for liquidity\\n    */\\n    function _getLiquidityEth() internal view returns (uint256) {\\n        return _getValueFromPercentage(pool.liquidityPortion, ethRaised);\\n    }\\n\\n    /*\\n    * Calculate the amount of ETH available for the contract owner\\n    */\\n    function _getOwnerEth() internal view returns (uint256) {\\n        uint256 liquidityEthFee = _getLiquidityEth();\\n        return ethRaised - liquidityEthFee;\\n    }\\n\\n    /*\\n    * Retrieve the amount of tokens to be deposited in the pool\\n    */\\n    function _getTokenDeposit() internal view returns (uint256) {\\n        return pool.tokenDeposit;\\n    }\\n\\n    /*\\n    * Get the percentage representation of a current value relative to a maximum value\\n    */\\n    function _getPercentageFromValue(uint256 currentValue, uint256 maxValue) internal pure returns (uint256) {\\n        require(currentValue <= maxValue, \\\"Number too high\\\");\\n\\n        return currentValue.mul(100).div(maxValue);\\n    }\\n\\n    /*\\n    * Get the value based on a given percentage of a maximum value\\n    */\\n    function _getValueFromPercentage(uint256 currentPercentage, uint256 maxValue) internal pure returns (uint256) {\\n        require(currentPercentage <= 100, \\\"Number too high\\\");\\n\\n        return maxValue.mul(currentPercentage).div(100);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMoonrocks\",\"name\":\"_tokenInstance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapv2Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapv2Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BurntRemainder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_inititator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_presale\",\"type\":\"address\"}],\"name\":\"Canceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_participent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalDeposit\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"Liquified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_refunder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RefundedRemainder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniswapV2Router02\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_tokenDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensForLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_liquidityPortion\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBuy\",\"type\":\"uint256\"}],\"name\":\"initSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinish\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRefund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"tokenDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensForLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"liquidityPortion\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBuy\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInstance\",\"outputs\":[{\"internalType\":\"contract IMoonrocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MoonrocksPresale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008dece2139d5258e31267fd5afeb906f984d79d3e0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}