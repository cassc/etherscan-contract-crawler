// SPDX-License-Identifier: MIT

/*
* Generated by @0x_digitalnomad
* Email [emailÂ protected] for your NFT launch needs
*/


pragma solidity ^0.8.10;


import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Strings.sol';
import "./ERC721B.sol";


/*//////////////////////////////////////
                ERRORS
//////////////////////////////////////*/
/// @notice Thrown when completing transaction will exceed collection supply
error ExceededMaxSupply();
/// @notice Thrown when the attempted sale is not actve
error SaleNotActive();
/// @notice Thrown when the message value is less than the required amount
error ValueTooLow();
/// @notice Thrown when the amount minted exceeds max allowed per txn
error MintingTooMany();
/// @notice Thrown when the input address is 0
error ZeroAddress();
/// @notice Thrown when the function caller does not own the token
error CallerNotOwner();


contract CycloTurtles is ERC721B, Ownable { 

    using Strings for uint256;
    
    /*//////////////////////////////////////
                STATE VARIABLES
    //////////////////////////////////////*/
    enum MintStatus {
        CLOSED,
        PRESALE,
        PUBLIC,
        SOLDOUT
    }
    MintStatus public mintStatus = MintStatus.CLOSED;

    uint256 public collectionSize;
    uint256 public constant maxPerTxn = 99;
    uint256 public presalePrice = 0.05 ether;
    uint256 public salePrice = 0.08 ether;
    uint256 public devMintCount;
    string private baseURI;
    string private unrevealedURI;
    bool public revealed = false;


    /*//////////////////////////////////////
                EVENTS
    //////////////////////////////////////*/
    event ChangeBaseURI(string _baseURI);
    event UpdateSaleState(string _sale);
    event Mint(address _minter, uint256 _amount, string _type);

    /*//////////////////////////////////////
                CONSTRUCTOR
    //////////////////////////////////////*/
    constructor(uint256 collectionSize_) ERC721B("CycloTurtles", "TURTLES") {
        collectionSize = collectionSize_;
    }

    /*//////////////////////////////////////
                MODIFIERS
    //////////////////////////////////////*/
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Caller is another contract");
        _;
    }

    /*//////////////////////////////////////
                MINTING FUNCTIONS
    //////////////////////////////////////*/

    // Airdrop
    function airdrop(address[] memory to, uint[] memory quantity)
        external
        onlyOwner
    {
        if (to.length != quantity.length) revert NonEqualArrays();
        
        uint sum = 0;
        for (uint i; i < quantity.length; i++) {
            sum += quantity[i];
        }

        if (totalSupply() + sum > collectionSize) revert ExceededMaxSupply();

        _airdrop(to, quantity);
    }
    
    // Dev Mint
    function devMint(address _address, uint256 _amount)
        external
        onlyOwner
    {
        if (_address == address(0)) revert ZeroAddress();
        if (totalSupply() + _amount > collectionSize) revert ExceededMaxSupply();

        _safeMint(_address, _amount);
        devMintCount += _amount;
        emit Mint(_address, _amount, "Dev");
    }

    // Presale Mint
    function presaleMint (uint256 _amount)
        external
        payable
        callerIsUser
    {
        if (mintStatus != MintStatus.PRESALE) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (totalSupply() + _amount > collectionSize) revert ExceededMaxSupply();
        if (msg.value == presalePrice * _amount) revert ValueTooLow();

        _safeMint(msg.sender, _amount);
        emit Mint(msg.sender, _amount, "Presale");
    }

    // Sale Mint
    function saleMint(uint256 _amount)
        external
        payable
        callerIsUser
    {
        if (mintStatus != MintStatus.PUBLIC) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (totalSupply() + _amount > collectionSize) revert ExceededMaxSupply();
        if (msg.value == salePrice * _amount) revert ValueTooLow();

        _safeMint(msg.sender, _amount);
        emit Mint(msg.sender, _amount, "Public Sale");

        if(totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
        }
    }
    
    /*//////////////////////////////////////
                SETTERS
    //////////////////////////////////////*/
    function setUnrevealedURI(string calldata _unrevealedURI)
        external
        onlyOwner
    {
        unrevealedURI = _unrevealedURI;
    }

    function setBaseURI(string calldata _tokenBaseURI)
        external
        onlyOwner
    {
        baseURI = _tokenBaseURI;
        emit ChangeBaseURI(_tokenBaseURI);
    }

    function setPresalePrice(uint256 _price)
        external
        onlyOwner
    {
        presalePrice = _price;
    }

    function setPublicPrice(uint256 _price)
        external
        onlyOwner
    {
        salePrice = _price;
    }

    function setCollectionSize(uint256 _size)
        external
        onlyOwner
    {
        if (_size < totalSupply()) revert ExceededMaxSupply();
        if (_size > 8888) revert ExceededMaxSupply();

        collectionSize = _size;
    }

    /*//////////////////////////////////////
                GETTERS
    //////////////////////////////////////*/
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");
        
        if (revealed == false) {
            return unrevealedURI;
        } else {
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
        }
    }

    function getMintStatus()
        external
        view
        returns(string memory)
    {
        if (mintStatus == MintStatus.CLOSED) {
            return "Closed";
        } else if (mintStatus == MintStatus.PRESALE){
            return "Presale";
        } else if (mintStatus == MintStatus.PUBLIC) {
            return "Public Sale";
        } else { //workflow == WorkflowStatus.SoldOut
            return "Sold Out";
        }
    }

    /*//////////////////////////////////////
                MISC
    //////////////////////////////////////*/
    function reveal(bool _revealed) external onlyOwner {
        revealed = _revealed;
    }

    function closeSale() external onlyOwner {
        if (totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
            emit UpdateSaleState("Sold Out");
        } else {
            mintStatus = MintStatus.CLOSED;
            emit UpdateSaleState("Closed");
        }
    }

    function startPresale() external onlyOwner {
        mintStatus = MintStatus.PRESALE;
        emit UpdateSaleState("Presale");
    }

    function startPublicSale() external onlyOwner {
        mintStatus = MintStatus.PUBLIC;
        emit UpdateSaleState("Public");
    }

    function withdrawl() external onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}