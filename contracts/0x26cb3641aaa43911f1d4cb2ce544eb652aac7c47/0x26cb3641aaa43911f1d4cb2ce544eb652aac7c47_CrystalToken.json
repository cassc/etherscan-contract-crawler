{"SourceCode": "pragma solidity ^0.4.19;\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic\r\n{\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address who) public constant returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic\r\n{\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// Contract Ownable (defines a contract with an owner)\r\n//------------------------------------------------------------------------------------------------------------\r\ncontract Ownable\r\n{\r\n    /**\r\n    * @dev Address of the current owner\r\n    */\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Constructor. Set the original `owner` of the contract to the sender account.\r\n    function Ownable() public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /** Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public\r\n    {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n// ------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath\r\n{\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract SafeBasicToken is ERC20Basic\r\n{\r\n    // Use safemath for math operations\r\n    using SafeMath for uint256;\r\n\r\n    // Maps each address to its current balance\r\n    mapping(address => uint256) balances;\r\n\r\n    // List of admins that can transfer tokens also during the ICO\r\n    mapping(address => bool) public admin;\r\n\r\n    // List of addresses that can receive tokens also during the ICO\r\n    mapping(address => bool) public receivable;\r\n\r\n    // Specifies whether the tokens are locked(ICO is running) - Tokens cannot be transferred during the ICO\r\n    bool public locked;\r\n\r\n\r\n    // Checks the size of the message to avoid attacks\r\n    modifier onlyPayloadSize(uint size)\r\n    {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /** Transfer tokens to the specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(!locked || admin[msg.sender] == true || receivable[_to] == true);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Get the balance of the specified address.\r\n    * @param _owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\n/** @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract SafeStandardToken is ERC20, SafeBasicToken\r\n{\r\n    /** Map address => (address => value)\r\n    *   allowed[_owner][_spender] represents the amount of tokens the _spender can use on behalf of the _owner\r\n    */\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n\r\n    /** Return the allowance of the _spender on behalf of the _owner\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will be allowed to spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /** Allow the _spender to spend _value tokens on behalf of msg.sender.\r\n     * To avoid race condition, the current allowed amount must be first set to 0 through a different transaction.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool)\r\n    {\r\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Increase the allowance for _spender by _addedValue (to be use when allowed[_spender] > 0)\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Decrease the allowance for _spender by _subtractedValue. Set it to 0 if _subtractedValue is less then the current allowance\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n\r\n        if (_subtractedValue > oldValue)\r\n            allowed[msg.sender][_spender] = 0;\r\n        else\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /** Transfer tokens on behalf of _from to _to (if allowed)\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n// Main contract\r\ncontract CrystalToken is SafeStandardToken, Ownable\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"CrystalToken\";\r\n    string public constant symbol = \"CYL\";\r\n    uint256 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 28000000 * (10 ** uint256(decimals));\r\n\r\n    // Struct representing information of a single round\r\n    struct Round\r\n    {\r\n        uint256 startTime;                      // Timestamp of the start of the round\r\n        uint256 endTime;                        // Timestamp of the end of the round\r\n        uint256 availableTokens;                // Number of tokens available in this round\r\n        uint256 maxPerUser;                     // Number of maximum tokens per user\r\n        uint256 rate;                           // Number of token per wei in this round\r\n        mapping(address => uint256) balances;   // Balances of the users in this round\r\n    }\r\n\r\n    // Array containing information of all the rounds\r\n    Round[5] rounds;\r\n\r\n    // Address where funds are collected\r\n    address public wallet;\r\n\r\n    // Amount of collected money in wei\r\n    uint256 public weiRaised;\r\n\r\n    // Current round index\r\n    uint256 public runningRound;\r\n\r\n    // Constructor\r\n    function CrystalToken(address _walletAddress) public\r\n    {\r\n        wallet = _walletAddress;\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n\r\n        rounds[0] = Round(1519052400, 1519138800,  250000 * (10 ** 18), 200 * (10 ** 18), 2000);    // 19 Feb 2018 - 15.00 GMT\r\n        rounds[1] = Round(1519398000, 1519484400, 1250000 * (10 ** 18), 400 * (10 ** 18), 1333);    // 23 Feb 2018 - 15.00 GMT\r\n        rounds[2] = Round(1519657200, 1519743600, 1500000 * (10 ** 18), 1000 * (10 ** 18), 1000);   // 26 Feb 2018 - 15.00 GMT\r\n        rounds[3] = Round(1519830000, 1519916400, 2000000 * (10 ** 18), 1000 * (10 ** 18), 800);    // 28 Feb 2018 - 15.00 GMT\r\n        rounds[4] = Round(1520262000, 1520348400, 2000000 * (10 ** 18), 2000 * (10 ** 18), 667);    //  5 Mar 2018 - 15.00 GMT\r\n\r\n        // Set the owner as an admin\r\n        admin[msg.sender] = true;\r\n\r\n        // Lock the tokens for the ICO\r\n        locked = true;\r\n\r\n        // Set the current round to 100 (no round)\r\n        runningRound = uint256(0);\r\n    }\r\n\r\n\r\n    /** Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n    // Rate change event\r\n    event RateChanged(address indexed owner, uint round, uint256 old_rate, uint256 new_rate);\r\n\r\n\r\n    // Fallback function, used to buy token\r\n    // If ETH are sent to the contract address, without any additional data, this function is called\r\n    function() public payable\r\n    {\r\n        // Take the address of the buyer\r\n        address beneficiary = msg.sender;\r\n\r\n        // Check that the sender is not the 0 address\r\n        require(beneficiary != 0x0);\r\n\r\n        // Check that sent ETH in wei is > 0\r\n        uint256 weiAmount = msg.value;\r\n        require(weiAmount != 0);\r\n\r\n        // Get the current round (100 if there is no open round)\r\n        uint256 roundIndex = runningRound;\r\n\r\n        // Check if there is a running round\r\n        require(roundIndex != uint256(100));\r\n\r\n        // Get the information of the current round\r\n        Round storage round = rounds[roundIndex];\r\n\r\n        // Calculate the token amount to sell. Exceeding amount will not generate tokens\r\n        uint256 tokens = weiAmount.mul(round.rate);\r\n        uint256 maxPerUser = round.maxPerUser;\r\n        uint256 remaining = maxPerUser - round.balances[beneficiary];\r\n        if(remaining < tokens)\r\n            tokens = remaining;\r\n\r\n        // Check if the tokens can be sold\r\n        require(areTokensBuyable(roundIndex, tokens));\r\n\r\n        // Reduce the number of available tokens in the round (fails if there are no more available tokens)\r\n        round.availableTokens = round.availableTokens.sub(tokens);\r\n\r\n        // Add the number of tokens to the current user's balance of this round\r\n        round.balances[msg.sender] = round.balances[msg.sender].add(tokens);\r\n\r\n        // Transfer the amount of token to the buyer\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        balances[beneficiary] = balances[beneficiary].add(tokens);\r\n        Transfer(owner, beneficiary, tokens);\r\n\r\n        // Raise the event of token purchase\r\n        TokenPurchase(beneficiary, beneficiary, weiAmount, tokens);\r\n\r\n        // Update the number of collected money\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        // Transfer funds to the wallet\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n\r\n    /** Check if there is an open round and if there are enough tokens available for current phase and for the sender\r\n    * @param _roundIndex index of the current round\r\n    * @param _tokens number of requested tokens\r\n    */\r\n    function areTokensBuyable(uint _roundIndex, uint256 _tokens) internal constant returns (bool)\r\n    {\r\n        uint256 current_time = block.timestamp;\r\n        Round storage round = rounds[_roundIndex];\r\n\r\n        return (\r\n        _tokens > 0 &&                                              // Check that the user can still buy tokens\r\n        round.availableTokens >= _tokens &&                         // Check that there are still available tokens\r\n        current_time >= round.startTime &&                          // Check that the current timestamp is after the start of the round\r\n        current_time <= round.endTime                               // Check that the current timestamp is before the end of the round\r\n        );\r\n    }\r\n\r\n\r\n\r\n    // Return the current number of unsold tokens\r\n    function tokenBalance() constant public returns (uint256)\r\n    {\r\n        return balanceOf(owner);\r\n    }\r\n\r\n\r\n    event Burn(address burner, uint256 value);\r\n\r\n\r\n    /** Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public onlyOwner\r\n    {\r\n        require(_value <= balances[msg.sender]);\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n\r\n\r\n\r\n    /** Mint a specific amount of tokens.\r\n   * @param _value The amount of token to be minted.\r\n   */\r\n    function mint(uint256 _value) public onlyOwner\r\n    {\r\n        totalSupply = totalSupply.add(_value);\r\n        balances[msg.sender] = balances[msg.sender].add(_value);\r\n    }\r\n\r\n\r\n\r\n    // Functions to set the features of each round (only for the owner) and of the whole ICO\r\n    // ----------------------------------------------------------------------------------------\r\n    function setTokensLocked(bool _value) onlyOwner public\r\n    {\r\n        locked = _value;\r\n    }\r\n\r\n    /** Set the current round index\r\n    * @param _roundIndex the new round index to set\r\n    */\r\n    function setRound(uint256 _roundIndex) public onlyOwner\r\n    {\r\n        runningRound = _roundIndex;\r\n    }\r\n\r\n    function setAdmin(address _addr, bool _value) onlyOwner public\r\n    {\r\n        admin[_addr] = _value;\r\n    }\r\n\r\n    function setReceivable(address _addr, bool _value) onlyOwner public\r\n    {\r\n        receivable[_addr] = _value;\r\n    }\r\n\r\n    function setRoundStart(uint _round, uint256 _value) onlyOwner public\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        rounds[_round].startTime = _value;\r\n    }\r\n\r\n    function setRoundEnd(uint _round, uint256 _value) onlyOwner public\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        rounds[_round].endTime = _value;\r\n    }\r\n\r\n    function setRoundAvailableToken(uint _round, uint256 _value) onlyOwner public\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        rounds[_round].availableTokens = _value;\r\n    }\r\n\r\n    function setRoundMaxPerUser(uint _round, uint256 _value) onlyOwner public\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        rounds[_round].maxPerUser = _value;\r\n    }\r\n\r\n    function setRoundRate(uint _round, uint256 _round_usd_cents, uint256 _ethvalue_usd) onlyOwner public\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        uint256 rate = _ethvalue_usd * 100 / _round_usd_cents;\r\n        uint256 oldRate = rounds[_round].rate;\r\n        rounds[_round].rate = rate;\r\n        RateChanged(msg.sender, _round, oldRate, rounds[_round].rate);\r\n    }\r\n    // ----------------------------------------------------------------------------------------\r\n\r\n\r\n    // Functions to get the features of each round\r\n    // ----------------------------------------------------------------------------------------\r\n    function getRoundUserBalance(uint _round, address _user) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].balances[_user];\r\n    }\r\n\r\n    function getRoundStart(uint _round) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].startTime;\r\n    }\r\n\r\n    function getRoundEnd(uint _round) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].endTime;\r\n    }\r\n\r\n    function getRoundAvailableToken(uint _round) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].availableTokens;\r\n    }\r\n\r\n    function getRoundMaxPerUser(uint _round) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].maxPerUser;\r\n    }\r\n\r\n    function getRoundRate(uint _round) public constant returns (uint256)\r\n    {\r\n        require(_round >= 0 && _round < rounds.length);\r\n        return rounds[_round].rate;\r\n    }\r\n    // ----------------------------------------------------------------------------------------\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setReceivable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setTokensLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_round_usd_cents\",\"type\":\"uint256\"},{\"name\":\"_ethvalue_usd\",\"type\":\"uint256\"}],\"name\":\"setRoundRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRoundMaxPerUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRoundEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundMaxPerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundIndex\",\"type\":\"uint256\"}],\"name\":\"setRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundAvailableToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRoundUserBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRoundStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"runningRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"receivable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRoundAvailableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"old_rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_rate\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "CrystalToken", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000024cf63494b22472d864c827258e30d722c53c97a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://8041e3b325e0b9242246162f6d35f4330a3f844d0818f999e6adcd2bef362601"}