{"SourceCode": "// File: contracts/XVersion.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract XVersion {\r\n    function getVersion() external view returns (bytes32);\r\n}\r\n\r\ncontract XApollo is XVersion {\r\n    function getVersion() external view returns (bytes32) {\r\n        return bytes32(\"APOLLO\");\r\n    }\r\n}\r\n\r\n// File: contracts/XConst.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract XConst {\r\n    uint256 public constant BONE = 10**18;\r\n\r\n    uint256 public constant MIN_BOUND_TOKENS = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n    uint256 public constant EXIT_ZERO_FEE = 0;\r\n\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n\r\n    // min effective value: 0.000001 TOKEN\r\n    uint256 public constant MIN_BALANCE = 10**6;\r\n\r\n    // BONE/(10**10) XPT\r\n    uint256 public constant MIN_POOL_AMOUNT = 10**8;\r\n\r\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\r\n\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n}\r\n\r\n// File: contracts/lib/XNum.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\nlibrary XNum {\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n}\r\n\r\n// File: contracts/XPToken.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n// Highly opinionated token implementation\r\ncontract XTokenBase {\r\n    using XNum for uint256;\r\n\r\n    mapping(address => uint256) internal _balance;\r\n    mapping(address => mapping(address => uint256)) internal _allowance;\r\n    uint256 internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function _mint(uint256 amt) internal {\r\n        _balance[address(this)] = (_balance[address(this)]).badd(amt);\r\n        _totalSupply = _totalSupply.badd(amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint256 amt) internal {\r\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[address(this)] = (_balance[address(this)]).bsub(amt);\r\n        _totalSupply = _totalSupply.bsub(amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) internal {\r\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[src] = (_balance[src]).bsub(amt);\r\n        _balance[dst] = (_balance[dst]).badd(amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n}\r\n\r\ncontract XPToken is XTokenBase, IERC20, XApollo {\r\n    using XNum for uint256;\r\n\r\n    string private constant _name = \"XDeFi Pool Token\";\r\n    string private constant _symbol = \"XPT\";\r\n    uint8 private constant _decimals = 18;\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view returns (uint256) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool) {\r\n        require(\r\n            msg.sender == src || amt <= _allowance[src][msg.sender],\r\n            \"ERR_BTOKEN_BAD_CALLER\"\r\n        );\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = (_allowance[src][msg.sender]).bsub(\r\n                amt\r\n            );\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/XMath.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\nlibrary XMath {\r\n    using XNum for uint256;\r\n\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant EXIT_ZERO_FEE = 0;\r\n\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 spotPrice) {\r\n        uint256 numer = tokenBalanceIn.bdiv(tokenWeightIn);\r\n        uint256 denom = tokenBalanceOut.bdiv(tokenWeightOut);\r\n        uint256 ratio = numer.bdiv(denom);\r\n        uint256 scale = BONE.bdiv(BONE.bsub(swapFee));\r\n        return (spotPrice = ratio.bmul(scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 weightRatio;\r\n        if (tokenWeightIn == tokenWeightOut) {\r\n            weightRatio = 1 * BONE;\r\n        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\r\n            weightRatio = 2 * BONE;\r\n        } else {\r\n            weightRatio = tokenWeightIn.bdiv(tokenWeightOut);\r\n        }\r\n        uint256 adjustedIn = BONE.bsub(swapFee);\r\n        adjustedIn = tokenAmountIn.bmul(adjustedIn);\r\n        uint256 y = tokenBalanceIn.bdiv(tokenBalanceIn.badd(adjustedIn));\r\n        uint256 foo;\r\n        if (tokenWeightIn == tokenWeightOut) {\r\n            foo = y;\r\n        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\r\n            foo = y.bmul(y);\r\n        } else {\r\n            foo = y.bpow(weightRatio);\r\n        }\r\n        uint256 bar = BONE.bsub(foo);\r\n        tokenAmountOut = tokenBalanceOut.bmul(bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 weightRatio;\r\n        if (tokenWeightOut == tokenWeightIn) {\r\n            weightRatio = 1 * BONE;\r\n        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\r\n            weightRatio = 2 * BONE;\r\n        } else {\r\n            weightRatio = tokenWeightOut.bdiv(tokenWeightIn);\r\n        }\r\n        uint256 diff = tokenBalanceOut.bsub(tokenAmountOut);\r\n        uint256 y = tokenBalanceOut.bdiv(diff);\r\n        uint256 foo;\r\n        if (tokenWeightOut == tokenWeightIn) {\r\n            foo = y;\r\n        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\r\n            foo = y.bmul(y);\r\n        } else {\r\n            foo = y.bpow(weightRatio);\r\n        }\r\n        foo = foo.bsub(BONE);\r\n        tokenAmountIn = BONE.bsub(swapFee);\r\n        tokenAmountIn = tokenBalanceIn.bmul(foo).bdiv(tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountOut) {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        ///  which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint256 normalizedWeight = tokenWeightIn.bdiv(totalWeight);\r\n        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\r\n        uint256 tokenAmountInAfterFee = tokenAmountIn.bmul(BONE.bsub(zaz));\r\n\r\n        uint256 newTokenBalanceIn = tokenBalanceIn.badd(tokenAmountInAfterFee);\r\n        uint256 tokenInRatio = newTokenBalanceIn.bdiv(tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint256 poolRatio = tokenInRatio.bpow(normalizedWeight);\r\n        uint256 newPoolSupply = poolRatio.bmul(poolSupply);\r\n        poolAmountOut = newPoolSupply.bsub(poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 normalizedWeight = tokenWeightOut.bdiv(totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint256 poolAmountInAfterExitFee =\r\n            poolAmountIn.bmul(BONE.bsub(EXIT_ZERO_FEE));\r\n        uint256 newPoolSupply = poolSupply.bsub(poolAmountInAfterExitFee);\r\n        uint256 poolRatio = newPoolSupply.bdiv(poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint256 tokenOutRatio = poolRatio.bpow(BONE.bdiv(normalizedWeight));\r\n        uint256 newTokenBalanceOut = tokenOutRatio.bmul(tokenBalanceOut);\r\n\r\n        uint256 tokenAmountOutBeforeSwapFee =\r\n            tokenBalanceOut.bsub(newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\r\n        tokenAmountOut = tokenAmountOutBeforeSwapFee.bmul(BONE.bsub(zaz));\r\n        return tokenAmountOut;\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IXConfig.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IXConfig {\r\n    function getCore() external view returns (address);\r\n\r\n    function getSAFU() external view returns (address);\r\n\r\n    function getMaxExitFee() external view returns (uint256);\r\n\r\n    function getSafuFee() external view returns (uint256);\r\n\r\n    function getSwapProxy() external view returns (address);\r\n\r\n    function dedupPool(address[] calldata tokens, uint256[] calldata denorms)\r\n        external\r\n        returns (bool exist, bytes32 sig);\r\n\r\n    function addPoolSig(bytes32 sig, address pool) external;\r\n}\r\n\r\n// File: contracts/XPool.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract XPool is XApollo, XPToken, XConst {\r\n    using XNum for uint256;\r\n\r\n    //Swap Fees: 0.1%, 0.25%, 1%, 2.5%, 10%\r\n    uint256[5] public SWAP_FEES = [\r\n        BONE / 1000,\r\n        (25 * BONE) / 10000,\r\n        BONE / 100,\r\n        (25 * BONE) / 1000,\r\n        BONE / 10\r\n    ];\r\n\r\n    struct Record {\r\n        bool bound; // is token bound to pool\r\n        uint256 index; // private\r\n        uint256 denorm; // denormalized weight\r\n        uint256 balance;\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_REFER(\r\n        address indexed caller,\r\n        address indexed ref,\r\n        address indexed tokenIn,\r\n        uint256 fee\r\n    );\r\n\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256 tokenAmountIn\r\n    );\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_BIND(\r\n        address indexed caller,\r\n        address indexed token,\r\n        uint256 denorm,\r\n        uint256 balance\r\n    );\r\n\r\n    event LOG_UPDATE_SAFU(address indexed safu, uint256 fee);\r\n\r\n    event LOG_EXIT_FEE(uint256 fee);\r\n\r\n    event LOG_FINAL(uint256 swapFee);\r\n\r\n    event SET_CONTROLLER(address indexed manager);\r\n\r\n    event UPDATE_FARM(address indexed caller, bool isFarm);\r\n\r\n    // anonymous event\r\n    event LOG_CALL(\r\n        bytes4 indexed sig,\r\n        address indexed caller,\r\n        bytes data\r\n    ) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    address public controller; // has CONTROL role\r\n\r\n    // `finalize` require CONTROL, `finalize` sets `can SWAP and can JOIN`\r\n    bool public finalized;\r\n\r\n    uint256 public swapFee;\r\n    uint256 public exitFee;\r\n\r\n    // Pool Governance\r\n    address public SAFU;\r\n    uint256 public safuFee;\r\n    bool public isFarmPool;\r\n\r\n    address[] internal _tokens;\r\n    mapping(address => Record) internal _records;\r\n    uint256 private _totalWeight;\r\n\r\n    IXConfig public xconfig;\r\n    address public origin;\r\n\r\n    constructor(address _xconfig, address _controller) public {\r\n        controller = _controller;\r\n        origin = tx.origin;\r\n        swapFee = SWAP_FEES[1];\r\n        exitFee = EXIT_ZERO_FEE;\r\n        finalized = false;\r\n        xconfig = IXConfig(_xconfig);\r\n        SAFU = xconfig.getSAFU();\r\n        safuFee = xconfig.getSafuFee();\r\n    }\r\n\r\n    function isBound(address t) external view returns (bool) {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getNumTokens() external view returns (uint256) {\r\n        return _tokens.length;\r\n    }\r\n\r\n    function getFinalTokens()\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (address[] memory tokens)\r\n    {\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256)\r\n    {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    function getTotalDenormalizedWeight()\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256)\r\n    {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256)\r\n    {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        uint256 denorm = _records[token].denorm;\r\n        return denorm.bdiv(_totalWeight);\r\n    }\r\n\r\n    function getBalance(address token)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256)\r\n    {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function setController(address manager) external _logs_ {\r\n        require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\r\n        require(manager != address(0), \"ERR_ZERO_ADDR\");\r\n        controller = manager;\r\n        emit SET_CONTROLLER(manager);\r\n    }\r\n\r\n    function setExitFee(uint256 fee) external {\r\n        require(!finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\r\n        require(fee <= xconfig.getMaxExitFee(), \"INVALID_EXIT_FEE\");\r\n        exitFee = fee;\r\n        emit LOG_EXIT_FEE(fee);\r\n    }\r\n\r\n    // allow SAFU address and SAFE FEE be updated by xconfig\r\n    function updateSafu(address safu, uint256 fee) external {\r\n        require(msg.sender == address(xconfig), \"ERR_NOT_CONFIG\");\r\n        require(safu != address(0), \"ERR_ZERO_ADDR\");\r\n        SAFU = safu;\r\n        safuFee = fee;\r\n\r\n        emit LOG_UPDATE_SAFU(safu, fee);\r\n    }\r\n\r\n    // allow isFarmPool be updated by xconfig\r\n    function updateFarm(bool isFarm) external {\r\n        require(msg.sender == address(xconfig), \"ERR_NOT_CONFIG\");\r\n        isFarmPool = isFarm;\r\n        emit UPDATE_FARM(msg.sender, isFarm);\r\n    }\r\n\r\n    function bind(address token, uint256 denorm) external _lock_ {\r\n        require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\r\n        require(!finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n\r\n        uint256 decimal = 10**uint256(IERC20(token).decimals());\r\n        require(decimal >= 10**6, \"ERR_TOO_SMALL\");\r\n\r\n        // 0.000001 TOKEN\r\n        require(balance >= decimal / MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n        _totalWeight = _totalWeight.badd(denorm);\r\n        require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n\r\n        _records[token] = Record({\r\n            bound: true,\r\n            index: _tokens.length,\r\n            denorm: denorm,\r\n            balance: balance\r\n        });\r\n        _tokens.push(token);\r\n\r\n        emit LOG_BIND(msg.sender, token, denorm, balance);\r\n    }\r\n\r\n    // _swapFee must be one of SWAP_FEES\r\n    function finalize(uint256 _swapFee) external _lock_ {\r\n        require(msg.sender == controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!finalized, \"ERR_IS_FINALIZED\");\r\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n        require(_tokens.length <= MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        require(_swapFee >= SWAP_FEES[0], \"ERR_MIN_FEE\");\r\n        require(_swapFee <= SWAP_FEES[SWAP_FEES.length - 1], \"ERR_MAX_FEE\");\r\n\r\n        bool found = false;\r\n        for (uint256 i = 0; i < SWAP_FEES.length; i++) {\r\n            if (_swapFee == SWAP_FEES[i]) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        require(found, \"ERR_INVALID_SWAP_FEE\");\r\n        swapFee = _swapFee;\r\n\r\n        finalized = true;\r\n\r\n        _mintPoolShare(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\r\n\r\n        emit LOG_FINAL(swapFee);\r\n    }\r\n\r\n    // Absorb any tokens that have been sent to this contract into the pool\r\n    function gulp(address token) external _logs_ _lock_ {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        _records[token].balance = IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256 spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return\r\n            XMath.calcSpotPrice(\r\n                inRecord.balance,\r\n                inRecord.denorm,\r\n                outRecord.balance,\r\n                outRecord.denorm,\r\n                swapFee\r\n            );\r\n    }\r\n\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256 spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return\r\n            XMath.calcSpotPrice(\r\n                inRecord.balance,\r\n                inRecord.denorm,\r\n                outRecord.balance,\r\n                outRecord.denorm,\r\n                0\r\n            );\r\n    }\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n        external\r\n        _lock_\r\n    {\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n        require(maxAmountsIn.length == _tokens.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 ratio = poolAmountOut.bdiv(poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountIn = ratio.bmul(bal);\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n            _records[t].balance = (_records[t].balance).badd(tokenAmountIn);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external\r\n        _lock_\r\n    {\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n        require(minAmountsOut.length == _tokens.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        // min pool amount\r\n        require(poolAmountIn >= MIN_POOL_AMOUNT, \"ERR_MIN_AMOUNT\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 _exitFee = poolAmountIn.bmul(exitFee);\r\n\r\n        // never charge exitFee to pool origin\r\n        if (msg.sender == origin) {\r\n            _exitFee = 0;\r\n        }\r\n        uint256 pAiAfterExitFee = poolAmountIn.bsub(_exitFee);\r\n        uint256 ratio = pAiAfterExitFee.bdiv(poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        // send exitFee to origin\r\n        if (_exitFee > 0) {\r\n            _pushPoolShare(origin, _exitFee);\r\n        }\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = ratio.bmul(bal);\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n            _records[t].balance = (_records[t].balance).bsub(tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\r\n        return\r\n            swapExactAmountInRefer(\r\n                tokenIn,\r\n                tokenAmountIn,\r\n                tokenOut,\r\n                minAmountOut,\r\n                maxPrice,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function swapExactAmountInRefer(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) public _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(\r\n            tokenAmountIn <= (inRecord.balance).bmul(MAX_IN_RATIO),\r\n            \"ERR_MAX_IN_RATIO\"\r\n        );\r\n\r\n        uint256 spotPriceBefore =\r\n            XMath.calcSpotPrice(\r\n                inRecord.balance,\r\n                inRecord.denorm,\r\n                outRecord.balance,\r\n                outRecord.denorm,\r\n                swapFee\r\n            );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountOut = calcOutGivenIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountIn,\r\n            swapFee\r\n        );\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(\r\n            spotPriceBefore <= tokenAmountIn.bdiv(tokenAmountOut),\r\n            \"ERR_MATH_APPROX\"\r\n        );\r\n\r\n        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\r\n        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\r\n\r\n        spotPriceAfter = XMath.calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n\r\n        emit LOG_SWAP(\r\n            msg.sender,\r\n            tokenIn,\r\n            tokenOut,\r\n            tokenAmountIn,\r\n            tokenAmountOut\r\n        );\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        uint256 _swapFee = tokenAmountIn.bmul(swapFee);\r\n\r\n        // to referral\r\n        uint256 _referFee = 0;\r\n        if (\r\n            referrer != address(0) &&\r\n            referrer != msg.sender &&\r\n            referrer != tx.origin\r\n        ) {\r\n            _referFee = _swapFee / 5; // 20% to referrer\r\n            _pushUnderlying(tokenIn, referrer, _referFee);\r\n            inRecord.balance = (inRecord.balance).bsub(_referFee);\r\n            emit LOG_REFER(msg.sender, referrer, tokenIn, _referFee);\r\n        }\r\n\r\n        // to SAFU\r\n        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\r\n        if (isFarmPool) {\r\n            _safuFee = _swapFee.bsub(_referFee);\r\n        }\r\n        require(_safuFee.badd(_referFee) <= _swapFee, \"ERR_FEE_LIMIT\");\r\n        _pushUnderlying(tokenIn, SAFU, _safuFee);\r\n        inRecord.balance = (inRecord.balance).bsub(_safuFee);\r\n\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\r\n        return\r\n            swapExactAmountOutRefer(\r\n                tokenIn,\r\n                maxAmountIn,\r\n                tokenOut,\r\n                tokenAmountOut,\r\n                maxPrice,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function swapExactAmountOutRefer(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) public _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(\r\n            tokenAmountOut <= (outRecord.balance).bmul(MAX_OUT_RATIO),\r\n            \"ERR_MAX_OUT_RATIO\"\r\n        );\r\n\r\n        uint256 spotPriceBefore =\r\n            XMath.calcSpotPrice(\r\n                inRecord.balance,\r\n                inRecord.denorm,\r\n                outRecord.balance,\r\n                outRecord.denorm,\r\n                swapFee\r\n            );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountIn = calcInGivenOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountOut,\r\n            swapFee\r\n        );\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n        require(\r\n            spotPriceBefore <= tokenAmountIn.bdiv(tokenAmountOut),\r\n            \"ERR_MATH_APPROX\"\r\n        );\r\n\r\n        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\r\n        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\r\n\r\n        spotPriceAfter = XMath.calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n\r\n        emit LOG_SWAP(\r\n            msg.sender,\r\n            tokenIn,\r\n            tokenOut,\r\n            tokenAmountIn,\r\n            tokenAmountOut\r\n        );\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        uint256 _swapFee = tokenAmountIn.bmul(swapFee);\r\n        // to referral\r\n        uint256 _referFee = 0;\r\n        if (\r\n            referrer != address(0) &&\r\n            referrer != msg.sender &&\r\n            referrer != tx.origin\r\n        ) {\r\n            _referFee = _swapFee / 5; // 20% to referrer\r\n            _pushUnderlying(tokenIn, referrer, _referFee);\r\n            inRecord.balance = (inRecord.balance).bsub(_referFee);\r\n            emit LOG_REFER(msg.sender, referrer, tokenIn, _referFee);\r\n        }\r\n\r\n        // to SAFU\r\n        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\r\n        if (isFarmPool) {\r\n            _safuFee = _swapFee.bsub(_referFee);\r\n        }\r\n        require(_safuFee.badd(_referFee) <= _swapFee, \"ERR_FEE_LIMIT\");\r\n        _pushUnderlying(tokenIn, SAFU, _safuFee);\r\n        inRecord.balance = (inRecord.balance).bsub(_safuFee);\r\n\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n        return (tokenAmountIn, spotPriceAfter);\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external _lock_ returns (uint256 poolAmountOut) {\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(\r\n            tokenAmountIn <= (_records[tokenIn].balance).bmul(MAX_IN_RATIO),\r\n            \"ERR_MAX_IN_RATIO\"\r\n        );\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        // to SAFU\r\n        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\r\n        if (isFarmPool) {\r\n            _safuFee = tokenAmountIn.bmul(swapFee);\r\n        }\r\n        tokenAmountIn = tokenAmountIn.bsub(_safuFee);\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n        poolAmountOut = XMath.calcPoolOutGivenSingleIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountIn,\r\n            swapFee\r\n        );\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\r\n\r\n        _pushUnderlying(tokenIn, SAFU, _safuFee);\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\r\n        require(finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(poolAmountIn >= MIN_POOL_AMOUNT, \"ERR_MIN_AMOUNT\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n\r\n        // exit fee to origin\r\n        if (exitFee > 0 && msg.sender != origin) {\r\n            uint256 _exitFee = poolAmountIn.bmul(exitFee);\r\n            _pushPoolShare(origin, _exitFee);\r\n            poolAmountIn = poolAmountIn.bsub(_exitFee);\r\n        }\r\n\r\n        _burnPoolShare(poolAmountIn);\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n        tokenAmountOut = XMath.calcSingleOutGivenPoolIn(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountIn,\r\n            swapFee\r\n        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(\r\n            tokenAmountOut <= (_records[tokenOut].balance).bmul(MAX_OUT_RATIO),\r\n            \"ERR_MAX_OUT_RATIO\"\r\n        );\r\n\r\n        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\r\n\r\n        // to SAFU\r\n        uint256 _safuFee = tokenAmountOut.bmul(safuFee);\r\n        if (isFarmPool) {\r\n            _safuFee = tokenAmountOut.bmul(swapFee);\r\n        }\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n        _pushUnderlying(tokenOut, SAFU, _safuFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut.bsub(_safuFee));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 _swapFee\r\n    ) public pure returns (uint256) {\r\n        return\r\n            XMath.calcOutGivenIn(\r\n                tokenBalanceIn,\r\n                tokenWeightIn,\r\n                tokenBalanceOut,\r\n                tokenWeightOut,\r\n                tokenAmountIn,\r\n                _swapFee\r\n            );\r\n    }\r\n\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 _swapFee\r\n    ) public pure returns (uint256) {\r\n        return\r\n            XMath.calcInGivenOut(\r\n                tokenBalanceIn,\r\n                tokenWeightIn,\r\n                tokenBalanceOut,\r\n                tokenWeightOut,\r\n                tokenAmountOut,\r\n                _swapFee\r\n            );\r\n    }\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n    // Fixed ERC-20 transfer revert for some special token such as USDT\r\n    function _pullUnderlying(\r\n        address erc20,\r\n        address from,\r\n        uint256 amount\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) =\r\n            erc20.call(\r\n                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\r\n            );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"ERC20_TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    function _pushUnderlying(\r\n        address erc20,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) =\r\n            erc20.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"ERC20_TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount) internal {\r\n        _move(from, address(this), amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _move(address(this), to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount) internal {\r\n        _burn(amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xconfig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LOG_BIND\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT_FEE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"LOG_FINAL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LOG_REFER\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safu\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LOG_UPDATE_SAFU\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SET_CONTROLLER\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFarm\",\"type\":\"bool\"}],\"name\":\"UPDATE_FARM\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXIT_ZERO_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_POOL_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFU\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SWAP_FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFarmPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safuFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setExitFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"swapExactAmountInRefer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"swapExactAmountOutRefer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isFarm\",\"type\":\"bool\"}],\"name\":\"updateFarm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"safu\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"updateSafu\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xconfig\",\"outputs\":[{\"internalType\":\"contract IXConfig\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XPool", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb2978a5dc9f6b68295e93d53a74ea2cf66265dc00000000000000000000000082484b7e77e4b80de6d78bdf9014e44cc715f66a", "EVMVersion": "istanbul", "Library": "XMath:4f8d1c6dabbb379134272cb1273638cc98212a44", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e4bc0b79265b34f3071fc12ee0e04d56963a3285dc6081942b73e464bfc1c8b0"}