{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Create/contracts/v1/MintPayout.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {Ownable} from \\\"solady/auth/Ownable.sol\\\";\\nimport {IMintPayout} from \\\"create/interfaces/v1/IMintPayout.sol\\\";\\nimport {IMintContract} from \\\"create/interfaces/v1/IMintContract.sol\\\";\\nimport {Version} from \\\"create/contracts/v1/Version.sol\\\";\\nimport {\\n    MINT_REFERRAL_REASON,\\n    PROTOCOL_FEE_REASON,\\n    PURCHASE_AMOUNT_REASON\\n} from \\\"create/interfaces/v1/MintPayoutReasons.sol\\\";\\n\\ncontract MintPayout is IMintPayout, Version, Ownable {\\n    /// @inheritdoc IMintPayout\\n    uint256 public protocolFee;\\n    /// @inheritdoc IMintPayout\\n    address public constant protocolFeeRecipientAccount = address(0x4444444444444444444444444444444444444444);\\n\\n    /// @inheritdoc IMintPayout\\n    mapping(address => uint256) public balanceOf;\\n\\n    error InvalidAddress();\\n    error InvalidArrayLength();\\n    error IncorrectDepositAmount();\\n    error InvalidWithdrawAmount();\\n    error TransferFailed();\\n\\n    constructor() Version(1) {\\n        _initializeOwner(tx.origin);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function totalSupply() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\\n        protocolFee = _protocolFee;\\n        emit ProtocolFeeUpdated(_protocolFee);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function withdrawProtocolFee(address to, uint256 amount) external onlyOwner {\\n        _withdraw(protocolFeeRecipientAccount, to, amount);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function mintDeposit(address mintContract, address minter, address referrer, uint256 quantity) external payable {\\n        if (mintContract == address(0)) revert InvalidAddress();\\n        if (quantity == 0) revert IncorrectDepositAmount();\\n        if (msg.value == 0) revert IncorrectDepositAmount();\\n\\n        uint256 protocolPayout = protocolFee * quantity;\\n        uint256 referralPayout;\\n        if (referrer != address(0)) {\\n            referralPayout = protocolPayout / 2;\\n            protocolPayout = referralPayout;\\n        }\\n\\n        if (msg.value < protocolPayout + referralPayout) revert IncorrectDepositAmount();\\n\\n        uint256 creatorPayout = msg.value - protocolPayout - referralPayout;\\n        address creator;\\n\\n        if (creatorPayout > 0) {\\n            creator = IMintContract(mintContract).payoutRecipient();\\n            if (creator == address(0)) {\\n                creator = protocolFeeRecipientAccount;\\n            }\\n\\n            _deposit(msg.sender, creator, PURCHASE_AMOUNT_REASON, creatorPayout);\\n        }\\n\\n        if (referralPayout > 0) {\\n            _deposit(msg.sender, referrer, MINT_REFERRAL_REASON, referralPayout);\\n        }\\n\\n        if (protocolPayout > 0) {\\n            _deposit(msg.sender, protocolFeeRecipientAccount, PROTOCOL_FEE_REASON, protocolPayout);\\n        }\\n\\n        emit MintDeposit(\\n            msg.sender,\\n            mintContract,\\n            minter,\\n            referrer,\\n            creator,\\n            creatorPayout,\\n            referralPayout,\\n            protocolPayout,\\n            msg.value,\\n            quantity,\\n            protocolFee\\n        );\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function deposit(address to, bytes4 reason) external payable {\\n        if (to == address(0)) revert InvalidAddress();\\n        _deposit(msg.sender, to, reason, msg.value);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, bytes4[] calldata reasons)\\n        external\\n        payable\\n    {\\n        uint256 numRecipients = recipients.length;\\n        if (numRecipients != amounts.length || numRecipients != reasons.length) {\\n            revert InvalidArrayLength();\\n        }\\n\\n        uint256 expectedTotalValue;\\n        for (uint256 i; i < numRecipients;) {\\n            expectedTotalValue += amounts[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (msg.value != expectedTotalValue) revert IncorrectDepositAmount();\\n\\n        address currentRecipient;\\n        uint256 currentAmount;\\n        for (uint256 i; i < numRecipients;) {\\n            currentRecipient = recipients[i];\\n            currentAmount = amounts[i];\\n\\n            if (currentRecipient == address(0)) revert InvalidAddress();\\n\\n            _deposit(msg.sender, currentRecipient, reasons[i], currentAmount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _deposit(address from, address to, bytes4 reason, uint256 amount) internal {\\n        balanceOf[to] += amount;\\n        emit Deposit(from, to, reason, amount);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function withdraw(address to, uint256 amount) external {\\n        _withdraw(msg.sender, to, amount);\\n    }\\n\\n    /// @inheritdoc IMintPayout\\n    function withdrawAll(address to) external {\\n        _withdraw(msg.sender, to, balanceOf[msg.sender]);\\n    }\\n\\n    function _withdraw(address from, address to, uint256 amount) internal {\\n        if (to == address(0)) revert InvalidAddress();\\n\\n        if (amount == 0 || amount > balanceOf[from]) revert InvalidWithdrawAmount();\\n\\n        balanceOf[from] -= amount;\\n        emit Withdraw(from, to, amount);\\n\\n        (bool success,) = to.call{value: amount}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintPayout.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMintPayoutEvents {\\n    /// @notice Emitted when a deposit has been made.\\n    /// @param from The depositor's address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    /// @param amount The deposit amount.\\n    event Deposit(address from, address to, bytes4 reason, uint256 amount);\\n\\n    /// @notice Emitted when a withdrawal has been made.\\n    /// @param from The address withdrawing.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    event Withdraw(address from, address to, uint256 amount);\\n\\n    /// @notice Emitted during a mint deposit to provide additional context.\\n    /// @param depositedBy The address of the mint initiator.\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the person minting.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param creator The address of the contract creator, or the protocol fee recipient if none.\\n    /// @param creatorPayout The amount being paid to the creator.\\n    /// @param referralPayout The amount being paid to the referrer.\\n    /// @param protocolPayout The amount being paid to the protocol.\\n    /// @param totalAmount The total deposit amount.\\n    /// @param quantity The number of tokens being minted.\\n    /// @param protocolFee The per-mint fee for the protocol.\\n    event MintDeposit(\\n        address depositedBy,\\n        address mintContract,\\n        address minter,\\n        address referrer,\\n        address creator,\\n        uint256 creatorPayout,\\n        uint256 referralPayout,\\n        uint256 protocolPayout,\\n        uint256 totalAmount,\\n        uint256 quantity,\\n        uint256 protocolFee\\n    );\\n\\n    /// @notice Emitted when the protocol fee is updated.\\n    /// @param fee The new protocol fee.\\n    event ProtocolFeeUpdated(uint256 fee);\\n}\\n\\ninterface IMintPayout is IMintPayoutEvents {\\n    function balanceOf(address owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice The current protocol fee per-mint.\\n    function protocolFee() external view returns (uint256 fee);\\n\\n    /// @notice Sets the protocol fee per-mint.\\n    /// @dev Only callable by the owner.\\n    /// @param fee The new protocol fee.\\n    function setProtocolFee(uint256 fee) external;\\n\\n    /// @notice Magic value used to represent the fees belonging to the protocol.\\n    function protocolFeeRecipientAccount() external view returns (address);\\n\\n    /// @notice Withdraws from the protocol fee balance.\\n    /// @dev Only callable by the owner.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdrawProtocolFee(address to, uint256 amount) external;\\n\\n    /// @notice Deposits ether for a mint.\\n    /// @dev Ensure that `quantity` is > 0. The `protocolFee` should be per-mint, not the total taken.\\n    /// Will trigger a `MintDeposit` event, followed by `Deposit` events for:\\n    /// creator payout, protocol payout, and referrer payout (if a referrer is specified).\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the minter.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param quantity The amount being minted.\\n    function mintDeposit(address mintContract, address minter, address referrer, uint256 quantity) external payable;\\n\\n    /// @notice Deposits ether to an address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    function deposit(address to, bytes4 reason) external payable;\\n\\n    /// @notice Deposits ether to multiple addresses.\\n    /// @dev The length of `recipients`, `amounts`, and `reasons` must be the same.\\n    /// @param recipients List of addresses receiving the deposits.\\n    /// @param amounts List of deposit amounts.\\n    /// @param reasons List of reason codes for the deposits.\\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, bytes4[] calldata reasons)\\n        external\\n        payable;\\n\\n    /// @notice Withdraws ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdraw(address to, uint256 amount) external;\\n\\n    /// @notice Withdraws all ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    function withdrawAll(address to) external;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IMetadataRenderer} from \\\"create/interfaces/v1/IMetadataRenderer.sol\\\";\\n\\ninterface IMintContractEvents {\\n    /// @notice Emitted when the royalty is updated.\\n    event RoyaltyUpdated(uint256 bps);\\n    /// @notice Emitted when a new mint module is added.\\n    event ModuleAdded(address module);\\n    /// @notice Emitted when a mint module is removed.\\n    event ModuleRemoved(address module);\\n    /// @notice Emitted when the metadata renderer is updated.\\n    event MetadataRendererUpdated(address renderer);\\n}\\n\\ninterface IMintContract is IMintContractEvents {\\n    /// @notice Mints tokens using approved mint modules.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function mint(address to, uint256 quantity) external;\\n\\n    /// @notice Mints tokens, callable only by the contract owner.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function adminMint(address to, uint256 quantity) external;\\n\\n    /// @notice Retrieves the payout recipient address for this mint contract.\\n    /// @return recipient address of the payout recipient.\\n    function payoutRecipient() external view returns (address recipient);\\n\\n    /// @notice Returns the total number of tokens minted.\\n    /// @return total number of tokens minted.\\n    function totalMinted() external view returns (uint256 total);\\n\\n    /// @notice Adds a new mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// Must be approved in the MintModuleRegistry.\\n    /// @param mintModule The contract address of the mint module.\\n    function addMintModule(address mintModule) external;\\n\\n    /// @notice Removes a mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// @param mintModule The contract address of the mint module.\\n    function removeMintModule(address mintModule) external;\\n\\n    /// @notice Returns whether a mint module is approved.\\n    /// @param mintModule The contract address of the mint module.\\n    /// @return isApproved Whether the mint module is approved.\\n    function isMintModuleApproved(address mintModule) external view returns (bool isApproved);\\n\\n    /// @notice Updates configuration located in an external contract.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// The cardinality of `configurables` and `configData` must be the same.\\n    /// @param configurables The contract addresses to configure.\\n    /// @param configData The configuration data for the contracts.\\n    function updateExternalConfiguration(address[] calldata configurables, bytes[] calldata configData) external;\\n\\n    /// @notice Sets the metadata renderer.\\n    /// @dev This will not request a metadata refresh. If needed, call `refreshMetadata`.\\n    /// @param renderer The new metadata renderer.\\n    function setMetadataRenderer(IMetadataRenderer renderer) external;\\n\\n    /// @notice Returns the metadata renderer for this contract.\\n    /// @return metadataRenderer The metadata renderer.\\n    function metadataRenderer() external returns (IMetadataRenderer metadataRenderer);\\n\\n    /// @notice Triggers a batch metadata update.\\n    function refreshMetadata() external;\\n\\n    /// @notice Updates the royalty for this contract.\\n    /// @dev Can only be called by the contract owner.\\n    /// Emits a `RoyaltyUpdated` event.\\n    /// @param bps The new royalty.\\n    function setRoyalty(uint256 bps) external;\\n\\n    /// @notice Returns the royalty for this contract.\\n    /// @return bps The royalty.\\n    function royaltyBps() external returns (uint256 bps);\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/Version.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nabstract contract Version {\\n    /// @notice The version of the contract.\\n    uint32 public immutable contractVersion;\\n\\n    constructor(uint32 _contractVersion) {\\n        contractVersion = _contractVersion;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/MintPayoutReasons.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nbytes4 constant MINT_REFERRAL_REASON = bytes4(keccak256(\\\"MINT_REFERRAL\\\"));\\nbytes4 constant PROTOCOL_FEE_REASON = bytes4(keccak256(\\\"PROTOCOL_FEE\\\"));\\nbytes4 constant PURCHASE_AMOUNT_REASON = bytes4(keccak256(\\\"PURCHASE_AMOUNT\\\"));\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMetadataRenderer {\\n    /// @notice Retrieves the token URI for the specified token ID.\\n    /// @param tokenId The ID of the token.\\n    /// @return uri The URI of the token.\\n    function tokenURI(uint256 tokenId) external view returns (string memory uri);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"fundrop/=src/Fundrop/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/src/\",\r\n      \"base64/=lib/base64/\",\r\n      \"create/=src/Create/\",\r\n      \"erc4626-tests/=lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/erc721a-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/operator-filter-registry/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 250000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IncorrectDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWithdrawAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"reason\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"name\":\"MintDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"reason\",\"type\":\"bytes4\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"reasons\",\"type\":\"bytes4[]\"}],\"name\":\"depositBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mintContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipientAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MintPayout", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "250000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}