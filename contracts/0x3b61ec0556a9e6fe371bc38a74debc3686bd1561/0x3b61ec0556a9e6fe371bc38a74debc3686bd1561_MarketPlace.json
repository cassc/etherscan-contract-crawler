{"SourceCode": "// File: Swivel-v4/src/interfaces/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n// methods requried on other contracts which are expected to, at least, implement the following:\r\ninterface IERC20 {\r\n    function approve(address, uint256) external returns (bool);\r\n\r\n    function transfer(address, uint256) external returns (bool);\r\n\r\n    function balanceOf(address) external returns (uint256);\r\n\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n\r\n    function decimals() external returns (uint8);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IAdapter.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\ninterface IAdapter {\r\n    function underlying(address) external view returns (address);\r\n\r\n    function exchangeRate(address) external view returns (uint256);\r\n\r\n    function deposit(address, uint256) external returns (uint256);\r\n\r\n    function withdraw(address, uint256) external returns (uint256);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IZcToken.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IZcToken {\r\n    function mint(address, uint256) external returns (bool);\r\n\r\n    function burn(address, uint256) external returns (bool);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IVaultTracker.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IVaultTracker {\r\n    function addNotional(address, uint256) external returns (bool);\r\n\r\n    function removeNotional(address, uint256) external returns (bool);\r\n\r\n    function redeemInterest(address) external returns (uint256);\r\n\r\n    function matureVault(uint256) external returns (bool);\r\n\r\n    function transferNotionalFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function transferNotionalFee(address, uint256) external returns (bool);\r\n\r\n    function rates() external view returns (uint256, uint256);\r\n\r\n    function balancesOf(address) external view returns (uint256, uint256);\r\n\r\n    function setAdapter(address) external;\r\n\r\n    function adapter() external view returns (address);\r\n}\r\n\r\n// File: Swivel-v4/src/lib/Sig.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\nlibrary Sig {\r\n    /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature\r\n    struct Components {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    error S();\r\n    error V();\r\n    error Length();\r\n    error ZeroAddress();\r\n\r\n    /// @param h Hashed data which was originally signed\r\n    /// @param c signature struct containing V,R and S\r\n    /// @return The recovered address\r\n    function recover(\r\n        bytes32 h,\r\n        Components calldata c\r\n    ) internal pure returns (address) {\r\n        // EIP-2 and malleable signatures...\r\n        // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (\r\n            uint256(c.s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            revert S();\r\n        }\r\n\r\n        if (c.v != 27 && c.v != 28) {\r\n            revert V();\r\n        }\r\n\r\n        address recovered = ecrecover(h, c.v, c.r, c.s);\r\n\r\n        if (recovered == address(0)) {\r\n            revert ZeroAddress();\r\n        }\r\n\r\n        return recovered;\r\n    }\r\n\r\n    /// @param sig Valid ECDSA signature\r\n    /// @return v The verification bit\r\n    /// @return r First 32 bytes\r\n    /// @return s Next 32 bytes\r\n    function split(\r\n        bytes memory sig\r\n    ) internal pure returns (uint8, bytes32, bytes32) {\r\n        if (sig.length != 65) {\r\n            revert Length();\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        return (v, r, s);\r\n    }\r\n}\r\n\r\n// File: Swivel-v4/src/lib/Hash.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n/**\r\n  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.\r\n  Also to produce / verify hashed and signed Orders.\r\n  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\r\n  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\r\n*/\r\n\r\nlibrary Hash {\r\n    /// @dev struct represents the attributes of an offchain Swivel.Order\r\n    struct Order {\r\n        bytes32 key;\r\n        uint8 protocol;\r\n        address maker;\r\n        address underlying;\r\n        bool vault;\r\n        bool exit;\r\n        uint256 principal;\r\n        uint256 premium;\r\n        uint256 maturity;\r\n        uint256 expiry;\r\n    }\r\n\r\n    // EIP712 Domain Separator typeHash\r\n    // keccak256(abi.encodePacked(\r\n    //     'EIP712Domain(',\r\n    //     'string name,',\r\n    //     'string version,',\r\n    //     'uint256 chainId,',\r\n    //     'address verifyingContract',\r\n    //     ')'\r\n    // ));\r\n    bytes32 internal constant DOMAIN_TYPEHASH =\r\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    // EIP712 typeHash of an Order\r\n    // keccak256(abi.encodePacked(\r\n    //     'Order(',\r\n    //     'bytes32 key,',\r\n    //     'uint8 protocol,',\r\n    //     'address maker,',\r\n    //     'address underlying,',\r\n    //     'bool vault,',\r\n    //     'bool exit,',\r\n    //     'uint256 principal,',\r\n    //     'uint256 premium,',\r\n    //     'uint256 maturity,',\r\n    //     'uint256 expiry',\r\n    //     ')'\r\n    // ));\r\n    bytes32 internal constant ORDER_TYPEHASH =\r\n        0xbc200cfe92556575f801f821f26e6d54f6421fa132e4b2d65319cac1c687d8e6;\r\n\r\n    /// @param n EIP712 domain name\r\n    /// @param version EIP712 semantic version string\r\n    /// @param i Chain ID\r\n    /// @param verifier address of the verifying contract\r\n    function domain(\r\n        string memory n,\r\n        string memory version,\r\n        uint256 i,\r\n        address verifier\r\n    ) internal pure returns (bytes32) {\r\n        bytes32 hash;\r\n\r\n        assembly {\r\n            let nameHash := keccak256(add(n, 32), mload(n))\r\n            let versionHash := keccak256(add(version, 32), mload(version))\r\n            let pointer := mload(64)\r\n            mstore(pointer, DOMAIN_TYPEHASH)\r\n            mstore(add(pointer, 32), nameHash)\r\n            mstore(add(pointer, 64), versionHash)\r\n            mstore(add(pointer, 96), i)\r\n            mstore(add(pointer, 128), verifier)\r\n            hash := keccak256(pointer, 160)\r\n        }\r\n\r\n        return hash;\r\n    }\r\n\r\n    /// @param d Type hash of the domain separator (see Hash.domain)\r\n    /// @param h EIP712 hash struct (order for example)\r\n    function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {\r\n        bytes32 hash;\r\n\r\n        assembly {\r\n            let pointer := mload(64)\r\n            mstore(\r\n                pointer,\r\n                0x1901000000000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(pointer, 2), d)\r\n            mstore(add(pointer, 34), h)\r\n            hash := keccak256(pointer, 66)\r\n        }\r\n\r\n        return hash;\r\n    }\r\n\r\n    /// @param o A Swivel Order\r\n    function order(Order calldata o) internal pure returns (bytes32) {\r\n        // TODO assembly\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    ORDER_TYPEHASH,\r\n                    o.key,\r\n                    o.protocol,\r\n                    o.maker,\r\n                    o.underlying,\r\n                    o.vault,\r\n                    o.exit,\r\n                    o.principal,\r\n                    o.premium,\r\n                    o.maturity,\r\n                    o.expiry\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/ISwivel.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n\r\n// the behavioral Swivel Interface, Implemented by Swivel.sol\r\ninterface ISwivel {\r\n    function initiate(\r\n        Hash.Order[] calldata,\r\n        uint256[] calldata,\r\n        Sig.Components[] calldata\r\n    ) external returns (bool);\r\n\r\n    function exit(\r\n        Hash.Order[] calldata,\r\n        uint256[] calldata,\r\n        Sig.Components[] calldata\r\n    ) external returns (bool);\r\n\r\n    function cancel(Hash.Order[] calldata) external returns (bool);\r\n\r\n    function setAdmin(address) external returns (bool);\r\n\r\n    function scheduleWithdrawal(address) external returns (bool);\r\n\r\n    function scheduleFeeChange(uint16[4] calldata) external returns (bool);\r\n\r\n    function blockWithdrawal(address) external returns (bool);\r\n\r\n    function blockFeeChange() external returns (bool);\r\n\r\n    function withdrawFunds(address) external returns (bool);\r\n\r\n    function changeFee(uint16[4] calldata) external returns (bool);\r\n\r\n    function approveUnderlying(\r\n        address[] calldata,\r\n        address[] calldata\r\n    ) external returns (bool);\r\n\r\n    function splitUnderlying(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function combineTokens(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function authRedeem(\r\n        address,\r\n        address,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function authApprove(\r\n        address,\r\n        address\r\n    ) external returns (uint256);\r\n\r\n    function redeemZcToken(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function redeemVaultInterest(\r\n        uint8,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function redeemSwivelVaultInterest(\r\n        uint8,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/ICreator.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface ICreator {\r\n    function create(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        address,\r\n        string calldata,\r\n        string calldata,\r\n        uint8\r\n    ) external returns (address, address);\r\n\r\n    function setAdmin(address) external returns (bool);\r\n\r\n    function setMarketPlace(address) external returns (bool);\r\n}\r\n\r\n// File: Swivel-v4/src/interfaces/IMarketPlace.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IMarketPlace {\r\n    function setSwivel(address) external returns (bool);\r\n\r\n    function setAdmin(address) external returns (bool);\r\n\r\n    function createMarket(\r\n        uint8,\r\n        uint256,\r\n        address,\r\n        address,\r\n        string memory,\r\n        string memory\r\n    ) external returns (bool);\r\n\r\n    function matureMarket(uint8, address, uint256) external returns (bool);\r\n\r\n    function authRedeem(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256);\r\n\r\n    function rates(uint8, address, uint256) external returns (uint256, uint256);\r\n\r\n    function transferVaultNotional(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // adds notional and mints zctokens\r\n    function mintZcTokenAddingNotional(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // removes notional and burns zctokens\r\n    function burnZcTokenRemovingNotional(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // returns the amount of underlying principal to send\r\n    function redeemZcToken(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (uint256);\r\n\r\n    // returns the amount of underlying interest to send\r\n    function redeemVaultInterest(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address\r\n    ) external returns (uint256);\r\n\r\n    // returns the cToken address for a given market\r\n    function cTokenAddress(uint8, address, uint256) external returns (address);\r\n\r\n    // returns the adapter address for a given market\r\n    function adapterAddress(uint8, address, uint256) external returns (address);\r\n\r\n    // EVFZE FF EZFVE call this which would then burn zctoken and remove notional\r\n    function custodialExit(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // IVFZI && IZFVI call this which would then mint zctoken and add notional\r\n    function custodialInitiate(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // IZFZE && EZFZI call this, tranferring zctoken from one party to another\r\n    function p2pZcTokenExchange(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // IVFVE && EVFVI call this, removing notional from one party and adding to the other\r\n    function p2pVaultExchange(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    // IVFZI && IVFVE call this which then transfers notional from msg.sender (taker) to swivel\r\n    function transferVaultNotionalFee(\r\n        uint8,\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: Swivel-v4/src/MarketPlace.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketPlace is IMarketPlace {\r\n    /// @dev A single custom error capable of indicating a wide range of detected errors by providing\r\n    /// an error code value whose string representation is documented <here>, and any possible other values\r\n    /// that are pertinent to the error.\r\n    error Exception(uint8, uint256, uint256, address, address);\r\n\r\n    struct Market {\r\n        address adapter;\r\n        address cTokenAddr;\r\n        address zcToken;\r\n        address vaultTracker;\r\n        uint256 maturityRate;\r\n    }\r\n\r\n    mapping(uint8 => mapping(address => mapping(uint256 => Market)))\r\n        public markets;\r\n    mapping(uint8 => bool) public paused;\r\n\r\n    address public admin;\r\n    address public swivel;\r\n    address public immutable creator;\r\n\r\n    event Create(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address cToken,\r\n        address zcToken,\r\n        address vaultTracker\r\n    );\r\n    event Mature(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        uint256 maturityRate,\r\n        uint256 matured\r\n    );\r\n    event RedeemZcToken(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address sender,\r\n        uint256 amount\r\n    );\r\n    event RedeemVaultInterest(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address sender\r\n    );\r\n    event CustodialInitiate(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address zcTarget,\r\n        address nTarget,\r\n        uint256 amount\r\n    );\r\n    event CustodialExit(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address zcTarget,\r\n        address nTarget,\r\n        uint256 amount\r\n    );\r\n    event P2pZcTokenExchange(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n    event P2pVaultExchange(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n    event TransferVaultNotional(\r\n        uint8 indexed protocol,\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n    event SetAdmin(address indexed admin);\r\n    event SetAdapter(\r\n        address indexed underlying,\r\n        uint256 indexed maturity,\r\n        address indexed adapter\r\n    );\r\n\r\n    /// @param c Address of the deployed creator contract\r\n    constructor(address c) {\r\n        admin = msg.sender;\r\n        creator = c;\r\n    }\r\n\r\n    /// @param s Address of the deployed swivel contract\r\n    /// @notice We only allow this to be set once\r\n    /// @dev there is no emit here as it's only done once post deploy by the deploying admin\r\n    function setSwivel(address s) external authorized(admin) returns (bool) {\r\n        if (swivel != address(0)) {\r\n            revert Exception(20, 0, 0, swivel, address(0));\r\n        }\r\n\r\n        swivel = s;\r\n        return true;\r\n    }\r\n\r\n    /// @param a Address of a new admin\r\n    function setAdmin(address a) external authorized(admin) returns (bool) {\r\n        admin = a;\r\n\r\n        emit SetAdmin(a);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// Should execute after the creation of a market to ensure the vaultTracker exists first\r\n    /// @param u Underlying address of a given market\r\n    /// @param m Maturity of a given market\r\n    /// @param p Protocol enum value of a given market\r\n    /// @param a Address of a new adapter\r\n    function setAdapter(\r\n        address u,\r\n        uint256 m,\r\n        uint8 p,\r\n        address a\r\n    ) external authorized(admin) returns (bool) {\r\n        // Update the market\r\n        markets[p][u][m].adapter = a;\r\n\r\n        // Update the adapter in the vault tracker\r\n        IVaultTracker(markets[p][u][m].vaultTracker).setAdapter(a);\r\n\r\n        emit SetAdapter(u, m, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the owner to create new markets\r\n    /// @param p Protocol associated with the new market\r\n    /// @param m Maturity timestamp of the new market\r\n    /// @param c Compounding Token address associated with the new market\r\n    /// @param a Satallite contract responsible for executing protocol specific transactions\r\n    /// @param n Name of the new market zcToken\r\n    /// @dev the memory allocation of `s` is for alleviating STD err, there's no clearly superior scoping or abstracting alternative.\r\n    /// @param s Symbol of the new market zcToken\r\n    function createMarket(\r\n        uint8 p,\r\n        uint256 m,\r\n        address c,\r\n        address a,\r\n        string memory n,\r\n        string memory s\r\n    ) external authorized(admin) unpaused(p) returns (bool) {\r\n        if (swivel == address(0)) {\r\n            revert Exception(21, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        address underlying = IAdapter(a).underlying(c);\r\n\r\n        if (markets[p][underlying][m].vaultTracker != address(0)) {\r\n            // NOTE: not saving and publishing that found tracker addr as stack limitations...\r\n            revert Exception(22, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        (address zct, address tracker) = ICreator(creator).create(\r\n            p,\r\n            underlying,\r\n            m,\r\n            a,\r\n            c,\r\n            swivel,\r\n            n,\r\n            s,\r\n            IERC20(underlying).decimals()\r\n        );\r\n\r\n        ISwivel(swivel).authApprove(underlying, c);\r\n\r\n        markets[p][underlying][m] = Market(a, c, zct, tracker, 0);\r\n\r\n        emit Create(p, underlying, m, c, zct, tracker);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\r\n    /// @param p Protocol Enum value associated with the market being matured\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    function matureMarket(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m\r\n    ) public unpaused(p) returns (bool) {\r\n        Market memory market = markets[p][u][m];\r\n\r\n        if (market.maturityRate != 0) {\r\n            revert Exception(\r\n                23,\r\n                market.maturityRate,\r\n                0,\r\n                address(0),\r\n                address(0)\r\n            );\r\n        }\r\n\r\n        if (block.timestamp < m) {\r\n            revert Exception(24, block.timestamp, m, address(0), address(0));\r\n        }\r\n\r\n        // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\r\n        uint256 xRate = IAdapter(market.adapter).exchangeRate(\r\n            market.cTokenAddr\r\n        );\r\n        markets[p][u][m].maturityRate = xRate;\r\n\r\n        // NOTE we don't check the return of this simple operation\r\n        IVaultTracker(market.vaultTracker).matureVault(xRate);\r\n\r\n        emit Mature(p, u, m, xRate, block.timestamp);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param t Address of the depositing user\r\n    /// @param a Amount of notional being added\r\n    function mintZcTokenAddingNotional(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        Market memory market = markets[p][u][m];\r\n\r\n        if (!IZcToken(market.zcToken).mint(t, a)) {\r\n            revert Exception(28, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        if (!IVaultTracker(market.vaultTracker).addNotional(t, a)) {\r\n            revert Exception(25, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \"combining\" the two and redeeming underlying.\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param t Address of the combining/redeeming user\r\n    /// @param a Amount of zcTokens being burned\r\n    function burnZcTokenRemovingNotional(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        Market memory market = markets[p][u][m];\r\n\r\n        if (!IZcToken(market.zcToken).burn(t, a)) {\r\n            revert Exception(29, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        if (!IVaultTracker(market.vaultTracker).removeNotional(t, a)) {\r\n            revert Exception(26, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Implementation of authRedeem to fulfill the IRedeemer interface for ERC5095\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param f Address of the user having their zcTokens burned\r\n    /// @param t Address of the user receiving underlying\r\n    /// @param a Amount of zcTokens being redeemed\r\n    /// @return Amount of underlying being withdrawn (needed for 5095 return)\r\n    function authRedeem(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address f,\r\n        address t,\r\n        uint256 a\r\n    )\r\n        external\r\n        authorized(markets[p][u][m].zcToken)\r\n        unpaused(p)\r\n        returns (uint256)\r\n    {\r\n        /// @dev swiv needs to be set or the call to authRedeem there will be faulty\r\n        if (swivel == address(0)) {\r\n            revert Exception(21, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        Market memory market = markets[p][u][m];\r\n        // if the market has not matured, mature it...\r\n        if (market.maturityRate == 0) {\r\n            if (!matureMarket(p, u, m)) {\r\n                revert Exception(30, 0, 0, address(0), address(0));\r\n            }\r\n        }\r\n\r\n        if (!IZcToken(market.zcToken).burn(f, a)) {\r\n            revert Exception(29, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        // depending on initial market maturity status adjust (or don't) the amount to be redemmed/returned\r\n        uint256 amount = market.maturityRate == 0\r\n            ? a\r\n            : calculateReturn(p, u, m, a);\r\n\r\n        if (\r\n            !ISwivel(swivel).authRedeem(\r\n                u,\r\n                market.cTokenAddr,\r\n                market.adapter,\r\n                t,\r\n                amount\r\n            )\r\n        ) {\r\n            revert Exception(37, amount, 0, market.cTokenAddr, t);\r\n        }\r\n\r\n        emit RedeemZcToken(p, u, m, t, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param t Address of the redeeming user\r\n    /// @param a Amount of zcTokens being redeemed\r\n    function redeemZcToken(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (uint256) {\r\n        Market memory market = markets[p][u][m];\r\n\r\n        // if the market has not matured, mature it and redeem exactly the amount\r\n        if (market.maturityRate == 0) {\r\n            if (!matureMarket(p, u, m)) {\r\n                revert Exception(30, 0, 0, address(0), address(0));\r\n            }\r\n        }\r\n\r\n        if (!IZcToken(market.zcToken).burn(t, a)) {\r\n            revert Exception(29, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit RedeemZcToken(p, u, m, t, a);\r\n\r\n        if (market.maturityRate == 0) {\r\n            return a;\r\n        } else {\r\n            // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\r\n            return calculateReturn(p, u, m, a);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param t Address of the redeeming user\r\n    function redeemVaultInterest(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address t\r\n    ) external authorized(swivel) unpaused(p) returns (uint256) {\r\n        // call to the floating market contract to release the position and calculate the interest generated\r\n        uint256 interest = IVaultTracker(markets[p][u][m].vaultTracker)\r\n            .redeemInterest(t);\r\n\r\n        // if the market has not matured, mature it and redeem exactly the amount\r\n        if (block.timestamp > m && markets[p][u][m].maturityRate == 0) {\r\n            if (!matureMarket(p, u, m)) {\r\n                revert Exception(30, 0, 0, address(0), address(0));\r\n            }\r\n        }\r\n\r\n        emit RedeemVaultInterest(p, u, m, t);\r\n\r\n        return interest;\r\n    }\r\n\r\n    /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param a Amount of zcTokens being redeemed\r\n    function calculateReturn(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        uint256 a\r\n    ) internal returns (uint256) {\r\n        Market memory market = markets[p][u][m];\r\n\r\n        uint256 xRate = IAdapter(market.adapter).exchangeRate(\r\n            market.cTokenAddr\r\n        );\r\n\r\n        return (a * xRate) / market.maturityRate;\r\n    }\r\n\r\n    /// @notice Return the compounding token address for a given market\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    function cTokenAddress(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m\r\n    ) external view returns (address) {\r\n        return markets[p][u][m].cTokenAddr;\r\n    }\r\n\r\n    /// @notice Return the adapter address for a given market\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    function adapterAddress(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m\r\n    ) external view returns (address) {\r\n        return markets[p][u][m].adapter;\r\n    }\r\n\r\n    /// @notice Return current rates (maturity, exchange) for a given vault. See VaultTracker.rates for details\r\n    /// @dev While it's true that Compounding exchange rate is not strictly affiliated with a vault, the 2 data points are usually needed together.\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @return maturityRate, exchangeRate*\r\n    function rates(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m\r\n    ) external view returns (uint256, uint256) {\r\n        return IVaultTracker(markets[p][u][m].vaultTracker).rates();\r\n    }\r\n\r\n    /// @notice Called by swivel IVFZI && IZFVI\r\n    /// @dev Call with protocol, underlying, maturity, mint-target, add-notional-target and an amount\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param z Recipient of the minted zcToken\r\n    /// @param n Recipient of the added notional\r\n    /// @param a Amount of zcToken minted and notional added\r\n    function custodialInitiate(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address z,\r\n        address n,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        Market memory market = markets[p][u][m];\r\n        if (!IZcToken(market.zcToken).mint(z, a)) {\r\n            revert Exception(28, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        if (!IVaultTracker(market.vaultTracker).addNotional(n, a)) {\r\n            revert Exception(25, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit CustodialInitiate(p, u, m, z, n, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Called by swivel EVFZE FF EZFVE\r\n    /// @dev Call with protocol, underlying, maturity, burn-target, remove-notional-target and an amount\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param z Owner of the zcToken to be burned\r\n    /// @param n Target to remove notional from\r\n    /// @param a Amount of zcToken burned and notional removed\r\n    function custodialExit(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address z,\r\n        address n,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        Market memory market = markets[p][u][m];\r\n        if (!IZcToken(market.zcToken).burn(z, a)) {\r\n            revert Exception(29, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        if (!IVaultTracker(market.vaultTracker).removeNotional(n, a)) {\r\n            revert Exception(26, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit CustodialExit(p, u, m, z, n, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Called by swivel IZFZE, EZFZI\r\n    /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param f Owner of the zcToken to be burned\r\n    /// @param t Target to be minted to\r\n    /// @param a Amount of zcToken transfer\r\n    function p2pZcTokenExchange(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address f,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        address zct = markets[p][u][m].zcToken;\r\n\r\n        if (!IZcToken(zct).burn(f, a)) {\r\n            revert Exception(29, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        if (!IZcToken(zct).mint(t, a)) {\r\n            revert Exception(28, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit P2pZcTokenExchange(p, u, m, f, t, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Called by swivel IVFVE, EVFVI\r\n    /// @dev Call with protocol, underlying, maturity, remove-from, add-to, amount\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param f Owner of the notional to be transferred\r\n    /// @param t Target to be transferred to\r\n    /// @param a Amount of notional transfer\r\n    function p2pVaultExchange(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address f,\r\n        address t,\r\n        uint256 a\r\n    ) external authorized(swivel) unpaused(p) returns (bool) {\r\n        if (\r\n            !IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(\r\n                f,\r\n                t,\r\n                a\r\n            )\r\n        ) {\r\n            revert Exception(27, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit P2pVaultExchange(p, u, m, f, t, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice External method giving access to this functionality within a given vault\r\n    /// @dev Note that this method calculates yield and interest as well\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param t Target to be transferred to\r\n    /// @param a Amount of notional to be transferred\r\n    function transferVaultNotional(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address t,\r\n        uint256 a\r\n    ) external unpaused(p) returns (bool) {\r\n        if (\r\n            !IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(\r\n                msg.sender,\r\n                t,\r\n                a\r\n            )\r\n        ) {\r\n            revert Exception(27, 0, 0, address(0), address(0));\r\n        }\r\n\r\n        emit TransferVaultNotional(p, u, m, msg.sender, t, a);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\r\n    /// @param p Protocol Enum value associated with this market\r\n    /// @param u Underlying token address associated with the market\r\n    /// @param m Maturity timestamp of the market\r\n    /// @param f Owner of the amount\r\n    /// @param a Amount to transfer\r\n    function transferVaultNotionalFee(\r\n        uint8 p,\r\n        address u,\r\n        uint256 m,\r\n        address f,\r\n        uint256 a\r\n    ) external authorized(swivel) returns (bool) {\r\n        return\r\n            IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFee(\r\n                f,\r\n                a\r\n            );\r\n    }\r\n\r\n    /// @notice Called by admin at any point to pause / unpause market transactions in a specified protocol\r\n    /// @param p Protocol Enum value of the protocol to be paused\r\n    /// @param b Boolean which indicates the (protocol) markets paused status\r\n    function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\r\n        paused[p] = b;\r\n        return true;\r\n    }\r\n\r\n    modifier authorized(address a) {\r\n        if (msg.sender != a) {\r\n            revert Exception(0, 0, 0, msg.sender, a);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier unpaused(uint8 p) {\r\n        if (paused[p]) {\r\n            revert Exception(1, 0, 0, address(0), address(0));\r\n        }\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultTracker\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodialExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodialInitiate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturityRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matured\",\"type\":\"uint256\"}],\"name\":\"Mature\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"P2pVaultExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"P2pZcTokenExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RedeemVaultInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedeemZcToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"SetAdapter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferVaultNotional\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"adapterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"burnZcTokenRemovingNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"cTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"n\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"}],\"name\":\"createMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"z\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"n\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"custodialExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"z\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"n\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"custodialInitiate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultTracker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maturityRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"matureMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"mintZcTokenAddingNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"p2pVaultExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"p2pZcTokenExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"rates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"redeemVaultInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"redeemZcToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdapter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"}],\"name\":\"setSwivel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swivel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"transferVaultNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"transferVaultNotionalFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MarketPlace", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000052be677d4568088024d87c66796b5d064fc7b57", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fac4e811572de22c3ac64cccacf6feb43db62062c0352b8e97d6484a6dae3e2d"}