{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/router/LinkedPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IPausable} from \\\"./interfaces/IPausable.sol\\\";\\nimport {IndexedToken, IPoolModule} from \\\"./interfaces/IPoolModule.sol\\\";\\nimport {ILinkedPool} from \\\"./interfaces/ILinkedPool.sol\\\";\\nimport {IDefaultPool} from \\\"./interfaces/IDefaultPool.sol\\\";\\nimport {Action} from \\\"./libs/Structs.sol\\\";\\nimport {UniversalTokenLib} from \\\"./libs/UniversalToken.sol\\\";\\nimport {TokenTree} from \\\"./tree/TokenTree.sol\\\";\\n\\nimport {Address} from \\\"@openzeppelin/contracts-4.5.0/utils/Address.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts-4.5.0/access/Ownable.sol\\\";\\nimport {IERC20, SafeERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// LinkedPool is using an internal Token Tree to aggregate a collection of pools with correlated\\n/// tokens into a single wrapper, conforming to IDefaultPool interface.\\n/// The internal Token Tree allows to store up to 256 tokens, which should be enough for most use cases.\\n/// Note: unlike traditional Default pools, tokens in LinkedPool could be duplicated.\\n/// This contract is supposed to be used in conjunction with Synapse:Bridge:\\n/// - The bridged token has index == 0, and could not be duplicated in the tree.\\n/// - Other tokens (correlated to bridge token) could be duplicated in the tree. Every node token in the tree\\n/// is represented by a trade path from root token to node token.\\n/// > This is the reason why token could be duplicated. `nUSD -> USDC` and `nUSD -> USDT -> USDC` both represent\\n/// > USDC token, but via different paths from nUSD, the bridge token.\\n/// In addition to the standard IDefaultPool interface, LinkedPool also implements getters to observe the internal\\n/// tree, as well as the best path finder between any two tokens in the tree.\\n/// Note: LinkedPool assumes that the added pool tokens have no transfer fees enabled.\\ncontract LinkedPool is TokenTree, Ownable, ILinkedPool {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using UniversalTokenLib for address;\\n\\n    error LinkedPool__DeadlineExceeded(uint256 timestamp, uint256 deadline);\\n    error LinkedPool__EqualSwapIndexes(uint8 index);\\n    error LinkedPool__MinDyNotMet(uint256 amountOut, uint256 minDy);\\n    error LinkedPool__EmptyPoolAddress();\\n\\n    /// @notice Replicates signature of `TokenSwap` event from Default Pools.\\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\\n\\n    constructor(address bridgeToken, address owner_) TokenTree(bridgeToken) {\\n        transferOwnership(owner_);\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 EXTERNAL \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Adds a pool having `N` pool tokens to the tree by adding `N-1` new nodes\\n    /// as the children of the given node. Given node needs to represent a token from the pool.\\n    /// @dev `poolModule` should be set to address(this) if the pool conforms to IDefaultPool interface.\\n    /// Otherwise, it should be set to the address of the contract that implements the logic for pool handling.\\n    /// @param nodeIndex        The index of the node to which the pool will be added\\n    /// @param pool             The address of the pool\\n    /// @param poolModule       The address of the pool module\\n    function addPool(\\n        uint256 nodeIndex,\\n        address pool,\\n        address poolModule\\n    ) external onlyOwner checkIndex(nodeIndex) {\\n        if (pool == address(0)) revert LinkedPool__EmptyPoolAddress();\\n        _addPool(nodeIndex, pool, poolModule);\\n    }\\n\\n    /// @notice Updates the pool module logic address for the given pool.\\n    /// @dev Will revert if the pool is not present in the tree, or if the new pool module\\n    /// produces a different token list for the pool.\\n    function updatePoolModule(address pool, address newPoolModule) external onlyOwner {\\n        _updatePoolModule(pool, newPoolModule);\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function swap(\\n        uint8 nodeIndexFrom,\\n        uint8 nodeIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external checkIndex(nodeIndexFrom) checkIndex(nodeIndexTo) returns (uint256 amountOut) {\\n        // solhint-disable-next-line not-rely-on-time\\n        if (block.timestamp > deadline) revert LinkedPool__DeadlineExceeded(block.timestamp, deadline);\\n        if (nodeIndexFrom == nodeIndexTo) revert LinkedPool__EqualSwapIndexes(nodeIndexFrom);\\n        // Pull initial token from the user. LinkedPool assumes that the tokens have no transfer fees enabled,\\n        // thus the balance checks are omitted.\\n        address tokenIn = _nodes[nodeIndexFrom].token;\\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), dx);\\n        amountOut = _multiSwap(nodeIndexFrom, nodeIndexTo, dx).amountOut;\\n        if (amountOut < minDy) revert LinkedPool__MinDyNotMet(amountOut, minDy);\\n        // Transfer the tokens to the user\\n        IERC20(_nodes[nodeIndexTo].token).safeTransfer(msg.sender, amountOut);\\n        // Emit the event\\n        emit TokenSwap(msg.sender, dx, amountOut, nodeIndexFrom, nodeIndexTo);\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// Note: this calculates a quote for a predefined swap path between two tokens. If any of the tokens is\\n    /// presented more than once in the internal tree, there might be a better quote. Integration should use\\n    /// findBestPath() instead. This function is present for backwards compatibility.\\n    /// @inheritdoc ILinkedPool\\n    function calculateSwap(\\n        uint8 nodeIndexFrom,\\n        uint8 nodeIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 amountOut) {\\n        uint256 totalTokens = _nodes.length;\\n        // Check that the token indexes are within range\\n        if (nodeIndexFrom >= totalTokens || nodeIndexTo >= totalTokens) {\\n            return 0;\\n        }\\n        // Check that the token indexes are not the same\\n        if (nodeIndexFrom == nodeIndexTo) {\\n            return 0;\\n        }\\n        // Calculate the quote by following the path from \\\"tokenFrom\\\" node to \\\"tokenTo\\\" node in the stored tree\\n        // This function might be called by Synapse:Bridge before the swap, so we don't waste gas checking if pool is paused,\\n        // as the swap will fail anyway if it is.\\n        amountOut = _getMultiSwapQuote({\\n            nodeIndexFrom: nodeIndexFrom,\\n            nodeIndexTo: nodeIndexTo,\\n            amountIn: dx,\\n            probePaused: false\\n        }).amountOut;\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function areConnectedTokens(address tokenIn, address tokenOut) external view returns (bool areConnected) {\\n        // Tokens are considered connected, if they are both present in the tree\\n        return _tokenNodes[tokenIn].length > 0 && _tokenNodes[tokenOut].length > 0;\\n    }\\n\\n    /// Note: this could be potentially a gas expensive operation. This is used by SwapQuoterV2 to get the best quote\\n    /// for tokenIn -> tokenOut swap request (the call to SwapQuoter is an off-chain call).\\n    /// This should NOT be used as a part of \\\"find path + perform a swap\\\" on-chain flow.\\n    /// Instead, do an off-chain call to findBestPath() and then perform a swap using the found node indexes.\\n    /// As pair of token nodes defines only a single trade path (tree has no cycles), it will be possible to go\\n    /// through the found path by simply supplying the found indexes (instead of searching for the best path again).\\n    /// @inheritdoc ILinkedPool\\n    function findBestPath(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    )\\n        external\\n        view\\n        returns (\\n            uint8 nodeIndexFromBest,\\n            uint8 nodeIndexToBest,\\n            uint256 amountOutBest\\n        )\\n    {\\n        // Check that the tokens are not the same and that the amount is not zero\\n        if (tokenIn == tokenOut || amountIn == 0) {\\n            return (0, 0, 0);\\n        }\\n        uint256 nodesFrom = _tokenNodes[tokenIn].length;\\n        uint256 nodesTo = _tokenNodes[tokenOut].length;\\n        // Go through every node that represents `tokenIn`\\n        for (uint256 i = 0; i < nodesFrom; ++i) {\\n            uint256 nodeIndexFrom = _tokenNodes[tokenIn][i];\\n            // Go through every node that represents `tokenOut`\\n            for (uint256 j = 0; j < nodesTo; ++j) {\\n                uint256 nodeIndexTo = _tokenNodes[tokenOut][j];\\n                // Calculate the quote by following the path from \\\"tokenFrom\\\" node to \\\"tokenTo\\\" node in the stored tree\\n                // We discard any paths with paused pools, as it's not possible to swap via them anyway.\\n                uint256 amountOut = _getMultiSwapQuote({\\n                    nodeIndexFrom: nodeIndexFrom,\\n                    nodeIndexTo: nodeIndexTo,\\n                    amountIn: amountIn,\\n                    probePaused: true\\n                }).amountOut;\\n                if (amountOut > amountOutBest) {\\n                    amountOutBest = amountOut;\\n                    nodeIndexFromBest = uint8(nodeIndexFrom);\\n                    nodeIndexToBest = uint8(nodeIndexTo);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function getToken(uint8 index) external view checkIndex(index) returns (address token) {\\n        return _nodes[index].token;\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function tokenNodesAmount() external view returns (uint256) {\\n        return _nodes.length;\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function getAttachedPools(uint8 index) external view checkIndex(index) returns (address[] memory pools) {\\n        pools = new address[](_pools.length);\\n        uint256 amountAttached = 0;\\n        uint256 poolsMask = _attachedPools[index];\\n        for (uint256 i = 0; i < pools.length; ) {\\n            // Check if _pools[i] is attached to the node at `index`\\n            unchecked {\\n                if ((poolsMask >> i) & 1 == 1) {\\n                    pools[amountAttached++] = _pools[i];\\n                }\\n                ++i;\\n            }\\n        }\\n        // Use assembly to shrink the array to the actual size\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(pools, amountAttached)\\n        }\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function getTokenIndexes(address token) external view returns (uint256[] memory nodes) {\\n        nodes = _tokenNodes[token];\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function getPoolModule(address pool) external view returns (address) {\\n        return _poolMap[pool].module;\\n    }\\n\\n    /// @inheritdoc ILinkedPool\\n    function getNodeParent(uint256 nodeIndex)\\n        external\\n        view\\n        checkIndex(nodeIndex)\\n        returns (uint256 parentIndex, address parentPool)\\n    {\\n        uint8 depth = _nodes[nodeIndex].depth;\\n        // Check if node is root, in which case there is no parent\\n        if (depth > 0) {\\n            parentIndex = _extractNodeIndex(_rootPath[nodeIndex], depth - 1);\\n            parentPool = _pools[_nodes[nodeIndex].poolIndex];\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Performs a single swap between two nodes using the given pool.\\n    /// Assumes that the initial token is already in this contract.\\n    function _poolSwap(\\n        address poolModule,\\n        address pool,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn\\n    ) internal override returns (uint256 amountOut) {\\n        address tokenFrom = _nodes[nodeIndexFrom].token;\\n        address tokenTo = _nodes[nodeIndexTo].token;\\n        // Approve pool to spend the token, if needed\\n        if (poolModule == address(this)) {\\n            tokenFrom.universalApproveInfinity(pool, amountIn);\\n            // Pool conforms to IDefaultPool interface. Note: we check minDy and deadline outside of this function.\\n            amountOut = IDefaultPool(pool).swap({\\n                tokenIndexFrom: tokenIndexes[pool][tokenFrom],\\n                tokenIndexTo: tokenIndexes[pool][tokenTo],\\n                dx: amountIn,\\n                minDy: 0,\\n                deadline: type(uint256).max\\n            });\\n        } else {\\n            // Here we pass both token address and its index to the pool module, so it doesn't need to store\\n            // index<>token mapping. This allows Pool Module to be implemented in a stateless way, as some\\n            // pools require token index for interactions, while others require token address.\\n            // poolSwap(pool, tokenFrom, tokenTo, amountIn)\\n            bytes memory payload = abi.encodeWithSelector(\\n                IPoolModule.poolSwap.selector,\\n                pool,\\n                IndexedToken({index: tokenIndexes[pool][tokenFrom], token: tokenFrom}),\\n                IndexedToken({index: tokenIndexes[pool][tokenTo], token: tokenTo}),\\n                amountIn\\n            );\\n            // Delegate swap logic to Pool Module. It should approve the pool to spend the token, if needed.\\n            // Note that poolModule address is set by the contract owner, so it's safe to delegatecall it.\\n            // Using OZ library here to bubble up the revert reason if the call fails.\\n            bytes memory result = poolModule.functionDelegateCall(payload);\\n            // Pool Modules are whitelisted, so we can trust the returned amountOut value.\\n            amountOut = abi.decode(result, (uint256));\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Returns the amount of tokens that will be received from a single swap.\\n    function _getPoolQuote(\\n        address poolModule,\\n        address pool,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view override returns (uint256 amountOut) {\\n        if (poolModule == address(this)) {\\n            // Check if pool is paused, if requested\\n            if (probePaused) {\\n                // We issue a static call in case the pool does not conform to IPausable interface.\\n                (bool success, bytes memory returnData) = pool.staticcall(\\n                    abi.encodeWithSelector(IPausable.paused.selector)\\n                );\\n                if (success && abi.decode(returnData, (bool))) {\\n                    // Pool is paused, return zero\\n                    return 0;\\n                }\\n            }\\n            // Pool conforms to IDefaultPool interface.\\n            try\\n                IDefaultPool(pool).calculateSwap({\\n                    tokenIndexFrom: tokenIndexes[pool][_nodes[nodeIndexFrom].token],\\n                    tokenIndexTo: tokenIndexes[pool][_nodes[nodeIndexTo].token],\\n                    dx: amountIn\\n                })\\n            returns (uint256 amountOut_) {\\n                amountOut = amountOut_;\\n            } catch {\\n                // Return zero if the pool getter reverts for any reason\\n                amountOut = 0;\\n            }\\n        } else {\\n            // Ask Pool Module to calculate the quote\\n            address tokenFrom = _nodes[nodeIndexFrom].token;\\n            address tokenTo = _nodes[nodeIndexTo].token;\\n            // Here we pass both token address and its index to the pool module, so it doesn't need to store\\n            // index<>token mapping. This allows Pool Module to be implemented in a stateless way, as some\\n            // pools require token index for interactions, while others require token address.\\n            try\\n                IPoolModule(poolModule).getPoolQuote(\\n                    pool,\\n                    IndexedToken({index: tokenIndexes[pool][tokenFrom], token: tokenFrom}),\\n                    IndexedToken({index: tokenIndexes[pool][tokenTo], token: tokenTo}),\\n                    amountIn,\\n                    probePaused\\n                )\\n            returns (uint256 amountOut_) {\\n                amountOut = amountOut_;\\n            } catch {\\n                // Return zero if the pool module getter reverts for any reason\\n                amountOut = 0;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the tokens in the pool at the given address.\\n    function _getPoolTokens(address poolModule, address pool) internal view override returns (address[] memory tokens) {\\n        if (poolModule == address(this)) {\\n            // Pool conforms to IDefaultPool interface.\\n            // First, figure out how many tokens there are in the pool\\n            uint256 numTokens = 0;\\n            while (true) {\\n                try IDefaultPool(pool).getToken(uint8(numTokens)) returns (address) {\\n                    unchecked {\\n                        ++numTokens;\\n                    }\\n                } catch {\\n                    break;\\n                }\\n            }\\n            // Then allocate the memory, and get the tokens\\n            tokens = new address[](numTokens);\\n            for (uint256 i = 0; i < numTokens; ) {\\n                tokens[i] = IDefaultPool(pool).getToken(uint8(i));\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            // Ask Pool Module to return the tokens\\n            // Note: this will revert if pool is not supported by the module, enforcing the invariant\\n            // that the added pools are supported by their specified module.\\n            tokens = IPoolModule(poolModule).getPoolTokens(pool);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IPausable {\\n    function paused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IPoolModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IndexedToken} from \\\"../libs/Structs.sol\\\";\\n\\ninterface IPoolModule {\\n    /// @notice Performs a swap via the given pool, assuming `tokenFrom` is already in the contract.\\n    /// After the call, the contract should have custody over the received `tokenTo` tokens.\\n    /// @dev This will be used via delegatecall from LinkedPool, which will have the custody over the initial tokens,\\n    /// and will only use the correct pool address for interacting with the Pool Module.\\n    /// Note: Pool Module is responsible for issuing the token approvals, if `pool` requires them.\\n    /// Note: execution needs to be reverted, if swap fails for any reason.\\n    /// @param pool         Address of the pool\\n    /// @param tokenFrom    Token to swap from\\n    /// @param tokenTo      Token to swap to\\n    /// @param amountIn     Amount of tokenFrom to swap\\n    /// @return amountOut   Amount of tokenTo received after the swap\\n    function poolSwap(\\n        address pool,\\n        IndexedToken memory tokenFrom,\\n        IndexedToken memory tokenTo,\\n        uint256 amountIn\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns a quote for a swap via the given pool.\\n    /// @dev This will be used by LinkedPool, which is supposed to pass only the correct pool address.\\n    /// Note: Pool Module should bubble the revert, if pool quote fails for any reason.\\n    /// Note: Pool Module should only revert if the pool is paused, if `probePaused` is true.\\n    /// @param pool         Address of the pool\\n    /// @param tokenFrom    Token to swap from\\n    /// @param tokenTo      Token to swap to\\n    /// @param amountIn     Amount of tokenFrom to swap\\n    /// @param probePaused  Whether to check if the pool is paused\\n    /// @return amountOut   Amount of tokenTo received after the swap\\n    function getPoolQuote(\\n        address pool,\\n        IndexedToken memory tokenFrom,\\n        IndexedToken memory tokenTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) external view returns (uint256 amountOut);\\n\\n    /// @notice Returns the list of tokens in the pool. Tokens should be returned in the same order\\n    /// that is used by the pool for indexing.\\n    /// @dev Execution needs to be reverted, if pool tokens retrieval fails for any reason, e.g.\\n    /// if the given pool is not compatible with the Pool Module.\\n    /// @param pool         Address of the pool\\n    /// @return tokens      Array of tokens in the pool\\n    function getPoolTokens(address pool) external view returns (address[] memory tokens);\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/ILinkedPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ILinkedPool {\\n    /// @notice Wrapper for IDefaultPool.swap()\\n    /// @param tokenIndexFrom    the token the user wants to swap from\\n    /// @param tokenIndexTo      the token the user wants to swap to\\n    /// @param dx                the amount of tokens the user wants to swap from\\n    /// @param minDy             the min amount the user would like to receive, or revert.\\n    /// @param deadline          latest timestamp to accept this transaction\\n    /// @return amountOut        amount of tokens bought\\n    function swap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external returns (uint256 amountOut);\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Wrapper for IDefaultPool.calculateSwap()\\n    /// @param tokenIndexFrom    the token the user wants to sell\\n    /// @param tokenIndexTo      the token the user wants to buy\\n    /// @param dx                the amount of tokens the user wants to sell. If the token charges\\n    ///                          a fee on transfers, use the amount that gets transferred after the fee.\\n    /// @return amountOut        amount of tokens the user will receive\\n    function calculateSwap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 amountOut);\\n\\n    /// @notice Wrapper for IDefaultPool.getToken()\\n    /// @param index     the index of the token\\n    /// @return token    address of the token at given index\\n    function getToken(uint8 index) external view returns (address token);\\n\\n    /// @notice Checks if a path exists between the two tokens, using any of the supported pools.\\n    /// @dev This is used by SwapQuoterV2 to check if a path exists between two tokens using the LinkedPool.\\n    /// Note: this only checks if both tokens are present in the tree, but doesn't check if any of the pools\\n    /// connecting the two tokens are paused. This is done to enable caching of the result, the paused/duplicated\\n    /// pools will be discarded, when `findBestPath` is called to fetch the quote.\\n    /// @param tokenIn          Token address to begin from\\n    /// @param tokenOut         Token address to end up with\\n    /// @return areConnected    True if a path exists between the two tokens, false otherwise\\n    function areConnectedTokens(address tokenIn, address tokenOut) external view returns (bool areConnected);\\n\\n    /// @notice Returns the best path for swapping the given amount of tokens. All possible paths\\n    /// present in the internal tree are considered, if any of the tokens are present in the tree more than once.\\n    /// Note: paths that have the same pool more than once are not considered.\\n    /// @dev Will return zero values if no path is found.\\n    /// @param tokenIn          the token the user wants to sell\\n    /// @param tokenOut         the token the user wants to buy\\n    /// @param amountIn         the amount of tokens the user wants to sell\\n    /// @return tokenIndexFrom  the index of the token the user wants to sell\\n    /// @return tokenIndexTo    the index of the token the user wants to buy\\n    /// @return amountOut       amount of tokens the user will receive\\n    function findBestPath(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    )\\n        external\\n        view\\n        returns (\\n            uint8 tokenIndexFrom,\\n            uint8 tokenIndexTo,\\n            uint256 amountOut\\n        );\\n\\n    /// @notice Returns the full amount of the \\\"token nodes\\\" in the internal tree.\\n    /// Note that some of the tokens might be duplicated, as the node in the tree represents\\n    /// a given path frm the bridge token to the node token using a series of pools.\\n    function tokenNodesAmount() external view returns (uint256);\\n\\n    /// @notice Returns the list of pools that are \\\"attached\\\" to a node.\\n    /// Pool is attached to a node, if it connects the node to one of its children.\\n    /// Note: pool that is connecting the node to its parent is not considered attached.\\n    function getAttachedPools(uint8 index) external view returns (address[] memory pools);\\n\\n    /// @notice Returns the list of indexes that represent a given token in the tree.\\n    /// @dev Will return empty array for tokens that are not added to the tree.\\n    function getTokenIndexes(address token) external view returns (uint256[] memory indexes);\\n\\n    /// @notice Returns the pool module logic address, that is used to get swap quotes, token indexes and perform swaps.\\n    /// @dev Will return address(0) for pools that are not added to the tree.\\n    /// Will return address(this) for pools that conform to IDefaultPool interface.\\n    function getPoolModule(address pool) external view returns (address poolModule);\\n\\n    /// @notice Returns the index of a parent node for the given node, as well as the pool that connects the two nodes.\\n    /// @dev Will return zero values for the root node. Will revert if index is out of range.\\n    function getNodeParent(uint256 nodeIndex) external view returns (uint256 parentIndex, address parentPool);\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IDefaultPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IDefaultPool {\\n    function swap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external returns (uint256 amountOut);\\n\\n    function calculateSwap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 amountOut);\\n\\n    function getToken(uint8 index) external view returns (address token);\\n}\\n\"\r\n    },\r\n    \"contracts/router/libs/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13; // \\\"using A for B global\\\" requires 0.8.13 or higher\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 TOKEN AND POOL DESCRIPTION \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\\n/// @param token    Bridge token address\\nstruct BridgeToken {\\n    string symbol;\\n    address token;\\n}\\n\\n/// @notice Struct used by IPoolHandler to represent a token in a pool\\n/// @param index    Token index in the pool\\n/// @param token    Token address\\nstruct IndexedToken {\\n    uint8 index;\\n    address token;\\n}\\n\\n/// @notice Struct representing a token, and the available Actions for performing a swap.\\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\\n/// @param token        Token address\\nstruct LimitedToken {\\n    uint256 actionMask;\\n    address token;\\n}\\n\\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\\n/// @param isWeth   Whether the token represents Wrapped ETH.\\n/// @param token    Token address.\\nstruct PoolToken {\\n    bool isWeth;\\n    address token;\\n}\\n\\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\\n/// @param pool         Pool address.\\n/// @param lpToken      Address of pool's LP token.\\n/// @param tokens       List of pool's tokens.\\nstruct Pool {\\n    address pool;\\n    address lpToken;\\n    PoolToken[] tokens;\\n}\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ROUTER STRUCTS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing a quote request for swapping a bridge token.\\n/// Used in destination chain's SynapseRouter, hence the name \\\"Destination Request\\\".\\n/// @dev tokenOut is passed externally.\\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\\nstruct DestRequest {\\n    string symbol;\\n    uint256 amountIn;\\n}\\n\\n/// @notice Struct representing a swap request for SynapseRouter.\\n/// @dev tokenIn is supplied separately.\\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \\\"no swap\\\" query.\\n/// @param tokenOut         Token address to swap to.\\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\\n///                         Should be DefaultParams for swaps via DefaultAdapter.\\nstruct SwapQuery {\\n    address routerAdapter;\\n    address tokenOut;\\n    uint256 minAmountOut;\\n    uint256 deadline;\\n    bytes rawParams;\\n}\\n\\nusing SwapQueryLib for SwapQuery global;\\n\\nlibrary SwapQueryLib {\\n    /// @notice Checks whether the router adapter was specified in the query.\\n    /// Query without a router adapter specifies that no action needs to be taken.\\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\\n        return query.routerAdapter != address(0);\\n    }\\n\\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\\n    /// and if a path for this action was found.\\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\\n        // Fill the fields only if some path was found.\\n        if (query.minAmountOut == 0) return;\\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\\n        // Set default deadline to infinity. Not using the value of 0,\\n        // which would lead to every swap to revert by default.\\n        query.deadline = type(uint256).max;\\n    }\\n}\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ADAPTER STRUCTS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\\n/// @param action           Action that DefaultAdapter needs to perform.\\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\\nstruct DefaultParams {\\n    Action action;\\n    address pool;\\n    uint8 tokenIndexFrom;\\n    uint8 tokenIndexTo;\\n}\\n\\n/// @notice All possible actions that DefaultAdapter could perform.\\nenum Action {\\n    Swap, // swap between two pools tokens\\n    AddLiquidity, // add liquidity in a form of a single pool token\\n    RemoveLiquidity, // remove liquidity in a form of a single pool token\\n    HandleEth // ETH <> WETH interaction\\n}\\n\\nusing ActionLib for Action global;\\n\\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\\nlibrary ActionLib {\\n    /// @notice Returns a bitmask with all possible actions set to True.\\n    function allActions() internal pure returns (uint256 actionMask) {\\n        actionMask = type(uint256).max;\\n    }\\n\\n    /// @notice Returns whether the given action is set to True in the bitmask.\\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\\n        return actionMask & mask(action) != 0;\\n    }\\n\\n    /// @notice Returns a bitmask with only the given action set to True.\\n    function mask(Action action) internal pure returns (uint256) {\\n        return 1 << uint256(action);\\n    }\\n\\n    /// @notice Returns a bitmask with only two given actions set to True.\\n    function mask(Action a, Action b) internal pure returns (uint256) {\\n        return mask(a) | mask(b);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/libs/UniversalToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {TokenNotContract} from \\\"./Errors.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary UniversalTokenLib {\\n    using SafeERC20 for IERC20;\\n\\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\\n    /// Make sure this can not lead to reentrancy attacks.\\n    function universalTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // Don't do anything, if need to send tokens to this address\\n        if (to == address(this)) return;\\n        if (token == ETH_ADDRESS) {\\n            /// @dev Note: this can potentially lead to executing code in `to`.\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = to.call{value: value}(\\\"\\\");\\n            require(success, \\\"ETH transfer failed\\\");\\n        } else {\\n            IERC20(token).safeTransfer(to, value);\\n        }\\n    }\\n\\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\\n    /// to spend the given amount.\\n    function universalApproveInfinity(\\n        address token,\\n        address spender,\\n        uint256 amountToSpend\\n    ) internal {\\n        // ETH Chad doesn't require your approval\\n        if (token == ETH_ADDRESS) return;\\n        // No-op if allowance is already sufficient\\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\\n        if (allowance >= amountToSpend) return;\\n        // Otherwise, reset approval to 0 and set to max allowance\\n        if (allowance > 0) IERC20(token).safeApprove(spender, 0);\\n        IERC20(token).safeApprove(spender, type(uint256).max);\\n    }\\n\\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\\n        if (token == ETH_ADDRESS) {\\n            return account.balance;\\n        } else {\\n            return IERC20(token).balanceOf(account);\\n        }\\n    }\\n\\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\\n    function assertIsContract(address token) internal view {\\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\\n        // Check that token is not an EOA\\n        if (token.code.length == 0) revert TokenNotContract();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/tree/TokenTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// TokenTree implements the internal logic for storing a set of tokens in a rooted tree.\\n/// - Root node represents a Synapse-bridged token.\\n/// - The root token could not appear more than once in the tree.\\n/// - Other tree nodes represent tokens that are correlated with the root token.\\n/// - These other tokens could appear more than once in the tree.\\n/// - Every edge between a child and a parent node is associated with a single liquidity pool that contains both tokens.\\n/// - The tree is rooted => the root of the tree has a zero depth. A child node depth is one greater than its parent.\\n/// - Every node can have arbitrary amount of children.\\n/// - New nodes are added to the tree by \\\"attaching\\\" a pool to an existing node. This adds all the other pool tokens\\n/// as new children of the existing node (which represents one of the tokens from the pool).\\n/// - Pool could be only attached once to any given node. Pool could not be attached to a node, if it connects the node\\n/// with its parent.\\n/// - Pool could be potentially attached to two different nodes in the tree.\\n/// - By definition a tree has no cycles, so there exists only one path between any two nodes. Every edge on this path\\n/// represents a liquidity pool, and the whole path represents a series of swaps that lead from one token to another.\\n/// - Paths that contain a pool more than once are not allowed, and are not used for quotes/swaps. This is due to\\n/// the fact that it's impossible to get an accurate quote for the second swap through the pool in the same tx.\\n/// > This contract is only responsible for storing and traversing the tree. The swap/quote logic, as well as\\n/// > transformation of the inner tree into IDefaultPool interface is implemented in the child contract.\\nabstract contract TokenTree {\\n    error TokenTree__DifferentTokenLists();\\n    error TokenTree__IndexOutOfRange(uint256 index);\\n    error TokenTree__NodeTokenNotInPool();\\n    error TokenTree__PoolAlreadyAttached();\\n    error TokenTree__PoolAlreadyOnRootPath();\\n    error TokenTree__SwapPoolUsedTwice(address pool);\\n    error TokenTree__TooManyNodes();\\n    error TokenTree__TooManyPools();\\n    error TokenTree__UnknownPool();\\n\\n    event TokenNodeAdded(uint256 childIndex, address token, address parentPool);\\n    event PoolAdded(uint256 parentIndex, address pool, address poolModule);\\n    event PoolModuleUpdated(address pool, address oldPoolModule, address newPoolModule);\\n\\n    /// @notice Struct so store the tree nodes\\n    /// @param token        Address of the token represented by this node\\n    /// @param depth        Depth of the node in the tree\\n    /// @param poolIndex    Index of the pool that connects this node to its parent (0 if root)\\n    struct Node {\\n        address token;\\n        uint8 depth;\\n        uint8 poolIndex;\\n    }\\n\\n    /// @notice Struct to store the liquidity pools\\n    /// @dev Module address is used for delegate calls to get swap quotes, token indexes, etc.\\n    /// Set to address(this) if pool conforms to IDefaultPool interface. Set to 0x0 if pool is not supported.\\n    /// @param module       Address of the module contract for this pool\\n    /// @param index        Index of the pool in the `_pools` array\\n    struct Pool {\\n        address module;\\n        uint8 index;\\n    }\\n\\n    /// @notice Struct to get around stack too deep error\\n    /// @param from         Node representing the token we are swapping from\\n    /// @param to           Node representing the token we are swapping to\\n    struct Request {\\n        Node from;\\n        Node to;\\n        bool probePaused;\\n    }\\n\\n    /// @notice Struct to get around stack too deep error\\n    /// @param visitedPoolsMask     Bitmask of pools visited so far\\n    /// @param amountOut            Amount of tokens received so far\\n    struct Route {\\n        uint256 visitedPoolsMask;\\n        uint256 amountOut;\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 STORAGE \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    // The nodes of the tree are stored in an array. The root node is at index 0.\\n    Node[] internal _nodes;\\n\\n    // The list of all supported liquidity pools. All values are unique.\\n    address[] internal _pools;\\n\\n    // (pool address => pool description)\\n    mapping(address => Pool) internal _poolMap;\\n\\n    // (pool => token => tokenIndex) for each pool, stores the index of each token in the pool.\\n    mapping(address => mapping(address => uint8)) public tokenIndexes;\\n\\n    // (token => nodes) for each token, stores the indexes of all nodes that represent this token.\\n    mapping(address => uint256[]) internal _tokenNodes;\\n\\n    // The full path from every node to the root is stored using bitmasks in the following way:\\n    // - For a node with index i at depth N, lowest N + 1 bytes of _rootPath[i] are used to store the path to the root.\\n    // - The lowest byte is always the root index. This is always 0, but we store this for consistency.\\n    // - The highest byte is always the node index. This is always i, but we store this for consistency.\\n    // - The remaining bytes are indexes of the nodes on the path from the node to the root (from highest to lowest).\\n    // This way the finding the lowest common ancestor of two nodes is reduced to finding the lowest differing byte\\n    // in node's encoded root paths.\\n    uint256[] internal _rootPath;\\n\\n    // (node => bitmask with all attached pools to the node).\\n    // Note: This excludes the pool that connects the node to its parent.\\n    mapping(uint256 => uint256) internal _attachedPools;\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 CONSTRUCTOR \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    constructor(address bridgeToken) {\\n        // Push the empty pool so that `poolIndex` for non-root nodes is never 0\\n        _pools.push(address(0));\\n        // The root node is always the bridge token\\n        _addNode({token: bridgeToken, depth: 0, poolIndex: 0, rootPathParent: 0});\\n    }\\n\\n    modifier checkIndex(uint256 nodeIndex) {\\n        if (nodeIndex >= _nodes.length) revert TokenTree__IndexOutOfRange(nodeIndex);\\n        _;\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Adds a pool having `N` pool tokens to the tree by adding `N-1` new nodes\\n    /// as the children of the given node. Given node needs to represent a token from the pool.\\n    /// Note: assumes that nodeIndex is valid, and that pool is not a zero address.\\n    function _addPool(\\n        uint256 nodeIndex,\\n        address pool,\\n        address poolModule\\n    ) internal {\\n        Node memory node = _nodes[nodeIndex];\\n        if (poolModule == address(0)) poolModule = address(this);\\n        (bool wasAdded, uint8 poolIndex) = (false, _poolMap[pool].index);\\n        // Save the pool and emit an event if it's not been added before\\n        if (poolIndex == 0) {\\n            if (_pools.length > type(uint8).max) revert TokenTree__TooManyPools();\\n            // Can do the unsafe cast here, as we just checked that pool index fits into uint8\\n            poolIndex = uint8(_pools.length);\\n            _pools.push(pool);\\n            _poolMap[pool] = Pool({module: poolModule, index: poolIndex});\\n            wasAdded = true;\\n            emit PoolAdded(nodeIndex, pool, poolModule);\\n        } else {\\n            // Check if the existing pool could be added to the node. This enforces some sanity checks,\\n            // as well the invariant that any path from root to node doesn't contain the same pool twice.\\n            _checkPoolAddition(nodeIndex, node.depth, poolIndex);\\n        }\\n        // Remember that the pool is attached to the node\\n        _attachedPools[nodeIndex] |= 1 << poolIndex;\\n        address[] memory tokens = _getPoolTokens(poolModule, pool);\\n        uint256 numTokens = tokens.length;\\n        bool nodeFound = false;\\n        unchecked {\\n            uint8 childDepth = node.depth + 1;\\n            uint256 rootPathParent = _rootPath[nodeIndex];\\n            for (uint256 i = 0; i < numTokens; ++i) {\\n                address token = tokens[i];\\n                // Save token indexes if this is a new pool\\n                if (wasAdded) {\\n                    tokenIndexes[pool][token] = uint8(i);\\n                }\\n                // Add new nodes to the tree\\n                if (token == node.token) {\\n                    nodeFound = true;\\n                    continue;\\n                }\\n                _addNode(token, childDepth, poolIndex, rootPathParent);\\n            }\\n        }\\n        if (!nodeFound) revert TokenTree__NodeTokenNotInPool();\\n    }\\n\\n    /// @dev Adds a new node to the tree and saves its path to the root.\\n    function _addNode(\\n        address token,\\n        uint8 depth,\\n        uint8 poolIndex,\\n        uint256 rootPathParent\\n    ) internal {\\n        // Index of the newly inserted child node\\n        uint256 nodeIndex = _nodes.length;\\n        if (nodeIndex > type(uint8).max) revert TokenTree__TooManyNodes();\\n        // Don't add the bridge token (root) twice. This may happen if we add a new pool containing the bridge token\\n        // to a few existing nodes. E.g. we have old nUSD/USDC/USDT pool, and we add a new nUSD/USDC pool. In this case\\n        // we attach nUSD/USDC pool to root, and then attach old nUSD/USDC/USDT pool to the newly added USDC node\\n        // to enable nUSD -> USDC -> USDT swaps via new + old pools.\\n        if (_nodes.length > 0 && token == _nodes[0].token) {\\n            return;\\n        }\\n        _nodes.push(Node({token: token, depth: depth, poolIndex: poolIndex}));\\n        _tokenNodes[token].push(nodeIndex);\\n        // Push the root path for the new node. The root path is the inserted node index + the parent's root path.\\n        _rootPath.push((nodeIndex << (8 * depth)) | rootPathParent);\\n        emit TokenNodeAdded(nodeIndex, token, _pools[poolIndex]);\\n    }\\n\\n    /// @dev Updates the Pool Module for the given pool.\\n    /// Will revert, if the pool was not previously added, or if the new pool module produces a different list of tokens.\\n    function _updatePoolModule(address pool, address newPoolModule) internal {\\n        // Check that pool was previously added\\n        address oldPoolModule = _poolMap[pool].module;\\n        if (oldPoolModule == address(0)) revert TokenTree__UnknownPool();\\n        // Sanity check that pool modules produce the same list of tokens\\n        address[] memory oldTokens = _getPoolTokens(oldPoolModule, pool);\\n        address[] memory newTokens = _getPoolTokens(newPoolModule, pool);\\n        if (oldTokens.length != newTokens.length) revert TokenTree__DifferentTokenLists();\\n        for (uint256 i = 0; i < oldTokens.length; ++i) {\\n            if (oldTokens[i] != newTokens[i]) revert TokenTree__DifferentTokenLists();\\n        }\\n        // Update the pool module\\n        _poolMap[pool].module = newPoolModule;\\n        emit PoolModuleUpdated(pool, oldPoolModule, newPoolModule);\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC: MULTIPLE POOLS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Performs a multi-hop swap by following the path from \\\"tokenFrom\\\" node to \\\"tokenTo\\\" node\\n    /// in the stored tree. Token indexes are checked to be within range and not the same.\\n    /// Assumes that the initial token is already in this contract.\\n    function _multiSwap(\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn\\n    ) internal returns (Route memory route) {\\n        // Struct to get around stack too deep\\n        Request memory req = Request({from: _nodes[nodeIndexFrom], to: _nodes[nodeIndexTo], probePaused: false});\\n        uint256 rootPathFrom = _rootPath[nodeIndexFrom];\\n        uint256 rootPathTo = _rootPath[nodeIndexTo];\\n        // Find the depth where the paths diverge\\n        uint256 depthDiff = _depthDiff(rootPathFrom, rootPathTo);\\n        // Check if `nodeIndexTo` is an ancestor of `nodeIndexFrom`. True if paths diverge below `nodeIndexTo`.\\n        if (depthDiff > req.to.depth) {\\n            // Path from \\\"tokenFrom\\\" to root includes \\\"tokenTo\\\",\\n            // so we simply go from \\\"tokenFrom\\\" to \\\"tokenTo\\\" in the \\\"to root\\\" direction.\\n            return _multiSwapToRoot(0, rootPathFrom, req.from.depth, req.to.depth, amountIn);\\n        }\\n        // Check if `nodeIndexFrom` is an ancestor of `nodeIndexTo`. True if paths diverge below `nodeIndexFrom`.\\n        if (depthDiff > req.from.depth) {\\n            // Path from \\\"tokenTo\\\" to root includes \\\"tokenFrom\\\",\\n            // so we simply go from \\\"tokenTo\\\" to \\\"tokenFrom\\\" in the \\\"from root\\\" direction.\\n            return _multiSwapFromRoot(0, rootPathTo, req.from.depth, req.to.depth, amountIn);\\n        }\\n        // First, we traverse up the tree from \\\"tokenFrom\\\" to one level deeper the lowest common ancestor.\\n        route = _multiSwapToRoot(0, rootPathFrom, req.from.depth, depthDiff, amountIn);\\n        // Check if we need to do a sibling swap. When the two nodes are connected to the same parent via the same pool,\\n        // we do a direct swap between the two nodes, instead of doing two swaps through the parent using the same pool.\\n        uint256 lastNodeIndex = _extractNodeIndex(rootPathFrom, depthDiff);\\n        uint256 siblingIndex = _extractNodeIndex(rootPathTo, depthDiff);\\n        uint256 firstPoolIndex = _nodes[lastNodeIndex].poolIndex;\\n        uint256 secondPoolIndex = _nodes[siblingIndex].poolIndex;\\n        if (firstPoolIndex == secondPoolIndex) {\\n            // Swap lastNode -> sibling\\n            (route.visitedPoolsMask, route.amountOut) = _singleSwap(\\n                route.visitedPoolsMask,\\n                firstPoolIndex,\\n                lastNodeIndex,\\n                siblingIndex,\\n                route.amountOut\\n            );\\n        } else {\\n            // Swap lastNode -> parent\\n            uint256 parentIndex = _extractNodeIndex(rootPathFrom, depthDiff - 1);\\n            (route.visitedPoolsMask, route.amountOut) = _singleSwap(\\n                route.visitedPoolsMask,\\n                firstPoolIndex,\\n                lastNodeIndex,\\n                parentIndex,\\n                route.amountOut\\n            );\\n            // Swap parent -> sibling\\n            (route.visitedPoolsMask, route.amountOut) = _singleSwap(\\n                route.visitedPoolsMask,\\n                secondPoolIndex,\\n                parentIndex,\\n                siblingIndex,\\n                route.amountOut\\n            );\\n        }\\n        // Finally, we traverse down the tree from the lowest common ancestor to \\\"tokenTo\\\".\\n        return _multiSwapFromRoot(route.visitedPoolsMask, rootPathTo, depthDiff, req.to.depth, route.amountOut);\\n    }\\n\\n    /// @dev Performs a multi-hop swap, going in \\\"from root direction\\\" (where depth increases)\\n    /// via the given `rootPath` from `depthFrom` to `depthTo`.\\n    /// Assumes that the initial token is already in this contract.\\n    function _multiSwapFromRoot(\\n        uint256 visitedPoolsMask,\\n        uint256 rootPath,\\n        uint256 depthFrom,\\n        uint256 depthTo,\\n        uint256 amountIn\\n    ) internal returns (Route memory route) {\\n        uint256 nodeIndex = _extractNodeIndex(rootPath, depthFrom);\\n        // Traverse down the tree following `rootPath` from `depthFrom` to `depthTo`.\\n        for (uint256 depth = depthFrom; depth < depthTo; ) {\\n            // Get the child node\\n            unchecked {\\n                ++depth;\\n            }\\n            uint256 childIndex = _extractNodeIndex(rootPath, depth);\\n            // Swap node -> child\\n            (visitedPoolsMask, amountIn) = _singleSwap(\\n                visitedPoolsMask,\\n                _nodes[childIndex].poolIndex,\\n                nodeIndex,\\n                childIndex,\\n                amountIn\\n            );\\n            nodeIndex = childIndex;\\n        }\\n        route.visitedPoolsMask = visitedPoolsMask;\\n        route.amountOut = amountIn;\\n    }\\n\\n    /// @dev Performs a multi-hop swap, going in \\\"to root direction\\\" (where depth decreases)\\n    /// via the given `rootPath` from `depthFrom` to `depthTo`.\\n    /// Assumes that the initial token is already in this contract.\\n    function _multiSwapToRoot(\\n        uint256 visitedPoolsMask,\\n        uint256 rootPath,\\n        uint256 depthFrom,\\n        uint256 depthTo,\\n        uint256 amountIn\\n    ) internal returns (Route memory route) {\\n        uint256 nodeIndex = _extractNodeIndex(rootPath, depthFrom);\\n        // Traverse up the tree following `rootPath` from `depthFrom` to `depthTo`.\\n        for (uint256 depth = depthFrom; depth > depthTo; ) {\\n            // Get the parent node\\n            unchecked {\\n                --depth; // depth > 0 so we can do unchecked math\\n            }\\n            uint256 parentIndex = _extractNodeIndex(rootPath, depth);\\n            // Swap node -> parent\\n            (visitedPoolsMask, amountIn) = _singleSwap(\\n                visitedPoolsMask,\\n                _nodes[nodeIndex].poolIndex,\\n                nodeIndex,\\n                parentIndex,\\n                amountIn\\n            );\\n            nodeIndex = parentIndex;\\n        }\\n        route.visitedPoolsMask = visitedPoolsMask;\\n        route.amountOut = amountIn;\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC: SINGLE POOL \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Performs a single swap between two nodes using the given pool.\\n    /// Assumes that the initial token is already in this contract.\\n    function _poolSwap(\\n        address poolModule,\\n        address pool,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn\\n    ) internal virtual returns (uint256 amountOut);\\n\\n    /// @dev Performs a single swap between two nodes using the given pool given the set of pools\\n    /// we have already used on the path. Returns the updated set of pools and the amount of tokens received.\\n    /// Assumes that the initial token is already in this contract.\\n    function _singleSwap(\\n        uint256 visitedPoolsMask,\\n        uint256 poolIndex,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn\\n    ) internal returns (uint256 visitedPoolsMask_, uint256 amountOut) {\\n        address pool = _pools[poolIndex];\\n        // If we already used this pool on the path, we can't use it again.\\n        if (visitedPoolsMask & (1 << poolIndex) != 0) revert TokenTree__SwapPoolUsedTwice(pool);\\n        // Mark the pool as visited\\n        visitedPoolsMask_ = visitedPoolsMask | (1 << poolIndex);\\n        amountOut = _poolSwap(_poolMap[pool].module, pool, nodeIndexFrom, nodeIndexTo, amountIn);\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL VIEWS: MULTIPLE POOLS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Calculates the multi-hop swap quote by following the path from \\\"tokenFrom\\\" node to \\\"tokenTo\\\" node\\n    /// in the stored tree. Token indexes are checked to be within range and not the same.\\n    function _getMultiSwapQuote(\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view returns (Route memory route) {\\n        // Struct to get around stack too deep\\n        Request memory req = Request({from: _nodes[nodeIndexFrom], to: _nodes[nodeIndexTo], probePaused: probePaused});\\n        uint256 rootPathFrom = _rootPath[nodeIndexFrom];\\n        uint256 rootPathTo = _rootPath[nodeIndexTo];\\n        // Find the depth where the paths diverge\\n        uint256 depthDiff = _depthDiff(rootPathFrom, rootPathTo);\\n        // Check if `nodeIndexTo` is an ancestor of `nodeIndexFrom`. True if paths diverge below `nodeIndexTo`.\\n        if (depthDiff > req.to.depth) {\\n            // Path from \\\"tokenFrom\\\" to root includes \\\"tokenTo\\\",\\n            // so we simply go from \\\"tokenFrom\\\" to \\\"tokenTo\\\" in the \\\"to root\\\" direction.\\n            return _getMultiSwapToRootQuote(0, rootPathFrom, req.from.depth, req.to.depth, amountIn, probePaused);\\n        }\\n        // Check if `nodeIndexFrom` is an ancestor of `nodeIndexTo`. True if paths diverge below `nodeIndexFrom`.\\n        if (depthDiff > req.from.depth) {\\n            // Path from \\\"tokenTo\\\" to root includes \\\"tokenFrom\\\",\\n            // so we simply go from \\\"tokenTo\\\" to \\\"tokenFrom\\\" in the \\\"from root\\\" direction.\\n            return _getMultiSwapFromRootQuote(0, rootPathTo, req.from.depth, req.to.depth, amountIn, probePaused);\\n        }\\n        // First, we traverse up the tree from \\\"tokenFrom\\\" to one level deeper the lowest common ancestor.\\n        route = _getMultiSwapToRootQuote(\\n            route.visitedPoolsMask,\\n            rootPathFrom,\\n            req.from.depth,\\n            depthDiff,\\n            amountIn,\\n            req.probePaused\\n        );\\n        // Check if we need to do a sibling swap. When the two nodes are connected to the same parent via the same pool,\\n        // we do a direct swap between the two nodes, instead of doing two swaps through the parent using the same pool.\\n        uint256 lastNodeIndex = _extractNodeIndex(rootPathFrom, depthDiff);\\n        uint256 siblingIndex = _extractNodeIndex(rootPathTo, depthDiff);\\n        uint256 firstPoolIndex = _nodes[lastNodeIndex].poolIndex;\\n        uint256 secondPoolIndex = _nodes[siblingIndex].poolIndex;\\n        if (firstPoolIndex == secondPoolIndex) {\\n            // Swap lastNode -> sibling\\n            (route.visitedPoolsMask, route.amountOut) = _getSingleSwapQuote(\\n                route.visitedPoolsMask,\\n                firstPoolIndex,\\n                lastNodeIndex,\\n                siblingIndex,\\n                route.amountOut,\\n                req.probePaused\\n            );\\n        } else {\\n            // Swap lastNode -> parent\\n            uint256 parentIndex = _extractNodeIndex(rootPathFrom, depthDiff - 1);\\n            (route.visitedPoolsMask, route.amountOut) = _getSingleSwapQuote(\\n                route.visitedPoolsMask,\\n                firstPoolIndex,\\n                lastNodeIndex,\\n                parentIndex,\\n                route.amountOut,\\n                req.probePaused\\n            );\\n            // Swap parent -> sibling\\n            (route.visitedPoolsMask, route.amountOut) = _getSingleSwapQuote(\\n                route.visitedPoolsMask,\\n                secondPoolIndex,\\n                parentIndex,\\n                siblingIndex,\\n                route.amountOut,\\n                req.probePaused\\n            );\\n        }\\n        // Finally, we traverse down the tree from the lowest common ancestor to \\\"tokenTo\\\".\\n        return\\n            _getMultiSwapFromRootQuote(\\n                route.visitedPoolsMask,\\n                rootPathTo,\\n                depthDiff,\\n                req.to.depth,\\n                route.amountOut,\\n                req.probePaused\\n            );\\n    }\\n\\n    /// @dev Calculates the amount of tokens that will be received from a multi-hop swap,\\n    /// going in \\\"from root direction\\\" (where depth increases) via the given `rootPath` from `depthFrom` to `depthTo`.\\n    function _getMultiSwapFromRootQuote(\\n        uint256 visitedPoolsMask,\\n        uint256 rootPath,\\n        uint256 depthFrom,\\n        uint256 depthTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view returns (Route memory route) {\\n        uint256 nodeIndex = _extractNodeIndex(rootPath, depthFrom);\\n        // Traverse down the tree following `rootPath` from `depthFrom` to `depthTo`.\\n        for (uint256 depth = depthFrom; depth < depthTo; ) {\\n            // Get the child node\\n            unchecked {\\n                ++depth;\\n            }\\n            uint256 childIndex = _extractNodeIndex(rootPath, depth);\\n            // Swap node -> child\\n            (visitedPoolsMask, amountIn) = _getSingleSwapQuote(\\n                visitedPoolsMask,\\n                _nodes[childIndex].poolIndex,\\n                nodeIndex,\\n                childIndex,\\n                amountIn,\\n                probePaused\\n            );\\n            nodeIndex = childIndex;\\n        }\\n        route.visitedPoolsMask = visitedPoolsMask;\\n        route.amountOut = amountIn;\\n    }\\n\\n    /// @dev Calculates the amount of tokens that will be received from a multi-hop swap,\\n    /// going in \\\"to root direction\\\" (where depth decreases) via the given `rootPath` from `depthFrom` to `depthTo`.\\n    function _getMultiSwapToRootQuote(\\n        uint256 visitedPoolsMask,\\n        uint256 rootPath,\\n        uint256 depthFrom,\\n        uint256 depthTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view returns (Route memory route) {\\n        uint256 nodeIndex = _extractNodeIndex(rootPath, depthFrom);\\n        // Traverse up the tree following `rootPath` from `depthFrom` to `depthTo`.\\n        for (uint256 depth = depthFrom; depth > depthTo; ) {\\n            // Get the parent node\\n            unchecked {\\n                --depth; // depth > 0 so we can do unchecked math\\n            }\\n            uint256 parentIndex = _extractNodeIndex(rootPath, depth);\\n            // Swap node -> parent\\n            (visitedPoolsMask, amountIn) = _getSingleSwapQuote(\\n                visitedPoolsMask,\\n                _nodes[nodeIndex].poolIndex,\\n                nodeIndex,\\n                parentIndex,\\n                amountIn,\\n                probePaused\\n            );\\n            nodeIndex = parentIndex;\\n        }\\n        route.visitedPoolsMask = visitedPoolsMask;\\n        route.amountOut = amountIn;\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL VIEWS: SINGLE POOL \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Returns the tokens in the pool at the given address.\\n    function _getPoolTokens(address poolModule, address pool) internal view virtual returns (address[] memory tokens);\\n\\n    /// @dev Returns the amount of tokens that will be received from a single swap.\\n    /// Will check if the pool is paused beforehand, if requested.\\n    function _getPoolQuote(\\n        address poolModule,\\n        address pool,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view virtual returns (uint256 amountOut);\\n\\n    /// @dev Calculates the amount of tokens that will be received from a single swap given the set of pools\\n    /// we have already used on the path. Returns the updated set of pools and the amount of tokens received.\\n    function _getSingleSwapQuote(\\n        uint256 visitedPoolsMask,\\n        uint256 poolIndex,\\n        uint256 nodeIndexFrom,\\n        uint256 nodeIndexTo,\\n        uint256 amountIn,\\n        bool probePaused\\n    ) internal view returns (uint256 visitedPoolsMask_, uint256 amountOut) {\\n        if (visitedPoolsMask & (1 << poolIndex) != 0) {\\n            // If we already used this pool on the path, we can't use it again.\\n            // Return the full mask and zero amount to indicate that the swap is not possible.\\n            return (type(uint256).max, 0);\\n        }\\n        // Otherwise, mark the pool as visited\\n        visitedPoolsMask_ = visitedPoolsMask | (1 << poolIndex);\\n        address pool = _pools[poolIndex];\\n        // Pass the parameter for whether we want to check that the pool is paused or not.\\n        amountOut = _getPoolQuote(_poolMap[pool].module, pool, nodeIndexFrom, nodeIndexTo, amountIn, probePaused);\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 HELPERS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Checks if a pool could be added to the tree at the given node. Requirements:\\n    /// - Pool is not already attached to the node: no need to add twice.\\n    /// - Pool is not present on the path from the node to root: this would invalidate swaps from added nodes to root,\\n    /// as this path would contain this pool twice.\\n    function _checkPoolAddition(\\n        uint256 nodeIndex,\\n        uint256 nodeDepth,\\n        uint8 poolIndex\\n    ) internal view {\\n        // Check that the pool is not already attached to the node\\n        if (_attachedPools[nodeIndex] & (1 << poolIndex) != 0) revert TokenTree__PoolAlreadyAttached();\\n        // Here we iterate over all nodes from the root to the node, and check that the pool connecting the current node\\n        // to its parent is not the pool we want to add. We skip the root node (depth 0), as it has no parent.\\n        uint256 rootPath = _rootPath[nodeIndex];\\n        for (uint256 d = 1; d <= nodeDepth; ) {\\n            uint256 nodeIndex_ = _extractNodeIndex(rootPath, d);\\n            if (_nodes[nodeIndex_].poolIndex == poolIndex) revert TokenTree__PoolAlreadyOnRootPath();\\n            unchecked {\\n                ++d;\\n            }\\n        }\\n    }\\n\\n    /// @dev Finds the lowest common ancestor of two different nodes in the tree.\\n    /// Node is defined by the path from the root to the node, and the depth of the node.\\n    function _depthDiff(uint256 rootPath0, uint256 rootPath1) internal pure returns (uint256 depthDiff) {\\n        // Xor the paths to get the first differing byte.\\n        // Nodes are different => root paths are different => the result is never zero.\\n        rootPath0 ^= rootPath1;\\n        // Sanity check for invariant: rootPath0 != rootPath1\\n        assert(rootPath0 != 0);\\n        // Traverse from root to node0 and node1 until the paths diverge.\\n        while ((rootPath0 & 0xFF) == 0) {\\n            // Shift off the lowest byte which are identical in both paths.\\n            rootPath0 >>= 8;\\n            unchecked {\\n                depthDiff++;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the index of the node at the given depth on the path from the root to the node.\\n    function _extractNodeIndex(uint256 rootPath, uint256 depth) internal pure returns (uint256 nodeIndex) {\\n        // Nodes on the path are stored from root to node (lowest to highest bytes).\\n        return (rootPath >> (8 * depth)) & 0xFF;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/libs/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nerror DeadlineExceeded();\\nerror InsufficientOutputAmount();\\n\\nerror MsgValueIncorrect();\\nerror PoolNotFound();\\nerror TokenAddressMismatch();\\nerror TokenNotContract();\\nerror TokenNotETH();\\nerror TokensIdentical();\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@boringcrypto/=node_modules/@boringcrypto/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"sol-explore/=node_modules/sol-explore/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"synthetix/=node_modules/synthetix/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"LinkedPool__DeadlineExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedPool__EmptyPoolAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"LinkedPool__EqualSwapIndexes\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"}],\"name\":\"LinkedPool__MinDyNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__DifferentTokenLists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"TokenTree__IndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__NodeTokenNotInPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__PoolAlreadyAttached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__PoolAlreadyOnRootPath\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"TokenTree__SwapPoolUsedTwice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__TooManyNodes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__TooManyPools\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTree__UnknownPool\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolModule\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPoolModule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPoolModule\",\"type\":\"address\"}],\"name\":\"PoolModuleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parentPool\",\"type\":\"address\"}],\"name\":\"TokenNodeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"soldId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"boughtId\",\"type\":\"uint128\"}],\"name\":\"TokenSwap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nodeIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolModule\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"areConnectedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"areConnected\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"nodeIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nodeIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"findBestPath\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"nodeIndexFromBest\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nodeIndexToBest\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountOutBest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getAttachedPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nodeIndex\",\"type\":\"uint256\"}],\"name\":\"getNodeParent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"parentIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parentPool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getPoolModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenIndexes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nodes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"nodeIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nodeIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenIndexes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenNodesAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPoolModule\",\"type\":\"address\"}],\"name\":\"updatePoolModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LinkedPool", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000fea3e5840334fc758a3decf14546bfdfbef5cd3", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a20dd8a538f2931dec0e2eef157073d30e5f0ec670efe8c0a9eae66158114485"}