{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// \ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\r\n// Author: tycoon.eth\r\n// \ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\ud83c\udf54\r\npragma solidity ^0.8.19;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\n/**\r\n\r\nThe Stogies token\r\n\r\nWhat are Stogies?\r\n\r\nAn ERC20 token that wraps the CIG/ETH SushiSwap Liquidity Pool (SLP)\r\ntoken, for meme-ability and ease of use. Each Stogie represents a share of the\r\nETH & CIG reserves stored at 0x22b15c7ee1186a7c7cffb2d942e20fc228f6e4ed.\r\n\r\nTo work out how much is a Stogie worth, add the values of ETH and CIG in the\r\npool, and divide them by the total supply of the SLP token.\r\nFor example, if there are $100 worth of CIG and $100 worth of ETH in the pool,\r\nand the total supply of the SLP token is 1000, then each token would be worth\r\n(100+100)/1000 = 0.2, or 20 cents. Note that the SLP tokens do not have a capped\r\nsupply and new tokens can be minted by anyone, by adding more CIG & ETH to the\r\npool. This means that Stogies are not capped, only limited by the amount of ETH\r\nand CIG can practically be added to the pool. For the Solidity devs, you can\r\nread stogies.sol for the implementation of Stogies.\r\n\r\n\r\n*/\r\n\r\n\r\ncontract Stogie {\r\n    ICigToken private immutable cig;           // 0xCB56b52316041A62B6b5D0583DcE4A8AE7a3C629\r\n    ILiquidityPool private immutable cigEthSLP;// 0x22b15c7ee1186a7c7cffb2d942e20fc228f6e4ed (SLP, it's also an ERC20)\r\n    address private immutable weth;            // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    IV2Router private immutable sushiRouter;   // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n    IV2Router private immutable uniswapRouter; // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    uint8 internal locked = 1;                 // reentrancy guard. 2 = entered, 1 not\r\n    bytes32 public DOMAIN_SEPARATOR;           // EIP-2612 permit functionality\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;    // EIP-2612 permit functionality\r\n    IIDBadges private immutable badges;        // id badges erc721 0xED9a438bD8E2F0e3F0Feb4DD397cBA4274609DBe\r\n    modifier notReentrant() { // notReentrant is a reentrancy guard\r\n        require(locked == 1, \"already entered\");\r\n        locked = 2; // enter\r\n        _;\r\n        locked = 1; // exit\r\n    }\r\n    constructor(\r\n        address _cig,          // 0xCB56b52316041A62B6b5D0583DcE4A8AE7a3C629\r\n        address _cigEthSLP,    // 0x22b15c7ee1186a7c7cffb2d942e20fc228f6e4ed\r\n        address _sushiRouter,  // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n        address _uniswapRouter,// 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        address _weth,         // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n        address _badges        // 0xED9a438bD8E2F0e3F0Feb4DD397cBA4274609DBe\r\n    ) {\r\n        cig = ICigToken(_cig);\r\n        cigEthSLP = ILiquidityPool(_cigEthSLP);\r\n        sushiRouter = IV2Router(_sushiRouter);\r\n        uniswapRouter = IV2Router(_uniswapRouter);\r\n        weth = _weth;\r\n        badges = IIDBadges(_badges);\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        ); // EIP-2612\r\n        address r = address(sushiRouter);\r\n        cig.approve(r, type(uint256).max);                          // approve Sushi to use all of our CIG\r\n        IERC20(weth).approve(r, type(uint256).max);                 // approve Sushi to use all of our WETH\r\n        IERC20(cigEthSLP).approve(r, type(uint256).max);            // approve Sushi to use all of our CIG/ETH SLP\r\n        cigEthSLP.approve(address(cig), type(uint256).max);         // approve CIG to use all of our CIG/ETH SLP\r\n    }\r\n\r\n    /**\r\n    * @dev permit is eip-2612 compliant\r\n    */\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, 'Stogie: permit expired');\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(abi.encode(\r\n                        PERMIT_TYPEHASH,\r\n                        owner,\r\n                        spender,\r\n                        value,\r\n                        nonces[owner]++,\r\n                        deadline)\r\n                    )\r\n                )\r\n            );\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, 'Stogie: INVALID_SIGNATURE');\r\n            _approve(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Sending ETH to this contract will automatically issue Stogies and stake them\r\n    *    it will also issue a badge to the user. Can only be used by addresses that\r\n    *    have not minted. Limited yp 1 ETH or less.\r\n    */\r\n    receive() external payable {\r\n        require(msg.value <= 1 ether, \"Too much ETH\");\r\n        bool mintID = (badges.minters(msg.sender) == 0);\r\n        onboard(msg.sender, 1, true, mintID);\r\n    }\r\n\r\n    /**\r\n    * @dev depositWithETH is used to enter CIG/ETH SLP, wrap to STOG, then stake the STOG\r\n    *   sending ETH to this function will sell ETH to get an equal portion of CIG, then\r\n    *   place both CIG and WETH to the CIG/ETH SLP.\r\n    * @param _amountCigMin - Minimum CIG expected from swapping ETH portion\r\n    * @param _deadline - Future timestamp, when to give up\r\n    * @param _transferSurplus - should the dust be refunded? May cost more gas\r\n    * @param _mintId mint a badge NFT for the msg.sender?\r\n    */\r\n    function depositWithETH(\r\n        uint256 _amountCigMin,\r\n        uint64 _deadline,\r\n        bool _transferSurplus,\r\n        bool _mintId\r\n    ) external payable returns( /* don't need notReentrant */\r\n        uint[] memory swpAmt, uint cigAdded, uint ethAdded, uint liquidity\r\n    ) {\r\n        require(msg.value > 0, \"no ETH sent\");\r\n        IWETH(weth).deposit{value:msg.value}(); // wrap ETH to WETH\r\n        (swpAmt, cigAdded, ethAdded, liquidity) = _depositSingleSide(\r\n            weth,\r\n            msg.value,\r\n            _amountCigMin,\r\n            _deadline,\r\n            _transferSurplus\r\n        );\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);         // mint nft\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev depositWithWETH is used to enter CIG/ETH SLP, wrap to STOG, then stake the STOG\r\n    *   This function will sell WETH to get an equal portion of CIG, then\r\n    *   place both CIG and WETH to the CIG/ETH SLP.\r\n    * @param _amount - How much WETH to use, assuming approved before\r\n    * @param _amountCigMin - Minimum CIG expected from swapping ETH portion\r\n    * @param _deadline - Future timestamp, when to give up\r\n    * @param _transferSurplus - Should the dust be refunded? May cost more gas\r\n    * @param _mintId mint a badge NFT for the msg.sender?\r\n    */\r\n    function depositWithWETH(\r\n        uint256 _amount,\r\n        uint256 _amountCigMin,\r\n        uint64 _deadline,\r\n        bool _transferSurplus,\r\n        bool _mintId\r\n    ) external payable returns( /* don't need notReentrant */\r\n        uint[] memory swpAmt, uint cigAdded, uint ethAdded, uint liquidity\r\n    ) {\r\n        require(_amount > 0, \"no WETH sent\");\r\n        _ERC20TransferFrom(\r\n            IERC20(weth),\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        ); // take their WETH\r\n        (swpAmt, cigAdded, ethAdded, liquidity) = _depositSingleSide(\r\n            weth,\r\n            _amount,\r\n            _amountCigMin,\r\n            _deadline,\r\n            _transferSurplus\r\n        );\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);           // mint nft\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev depositWithToken is used to enter CIG/ETH SLP, wrap to STOG, then\r\n    *   stake the STOG.\r\n    *   This function will sell a token to get WETH, then sell a portion of WETH\r\n    *   to get an equal portion of CIG, then stake, by placeing both CIG and\r\n    *   WETH to the CIG/ETH SLP.\r\n    * @param _amount - How much token to use, assuming approved before\r\n    * @param _amountCigMin - Minimum CIG expected from swapping ETH portion\r\n    *   (final output swap)\r\n    * @param _amountWethMin - Minimum WETH expected from swapping _token\r\n    *   (1st hop swap)\r\n    * @param _token address of the token we are entering in with\r\n    * @param _router address of router to use (Sushi or Uniswap)\r\n    * @param _deadline - Future timestamp, when to give up\r\n    * @param _transferSurplus - Should the dust be refunded? May cost more gas\r\n    * @param _mintId mint a badge NFT for the msg.sender?\r\n    */\r\n    function depositWithToken(\r\n        uint256 _amount,\r\n        uint256 _amountCigMin,\r\n        uint256 _amountWethMin,\r\n        address _token,\r\n        address _router,\r\n        uint64 _deadline,\r\n        bool _transferSurplus,\r\n        bool _mintId\r\n    ) external payable notReentrant returns(\r\n        uint[] memory swpAmt, uint cigAdded, uint ethAdded, uint liquidity\r\n    ) {\r\n        require(\r\n            (_token != weth) && (_token != address(cig)),\r\n            \"must not be WETH or CIG\"\r\n        );\r\n        require(_amount > 0, \"no token sent\");\r\n        _ERC20TransferFrom(\r\n            IERC20(_token),\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        ); // take their token\r\n        swpAmt = _swapTokenToWETH(_amount, _amountWethMin, _router, _token, _deadline);\r\n        // now we have WETH\r\n        (swpAmt, cigAdded, ethAdded, liquidity) = _depositSingleSide(\r\n            weth,\r\n            swpAmt[1],\r\n            _amountCigMin,\r\n            _deadline,\r\n            _transferSurplus\r\n        );\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);           // mint nft\r\n        }\r\n    }\r\n\r\n    /**\r\n    * swap all tokens to WETH. Internal function used when depositing with token\r\n    *    other than CIG or WETH\r\n    */\r\n    function _swapTokenToWETH(\r\n        uint256 _amount,\r\n        uint256 _amountWethMin,\r\n        address _router,\r\n        address _token,\r\n        uint64 _deadline\r\n    ) internal returns (uint[] memory swpAmt) {\r\n        IV2Router r;\r\n        if (_router == address(uniswapRouter)) {\r\n            r = IV2Router(uniswapRouter);                   // use Uniswap for intermediate swap\r\n        } else {\r\n            r = sushiRouter;\r\n        }\r\n        if (IERC20(_token).allowance(address(this), address(r)) < _amount) {\r\n            IERC20(_token).approve(\r\n                address(r), type(uint256).max\r\n            );                                              // unlimited approval\r\n        }\r\n        // swap the _token to WETH\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = _token;\r\n        path[1] = weth;\r\n        swpAmt = r.swapExactTokensForTokens(\r\n            _amount,\r\n            _amountWethMin,                                 // min ETH that must be received\r\n            path,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        return swpAmt;\r\n    }\r\n\r\n    /**\r\n    * @dev deposit with CIG single side liquidity\r\n    * @param _amount in CIG to deposit\r\n    * @param _amountWethMin minimum CIG we expect to get\r\n    * @param _deadline - Future timestamp, when to give up\r\n    * @param _transferSurplus - Should the dust be refunded? May cost more gas\r\n    * @param _mintId mint a badge NFT for the msg.sender?\r\n    */\r\n    function depositWithCIG(\r\n        uint256 _amount,\r\n        uint256 _amountWethMin,\r\n        uint64 _deadline,\r\n        bool _transferSurplus,\r\n        bool _mintId\r\n    ) external payable notReentrant returns(\r\n        uint[] memory swpAmt, uint cigAdded, uint ethAdded, uint liquidity\r\n    ) {\r\n        cig.transferFrom(msg.sender, address(this), _amount); // take their CIG\r\n        (swpAmt, cigAdded, ethAdded, liquidity) = _depositSingleSide(\r\n            address(cig),\r\n            _amount,\r\n            _amountWethMin,\r\n            _deadline,\r\n            _transferSurplus\r\n        );\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);                       // mint nft\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param _amountOutMin if the fromToken is CIG, _amountOutMin is min ETH we\r\n    *   must get after swapping from CIG.\r\n    *   if fromToken is WETH, _amountOutMin is min CIG we must get, after\r\n    *   swapping WETH.\r\n    *   if fromToken is CIG, _amountOutMin is min WETH we must get, after\r\n    *   swapping the token to WETH.\r\n    */\r\n    function _depositSingleSide(\r\n        address _fromToken,\r\n        uint256 _amount,\r\n        uint256 _amountOutMin,\r\n        uint64 _deadline,\r\n        bool _transferSurplus\r\n    ) internal returns(\r\n        uint[] memory swpAmt, uint addedA, uint addedB, uint liquidity\r\n    ) {\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        uint112 r; // reserve\r\n        if (_fromToken == address(cig)) {\r\n            (,r,) = cigEthSLP.getReserves();           // _reserve1 is CIG\r\n            path[0] = _fromToken;\r\n            path[1] = weth;\r\n        } else if (_fromToken == weth) {\r\n            (r,,) = cigEthSLP.getReserves();           // _reserve0 is ETH\r\n            path[0] = weth;\r\n            path[1] = address(cig);                    // swapping a portion to CIG\r\n        } else {\r\n            revert(\"invalid token\");\r\n        }\r\n        uint256 a = _getSwapAmount(_amount, r);        // amount to swap to get equal amounts\r\n        /*\r\n        Swap \"a\" amount of path[0] for path[1] to get equal portions.\r\n        */\r\n        swpAmt = sushiRouter.swapExactTokensForTokens(\r\n            a,\r\n            _amountOutMin,                             // min amount that must be received\r\n            path,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        uint256 token0Amt = _amount - swpAmt[0];       // how much of IERC20(path[0]) we have left\r\n        (addedA, addedB, liquidity) = sushiRouter.addLiquidity(\r\n            path[0],\r\n            path[1],\r\n            token0Amt,                                 // Amt of the single-side token\r\n            swpAmt[1],                                 // Amt received from the swap\r\n            1,                                         // we've already checked slippage\r\n            1,                                         // ditto\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        _wrap(address(this), address(this), liquidity);// wrap our liquidity to Stogie\r\n        /* update user's account of STOG, so they can withdraw it later */\r\n        _addStake(msg.sender, liquidity);              // update the user's account\r\n        if (!_transferSurplus) {\r\n            return (swpAmt, addedA, addedB, liquidity);\r\n        }\r\n        uint temp;\r\n        if (token0Amt > addedA) {\r\n            unchecked{temp = token0Amt - addedA;}\r\n            _ERC20Transfer(\r\n                IERC20(_fromToken),\r\n                msg.sender,\r\n                temp);                                 // send surplus token back\r\n        }\r\n        if (swpAmt[1] > addedB) {\r\n            unchecked{temp = swpAmt[1] - addedB;}\r\n            IERC20(path[1]).transfer(\r\n                msg.sender,\r\n                temp);                                 // send surplus token1 back\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev mint STOG using CIG and WETH\r\n    * @param _amountCIG - amount of CIG we want to add\r\n    * @param _amountWETH - amount of WETH we want to add\r\n    * @param _amountCIGMin - minimum CIG that will be tolerated\r\n    * @param _amountWETHMin - minimum WETH that will be tolerated\r\n    * @param _deadline - timestamp when to expire\r\n    * @param _transferSurplus - send back any change?\r\n    * @param _mintId - mint a badge NFT?\r\n    */\r\n    function depositCigWeth(\r\n        uint256 _amountCIG,\r\n        uint256 _amountWETH,\r\n        uint256 _amountCIGMin,\r\n        uint256 _amountWETHMin,\r\n        uint64 _deadline,\r\n        bool _transferSurplus,\r\n        bool _mintId\r\n    ) external returns(\r\n        uint cigAdded, uint ethAdded, uint liquidity)\r\n    {\r\n        IERC20(cig).transferFrom(msg.sender, address(this), _amountCIG);\r\n        IERC20(weth).transferFrom(msg.sender, address(this), _amountWETH);\r\n        (cigAdded, ethAdded, liquidity) = sushiRouter.addLiquidity(\r\n            address(cig),\r\n            weth,\r\n            _amountCIG,                                  // CIG\r\n            _amountWETH,                                 // WETH amount\r\n            _amountCIGMin,                               // minimum CIG to get\r\n            _amountWETHMin,                              // minimum WETH to get\r\n            address(this),\r\n            _deadline\r\n        );\r\n        _wrap(address(this), address(this), liquidity);  // wrap our liquidity to Stogie\r\n        _addStake(msg.sender, liquidity);                // update the user's account\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);                  // mint nft\r\n        }\r\n        if (!_transferSurplus) {\r\n            return(cigAdded, ethAdded, liquidity);\r\n        }\r\n        if (_amountCIG > cigAdded) {\r\n            unchecked{cig.transfer(\r\n            msg.sender, _amountCIG - cigAdded);}          // send surplus CIG back\r\n        }\r\n        if (_amountWETH > ethAdded) {\r\n            unchecked{IERC20(weth).transfer(\r\n            msg.sender, _amountWETH - ethAdded\r\n        );}                                              // send surplus WETH back\r\n        }\r\n        return(cigAdded, ethAdded, liquidity);\r\n    }\r\n\r\n    /**\r\n    * @dev withdrawToWETH unstake, remove liquidity & swap CIG portion to WETH.\r\n    *    Also, CIG will be harvested and sold for WETH.\r\n    *    Note: UI should check to see how much WETH is expected to be output\r\n    *    by estimating the removal of liquidity and then simulating the swap.\r\n    * @param _liquidity, The amount of liquidity tokens to remove.\r\n    * @param _amountCIGMin, The minimum amount of CIG that must be received for\r\n    *   the transaction not to revert.\r\n    * @param _amountWETHMin, The minimum amount of WETH that must be received for\r\n     *   the transaction not to revert.\r\n    * @param _deadline block number of expiry\r\n    */\r\n    function withdrawToWETH(\r\n        uint _liquidity,\r\n        uint _amountCIGMin,  // input\r\n        uint _amountWETHMin, // output\r\n        uint _deadline\r\n    ) external returns(uint out) {\r\n        out = _withdrawSingleSide(\r\n            msg.sender,\r\n            address(cig),\r\n            weth,\r\n            _liquidity,\r\n            _amountCIGMin,\r\n            _amountWETHMin,\r\n            _deadline\r\n        );\r\n        IERC20(weth).transfer(\r\n            msg.sender,\r\n            out\r\n        );         // send WETH back\r\n        return out;\r\n    }\r\n\r\n    /**\r\n    * @dev withdrawToCIG unstake, remove liquidity & swap ETH portion to CIG.\r\n    *    Note: UI should check to see how much CIG is expected to be output\r\n    *    by estimating the removal of liquidity and then simulating the swap.\r\n    * @param _liquidity amount of Stog to remove\r\n    * @param  _amountWETHMin min out WETH  when removing liquidity\r\n    * @param _amountCIGMin  min out CIG  when removing liquidity\r\n    * @param _deadline timestamp in seconds\r\n    */\r\n    function withdrawToCIG(\r\n        uint256 _liquidity,\r\n        uint _amountWETHMin,\r\n        uint _amountCIGMin,\r\n        uint _deadline\r\n    ) external returns (uint out) {\r\n        out = _withdrawSingleSide(\r\n            msg.sender,\r\n            weth,\r\n            address(cig),\r\n            _liquidity,\r\n            _amountWETHMin,\r\n            _amountCIGMin,\r\n            _deadline\r\n        );\r\n        cig.transfer(\r\n            msg.sender,\r\n            out\r\n        );         // send CIG back\r\n        return out;\r\n    }\r\n\r\n    /**\r\n    * @param _amount, how much STOG to withdraw\r\n    * @param _token, address of token to withdraw to\r\n    * @param _router, address of V2 router to use for the swap (Uni/Sushi)\r\n    * @param _amountCIGMin, The minimum amount of CIG that must be received\r\n    *   for the transaction not to revert, when removing liquidity\r\n    * @param _amountWETHMin, The minimum amount of WETH that must be received\r\n    *   for the transaction not to revert, when removing liquidity\r\n    * @param _amountTokenMin, the min amount of _token to receive, when the\r\n    *   WETH to _token\r\n    * @param _deadline, expiry block number\r\n    */\r\n    function withdrawToToken(\r\n        uint256 _amount,\r\n        address _token,\r\n        address _router,\r\n        uint _amountCIGMin,\r\n        uint _amountWETHMin,\r\n        uint _amountTokenMin,\r\n        uint _deadline\r\n    ) external notReentrant returns (uint out) {\r\n        require(\r\n            (_token != weth) && (_token != address(cig)),\r\n            \"must not be WETH or CIG\"\r\n        );\r\n        /* Withdraw to WETH first, then WETH to _token */\r\n        out = _withdrawSingleSide(\r\n            msg.sender,\r\n            address(cig),\r\n            weth,\r\n            _amount,\r\n            _amountCIGMin,\r\n            _amountWETHMin,\r\n            _deadline\r\n        );\r\n        IV2Router r;\r\n        if (_router == address(uniswapRouter)) {\r\n            r = IV2Router(uniswapRouter); // use Uniswap for intermediate swap\r\n        } else {\r\n            r = sushiRouter;\r\n        }\r\n        // swap the WETH to _token\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = weth;\r\n        path[1] = _token;\r\n        uint[] memory swpAmt = r.swapExactTokensForTokens(\r\n            out,\r\n            _amountTokenMin,              // min _token that must be received\r\n            path,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        out = swpAmt[1];\r\n        _ERC20Transfer(\r\n            IERC20(_token),\r\n            msg.sender,\r\n            out\r\n        );                                // send token back\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * @dev withdrawCIGWETH harvests CIG, withdraws and un-stakes STOG, then\r\n     *    burns STOG down to WETH & CIG, which is returned back to the caller.\r\n     * @param _liquidity, amount of STOG to withdraw\r\n     * @param _amountCIGMin, The minimum amount of CIG that must be received\r\n     *   for the transaction not to revert, when removing liquidity\r\n     * @param _amountWETHMin, The minimum amount of ETH that must be received\r\n     *   for the transaction not to revert, when removing liquidity\r\n     * @param _deadline, expiry block number\r\n     */\r\n    function withdrawCIGWETH(\r\n        uint256 _liquidity,\r\n        uint _amountCIGMin,\r\n        uint _amountWETHMin,\r\n        uint _deadline\r\n    ) external returns(uint amtCIGOut, uint amtWETHout, uint harvested) {\r\n        harvested = _withdraw(\r\n            _liquidity,\r\n            msg.sender,\r\n            address(this)\r\n        );                         // harvest and withdraw on behalf of msg.sender\r\n        cig.transfer(\r\n            msg.sender,\r\n            harvested\r\n        );                         // send harvested CIG\r\n        _unwrap(\r\n            address(this),\r\n            _liquidity\r\n        );                         // Unwrap STOG to CIG/ETH SLP token, burning STOG\r\n        (amtCIGOut, amtWETHout) = sushiRouter.removeLiquidity(\r\n            address(cig),\r\n            weth,\r\n            _liquidity,\r\n            _amountCIGMin,\r\n            _amountWETHMin,\r\n            msg.sender,\r\n            _deadline\r\n        );                          // This burns the CIG/SLP token, gives us CIG & WETH\r\n        return (amtCIGOut, amtWETHout, harvested);\r\n    }\r\n\r\n    /**\r\n    @param _farmer, the user we harvest and collect for\r\n    @param _tokenA, input token address\r\n    @param _tokenB, output token address\r\n    @param _liquidity, amount of SLP to withdraw\r\n    @param _amountAMin, min amount of _tokenA we expect to get after removal\r\n    @param _amountBMin, min amount of _tokenB we expect to get after removal\r\n    @param _deadline, expiry block number\r\n    */\r\n    function _withdrawSingleSide(\r\n        address _farmer,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint _liquidity,\r\n        uint _amountAMin,\r\n        uint _amountBMin,\r\n        uint _deadline\r\n    ) internal returns(\r\n        uint output\r\n    ) {\r\n        uint harvested = _withdraw(\r\n            _liquidity,\r\n            _farmer,\r\n            address(this)\r\n        );                          // harvest and withdraw on behalf of the user.\r\n        _unwrap(\r\n            address(this),\r\n            _liquidity\r\n        );                          // Unwrap STOG to CIG/ETH SLP token, burning STOG\r\n        (uint amtAOutput, uint amtBOutput) = sushiRouter.removeLiquidity(\r\n            _tokenA,\r\n            _tokenB,\r\n            _liquidity,\r\n            _amountAMin,\r\n            _amountBMin,\r\n            address(this),\r\n            _deadline\r\n        );                          // This burns the CIG/SLP token, gives us _tokenA & _tokenB\r\n        /*\r\n        Swap the _tokenA portion to _tokenB\r\n        */\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = _tokenA;\r\n        path[1] = _tokenB;\r\n        uint256 swapInput = amtAOutput;\r\n        /*\r\n        If outputting to WETH, sell harvested CIG to WETH, otherwise\r\n        add it to the total output\r\n        */\r\n        if (_tokenB == address(weth)) {\r\n            swapInput += harvested; // swap harvested CIG to WETH\r\n        } else {\r\n            amtBOutput += harvested;// add the harvested CIG to amtB total\r\n        }\r\n        uint[] memory swpAmt;\r\n        swpAmt = sushiRouter.swapExactTokensForTokens(\r\n            swapInput,\r\n            1,                      // assuming reserves won't change since last swap\r\n            path,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        // swpAmt[0] is the input\r\n        // swpAmt[1] is output\r\n        return (swpAmt[1] + amtBOutput);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev wrap LP tokens to STOG\r\n    * @param _amount number os CIG/ETH Sushi SLP tokens\r\n    */\r\n    function wrap(\r\n        uint256 _amount,\r\n        bool _maxApproval,\r\n        uint _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s) external {\r\n        require(_amount != 0, \"_amountLP cannot be 0\");      // Has enough?\r\n        if (_r != 0x0) {                                     // contains eip2612 sig\r\n            cigEthSLP.permit(\r\n                msg.sender,\r\n                address(this),\r\n                _maxApproval ? type(uint256).max : _amount,  // approve for max amount, or _amount\r\n                _deadline,\r\n                _v,\r\n                _r,\r\n                _s\r\n            );\r\n        }\r\n        _wrap(msg.sender, msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev unwrap STOG to LP tokens\r\n    */\r\n    function unwrap(uint256 _amountSTOG) external {\r\n        _unwrap(msg.sender, _amountSTOG);\r\n    }\r\n\r\n    /**\r\n    * @dev unwrap STOG to CIG and ETH tokens\r\n    */\r\n    function unwrapToCIGETH(\r\n        uint256 _amountSTOG,\r\n        uint _amountCIGMin,\r\n        uint _amountWETHMin,\r\n        uint _deadline) external returns(uint amtCIGOut, uint amtWETHout) {\r\n        _transfer(msg.sender, address(this), _amountSTOG);            // take their STOG\r\n        (amtCIGOut, amtWETHout) = sushiRouter.removeLiquidity(\r\n            address(cig),\r\n            weth,\r\n            _amountSTOG,\r\n            _amountCIGMin,\r\n            _amountWETHMin,\r\n            msg.sender,                                               // return CIG/ETH to user\r\n            _deadline\r\n        );\r\n        _burn(_amountSTOG);                                           // Burn the STOG\r\n    }\r\n\r\n    /**\r\n    * @dev Harvest CIG, then use our CIG holdings to buy ETH, then stake the STOG.\r\n    * @param _amountWethMin min amount of STOG we should get after swapping the\r\n    *   harvested CIG.\r\n    * @param _deadline future timestamp\r\n    */\r\n    function packSTOG(\r\n        uint _amountWethMin,\r\n        uint64 _deadline\r\n    ) external {\r\n        UserInfo storage user = farmers[msg.sender];\r\n        creditCigarettes();                     // harvest CIG from factory v1\r\n        uint harvested = _harvest(\r\n            user,\r\n            address(this)\r\n        );                                      // harvest CIG first\r\n        _depositSingleSide(\r\n            address(cig),\r\n            harvested,\r\n            _amountWethMin,\r\n            _deadline,\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n    * This is just like _depositSingleSide, but does not return surplus.\r\n    * It's useful for entering the CIG Factory with ETH and getting an NFT in\r\n    * a single tx.\r\n    * Additionally, it can be used to just mint and return Stogies without\r\n    * depositing to the CIG Factory.\r\n    */\r\n    function onboard(\r\n        address _to,\r\n        uint256 _amountOutMin,\r\n        bool _isDeposit,\r\n        bool _isMint\r\n    ) public payable returns(\r\n        uint[] memory swpAmt, uint addedA, uint addedB, uint liquidity\r\n    ) {\r\n        require(msg.value > 0, \"need ETH\");\r\n        IWETH(weth).deposit{value:msg.value}();        // wrap ETH to WETH\r\n        uint112 r; // reserve\r\n        (r,,) = cigEthSLP.getReserves();\r\n        uint256 a = _getSwapAmount(msg.value, r);      // amount to swap to get equal amounts\r\n        /*\r\n        Swap \"a\" amount of path[0] for path[1] to get equal portions.\r\n        */\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = weth;\r\n        path[1] = address(cig);\r\n        swpAmt = sushiRouter.swapExactTokensForTokens(\r\n            a,\r\n            _amountOutMin,                             // min amount that must be received\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 token0Amt = msg.value - swpAmt[0];     // how much of IERC20(path[0]) we have left\r\n        (addedA, addedB, liquidity) = sushiRouter.addLiquidity(\r\n            path[0],\r\n            path[1],\r\n            token0Amt,                                 // Amt of the single-side token\r\n            swpAmt[1],                                 // Amt received from the swap\r\n            1,                                         // Sandwich is possible, however we\r\n            1,                                         // do not allow swaps of more than 1 ETH\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if (_isDeposit) {\r\n            _wrap(\r\n                address(this),\r\n                address(this),\r\n                liquidity);                             // wrap our liquidity to Stogie, keep holding here\r\n            /* update user's account of STOG, so they can withdraw it later */\r\n            _addStake(_to, liquidity);\r\n            if (_isMint) {\r\n                badges.issueID(_to);                    // mint nft. We can only do here since\r\n            }                                           // we need to have a deposit to hold the nft\r\n        } else {\r\n            _wrap(\r\n                address(this),\r\n                _to,\r\n                liquidity);                             // wrap our liquidity and send to _to\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev _sqrt is the babylonian method from Uniswap Math.sol\r\n     */\r\n    function _sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev _getSwapAmount calculates how much _a we need to sell to have an equal portion when adding\r\n       liquidity to a pool, that has a reserve balance of _r in that token. Accounts for a  0.3% fee\r\n       @param _a amount in\r\n       @param _r reserve of _a in\r\n    */\r\n    function _getSwapAmount(uint256 _r, uint256 _a) internal pure returns (uint256){\r\n        return (_sqrt((_a * ((_r * 3988000) + (_a * 3988009)))) - (_a * 1997)) / 1994;\r\n    }\r\n\r\n    /**\r\n    * ERC20 functionality\r\n    */\r\n    string public constant name = \"Stogies Token\";\r\n    string public constant symbol = \"STOG\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply = 0;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n    * @dev transfer transfers tokens for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev transferFrom transfers tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool) {\r\n        uint256 a = allowance[_from][msg.sender]; // read allowance\r\n        //require(_value <= balanceOf[_from], \"value exceeds balance\"); // SafeMath already checks this\r\n        if (a != type(uint256).max) {             // not infinite approval\r\n            require(_value <= a, \"not approved\");\r\n            unchecked{allowance[_from][msg.sender] = a - _value;}\r\n        }\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Approve tokens of mount _value to be spent by _spender\r\n    * @param _spender address The spender\r\n    * @param _value the stipend to spend\r\n    */\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        _approve(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev burn some STOG tokens\r\n    * @param _amount The amount to burn\r\n    */\r\n    function _burn(uint256 _amount) internal {\r\n        balanceOf[address(this)] = balanceOf[address(this)] - _amount;\r\n        totalSupply = totalSupply - _amount;\r\n        emit Transfer(address(this), address(0), _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev mint new tokens\r\n    * @param _to The address to mint to.\r\n    * @param _amount The amount to be minted.\r\n    */\r\n    function _mint(address _to, uint256 _amount) internal {\r\n        require(_to != address(0), \"ERC20: mint to the zero address\");\r\n        unchecked {totalSupply = totalSupply + _amount;}\r\n        unchecked {balanceOf[_to] = balanceOf[_to] + _amount;}\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev _wrap takes CIG/ETH SLP from _form and mints STOG to _to.\r\n    * @param _from the address to take the CIG/ETH SLP tokens from\r\n    * @param _to the address to send the STOG to in return\r\n    */\r\n    function _wrap(address _from, address _to, uint256 _amount) internal {\r\n        if (_from != address(this)) {\r\n            cigEthSLP.transferFrom(_from, address(this), _amount);// take SLP\r\n        }\r\n        _mint(_to, _amount);                              // give newly minted STOG\r\n    }\r\n\r\n    /**\r\n    * @dev _unwrap redeems STOG for SLP, burning STOG\r\n    * @param _from address to unwrap for\r\n    * @param _amount how much\r\n    */\r\n    function _unwrap(address _from, uint256 _amount) internal {\r\n        if (_from != address(this)) {\r\n            _transfer(_from, address(this), _amount);     // take STOG\r\n            cigEthSLP.transfer(_from, _amount);           // give SLP back\r\n        }\r\n        _burn(_amount);                                   // burn STOG\r\n    }\r\n\r\n    /**\r\n    * @dev _transfer transfers STOG tokens from one address to another without checking allowance,\r\n       internal only\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal returns (bool) {\r\n        //require(_value <= balanceOf[_from], \"value exceeds balance\"); // SafeMath already checks this\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev _approve is an unsafe approval, for internal calls only\r\n    * @param _from account to pull funds from\r\n    * @param _spender address that will pull the funds\r\n    * @param _value amount to approve in wei\r\n    */\r\n    function _approve(address _from, address _spender, uint256 _value) internal  {\r\n        allowance[_from][_spender] = _value;\r\n        emit Approval(_from, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * STOG staking\r\n    */\r\n    uint256 public accCigPerShare;// Accumulated cigarettes per share, times 1e12.\r\n    uint256 internal paidCigDebt; // How much CIG has been advanced without actually harvesting from parent\r\n    // UserInfo keeps track of user LP deposits and withdrawals\r\n    struct UserInfo {\r\n        uint256 deposit;    // How many LP tokens the user has deposited.\r\n        uint256 rewardDebt; // keeps track of how much reward was paid out\r\n    }\r\n    mapping (address => UserInfo) public farmers;                   // keeps track of staking deposits and rewards\r\n    event Deposit(address indexed user, uint256 amount);            // when depositing LP tokens to stake\r\n    event Harvest(address indexed user, address to, uint256 amount);// when withdrawing LP tokens form staking\r\n    event Withdraw(address indexed user, uint256 amount);           // when withdrawing LP tokens, no rewards claimed\r\n    //event TransferStake(address indexed from, address indexed to, uint256 amount); // when a stake is transferred\r\n\r\n\r\n\r\n    /**\r\n    * @dev credits any CIG profit to STIG stakers, without actually fetching the\r\n    *   CIG from the factory.\r\n    *   All deposited Stogies are farmed by this contract as CIG/ETH in the old\r\n    *   Cigarette Factory.\r\n    *   This function reads the amount it has farmed since it was last called,\r\n    *   this amount (cigReward) is added to the payout by updating accCigPerShare\r\n    * @return cigReward - the amount of CIG that was credited to this contract\r\n    */\r\n    function creditCigarettes() public returns (uint256 cigReward) {\r\n        (uint256 supply,) = cig.farmers(address(this)); // how much is staked in total\r\n        if (supply == 0) {\r\n            return 0;\r\n        }\r\n        uint256 paid = paidCigDebt;\r\n        cigReward = cig.pendingCig(address(this));\r\n        if (paid > cigReward) {\r\n            return 0;                                   // CEO may lower rewards causing paid to be temporarily over\r\n        }\r\n        unchecked {\r\n            cigReward -= paid;\r\n            if (cigReward == 0) {\r\n                return 0;\r\n            }\r\n            paidCigDebt += cigReward;\r\n            accCigPerShare = accCigPerShare +\r\n                (cigReward * 1e12 / supply);            // credit all stakers\r\n        }\r\n        return cigReward;\r\n    }\r\n\r\n    /*\r\n    * @dev Fetch the cigarettes from the CIG factory & cancel out any credit\r\n    * that was brought forward. Also credit any additional surplus CIG to be\r\n    * distributed amongst STOG stakers\r\n    **/\r\n    function fetchCigarettes() public returns (uint256 cigReward) {\r\n        (uint256 supply,) = cig.farmers(address(this));// how much is staked in total\r\n        if (supply == 0) {\r\n            return 0;\r\n        }\r\n        uint256 b0 = cig.balanceOf(address(this));\r\n        cig.harvest();                                 // harvest rewards\r\n        uint256 b1 = cig.balanceOf(address(this));\r\n        cigReward = b1 - b0;\r\n        if (cigReward == 0) {                          // nothing fetched\r\n            paidCigDebt = 0;\r\n            return cigReward;\r\n        }\r\n        uint256 paid = paidCigDebt;                    // tracks rewards already distributed\r\n        if (cigReward > paid) {\r\n            unchecked {\r\n                cigReward = cigReward - paid;          // additional CIG we received since calling fetchCigarettes()\r\n            }\r\n            accCigPerShare = accCigPerShare +\r\n                (cigReward * 1e12 / supply);           // add the additional CIG to the distribution\r\n            paidCigDebt = 0;                           // clear the debt\r\n        } else {\r\n            // we paid out (using creditCigarettes()) more than the actual CIG\r\n            // harvested. This can happen if rewards were decreased. In this\r\n            // case, cancel out the reward from the paid credit, and remainder\r\n            // will be debited next time fetchCigarettes() is called.\r\n            paidCigDebt = paid - cigReward;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev pendingCig returns the amount of cig to be claimed\r\n    * @param _user the address to report\r\n    * @return the amount of CIG they can claim\r\n    */\r\n    function pendingCig(address _user) view public returns (uint256) {\r\n        // simulate really Fetching Cigarettes()\r\n        uint256 _acps = accCigPerShare;                    // accumulated cig per share\r\n        UserInfo storage user = farmers[_user];\r\n        (uint256 supply,) = cig.farmers(address(this));    // how much is staked in total\r\n        uint256 cigReward = cig.pendingCig(address(this)); // get our pending reward\r\n        uint256 acc = paidCigDebt;                         // tracks rewards already distributed\r\n        if (cigReward > acc) {\r\n            cigReward = cigReward - acc;                   // additional CIG we received since calling fetchCigarettes()\r\n            _acps = _acps +\r\n                (cigReward * 1e12 / supply);               // add the additional CIG to the distribution\r\n        }\r\n        return (user.deposit * _acps / 1e12) - user.rewardDebt;\r\n    }\r\n\r\n    /**\r\n    * @dev deposit STOG or CIG/ETH SLP tokens to stake. Parameters after\r\n    *    _wrapIt are only needed if you are including an eip2612 sig\r\n    * @param _amount the amount of liquidity tokens\r\n    * @param _mintId set to true if you want to mint a badge\r\n    * @param _isCigEthSlp set to true if we are depositing CIG/ETH SLP, we need\r\n    *    to wrap these tokens to STOG\r\n    * @param _maxApproval optional eip2612 approval, set to true if the sig\r\n    *    has max approval.\r\n    * @param _deadline in seconds for the eip2612 sig\r\n    * @param _v the v part of the eip2612 sig\r\n    * @param _r the r part of the eip2612 sig\r\n    * @param _s the s part of the eip2612 sig\r\n    */\r\n    function deposit(\r\n        uint256 _amount,\r\n        bool _mintId,\r\n        bool _isCigEthSlp,\r\n        bool _maxApproval,\r\n        uint _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        require(_amount != 0, \"You cannot deposit only 0 tokens\");           // Has enough?\r\n        if (_isCigEthSlp) {\r\n            if (_r != 0x0) {                                                 // contains eip2612 sig\r\n                cigEthSLP.permit(\r\n                    msg.sender,\r\n                    address(this),\r\n                    _maxApproval ? type(uint256).max : _amount,\r\n                    _deadline,\r\n                    _v,\r\n                    _r,\r\n                    _s\r\n                );\r\n            }\r\n            _wrap(msg.sender, address(this), _amount);\r\n        } else {\r\n            require(_transfer(address(msg.sender), address(this), _amount)); // transfer STOG to this contract\r\n        }\r\n        _addStake(msg.sender, _amount);                                      // update the user's account\r\n        if (_mintId) {\r\n            badges.issueID(msg.sender);                                      // mint nft\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev _addStake updates how many STOG has been deposited for the user\r\n    * @param _user address of user we are updating the stake for\r\n    */\r\n    function _addStake(\r\n        address _user,\r\n        uint256 _amount\r\n    ) internal {\r\n        UserInfo storage user = farmers[_user];\r\n        user.deposit += _amount;\r\n        user.rewardDebt += _amount * accCigPerShare / 1e12;\r\n        cig.deposit(_amount);                 // forward the SLP to the factory\r\n        emit Deposit(_user, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw takes out the LP tokens. This will also harvest.\r\n    * @param _amount the amount to withdraw\r\n    * @return harvested amount of CIG harvested\r\n    */\r\n    function withdraw(uint256 _amount) public returns (uint256 harvested) {\r\n        return _withdraw(_amount, msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev _withdraw harvest from the CIG factory, withdraw on behalf of\r\n    *    _farmer,  and send back the STOG\r\n    */\r\n    function _withdraw(\r\n        uint256 _amount,\r\n        address _farmer,\r\n        address _to\r\n    ) internal returns (uint256 harvested) {\r\n        UserInfo storage user = farmers[_farmer];\r\n        require(user.deposit >= _amount, \"no STOG deposited\");\r\n        /* update() will harvest CIG for everyone before emergencyWithdraw, this important. */\r\n        fetchCigarettes();                                   // fetch CIG rewards for everyone\r\n        /*\r\n        Due to a bug in the Cig contract, we can only use emergencyWithdraw().\r\n        This will take out the entire TVL first, subtract the _amount and\r\n        deposit back the remainder. emergencyWithdraw() doesn't return\r\n        the amount of tokens withdrawn, thus we use difference between b0 and\r\n        b1 to work it out.\r\n        */\r\n        (uint256 bal, ) = cig.farmers(address(this));\r\n        cig.emergencyWithdraw();\r\n        uint256 butt = bal - _amount;\r\n        if (butt > 0) {\r\n            cig.deposit(butt);                                     // put the SLP back into the factory, sans _amount\r\n        }\r\n        /* harvest beforehand, so _withdraw can safely decrement their reward count */\r\n        harvested = _harvest(user, _to);                           // distribute the user's reward\r\n        _unstake(user, _amount);                                   // update accounting for withdrawal\r\n        if (_to != address(this)) {\r\n            _transfer(address(this), address(_to), _amount);       // send STOG back\r\n        }\r\n        emit Withdraw(_farmer, _amount);\r\n        return harvested;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal withdraw, updates internal accounting after withdrawing LP\r\n    * @param _amount to subtract\r\n    */\r\n    function _unstake(UserInfo storage _user, uint256 _amount) internal {\r\n        require(_user.deposit >= _amount, \"Balance is too low\");\r\n        _user.deposit -= _amount;\r\n        uint256 _rewardAmount = _amount * accCigPerShare / 1e12;\r\n        _user.rewardDebt -= _rewardAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev harvest redeems pending rewards & updates state\r\n    * @return received is the amount that was harvested\r\n    */\r\n    function harvest() public returns (uint256 received) {\r\n        UserInfo storage user = farmers[msg.sender];\r\n        creditCigarettes();                          // harvest CIG from factory v1\r\n        return _harvest(user, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal harvest\r\n    * @param _to the amount to harvest\r\n    */\r\n    function _harvest(UserInfo storage _user, address _to) internal returns(uint256 delta) {\r\n        uint256 potentialValue = _user.deposit * accCigPerShare / 1e12;\r\n        delta = potentialValue - _user.rewardDebt;\r\n        if (cig.balanceOf(address(this)) < delta) {\r\n            fetchCigarettes();\r\n            potentialValue = _user.deposit * accCigPerShare / 1e12;\r\n            delta = potentialValue - _user.rewardDebt;\r\n        }\r\n        cig.transfer(_to, delta);                                 // give them their rewards\r\n        _user.rewardDebt = _user.deposit * accCigPerShare / 1e12; // Recalculate their reward debt\r\n        emit Harvest(msg.sender, _to, delta);\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n    * @dev getStats gets all the current stats & states of the contract\r\n    * @param _user the user address to lookup\r\n    */\r\n    function getStats(address _user) external view returns (\r\n        uint256[] memory, // ret\r\n        uint256[] memory, // cigdata\r\n        address,          // theCEO\r\n        bytes32,          // graffiti\r\n        uint112[] memory  // reserves\r\n    ) {\r\n        uint[] memory ret = new uint[](29);\r\n        uint[] memory cigdata;\r\n        address theCEO;\r\n        bytes32 graffiti;\r\n        ret[24] = nonces[_user];                       // eip-2612 nonces for _user (placing here avoids stack too deep)\r\n        ret[25] = cigEthSLP.nonces(_user);             // eip-2612 nonces\r\n        //ret[26] = badges.balanceOf(_user);             // how many badges the user has\r\n        //ret[28] = badges.minSTOG();                  // Current min Stogie value to mint a badge (commented out because contract would be too long)\r\n        ILiquidityPool ethusd = ILiquidityPool(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f));\r\n        uint112[] memory reserves = new uint112[](2);\r\n        (cigdata, theCEO, graffiti, reserves) = cig.getStats(_user); //  new uint[](27);\r\n        UserInfo memory info = farmers[_user];\r\n        uint256 t = uint256(badges.minters(_user));    // timestamp of id card mint\r\n        ret[0] = info.deposit;                         // how much STOG staked by user\r\n        ret[1] = info.rewardDebt;                      // amount of rewards paid out for user\r\n        (ret[2],) = cig.farmers(address(this));        // contract's STOGE balance\r\n        ret[3] = cigEthSLP.balanceOf(address(this));   // contract CIG/ETH SLP balance\r\n        ret[4] = balanceOf[_user];                     // user's STOG balance\r\n        ret[5] = paidCigDebt;                          // amount of CIG accumulated and advanced from the factory\r\n        ret[6] = accCigPerShare;                       // accumulated CIG per STOG share\r\n        ret[7] = pendingCig(_user);                    // pending CIG reward to be harvested\r\n        ret[8] = IERC20(weth).balanceOf(_user);        // user's WETH balance\r\n        ret[9] = _user.balance;                        // user's ETH balance\r\n        ret[10] = cig.allowance(_user, address(this)); // user's approval for Stogies to spend their CIG\r\n        ret[11] = cigEthSLP.allowance(\r\n            _user, address(this));                     // user's approval for Stogies to spend CIG/ETH SLP\r\n        ret[12] = IERC20(weth)\r\n            .allowance(_user, address(this));          // user's approval to spend WETH\r\n        ret[13] = totalSupply;                         // total supply of STOG\r\n        (uint112 r7, uint112 r8,) = cigEthSLP.getReserves();   // CIG/ETH SLP reserves, ret[7] is ETH, ret[8] is CIG\r\n        ret[14] = sushiRouter.getAmountOut(\r\n            1 ether, uint(r8), uint(r7));              // How much CIG for 1 ETH (ETH price in CIG)\r\n        (ret[15], ret[16],) = ethusd.getReserves();    // WETH/DAI reserves (15 = DAI, 16 = WETH)\r\n        ret[17] = sushiRouter.getAmountOut(\r\n            1 ether, ret[15], ret[16]);                // ETH price in USD\r\n        ret[18] = r7;                                  // ETH reserve of CIG/ETH\r\n        ret[19] = r8;                                  // CIH reserve of CIG/ETH\r\n        ret[20] = block.timestamp;                     // current timestamp\r\n        ret[21] = cig.balanceOf(address(this));        // CIG in contract\r\n        ret[22] = t;                                   // timestamp of id card mint (damn you stack too deep)\r\n        ret[23] = getMinETHDeposit();                  // Minimum ETH deposit required to mint a card\r\n\r\n        return (ret, cigdata, theCEO, graffiti, reserves);\r\n    }\r\n\r\n    /**\r\n    * Get the min ETH deposit required to get a badge\r\n    */\r\n    function getMinETHDeposit() view public returns (uint256 r) {\r\n        uint256 ts = cigEthSLP.totalSupply();\r\n        (uint256 r0, /*uint256 r1*/, ) = cigEthSLP.getReserves();\r\n        uint256 a0 =  r0 * (badges.minSTOG()*2) / ts;\r\n        r = a0 + (a0 / 1000 * 3 );\r\n    }\r\n\r\n    function _ERC20Transfer(IERC20 _token, address _to, uint256 _amount) internal {\r\n        bytes memory payload = abi.encodeWithSelector(_token.transfer.selector, _to, _amount);\r\n        (bool success, bytes memory returndata) = address(_token).call(payload);\r\n        require(success, \"_ERC20Transfer failed\");\r\n        if (returndata.length > 0) { // check return value if it was returned\r\n            require(abi.decode(returndata, (bool)), \"_ERC20Transfer failed did not succeed\");\r\n        }\r\n    }\r\n\r\n    function _ERC20TransferFrom(IERC20 _token, address _from, address _to, uint256 _amount) internal {\r\n        bytes memory payload = abi.encodeWithSelector(_token.transferFrom.selector, _from, _to, _amount);\r\n        (bool success, bytes memory returndata) = address(_token).call(payload);\r\n        require(success, \"_ERC20TransferFrom failed\");\r\n        if (returndata.length > 0) { // check return value if it was returned\r\n            require(abi.decode(returndata, (bool)), \"_ERC20TransferFrom did not succeed\");\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\r\n        return\r\n            interfaceId == type(IERC20).interfaceId ||\r\n            interfaceId == type(IERC2612).interfaceId;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address token0, address token1) external view returns (address);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n\r\ninterface IV2Router {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external pure returns(uint256 amountOut);\r\n}\r\n\r\n/*\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n * 0xTycoon was here\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ILiquidityPool is IERC20 {\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function token0() external view returns (address);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner) external view returns (uint);\r\n}\r\n\r\ninterface ICigToken is IERC20 {\r\n    struct UserInfo {\r\n        uint256 deposit;    // How many LP tokens the user has deposited.\r\n        uint256 rewardDebt; // keeps track of how much reward was paid out\r\n    }\r\n    function emergencyWithdraw() external; // make sure to call harvest before calling this\r\n    function harvest() external;\r\n    function deposit(uint256 _amount) external;\r\n    function pendingCig(address) external view returns (uint256);\r\n    function cigPerBlock() external view returns (uint256);\r\n    function getStats(address _user) external view returns(uint256[] memory, address, bytes32, uint112[] memory);\r\n    function farmers(address _user) external view returns (uint256 deposit, uint256 rewardDebt);\r\n    //function stakedlpSupply() external view returns(uint256);\r\n\r\n    //function withdraw(uint256 _amount) external // bugged, use emergencyWithdraw() instead.\r\n}\r\n\r\ninterface IIDBadges {\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n    function transferFrom(address,address,uint256) external;\r\n    function issueID(address _to) external;\r\n    function ownerOf(uint256 _id) external view returns (address);\r\n    function minters(address) external view returns(uint64);\r\n    function minSTOG() external view returns(uint256);\r\n}\r\n\r\ninterface IERC2612 {\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner) external view returns (uint);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cigEthSLP\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_badges\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accCigPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditCigarettes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cigReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isCigEthSlp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_maxApproval\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountCIG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_transferSurplus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"}],\"name\":\"depositCigWeth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cigAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWethMin\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_transferSurplus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"}],\"name\":\"depositWithCIG\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swpAmt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"cigAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountCigMin\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_transferSurplus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"}],\"name\":\"depositWithETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swpAmt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"cigAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCigMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWethMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_transferSurplus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"}],\"name\":\"depositWithToken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swpAmt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"cigAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCigMin\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_transferSurplus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintId\",\"type\":\"bool\"}],\"name\":\"depositWithWETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swpAmt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"cigAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"farmers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchCigarettes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cigReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinETHDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint112[]\",\"name\":\"\",\"type\":\"uint112[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDeposit\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isMint\",\"type\":\"bool\"}],\"name\":\"onboard\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swpAmt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"addedA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountWethMin\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_deadline\",\"type\":\"uint64\"}],\"name\":\"packSTOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingCig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountSTOG\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountSTOG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"unwrapToCIGETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amtCIGOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtWETHout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"harvested\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"withdrawCIGWETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amtCIGOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtWETHout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvested\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"withdrawToCIG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"out\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"withdrawToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"out\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountCIGMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"withdrawToWETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"out\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maxApproval\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Stogie", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb56b52316041a62b6b5d0583dce4a8ae7a3c62900000000000000000000000022b15c7ee1186a7c7cffb2d942e20fc228f6e4ed000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ed9a438bd8e2f0e3f0feb4dd397cba4274609dbe", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://37a3777163b2d121021d382b85a61fa9e1a442a8cd957ae0cbc542e9b8b22b0e"}