{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface IERC20 {\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"},\"ISwapsCallee.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface ISwapsCallee {\\n\\n    function swapsCall(\\n        address _sender,\\n        uint256 _amount0,\\n        uint256 _amount1,\\n        bytes calldata _data\\n    )\\n        external;\\n}\\n\"},\"ISwapsFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ninterface ISwapsFactory {\\n\\n    function feeTo()\\n        external\\n        view\\n        returns (address);\\n\\n    function feeToSetter()\\n        external\\n        view\\n        returns (address);\\n\\n    function getPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairsLength()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function createPair(\\n        address _tokenA,\\n        address _tokenB\\n    )\\n        external\\n        returns (address pair);\\n\\n    function setFeeTo(\\n        address\\n    )\\n        external;\\n\\n    function setFeeToSetter(\\n        address\\n    )\\n        external;\\n\\n    function cloneTarget()\\n        external\\n        view\\n        returns (address target);\\n}\\n\"},\"SwapsERC20.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\ncontract SwapsERC20 {\\n\\n    string public constant name = \\\"Verse Exchange\\\";\\n    string public constant symbol = \\\"VERSE-X\\\";\\n    uint8 public constant decimals = 18;\\n\\n    address constant ZERO_ADDRESS = address(0);\\n    uint256 constant UINT256_MAX = type(uint256).max;\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\\n        \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    constructor() {\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        totalSupply =\\n        totalSupply + _value;\\n\\n        unchecked {\\n            balanceOf[_to] =\\n            balanceOf[_to] + _value;\\n        }\\n\\n        emit Transfer(\\n            ZERO_ADDRESS,\\n            _to,\\n            _value\\n        );\\n    }\\n\\n    function _burn(\\n        address _from,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        unchecked {\\n            totalSupply =\\n            totalSupply - _value;\\n        }\\n\\n        balanceOf[_from] =\\n        balanceOf[_from] - _value;\\n\\n        emit Transfer(\\n            _from,\\n            ZERO_ADDRESS,\\n            _value\\n        );\\n    }\\n\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _value\\n    )\\n        private\\n    {\\n        allowance[_owner][_spender] = _value;\\n\\n        emit Approval(\\n            _owner,\\n            _spender,\\n            _value\\n        );\\n    }\\n\\n    function _transfer(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        private\\n    {\\n        balanceOf[_from] =\\n        balanceOf[_from] - _value;\\n\\n        unchecked {\\n            balanceOf[_to] =\\n            balanceOf[_to] + _value;\\n        }\\n\\n        emit Transfer(\\n            _from,\\n            _to,\\n            _value\\n        );\\n    }\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            _spender,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        _transfer(\\n            msg.sender,\\n            _to,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        returns (bool)\\n    {\\n        if (allowance[_from][msg.sender] != UINT256_MAX) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n\\n        _transfer(\\n            _from,\\n            _to,\\n            _value\\n        );\\n\\n        return true;\\n    }\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        external\\n    {\\n        require(\\n            _deadline \\u003e= block.timestamp,\\n            \\\"SwapsERC20: PERMIT_CALL_EXPIRED\\\"\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        _owner,\\n                        _spender,\\n                        _value,\\n                        nonces[_owner]++,\\n                        _deadline\\n                    )\\n                )\\n            )\\n        );\\n\\n        if (uint256(_s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"SwapsERC20: INVALID_SIGNATURE\\\");\\n        }\\n\\n        address recoveredAddress = ecrecover(\\n            digest,\\n            _v,\\n            _r,\\n            _s\\n        );\\n\\n        require(\\n            recoveredAddress != ZERO_ADDRESS \\u0026\\u0026\\n            recoveredAddress == _owner,\\n            \\\"SwapsERC20: INVALID_SIGNATURE\\\"\\n        );\\n\\n        _approve(\\n            _owner,\\n            _spender,\\n            _value\\n        );\\n    }\\n}\\n\"},\"SwapsPair.sol\":{\"content\":\"// SPDX-License-Identifier: BCOM\\n\\npragma solidity =0.8.14;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwapsFactory.sol\\\";\\nimport \\\"./ISwapsCallee.sol\\\";\\nimport \\\"./SwapsERC20.sol\\\";\\n\\ncontract SwapsPair is SwapsERC20 {\\n\\n    uint224 constant Q112 = 2 ** 112;\\n    uint112 constant UINT112_MAX = type(uint112).max;\\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\\n\\n    bytes4 private constant SELECTOR = bytes4(\\n        keccak256(bytes(\\u0027transfer(address,uint256)\\u0027))\\n    );\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n\\n    uint112 private reserve0;\\n    uint112 private reserve1;\\n    uint32  private blockTimestampLast;\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n\\n    uint256 public kLast;\\n    uint256 private unlocked;\\n\\n    modifier lock() {\\n        require(\\n            unlocked == 1,\\n            \\\"SwapsPair: LOCKED\\\"\\n        );\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    event Mint(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n\\n    event Sync(\\n        uint112 reserve0,\\n        uint112 reserve1\\n    );\\n\\n    function initialize(\\n        address _token0,\\n        address _token1\\n    )\\n        external\\n    {\\n        require(\\n            factory == ZERO_ADDRESS,\\n            \\\"SwapsPair: ALREADY_INITIALIZED\\\"\\n        );\\n\\n        token0 = _token0;\\n        token1 = _token1;\\n        factory = msg.sender;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint112,\\n            uint112,\\n            uint32\\n        )\\n    {\\n        return (\\n            reserve0,\\n            reserve1,\\n            blockTimestampLast\\n        );\\n    }\\n\\n    function _update(\\n        uint256 _balance0,\\n        uint256 _balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    )\\n        private\\n    {\\n        require(\\n            _balance0 \\u003c= UINT112_MAX \\u0026\\u0026\\n            _balance1 \\u003c= UINT112_MAX,\\n            \\\"SwapsPair: OVERFLOW\\\"\\n        );\\n\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n\\n        unchecked {\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n                price0CumulativeLast += uint256(uqdiv(encode(_reserve1), _reserve0)) * timeElapsed;\\n                price1CumulativeLast += uint256(uqdiv(encode(_reserve0), _reserve1)) * timeElapsed;\\n            }\\n        }\\n\\n        reserve0 = uint112(_balance0);\\n        reserve1 = uint112(_balance1);\\n\\n        blockTimestampLast = blockTimestamp;\\n\\n        emit Sync(\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _mintFee(\\n        uint112 _reserve0,\\n        uint112 _reserve1,\\n        uint256 _kLast\\n    )\\n        private\\n    {\\n        if (_kLast == 0) return;\\n\\n        uint256 rootK = sqrt(uint256(_reserve0) * _reserve1);\\n        uint256 rootKLast = sqrt(_kLast);\\n\\n        if (rootK \\u003e rootKLast) {\\n\\n            uint256 liquidity = totalSupply\\n                * (rootK - rootKLast)\\n                / (rootK * 5 + rootKLast);\\n\\n            if (liquidity == 0) return;\\n\\n            _mint(\\n                ISwapsFactory(factory).feeTo(),\\n                liquidity\\n            );\\n        }\\n    }\\n\\n    function mint(\\n        address _to\\n    )\\n        external\\n        lock\\n        returns (uint256 liquidity)\\n    {\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        uint256 amount0 = balance0 - _reserve0;\\n        uint256 amount1 = balance1 - _reserve1;\\n\\n        _mintFee(\\n            _reserve0,\\n            _reserve1,\\n            kLast\\n        );\\n\\n        uint256 _totalSupply = totalSupply;\\n\\n        if (_totalSupply == 0) {\\n\\n            liquidity = sqrt(\\n                amount0 * amount1\\n            ) - MINIMUM_LIQUIDITY;\\n\\n            _mint(\\n               ZERO_ADDRESS,\\n               MINIMUM_LIQUIDITY\\n            );\\n\\n        } else {\\n\\n            liquidity = min(\\n                amount0 * _totalSupply / _reserve0,\\n                amount1 * _totalSupply / _reserve1\\n            );\\n        }\\n\\n        require(\\n            liquidity \\u003e 0,\\n            \\\"INSUFFICIENT_LIQUIDITY_MINTED\\\"\\n        );\\n\\n        _mint(\\n            _to,\\n            liquidity\\n        );\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        kLast = uint256(reserve0) * reserve1;\\n\\n        emit Mint(\\n            msg.sender,\\n            amount0,\\n            amount1\\n        );\\n    }\\n\\n    function burn(\\n        address _to\\n    )\\n        external\\n        lock\\n        returns (\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        address _token0 = token0;\\n        address _token1 = token1;\\n\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        _mintFee(\\n            _reserve0,\\n            _reserve1,\\n            kLast\\n        );\\n\\n        uint256 _totalSupply = totalSupply;\\n\\n        amount0 = liquidity * balance0 / _totalSupply;\\n        amount1 = liquidity * balance1 / _totalSupply;\\n\\n        require(\\n            amount0 \\u003e 0 \\u0026\\u0026\\n            amount1 \\u003e 0,\\n            \\\"INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n\\n        _burn(\\n            address(this),\\n            liquidity\\n        );\\n\\n        _safeTransfer(\\n            _token0,\\n            _to,\\n            amount0\\n        );\\n\\n        _safeTransfer(\\n            _token1,\\n            _to,\\n            amount1\\n        );\\n\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        kLast = uint256(reserve0) * reserve1;\\n\\n        emit Burn(\\n            msg.sender,\\n            amount0,\\n            amount1,\\n            _to\\n        );\\n    }\\n\\n    function swap(\\n        uint256 _amount0Out,\\n        uint256 _amount1Out,\\n        address _to,\\n        bytes calldata _data\\n    )\\n        external\\n        lock\\n    {\\n        require(\\n            _amount0Out \\u003e 0 ||\\n            _amount1Out \\u003e 0,\\n            \\\"INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n\\n        ) = getReserves();\\n\\n        require(\\n            _amount0Out \\u003c _reserve0 \\u0026\\u0026\\n            _amount1Out \\u003c _reserve1,\\n            \\\"INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n\\n        {\\n            address _token0 = token0;\\n            address _token1 = token1;\\n\\n            if (_amount0Out \\u003e 0) _safeTransfer(_token0, _to, _amount0Out);\\n            if (_amount1Out \\u003e 0) _safeTransfer(_token1, _to, _amount1Out);\\n\\n            if (_data.length \\u003e 0) ISwapsCallee(_to).swapsCall(\\n                msg.sender,\\n                _amount0Out,\\n                _amount1Out,\\n                _data\\n            );\\n\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n\\n        uint256 _amount0In =\\n            balance0 \\u003e _reserve0 - _amount0Out ?\\n            balance0 - (_reserve0 - _amount0Out) : 0;\\n\\n        uint256 _amount1In =\\n            balance1 \\u003e _reserve1 - _amount1Out ?\\n            balance1 - (_reserve1 - _amount1Out) : 0;\\n\\n        require(\\n            _amount0In \\u003e 0 ||\\n            _amount1In \\u003e 0,\\n            \\\"INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n\\n        {\\n            uint256 balance0Adjusted = balance0 * 1000 - (_amount0In * 3);\\n            uint256 balance1Adjusted = balance1 * 1000 - (_amount1In * 3);\\n\\n            require(\\n                balance0Adjusted * balance1Adjusted \\u003e=\\n                uint256(_reserve0)\\n                    * _reserve1\\n                    * (1000 ** 2)\\n            );\\n        }\\n\\n        _update(\\n            balance0,\\n            balance1,\\n            _reserve0,\\n            _reserve1\\n        );\\n\\n        emit Swap(\\n            msg.sender,\\n            _amount0In,\\n            _amount1In,\\n            _amount0Out,\\n            _amount1Out,\\n            _to\\n        );\\n    }\\n\\n    function skim()\\n        external\\n        lock\\n    {\\n        address _token0 = token0;\\n        address _token1 = token1;\\n        address _feesTo = ISwapsFactory(factory).feeTo();\\n\\n        _safeTransfer(\\n            _token0,\\n            _feesTo,\\n            IERC20(_token0).balanceOf(address(this)) - reserve0\\n        );\\n\\n        _safeTransfer(\\n            _token1,\\n            _feesTo,\\n            IERC20(_token1).balanceOf(address(this)) - reserve1\\n        );\\n    }\\n\\n    function sync()\\n        external\\n        lock\\n    {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function encode(\\n        uint112 _y\\n    )\\n        pure\\n        internal\\n        returns (uint224 z)\\n    {\\n        unchecked {\\n            z = uint224(_y) * Q112;\\n        }\\n    }\\n\\n    function uqdiv(\\n        uint224 _x,\\n        uint112 _y\\n    )\\n        pure\\n        internal\\n        returns (uint224 z)\\n    {\\n        unchecked {\\n            z = _x / uint224(_y);\\n        }\\n    }\\n\\n    function min(\\n        uint256 _x,\\n        uint256 _y\\n    )\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = _x \\u003c _y ? _x : _y;\\n    }\\n\\n    function sqrt(\\n        uint256 _y\\n    )\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        unchecked {\\n            if (_y \\u003e 3) {\\n                z = _y;\\n                uint256 x = _y / 2 + 1;\\n                while (x \\u003c z) {\\n                    z = x;\\n                    x = (_y / x + x) / 2;\\n                }\\n            } else if (_y != 0) {\\n                z = 1;\\n            }\\n        }\\n    }\\n\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                SELECTOR,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"SwapsPair: TRANSFER_FAILED\\\"\\n        );\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SwapsPair", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fa081df5e17b676f55079757c12e1bfb8cfff147f8ec82075a71c156c872c328"}