{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamond {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\r\\n\\r\\ninterface IDiamondCut is IDiamond {    \\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;    \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\n/* is ERC165 */\\r\\ninterface IERC173 {\\r\\n    /// @dev This emits when ownership of a contract changes.\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Get the address of the owner\\r\\n    /// @return owner_ The address of the owner.\\r\\n    function owner() external view returns (address owner_);\\r\\n\\r\\n    /// @notice Set the address of the new owner of the contract\\r\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n    /// @param _newOwner The address of the new owner of the contract\\r\\n    function transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\n\\r\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\r\\n// The loupe functions are required by the EIP2535 Diamonds standard\\r\\n\\r\\nerror NoSelectorsGivenToAdd();\\r\\nerror NotContractOwner(address _user, address _contractOwner);\\r\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\r\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\r\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\r\\nerror IncorrectFacetCutAction(uint8 _action);\\r\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\r\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\r\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\r\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\r\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\r\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\r\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\r\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\r\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\r\\n\\r\\nlibrary LibDiamond {\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n    struct FacetAddressAndSelectorPosition {\\r\\n        address facetAddress;\\r\\n        uint16 selectorPosition;\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // function selector => facet address and selector position in selectors array\\r\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\r\\n        bytes4[] selectors;\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address _newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = _newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    function enforceIsContractOwner() internal view {\\r\\n        if(msg.sender != diamondStorage().contractOwner) {\\r\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\r\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\r\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\r\\n            if(functionSelectors.length == 0) {\\r\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\r\\n            }\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamond.FacetCutAction.Add) {\\r\\n                addFunctions(facetAddress, functionSelectors);\\r\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\r\\n                replaceFunctions(facetAddress, functionSelectors);\\r\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\r\\n                removeFunctions(facetAddress, functionSelectors);\\r\\n            } else {\\r\\n                revert IncorrectFacetCutAction(uint8(action));\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        if(_facetAddress == address(0)) {\\r\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\r\\n        }\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint16 selectorCount = uint16(ds.selectors.length);                \\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            if(oldFacetAddress != address(0)) {\\r\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\r\\n            }            \\r\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\r\\n            ds.selectors.push(selector);\\r\\n            selectorCount++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        if(_facetAddress == address(0)) {\\r\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\r\\n        }\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\r\\n            if(oldFacetAddress == address(this)) {\\r\\n                revert CannotReplaceImmutableFunction(selector);\\r\\n            }\\r\\n            if(oldFacetAddress == _facetAddress) {\\r\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\r\\n            }\\r\\n            if(oldFacetAddress == address(0)) {\\r\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\r\\n            }\\r\\n            // replace old facet address\\r\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        if(_facetAddress != address(0)) {\\r\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\r\\n        }        \\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\r\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\r\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\r\\n            }\\r\\n            \\r\\n            \\r\\n            // can't remove immutable functions -- functions defined directly in the diamond\\r\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\r\\n                revert CannotRemoveImmutableFunction(selector);\\r\\n            }\\r\\n            // replace selector with last selector\\r\\n            selectorCount--;\\r\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\r\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\r\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\r\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\r\\n            }\\r\\n            // delete last selector\\r\\n            ds.selectors.pop();\\r\\n            delete ds.facetAddressAndSelectorPosition[selector];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\r\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n        if (!success) {\\r\\n            if (error.length > 0) {\\r\\n                // bubble up error\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(error)\\r\\n                    revert(add(32, error), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert InitializationFunctionReverted(_init, _calldata);\\r\\n            }\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        if(contractSize == 0) {\\r\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\r\\n        }        \\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/upgradeInitializers/DiamondInit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n*\\r\\n* Implementation of a diamond.\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nimport { IERC173 } from \\\"../interfaces/IERC173.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\n// It is expected that this contract is customized if you want to deploy your diamond\\r\\n// with data from a deployment script. Use the init function to initialize state variables\\r\\n// of your diamond. Add parameters to the init funciton if you need to.\\r\\n\\r\\n// Adding parameters to the `init` or other functions you add here can make a single deployed\\r\\n// DiamondInit contract reusable accross upgrades, and can be used for multiple diamonds.\\r\\n\\r\\ncontract DiamondInit {    \\r\\n\\r\\n    // You can add parameters to this function in order to pass in \\r\\n    // data to set your own state variables\\r\\n    function init() external {\\r\\n        // adding ERC165 data\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\r\\n\\r\\n        // add your own state variables \\r\\n        // EIP-2535 specifies that the `diamondCut` function takes two optional \\r\\n        // arguments: address _init and bytes calldata _calldata\\r\\n        // These arguments are used to execute an arbitrary function using delegatecall\\r\\n        // in order to set state variables in the diamond during deployment or an upgrade\\r\\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondInit", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}