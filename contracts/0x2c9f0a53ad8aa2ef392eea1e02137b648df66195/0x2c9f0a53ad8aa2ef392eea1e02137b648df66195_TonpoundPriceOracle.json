{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Oracles/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n\\t// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n\\t// if they do not have data to report, instead of returning unset values\\n\\t// which could be misinterpreted as actual reported values.\\n\\tfunction getRoundData(uint80 _roundId) external view \\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n\\n\\tfunction latestRoundData() external view\\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n}\\n\\ninterface AggregatorValidatorInterface {\\n\\tfunction validate(uint256 previousRoundId,\\n\\t\\t\\tint256 previousAnswer,\\n\\t\\t\\tuint256 currentRoundId,\\n\\t\\t\\tint256 currentAnswer) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Oracles/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface ICToken {\\n    function underlying() external view returns (address);\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n    function isCToken() external view returns (bool);\\n}\\n\\ninterface IPriceOracle {\\n    function isPriceOracle() external view returns (bool);\\n    function getAssetPrice(address asset) external view returns (uint);\\n    function getAssetPriceUpdateTimestamp(address asset) external view returns (uint);\\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint);\\n    function getUnderlyingPriceUpdateTimestamp(address cToken) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Oracles/TonpoundPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./UniswapConfig.sol\\\";\\nimport \\\"../ExponentialNoError.sol\\\";\\nimport \\\"./interfaces/IPriceOracle.sol\\\";\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract TonpoundPriceOracle is ExponentialNoError, UniswapConfig, Ownable {\\n    \\n    /// @notice ChainLink Feed address by underlying address\\n    mapping(address => address) public chainLinkFeeds;\\n\\n    mapping(address => address) public chainLinkETHFeeds;\\n\\n    /// @notice ChainLink Feed decimals by underlying address\\n    mapping(address => uint8) public chainLinkFeedDecimals;\\n\\n    /// @notice assets decimals by underlying address \\n    mapping(address => uint8) public assetsDecimals;\\n\\n    /// @notice chainlink price feed ETH / USD\\n    AggregatorV3Interface public immutable baseAssetFeed;\\n\\n    /// @notice The number of wei in 1 ETH\\n    uint256 public constant ETH_BASE_UNIT = 1e18;\\n\\n    /// @notice A common scaling factor to maintain precision\\n    uint256 public constant EXP_SCALE = 1e18;\\n\\n    /// @notice denominator to scale price from chainlink price feed\\n    uint256 public immutable baseAssetFeedDenominator;\\n\\n    /// @notice The time interval to for TWAP price calculation\\n    uint256 public twapPeriod;\\n\\n    /// @notice The event emitted when the stored price is updated\\n    event PriceUpdated(bytes32 indexed symbolHash, uint256 price);\\n\\n    /// @notice The event emitted when new PriceFeed added (updated)\\n    event NewFeedForAsset(address indexed asset, address oldFeed, address newFeed);\\n\\n    /// @notice The event emitted when twapPeriod updated\\n    event NewTwapPeriod(uint256 newTwap);\\n\\n    /**\\n     * @notice Construct a Uniswap anchored view for a set of token configurations\\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single twapPeriod before using.\\n     *      NOTE: Reported prices are set to 1 during construction. We assume that this contract will not be voted in by\\n     *      governance until prices have been updated through `validate` for each TokenConfig.\\n     * @param twapPeriod_ The time difference to calculate twap price\\n     */\\n    constructor(\\n        uint32 twapPeriod_,\\n        address baseUnderlying,\\n        AggregatorV3Interface baseAssetFeed_\\n    ) {\\n        require(twapPeriod_ >= 600 && twapPeriod_ < 604800, \\\"invalid twap\\\");\\n        twapPeriod = twapPeriod_;\\n\\n        require(baseUnderlying != address(0), \\\"underlying\\\");\\n        baseAssetFeed = baseAssetFeed_;\\n        uint8 priceFeedDecimals = baseAssetFeed_.decimals();\\n        baseAssetFeedDenominator = 10 ** (priceFeedDecimals - 6);\\n        _setPriceFeedForUnderlyingInternal(baseUnderlying, address(baseAssetFeed_), priceFeedDecimals);\\n    }\\n\\n    /// @notice Get the underlying price of a cToken asset\\n    /// @param cToken The cToken to get the underlying price of\\n    /// @return The underlying asset price mantissa (scaled by 1e(36 - assetDecimals)).\\n    ///         Zero means the price is unavailable.\\n    function getUnderlyingPrice(address cToken) public view returns (uint) {\\n        address asset = ICToken(cToken).underlying();\\n        if (hasFeedForAsset(asset)) {\\n            return _getOraclePriceForAssetInternal(asset);\\n        } else if (hasTwapForCToken(cToken)) {\\n            return _fetchTwapPriceForAssetInternal(cToken);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Sets config to fetch underlying price\\n    /// @param newTwap The time interval to for TWAP price calculation\\n    function setTwapPeriod(uint256 newTwap) external onlyOwner {\\n        require(newTwap >= 600 && newTwap < 604800, \\\"invalid twap\\\");\\n        twapPeriod = newTwap;\\n        emit NewTwapPeriod(newTwap);\\n    }\\n\\n    /// @notice Sets config to fetch underlying price\\n    /// @param cToken The address of the Compound Token\\n    /// @param uniswapMarket The address of the V3 pool being used as the anchor for this market\\n    function setTokenConfig(address cToken, address uniswapMarket) external onlyOwner {\\n        _setTokenConfig(cToken, uniswapMarket);\\n    }\\n\\n    /// @notice Sets config to fetch underlying price\\n    /// @param cToken The array of the Compound Tokens\\n    /// @param uniswapMarket The array of the V3 pools being used as the anchor for this markets\\n    function setTokenConfigs(address[] calldata cToken, address[] calldata uniswapMarket) external onlyOwner {\\n            require(cToken.length == uniswapMarket.length, \\\"invalid lengths\\\");\\n\\n        for (uint i = 0; i < cToken.length; i++) {\\n            _setTokenConfig(cToken[i], uniswapMarket[i]);\\n        }\\n    }\\n\\n    /// @notice Fetch the underlying price of a cToken from TWAP, in the format expected by the Comptroller.\\n    /// @dev Implements the PriceOracle interface for Compound v2.\\n    /// @param cToken The cToken address for price retrieval\\n    /// @return Price denominated in USD for the given cToken address, in the format expected by the Comptroller.\\n    ///         (scaled by 1e(36 - assetDecimals))\\n    function _fetchTwapPriceForAssetInternal(address cToken)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        TokenConfig memory config = getTokenConfigByCToken(cToken);\\n        uint256 anchorPrice = calculateAnchorPriceFromEthPrice(config);\\n        require(anchorPrice < 2**248, \\\"Anchor too big\\\");\\n        // Comptroller needs prices in the format: ${raw price} * 1e36 / baseUnit\\n        // The baseUnit of an asset is the amount of the smallest denomination of that asset per whole.\\n        // For example, the baseUnit of ETH is 1e18.\\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6)/baseUnit\\n        return FullMath.mulDiv(1e30, anchorPrice, config.baseUnit);\\n    }\\n\\n    /// @notice Calculate the anchor price by fetching price data from the TWAP\\n    /// @param config TokenConfig\\n    /// @return anchorPrice uint\\n    function calculateAnchorPriceFromEthPrice(TokenConfig memory config)\\n        internal\\n        view\\n        returns (uint256 anchorPrice)\\n    {\\n        uint256 ethPrice = fetchEthPrice();\\n        anchorPrice = fetchAnchorPrice(config, ethPrice);\\n    }\\n\\n    /// @dev Fetches the latest TWATP from the UniV3 pool oracle, over the last anchor period.\\n    ///      Note that the TWATP (time-weighted average tick-price) is not equivalent to the TWAP,\\n    ///      as ticks are logarithmic. The TWATP returned by this function will usually\\n    ///      be lower than the TWAP.\\n    function getUniswapTwap(TokenConfig memory config)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint32 twapPeriod_ = uint32(twapPeriod);\\n        uint32[] memory secondsAgos = new uint32[](2);\\n        secondsAgos[0] = twapPeriod_;\\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(\\n            config.uniswapMarket\\n        ).observe(secondsAgos);\\n\\n        int56 twapPeriod__ = int56(uint56(twapPeriod_));\\n        int56 timeWeightedAverageTickS56 = (tickCumulatives[1] -\\n            tickCumulatives[0]) / twapPeriod__;\\n        require(\\n            timeWeightedAverageTickS56 >= TickMath.MIN_TICK &&\\n                timeWeightedAverageTickS56 <= TickMath.MAX_TICK,\\n            \\\"TWAP not in range\\\"\\n        );\\n        require(\\n            timeWeightedAverageTickS56 < type(int24).max,\\n            \\\"timeWeightedAverageTick > max\\\"\\n        );\\n        int24 timeWeightedAverageTick = int24(timeWeightedAverageTickS56);\\n        if (config.isUniswapReversed) {\\n            // If the reverse price is desired, inverse the tick\\n            // price = 1.0001^{tick}\\n            // (price)^{-1} = (1.0001^{tick})^{-1}\\n            // \\\\frac{1}{price} = 1.0001^{-tick}\\n            timeWeightedAverageTick = -timeWeightedAverageTick;\\n        }\\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(\\n            timeWeightedAverageTick\\n        );\\n        // Squaring the result also squares the Q96 scalar (2**96),\\n        // so after this mulDiv, the resulting TWAP is still in Q96 fixed precision.\\n        uint256 twapX96 = FullMath.mulDiv(\\n            sqrtPriceX96,\\n            sqrtPriceX96,\\n            FixedPoint96.Q96\\n        );\\n\\n        // Scale up to a common precision (EXP_SCALE), then down-scale from Q96.\\n        return FullMath.mulDiv(EXP_SCALE, twapX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @dev Fetches the current eth/usd price from price feed, with 6 decimals of precision.\\n    function fetchEthPrice() internal view returns (uint256) {\\n        return uint256(getChainLinkPrice(baseAssetFeed)) / baseAssetFeedDenominator ;\\n    }\\n\\n    /// @dev Fetches the current token/usd price from Uniswap, with 6 decimals of precision.\\n    /// @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\\n    function fetchAnchorPrice(\\n        TokenConfig memory config,\\n        uint256 conversionFactor\\n    ) internal view virtual returns (uint256) {\\n        // `getUniswapTwap(config)`\\n        //      -> TWAP between the baseUnits of Uniswap pair (scaled to 1e18)\\n        // `twap * config.baseUnit`\\n        //      -> price of 1 token relative to `baseUnit` of the other token (scaled to 1e18)\\n        uint256 twap = getUniswapTwap(config);\\n\\n        // `unscaledPriceMantissa * config.baseUnit / EXP_SCALE`\\n        //      -> price of 1 token relative to baseUnit of the other token (scaled to 1)\\n        uint256 unscaledPriceMantissa = twap * conversionFactor;\\n\\n        // Adjust twap according to the units of the non-ETH asset\\n        // 1. In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\\n        // 2. In the case of non-ETH tokens\\n        //  a. `getUniswapTwap(config)` handles \\\"reversed\\\" token pairs, so `twap` will always be Token/ETH TWAP.\\n        //  b. conversionFactor = ETH price * 1e6\\n        //      unscaledPriceMantissa = twap{token/ETH} * EXP_SCALE * conversionFactor\\n        //      so ->\\n        //      anchorPrice = (twap * tokenBaseUnit / ETH_BASE_UNIT) * ETH_price * 1e6\\n        //                  = twap * conversionFactor * tokenBaseUnit / ETH_BASE_UNIT\\n        //                  = unscaledPriceMantissa / EXP_SCALE * tokenBaseUnit / ETH_BASE_UNIT\\n        uint256 anchorPrice = (unscaledPriceMantissa * config.baseUnit) /\\n            ETH_BASE_UNIT /\\n            EXP_SCALE;\\n\\n        return anchorPrice;\\n    }\\n\\n    function hasTwapForCToken(address cToken) internal view returns (bool) {\\n        return cTokenConfig[cToken].uniswapMarket != address(0);\\n    }\\n\\n    function hasFeedForAsset(address asset) internal view returns (bool) {\\n        return chainLinkFeeds[asset] != address(0);\\n    }\\n\\n    /* ChainLink Oracles */\\n\\n    function _setPriceFeedForUnderlying(address _underlying, address _chainlinkFeed, uint8 _priceFeedDecimals) onlyOwner external {\\n        _setPriceFeedForUnderlyingInternal(_underlying, _chainlinkFeed, _priceFeedDecimals);\\n    }\\n\\n    function _setPriceETHFeedsForUnderlyings(address[] calldata _underlyings, address[] calldata _chainlinkFeeds) onlyOwner external {\\n        require(_underlyings.length == _chainlinkFeeds.length, \\\"invalid lengths\\\");\\n\\n        for (uint i = 0; i < _underlyings.length; i++) {\\n            chainLinkETHFeeds[_underlyings[i]] = _chainlinkFeeds[i];\\n        }\\n    }\\n\\n    function _setPriceFeedsForUnderlyings(address[] calldata _underlyings, address[] calldata _chainlinkFeeds, uint8[] calldata _priceFeedsDecimals) onlyOwner external {\\n        require(_underlyings.length == _chainlinkFeeds.length, \\\"invalid lengths\\\");\\n        require(_underlyings.length == _priceFeedsDecimals.length, \\\"invalid lengths\\\");\\n\\n        for (uint i = 0; i < _underlyings.length; i++) {\\n            _setPriceFeedForUnderlyingInternal(_underlyings[i], _chainlinkFeeds[i], _priceFeedsDecimals[i]);\\n        }\\n    }\\n\\n    function _setPriceFeedForUnderlyingInternal(address underlying, address chainlinkFeed, uint8 priceFeedDecimals) internal {\\n        address existingFeed = chainLinkFeeds[underlying];\\n        // require(existingFeed == address(0), \\\"Cannot reassign feed\\\");\\n\\n        uint8 decimalsForAsset;\\n\\n        if (underlying == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\\n            decimalsForAsset = 18;\\n        } else {\\n            decimalsForAsset = IERC20(underlying).decimals();\\n        }\\n\\n        // Update if the feed is different\\n        if (existingFeed != chainlinkFeed) {\\n            chainLinkFeeds[underlying] = chainlinkFeed;\\n            chainLinkFeedDecimals[underlying] = priceFeedDecimals;\\n            assetsDecimals[underlying] = decimalsForAsset;\\n            emit NewFeedForAsset(underlying, existingFeed, chainlinkFeed);\\n        }\\n    }\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param asset The asset (Erc20 or native)\\n      * @return The asset price mantissa (scaled by 1e(36 - assetDecimals)).\\n      *  Zero means the price is unavailable.\\n      */\\n    function _getOraclePriceForAssetInternal(address asset) internal view returns (uint) {\\n        uint8 feedDecimals = chainLinkFeedDecimals[asset];\\n        uint8 assetDecimals = assetsDecimals[asset];\\n        address feed = chainLinkFeeds[asset];\\n        int feedPriceRaw = getChainLinkPrice(AggregatorV3Interface(feed));\\n        uint feedPrice = uint(feedPriceRaw);\\n\\n        // Safety\\n        require(feedPriceRaw == int(feedPrice), \\\"Price Conversion error\\\");\\n\\n        if (feed == chainLinkETHFeeds[asset]) {\\n            feedPrice = feedPrice * fetchEthPrice() / 1e6;\\n        }\\n\\n        // Needs to be scaled to e36 and then divided by the asset's decimals\\n        if (feedDecimals == 8) {\\n            return (1e28 * feedPrice) / (10 ** assetDecimals);\\n        } else if (feedDecimals == 18) {\\n            return (1e18 * feedPrice) / (10 ** assetDecimals);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function getChainLinkPrice(AggregatorV3Interface priceFeed) internal view returns (int) {\\n        (\\n        uint80 roundID,\\n        int price,\\n        uint startedAt,\\n        uint timeStamp,\\n        uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    /// @notice         Evaluates input amount according to stored price, accrues interest\\n    /// @param cToken   Market to evaluate\\n    /// @param amount   Amount of tokens to evaluate according to 'reverse' order\\n    /// @param reverse  Order of evaluation\\n    /// @return         Depending on 'reverse' order:\\n    ///                     false - return USD amount equal to 'amount' of 'cToken' in wei\\n    ///                     true - return cTokens equal to 'amount' of USD represented in wei\\n    ///                            e.g. 123e18 = 123.00$\\n    function getEvaluation(address cToken, uint256 amount, bool reverse) external returns (uint256) {\\n        Exp memory exchangeRate = Exp({mantissa: ICToken(cToken).exchangeRateCurrent()});\\n        uint256 oraclePriceMantissa = getUnderlyingPrice(cToken);        \\n        require(oraclePriceMantissa != 0, \\\"invalid price\\\");\\n        Exp memory oraclePrice = Exp({mantissa: oraclePriceMantissa});\\n\\n        if (reverse) {\\n            // input: 'amount' in USD scaled in 1e18, i.e. 19.54$ = 19540000000000000000\\n            // tokenAmount = amountUSD / oraclePrice \\n            // cTokenAmount = tokenAmount / exchangeRate\\n            uint256 tokenAmount = div_(amount, oraclePrice);\\n            uint256 cTokenAmount =  div_(tokenAmount, exchangeRate);\\n            return cTokenAmount; \\n        }\\n        // underlyingAmount = exchangeRate * cTokenAmount\\n        // underlyingAmountUSD = underlyingAmount * oraclePrice\\n        uint256 underlyingAmount = mul_ScalarTruncate(exchangeRate, amount);\\n        uint256 underlyingAmountUSD = mul_ScalarTruncate(oraclePrice, underlyingAmount);\\n        return underlyingAmountUSD;\\n    }\\n\\n\\n    /// @notice         Evaluates input amount according to stored price, doesn't accrue interest\\n    /// @param cToken   Market to evaluate\\n    /// @param amount   Amount of tokens to evaluate according to 'reverse' order\\n    /// @param reverse  Order of evaluation\\n    /// @return         Depending on 'reverse' order:\\n    ///                     false - return USD amount equal to 'amount' of 'cToken' in wei\\n    ///                     true - return cTokens equal to 'amount' of USD represented in wei\\n    ///                            e.g. 123e18 = 123.00$\\n    function getEvaluationStored(address cToken, uint256 amount, bool reverse) external view returns (uint256) {\\n        Exp memory exchangeRate = Exp({mantissa: ICToken(cToken).exchangeRateStored()});\\n        // uint256 underlyingDecimals = IERC20(cToken.underlying()).decimals();\\n        uint256 oraclePriceMantissa = getUnderlyingPrice(cToken);\\n        require(oraclePriceMantissa != 0, \\\"invalid price\\\");\\n        Exp memory oraclePrice = Exp({mantissa: oraclePriceMantissa});\\n\\n        if (reverse) {\\n            // input: 'amount' in USD scaled in 1e18, i.e. 19.54$ = 19540000000000000000\\n            // tokenAmount = amountUSD / oraclePrice \\n            // cTokenAmount = tokenAmount / exchangeRate\\n            uint256 tokenAmount = div_(amount, oraclePrice);\\n            uint256 cTokenAmount =  div_(tokenAmount, exchangeRate);\\n            return cTokenAmount; \\n        }\\n        // underlyingAmount = exchangeRate * cTokenAmount\\n        // underlyingAmountUSD = underlyingAmount * oraclePrice\\n        uint256 underlyingAmount = mul_ScalarTruncate(exchangeRate, amount);\\n        uint256 underlyingAmountUSD = mul_ScalarTruncate(oraclePrice, underlyingAmount);\\n        return underlyingAmountUSD;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Oracles/UniswapConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./interfaces/IPriceOracle.sol\\\";\\nimport \\\"./UniswapLib.sol\\\";\\n\\n\\ncontract UniswapConfig {\\n\\n    /// @dev Describe how the USD price should be determined for an asset.\\n    struct TokenConfig {\\n        // The address of the underlying market token. For this `LINK` market configuration, this would be the address of the `LINK` token.\\n        address underlying;\\n        // The bytes32 hash of the underlying symbol.\\n        bytes32 symbolHash;\\n        // The number of smallest units of measurement in a single whole unit.\\n        uint256 baseUnit;\\n        // The address of the pool being used as the anchor for this market.\\n        address uniswapMarket;\\n        // True if the pair on Uniswap is defined as ETH / X\\n        bool isUniswapReversed;\\n    }\\n\\n    /// @notice cToken configs\\n    mapping(address => TokenConfig) public cTokenConfig;\\n    \\n    /// @notice cToken address by underlying's symbol hash\\n    mapping(bytes32 => address) internal cTokenBySymbolHash;\\n\\n    /// @notice cToken address by underlying address\\n    mapping(address => address) internal cTokenByUnderlying;\\n\\n    event ConfigUpdate(address indexed cToken, address uniswapMarket);\\n\\n    /**\\n     * @notice Sets config to fetch underlying price\\n     * @param cToken The address of the Compound Token\\n     * @param uniswapMarket The address of the V3 pool being used as the anchor for this market\\n     */\\n    function _setTokenConfig(\\n        address cToken,\\n        address uniswapMarket\\n        ) internal {\\n\\n        require(ICToken(cToken).isCToken(), \\\"invalid cToken\\\");\\n        address underlying = ICToken(cToken).underlying();\\n\\n        require(uniswapMarket != address(0), \\\"No market\\\");\\n        require(\\n            IUniswapV3Pool(uniswapMarket).token0() == underlying || \\n            IUniswapV3Pool(uniswapMarket).token1() == underlying,\\n            \\\"invalid market\\\"\\n            );\\n\\n        bytes32 symbolHash = keccak256(bytes(IERC20(underlying).symbol()));\\n        uint256 baseUnit = 10 ** IERC20(underlying).decimals();\\n        bool isUniswapReversed = IUniswapV3Pool(uniswapMarket).token0() == underlying ?\\n            false : true;\\n\\n        cTokenConfig[cToken] = TokenConfig({\\n            underlying: underlying,\\n            symbolHash: symbolHash,\\n            baseUnit: baseUnit,\\n            uniswapMarket: uniswapMarket,\\n            isUniswapReversed: isUniswapReversed\\n        });\\n\\n        cTokenBySymbolHash[symbolHash] = cToken;\\n        cTokenByUnderlying[underlying] = cToken;\\n        \\n        emit ConfigUpdate(cToken, uniswapMarket);\\n    }\\n\\n    /**\\n     * @notice Get the config for symbol\\n     * @param symbol The symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbol(string calldata symbol)\\n        public\\n        view\\n        returns (TokenConfig memory)\\n    {\\n        TokenConfig memory config = cTokenConfig[cTokenBySymbolHash[keccak256(bytes(symbol))]];\\n        return config;\\n    }\\n\\n    /**\\n     * @notice Get the config for the symbolHash\\n     * @param symbolHash The keccack256 of the symbol of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigBySymbolHash(bytes32 symbolHash)\\n        public\\n        view\\n        returns (TokenConfig memory)\\n    {\\n        TokenConfig memory config = cTokenConfig[cTokenBySymbolHash[symbolHash]];\\n        return config;\\n    }\\n\\n    /**\\n     * @notice Get the config for the cToken\\n     * @param cToken The address of the cToken of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByCToken(address cToken)\\n        public\\n        view\\n        returns (TokenConfig memory)\\n    {\\n        TokenConfig memory config = cTokenConfig[cToken];\\n        return config;\\n    }\\n\\n    /**\\n     * @notice Get the config for an underlying asset\\n     * @dev The underlying address of ETH is the zero address\\n     * @param underlying The address of the underlying asset of the config to get\\n     * @return The config object\\n     */\\n    function getTokenConfigByUnderlying(address underlying)\\n        public\\n        view\\n        returns (TokenConfig memory)\\n    {\\n        TokenConfig memory config = cTokenConfig[cTokenByUnderlying[underlying]];\\n        return config;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Oracles/UniswapLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >0.8.7;\\n\\n// From: https://github.com/Uniswap/uniswap-v3-core\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = denominator & (~denominator + 1);\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n}\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MIN_TICK = -887272;\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO =\\n        1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick)\\n        internal\\n        pure\\n        returns (uint160 sqrtPriceX96)\\n    {\\n        uint256 absTick = tick < 0\\n            ? uint256(-int256(tick))\\n            : uint256(int256(tick));\\n        require(absTick <= uint256(uint24(MAX_TICK)), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\n            : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0)\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0)\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0)\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0)\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0)\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0)\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0)\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0)\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0)\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0)\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0)\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0)\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0)\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0)\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0)\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0)\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0)\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0)\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0)\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160(\\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n        );\\n    }\\n}\\n\\ninterface IUniswapV3Pool {\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (\\n            int56[] memory tickCumulatives,\\n            uint160[] memory secondsPerLiquidityCumulativeX128s\\n        );\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n}\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC20 {\\n\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool success);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"twapPeriod_\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"baseUnderlying\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"baseAssetFeed_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"}],\"name\":\"ConfigUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeed\",\"type\":\"address\"}],\"name\":\"NewFeedForAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTwap\",\"type\":\"uint256\"}],\"name\":\"NewTwapPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_BASE_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXP_SCALE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_underlyings\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_chainlinkFeeds\",\"type\":\"address[]\"}],\"name\":\"_setPriceETHFeedsForUnderlyings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkFeed\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_priceFeedDecimals\",\"type\":\"uint8\"}],\"name\":\"_setPriceFeedForUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_underlyings\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_chainlinkFeeds\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_priceFeedsDecimals\",\"type\":\"uint8[]\"}],\"name\":\"_setPriceFeedsForUnderlyings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetsDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAssetFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAssetFeedDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cTokenConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainLinkETHFeeds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainLinkFeedDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainLinkFeeds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reverse\",\"type\":\"bool\"}],\"name\":\"getEvaluation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reverse\",\"type\":\"bool\"}],\"name\":\"getEvaluationStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getTokenConfigByCToken\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"getTokenConfigBySymbol\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"}],\"name\":\"getTokenConfigBySymbolHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"getTokenConfigByUnderlying\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"symbolHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseUnit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUniswapReversed\",\"type\":\"bool\"}],\"internalType\":\"struct UniswapConfig.TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapMarket\",\"type\":\"address\"}],\"name\":\"setTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cToken\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"uniswapMarket\",\"type\":\"address[]\"}],\"name\":\"setTokenConfigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTwap\",\"type\":\"uint256\"}],\"name\":\"setTwapPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twapPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TonpoundPriceOracle", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000708000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}