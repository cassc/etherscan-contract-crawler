{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"SHIBAQATAR.sol\": {\r\n      \"content\": \"/**\\r\\nINTRODUCE SHIBAQATAR \\r\\n\\r\\n\ud83c\uddf6\ud83c\udde6\ud83d\udc15ShibaQatar - $SHQ is a decentralized coin built on ETH chain inspired by the world\u2019s most prestigious sports tournament, a sport that unites people with common interests, competition and love for football and the King of meme Shiba\\r\\n\\r\\nWe strongly believe that we can use the hype of this year's world cup to promote our brand and expand it with time.\ud83c\uddf6\ud83c\udde6\ud83d\udc15\\r\\n\\r\\n\ud83d\udc68\u200d\ud83d\udcbb Checkout the Socials to get chance \ud83d\udc47\\r\\nTg: https://t.me/ShibaQatarErc20\\r\\nTw: https://twitter.com/ShibaQatarErc20\\r\\nReddit: https://www.reddit.com/user/ShibaQatar-eth-123\\r\\nMedium: https://medium.com/@ShibaQatar.eth\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8;\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(from, spender, amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[from];\\r\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[to] += amount;\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        _afterTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n\\r\\n        _afterTokenTransfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        uint256 accountBalance = _balances[account];\\r\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[account] = accountBalance - amount;\\r\\n        }\\r\\n        _totalSupply -= amount;\\r\\n\\r\\n        emit Transfer(account, address(0), amount);\\r\\n\\r\\n        _afterTokenTransfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _spendAllowance(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        uint256 currentAllowance = allowance(owner, spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\r\\n            unchecked {\\r\\n                _approve(owner, spender, currentAllowance - amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\ninterface IFactory{\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IPair{\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\ninterface IRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountATokenDesired,\\r\\n        uint amountBTokenDesired,\\r\\n        uint amountATokenMin,\\r\\n        uint amountBTokenMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline) external;\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract SHIBAQATAR is ERC20, Ownable{\\r\\n    using Address for address payable;\\r\\n\\r\\n    uint256 constant DECIMALS = 18;\\r\\n\\r\\n    uint256 _totalSupply = 1_000_000_000_000 * (10**DECIMALS);\\r\\n\\r\\n    mapping(address => bool) public exemptFee;\\r\\n    mapping(address => bool) public isTxLimitExempt;\\r\\n    mapping (address => bool) public isBlacklist;\\r\\n    bool public antiBot = true;\\r\\n    bool public swapEnabled;\\r\\n\\r\\n    IRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    address public lpRecipient;\\r\\n    address public marketingWallet;\\r\\n    address public stakingPoolWallet;\\r\\n\\r\\n    bool private swapping;\\r\\n    uint256 public swapThreshold;\\r\\n    uint256 public maxWalletAmount;\\r\\n    uint256 public maxTxAmount;\\r\\n\\r\\n    uint256 public transferFee;\\r\\n\\r\\n    struct Fees {\\r\\n        uint256 lp;\\r\\n        uint256 marketing;\\r\\n        uint256 stakingPool;\\r\\n    }\\r\\n\\r\\n    Fees public buyFees = Fees(2, 2, 1);\\r\\n    Fees public sellFees = Fees(2, 2, 1);\\r\\n    uint256 public totalSellFee = 5;\\r\\n    uint256 public totalBuyFee = 5;\\r\\n\\r\\n    modifier inSwap() {\\r\\n        if (!swapping) {\\r\\n            swapping = true;\\r\\n            _;\\r\\n            swapping = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event TaxRecipientsUpdated(address newLpRecipient, address newMarketingWallet, address newStakingPoolWallet);\\r\\n    event FeesUpdated();\\r\\n    event SwapThresholdUpdated(uint256 amount);\\r\\n    event MaxWalletAmountUpdated(uint256 amount);\\r\\n    event MaxTXAmountUpdated(uint256 amount);\\r\\n    event ExemptFromFeeUpdated(address user, bool state);\\r\\n    event ExemptTXUpdated(address user, bool state);\\r\\n\\r\\n    constructor() ERC20(\\\"SHIBAQATAR\\\", \\\"SHQ\\\") {\\r\\n        \\r\\n        router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n\\r\\n        pair = IFactory(router.factory()).createPair(address(this), router.WETH());\\r\\n\\r\\n        swapThreshold = 1_000_000_000 * (10**DECIMALS); // 0.1%\\r\\n        maxWalletAmount = 20_000_000_000 * (10**DECIMALS); // 2%\\r\\n        maxTxAmount = 10_000_000_000 * (10**DECIMALS); // 1%\\r\\n\\r\\n        exemptFee[msg.sender] = true;\\r\\n        exemptFee[address(this)] = true;\\r\\n        \\r\\n        isTxLimitExempt[msg.sender] = true;\\r\\n        isTxLimitExempt[address(this)] = true;\\r\\n        isTxLimitExempt[address(router)] = true;\\r\\n        isTxLimitExempt[pair] = true;\\r\\n\\r\\n        _mint(msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function setTaxRecipients(address _lpRecipient, address _marketingWallet, address _stakingPoolWallet) external onlyOwner{\\r\\n        require(_lpRecipient != address(0), \\\"lpRecipient cannot be the 0 address\\\");\\r\\n        require(_marketingWallet != address(0), \\\"marketingWallet cannot be the 0 address\\\");\\r\\n        require(_stakingPoolWallet != address(0), \\\"stakingPoolWallet cannot be the 0 address\\\");\\r\\n        lpRecipient = _lpRecipient;\\r\\n        marketingWallet = _marketingWallet;\\r\\n        stakingPoolWallet = _stakingPoolWallet;\\r\\n\\r\\n        exemptFee[stakingPoolWallet] = true;\\r\\n        exemptFee[marketingWallet] = true;\\r\\n        exemptFee[lpRecipient] = true;\\r\\n\\r\\n        isTxLimitExempt[stakingPoolWallet] = true;\\r\\n        isTxLimitExempt[marketingWallet] = true;\\r\\n        isTxLimitExempt[lpRecipient] = true;\\r\\n\\r\\n        emit TaxRecipientsUpdated(_lpRecipient, _marketingWallet, _stakingPoolWallet);\\r\\n    }\\r\\n\\r\\n    function setTransferFee(uint256 _transferFee) external onlyOwner{\\r\\n        require(_transferFee < 6, \\\"Transfer fee must be less than 6\\\");\\r\\n        transferFee = _transferFee;\\r\\n        emit FeesUpdated();\\r\\n    }\\r\\n\\r\\n    function setBuyFees(uint256 _lp, uint256 _marketing, uint256 _stakingPool) external onlyOwner{\\r\\n        require((_lp + _marketing + _stakingPool) < 10, \\\"Buy fee must be less than 10\\\");\\r\\n        buyFees = Fees(_lp, _marketing, _stakingPool);\\r\\n        totalBuyFee = _lp + _marketing + _stakingPool;\\r\\n        emit FeesUpdated();\\r\\n    }\\r\\n\\r\\n    function setSellFees(uint256 _lp, uint256 _marketing, uint256 _stakingPool) external onlyOwner{\\r\\n        require((_lp + _marketing + _stakingPool) < 10, \\\"Sell fee must be less than 10\\\");\\r\\n        sellFees = Fees(_lp, _marketing, _stakingPool);\\r\\n        totalSellFee = _lp + _marketing + _stakingPool;\\r\\n        emit FeesUpdated();\\r\\n    }\\r\\n\\r\\n    function setSwapThreshold(uint256 amount) external onlyOwner{\\r\\n        swapThreshold = amount * 10**DECIMALS;\\r\\n        emit SwapThresholdUpdated(amount);\\r\\n    }\\r\\n\\r\\n    function setMaxWalletAmount(uint256 amount) external onlyOwner{\\r\\n        require(amount >= 1_000_000_000, \\\"Max wallet amount must be >= 1_000_000_000\\\");\\r\\n        maxWalletAmount = amount * 10**DECIMALS;\\r\\n        emit MaxWalletAmountUpdated(amount);\\r\\n    }\\r\\n    \\r\\n    function setMaxTxAmount(uint256 amount) external onlyOwner{\\r\\n        require(amount >= 1_000_000_000, \\\"Max TX amount must be >= 1_000_000_000\\\");\\r\\n        maxTxAmount = amount * 10**DECIMALS;\\r\\n        emit MaxTXAmountUpdated(amount);\\r\\n    }\\r\\n\\r\\n    function setMulFeeExempt(address[] calldata addr, bool status) external onlyOwner {\\r\\n        for(uint256 i = 0; i < addr.length; i++) {\\r\\n            exemptFee[addr[i]] = status;\\r\\n            emit ExemptFromFeeUpdated(addr[i], status);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setMulTXExempt(address[] calldata addr, bool status) external onlyOwner {\\r\\n        for(uint256 i = 0; i < addr.length; i++) {\\r\\n            isTxLimitExempt[addr[i]] = status;\\r\\n            emit ExemptTXUpdated(addr[i], status);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setMulBlacklist(address[] calldata addr, bool _isBlacklist) external onlyOwner{\\r\\n        for (uint256 i = 0; i < addr.length; i++) {\\r\\n            isBlacklist[addr[i]] = _isBlacklist; \\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        require(!isBlacklist[from], \\\"From cannot be BOT\\\");\\r\\n\\r\\n        if(!exemptFee[from] && !exemptFee[to]) {\\r\\n            require(swapEnabled, \\\"Transactions are not enable\\\");\\r\\n            if(to != pair) require(balanceOf(to) + amount <= maxWalletAmount, \\\"Receiver balance is exceeding maxWalletAmount\\\");\\r\\n        }\\r\\n\\r\\n        if (swapEnabled && antiBot) {\\r\\n            isBlacklist[to] = true;\\r\\n        }\\r\\n\\r\\n        if (!isTxLimitExempt[from]) {\\r\\n            require(amount <= maxTxAmount, \\\"Buy/Sell exceeds the max tx\\\");\\r\\n        }\\r\\n\\r\\n        uint256 taxAmt;\\r\\n\\r\\n        if(!swapping && !exemptFee[from] && !exemptFee[to]){\\r\\n            if(to == pair){\\r\\n                taxAmt = amount * totalSellFee / 100;\\r\\n            } else if(from == pair){\\r\\n                taxAmt = amount * totalBuyFee / 100;\\r\\n            } else {\\r\\n                taxAmt = amount * transferFee / 100;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!swapping && to == pair && totalSellFee > 0) {\\r\\n            takeFees();\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount - taxAmt);\\r\\n        if(taxAmt > 0) {\\r\\n            super._transfer(from, address(this), taxAmt);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function takeFees() private inSwap {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        if (contractBalance >= swapThreshold) {\\r\\n            if(swapThreshold > 1){\\r\\n                contractBalance = swapThreshold;\\r\\n            }\\r\\n            // Split the contract balance into halves\\r\\n            uint256 denominator = totalSellFee * 2;\\r\\n            uint256 tokensToAddLiquidityWith = contractBalance * sellFees.lp / denominator;\\r\\n            uint256 toSwap = contractBalance - tokensToAddLiquidityWith;\\r\\n\\r\\n            uint256 initialBalance = address(this).balance;\\r\\n\\r\\n            swapTokensForETH(toSwap);\\r\\n\\r\\n            uint256 deltaBalance = address(this).balance - initialBalance;\\r\\n            uint256 unitBalance= deltaBalance / (denominator - sellFees.lp);\\r\\n            uint256 ethToAddLiquidityWith = unitBalance * sellFees.lp;\\r\\n\\r\\n            if(ethToAddLiquidityWith > 0){\\r\\n                // Add liquidity to Uniswap\\r\\n                addLiquidity(tokensToAddLiquidityWith, ethToAddLiquidityWith);\\r\\n            }\\r\\n\\r\\n            uint256 marketingAmt = unitBalance * 2 * sellFees.marketing;\\r\\n            if(marketingAmt > 0){\\r\\n                payable(marketingWallet).sendValue(marketingAmt);\\r\\n            }\\r\\n\\r\\n            uint256 stakingPoolAmt = unitBalance * 2 * sellFees.stakingPool;\\r\\n            if(stakingPoolAmt > 0){\\r\\n                payable(stakingPoolWallet).sendValue(stakingPoolAmt);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -> ETH\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        _approve(address(this), address(router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\\r\\n\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            lpRecipient,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setSwapEnabled() external onlyOwner {\\r\\n        swapEnabled = true;\\r\\n    }\\r\\n\\r\\n    function turnOffAntiBot() external onlyOwner {\\r\\n        antiBot = false;\\r\\n    }\\r\\n\\r\\n    function stuckETH() external payable {\\r\\n        require(address(this).balance > 0, \\\"Insufficient ETH balance\\\");\\r\\n        payable(marketingWallet).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function stuckERC20(address token, uint256 value) external {\\r\\n        require(\\r\\n            ERC20(token).balanceOf(address(this)) >= value,\\r\\n            \\\"Insufficient ERC20 balance\\\"\\r\\n        );\\r\\n        ERC20(token).transfer(marketingWallet, value);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ExemptFromFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ExemptTXUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxTXAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxWalletAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLpRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStakingPoolWallet\",\"type\":\"address\"}],\"name\":\"TaxRecipientsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exemptFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingPool\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isBlacklist\",\"type\":\"bool\"}],\"name\":\"setMulBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setMulFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setMulTXExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingPool\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingPoolWallet\",\"type\":\"address\"}],\"name\":\"setTaxRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPoolWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"stuckERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stuckETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOffAntiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SHIBAQATAR", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}