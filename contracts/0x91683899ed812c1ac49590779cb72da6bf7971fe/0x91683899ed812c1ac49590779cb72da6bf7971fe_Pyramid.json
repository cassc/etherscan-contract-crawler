{"SourceCode": "pragma solidity ^ 0.6.6;\r\n/*\r\n          ,/`.\r\n        ,'/ __`.\r\n      ,'_/__ _ _`.\r\n    ,'__/__ _ _  _`.\r\n  ,'_  /___ __ _ __ `.\r\n '-.._/___ _ __ __  __`.\r\n*/\r\n\r\ncontract ColorToken{\r\n\r\n\tmapping(address => uint256) public balances;\r\n\tmapping(address => uint256) public red;\r\n\tmapping(address => uint256) public green;\r\n\tmapping(address => uint256) public blue;\r\n\r\n\tuint public _totalSupply;\r\n\r\n\tmapping(address => mapping(address => uint)) approvals;\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount,\r\n\t\tbytes data\r\n\t);\r\n\t\r\n\tfunction totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\tfunction addColor(address addr, uint amount, uint _red, uint _green, uint _blue) internal {\r\n\t\t//adding color values to balance\r\n\t\tred[addr] += _red * amount;\r\n\t\tgreen[addr] += _green * amount;\r\n\t\tblue[addr] += _blue * amount;\r\n\t}\r\n\r\n\r\n  \tfunction RGB_Ratio() public view returns(uint,uint,uint){\r\n  \t\treturn RGB_Ratio(msg.sender);\r\n  \t}\r\n\r\n  \tfunction RGB_Ratio(address addr) public view returns(uint,uint,uint){\r\n  \t\t//returns the color of one's tokens\r\n  \t\tuint weight = balances[addr];\r\n  \t\tif (weight == 0){\r\n  \t\t\treturn (0,0,0);\r\n  \t\t}\r\n  \t\treturn ( red[addr]/weight, green[addr]/weight, blue[addr]/weight);\r\n  \t}\r\n\r\n  \tfunction RGB_scale(address addr, uint numerator, uint denominator) internal view returns(uint,uint,uint){\r\n\t\treturn (red[addr] * numerator / denominator, green[addr] * numerator / denominator, blue[addr] * numerator / denominator);\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds.\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) {\r\n\t\tif( isContract(_to) ){\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Standard function transfer similar to ERC20 transfer with no _data.\r\n\t// Added due to backwards compatibility reasons .\r\n\tfunction transfer(address _to, uint _value) public virtual returns (bool) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)){\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) internal virtual{\r\n\t\trequire( _amount <= balances[_from] );\r\n\r\n\t\t//mix colors\r\n\t\t(uint red_ratio, uint green_ratio, uint blue_ratio) = RGB_scale( _from, _amount, balances[_from] );\r\n\t\tred[_from] -= red_ratio;\r\n\t\tgreen[_from] -= green_ratio;\r\n\t\tblue[_from] -= blue_ratio;\r\n\t\tred[_to] += red_ratio;\r\n\t\tgreen[_to] += green_ratio;\r\n\t\tblue[_to] += blue_ratio;\r\n\r\n\t\t//update balances\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t}\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n  \t\r\n    function transferFrom(address src, address dst, uint amount) public returns (bool){\r\n        address sender = msg.sender;\r\n        require(approvals[src][sender] >=  amount);\r\n        require(balances[src] >= amount);\r\n        approvals[src][sender] -= amount;\r\n        moveTokens(src,dst,amount);\r\n        bytes memory empty;\r\n        emit Transfer(sender, dst, amount, empty);\r\n        return true;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint amount);\r\n    function approve(address guy, uint amount) public returns (bool) {\r\n        address sender = msg.sender;\r\n        approvals[sender][guy] = amount;\r\n\r\n        emit Approval( sender, guy, amount );\r\n        return true;\r\n    }\r\n\r\n    function isContract(address _addr) public view returns (bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract Pyramid is ColorToken{\r\n\t// scaleFactor is used to convert Ether into bonds and vice-versa: they're of different\r\n\t// orders of magnitude, hence the need to bridge between the two.\r\n\tuint256 constant scaleFactor = 0x10000000000000000;\r\n\taddress payable address0 = address(0);\r\n\r\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\r\n\r\n\t// Typical values that we have to declare.\r\n\tstring constant public name = \"Bonds\";\r\n\tstring constant public symbol = \"BOND\";\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tmapping(address => uint256) public average_ethSpent;\r\n\t// For calculating hodl multiplier that factors into resolves minted\r\n\tmapping(address => uint256) public average_buyInTimeSum;\r\n\t// Array between each address and their number of resolves being staked.\r\n\tmapping(address => uint256) public resolveWeight;\r\n\r\n\t// Array between each address and how much Ether has been paid out to it.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tmapping(address => int256) public payouts;\r\n\r\n\t// The total number of resolves being staked in this contract\r\n\tuint256 public dissolvingResolves;\r\n\r\n\t// For calculating the hodl multiplier. Weighted average release time\r\n\tuint public sumOfInputETH;\r\n\tuint public sumOfInputTime;\r\n\tuint public sumOfOutputETH;\r\n\tuint public sumOfOutputTime;\r\n\r\n\t// Something about invarience.\r\n\tint256 public earningsOffset;\r\n\r\n\t// Variable tracking how much Ether each token is currently worth// Note that this is scaled by the scaleFactor variable.\r\n\tuint256 public earningsPerResolve;\r\n\r\n\t//The resolve token contract\r\n\tResolveToken public resolveToken;\r\n\r\n\tconstructor() public{\r\n\t\tresolveToken = new ResolveToken( address(this) );\r\n\t}\r\n\r\n\tfunction fluxFee(uint paidAmount) public view returns (uint fee) {\r\n\t\t//we're only going to count resolve tokens that haven't been burned.\r\n\t\tuint totalResolveSupply = resolveToken.totalSupply() - resolveToken.balanceOf( address(0) );\r\n\t\tif ( dissolvingResolves == 0 )\r\n\t\t\treturn 0;\r\n\r\n\t\t//the fee is the % of resolve tokens outside of the contract\r\n\t\treturn paidAmount * ( totalResolveSupply - dissolvingResolves ) / totalResolveSupply * sumOfOutputETH / sumOfInputETH;\r\n\t}\r\n\r\n\t// Converts the Ether accrued as resolveEarnings back into bonds without having to\r\n\t// withdraw it first. Saves on gas and potential price spike loss.\r\n\tevent Reinvest( address indexed addr, uint256 reinvested, uint256 dissolved, uint256 bonds, uint256 resolveTax);\r\n\tfunction reinvestEarnings(uint amountFromEarnings) public returns(uint,uint){\r\n\t\taddress sender = msg.sender;\r\n\t\t// Retrieve the resolveEarnings associated with the address the request came from.\t\t\r\n\t\tuint upScaleDivs = (uint)((int256)( earningsPerResolve * resolveWeight[sender] ) - payouts[sender]);\r\n\t\tuint totalEarnings = upScaleDivs / scaleFactor;//resolveEarnings(sender);\r\n\t\trequire(amountFromEarnings <= totalEarnings, \"the amount exceeds total earnings\");\r\n\t\tuint oldWeight = resolveWeight[sender];\r\n\t\tresolveWeight[sender] = oldWeight * (totalEarnings - amountFromEarnings) / totalEarnings;\r\n\t\tuint weightDiff = oldWeight - resolveWeight[sender];\r\n\t\tresolveToken.transfer( address0, weightDiff );\r\n\t\tdissolvingResolves -= weightDiff;\r\n\t\t\r\n\t\t// something about invariance\r\n\t\tint withdrawnEarnings = (int)(upScaleDivs * amountFromEarnings / totalEarnings) - (int)(weightDiff*earningsPerResolve);\r\n\t\tpayouts[sender] += withdrawnEarnings;\r\n\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\tearningsOffset += withdrawnEarnings;\r\n\r\n\t\t// Assign balance to a new variable.\r\n\t\tuint value_ = (uint) (amountFromEarnings);\r\n\r\n\t\t// If your resolveEarnings are worth less than 1 szabo, abort.\r\n\t\tif (value_ < 0.000001 ether)\r\n\t\t\trevert();\r\n\r\n\t\t// Calculate the fee\r\n\t\tuint fee = fluxFee(value_);\r\n\r\n\t\t// The amount of Ether used to purchase new bonds for the caller\r\n\t\tuint numEther = value_ - fee;\r\n\r\n\t\t//resolve reward tracking stuff\r\n\t\taverage_ethSpent[sender] += numEther;\r\n\t\taverage_buyInTimeSum[sender] += now * scaleFactor * numEther;\r\n\t\tsumOfInputETH += numEther;\r\n\t\tsumOfInputTime += now * scaleFactor * numEther;\r\n\r\n\t\t// The number of bonds which can be purchased for numEther.\r\n\t\tuint createdBonds = ethereumToTokens_(numEther);\r\n\t\tuint[] memory RGB = new uint[](3);\r\n  \t\t(RGB[0], RGB[1], RGB[2]) = RGB_Ratio(sender);\r\n\t\t\r\n\t\taddColor(sender, createdBonds, RGB[0], RGB[1], RGB[2]);\r\n\r\n\t\t// the variable stoLOGC the amount to be paid to stakers\r\n\t\tuint resolveFee;\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tif ( dissolvingResolves > 0 ) {\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all existing resolve stakers before the new bonds are purchased.\r\n\t\t\t// rewardPerResolve is the amount(ETH) gained per resolve token from this purchase.\r\n\t\t\tuint rewardPerResolve = resolveFee / dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\r\n\t\t// Add the createdBonds to the total supply.\r\n\t\t_totalSupply += createdBonds;\r\n\r\n\t\t// Assign the bonds to the balance of the buyer.\r\n\t\tbalances[sender] += createdBonds;\r\n\r\n\t\temit Reinvest(sender, value_, weightDiff, createdBonds, resolveFee);\r\n\t\treturn (createdBonds, weightDiff);\r\n\t}\r\n\r\n\t// Sells your bonds for Ether\r\n\tfunction sellAllBonds() public returns(uint returned_eth, uint returned_resolves, uint initialInput_ETH){\r\n\t\treturn sell( balanceOf(msg.sender) );\r\n\t}\r\n\r\n\tfunction sellBonds(uint amount) public returns(uint returned_eth, uint returned_resolves, uint initialInput_ETH){\r\n\t\trequire(balanceOf(msg.sender) >= amount, \"Amount is more than balance\");\r\n\t\t( returned_eth, returned_resolves, initialInput_ETH ) = sell(amount);\r\n\t\treturn (returned_eth, returned_resolves, initialInput_ETH);\r\n\t}\r\n\r\n\t// Big red exit button to pull all of a holder's Ethereum value from the contract\r\n\tfunction getMeOutOfHere() public {\r\n\t\tsellAllBonds();\r\n\t\twithdraw( resolveEarnings(msg.sender) );\r\n\t}\r\n\r\n\t// Gatekeeper function to check if the amount of Ether being sent isn't too small\r\n\tfunction fund() payable public returns(uint createdBonds){\r\n\t\tuint[] memory RGB = new uint[](3);\r\n  \t\t(RGB[0], RGB[1], RGB[2]) = RGB_Ratio(msg.sender);\r\n\t\treturn buy(msg.sender, RGB[0], RGB[1], RGB[2]);\r\n  \t}\r\n \r\n\t// Calculate the current resolveEarnings associated with the caller address. This is the net result\r\n\t// of multiplying the number of resolves held by their current value in Ether and subtracting the\r\n\t// Ether that has already been paid out.\r\n\tfunction resolveEarnings(address _owner) public view returns (uint256 amount) {\r\n\t\treturn (uint256) ((int256)(earningsPerResolve * resolveWeight[_owner]) - payouts[_owner]) / scaleFactor;\r\n\t}\r\n\r\n\tevent Buy( address indexed addr, uint256 spent, uint256 bonds, uint256 resolveTax);\r\n\tfunction buy(address addr, uint _red, uint _green, uint _blue) public payable returns(uint createdBonds){\r\n\t\t//make sure the color components don't exceed limits\r\n\t\tif(_red>1e18) _red = 1e18;\r\n\t\tif(_green>1e18) _green = 1e18;\r\n\t\tif(_blue>1e18) _blue = 1e18;\r\n\t\t\r\n\t\t// Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\n\t\tif ( msg.value < 0.000001 ether )\r\n\t\t\trevert();\r\n\r\n\t\t// Calculate the fee\r\n\t\tuint fee = fluxFee(msg.value);\r\n\r\n\t\t// The amount of Ether used to purchase new bonds for the caller.\r\n\t\tuint numEther = msg.value - fee;\r\n\r\n\t\t//resolve reward tracking stuff\r\n\t\tuint currentTime = now;\r\n\t\taverage_ethSpent[addr] += numEther;\r\n\t\taverage_buyInTimeSum[addr] += currentTime * scaleFactor * numEther;\r\n\t\tsumOfInputETH += numEther;\r\n\t\tsumOfInputTime += currentTime * scaleFactor * numEther;\r\n\r\n\t\t// The number of bonds which can be purchased for numEther.\r\n\t\tcreatedBonds = ethereumToTokens_(numEther);\r\n\t\taddColor(addr, createdBonds, _red, _green, _blue);\r\n\r\n\t\t// Add the createdBonds to the total supply.\r\n\t\t_totalSupply += createdBonds;\r\n\r\n\t\t// Assign the bonds to the balance of the buyer.\r\n\t\tbalances[addr] += createdBonds;\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tuint resolveFee;\r\n\t\tif (dissolvingResolves > 0) {\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all existing resolve holders before the new bonds are purchased.\r\n\t\t\t// rewardPerResolve is the amount gained per resolve token from this purchase.\r\n\t\t\tuint rewardPerResolve = resolveFee/dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per resolve is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\t\temit Buy( addr, msg.value, createdBonds, resolveFee);\r\n\t\treturn createdBonds;\r\n\t}\r\n\r\n\tfunction avgHodl() public view returns(uint hodlTime){\r\n\t\treturn now - (sumOfInputTime - sumOfOutputTime) / (sumOfInputETH - sumOfOutputETH) / scaleFactor;\r\n\t}\r\n\r\n\tfunction getReturnsForBonds(address addr, uint bondsReleased) public view returns(uint etherValue, uint mintedResolves, uint new_releaseTimeSum, uint new_releaseAmount, uint initialInput_ETH){\r\n\t\tuint output_ETH = tokensToEthereum_(bondsReleased);\r\n\t\tuint input_ETH = average_ethSpent[addr] * bondsReleased / balances[addr];\r\n\t\t// hodl multiplier. because if you don't hodl at all, you shouldn't be rewarded resolves.\r\n\t\t// and the multiplier you get for hodling needs to be relative to the average hodl\r\n\t\tuint buyInTime = average_buyInTimeSum[addr] / average_ethSpent[addr];\r\n\t\tuint cashoutTime = now * scaleFactor - buyInTime;\r\n\t\tuint new_sumOfOutputTime = sumOfOutputTime + average_buyInTimeSum[addr] * bondsReleased / balances[addr];\r\n\t\tuint new_sumOfOutputETH = sumOfOutputETH + input_ETH; //It's based on the original ETH, so that's why input_ETH is used. Not output_ETH.\r\n\t\tuint averageHoldingTime = now * scaleFactor - ( sumOfInputTime - sumOfOutputTime ) / ( sumOfInputETH - sumOfOutputETH );\r\n\t\treturn (output_ETH, input_ETH * cashoutTime / averageHoldingTime * input_ETH / output_ETH, new_sumOfOutputTime, new_sumOfOutputETH, input_ETH);\r\n\t}\r\n\r\n\tevent Sell( address indexed addr, uint256 bondsSold, uint256 cashout, uint256 resolves, uint256 resolveTax, uint256 initialCash);\r\n\tfunction sell(uint256 amount) internal returns(uint eth, uint resolves, uint initialInput){\r\n\t\taddress payable sender = msg.sender;\r\n\t  \t// Calculate the amount of Ether & Resolves that the holder's bonds sell for at the current sell price.\r\n\r\n\t\tuint[] memory UINTs = new uint[](5);\r\n\t\t(\r\n\t\tUINTs[0]/*ether before fee*/,\r\n\t\tUINTs[1]/*minted resolves*/,\r\n\t\tUINTs[2]/*new_sumOfOutputTime*/,\r\n\t\tUINTs[3]/*new_sumOfOutputETH*/,\r\n\t\tUINTs[4]/*initialInput_ETH*/) = getReturnsForBonds(sender, amount);\r\n\r\n\t\t// calculate the fee\r\n\t    uint fee = fluxFee(UINTs[0]/*ether before fee*/);\r\n\r\n\t\t// magic distribution\r\n\t\tuint[] memory RGB = new uint[](3);\r\n  \t\t(RGB[0], RGB[1], RGB[2]) = RGB_Ratio(sender);\r\n\t\tresolveToken.mint(sender, UINTs[1]/*minted resolves*/, RGB[0], RGB[1], RGB[2]);\r\n\r\n\t\t// update weighted average cashout time\r\n\t\tsumOfOutputTime = UINTs[2]/*new_sumOfOutputTime*/;\r\n\t\tsumOfOutputETH = UINTs[3] /*new_sumOfOutputETH*/;\r\n\r\n\t\t// reduce the amount of \"eth spent\" based on the percentage of bonds being sold back into the contract\r\n\t\taverage_ethSpent[sender] = average_ethSpent[sender] * ( balances[sender] - amount) / balances[sender];\r\n\t\t// reduce the \"buyInTime\" sum that's used for average buy in time\r\n\t\taverage_buyInTimeSum[sender] = average_buyInTimeSum[sender] * (balances[sender] - amount) / balances[sender];\r\n\r\n\t\t// Net Ether for the seller after the fee has been subtracted.\r\n\t    uint numEthers = UINTs[0]/*ether before fee*/ - fee;\r\n\r\n\t\t// Burn the bonds which were just sold from the total supply.\r\n\t\t_totalSupply -= amount;\r\n\r\n\r\n\t    // maintain color density\r\n\t    thinColor( sender, balances[sender] - amount, balances[sender]);\r\n\t    // Remove the bonds from the balance of the buyer.\r\n\t    balances[sender] -= amount;\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tuint resolveFee;\r\n\t\tif ( dissolvingResolves > 0 ){\r\n\t\t\t// Scale the Ether taken as the selling fee by the scaleFactor variable.\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all remaining resolve holders.\r\n\t\t\t// rewardPerResolve is the amount gained per resolve thanks to this sell.\r\n\t\t\tuint rewardPerResolve = resolveFee/dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per resolve is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t(bool success, ) = sender.call{value:numEthers}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n\r\n\t\temit Sell( sender, amount, numEthers, UINTs[1]/*minted resolves*/, resolveFee, UINTs[4] /*initialInput_ETH*/);\r\n\t\treturn (numEthers, UINTs[1]/*minted resolves*/, UINTs[4] /*initialInput_ETH*/);\r\n\t}\r\n\r\n\tfunction thinColor(address addr, uint newWeight, uint oldWeight) internal{\r\n\t\t//bonds cease to exist so the color density needs to be updated.\r\n  \t\t(red[addr], green[addr], blue[addr]) = RGB_scale( addr, newWeight, oldWeight);\r\n  \t}\r\n\r\n\t// Allow contract to accept resolve tokens\r\n\tevent StakeResolves( address indexed addr, uint256 amountStaked, bytes _data );\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\tif(msg.sender == address(resolveToken) ){\r\n\t\t\tresolveWeight[from] += value;\r\n\t\t\tdissolvingResolves += value;\r\n\r\n\t\t\t// Then we update the payouts array for the \"resolve shareholder\" with this amount\r\n\t\t\tint payoutDiff = (int256) (earningsPerResolve * value);\r\n\t\t\tpayouts[from] += payoutDiff;\r\n\t\t\tearningsOffset += payoutDiff;\r\n\r\n\t\t\temit StakeResolves(from, value, _data);\r\n\t\t}else{\r\n\t\t\trevert(\"no want\");\r\n\t\t}\r\n\t}\r\n\r\n\t// Withdraws resolveEarnings held by the caller sending the transaction, updates\r\n\t// the requisite global variables, and transfers Ether back to the caller.\r\n\tevent Withdraw( address indexed addr, uint256 earnings, uint256 dissolve );\r\n\tfunction withdraw(uint amount) public returns(uint){\r\n\t\taddress payable sender = msg.sender;\r\n\t\t// Retrieve the resolveEarnings associated with the address the request came from.\r\n\t\tuint upScaleDivs = (uint)((int256)( earningsPerResolve * resolveWeight[sender] ) - payouts[sender]);\r\n\t\tuint totalEarnings = upScaleDivs / scaleFactor;\r\n\t\trequire( amount <= totalEarnings && amount > 0 );\r\n\t\tuint oldWeight = resolveWeight[sender];\r\n\t\tresolveWeight[sender] = oldWeight * ( totalEarnings - amount ) / totalEarnings;\r\n\t\tuint weightDiff = oldWeight - resolveWeight[sender];\r\n\t\tresolveToken.transfer( address0, weightDiff);\r\n\t\tdissolvingResolves -= weightDiff;\r\n\t\t\r\n\t\t// something about invariance\r\n\t\tint withdrawnEarnings = (int)(upScaleDivs * amount / totalEarnings) - (int)(weightDiff*earningsPerResolve);\r\n\t\tpayouts[sender] += withdrawnEarnings;\r\n\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\tearningsOffset += withdrawnEarnings;\r\n\r\n\r\n\t\t// Send the resolveEarnings to the address that requested the withdraw.\r\n\t\t(bool success, ) = sender.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed.\");\r\n\r\n\t\temit Withdraw( sender, amount, weightDiff);\r\n\t\treturn weightDiff;\r\n\t}\r\n\r\n\tevent PullResolves( address indexed addr, uint256 pulledResolves, uint256 forfeiture);\r\n\tfunction pullResolves(uint amount) public returns (uint forfeiture){\r\n\t\taddress sender = msg.sender;\r\n\t\tuint resolves = resolveWeight[ sender ];\r\n\t\trequire(amount <= resolves && amount > 0);\r\n\t\trequire(amount < dissolvingResolves);//\"you can't forfeit the last resolve\"\r\n\r\n\t\tuint yourTotalEarnings = (uint)((int256)(resolves * earningsPerResolve) - payouts[sender]);\r\n\t\tuint forfeitedEarnings = yourTotalEarnings * amount / resolves;\r\n\r\n\t\t// Update the payout array so that the \"resolve shareholder\" cannot claim resolveEarnings on previous staked resolves.\r\n\t\tpayouts[sender] += (int256)(forfeitedEarnings) - (int256)(earningsPerResolve * amount);\r\n\r\n\t\tresolveWeight[sender] -= amount;\r\n\t\tdissolvingResolves -= amount;\r\n\t\t// The Ether value per token is increased proportionally.\r\n\t\tearningsPerResolve += forfeitedEarnings / dissolvingResolves;\r\n\r\n\t\tresolveToken.transfer( sender, amount );\r\n\t\temit PullResolves( sender, amount, forfeitedEarnings / scaleFactor);\r\n\t\treturn forfeitedEarnings / scaleFactor;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) internal override{\r\n\t\t//mix multi-dimensional bond values\r\n\t\tuint totalBonds = balances[_from];\r\n\t\tuint ethSpent = average_ethSpent[_from] * _amount / totalBonds;\r\n\t\tuint buyInTimeSum = average_buyInTimeSum[_from] * _amount / totalBonds;\r\n\t\taverage_ethSpent[_from] -= ethSpent;\r\n\t\taverage_buyInTimeSum[_from] -= buyInTimeSum;\r\n\t\taverage_ethSpent[_to] += ethSpent;\r\n\t\taverage_buyInTimeSum[_to] += buyInTimeSum;\r\n\t\tsuper.moveTokens(_from, _to, _amount);\r\n\t}\r\n\r\n    function buyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(_totalSupply == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = fluxFee(_ethereum  );\r\n            uint256 _taxedEthereum = _ethereum + _dividends;\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    function sellPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(_totalSupply == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = fluxFee(_ethereum  );\r\n            uint256 _taxedEthereum = subtract(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 _dividends = fluxFee(_ethereumToSpend);\r\n        uint256 _taxedEthereum = subtract(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n    \r\n\r\n    function calculateEthereumReceived(uint256 _tokensToSell) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        require(_tokensToSell <= _totalSupply);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = fluxFee(_ethereum );\r\n        uint256 _taxedEthereum = subtract(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n\r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived = \r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                subtract(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(_totalSupply**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*_totalSupply)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(_totalSupply)\r\n        ;\r\n  \r\n        return _tokensReceived;\r\n    }\r\n\r\n    function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (_totalSupply + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            // underflow attempts BTFO\r\n            subtract(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    function subtract(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n}\r\n\r\ncontract ResolveToken is ColorToken{\r\n\r\n\tstring public name = \"Color\";\r\n    string public symbol = \"`c\";\r\n    uint8 constant public decimals = 18;\r\n\taddress public hourglass;\r\n\r\n\tconstructor(address _hourglass) public{\r\n\t\thourglass = _hourglass;\r\n\t}\r\n\r\n\tmodifier hourglassOnly{\r\n\t  require(msg.sender == hourglass);\r\n\t  _;\r\n    }\r\n\r\n\tevent Mint(\r\n\t\taddress indexed addr,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\tfunction mint(address _address, uint _value, uint _red, uint _green, uint _blue) external hourglassOnly(){\r\n\t\tbalances[_address] += _value;\r\n\t\t_totalSupply += _value;\r\n\t\taddColor(_address, _value, _red, _green, _blue);\r\n\t\temit Mint(_address, _value);\r\n\t}\r\n}\r\n\r\nabstract contract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external virtual;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pulledResolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forfeiture\",\"type\":\"uint256\"}],\"name\":\"PullResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dissolved\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondsSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialCash\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"StakeResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dissolve\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RGB_Ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"RGB_Ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"average_buyInTimeSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"average_ethSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgHodl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hodlTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blue\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdBonds\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dissolvingResolves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningsOffset\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningsPerResolve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"fluxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"createdBonds\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMeOutOfHere\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bondsReleased\",\"type\":\"uint256\"}],\"name\":\"getReturnsForBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedResolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseTimeSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialInput_ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"green\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is_contract\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payouts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullResolves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forfeiture\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"red\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountFromEarnings\",\"type\":\"uint256\"}],\"name\":\"reinvestEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"resolveEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolveToken\",\"outputs\":[{\"internalType\":\"contract ResolveToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"resolveWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellAllBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returned_eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returned_resolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialInput_ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returned_eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returned_resolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialInput_ETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfInputETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfInputTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfOutputETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfOutputTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pyramid", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d0efb97e259f645bf57129f8680e30702c0bbd38bba139fc8e68af58d9f60ea5"}