{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/oracles/UniswapV2PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IUniswapV2Pair} from \\\"lib/uniswap-v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\nimport {IPriceOracle} from \\\"../interfaces/IPriceOracle.sol\\\";\\n\\n/**\\n * @title CoW AMM UniswapV2 Price Oracle\\n * @author CoW Protocol Developers\\n * @dev This contract creates an oracle that is compatible with the IPriceOracle\\n * interface and can be used by a CoW AMM to determine the current price of the\\n * traded tokens on specific Uniswap v2 pools.\\n */\\ncontract UniswapV2PriceOracle is IPriceOracle {\\n    /**\\n     * Data required by the oracle to determine the current price.\\n     */\\n    struct Data {\\n        /**\\n         * The Uniswap v2 pair to use as a price reference.\\n         * It is expected that the pair's token0 and token1 coincide with the\\n         * tokens traded by the AMM and have the same order.\\n         */\\n        IUniswapV2Pair referencePair;\\n    }\\n\\n    /**\\n     * @inheritdoc IPriceOracle\\n     */\\n    function getPrice(address token0, address token1, bytes calldata data)\\n        external\\n        view\\n        returns (uint256 priceNumerator, uint256 priceDenominator)\\n    {\\n        Data memory oracleData = abi.decode(data, (Data));\\n        (priceNumerator, priceDenominator,) = oracleData.referencePair.getReserves();\\n        address uniswapToken0 = oracleData.referencePair.token0();\\n        address uniswapToken1 = oracleData.referencePair.token1();\\n        if (token0 == uniswapToken1) {\\n            (priceNumerator, priceDenominator) = (priceDenominator, priceNumerator);\\n            (uniswapToken0, uniswapToken1) = (uniswapToken1, uniswapToken0);\\n        }\\n        require(token0 == uniswapToken0, \\\"oracle: invalid token0\\\");\\n        require(token1 == uniswapToken1, \\\"oracle: invalid token1\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/uniswap-v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @title CoW AMM Price Oracle Interface\\n * @author CoW Protocol Developers\\n * @dev A contract that can be used by the CoW AMM as as a price oracle.\\n * The price source depends on the actual implementation; it could rely for\\n * example on Uniswap, Balancer, Chainlink...\\n */\\ninterface IPriceOracle {\\n    /**\\n     * @dev Calling this function returns the price of token1 in terms of token0\\n     * as a fraction (numerator, denominator).\\n     * For example, in a pool where token0 is DAI, token1 is ETH, and ETH is\\n     * worth 2000 DAI, valid output tuples would be (2000, 1), (20000, 10), ...\\n     * @dev To keep the risk of multiplication overflow to a minimum, we\\n     * recommend to use return values that fit the size of a uint128.\\n     * @param token0 The first token, whose price is determined based on the\\n     * second token.\\n     * @param token1 The second token; the price of the first token is\\n     * determined relative to this token.\\n     * @param data Any additional data that may be required by the specific\\n     * oracle implementation. For example, it could be a specific pool id for\\n     * balancer, or the address of a specific price feed for Chainlink.\\n     * We recommend this data be implemented as the abi-encoding of a dedicated\\n     * data struct for ease of type-checking and decoding the input.\\n     * @return priceNumerator The numerator of the price, expressed in amount of\\n     * token1 per amount of token0.\\n     * @return priceDenominator The denominator of the price, expressed in\\n     * amount of token1 per amount of token0.\\n     */\\n    function getPrice(address token0, address token1, bytes calldata data)\\n        external\\n        view\\n        returns (uint256 priceNumerator, uint256 priceDenominator);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"lib/composable-cow:cowprotocol/=lib/composable-cow/lib/cowprotocol/src/contracts/\",\r\n      \"lib/composable-cow:safe/=lib/composable-cow/lib/safe/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"lib/composable-cow:@openzeppelin/contracts/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"@openzeppelin/=lib/composable-cow/lib/@openzeppelin/\",\r\n      \"@openzeppelin/contracts/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"balancer/=lib/composable-cow/lib/balancer/src/\",\r\n      \"canonical-weth/=lib/composable-cow/lib/canonical-weth/src/\",\r\n      \"composable-cow/=lib/composable-cow/\",\r\n      \"cowprotocol/=lib/composable-cow/lib/cowprotocol/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/composable-cow/lib/@openzeppelin/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"helpers/=lib/composable-cow/lib/balancer/src/lib/helpers/\",\r\n      \"math/=lib/composable-cow/lib/balancer/src/lib/math/\",\r\n      \"murky/=lib/composable-cow/lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/composable-cow/lib/canonical-weth/lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/composable-cow/lib/@openzeppelin/contracts/\",\r\n      \"safe/=lib/composable-cow/lib/safe/\",\r\n      \"uniswap-v2-core/=lib/uniswap-v2-core/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDenominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapV2PriceOracle", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}