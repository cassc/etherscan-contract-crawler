{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IPlanetaryPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IPlanetaryPositions {\\n\\n  enum CelestialBody {\\n    SUN,\\n    MERCURY,\\n    VENUS,\\n    EARTH,\\n    MOON,\\n    MARS,\\n    JUPITER,\\n    SATURN,\\n    URANUS,\\n    NEPTUNE,\\n    OTHER\\n  }\\n\\n    /**\\n   * @notice The orbital elements consist of 6 quantities which completely define a circular, elliptic, \\n   *         parabolic or hyperbolic orbit.\\n   *\\n   *         Three of these quantities describe the shape and size of the orbit, and the position of \\n   *         the planet in the orbit:\\n   *         - a : Mean distance, or semi-major axis\\n   *         - e : Exxcentricity\\n   *         - T : Time at perihelion\\n   *         The three remaining orbital elements define the orientation of the orbit in space:\\n   *         - i : Inclination, i.e. the \\\"tilt\\\" of the orbit relative to the ecliptic.  The inclination \\n   *           varies from 0 to 180 degrees. If the inclination is larger than 90 degrees, the planet \\n   *           is in a retrogade orbit, i.e. it moves \\\"backwards\\\". The most well-known celestial body \\n   *           with retrogade motion is Comet Halley.\\n   *         - N : (usually written as \\\"Capital Omega\\\") Longitude of Ascending Node. This is the angle, \\n   *           along the ecliptic, from the Vernal Point to the Ascending Node, which is the intersection \\n   *           between the orbit and the ecliptic, where the planet moves from south of to north of the \\n   *           ecliptic, i.e. from negative to positive latitudes.\\n   *         - w : (usually written as \\\"small Omega\\\") The angle from the Ascending node to the Perihelion, \\n   *           along the orbit.\\n   *\\n   *         These are the primary orbital elements. From these many secondary orbital elements can be \\n   *         computed. Only one is stored in the struct:\\n   *         - M : Mean Anomaly = n * (t - T)  =  (t - T) * 360_deg / P. Mean Anomaly is 0 at \\n   *           perihelion and 180 degrees at aphelion.\\n   *\\n   * All values are scaled by 1e18.\\n   */\\n  struct OrbitalElements {\\n    // The celestial body of these orbital elements\\n    // If filled with some known planets, perturbation corrections will be done\\n    CelestialBody body;\\n    // The origin(center) of the orbit\\n    CelestialBody origin;\\n\\n    // The \\\"day number\\\" moment in time of these orbital elements, scaled by 1e18\\n    int dayNumber;\\n\\n    // Long asc. node, radians\\n    int N;\\n    // Inclination; radians\\n    int i;\\n    // Arg. of perigee, radians\\n    int w;\\n    // Mean distance\\n    int a;\\n    // Eccentricity\\n    int e;\\n    // Mean anomaly, radians\\n    int M;\\n  }\\n\\n  /**\\n   * @notice The orbital elements parameters, necessary to compute the orbital elements at a given point\\n   *         in time.\\n   */\\n  struct OrbitalElementsParameters {\\n    // The celestial body of these orbital elements\\n    // If filled with some known planets, perturbation corrections will be done\\n    CelestialBody body;\\n    // The origin(center) of the orbit\\n    CelestialBody origin;\\n\\n    // Long asc. node, radians\\n    int N;\\n    int dN;\\n    // Inclination; radians\\n    int i;\\n    int di;\\n    // Arg. of perigee, radians\\n    int w;\\n    int dw;\\n    // Mean distance\\n    int a;\\n    int da;\\n    // Eccentricity\\n    int e;\\n    int de;\\n    // Mean anomaly, radians\\n    int M;\\n    int dM;\\n  }\\n\\n  // An axial tilt of a planet\\n  struct AxialTilt {\\n    // Radians\\n    int at;\\n    int dat;\\n  }\\n\\n  \\n  /**\\n   * Functions: See doc on PlanetaryPositionLib.sol\\n   */\\n\\n  function getDayNumberFromGregorianCalendar(uint year, uint month, uint day, uint hour, uint min) external pure returns (int);\\n\\n  function getDayNumberFromGregorianCalendar1900to2100(uint year, uint month, uint day, uint hour, uint min) external pure returns (int);\\n\\n  function getDayNumberFromTimestamp(uint timestamp) external pure returns (int);\\n\\n\\n\\n\\n  function getBodyAzimuthAltitude(int observerLongitude, int observerLatitude, CelestialBody body, int dayNumber) external pure returns (int azimuth, int altitude, uint distance);\\n\\n  function getBodyAzimuthAltitudeInRadians(int observerLongitude, int observerLatitude, CelestialBody body, int dayNumber) external pure returns (int azimuth, int altitude, uint distance);\\n\\n  function getBodyBodyAzimuthAltitudeInRadians(OrbitalElements memory orbitalElements, AxialTilt memory originAxialTilt, OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude, int localSiderealTime) external pure returns (int azimuth, int altitude, uint distance);\\n\\n\\n\\n\\n  function getBodyTopocentricRADecl(int observerLongitude, int observerLatitude, CelestialBody body, int dayNumber) external pure returns (int rightAscension, int declination, uint distance);\\n\\n  function getBodyTopocentricRADeclInRadians(int observerLongitude, int observerLatitude, CelestialBody body, int dayNumber) external pure returns (int rightAscension, int declination, uint distance);\\n\\n  function getBodyBodyTopocentricRADeclInRadians(OrbitalElements memory orbitalElements, AxialTilt memory originAxialTilt, OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude)  external pure returns (int rightAscension, int declination, uint distance);\\n\\n\\n\\n\\n  function getBodyGeocentricRADecl(CelestialBody body, int dayNumber) external pure returns (int rightAscension, int declination, uint distance);\\n\\n  function getBodyGeocentricRADeclInRadians(CelestialBody body, int dayNumber) external pure returns (int rightAscension, int declination, uint distance);\\n\\n  function getBodyBodycentricRADeclInRadians(OrbitalElements memory orbitalElements, AxialTilt memory originAxialTilt, OrbitalElements memory newOriginOrbitalElements) external pure returns (int rightAscension, int declination, uint distance);\\n\\n\\n\\n\\n  function getBodyEclipticLonLat(CelestialBody body, int dayNumber) external pure returns (int longitude, int latitude, uint distance);\\n\\n  function getBodyEclipticLonLatInRadians(CelestialBody body, int dayNumber) external pure returns (int longitude, int latitude, uint distance);\\n\\n  function getBodyEclipticLonLatInRadians(OrbitalElements memory orbitalElements) external pure returns (int longitude, int latitude, uint distance);\\n\\n\\n\\n\\n  function getLocalSiderealTime(int longitude, int dayNumber) external pure returns (int siderealTime);\\n\\n  function getLocalSiderealTimeInRadians(int longitude, int dayNumber) external pure returns (int siderealTime);\\n\\n\\n\\n\\n  function getOrbitalElements(CelestialBody body, int dayNumber) external pure returns (OrbitalElements memory elements);\\n\\n  function getOrbitalElements(OrbitalElementsParameters memory elementsParameters, int dayNumber) external pure returns (OrbitalElements memory elements);\\n\\n  function getOrbitalElementsParameters(CelestialBody body) external pure returns (OrbitalElementsParameters memory elementsParameters);\\n}\"\r\n    },\r\n    \"contracts/libs/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Solidity library offering basic functions where inputs and outputs are\\n * integers. Inputs are specified in units scaled by 1e18, and similarly outputs are scaled by 1e18.\\n */\\n\\nlibrary Math {\\n\\n  /**\\n   * Returns the square root of a number scaled by 1e18\\n   * Sourced from uniswap v2 on\\n   * https://github.com/Uniswap/v2-core/blob/v1.0.1/contracts/libraries/Math.sol\\n   * and adapted for 1e18 numbers.\\n   */\\n  function sqrt(uint y) internal pure returns (uint z) {\\n    if (y > 3) {\\n      z = y;\\n      uint x = y / 2 + 1;\\n      while (x < z) {\\n        z = x;\\n        x = (y / x + x) / 2;\\n      }\\n    } else if (y != 0) {\\n      z = 1;\\n    }\\n\\n    z *= 1e9;\\n  }\\n\\n  /**\\n   * Simple abs function\\n   */\\n  function abs(int x) internal pure returns (uint) {\\n    if(x < 0) {\\n      return uint(- x);\\n    }\\n    return uint(x);\\n  }\\n\\n  /**\\n   * Floor a number scaled by 1e18\\n   */\\n  function floor(int x) internal pure returns (int) {\\n    if(x < 0) {\\n      return x - (x % 1e18 + 1e18);\\n    }\\n    return x - x % 1e18;\\n  }\\n\\n  function round(int x) internal pure returns (int) {\\n    int part = x % 1e18;\\n    if(x > 0 && part >= 1e18 / 2) {\\n      return x - part + 1e18;\\n    }\\n    if(x < 0 && part <= - 1e18 / 2) {\\n      return x - part - 1e18;\\n    }\\n    return x - part;\\n  }\\n\\n  /**\\n   *  Round down a 1e18-scaled number:\\n   * 4.50001 => 5\\n   * 4.5 => 4\\n   * 4.49999 => 4\\n   */\\n  function roundDown(int x) internal pure returns (int) {\\n    int part = x % 1e18;\\n    if(x > 0 && part > 1e18 / 2) {\\n      return x - part + 1e18;\\n    }\\n    if(x < 0 && part < - 1e18 / 2) {\\n      return x - part - 1e18;\\n    }\\n    return x - part;\\n  }\\n}\"\r\n    },\r\n    \"contracts/libs/Trigonometry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Imported from: https://github.com/mds1/solidity-trigonometry\\n// Added arctan function, see below\\npragma solidity ^0.8.0;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @notice Solidity library offering basic trigonometry functions where inputs and outputs are\\n * integers. Inputs are specified in radians scaled by 1e18, and similarly outputs are scaled by 1e18.\\n *\\n * This implementation is based off the Solidity trigonometry library written by Lefteris Karapetsas\\n * which can be found here: https://github.com/Sikorkaio/sikorka/blob/e75c91925c914beaedf4841c0336a806f2b5f66d/contracts/trigonometry.sol\\n *\\n * Compared to Lefteris' implementation, this version makes the following changes:\\n *   - Uses a 32 bits instead of 16 bits for improved accuracy\\n *   - Updated for Solidity 0.8.x\\n *   - Various gas optimizations\\n *   - Change inputs/outputs to standard trig format (scaled by 1e18) instead of requiring the\\n *     integer format used by the algorithm\\n *\\n * Lefertis' implementation is based off Dave Dribin's trigint C library\\n *     http://www.dribin.org/dave/trigint/\\n *\\n * Which in turn is based from a now deleted article which can be found in the Wayback Machine:\\n *     http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html\\n */\\nlibrary Trigonometry {\\n  // Table index into the trigonometric table\\n  uint256 constant INDEX_WIDTH        = 8;\\n  // Interpolation between successive entries in the table\\n  uint256 constant INTERP_WIDTH       = 16;\\n  uint256 constant INDEX_OFFSET       = 28 - INDEX_WIDTH;\\n  uint256 constant INTERP_OFFSET      = INDEX_OFFSET - INTERP_WIDTH;\\n  uint32  constant ANGLES_IN_CYCLE    = 1073741824;\\n  uint32  constant QUADRANT_HIGH_MASK = 536870912;\\n  uint32  constant QUADRANT_LOW_MASK  = 268435456;\\n  uint256 constant SINE_TABLE_SIZE    = 256;\\n\\n  // Pi as an 18 decimal value, which is plenty of accuracy: \\\"For JPL's highest accuracy calculations, which are for\\n  // interplanetary navigation, we use 3.141592653589793: https://www.jpl.nasa.gov/edu/news/2016/3/16/how-many-decimals-of-pi-do-we-really-need/\\n  uint256 constant PI          = 3141592653589793238;\\n  uint256 constant TWO_PI      = 2 * PI;\\n  uint256 constant PI_OVER_TWO = PI / 2;\\n\\n  // The constant sine lookup table was generated by generate_trigonometry.py. We must use a constant\\n  // bytes array because constant arrays are not supported in Solidity. Each entry in the lookup\\n  // table is 4 bytes. Since we're using 32-bit parameters for the lookup table, we get a table size\\n  // of 2^(32/4) + 1 = 257, where the first and last entries are equivalent (hence the table size of\\n  // 256 defined above)\\n  uint8   constant entry_bytes = 4; // each entry in the lookup table is 4 bytes\\n  uint256 constant entry_mask  = ((1 << 8*entry_bytes) - 1); // mask used to cast bytes32 -> lookup table entry\\n  bytes   constant sin_table   = hex\\\"00_00_00_00_00_c9_0f_88_01_92_1d_20_02_5b_26_d7_03_24_2a_bf_03_ed_26_e6_04_b6_19_5d_05_7f_00_35_06_47_d9_7c_07_10_a3_45_07_d9_5b_9e_08_a2_00_9a_09_6a_90_49_0a_33_08_bc_0a_fb_68_05_0b_c3_ac_35_0c_8b_d3_5e_0d_53_db_92_0e_1b_c2_e4_0e_e3_87_66_0f_ab_27_2b_10_72_a0_48_11_39_f0_cf_12_01_16_d5_12_c8_10_6e_13_8e_db_b1_14_55_76_b1_15_1b_df_85_15_e2_14_44_16_a8_13_05_17_6d_d9_de_18_33_66_e8_18_f8_b8_3c_19_bd_cb_f3_1a_82_a0_25_1b_47_32_ef_1c_0b_82_6a_1c_cf_8c_b3_1d_93_4f_e5_1e_56_ca_1e_1f_19_f9_7b_1f_dc_dc_1b_20_9f_70_1c_21_61_b3_9f_22_23_a4_c5_22_e5_41_af_23_a6_88_7e_24_67_77_57_25_28_0c_5d_25_e8_45_b6_26_a8_21_85_27_67_9d_f4_28_26_b9_28_28_e5_71_4a_29_a3_c4_85_2a_61_b1_01_2b_1f_34_eb_2b_dc_4e_6f_2c_98_fb_ba_2d_55_3a_fb_2e_11_0a_62_2e_cc_68_1e_2f_87_52_62_30_41_c7_60_30_fb_c5_4d_31_b5_4a_5d_32_6e_54_c7_33_26_e2_c2_33_de_f2_87_34_96_82_4f_35_4d_90_56_36_04_1a_d9_36_ba_20_13_37_6f_9e_46_38_24_93_b0_38_d8_fe_93_39_8c_dd_32_3a_40_2d_d1_3a_f2_ee_b7_3b_a5_1e_29_3c_56_ba_70_3d_07_c1_d5_3d_b8_32_a5_3e_68_0b_2c_3f_17_49_b7_3f_c5_ec_97_40_73_f2_1d_41_21_58_9a_41_ce_1e_64_42_7a_41_d0_43_25_c1_35_43_d0_9a_ec_44_7a_cd_50_45_24_56_bc_45_cd_35_8f_46_75_68_27_47_1c_ec_e6_47_c3_c2_2e_48_69_e6_64_49_0f_57_ee_49_b4_15_33_4a_58_1c_9d_4a_fb_6c_97_4b_9e_03_8f_4c_3f_df_f3_4c_e1_00_34_4d_81_62_c3_4e_21_06_17_4e_bf_e8_a4_4f_5e_08_e2_4f_fb_65_4c_50_97_fc_5e_51_33_cc_94_51_ce_d4_6e_52_69_12_6e_53_02_85_17_53_9b_2a_ef_54_33_02_7d_54_ca_0a_4a_55_60_40_e2_55_f5_a4_d2_56_8a_34_a9_57_1d_ee_f9_57_b0_d2_55_58_42_dd_54_58_d4_0e_8c_59_64_64_97_59_f3_de_12_5a_82_79_99_5b_10_35_ce_5b_9d_11_53_5c_29_0a_cc_5c_b4_20_df_5d_3e_52_36_5d_c7_9d_7b_5e_50_01_5d_5e_d7_7c_89_5f_5e_0d_b2_5f_e3_b3_8d_60_68_6c_ce_60_ec_38_2f_61_6f_14_6b_61_f1_00_3e_62_71_fa_68_62_f2_01_ac_63_71_14_cc_63_ef_32_8f_64_6c_59_bf_64_e8_89_25_65_63_bf_91_65_dd_fb_d2_66_57_3c_bb_66_cf_81_1f_67_46_c7_d7_67_bd_0f_bc_68_32_57_aa_68_a6_9e_80_69_19_e3_1f_69_8c_24_6b_69_fd_61_4a_6a_6d_98_a3_6a_dc_c9_64_6b_4a_f2_78_6b_b8_12_d0_6c_24_29_5f_6c_8f_35_1b_6c_f9_34_fb_6d_62_27_f9_6d_ca_0d_14_6e_30_e3_49_6e_96_a9_9c_6e_fb_5f_11_6f_5f_02_b1_6f_c1_93_84_70_23_10_99_70_83_78_fe_70_e2_cb_c5_71_41_08_04_71_9e_2c_d1_71_fa_39_48_72_55_2c_84_72_af_05_a6_73_07_c3_cf_73_5f_66_25_73_b5_eb_d0_74_0b_53_fa_74_5f_9d_d0_74_b2_c8_83_75_04_d3_44_75_55_bd_4b_75_a5_85_ce_75_f4_2c_0a_76_41_af_3c_76_8e_0e_a5_76_d9_49_88_77_23_5f_2c_77_6c_4e_da_77_b4_17_df_77_fa_b9_88_78_40_33_28_78_84_84_13_78_c7_ab_a1_79_09_a9_2c_79_4a_7c_11_79_8a_23_b0_79_c8_9f_6d_7a_05_ee_ac_7a_42_10_d8_7a_7d_05_5a_7a_b6_cb_a3_7a_ef_63_23_7b_26_cb_4e_7b_5d_03_9d_7b_92_0b_88_7b_c5_e2_8f_7b_f8_88_2f_7c_29_fb_ed_7c_5a_3d_4f_7c_89_4b_dd_7c_b7_27_23_7c_e3_ce_b1_7d_0f_42_17_7d_39_80_eb_7d_62_8a_c5_7d_8a_5f_3f_7d_b0_fd_f7_7d_d6_66_8e_7d_fa_98_a7_7e_1d_93_e9_7e_3f_57_fe_7e_5f_e4_92_7e_7f_39_56_7e_9d_55_fb_7e_ba_3a_38_7e_d5_e5_c5_7e_f0_58_5f_7f_09_91_c3_7f_21_91_b3_7f_38_57_f5_7f_4d_e4_50_7f_62_36_8e_7f_75_4e_7f_7f_87_2b_f2_7f_97_ce_bc_7f_a7_36_b3_7f_b5_63_b2_7f_c2_55_95_7f_ce_0c_3d_7f_d8_87_8d_7f_e1_c7_6a_7f_e9_cb_bf_7f_f0_94_77_7f_f6_21_81_7f_fa_72_d0_7f_fd_88_59_7f_ff_62_15_7f_ff_ff_ff\\\";\\n\\n  // 6 constants needed to compute atan, encoded each as int32 scaled by 1e7\\n  // Generated by generateAtanByteArray.js\\n  // \\n  // Algo taken from https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\\n  // (MIT license, Copyright (c) 2017-2020 Novak Distributed), modified for\\n  // angle in radian scaled by 10^18\\n  //\\n  // Uses the Chebyshev polynomial approach presented at\\n  // https://www.mathworks.com/help/fixedpoint/examples/calculate-fixed-point-arctangent.html\\n  // Uses polynomials received by personal communication.\\n  // 0.999974x-0.332568x^3+0.193235x^5-0.115729x^7+0.0519505x^9-0.0114658x^11\\n  uint256 constant atan_table = 0x0098957c_ffcd4110_001d7c3e_ffee5756_0007ed51_fffe401e;\\n\\n  /**\\n   * @notice Return the sine of a value, specified in radians scaled by 1e18\\n   * @dev This algorithm for converting sine only uses integer values, and it works by dividing the\\n   * circle into 30 bit angles, i.e. there are 1,073,741,824 (2^30) angle units, instead of the\\n   * standard 360 degrees (2pi radians). From there, we get an output in range -2,147,483,647 to\\n   * 2,147,483,647, (which is the max value of an int32) which is then converted back to the standard\\n   * range of -1 to 1, again scaled by 1e18\\n   * @param angle Angle to convert\\n   * @return Result scaled by 1e18\\n   */\\n  function sin(int256 angle) internal pure returns (int256) {\\n    unchecked {\\n      // Addition to original algorithm: Add support for negative angle\\n      // If negative, convert to a positive angle\\n      if(angle < 0) {\\n        angle += - (angle / int256(TWO_PI) - 1) * int256(TWO_PI);\\n      }\\n      uint256 _uangle = uint256(angle);\\n\\n      // Convert angle from from arbitrary radian value (range of 0 to 2pi) to the algorithm's range\\n      // of 0 to 1,073,741,824\\n      _uangle = ANGLES_IN_CYCLE * (_uangle % TWO_PI) / TWO_PI;\\n\\n      // Apply a mask on an integer to extract a certain number of bits, where angle is the integer\\n      // whose bits we want to get, the width is the width of the bits (in bits) we want to extract,\\n      // and the offset is the offset of the bits (in bits) we want to extract. The result is an\\n      // integer containing _width bits of _value starting at the offset bit\\n      uint256 interp = (_uangle >> INTERP_OFFSET) & ((1 << INTERP_WIDTH) - 1);\\n      uint256 index  = (_uangle >> INDEX_OFFSET)  & ((1 << INDEX_WIDTH)  - 1);\\n\\n      // The lookup table only contains data for one quadrant (since sin is symmetric around both\\n      // axes), so here we figure out which quadrant we're in, then we lookup the values in the\\n      // table then modify values accordingly\\n      bool is_odd_quadrant      = (_uangle & QUADRANT_LOW_MASK)  == 0;\\n      bool is_negative_quadrant = (_uangle & QUADRANT_HIGH_MASK) != 0;\\n\\n      if (!is_odd_quadrant) {\\n        index = SINE_TABLE_SIZE - 1 - index;\\n      }\\n\\n      bytes memory table = sin_table;\\n      // We are looking for two consecutive indices in our lookup table\\n      // Since EVM is left aligned, to read n bytes of data from idx i, we must read from `i * data_len` + `n`\\n      // therefore, to read two entries of size entry_bytes `index * entry_bytes` + `entry_bytes * 2`\\n      uint256 offset1_2 = (index + 2) * entry_bytes;\\n\\n      // This following snippet will function for any entry_bytes <= 15\\n      uint256 x1_2; assembly {\\n        // mload will grab one word worth of bytes (32), as that is the minimum size in EVM\\n        x1_2 := mload(add(table, offset1_2))\\n      }\\n\\n      // We now read the last two numbers of size entry_bytes from x1_2\\n      // in example: entry_bytes = 4; x1_2 = 0x00...12345678abcdefgh\\n      // therefore: entry_mask = 0xFFFFFFFF\\n\\n      // 0x00...12345678abcdefgh >> 8*4 = 0x00...12345678\\n      // 0x00...12345678 & 0xFFFFFFFF = 0x12345678\\n      uint256 x1 = x1_2 >> 8*entry_bytes & entry_mask;\\n      // 0x00...12345678abcdefgh & 0xFFFFFFFF = 0xabcdefgh\\n      uint256 x2 = x1_2 & entry_mask;\\n\\n      // Approximate angle by interpolating in the table, accounting for the quadrant\\n      uint256 approximation = ((x2 - x1) * interp) >> INTERP_WIDTH;\\n      int256 sine = is_odd_quadrant ? int256(x1) + int256(approximation) : int256(x2) - int256(approximation);\\n      if (is_negative_quadrant) {\\n        sine *= -1;\\n      }\\n\\n      // Bring result from the range of -2,147,483,647 through 2,147,483,647 to -1e18 through 1e18.\\n      // This can never overflow because sine is bounded by the above values\\n      return sine * 1e18 / 2_147_483_647;\\n    }\\n  }\\n\\n  /**\\n   * @notice Return the cosine of a value, specified in radians scaled by 1e18\\n   * @dev This is identical to the sin() method, and just computes the value by delegating to the\\n   * sin() method using the identity cos(x) = sin(x + pi/2)\\n   * @dev Overflow when `angle + PI_OVER_TWO > type(uint256).max` is ok, results are still accurate\\n   * @param _angle Angle to convert\\n   * @return Result scaled by 1e18\\n   */\\n  function cos(int256 _angle) internal pure returns (int256) {\\n    unchecked {\\n      return sin(_angle + int256(PI_OVER_TWO));\\n    }\\n  }\\n\\n  /**\\n   * @notice Return the tangent of a value, specified in radians scaled by 1e18\\n   */\\n  function tan(int256 _angle) internal pure returns (int256) {\\n    return sin(_angle) * 1e18 / cos(_angle);\\n  }\\n\\n  /**\\n   * Calculate atan(x) for x in [-1, 1].\\n   *\\n   * Taken from https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\\n   * (MIT license, Copyright (c) 2017-2020 Novak Distributed), modified for\\n   * angle in radian scaled by 10^18\\n   *\\n   * Uses the Chebyshev polynomial approach presented at\\n   * https://www.mathworks.com/help/fixedpoint/examples/calculate-fixed-point-arctangent.html\\n   * Uses polynomials received by personal communication.\\n   * 0.999974x-0.332568x^3+0.193235x^5-0.115729x^7+0.0519505x^9-0.0114658x^11\\n   */\\n  function atanSmall(int256 _angle) internal pure returns (int256 result) {\\n    unchecked {\\n      int256 expAngle = _angle;\\n      int256 angleSquared = _angle * _angle / 1e18;\\n\\n      for(uint i = 0; i < 6; i++) {\\n\\n        result = result + expAngle * int(int32(uint32((atan_table & (0xffffffff << (256 - 2*32 - 32 - i * 32))) >> (256 - 2*32 - 32 - i * 32)))) / 1e7;\\n\\n        expAngle = expAngle * angleSquared / 1e18;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Compute the nice two-component arctangent of y/x.\\n   *\\n   * Taken from https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\\n   * (MIT license, Copyright (c) 2017-2020 Novak Distributed), modified for\\n   * angle in radian scaled by 10^18\\n   */\\n  function atan2(int256 _y, int256 _x) internal pure returns (int256) {\\n    unchecked {\\n      int256 atan_result;\\n      \\n      // We will re-use these absolute values\\n      int256 abs_x = _x >= 0 ? _x : - _x;\\n      int256 abs_y = _y >= 0 ? _y : - _y;\\n      \\n      if (abs_x > abs_y) {\\n        // We are in the (0, pi/4] region\\n        // abs(y)/abs(x) will be in 0 to 1.\\n        atan_result = atanSmall(1e18 * abs_y / abs_x);\\n      } else {\\n        // We are in the (pi/4, pi/2) region\\n        // abs(x) / abs(y) will be in 0 to 1; we swap the arguments\\n        atan_result = int256(PI) / 2 - atanSmall(1e18 * abs_x / abs_y);\\n      }\\n      \\n      // Now we correct the result for other regions\\n      if (_x < 0) {\\n        if (_y < 0) {\\n          atan_result -= int256(PI);\\n        } else {\\n          atan_result = int256(PI) - atan_result;\\n        }\\n      } else {\\n        if (_y < 0) {\\n            atan_result = - atan_result;\\n        }\\n      }\\n      \\n      return atan_result;\\n    }\\n  }\\n\\n  /**\\n   * Ensure an angle is in the 0pi - 2pi range.\\n   */\\n  function wrapAngleZeroToTwoPi(int256 angle) internal pure returns (int256) {\\n    int256 a = angle % int256(TWO_PI);\\n    if(angle < 0) {\\n      a = int256(TWO_PI) - (-a);\\n    }\\n\\n    return a;\\n  }\\n\\n  /**\\n   * Ensure an angle is in the -1pi - 1pi range.\\n   */\\n  function wrapAngleMinusPiToPi(int256 angle) internal pure returns (int256) {\\n    int256 a = angle % int256(TWO_PI);\\n    if(angle < 0) {\\n      a = int256(TWO_PI) - (-a);\\n    }\\n    if(a > int256(PI)) {\\n      a -= int256(TWO_PI);\\n    }\\n\\n    return a;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/PlanetaryPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {PlanetaryPositionsLib as PPL} from \\\"./PlanetaryPositionsLib.sol\\\";\\nimport {IPlanetaryPositions as IPP} from \\\"./interfaces/IPlanetaryPositions.sol\\\";\\n\\n/**\\n * @notice This contracts call a library that compute the planetary positions of the moon, the sun, and the \\n *         7 others planet of the solarsystem.\\n *         Planetary positions can be computed in ecliptic longitude/latitude, in \\n *         right ascension/declination, both geocentric and topocentric, and in azimuth/altitude.\\n *         The algorithms are from Paul Schlyter, who published them at \\n *         https://stjarnhimlen.se/comp/tutorial.html, \\n *         as well as examples at https://stjarnhimlen.se/comp/ppcomp.html.\\n *         Some comments from his website were copied into here for better clarity.\\n *         All numbers are scaled by 1e18.\\n * \\n *         Method comments are in the Library source code.\\n */\\ncontract PlanetaryPositions is IPP {\\n    function getDayNumberFromGregorianCalendar(uint year, uint month, uint day, uint hour, uint min) public pure returns (int) {\\n        return PPL.getDayNumberFromGregorianCalendar(year, month, day, hour, min);\\n    }\\n\\n    function getDayNumberFromGregorianCalendar1900to2100(uint year, uint month, uint day, uint hour, uint min) public pure returns (int) {\\n        return PPL.getDayNumberFromGregorianCalendar1900to2100(year, month, day, hour, min);\\n    }\\n\\n    function getDayNumberFromTimestamp(uint timestamp) public pure returns (int) {\\n        return PPL.getDayNumberFromTimestamp(timestamp);\\n    }\\n\\n\\n\\n    function getBodyAzimuthAltitudeNow(int observerLongitude, int observerLatitude, CelestialBody body) public view returns (int azimuth, int altitude, uint distance) {\\n\\n        return PPL.getBodyAzimuthAltitude(observerLongitude, observerLatitude, IPP.CelestialBody(uint(body)), getDayNumberFromTimestamp(block.timestamp));\\n    }\\n\\n    function getBodyAzimuthAltitude(int observerLongitude, int observerLatitude, CelestialBody body, int dayNumber) public pure returns (int azimuth, int altitude, uint distance) {\\n\\n        return PPL.getBodyAzimuthAltitude(observerLongitude, observerLatitude, IPP.CelestialBody(uint(body)), dayNumber);\\n    }\\n\\n    function getBodyAzimuthAltitudeInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) public pure returns (int azimuth, int altitude, uint distance) {\\n        return PPL.getBodyAzimuthAltitudeInRadians(observerLongitude, observerLatitude, body, dayNumber);\\n    }\\n\\n    function getBodyBodyAzimuthAltitudeInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude, int localSiderealTime) public pure returns (int azimuth, int altitude, uint distance) {\\n        return PPL.getBodyBodyAzimuthAltitudeInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude, localSiderealTime);\\n    }\\n\\n\\n\\n\\n    function getBodyTopocentricRADeclNow(int observerLongitude, int observerLatitude, IPP.CelestialBody body) public view returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyTopocentricRADecl(observerLongitude, observerLatitude, body, getDayNumberFromTimestamp(block.timestamp));\\n    }\\n\\n    function getBodyTopocentricRADecl(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyTopocentricRADecl(observerLongitude, observerLatitude, body, dayNumber);\\n    }\\n\\n    function getBodyTopocentricRADeclInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyTopocentricRADeclInRadians(observerLongitude, observerLatitude, body, dayNumber);\\n    }\\n\\n    function getBodyBodyTopocentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude)  public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyBodyTopocentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude);\\n    }\\n\\n\\n\\n\\n    function getBodyGeocentricRADeclNow(IPP.CelestialBody body) public view returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyGeocentricRADecl(body, getDayNumberFromTimestamp(block.timestamp));\\n    }\\n\\n    function getBodyGeocentricRADecl(IPP.CelestialBody body, int dayNumber) public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyGeocentricRADecl(body, dayNumber);\\n    }\\n\\n    function getBodyGeocentricRADeclInRadians(IPP.CelestialBody body, int dayNumber) public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyGeocentricRADeclInRadians(body, dayNumber);\\n    }\\n\\n    function getBodyBodycentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements) public pure returns (int rightAscension, int declination, uint distance) {\\n        return PPL.getBodyBodycentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements);\\n    }\\n\\n\\n\\n\\n    function getBodyEclipticLonLatNow(IPP.CelestialBody body) public view returns (int longitude, int latitude, uint distance) {\\n        return PPL.getBodyEclipticLonLat(body, getDayNumberFromTimestamp(block.timestamp));\\n    }\\n\\n    function getBodyEclipticLonLat(IPP.CelestialBody body, int dayNumber) public pure returns (int longitude, int latitude, uint distance) {\\n        return PPL.getBodyEclipticLonLat(body, dayNumber);\\n    }\\n\\n    function getBodyEclipticLonLatInRadians(IPP.CelestialBody body, int dayNumber) public pure returns (int longitude, int latitude, uint distance) {\\n        return PPL.getBodyEclipticLonLatInRadians(body, dayNumber);\\n    }\\n\\n    function getBodyEclipticLonLatInRadians(IPP.OrbitalElements memory orbitalElements) public pure returns (int longitude, int latitude, uint distance) {\\n        return PPL.getBodyEclipticLonLatInRadians(orbitalElements);\\n    }\\n\\n\\n\\n\\n    function getLocalSiderealTime(int longitude, int dayNumber) public pure returns (int siderealTime) {\\n        return PPL.getLocalSiderealTime(longitude, dayNumber);\\n    }\\n\\n    function getLocalSiderealTimeInRadians(int longitude, int dayNumber) public pure returns (int siderealTime) {\\n        return PPL.getLocalSiderealTimeInRadians(longitude, dayNumber);\\n    }\\n\\n\\n\\n\\n    function getOrbitalElements(IPP.CelestialBody body, int dayNumber) public pure returns (IPP.OrbitalElements memory elements) {\\n        return PPL.getOrbitalElements(body, dayNumber);\\n    }\\n\\n    function getOrbitalElements(IPP.OrbitalElementsParameters memory elementsParameters, int dayNumber) public pure returns (IPP.OrbitalElements memory elements) {\\n        return PPL.getOrbitalElements(elementsParameters, dayNumber);\\n    }\\n\\n    function getOrbitalElementsParameters(IPP.CelestialBody body) public pure returns (IPP.OrbitalElementsParameters memory elementsParameters) {\\n        return PPL.getOrbitalElementsParameters(body);\\n    }\\n}\"\r\n    },\r\n    \"contracts/PlanetaryPositionsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IPlanetaryPositions as IPP} from \\\"./interfaces/IPlanetaryPositions.sol\\\";\\nimport {Trigonometry as Trigo} from \\\"./libs/Trigonometry.sol\\\";\\nimport {Math} from \\\"./libs/Math.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @notice This library compute the planetary positions of the moon, the sun, and the 7 others planet of \\n *         the solarsystem.\\n *         Planetary positions can be computed in ecliptic longitude/latitude, in \\n *         right ascension/declination, both geocentric and topocentric, and in azimuth/altitude.\\n *         The algorithms are from Paul Schlyter, who published them at \\n *         https://stjarnhimlen.se/comp/tutorial.html, \\n *         as well as examples at https://stjarnhimlen.se/comp/ppcomp.html.\\n *         Some comments from his website were copied into here for better clarity.\\n *         All numbers are scaled by 1e18.\\n */\\nlibrary PlanetaryPositionsLib {\\n\\n\\n  /**\\n   * @notice Since solidity doesn't support constant arrays.... Here are the constants to compute the orbital \\n   *         elements of the 10 bodies!\\n   *         For Sun and Moon, Earth is the origin, otherwise Sun is the origin.\\n   *         Each orbital elements (N, i, w, a, e, M) for a body each need 2 constants to be computed.\\n   *         So we have 12 constants per body, and 120 total.\\n   *         These constants are in radians, encoded as int64, and their value are scaled by 1e18, with the \\n   *         exception of a1 (the seventh value) which is scaled by 1e16.\\n   *         These values were fetched, as all the algorithms, from Paul Schlyter website, and the below \\n   *         bytes array was generated by generateOrbitalElementsBytesArray.js.\\n   */\\n  bytes constant orbitalElementsConstantsTable = hex\\\"00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_44_88_28_8a_8a_b9_90_7b_00_00_00_bf_5f_3d_ad_f7_00_23_86_f2_6f_c1_00_00_00_00_00_00_00_00_00_00_00_3b_5c_bf_39_8d_50_00_ff_ff_ff_ff_bb_65_22_40_56_3d_3f_1a_06_48_3f_2d_00_3d_1d_19_a8_98_ec_83_0b_b4_db_72_e6_be_aa_f2_00_00_00_83_e6_b2_af_fd_01_b2_56_58_86_ff_cd_ca_00_00_00_00_34_03_ce_31_07_0d_e2_8e_fa_95_ac_75_00_00_00_29_39_31_22_df_00_0d_c0_a2_c3_d5_28_00_00_00_00_00_00_00_00_00_02_da_8f_f1_68_63_30_00_00_00_00_00_21_51_a9_c0_28_d9_ca_0e_39_3e_32_e0_00_fd_c0_65_34_9f_b5_92_12_92_a7_f8_84_8c_b2_4f_00_00_00_64_34_b0_ee_99_00_d2_7c_c8_c1_56_4c_53_00_00_00_00_1c_9b_b1_68_0d_4b_9a_02_22_e1_f2_0f_00_00_00_38_3b_02_86_db_00_19_b2_a5_e5_0d_c8_00_00_00_00_00_00_00_00_00_00_18_10_01_f3_10_50_00_ff_ff_ff_ff_b2_65_0e_80_0b_a0_a3_0a_f0_f3_2f_0e_00_63_57_b2_a3_fe_33_27_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_18_ee_fa_aa_e8_87_47_93_00_00_00_bf_5f_3d_ad_f7_00_23_86_f2_6f_c1_00_00_00_00_00_00_00_00_00_00_00_3b_5c_bf_39_8d_50_00_ff_ff_ff_ff_bb_65_22_40_56_3d_3f_1a_06_48_3f_2d_00_3d_1d_19_a8_98_ec_83_1e_4e_6e_ec_06_10_a6_0a_ff_fc_b7_6d_a8_28_64_7b_01_3f_0c_6b_03_99_5f_03_00_00_00_00_00_00_00_00_4d_0a_03_b3_7b_26_df_46_00_0a_30_f4_7e_c1_e5_b3_08_5d_19_88_b0_34_a0_00_00_00_00_00_00_00_00_00_00_c3_0b_42_56_2b_40_00_00_00_00_00_00_00_00_00_1b_f1_69_1a_f3_1e_bb_9c_03_2a_1d_7a_a5_f3_a3_f7_0c_00_e2_2a_0f_45_48_7c_00_00_00_55_c6_b3_0f_80_00_72_b1_8a_5d_4f_f4_e7_ff_ff_ff_ff_ed_7b_92_c2_45_64_f9_e1_46_60_95_27_00_00_00_77_0c_a7_5c_71_00_36_21_dc_93_e2_a0_00_00_00_00_00_00_00_00_00_01_4b_d7_5a_45_3e_d0_00_00_00_00_00_95_f7_1d_00_04_81_73_ba_73_70_4c_a5_00_20_7e_22_f7_77_6c_28_18_54_d1_88_1b_3f_c7_88_00_00_00_70_81_0c_01_1b_00_50_cb_66_b6_f5_53_20_ff_ff_ff_ff_5e_06_94_f3_42_56_36_2a_fe_a7_74_0c_00_00_00_42_d9_69_26_b7_00_b8_d5_01_ef_3a_00_00_00_00_00_00_00_00_00_00_00_ac_4c_ac_8e_51_20_00_00_00_00_01_0a_5f_87_40_04_d1_9e_ce_2f_a8_a4_e2_00_05_26_de_85_6e_63_3d_1b_87_e0_1b_5d_23_3f_1d_00_00_00_61_1d_06_5f_81_00_9a_4f_3b_96_cd_1e_82_ff_ff_ff_ff_8f_8b_3a_87_52_34_a5_2b_82_20_64_10_00_00_00_78_f5_97_ee_ad_01_53_73_f1_ec_ad_38_00_00_00_00_00_00_00_00_00_00_c5_56_ca_ee_b1_a0_00_ff_ff_ff_fd_c9_d0_c3_40_4c_c6_07_cd_32_8a_95_a2_00_02_12_e2_04_52_ff_40_11_ec_84_0a_58_c0_dd_90_00_00_00_38_cd_46_92_5b_00_2f_f3_1d_4e_b7_d3_d5_00_00_00_00_13_c4_01_8d_17_69_a0_ac_ad_44_b9_74_00_00_00_7c_34_af_df_30_02_a9_78_a2_db_58_78_00_ff_ff_ff_fc_64_20_c5_00_00_a8_1b_78_65_7b_60_00_00_00_00_01_bc_0d_fa_80_22_89_8b_8d_0f_76_5b_f6_00_00_ba_21_b4_54_e6_da_1f_eb_42_b0_6f_69_9a_8b_00_00_00_7a_9c_e3_f5_04_00_6d_c0_68_8e_70_06_6f_ff_ff_ff_fe_f6_b9_64_68_42_16_3e_e1_f7_22_e1_0e_ff_ff_ff_e7_82_20_cf_9f_04_2b_e2_48_3a_a9_d0_00_00_00_00_07_b6_b3_ae_80_00_1e_93_1c_84_ef_e0_00_00_00_00_00_80_26_65_80_3f_09_06_6c_da_34_0c_0f_00_00_5f_2a_3f_3d_f8_74\\\";\\n\\n\\n  // The value for Earth\\n  int constant EarthAxialTiltValue = 0.409093 * 1e18;\\n  int constant EarthAxialTiltDeltaValue = - 0.000000006217 * 1e18;\\n\\n\\n\\n\\n  /**\\n   * @notice All the algorithms are using a specific time scale that can be computed using either:\\n   *         - getDayNumberFromTimestamp()\\n   *         - getDayNumberFromGregorianCalendar()\\n   *         - getDayNumberFromGregorianCalendar1900to2100() (only valid from year 1900 to 2100)\\n   *         We will call these dates a \\\"day number\\\".\\n   *\\n   *         Informations about this time scale : \\n   *         The time scale in these formulae are counted in days. Hours, minutes, seconds are \\n   *         expressed as fractions of a day. Day 0.0 occurs at 2000 Jan 0.0 UT (or 1999 Dec 31, \\n   *         0:00 UT). This \\\"day number\\\" d is computed as follows (y=year, m=month, D=date, UT=UT\\n   *         in hours+decimals):\\n   *\\n   *         d = 367*y - 7 * ( y + (m+9)/12 ) / 4 + 275*m/9 + D - 730530\\n   *\\n   *         Note that the formula above is only valid from March 1900 to February 2100.\\n   *         Below is another formula, which is valid over the entire Gregorian Calendar:\\n   *\\n   *         d = 367*y - 7 * ( y + (m+9)/12 ) / 4 - 3 * ( ( y + (m-9)/7 ) / 100 + 1 ) / 4 + 275*m/9 + D - 730515\\n   *\\n   *         Note that ALL divisions here should be INTEGER divisions (get the floor of the division).\\n   *         Finally, include the time of the day, by adding:\\n   *\\n   *         d = d + UT/24.0        (this is a floating-point division)\\n   */\\n\\n  /**\\n   * @notice Generate a \\\"day number\\\" time from a given unix timestamp.\\n   * @param timestamp An unix timestamp\\n   * @return A \\\"day number\\\" to be used in the various functions as time input. (scaled by 1e18)\\n   */\\n  function getDayNumberFromTimestamp(uint timestamp) internal pure returns (int) {\\n    return (int(timestamp) - 946598400) * 1e18 / (3600 * 24);\\n  }\\n\\n  /**\\n   * @notice Generate a \\\"day number\\\" time from a given date.\\n   * @param year The year\\n   * @param month The month, in the 1-12 range\\n   * @param day The day, in the 1-31 range\\n   * @param hour The hour, in the 1-23 range\\n   * @param min The minute, in the 0-59 range\\n   * @return A \\\"day number\\\" to be used in the various functions as time input. (scaled by 1e18)\\n   */\\n  function getDayNumberFromGregorianCalendar(uint year, uint month, uint day, uint hour, uint min) internal pure returns (int) {\\n    int d = 367 * int(year) - 7 * (int(year) + (int(month) + 9) / 12) / 4 - 3 * ((int(year) + (int(month) - 9) / 7) / 100 + 1) / 4 + 275 * int(month) / 9 + int(day) - 730515;\\n\\n    return d * 1e18 + int(hour * 1e18 / 24) + int(min * 1e18 / (24*60));\\n  }\\n\\n  /**\\n   * @notice Generate a \\\"day number\\\" time from a given date. Only valid from mars 1900 to feb 2100.\\n   * @param year The year\\n   * @param month The month, in the 1-12 range\\n   * @param day The day, in the 1-31 range\\n   * @param hour The hour, in the 1-23 range\\n   * @param min The minute, in the 0-59 range\\n   * @return A \\\"day number\\\" to be used in the various functions as time input. (scaled by 1e18)\\n   */\\n  function getDayNumberFromGregorianCalendar1900to2100(uint year, uint month, uint day, uint hour, uint min) internal pure returns (int) {\\n    int d = int(367 * year - 7 * (year + (month + 9) / 12) / 4 + 275 * month / 9 + day) - 730530;\\n\\n    return d * 1e18 + int(hour * 1e18 / 24) + int(min * 1e18 / (24*60));\\n  }\\n\\n\\n\\n  /**\\n   * @notice For a given observer positioned on earth, returns the azimuth and altitude of a specific \\n   *         celestial body.\\n   * @param observerLongitude The longitude of the observer on earth. In degrees, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In degrees, scaled by 1e18.\\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return azimuth The azimuth where the body is, in degrees, in the range 0:360, scaled by 1e18\\n   * @return altitude The altitude where the body is, in degrees, in the range -90:90, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyAzimuthAltitude(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int azimuth, int altitude, uint distance) {\\n\\n    // Convert args to radians\\n    observerLongitude = observerLongitude * (int(Trigo.PI) / 180) / 1e18;\\n    observerLatitude = observerLatitude * (int(Trigo.PI) / 180) / 1e18;\\n\\n    (azimuth, altitude, distance) = getBodyAzimuthAltitudeInRadians(observerLongitude, observerLatitude, body, dayNumber);\\n\\n    // Convert result to degrees\\n    azimuth = azimuth * 1e18 / int(Trigo.PI / 180);\\n    altitude = altitude * 1e18 / int(Trigo.PI / 180);\\n  }\\n\\n  /**\\n   * @notice For a given observer positioned on earth, returns the azimuth and altitude of a specific \\n   *         celestial body. Version with everything in radians.\\n   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return azimuth The azimuth where the body is, in radians, in the range 0:2pi, scaled by 1e18\\n   * @return altitude The altitude where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyAzimuthAltitudeInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int azimuth, int altitude, uint distance) {\\n\\n    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);\\n    \\n    // Origin will be the earth\\n    IPP.OrbitalElements memory newOriginOrbitalElements;\\n    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {\\n      // No need to specify a new origin\\n    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {\\n      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);\\n    } else {\\n      revert(\\\"Origin must be sun or earth\\\");\\n    }\\n\\n    // Earth axias tilt\\n    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({\\n      at: EarthAxialTiltValue,\\n      dat: EarthAxialTiltDeltaValue\\n    });\\n\\n    // Get the local sideral time at the observer location\\n    int sidTime = getLocalSiderealTimeInRadians(observerLongitude, dayNumber);\\n\\n    (azimuth, altitude, distance) = getBodyBodyAzimuthAltitudeInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude, sidTime);\\n  }\\n\\n  /**\\n   * @notice For a given observer positioned on a celestial body, returns the azimuth and altitude of another\\n   *         specific celestial body.\\n   * @param orbitalElements The orbital elements of the body we look at.\\n   * @param originAxialTilt The axial tilt of the body where we are looking from\\n   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center\\n   *                                 of the orbit. You can override this (e.g. look at mars from venus)\\n   *                                 Note: This is likely buggy for planets != earth due to different\\n   *                                 axial tilt orientation, not tested\\n   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.\\n   * @return azimuth The azimuth where the body is, in radians, in the range 0:2pi, scaled by 1e18\\n   * @return altitude The altitude where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyBodyAzimuthAltitudeInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude, int localSiderealTime) internal pure returns (int azimuth, int altitude, uint distance) {\\n\\n    int x;\\n    int y;\\n    int z;\\n\\n    { // Stack too deeep\\n\\n      // Get the body topocentric right ascension / declination\\n      int rightAscension; \\n      int declination;\\n      (rightAscension, declination, distance) = getBodyBodyTopocentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude);\\n\\n      // Determine the hour angle\\n      int ha = localSiderealTime - rightAscension;\\n\\n      // Convert the HA and declination to a rectangular coordinate system where the X axis points to \\n      // the celestial equator in the south, the Y axis to the horizon in the west, and the Z axis to \\n      // the north celestial pole\\n      x = Trigo.cos(ha) * Trigo.cos(declination) / 1e18;\\n      y = Trigo.sin(ha) * Trigo.cos(declination) / 1e18;\\n      z = Trigo.sin(declination);\\n    }\\n\\n    // Now we'll rotate this x,y,z system along an axis going east-west, i.e. the Y axis, in such a way \\n    // that the Z axis will point to the zenith. At the North Pole the angle of rotation will be zero \\n    // since there the north celestial pole already is in the zenith. At other latitudes the angle of \\n    // rotation becomes 90_deg - latitude. \\n    int xhor = x * Trigo.sin(observerLatitude) / 1e18 - z * Trigo.cos(observerLatitude) / 1e18;\\n    int yhor = y;\\n    int zhor = x * Trigo.cos(observerLatitude) / 1e18 + z * Trigo.sin(observerLatitude) / 1e18;\\n\\n    // Compute azimuth and altitude\\n    azimuth = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yhor, xhor) + int(Trigo.PI));\\n    altitude = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(zhor, int(Math.sqrt(uint(xhor * xhor / 1e18 + yhor * yhor / 1e18)))));\\n  }\\n\\n\\n\\n\\n  /**\\n   * @notice For a given observer positioned on earth, returns the right ascension and declination \\n   *         of a specific celestial body. This is different from the geocentric RA/Decl only for \\n   *         the moon.\\n   * @param observerLongitude The longitude of the observer on earth. In degrees, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In degrees, scaled by 1e18.\\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return rightAscension The right ascension where the body is, in degrees, in the range 0:360, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in degrees, in the range -90:90, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyTopocentricRADecl(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {\\n\\n    // Convert args to radians\\n    observerLongitude = observerLongitude * (int(Trigo.PI) / 180) / 1e18;\\n    observerLatitude = observerLatitude * (int(Trigo.PI) / 180) / 1e18;\\n\\n    (rightAscension, declination, distance) = getBodyTopocentricRADeclInRadians(observerLongitude, observerLatitude, body, dayNumber);\\n\\n    // Convert result to degrees\\n    rightAscension = rightAscension * 1e18 / int(Trigo.PI / 180);\\n    declination = declination * 1e18 / int(Trigo.PI / 180);\\n  }\\n\\n  /**\\n   * @notice For a given observer positioned on earth, returns the right ascension and declination \\n   *         of a specific celestial body. This is different from the geocentric RA/Decl only for \\n   *         the moon. Version with everything in radians.\\n   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyTopocentricRADeclInRadians(int observerLongitude, int observerLatitude, IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {\\n\\n    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);\\n    \\n    // Origin will be the earth\\n    IPP.OrbitalElements memory newOriginOrbitalElements;\\n    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {\\n      // No need to specify a new origin\\n    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {\\n      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);\\n    } else {\\n      revert(\\\"Origin must be sun or earth\\\");\\n    }\\n\\n    // Earth axias tilt\\n    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({\\n      at: EarthAxialTiltValue,\\n      dat: EarthAxialTiltDeltaValue\\n    });\\n\\n    (rightAscension, declination, distance) = getBodyBodyTopocentricRADeclInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements, observerLongitude, observerLatitude);\\n  }\\n\\n  /**\\n   * @notice For a given observer positioned on a celestial body, returns the right ascension and declination \\n   *         of another specific celestial body. This is different from the bodycentric RA/Decl only for \\n   *         the moon viewed from earth.\\n   * @param orbitalElements The orbital elements of the body we look at.\\n   * @param originAxialTilt The axial tilt of the body where we are looking from\\n   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center\\n   *                                 of the orbit. You can override this (e.g. look at mars from venus)\\n   *                                 Note: This is likely buggy for planets != earth due to different\\n   *                                 axial tilt orientation, not tested\\n   * @param observerLongitude The longitude of the observer on earth. In radians, scaled by 1e18.\\n   * @param observerLatitude The latitude of the observer on earth. In radians, scaled by 1e18.\\n   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyBodyTopocentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements, int observerLongitude, int observerLatitude)  internal pure returns (int rightAscension, int declination, uint distance) {\\n    // For most bodies, topocentric and geocentric difference is extremely small\\n    // We only recompute for the moon\\n    if(orbitalElements.body != IPP.CelestialBody.MOON) {\\n      return getBodyBodycentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements);\\n    }\\n\\n    // Get the geocentric right ascension/declination\\n    (int geoRightAscension, int geoDeclination, uint geoDistance) = getBodyBodycentricRADeclInRadians(orbitalElements, originAxialTilt, newOriginOrbitalElements);\\n    // Get the local sideral time at the observer location\\n    int sidTime = getLocalSiderealTimeInRadians(observerLongitude, orbitalElements.dayNumber);\\n\\n    // Computing the Moon's parallax, i.e. the apparent size of the (equatorial) radius of the Earth, \\n    // as seen from the Moon\\n    uint geoDistanceInv = 1e18 * 1e18 / geoDistance;\\n    int mpar = Trigo.atan2(int(geoDistanceInv), int(Math.sqrt(1e18 - geoDistanceInv * geoDistanceInv / 1e18)));\\n\\n    // Our astronomical latitude (observerLatitude) must first be converted to a \\n    // geocentric latitude (gclat) and  distance from the center of the Earth (rho) in Earth equatorial radii.\\n    int gclat = observerLatitude - (0.1924 * 1e18 * (int(Trigo.PI) / 180) / 1e18) * Trigo.sin(2 * observerLatitude) / 1e18;\\n    int rho = (0.99833 * 1e18) + (0.00167 * 1e18) * Trigo.cos(2 * observerLatitude) / 1e18;\\n\\n    // We compute the Moon's geocentric Hour Angle (HA)\\n    int ha = Trigo.wrapAngleZeroToTwoPi(sidTime - geoRightAscension);\\n\\n    // Compute an auxiliary angle\\n    int g = Trigo.atan2(Trigo.tan(gclat), Trigo.cos(ha));\\n\\n    // Final computation\\n    rightAscension = geoRightAscension - mpar * rho / 1e18 * Trigo.cos(gclat) / 1e18 * Trigo.sin(ha) / 1e18 * 1e18 / Trigo.cos(geoDeclination);\\n    declination = geoDeclination - mpar * rho / 1e18 * Trigo.sin(gclat) / 1e18 * Trigo.sin(g - geoDeclination) / 1e18 * 1e18 / Trigo.sin(g);\\n    distance = geoDistance; // Not updated\\n  }\\n\\n\\n\\n\\n  /**\\n   * @notice Returns the right ascension and declination of a specific celestial body. \\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return rightAscension The right ascension where the body is, in degrees, in the range 0:360, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in degrees, in the range -90:90, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyGeocentricRADecl(IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {\\n\\n    (rightAscension, declination, distance) = getBodyGeocentricRADeclInRadians(body, dayNumber);\\n\\n    // Convert result to degrees\\n    rightAscension = rightAscension * 1e18 / int(Trigo.PI / 180);\\n    declination = declination * 1e18 / int(Trigo.PI / 180);\\n  }\\n\\n  /**\\n   * @notice Returns the right ascension and declination of a specific celestial body. \\n   *         Version with everything in radians.\\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyGeocentricRADeclInRadians(IPP.CelestialBody body, int dayNumber) internal pure returns (int rightAscension, int declination, uint distance) {\\n\\n    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);\\n\\n    // Origin will be the earth\\n    IPP.OrbitalElements memory newOriginOrbitalElements;\\n    if(orbitalElements.origin == IPP.CelestialBody.EARTH) {\\n      // No need to specify a new origin\\n    } else if(orbitalElements.origin == IPP.CelestialBody.SUN) {\\n      newOriginOrbitalElements = getOrbitalElements(IPP.CelestialBody.EARTH, dayNumber);\\n    } else {\\n      revert(\\\"Origin must be sun or earth\\\");\\n    }\\n\\n    // Earth axias tilt\\n    IPP.AxialTilt memory earthAxialTilt = IPP.AxialTilt({\\n      at: EarthAxialTiltValue,\\n      dat: EarthAxialTiltDeltaValue\\n    });\\n\\n    (rightAscension, declination, distance) = getBodyBodycentricRADeclInRadians(orbitalElements, earthAxialTilt, newOriginOrbitalElements);\\n  }\\n\\n  /**\\n   * @notice From a specific celestial body, returns the right ascension and declination of another\\n   * specific celestial body. \\n   * @param orbitalElements The orbital elements of the body we look at.\\n   * @param originAxialTilt The axial tilt of the body where we are looking from\\n   * @param newOriginOrbitalElements By default, the body we are looking from is the body at the center\\n   *                                 of the orbit. You can override this (e.g. look at mars from venus)\\n   *                                 Note: This is likely buggy for planets != earth due to different\\n   *                                 axial tilt orientation, not tested\\n   * @return rightAscension The right ascension where the body is, in radians, in the range 0:2pi, \\n   *                        scaled by 1e18\\n   * @return declination The declination where the body is, in radians, in the range -pi/2:pi/2, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyBodycentricRADeclInRadians(IPP.OrbitalElements memory orbitalElements, IPP.AxialTilt memory originAxialTilt, IPP.OrbitalElements memory newOriginOrbitalElements) internal pure returns (int rightAscension, int declination, uint distance) {\\n\\n    (int longitude, int latitude, uint d) = getBodyEclipticLonLatInRadians(orbitalElements);\\n    distance = d;\\n\\n    // Next, we compute the body rectangular ecliptic coordinates and rotate them to get rectangular \\n    // equatorial coordinates and then RA and Decl\\n    int xg = int(distance) * Trigo.cos(longitude) / 1e18 * Trigo.cos(latitude) / 1e18;\\n    int yg = int(distance) * Trigo.sin(longitude) / 1e18 * Trigo.cos(latitude) / 1e18;\\n    int zg = int(distance) * Trigo.sin(latitude) / 1e18;\\n\\n    // If we want RADecl not from the elliptic center, but from another body\\n    // Not a clean way to check for a non-null originOrbitalElements\\n    if(newOriginOrbitalElements.N != 0 || newOriginOrbitalElements.i != 0 || newOriginOrbitalElements.w != 0 || newOriginOrbitalElements.a != 0 || newOriginOrbitalElements.e != 0 || newOriginOrbitalElements.M != 0) {\\n      // Must share the same origin\\n      require(orbitalElements.origin == newOriginOrbitalElements.origin, \\\"Must share origin\\\");\\n\\n      (int newOriginLongitude, int newOriginLatitude, uint newOriginDistance) = getBodyEclipticLonLatInRadians(newOriginOrbitalElements);\\n\\n      xg = xg - int(newOriginDistance) * Trigo.cos(newOriginLongitude) / 1e18 * Trigo.cos(newOriginLatitude) / 1e18;\\n      yg = yg - int(newOriginDistance) * Trigo.sin(newOriginLongitude) / 1e18 * Trigo.cos(newOriginLatitude) / 1e18;\\n      zg = zg - int(newOriginDistance) * Trigo.sin(newOriginLatitude) / 1e18;\\n    }\\n\\n    // We compute the obliquity of the ecliptic of the origin\\n    int ecl = (originAxialTilt.at + originAxialTilt.dat * orbitalElements.dayNumber / 1e18);\\n\\n    int xe = xg;\\n    int ye = yg * Trigo.cos(ecl) / 1e18 - zg * Trigo.sin(ecl) / 1e18;\\n    int ze = yg * Trigo.sin(ecl) / 1e18 + zg * Trigo.cos(ecl) / 1e18;\\n\\n    // Finally, compute RA, Decl, distance (not changed for the moon):\\n    rightAscension = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(ye, xe));\\n    declination = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(ze, int(Math.sqrt(uint(xe * xe / 1e18 + ye * ye / 1e18)))));\\n    distance = Math.sqrt(uint(xe * xe / 1e18 + ye * ye / 1e18 + ze * ze / 1e18));\\n  }\\n\\n\\n\\n  /**\\n   * @notice Returns the ecliptic longitude and latitude of a specific celestial body. \\n   * @param body The celestial body to look for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return longitude The ecliptic longitude where the body is, in degrees, in the range 0:360, \\n   *                        scaled by 1e18\\n   * @return latitude The ecliptic latitude where the body is, in degrees, in the range -90:90, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyEclipticLonLat(IPP.CelestialBody body, int dayNumber) internal pure returns (int longitude, int latitude, uint distance) {\\n   \\n    (longitude, latitude, distance) = getBodyEclipticLonLatInRadians(body, dayNumber);\\n\\n    // Convert result to degrees\\n    longitude = longitude * 1e18 / int(Trigo.PI / 180);\\n    latitude = latitude * 1e18 / int(Trigo.PI / 180);\\n  }\\n\\n  /**\\n   * From a \\\"day number\\\" as defined above, return the ecliptic lon/lat of a planet.\\n   * longitude and latitude are in radians, scaled by 1e18\\n   * distance is in astronomical units (AU) (or earth radii if Moon), scaled by 1e18\\n   */\\n  \\n  function getBodyEclipticLonLatInRadians(IPP.CelestialBody body, int dayNumber) internal pure returns (int longitude, int latitude, uint distance) {\\n    \\n    IPP.OrbitalElements memory orbitalElements = getOrbitalElements(body, dayNumber);\\n    (longitude, latitude, distance) = getBodyEclipticLonLatInRadians(orbitalElements);\\n  } \\n\\n  /**\\n   * @notice Returns the ecliptic longitude and latitude of a specific celestial body. \\n   *         Version using orbitalElements and with everything in radians.\\n   * @param orbitalElements The orbital elements of the celestial body to look for\\n   * @return longitude The ecliptic longitude where the body is, in degrees, in the range 0:360, \\n   *                        scaled by 1e18\\n   * @return latitude The ecliptic latitude where the body is, in degrees, in the range -90:90, scaled by 1e18.\\n   * @return distance The distance to the body, in astronomical units (AU), or earth radii for the moon,\\n   *                 scaled by 1e18.\\n   */\\n  function getBodyEclipticLonLatInRadians(IPP.OrbitalElements memory orbitalElements) internal pure returns (int longitude, int latitude, uint distance) {\\n    \\n    { // Stack too deeep\\n\\n      // We compute the excentric anomaly\\n      int em = orbitalElements.M + orbitalElements.e * Trigo.sin(orbitalElements.M) / 1e18 * (1e18 + orbitalElements.e * Trigo.cos(orbitalElements.M) / 1e18) / 1e18;\\n      // We do 1 iteration to refine the result, should be enough\\n      em = em - (em - orbitalElements.e * Trigo.sin(em) / 1e18 - orbitalElements.M) * 1e18 / (1e18 - orbitalElements.e * Trigo.cos(em) / 1e18);\\n      \\n      // Compute the rectangular (x,y) coordinates in the plane of the body orbit\\n      int xv = orbitalElements.a * (Trigo.cos(em) - orbitalElements.e) / 1e18;\\n      int yv = orbitalElements.a * int(Math.sqrt(uint(1e18 - orbitalElements.e * orbitalElements.e / 1e18))) / 1e18 * Trigo.sin(em) / 1e18;\\n      \\n      // Convert this to distance and true anomaly\\n      int vm = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yv, xv));\\n      distance = Math.sqrt(uint(xv * xv / 1e18 + yv * yv / 1e18));\\n      \\n      // Now we know the body's position in the plane of the body orbit. \\n      // Compute the body position in ecliptic coordinates\\n      int xh = int(distance) * (Trigo.cos(orbitalElements.N) * Trigo.cos(vm + orbitalElements.w) / 1e18 - Trigo.sin(orbitalElements.N) * Trigo.sin(vm + orbitalElements.w) / 1e18 * Trigo.cos(orbitalElements.i) / 1e18) / 1e18;\\n      int yh = int(distance) * (Trigo.sin(orbitalElements.N) * Trigo.cos(vm + orbitalElements.w) / 1e18 + Trigo.cos(orbitalElements.N) * Trigo.sin(vm + orbitalElements.w) / 1e18 * Trigo.cos(orbitalElements.i) / 1e18) / 1e18;\\n      int zh = int(distance) * (Trigo.sin(vm + orbitalElements.w) * Trigo.sin(orbitalElements.i) / 1e18) / 1e18;\\n\\n      // Convert to ecliptic longitude, latitude and distance\\n      longitude = Trigo.wrapAngleZeroToTwoPi(Trigo.atan2(yh, xh));\\n      latitude = Trigo.wrapAngleMinusPiToPi(Trigo.atan2(zh, int(Math.sqrt(uint(xh * xh / 1e18 + yh * yh / 1e18)))));\\n      distance = Math.sqrt(uint(xh * xh / 1e18 + yh * yh / 1e18 + zh * zh / 1e18));\\n    }\\n\\n\\n    //\\n    // Below we'll compute the most important perturbation terms, and then add these as corrections\\n    // to our previous figures.\\n    //\\n\\n    if(orbitalElements.body == IPP.CelestialBody.MOON) {\\n      IPP.OrbitalElements memory sunElements = getOrbitalElements(IPP.CelestialBody.SUN, orbitalElements.dayNumber);\\n\\n      // Sun mean longitutde\\n      int ls = sunElements.M + sunElements.w + sunElements.N;\\n      // Moon mean longitude\\n      int lm = orbitalElements.M + orbitalElements.w + orbitalElements.N;\\n      // Moon mean elongation\\n      int dm = lm - ls;\\n      // Moon argument of latitude\\n      int f = lm - orbitalElements.N;\\n\\n      // Compute and add up the 12 largest pertirbation terms in longitude\\n      // Evection\\n      int dlon = - (1.274 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 2 * dm) / 1e18;\\n      // Variation\\n      dlon = dlon + (0.658 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * dm) / 1e18;\\n      // yearly equation\\n      dlon = dlon - (0.186 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(sunElements.M) / 1e18;\\n      dlon = dlon - (0.059 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 2 * dm) / 1e18;\\n      dlon = dlon - (0.057 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 2 * dm + sunElements.M) / 1e18;\\n      dlon = dlon + (0.053 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + 2 * dm) / 1e18;\\n      dlon = dlon + (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * dm - sunElements.M) / 1e18;\\n      dlon = dlon + (0.041 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - sunElements.M) / 1e18;\\n      // the Parallactic Equation\\n      dlon = dlon - (0.035 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(dm) / 1e18;\\n      dlon = dlon - (0.031 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + sunElements.M) / 1e18;\\n      dlon = dlon - (0.015 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * f - 2 * dm) / 1e18;\\n      dlon = dlon + (0.011 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - 4 * dm) / 1e18;\\n      longitude = longitude + dlon;\\n\\n      // Compute and add up the 5 largest pertirbation terms in latitude\\n      int dlat = (-0.173 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(f - 2 * dm) / 1e18;\\n      dlat = dlat - (0.055 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M - f - 2 * dm) / 1e18;\\n      dlat = dlat - (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(orbitalElements.M + f - 2 * dm) / 1e18;\\n      dlat = dlat + (0.033 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(f + 2 * dm) / 1e18;\\n      dlat = dlat + (0.017 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M + f) / 1e18;\\n      latitude = latitude + dlat;\\n\\n      // Compute and add up the 2 largest pertirbation terms in distance\\n      int ddistance = (-0.58 * 1e18) * Trigo.cos(orbitalElements.M - 2 * dm) / 1e18;\\n      ddistance = ddistance - (0.46 * 1e18) * Trigo.cos(2 * dm) / 1e18;\\n      distance = uint(int(distance) + ddistance);\\n    }\\n    else if(orbitalElements.body == IPP.CelestialBody.JUPITER) {\\n      IPP.OrbitalElements memory saturnElements = getOrbitalElements(IPP.CelestialBody.SATURN, orbitalElements.dayNumber);\\n\\n      int dlon = - (0.332 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 5 * saturnElements.M - 67.6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon - (0.056 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 2 * saturnElements.M + 21 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon + (0.042 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(3 * orbitalElements.M - 5 * saturnElements.M + 21 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon - (0.036 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * orbitalElements.M - 2 * saturnElements.M) / 1e18;\\n      dlon = dlon + (0.022 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(1 * orbitalElements.M - 1 * saturnElements.M) / 1e18;\\n      dlon = dlon + (0.023 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * orbitalElements.M - 3 * saturnElements.M + 52 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon - (0.016 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * orbitalElements.M - 5 * saturnElements.M - 69 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      longitude = longitude + dlon;\\n    }\\n    else if(orbitalElements.body == IPP.CelestialBody.SATURN) {\\n      IPP.OrbitalElements memory jupiterElements = getOrbitalElements(IPP.CelestialBody.JUPITER, orbitalElements.dayNumber);\\n\\n      int dlon = (0.812 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 5 * orbitalElements.M - 67.6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon - (0.229 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(2 * jupiterElements.M - 4 * orbitalElements.M - 2 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon + (0.119 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 2 * orbitalElements.M - 3 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon + (0.046 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 6 * orbitalElements.M - 69 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon + (0.014 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 3 * orbitalElements.M + 32 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      longitude = longitude + dlon;\\n\\n      int dlat = - (0.020 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.cos(2 * jupiterElements.M - 4 * orbitalElements.M - 2 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlat = dlat + (0.018 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(2 * jupiterElements.M - 6 * orbitalElements.M - 49 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      latitude = latitude + dlat;\\n    }\\n    else if(orbitalElements.body == IPP.CelestialBody.URANUS) {\\n      IPP.OrbitalElements memory jupiterElements = getOrbitalElements(IPP.CelestialBody.JUPITER, orbitalElements.dayNumber);\\n      IPP.OrbitalElements memory saturnElements = getOrbitalElements(IPP.CelestialBody.SATURN, orbitalElements.dayNumber);\\n\\n      int dlon = (0.040 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * saturnElements.M - 2 * orbitalElements.M + 6 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon + (0.035 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * saturnElements.M - 3 * orbitalElements.M + 33 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      dlon = dlon - (0.015 * 1e18 * int(Trigo.PI) / 1e18 / 180) * Trigo.sin(1 * jupiterElements.M - 1 * orbitalElements.M + 20 * 1e18 * int(Trigo.PI) / 1e18 / 180) / 1e18;\\n      longitude = longitude + dlon;\\n    }\\n  }\\n\\n\\n\\n  /**\\n   * @notice For a given longitude on earth at a given time, return the local sidereal time.\\n   * @param longitude The longitude for which to get the local sideral time, in degrees scaled by 1e18.\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return siderealTime The local sidereal time, in hours (range 0:24) scaled by 1e18.\\n   */\\n  function getLocalSiderealTime(int longitude, int dayNumber) internal pure returns (int siderealTime) {\\n    \\n    // Convert args to radians\\n    longitude = longitude * (int(Trigo.PI) / 180) / 1e18;\\n\\n    siderealTime = getLocalSiderealTimeInRadians(longitude, dayNumber);\\n\\n    // Convert result to hours\\n    siderealTime = siderealTime * 1e18 / (int(Trigo.PI) / 180) / 15;\\n  }\\n\\n  /**\\n   * @notice For a given longitude on earth at a given time, return the local sidereal time.\\n   *         Version with everything in radians.\\n   * @param longitude The longitude for which to get the local sideral time, in radians scaled by 1e18.\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return siderealTime The local sidereal time, in radians (range 0:2pi) scaled by 1e18.\\n   */\\n  function getLocalSiderealTimeInRadians(int longitude, int dayNumber) internal pure returns (int siderealTime) {\\n    // Compute the sun median longitude\\n    IPP.OrbitalElements memory sunElements = getOrbitalElements(IPP.CelestialBody.SUN, dayNumber);\\n    int L = Trigo.wrapAngleZeroToTwoPi(sunElements.w + sunElements.M);\\n\\n    // Compute GMST0 : The Sidereal Time at the Greenwich meridian at 00:00 right now\\n    int gmst0 = (L + int(Trigo.PI));\\n\\n    // Compute local Sidereal Time at the longitude of the observer : GMST0 + UT + LON\\n    siderealTime = gmst0 + (dayNumber % 1e18) * int(Trigo.TWO_PI) / 1e18 + longitude;\\n  }\\n\\n\\n\\n  /**\\n   * @notice Get orbital elements for a given celestial body at a given time.\\n   *         WARN: For the moon and sun, the origin is the earth, otherwise the origin is the sun.\\n   * @param body The celestial body to do the computation for\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return elements The orbital elements, in radians when applicable (N, i, w, M), scaled by 1e18.\\n   */\\n  function getOrbitalElements(IPP.CelestialBody body, int dayNumber) internal pure returns (IPP.OrbitalElements memory elements) {\\n\\n    IPP.OrbitalElementsParameters memory elementsParameters = getOrbitalElementsParameters(body);\\n\\n    elements = getOrbitalElements(elementsParameters, dayNumber);\\n  }\\n\\n  /**\\n   * @notice For a given set of orbital elements parameters, and a time of observation, return orbital\\n   *         elements.\\n   * @param elementsParameters The orbital elements parameters of the celestial body.\\n   * @param dayNumber The time of the observation, in the custom \\\"day number\\\" format (see above; scaled by 1e18)\\n   * @return elements The orbital elements, in radians when applicable (N, i, w, M), scaled by 1e18.\\n   */\\n  function getOrbitalElements(IPP.OrbitalElementsParameters memory elementsParameters, int dayNumber) internal pure returns (IPP.OrbitalElements memory elements) {\\n\\n    elements.body = elementsParameters.body;\\n    elements.origin = elementsParameters.origin;\\n\\n    elements.N = Trigo.wrapAngleZeroToTwoPi(elementsParameters.N + elementsParameters.dN * dayNumber / 1e18);\\n    elements.i = Trigo.wrapAngleZeroToTwoPi(elementsParameters.i + elementsParameters.di * dayNumber / 1e18);\\n    elements.w = Trigo.wrapAngleZeroToTwoPi(elementsParameters.w + elementsParameters.dw * dayNumber / 1e18);\\n    elements.a = elementsParameters.a + elementsParameters.da * dayNumber / 1e18;\\n    elements.e = elementsParameters.e + elementsParameters.de * dayNumber / 1e18;\\n    elements.M = Trigo.wrapAngleZeroToTwoPi(elementsParameters.M + elementsParameters.dM * dayNumber / 1e18);\\n\\n    elements.dayNumber = dayNumber;\\n  }\\n\\n  /**\\n   * @notice For a given body, returns the orbital element parameters necessary to compute the orbital\\n   *         elements at a given time.\\n   */\\n  function getOrbitalElementsParameters(IPP.CelestialBody body) internal pure returns (IPP.OrbitalElementsParameters memory elementsParameters) {\\n    \\n    elementsParameters.body = body;\\n    if(body == IPP.CelestialBody.SUN || body == IPP.CelestialBody.MOON) {\\n        elementsParameters.origin = IPP.CelestialBody.EARTH;\\n    }\\n    else {\\n        elementsParameters.origin = IPP.CelestialBody.SUN;\\n    }\\n\\n    // Fetching constants from the table, see doc of orbitalElementsConstantsTable\\n    bytes memory table = orbitalElementsConstantsTable;\\n    uint bodyTableOffset = uint(body) * 0x60;\\n    int Ni; \\n    int wa;\\n    int eM;\\n    assembly {\\n      Ni := mload(add(add(add(table, 0x20), bodyTableOffset), 0x00)) // Contains N1, N2, i1, i2\\n      wa := mload(add(add(add(table, 0x20), bodyTableOffset), 0x20)) // Contains w1, w2, a1, a2\\n      eM := mload(add(add(add(table, 0x20), bodyTableOffset), 0x40)) // Contains e1, e1, M1, M2\\n    }\\n\\n    elementsParameters.N = (Ni >> 24 * 8);\\n    elementsParameters.dN = (Ni << 8 * 8 >> 24 * 8);\\n    elementsParameters.i = (Ni << 16 * 8 >> 24 * 8);\\n    elementsParameters.di = (Ni << 24 * 8 >> 24 * 8);\\n    elementsParameters.w = (wa >> 24 * 8);\\n    elementsParameters.dw = (wa << 8 * 8 >> 24 * 8);\\n    elementsParameters.a = (wa << 16 * 8 >> 24 * 8 /** scaled by 1e16 */) * 1e2;\\n    elementsParameters.da = (wa << 24 * 8 >> 24 * 8);\\n    elementsParameters.e = (eM >> 24 * 8);\\n    elementsParameters.de = (eM << 8 * 8 >> 24 * 8);\\n    elementsParameters.M = (eM << 16 * 8 >> 24 * 8);\\n    elementsParameters.dM = (eM << 24 * 8 >> 24 * 8);\\n  }\\n}\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyAzimuthAltitude\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"azimuth\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"altitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyAzimuthAltitudeInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"azimuth\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"altitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"}],\"name\":\"getBodyAzimuthAltitudeNow\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"azimuth\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"altitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"orbitalElements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"at\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dat\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.AxialTilt\",\"name\":\"originAxialTilt\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"newOriginOrbitalElements\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"localSiderealTime\",\"type\":\"int256\"}],\"name\":\"getBodyBodyAzimuthAltitudeInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"azimuth\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"altitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"orbitalElements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"at\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dat\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.AxialTilt\",\"name\":\"originAxialTilt\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"newOriginOrbitalElements\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"}],\"name\":\"getBodyBodyTopocentricRADeclInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"orbitalElements\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"at\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dat\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.AxialTilt\",\"name\":\"originAxialTilt\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"newOriginOrbitalElements\",\"type\":\"tuple\"}],\"name\":\"getBodyBodycentricRADeclInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyEclipticLonLat\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"latitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyEclipticLonLatInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"latitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"orbitalElements\",\"type\":\"tuple\"}],\"name\":\"getBodyEclipticLonLatInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"latitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"}],\"name\":\"getBodyEclipticLonLatNow\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"latitude\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyGeocentricRADecl\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyGeocentricRADeclInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"}],\"name\":\"getBodyGeocentricRADeclNow\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyTopocentricRADecl\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getBodyTopocentricRADeclInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"observerLongitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"observerLatitude\",\"type\":\"int256\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"}],\"name\":\"getBodyTopocentricRADeclNow\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"rightAscension\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"declination\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"getDayNumberFromGregorianCalendar\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"getDayNumberFromGregorianCalendar1900to2100\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDayNumberFromTimestamp\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getLocalSiderealTime\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"siderealTime\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getLocalSiderealTimeInRadians\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"siderealTime\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dN\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"di\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dw\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"da\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"de\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dM\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElementsParameters\",\"name\":\"elementsParameters\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getOrbitalElements\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"elements\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"}],\"name\":\"getOrbitalElements\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"dayNumber\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElements\",\"name\":\"elements\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"}],\"name\":\"getOrbitalElementsParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"enum IPlanetaryPositions.CelestialBody\",\"name\":\"origin\",\"type\":\"uint8\"},{\"internalType\":\"int256\",\"name\":\"N\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dN\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"i\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"di\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"w\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dw\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"da\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"e\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"de\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"M\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"dM\",\"type\":\"int256\"}],\"internalType\":\"struct IPlanetaryPositions.OrbitalElementsParameters\",\"name\":\"elementsParameters\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PlanetaryPositions", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}