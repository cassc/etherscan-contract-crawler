{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LayerrRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {ILayerrRenderer} from \\\"./interfaces/ILayerrRenderer.sol\\\";\\r\\nimport {IOwnable} from \\\"./interfaces/IOwnable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LayerrRenderer\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice LayerrRenderer handles contractURI and tokenURI generation for contracts\\r\\n *         deployed on the Layerr platform. Contract owners have complete control of \\r\\n *         their tokens with the ability to set their own renderer, host their tokens\\r\\n *         with Layerr, set all tokens to a prereveal image, or set a base URI that\\r\\n *         token ids will be appended to.\\r\\n *         Tokens hosted with Layerr will automatically generate a tokenURI with the\\r\\n *         `layerrBaseTokenUri`/{chainId}/{contractAddress}/{tokenId} to allow new tokens\\r\\n *         to be minted without updating a base uri.\\r\\n *         For long term storage, Layerr-hosted tokens can be swept onto Layerr's IPFS\\r\\n *         solution.\\r\\n */\\r\\ncontract LayerrRenderer is ILayerrRenderer {\\r\\n\\r\\n    /// @dev Layerr-owned EOA that is allowed to update the base token and base contract URIs for Layerr-hosted non-IPFS tokens\\r\\n    address public owner;\\r\\n\\r\\n    /// @dev Layerr's signature account for checking parameters of tokens swept to Layerr IPFS\\r\\n    address public layerrSigner = 0xc44355A57368C22D01A8a146C0a2669B504B25A0;\\r\\n\\r\\n    /// @dev The base token URI that chainId, contractAddress and tokenId are added to for rendering\\r\\n    string public layerrBaseTokenUri = 'https://metadata.layerr.art';\\r\\n\\r\\n    /// @dev The base contract URI that chainId and contractAddress are added to for rendering\\r\\n    string public layerrBaseContractUri = 'https://contract-metadata.layerr.art';\\r\\n\\r\\n    /// @dev The rendering type for a token contract, defaults to LAYERR_HOSTED\\r\\n    mapping(address => RenderType) public contractRenderType;\\r\\n\\r\\n    /// @dev Base token URI set by the token contract owner for BASE_PLUS_TOKEN render type and LAYERR_HOSTED tokens on IPFS\\r\\n    mapping(address => string) public contractBaseTokenUri;\\r\\n\\r\\n    /// @dev Token contract URI set by the token contract owner\\r\\n    mapping(address => string) public contractContractUri;\\r\\n\\r\\n    /// @dev mapping of token contract addresses that flag a token contract as having all of its tokens hosted on Layerr IPFS\\r\\n    mapping(address => bool) public layerrHostedAllTokensOnIPFS;\\r\\n\\r\\n    /// @dev bitmap of token ids for a token contract that have been moved to Layerr hosted IPFS\\r\\n    mapping(address => mapping(uint256 => uint256)) public layerrHostedTokensOnIPFS;\\r\\n\\r\\n    /// @dev mapping of token contract addresses with the UTC timestamp of when the IPFS hosting is paid through\\r\\n    mapping(address => uint256) public layerrHostedIPFSExpiration;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        if (msg.sender != owner) {\\r\\n            revert NotContractOwner();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        owner = 0x0000000000799dfE79Ed462822EC68eF9a6199e6;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrRenderer\\r\\n     */\\r\\n    function tokenURI(\\r\\n        address contractAddress,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (string memory _tokenURI) {\\r\\n        RenderType renderType = contractRenderType[contractAddress];\\r\\n        if (renderType == RenderType.LAYERR_HOSTED) {\\r\\n            if(_isLayerrHostedIPFS(contractAddress, tokenId)) {\\r\\n                _tokenURI = string(\\r\\n                    abi.encodePacked(contractBaseTokenUri[contractAddress], _toString(tokenId))\\r\\n                );\\r\\n            } else {\\r\\n                _tokenURI = string(\\r\\n                    abi.encodePacked(\\r\\n                        layerrBaseTokenUri,\\r\\n                        \\\"/\\\",\\r\\n                        _toString(block.chainid),\\r\\n                        \\\"/\\\",\\r\\n                        _toString(contractAddress),\\r\\n                        \\\"/\\\",\\r\\n                        _toString(tokenId)\\r\\n                    )\\r\\n                );\\r\\n            }\\r\\n        } else if (renderType == RenderType.PREREVEAL) {\\r\\n            _tokenURI = contractBaseTokenUri[contractAddress];\\r\\n        } else if (renderType == RenderType.BASE_PLUS_TOKEN) {\\r\\n            _tokenURI = string(\\r\\n                abi.encodePacked(contractBaseTokenUri[contractAddress], _toString(tokenId))\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrRenderer\\r\\n     */\\r\\n    function contractURI(\\r\\n        address contractAddress\\r\\n    ) external view returns (string memory _contractURI) {\\r\\n        _contractURI = contractContractUri[contractAddress];\\r\\n        if (bytes(_contractURI).length == 0) {\\r\\n            _contractURI = string(\\r\\n                abi.encodePacked(\\r\\n                    layerrBaseContractUri,\\r\\n                    \\\"/\\\",\\r\\n                    _toString(block.chainid),\\r\\n                    \\\"/\\\",\\r\\n                    _toString(contractAddress)\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates rendering settings for a contract. Must be the ERC173 owner for the token contract to call.\\r\\n     * @param contractAddress address of the contract to set the base token URI for\\r\\n     * @param baseTokenUri base token URI to set for `contractAddress`\\r\\n     * @param renderType sets the current render type for the contract\\r\\n     */\\r\\n    function setContractBaseTokenUri(\\r\\n        address contractAddress,\\r\\n        string calldata baseTokenUri,\\r\\n        RenderType renderType\\r\\n    ) external {\\r\\n        if (IOwnable(contractAddress).owner() != msg.sender) {\\r\\n            revert NotContractOwner();\\r\\n        }\\r\\n        contractBaseTokenUri[contractAddress] = baseTokenUri;\\r\\n        contractRenderType[contractAddress] = renderType;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates rendering settings for a contract. Must be the ERC173 owner for the token contract to call.\\r\\n     * @param contractAddress address of the contract to set the base token URI for\\r\\n     * @param contractUri contract URI to set for `contractAddress`\\r\\n     */\\r\\n    function setContractUri(\\r\\n        address contractAddress,\\r\\n        string calldata contractUri\\r\\n    ) external {\\r\\n        if (IOwnable(contractAddress).owner() != msg.sender) {\\r\\n            revert NotContractOwner();\\r\\n        }\\r\\n        contractContractUri[contractAddress] = contractUri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the base token URI to sweep tokens to IPFS for Layerr hosted tokens\\r\\n     *         This allows new tokens to continue to be minted on the contract with the default\\r\\n     *         rendering address while existing tokens are moved onto IPFS for long term storage.\\r\\n     * @param contractAddress address of the token contract\\r\\n     * @param baseTokenUri base token URI to set for the contract's tokens\\r\\n     * @param allTokens set to true for larger collections that are done minting\\r\\n     *                  avoids setting each token id in the bitmap for gas savings but new tokens\\r\\n     *                  will not render with the default rendering address\\r\\n     * @param tokenIds array of token ids that are being swept to Layerr hosted IPFS\\r\\n     * @param ipfsExpiration UTC timestamp that the IPFS hosting is paid through\\r\\n     * @param signature signature by Layerr account to confirm the parameters supplied\\r\\n     */\\r\\n    function setContractBaseTokenUriForLayerrHostedIPFS(\\r\\n        address contractAddress,\\r\\n        string calldata baseTokenUri,\\r\\n        bool allTokens,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256 ipfsExpiration,\\r\\n        bytes calldata signature\\r\\n    ) external payable {\\r\\n        if (IOwnable(contractAddress).owner() != msg.sender) {\\r\\n            revert NotContractOwner();\\r\\n        }\\r\\n\\r\\n        bytes32 hash = keccak256(abi.encodePacked(contractAddress, baseTokenUri, ipfsExpiration, msg.value));\\r\\n        address signer = _recover(hash, signature);\\r\\n        if(signer != layerrSigner) revert InvalidSignature();\\r\\n\\r\\n        (bool sent, ) = payable(owner).call{value: msg.value}(\\\"\\\");\\r\\n        if (!sent) {\\r\\n            revert PaymentFailed();\\r\\n        }\\r\\n\\r\\n        layerrHostedIPFSExpiration[contractAddress] = ipfsExpiration;\\r\\n        layerrHostedAllTokensOnIPFS[contractAddress] = allTokens;\\r\\n        contractBaseTokenUri[contractAddress] = baseTokenUri;\\r\\n        contractRenderType[contractAddress] = RenderType.LAYERR_HOSTED;\\r\\n\\r\\n        for(uint256 i = 0;i < tokenIds.length;) {\\r\\n            _setLayerrHostedIPFS(contractAddress, tokenIds[i]);\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(ILayerrRenderer).interfaceId;\\r\\n    }\\r\\n\\r\\n    /* OWNER FUNCTIONS */\\r\\n    \\r\\n    /**\\r\\n     * @notice Owner function to set the Layerr signature account\\r\\n     * @param _layerrSigner address that will be used to check signatures\\r\\n     */\\r\\n    function setLayerrSigner(\\r\\n        address _layerrSigner\\r\\n    ) external onlyOwner {\\r\\n        layerrSigner = _layerrSigner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Owner function to set the default token rendering URI\\r\\n     * @param _layerrBaseTokenUri base token uri to be used for default token rendering\\r\\n     */\\r\\n    function setLayerrBaseTokenUri(\\r\\n        string calldata _layerrBaseTokenUri\\r\\n    ) external onlyOwner {\\r\\n        layerrBaseTokenUri = _layerrBaseTokenUri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Owner function to set the default contract rendering URI\\r\\n     * @param _layerrBaseContractUri base contract uri to be used for default rendering\\r\\n     */\\r\\n\\r\\n    function setLayerrBaseContractUri(\\r\\n        string calldata _layerrBaseContractUri\\r\\n    ) external onlyOwner {\\r\\n        layerrBaseContractUri = _layerrBaseContractUri;\\r\\n    }\\r\\n\\r\\n    /* INTERNAL FUNCTIONS */\\r\\n\\r\\n    /**\\r\\n     * @notice Checks to see if a token has been flagged as being hosted on Layerr IPFS\\r\\n     * @param contractAddress token contract address to check\\r\\n     * @param tokenId id of the token to check\\r\\n     * @return isIPFS if token has been flagged as being hosted on Layerr IPFS\\r\\n     */\\r\\n    function _isLayerrHostedIPFS(address contractAddress, uint256 tokenId) internal view returns(bool isIPFS) {\\r\\n        isIPFS = layerrHostedAllTokensOnIPFS[contractAddress] || layerrHostedTokensOnIPFS[contractAddress][tokenId >> 8] & (1 << (tokenId & 0xFF)) != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Flags a token as being hosted on Layerr IPFS in a bitmap\\r\\n     * @param contractAddress token contract address\\r\\n     * @param tokenId id of the token\\r\\n     */\\r\\n    function _setLayerrHostedIPFS(address contractAddress, uint256 tokenId) internal {\\r\\n        layerrHostedTokensOnIPFS[contractAddress][tokenId >> 8] |= (1 << (tokenId & 0xFF));\\r\\n    }\\r\\n\\r\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := add(mload(0x40), 0xa0)\\r\\n            mstore(0x40, m)\\r\\n            str := sub(m, 0x20)\\r\\n            mstore(str, 0)\\r\\n            let end := str\\r\\n\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := sub(str, 1)\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _toString(address value) internal pure returns (string memory) {\\r\\n        bytes memory s = new bytes(40);\\r\\n        for (uint i = 0; i < 20; ) {\\r\\n            bytes1 b = bytes1(uint8(uint(uint160(value)) / (2**(8*(19 - i)))));\\r\\n            bytes1 hi = bytes1(uint8(b) / 16);\\r\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\r\\n            s[2*i] = _char(hi);\\r\\n            s[2*i+1] = _char(lo);\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n        return string(s);\\r\\n    }\\r\\n\\r\\n    function _char(bytes1 b) internal pure returns (bytes1 c) {\\r\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\r\\n        else return bytes1(uint8(b) + 0x57);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Recover signer address from a message by using their signature\\r\\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\\r\\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\\r\\n     */\\r\\n    function _recover(\\r\\n        bytes32 hash,\\r\\n        bytes calldata sig\\r\\n    ) internal pure returns (address) {\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        // Check the signature length\\r\\n        if (sig.length != 65) {\\r\\n            return (address(0));\\r\\n        }\\r\\n\\r\\n        // Divide the signature in r, s and v variables\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r := calldataload(sig.offset)\\r\\n            s := calldataload(add(sig.offset, 32))\\r\\n            v := byte(0, calldataload(add(sig.offset, 64)))\\r\\n        }\\r\\n\\r\\n        // If the version is correct return the signer address\\r\\n        if (v != 27 && v != 28) {\\r\\n            return (address(0));\\r\\n        } else {\\r\\n            return ecrecover(hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILayerrRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {ERC165} from \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ILayerrRenderer\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice ILayerrRenderer interface defines functions required in LayerrRenderer to be callable by token contracts\\r\\n */\\r\\ninterface ILayerrRenderer is ERC165 {\\r\\n\\r\\n    enum RenderType {\\r\\n        LAYERR_HOSTED,\\r\\n        PREREVEAL,\\r\\n        BASE_PLUS_TOKEN\\r\\n    }\\r\\n\\r\\n    /// @dev Thrown when a payment fails for Layerr-hosted IPFS\\r\\n    error PaymentFailed();\\r\\n\\r\\n    /// @dev Thrown when a call is made for an owner-function by a non-contract owner\\r\\n    error NotContractOwner();\\r\\n\\r\\n    /// @dev Thrown when a signature is not made by the authorized account\\r\\n    error InvalidSignature();\\r\\n\\r\\n    /**\\r\\n     * @notice Generates a tokenURI for the `contractAddress` and `tokenId`\\r\\n     * @param contractAddress token contract address to render a token URI for\\r\\n     * @param tokenId token id to render\\r\\n     * @return uri for the token metadata\\r\\n     */\\r\\n    function tokenURI(\\r\\n        address contractAddress,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Generates a contractURI for the `contractAddress`\\r\\n     * @param contractAddress contract address to render a contract URI for\\r\\n     * @return uri for the contract metadata\\r\\n     */\\r\\n    function contractURI(\\r\\n        address contractAddress\\r\\n    ) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. \\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {ERC165} from './IERC165.sol';\\r\\n\\r\\ninterface IOwnable is ERC165 {\\r\\n\\r\\n    /// @dev Thrown when a non-owner is attempting to perform an owner function\\r\\n    error NotContractOwner();\\r\\n\\r\\n    /// @dev Emitted when contract ownership is transferred to a new owner\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Get the address of the owner    \\r\\n    /// @return The address of the owner.\\r\\n    function owner() view external returns(address);\\r\\n\\t\\r\\n    /// @notice Set the address of the new owner of the contract\\r\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n    /// @param _newOwner The address of the new owner of the contract    \\r\\n    function transferOwnership(address _newOwner) external;\\t\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 33333\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotContractOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractBaseTokenUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractContractUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractRenderType\",\"outputs\":[{\"internalType\":\"enum ILayerrRenderer.RenderType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerrBaseContractUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerrBaseTokenUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"layerrHostedAllTokensOnIPFS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"layerrHostedIPFSExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"layerrHostedTokensOnIPFS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerrSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseTokenUri\",\"type\":\"string\"},{\"internalType\":\"enum ILayerrRenderer.RenderType\",\"name\":\"renderType\",\"type\":\"uint8\"}],\"name\":\"setContractBaseTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseTokenUri\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"allTokens\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"ipfsExpiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"setContractBaseTokenUriForLayerrHostedIPFS\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractUri\",\"type\":\"string\"}],\"name\":\"setContractUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_layerrBaseContractUri\",\"type\":\"string\"}],\"name\":\"setLayerrBaseContractUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_layerrBaseTokenUri\",\"type\":\"string\"}],\"name\":\"setLayerrBaseTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_layerrSigner\",\"type\":\"address\"}],\"name\":\"setLayerrSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LayerrRenderer", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "33333", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6bc15351f18d369ad8114fef889337e19224acfe27fc86a5c6465257e33eef7f"}