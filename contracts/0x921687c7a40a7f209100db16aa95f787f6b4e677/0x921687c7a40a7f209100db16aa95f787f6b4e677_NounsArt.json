{"SourceCode": "{\"IInflator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Inflator\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from \\u0027./Inflate.sol\\u0027;\\n\\ninterface IInflator {\\n    function puff(bytes memory source, uint256 destlen) external pure returns (Inflate.ErrorCode, bytes memory);\\n}\\n\"},\"Inflate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity \\u003e=0.8.0 \\u003c0.9.0;\\n\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\n/// @dev Modified the original code for gas optimizations\\n/// 1. Disable overflow/underflow checks\\n/// 2. Chunk some loop iterations\\nlibrary Inflate {\\n    // Maximum bits in a code\\n    uint256 constant MAXBITS = 15;\\n    // Maximum number of literal/length codes\\n    uint256 constant MAXLCODES = 286;\\n    // Maximum number of distance codes\\n    uint256 constant MAXDCODES = 30;\\n    // Maximum codes lengths to read\\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n    // Number of fixed literal/length codes\\n    uint256 constant FIXLCODES = 288;\\n\\n    // Error codes\\n    enum ErrorCode {\\n        ERR_NONE, // 0 successful inflate\\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one\\u0027s complement\\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n        ERR_CONSTRUCT // 14 internal: error in construct()\\n    }\\n\\n    // Input and output state\\n    struct State {\\n        //////////////////\\n        // Output state //\\n        //////////////////\\n        // Output buffer\\n        bytes output;\\n        // Bytes written to out so far\\n        uint256 outcnt;\\n        /////////////////\\n        // Input state //\\n        /////////////////\\n        // Input buffer\\n        bytes input;\\n        // Bytes read so far\\n        uint256 incnt;\\n        ////////////////\\n        // Temp state //\\n        ////////////////\\n        // Bit buffer\\n        uint256 bitbuf;\\n        // Number of bits in bit buffer\\n        uint256 bitcnt;\\n        //////////////////////////\\n        // Static Huffman codes //\\n        //////////////////////////\\n        Huffman lencode;\\n        Huffman distcode;\\n    }\\n\\n    // Huffman code decoding tables\\n    struct Huffman {\\n        uint256[] counts;\\n        uint256[] symbols;\\n    }\\n\\n    function bits(State memory s, uint256 need) private pure returns (ErrorCode, uint256) {\\n        unchecked {\\n            // Bit accumulator (can use up to 20 bits)\\n            uint256 val;\\n\\n            // Load at least need bits into val\\n            val = s.bitbuf;\\n            while (s.bitcnt \\u003c need) {\\n                if (s.incnt == s.input.length) {\\n                    // Out of input\\n                    return (ErrorCode.ERR_NOT_TERMINATED, 0);\\n                }\\n\\n                // Load eight bits\\n                val |= uint256(uint8(s.input[s.incnt++])) \\u003c\\u003c s.bitcnt;\\n                s.bitcnt += 8;\\n            }\\n\\n            // Drop need bits and update buffer, always zero to seven bits left\\n            s.bitbuf = val \\u003e\\u003e need;\\n            s.bitcnt -= need;\\n\\n            // Return need bits, zeroing the bits above that\\n            uint256 ret = (val \\u0026 ((1 \\u003c\\u003c need) - 1));\\n            return (ErrorCode.ERR_NONE, ret);\\n        }\\n    }\\n\\n    function _stored(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length of stored block\\n            uint256 len;\\n\\n            // Discard leftover bits from current byte (assumes s.bitcnt \\u003c 8)\\n            s.bitbuf = 0;\\n            s.bitcnt = 0;\\n\\n            // Get length and check against its one\\u0027s complement\\n            if (s.incnt + 4 \\u003e s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            len = uint256(uint8(s.input[s.incnt++]));\\n            len |= uint256(uint8(s.input[s.incnt++])) \\u003c\\u003c 8;\\n\\n            if (uint8(s.input[s.incnt++]) != (~len \\u0026 0xFF) || uint8(s.input[s.incnt++]) != ((~len \\u003e\\u003e 8) \\u0026 0xFF)) {\\n                // Didn\\u0027t match complement!\\n                return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n            }\\n\\n            // Copy len bytes from in to out\\n            if (s.incnt + len \\u003e s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            if (s.outcnt + len \\u003e s.output.length) {\\n                // Not enough output space\\n                return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            while (len != 0) {\\n                // Note: Solidity reverts on underflow, so we decrement here\\n                len -= 1;\\n                s.output[s.outcnt++] = s.input[s.incnt++];\\n            }\\n\\n            // Done with a valid stored block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _decode(State memory s, Huffman memory h) private pure returns (ErrorCode, uint256) {\\n        unchecked {\\n            // Current number of bits in code\\n            uint256 len;\\n            // Len bits being decoded\\n            uint256 code = 0;\\n            // First code of length len\\n            uint256 first = 0;\\n            // Number of codes of length len\\n            uint256 count;\\n            // Index of first code of length len in symbol table\\n            uint256 index = 0;\\n            // Error code\\n            ErrorCode err;\\n\\n            uint256 tempCode;\\n            for (len = 1; len \\u003c= MAXBITS; len += 5) {\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len];\\n\\n                // If length len, return symbol\\n                if (code \\u003c first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first \\u003c\\u003c= 1;\\n                code \\u003c\\u003c= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 1];\\n\\n                // If length len, return symbol\\n                if (code \\u003c first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first \\u003c\\u003c= 1;\\n                code \\u003c\\u003c= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 2];\\n\\n                // If length len, return symbol\\n                if (code \\u003c first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first \\u003c\\u003c= 1;\\n                code \\u003c\\u003c= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 3];\\n\\n                // If length len, return symbol\\n                if (code \\u003c first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first \\u003c\\u003c= 1;\\n                code \\u003c\\u003c= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 4];\\n\\n                // If length len, return symbol\\n                if (code \\u003c first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first \\u003c\\u003c= 1;\\n                code \\u003c\\u003c= 1;\\n            }\\n\\n            // Ran out of codes\\n            return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\\n        }\\n    }\\n\\n    function _construct(\\n        Huffman memory h,\\n        uint256[] memory lengths,\\n        uint256 n,\\n        uint256 start\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Current symbol when stepping through lengths[]\\n            uint256 symbol;\\n            // Current length when stepping through h.counts[]\\n            uint256 len;\\n            // Number of possible codes left of current length\\n            uint256 left;\\n            // Offsets in symbol table for each length\\n            uint256[MAXBITS + 1] memory offs;\\n\\n            // Count number of codes of each length\\n            for (len = 0; len \\u003c= MAXBITS; ++len) {\\n                h.counts[len] = 0;\\n            }\\n            for (symbol = 0; symbol \\u003c n; ++symbol) {\\n                // Assumes lengths are within bounds\\n                ++h.counts[lengths[start + symbol]];\\n            }\\n            // No codes!\\n            if (h.counts[0] == n) {\\n                // Complete, but decode() will fail\\n                return (ErrorCode.ERR_NONE);\\n            }\\n\\n            // Check for an over-subscribed or incomplete set of lengths\\n\\n            // One possible code of zero length\\n            left = 1;\\n\\n            for (len = 1; len \\u003c= MAXBITS; len += 5) {\\n                // One more bit, double codes left\\n                left \\u003c\\u003c= 1;\\n                if (left \\u003c h.counts[len]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len];\\n\\n                // One more bit, double codes left\\n                left \\u003c\\u003c= 1;\\n                if (left \\u003c h.counts[len + 1]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 1];\\n\\n                // One more bit, double codes left\\n                left \\u003c\\u003c= 1;\\n                if (left \\u003c h.counts[len + 2]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 2];\\n\\n                // One more bit, double codes left\\n                left \\u003c\\u003c= 1;\\n                if (left \\u003c h.counts[len + 3]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 3];\\n\\n                // One more bit, double codes left\\n                left \\u003c\\u003c= 1;\\n                if (left \\u003c h.counts[len + 4]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 4];\\n            }\\n\\n            // Generate offsets into symbol table for each length for sorting\\n            offs[1] = 0;\\n            for (len = 1; len \\u003c MAXBITS; ++len) {\\n                offs[len + 1] = offs[len] + h.counts[len];\\n            }\\n\\n            // Put symbols in table sorted by length, by symbol order within each length\\n            for (symbol = 0; symbol \\u003c n; ++symbol) {\\n                if (lengths[start + symbol] != 0) {\\n                    h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n                }\\n            }\\n\\n            // Left \\u003e 0 means incomplete\\n            return left \\u003e 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _codes(\\n        State memory s,\\n        Huffman memory lencode,\\n        Huffman memory distcode\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decoded symbol\\n            uint256 symbol;\\n            // Length for copy\\n            uint256 len;\\n            // Distance for copy\\n            uint256 dist;\\n            // TODO Solidity doesn\\u0027t support constant arrays, but these are fixed at compile-time\\n            // Size base for length codes 257..285\\n            uint16[29] memory lens = [\\n                3,\\n                4,\\n                5,\\n                6,\\n                7,\\n                8,\\n                9,\\n                10,\\n                11,\\n                13,\\n                15,\\n                17,\\n                19,\\n                23,\\n                27,\\n                31,\\n                35,\\n                43,\\n                51,\\n                59,\\n                67,\\n                83,\\n                99,\\n                115,\\n                131,\\n                163,\\n                195,\\n                227,\\n                258\\n            ];\\n            // Extra bits for length codes 257..285\\n            uint8[29] memory lext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                1,\\n                1,\\n                2,\\n                2,\\n                2,\\n                2,\\n                3,\\n                3,\\n                3,\\n                3,\\n                4,\\n                4,\\n                4,\\n                4,\\n                5,\\n                5,\\n                5,\\n                5,\\n                0\\n            ];\\n            // Offset base for distance codes 0..29\\n            uint16[30] memory dists = [\\n                1,\\n                2,\\n                3,\\n                4,\\n                5,\\n                7,\\n                9,\\n                13,\\n                17,\\n                25,\\n                33,\\n                49,\\n                65,\\n                97,\\n                129,\\n                193,\\n                257,\\n                385,\\n                513,\\n                769,\\n                1025,\\n                1537,\\n                2049,\\n                3073,\\n                4097,\\n                6145,\\n                8193,\\n                12289,\\n                16385,\\n                24577\\n            ];\\n            // Extra bits for distance codes 0..29\\n            uint8[30] memory dext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                2,\\n                2,\\n                3,\\n                3,\\n                4,\\n                4,\\n                5,\\n                5,\\n                6,\\n                6,\\n                7,\\n                7,\\n                8,\\n                8,\\n                9,\\n                9,\\n                10,\\n                10,\\n                11,\\n                11,\\n                12,\\n                12,\\n                13,\\n                13\\n            ];\\n            // Error code\\n            ErrorCode err;\\n\\n            // Decode literals and length/distance pairs\\n            while (symbol != 256) {\\n                (err, symbol) = _decode(s, lencode);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Invalid symbol\\n                    return err;\\n                }\\n\\n                if (symbol \\u003c 256) {\\n                    // Literal: symbol is the byte\\n                    // Write out the literal\\n                    if (s.outcnt == s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    s.output[s.outcnt] = bytes1(uint8(symbol));\\n                    ++s.outcnt;\\n                } else if (symbol \\u003e 256) {\\n                    uint256 tempBits;\\n                    // Length\\n                    // Get and compute length\\n                    symbol -= 257;\\n                    if (symbol \\u003e= 29) {\\n                        // Invalid fixed code\\n                        return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n                    }\\n\\n                    (err, tempBits) = bits(s, lext[symbol]);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return err;\\n                    }\\n                    len = lens[symbol] + tempBits;\\n\\n                    // Get and check distance\\n                    (err, symbol) = _decode(s, distcode);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        // Invalid symbol\\n                        return err;\\n                    }\\n                    (err, tempBits) = bits(s, dext[symbol]);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return err;\\n                    }\\n                    dist = dists[symbol] + tempBits;\\n                    if (dist \\u003e s.outcnt) {\\n                        // Distance too far back\\n                        return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n                    }\\n\\n                    // Copy length bytes from distance bytes back\\n                    if (s.outcnt + len \\u003e s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    while (len != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        len -= 1;\\n                        s.output[s.outcnt] = s.output[s.outcnt - dist];\\n                        ++s.outcnt;\\n                    }\\n                } else {\\n                    s.outcnt += len;\\n                }\\n            }\\n\\n            // Done with a valid fixed or dynamic block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Build fixed Huffman tables\\n            // TODO this is all a compile-time constant\\n            uint256 symbol;\\n            uint256[] memory lengths = new uint256[](FIXLCODES);\\n\\n            // Literal/length table\\n            for (symbol = 0; symbol \\u003c 144; ++symbol) {\\n                lengths[symbol] = 8;\\n            }\\n            for (; symbol \\u003c 256; ++symbol) {\\n                lengths[symbol] = 9;\\n            }\\n            for (; symbol \\u003c 280; ++symbol) {\\n                lengths[symbol] = 7;\\n            }\\n            for (; symbol \\u003c FIXLCODES; ++symbol) {\\n                lengths[symbol] = 8;\\n            }\\n\\n            _construct(s.lencode, lengths, FIXLCODES, 0);\\n\\n            // Distance table\\n            for (symbol = 0; symbol \\u003c MAXDCODES; ++symbol) {\\n                lengths[symbol] = 5;\\n            }\\n\\n            _construct(s.distcode, lengths, MAXDCODES, 0);\\n\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decode data until end-of-block code\\n            return _codes(s, s.lencode, s.distcode);\\n        }\\n    }\\n\\n    function _build_dynamic_lengths(State memory s) private pure returns (ErrorCode, uint256[] memory) {\\n        unchecked {\\n            uint256 ncode;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Error code\\n            ErrorCode err;\\n            // Permutation of code length codes\\n            uint8[19] memory order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n            (err, ncode) = bits(s, 4);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lengths);\\n            }\\n            ncode += 4;\\n\\n            // Read code length code lengths (really), missing lengths are zero\\n            for (index = 0; index \\u003c ncode; ++index) {\\n                (err, lengths[order[index]]) = bits(s, 3);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, lengths);\\n                }\\n            }\\n            for (; index \\u003c 19; ++index) {\\n                lengths[order[index]] = 0;\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lengths);\\n        }\\n    }\\n\\n    function _build_dynamic(State memory s)\\n        private\\n        pure\\n        returns (\\n            ErrorCode,\\n            Huffman memory,\\n            Huffman memory\\n        )\\n    {\\n        unchecked {\\n            // Number of lengths in descriptor\\n            uint256 nlen;\\n            uint256 ndist;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Error code\\n            ErrorCode err;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Length and distance codes\\n            Huffman memory lencode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n            Huffman memory distcode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n            uint256 tempBits;\\n\\n            // Get number of lengths in each table, check lengths\\n            (err, nlen) = bits(s, 5);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n            nlen += 257;\\n            (err, ndist) = bits(s, 5);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n            ndist += 1;\\n\\n            if (nlen \\u003e MAXLCODES || ndist \\u003e MAXDCODES) {\\n                // Bad counts\\n                return (ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, lencode, distcode);\\n            }\\n\\n            (err, lengths) = _build_dynamic_lengths(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n\\n            // Build huffman table for code lengths codes (use lencode temporarily)\\n            err = _construct(lencode, lengths, 19, 0);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Require complete code set here\\n                return (ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE, lencode, distcode);\\n            }\\n\\n            // Read length/literal and distance code length tables\\n            index = 0;\\n            while (index \\u003c nlen + ndist) {\\n                // Decoded value\\n                uint256 symbol;\\n                // Last length to repeat\\n                uint256 len;\\n\\n                (err, symbol) = _decode(s, lencode);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Invalid symbol\\n                    return (err, lencode, distcode);\\n                }\\n\\n                if (symbol \\u003c 16) {\\n                    // Length in 0..15\\n                    lengths[index++] = symbol;\\n                } else {\\n                    // Repeat instruction\\n                    // Assume repeating zeros\\n                    len = 0;\\n                    if (symbol == 16) {\\n                        // Repeat last length 3..6 times\\n                        if (index == 0) {\\n                            // No last length!\\n                            return (ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH, lencode, distcode);\\n                        }\\n                        // Last length\\n                        len = lengths[index - 1];\\n                        (err, tempBits) = bits(s, 2);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 3 + tempBits;\\n                    } else if (symbol == 17) {\\n                        // Repeat zero 3..10 times\\n                        (err, tempBits) = bits(s, 3);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 3 + tempBits;\\n                    } else {\\n                        // == 18, repeat zero 11..138 times\\n                        (err, tempBits) = bits(s, 7);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 11 + tempBits;\\n                    }\\n\\n                    if (index + symbol \\u003e nlen + ndist) {\\n                        // Too many lengths!\\n                        return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n                    }\\n                    while (symbol != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        symbol -= 1;\\n\\n                        // Repeat last or zero symbol times\\n                        lengths[index++] = len;\\n                    }\\n                }\\n            }\\n\\n            // Check for end-of-block code -- there better be one!\\n            if (lengths[256] == 0) {\\n                return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n            }\\n\\n            // Build huffman table for literal/length codes\\n            err = _construct(lencode, lengths, nlen, 0);\\n            if (\\n                err != ErrorCode.ERR_NONE \\u0026\\u0026\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    nlen != lencode.counts[0] + lencode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            // Build huffman table for distance codes\\n            err = _construct(distcode, lengths, ndist, nlen);\\n            if (\\n                err != ErrorCode.ERR_NONE \\u0026\\u0026\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    ndist != distcode.counts[0] + distcode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lencode, distcode);\\n        }\\n    }\\n\\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length and distance codes\\n            Huffman memory lencode;\\n            Huffman memory distcode;\\n            // Error code\\n            ErrorCode err;\\n\\n            (err, lencode, distcode) = _build_dynamic(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return err;\\n            }\\n\\n            // Decode data until end-of-block code\\n            return _codes(s, lencode, distcode);\\n        }\\n    }\\n\\n    function puff(bytes memory source, uint256 destlen) internal pure returns (ErrorCode, bytes memory) {\\n        unchecked {\\n            // Input/output state\\n            State memory s = State(\\n                new bytes(destlen),\\n                0,\\n                source,\\n                0,\\n                0,\\n                0,\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n            );\\n            // Temp: last bit\\n            uint256 last;\\n            // Temp: block type bit\\n            uint256 t;\\n            // Error code\\n            ErrorCode err;\\n\\n            // Build fixed Huffman tables\\n            err = _build_fixed(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            // Process blocks until last block or error\\n            while (last == 0) {\\n                // One if last block\\n                (err, last) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, s.output);\\n                }\\n\\n                // Block type 0..3\\n                (err, t) = bits(s, 2);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, s.output);\\n                }\\n\\n                err = (\\n                    t == 0\\n                        ? _stored(s)\\n                        : (t == 1 ? _fixed(s) : (t == 2 ? _dynamic(s) : ErrorCode.ERR_INVALID_BLOCK_TYPE))\\n                );\\n                // type == 3, invalid\\n\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Return with error\\n                    break;\\n                }\\n            }\\n\\n            return (err, s.output);\\n        }\\n    }\\n}\\n\"},\"INounsArt.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsArt\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { IInflator } from \\u0027./IInflator.sol\\u0027;\\n\\ninterface INounsArt {\\n    error SenderIsNotDescriptor();\\n\\n    error EmptyPalette();\\n\\n    error BadPaletteLength();\\n\\n    error EmptyBytes();\\n\\n    error BadDecompressedLength();\\n\\n    error BadImageCount();\\n\\n    error ImageNotFound();\\n\\n    error PaletteNotFound();\\n\\n    event DescriptorUpdated(address oldDescriptor, address newDescriptor);\\n\\n    event InflatorUpdated(address oldInflator, address newInflator);\\n\\n    event BackgroundsAdded(uint256 count);\\n\\n    event PaletteSet(uint8 paletteIndex);\\n\\n    event BodiesAdded(uint16 count);\\n\\n    event AccessoriesAdded(uint16 count);\\n\\n    event HeadsAdded(uint16 count);\\n\\n    event GlassesAdded(uint16 count);\\n\\n    struct NounArtStoragePage {\\n        uint16 imageCount;\\n        uint80 decompressedLength;\\n        address pointer;\\n    }\\n\\n    struct Trait {\\n        NounArtStoragePage[] storagePages;\\n        uint256 storedImagesCount;\\n    }\\n\\n    function descriptor() external view returns (address);\\n\\n    function inflator() external view returns (IInflator);\\n\\n    function setDescriptor(address descriptor) external;\\n\\n    function setInflator(IInflator inflator) external;\\n\\n    function addManyBackgrounds(string[] calldata _backgrounds) external;\\n\\n    function addBackground(string calldata _background) external;\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addBodies(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addAccessories(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeads(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlasses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addBodiesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addAccessoriesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeadsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlassesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function backgroundCount() external view returns (uint256);\\n\\n    function bodyCount() external view returns (uint256);\\n\\n    function accessoryCount() external view returns (uint256);\\n\\n    function headCount() external view returns (uint256);\\n\\n    function glassesCount() external view returns (uint256);\\n\\n    function backgrounds(uint256 index) external view returns (string memory);\\n\\n    function heads(uint256 index) external view returns (bytes memory);\\n\\n    function bodies(uint256 index) external view returns (bytes memory);\\n\\n    function accessories(uint256 index) external view returns (bytes memory);\\n\\n    function glasses(uint256 index) external view returns (bytes memory);\\n\\n    function getBodiesTrait() external view returns (Trait memory);\\n\\n    function getAccessoriesTrait() external view returns (Trait memory);\\n\\n    function getHeadsTrait() external view returns (Trait memory);\\n\\n    function getGlassesTrait() external view returns (Trait memory);\\n}\\n\"},\"NounsArt.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The Nouns art storage contract\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsArt } from \\u0027./INounsArt.sol\\u0027;\\nimport { SSTORE2 } from \\u0027./SSTORE2.sol\\u0027;\\nimport { IInflator } from \\u0027./IInflator.sol\\u0027;\\n\\ncontract NounsArt is INounsArt {\\n    /// @notice Current Nouns Descriptor address\\n    address public override descriptor;\\n\\n    /// @notice Current inflator address\\n    IInflator public override inflator;\\n\\n    /// @notice Noun Backgrounds (Hex Colors)\\n    string[] public override backgrounds;\\n\\n    /// @notice Noun Color Palettes (Index =\\u003e Hex Colors, stored as a contract using SSTORE2)\\n    mapping(uint8 =\\u003e address) public palettesPointers;\\n\\n    /// @notice Noun Bodies Trait\\n    Trait public bodiesTrait;\\n\\n    /// @notice Noun Accessories Trait\\n    Trait public accessoriesTrait;\\n\\n    /// @notice Noun Heads Trait\\n    Trait public headsTrait;\\n\\n    /// @notice Noun Glasses Trait\\n    Trait public glassesTrait;\\n\\n    /**\\n     * @notice Require that the sender is the descriptor.\\n     */\\n    modifier onlyDescriptor() {\\n        if (msg.sender != descriptor) {\\n            revert SenderIsNotDescriptor();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _descriptor, IInflator _inflator) {\\n        descriptor = _descriptor;\\n        inflator = _inflator;\\n    }\\n\\n    /**\\n     * @notice Set the descriptor.\\n     * @dev This function can only be called by the current descriptor.\\n     */\\n    function setDescriptor(address _descriptor) external override onlyDescriptor {\\n        address oldDescriptor = descriptor;\\n        descriptor = _descriptor;\\n\\n        emit DescriptorUpdated(oldDescriptor, descriptor);\\n    }\\n\\n    /**\\n     * @notice Set the inflator.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setInflator(IInflator _inflator) external override onlyDescriptor {\\n        address oldInflator = address(inflator);\\n        inflator = _inflator;\\n\\n        emit InflatorUpdated(oldInflator, address(_inflator));\\n    }\\n\\n    /**\\n     * @notice Get the Trait struct for bodies.\\n     * @dev This explicit getter is needed because implicit getters for structs aren\\u0027t fully supported yet:\\n     * https://github.com/ethereum/solidity/issues/11826\\n     * @return Trait the struct, including a total image count, and an array of storage pages.\\n     */\\n    function getBodiesTrait() external view override returns (Trait memory) {\\n        return bodiesTrait;\\n    }\\n\\n    /**\\n     * @notice Get the Trait struct for accessories.\\n     * @dev This explicit getter is needed because implicit getters for structs aren\\u0027t fully supported yet:\\n     * https://github.com/ethereum/solidity/issues/11826\\n     * @return Trait the struct, including a total image count, and an array of storage pages.\\n     */\\n    function getAccessoriesTrait() external view override returns (Trait memory) {\\n        return accessoriesTrait;\\n    }\\n\\n    /**\\n     * @notice Get the Trait struct for heads.\\n     * @dev This explicit getter is needed because implicit getters for structs aren\\u0027t fully supported yet:\\n     * https://github.com/ethereum/solidity/issues/11826\\n     * @return Trait the struct, including a total image count, and an array of storage pages.\\n     */\\n    function getHeadsTrait() external view override returns (Trait memory) {\\n        return headsTrait;\\n    }\\n\\n    /**\\n     * @notice Get the Trait struct for glasses.\\n     * @dev This explicit getter is needed because implicit getters for structs aren\\u0027t fully supported yet:\\n     * https://github.com/ethereum/solidity/issues/11826\\n     * @return Trait the struct, including a total image count, and an array of storage pages.\\n     */\\n    function getGlassesTrait() external view override returns (Trait memory) {\\n        return glassesTrait;\\n    }\\n\\n    /**\\n     * @notice Batch add Noun backgrounds.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addManyBackgrounds(string[] calldata _backgrounds) external override onlyDescriptor {\\n        for (uint256 i = 0; i \\u003c _backgrounds.length; i++) {\\n            _addBackground(_backgrounds[i]);\\n        }\\n\\n        emit BackgroundsAdded(_backgrounds.length);\\n    }\\n\\n    /**\\n     * @notice Add a Noun background.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addBackground(string calldata _background) external override onlyDescriptor {\\n        _addBackground(_background);\\n\\n        emit BackgroundsAdded(1);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette.\\n     * @param paletteIndex the identifier of this palette\\n     * @param palette byte array of colors. every 3 bytes represent an RGB color. max length: 256 * 3 = 768\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external override onlyDescriptor {\\n        if (palette.length == 0) {\\n            revert EmptyPalette();\\n        }\\n        if (palette.length % 3 != 0 || palette.length \\u003e 768) {\\n            revert BadPaletteLength();\\n        }\\n        palettesPointers[paletteIndex] = SSTORE2.write(palette);\\n\\n        emit PaletteSet(paletteIndex);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addBodies(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(bodiesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit BodiesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of accessory images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addAccessories(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(accessoriesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit AccessoriesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of head images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addHeads(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(headsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit HeadsAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of glasses images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addGlasses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(glassesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit GlassesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette. This function does not check for data length validity\\n     * (len \\u003c= 768, len % 3 == 0).\\n     * @param paletteIndex the identifier of this palette\\n     * @param pointer the address of the contract holding the palette bytes. every 3 bytes represent an RGB color.\\n     * max length: 256 * 3 = 768.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external override onlyDescriptor {\\n        palettesPointers[paletteIndex] = pointer;\\n\\n        emit PaletteSet(paletteIndex);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addBodiesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(bodiesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit BodiesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of accessory images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addAccessoriesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(accessoriesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit AccessoriesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of head images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches\\n     * @dev This function can only be called by the descriptor..\\n     */\\n    function addHeadsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(headsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit HeadsAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of glasses images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addGlassesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(glassesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit GlassesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `backgrounds`.\\n     */\\n    function backgroundCount() external view returns (uint256) {\\n        return backgrounds.length;\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `bodies`.\\n     */\\n    function bodyCount() external view returns (uint256) {\\n        return bodiesTrait.storedImagesCount;\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `accessories`.\\n     */\\n    function accessoryCount() external view returns (uint256) {\\n        return accessoriesTrait.storedImagesCount;\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `heads`.\\n     */\\n    function headCount() external view returns (uint256) {\\n        return headsTrait.storedImagesCount;\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `glasses`.\\n     */\\n    function glassesCount() external view returns (uint256) {\\n        return glassesTrait.storedImagesCount;\\n    }\\n\\n    /**\\n     * @notice Get a head image bytes (RLE-encoded).\\n     */\\n    function heads(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(headsTrait, index);\\n    }\\n\\n    /**\\n     * @notice Get a body image bytes (RLE-encoded).\\n     */\\n    function bodies(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(bodiesTrait, index);\\n    }\\n\\n    /**\\n     * @notice Get a accessory image bytes (RLE-encoded).\\n     */\\n    function accessories(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(accessoriesTrait, index);\\n    }\\n\\n    /**\\n     * @notice Get a glasses image bytes (RLE-encoded).\\n     */\\n    function glasses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(glassesTrait, index);\\n    }\\n\\n    /**\\n     * @notice Get a color palette bytes.\\n     */\\n    function palettes(uint8 paletteIndex) public view override returns (bytes memory) {\\n        address pointer = palettesPointers[paletteIndex];\\n        if (pointer == address(0)) {\\n            revert PaletteNotFound();\\n        }\\n        return SSTORE2.read(palettesPointers[paletteIndex]);\\n    }\\n\\n    function _addBackground(string calldata _background) internal {\\n        backgrounds.push(_background);\\n    }\\n\\n    function addPage(\\n        Trait storage trait,\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) internal {\\n        if (encodedCompressed.length == 0) {\\n            revert EmptyBytes();\\n        }\\n        address pointer = SSTORE2.write(encodedCompressed);\\n        addPage(trait, pointer, decompressedLength, imageCount);\\n    }\\n\\n    function addPage(\\n        Trait storage trait,\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) internal {\\n        if (decompressedLength == 0) {\\n            revert BadDecompressedLength();\\n        }\\n        if (imageCount == 0) {\\n            revert BadImageCount();\\n        }\\n        trait.storagePages.push(\\n            NounArtStoragePage({ pointer: pointer, decompressedLength: decompressedLength, imageCount: imageCount })\\n        );\\n        trait.storedImagesCount += imageCount;\\n    }\\n\\n    function imageByIndex(INounsArt.Trait storage trait, uint256 index) internal view returns (bytes memory) {\\n        (INounsArt.NounArtStoragePage storage page, uint256 indexInPage) = getPage(trait.storagePages, index);\\n        bytes[] memory decompressedImages = decompressAndDecode(page);\\n        return decompressedImages[indexInPage];\\n    }\\n\\n    /**\\n     * @dev Given an image index, this function finds the storage page the image is in, and the relative index\\n     * inside the page, so the image can be read from storage.\\n     * Example: if you have 2 pages with 100 images each, and you want to get image 150, this function would return\\n     * the 2nd page, and the 50th index.\\n     * @return INounsArt.NounArtStoragePage the page containing the image at index\\n     * @return uint256 the index of the image in the page\\n     */\\n    function getPage(INounsArt.NounArtStoragePage[] storage pages, uint256 index)\\n        internal\\n        view\\n        returns (INounsArt.NounArtStoragePage storage, uint256)\\n    {\\n        uint256 len = pages.length;\\n        uint256 pageFirstImageIndex = 0;\\n        for (uint256 i = 0; i \\u003c len; i++) {\\n            INounsArt.NounArtStoragePage storage page = pages[i];\\n\\n            if (index \\u003c pageFirstImageIndex + page.imageCount) {\\n                return (page, index - pageFirstImageIndex);\\n            }\\n\\n            pageFirstImageIndex += page.imageCount;\\n        }\\n\\n        revert ImageNotFound();\\n    }\\n\\n    function decompressAndDecode(INounsArt.NounArtStoragePage storage page) internal view returns (bytes[] memory) {\\n        bytes memory compressedData = SSTORE2.read(page.pointer);\\n        (, bytes memory decompressedData) = inflator.puff(compressedData, page.decompressedLength);\\n        return abi.decode(decompressedData, (bytes[]));\\n    }\\n}\\n\"},\"SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity ^0.8.6;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it\\u0027s a STOP opcode to ensure the contract can\\u0027t be called.\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\u002700\\u0027, data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\u002760_0B_59_81_38_03_80_92_59_39_F3\\u0027, // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\u0027DEPLOYMENT_FAILED\\u0027);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length \\u003e= end, \\u0027OUT_OF_BOUNDS\\u0027);\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"},{\"internalType\":\"contract IInflator\",\"name\":\"_inflator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadDecompressedLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadImageCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPaletteLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBytes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyPalette\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImageNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaletteNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderIsNotDescriptor\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"AccessoriesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"BackgroundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"BodiesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDescriptor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDescriptor\",\"type\":\"address\"}],\"name\":\"DescriptorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"GlassesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"HeadsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldInflator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newInflator\",\"type\":\"address\"}],\"name\":\"InflatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"}],\"name\":\"PaletteSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"accessories\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessoriesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addAccessories\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addAccessoriesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_background\",\"type\":\"string\"}],\"name\":\"addBackground\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBodies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBodiesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlassesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHeads\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHeadsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_backgrounds\",\"type\":\"string[]\"}],\"name\":\"addManyBackgrounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backgroundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backgrounds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"bodies\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bodiesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bodyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descriptor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccessoriesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct INounsArt.NounArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct INounsArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBodiesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct INounsArt.NounArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct INounsArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlassesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct INounsArt.NounArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct INounsArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHeadsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct INounsArt.NounArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct INounsArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"glasses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glassesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glassesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"heads\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflator\",\"outputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"palettesPointers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"}],\"name\":\"setDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"_inflator\",\"type\":\"address\"}],\"name\":\"setInflator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"setPalettePointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NounsArt", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000025ff2fde7df1a433e09749c952f7e09ad3c27951000000000000000000000000a2acee85cd81c42bcaa1fefa8ed2516b68872dbe", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://af309f0f23a6e4cfcbe9adbeaeba7331a7447a6a51cf61f3dc3ae8b45c13bc20"}