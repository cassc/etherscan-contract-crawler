{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20/IERC20ByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20ConfigByMetadrop} from \\\"./IERC20ConfigByMetadrop.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Metadrop core ERC-20 contract, interface\\n */\\ninterface IERC20ByMetadrop is\\n  IConfigStructures,\\n  IERC20,\\n  IERC20ConfigByMetadrop,\\n  IERC20Metadata\\n{\\n  event AutoSwapThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);\\n\\n  event ExternalCallError(uint256 identifier);\\n\\n  event InitialLiquidityAdded(uint256 tokenA, uint256 tokenB, uint256 lpToken);\\n\\n  event LimitsUpdated(\\n    uint256 oldMaxTokensPerTransaction,\\n    uint256 newMaxTokensPerTransaction,\\n    uint256 oldMaxTokensPerWallet,\\n    uint256 newMaxTokensPerWallet\\n  );\\n\\n  event LiquidityLocked(uint256 lpTokens, uint256 lpLockupInDays);\\n\\n  event LiquidityBurned(uint256 lpTokens);\\n\\n  event LiquidityPoolCreated(address addedPool);\\n\\n  event LiquidityPoolAdded(address addedPool);\\n\\n  event LiquidityPoolRemoved(address removedPool);\\n\\n  event MetadropTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event ProjectTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event RevenueAutoSwap();\\n\\n  event ProjectTaxRecipientUpdated(address treasury);\\n\\n  event UnlimitedAddressAdded(address addedUnlimted);\\n\\n  event UnlimitedAddressRemoved(address removedUnlimted);\\n\\n  event ValidCallerAdded(bytes32 addedValidCaller);\\n\\n  event ValidCallerRemoved(bytes32 removedValidCaller);\\n\\n  /**\\n   * @dev function {addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair\\n   *\\n   * @param vaultFee_ The vault fee in wei. This must match the required fee from the external vault contract.\\n   * @param lpLockupInDaysOverride_ The number of days to lock liquidity NOTE you can pass 0 to use the stored value.\\n   * This value is an override, and will override a stored value which is LOWER that it. If the value you are passing is\\n   * LOWER than the stored value the stored value will not be reduced.\\n   *\\n   * Example usage 1: When creating the coin the lpLockupInDays is set to 0. This means that on this call the\\n   * user can set the lockup to any value they like, as all integer values greater than zero will be used to override\\n   * that set in storage.\\n   *\\n   * Example usage 2: When using a DRI Pool the lockup period is set on this contract and the pool need not know anything\\n   * about this setting. The pool can pass back a 0 on this call and know that the existing value stored on this contract\\n   * will be used.\\n   * @param burnLPTokensOverride_ If the LP tokens should be burned (otherwise they are locked). This is an override field\\n   * that can ONLY be used to override a held value of FALSE with a new value of TRUE.\\n   *\\n   * Example usage 1: When creating the coin the user didn't add liquidity, or specify that the LP tokens were to be burned.\\n   * So burnLPTokens is held as FALSE. When they add liquidity they want to lock tokens, so they pass this in as FALSE again,\\n   * and it remains FALSE.\\n   *\\n   * Example usage 2: As above, but when later adding liquidity the user wants to burn the LP. So the stored value is FALSE\\n   * and the user passes TRUE into this method. The TRUE overrides the held value of FALSE and the tokens are burned.\\n   *\\n   * Example uusage 3: The user is using a DRI pool and they have specified on the coin creation that the LP tokens are to\\n   * be burned. This contract therefore holds TRUE for burnLPTokens. The DRI pool does not need to know what the user has\\n   * selected. It can safely pass back FALSE to this method call and the stored value of TRUE will remain, resulting in the\\n   * LP tokens being burned.\\n   */\\n  function addInitialLiquidity(\\n    uint256 vaultFee_,\\n    uint256 lpLockupInDaysOverride_,\\n    bool burnLPTokensOverride_\\n  ) external payable;\\n\\n  /**\\n   * @dev function {isLiquidityPool}\\n   *\\n   * Return if an address is a liquidity pool\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't a liquidity pool\\n   */\\n  function isLiquidityPool(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {liquidityPools}\\n   *\\n   * Returns a list of all liquidity pools\\n   *\\n   * @return liquidityPools_ a list of all liquidity pools\\n   */\\n  function liquidityPools()\\n    external\\n    view\\n    returns (address[] memory liquidityPools_);\\n\\n  /**\\n   * @dev function {addLiquidityPool} onlyOwner\\n   *\\n   * Allows the manager to add a liquidity pool to the pool enumerable set\\n   *\\n   * @param newLiquidityPool_ The address of the new liquidity pool\\n   */\\n  function addLiquidityPool(address newLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {removeLiquidityPool} onlyOwner\\n   *\\n   * Allows the manager to remove a liquidity pool\\n   *\\n   * @param removedLiquidityPool_ The address of the old removed liquidity pool\\n   */\\n  function removeLiquidityPool(address removedLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {isUnlimited}\\n   *\\n   * Return if an address is unlimited (is not subject to per txn and per wallet limits)\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't unlimited\\n   */\\n  function isUnlimited(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {unlimitedAddresses}\\n   *\\n   * Returns a list of all unlimited addresses\\n   *\\n   * @return unlimitedAddresses_ a list of all unlimited addresses\\n   */\\n  function unlimitedAddresses()\\n    external\\n    view\\n    returns (address[] memory unlimitedAddresses_);\\n\\n  /**\\n   * @dev function {addUnlimited} onlyOwner\\n   *\\n   * Allows the manager to add an unlimited address\\n   *\\n   * @param newUnlimited_ The address of the new unlimited address\\n   */\\n  function addUnlimited(address newUnlimited_) external;\\n\\n  /**\\n   * @dev function {removeUnlimited} onlyOwner\\n   *\\n   * Allows the manager to remove an unlimited address\\n   *\\n   * @param removedUnlimited_ The address of the old removed unlimited address\\n   */\\n  function removeUnlimited(address removedUnlimited_) external;\\n\\n  /**\\n   * @dev function {isValidCaller}\\n   *\\n   * Return if an address is a valid caller\\n   *\\n   * @param queryHash_ The code hash being queried\\n   * @return bool The address is / isn't a valid caller\\n   */\\n  function isValidCaller(bytes32 queryHash_) external view returns (bool);\\n\\n  /**\\n   * @dev function {validCallers}\\n   *\\n   * Returns a list of all valid caller code hashes\\n   *\\n   * @return validCallerHashes_ a list of all valid caller code hashes\\n   */\\n  function validCallers()\\n    external\\n    view\\n    returns (bytes32[] memory validCallerHashes_);\\n\\n  /**\\n   * @dev function {addValidCaller} onlyOwner\\n   *\\n   * Allows the owner to add the hash of a valid caller\\n   *\\n   * @param newValidCallerHash_ The hash of the new valid caller\\n   */\\n  function addValidCaller(bytes32 newValidCallerHash_) external;\\n\\n  /**\\n   * @dev function {removeValidCaller} onlyOwner\\n   *\\n   * Allows the owner to remove a valid caller\\n   *\\n   * @param removedValidCallerHash_ The hash of the old removed valid caller\\n   */\\n  function removeValidCaller(bytes32 removedValidCallerHash_) external;\\n\\n  /**\\n   * @dev function {setProjectTaxRecipient} onlyOwner\\n   *\\n   * Allows the manager to set the project tax recipient address\\n   *\\n   * @param projectTaxRecipient_ New recipient address\\n   */\\n  function setProjectTaxRecipient(address projectTaxRecipient_) external;\\n\\n  /**\\n   * @dev function {setSwapThresholdBasisPoints} onlyOwner\\n   *\\n   * Allows the manager to set the autoswap threshold\\n   *\\n   * @param swapThresholdBasisPoints_ New swap threshold in basis points\\n   */\\n  function setSwapThresholdBasisPoints(\\n    uint16 swapThresholdBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {setProjectTaxRates} onlyOwner\\n   *\\n   * Change the tax rates, subject to only ever decreasing\\n   *\\n   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newProjectSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setProjectTaxRates(\\n    uint16 newProjectBuyTaxBasisPoints_,\\n    uint16 newProjectSellTaxBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {setLimits} onlyOwner\\n   *\\n   * Change the limits on transactions and holdings\\n   *\\n   * @param newMaxTokensPerTransaction_ The new per txn limit\\n   * @param newMaxTokensPerWallet_ The new tokens per wallet limit\\n   */\\n  function setLimits(\\n    uint256 newMaxTokensPerTransaction_,\\n    uint256 newMaxTokensPerWallet_\\n  ) external;\\n\\n  /**\\n   * @dev function {limitsEnforced}\\n   *\\n   * Return if limits are enforced on this contract\\n   *\\n   * @return bool : they are / aren't\\n   */\\n  function limitsEnforced() external view returns (bool);\\n\\n  /**\\n   * @dev getMetadropBuyTaxBasisPoints\\n   *\\n   * Return the metadrop buy tax basis points given the timed expiry\\n   */\\n  function getMetadropBuyTaxBasisPoints() external view returns (uint256);\\n\\n  /**\\n   * @dev getMetadropSellTaxBasisPoints\\n   *\\n   * Return the metadrop sell tax basis points given the timed expiry\\n   */\\n  function getMetadropSellTaxBasisPoints() external view returns (uint256);\\n\\n  /**\\n   * @dev totalBuyTaxBasisPoints\\n   *\\n   * Provide easy to view tax total:\\n   */\\n  function totalBuyTaxBasisPoints() external view returns (uint256);\\n\\n  /**\\n   * @dev totalSellTaxBasisPoints\\n   *\\n   * Provide easy to view tax total:\\n   */\\n  function totalSellTaxBasisPoints() external view returns (uint256);\\n\\n  /**\\n   * @dev distributeTaxTokens\\n   *\\n   * Allows the distribution of tax tokens to the designated recipient(s)\\n   *\\n   * As part of standard processing the tax token balance being above the threshold\\n   * will trigger an autoswap to ETH and distribution of this ETH to the designated\\n   * recipients. This is automatic and there is no need for user involvement.\\n   *\\n   * As part of this swap there are a number of calculations performed, particularly\\n   * if the tax balance is above MAX_SWAP_THRESHOLD_MULTIPLE.\\n   *\\n   * Testing indicates that these calculations are safe. But given the data / code\\n   * interactions it remains possible that some edge case set of scenarios may cause\\n   * an issue with these calculations.\\n   *\\n   * This method is therefore provided as a 'fallback' option to safely distribute\\n   * accumulated taxes from the contract, with a direct transfer of the ERC20 tokens\\n   * themselves.\\n   */\\n  function distributeTaxTokens() external;\\n\\n  /**\\n   * @dev function {withdrawETH} onlyOwner\\n   *\\n   * A withdraw function to allow ETH to be withdrawn by the manager\\n   *\\n   * This contract should never hold ETH. The only envisaged scenario where\\n   * it might hold ETH is a failed autoswap where the uniswap swap has completed,\\n   * the recipient of ETH reverts, the contract then wraps to WETH and the\\n   * wrap to WETH fails.\\n   *\\n   * This feels unlikely. But, for safety, we include this method.\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external;\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyOwner\\n   *\\n   * A withdraw function to allow ERC20s (except address(this)) to be withdrawn.\\n   *\\n   * This contract should never hold ERC20s other than tax tokens. The only envisaged\\n   * scenario where it might hold an ERC20 is a failed autoswap where the uniswap swap\\n   * has completed, the recipient of ETH reverts, the contract then wraps to WETH, the\\n   * wrap to WETH succeeds, BUT then the transfer of WETH fails.\\n   *\\n   * This feels even less likely than the scenario where ETH is held on the contract.\\n   * But, for safety, we include this method.\\n   *\\n   * @param token_ The ERC20 contract\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(address token_, uint256 amount_) external;\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 value) external;\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n   * the caller's allowance.\\n   *\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `value`.\\n   */\\n  function burnFrom(address account, uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20/IERC20ConfigByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IERC20ByMetadrop.sol. Interface for metadrop ERC20 standard\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IERC20ConfigByMetadrop {\\n  struct ERC20Config {\\n    bytes baseParameters;\\n    bytes supplyParameters;\\n    bytes taxParameters;\\n    bytes poolParameters;\\n  }\\n\\n  struct ERC20BaseParameters {\\n    string name;\\n    string symbol;\\n    bool addLiquidityOnCreate;\\n    bool usesDRIPool;\\n  }\\n\\n  struct ERC20SupplyParameters {\\n    uint256 maxSupply;\\n    uint256 lpSupply;\\n    uint256 projectSupply;\\n    uint256 maxTokensPerWallet;\\n    uint256 maxTokensPerTxn;\\n    uint256 lpLockupInDays;\\n    uint256 botProtectionDurationInSeconds;\\n    address projectSupplyRecipient;\\n    address projectLPOwner;\\n    bool burnLPTokens;\\n  }\\n\\n  struct ERC20TaxParameters {\\n    uint256 projectBuyTaxBasisPoints;\\n    uint256 projectSellTaxBasisPoints;\\n    uint256 taxSwapThresholdBasisPoints;\\n    uint256 metadropBuyTaxBasisPoints;\\n    uint256 metadropSellTaxBasisPoints;\\n    uint256 metadropTaxPeriodInDays;\\n    address projectTaxRecipient;\\n    address metadropTaxRecipient;\\n  }\\n\\n  struct ERC20PoolParameters {\\n    uint256 poolSupply;\\n    uint256 poolStartDate;\\n    uint256 poolEndDate;\\n    uint256 poolVestingInDays;\\n    uint256 poolMaxETH;\\n    uint256 poolPerAddressMaxETH;\\n    uint256 poolMinETH;\\n    uint256 poolPerTransactionMinETH;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Pools/ERC20DRIPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20ByMetadrop} from \\\"../ERC20/IERC20ByMetadrop.sol\\\";\\nimport {IERC20DRIPool} from \\\"./IERC20DRIPool.sol\\\";\\nimport {Revert} from \\\"../../Global/Revert.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../../Global/OZ/SafeERC20.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 Decentralised Rationalised Incentive Pool (DRIP)\\n *\\n * @dev Implementation of the {IERC20DRIPool} interface.\\n */\\ncontract ERC20DRIPool is ERC20, IERC20DRIPool, Revert {\\n  using SafeERC20 for IERC20ByMetadrop;\\n\\n  uint256 private constant ETH_TO_DRIP_MULTIPLIER = 1000000;\\n\\n  address private constant DEAD_ADDRESS =\\n    0x000000000000000000000000000000000000dEaD;\\n\\n  // Slot 1: accessed when contributing to the pool / claiming from the pool:\\n  //     32\\n  //     32\\n  //    128\\n  //     64\\n  // ------\\n  //    256\\n  // ------\\n  // When does the pool phase start? Contributions to the DRIP will not be accepted\\n  // before this date:\\n  uint32 public poolStartDate;\\n\\n  // When does the pool phase end? Contributions to the DRIP will not be accepted\\n  // after this date:\\n  uint32 public poolEndDate;\\n\\n  // What is the max contribution per address? If this is ZERO there is no no limits,\\n  // we'll reach for the sky\\n  uint128 public poolPerAddressMaxETH;\\n\\n  // What is the minimum contribution per transaction?:\\n  uint64 public poolPerTransactionMinETH;\\n\\n  // Slot 2: accessed when contributing to the pool:\\n  //    256\\n  // ------\\n  //    256\\n  // ------\\n\\n  // What is the max pooled ETH? Contributions that would exceed this amount will not\\n  // be accepted: If this is ZERO there is no no limits, won't give up the fight.\\n  uint256 public poolMaxETH;\\n\\n  // Slot 3: accessed when claiming from the pool:\\n  //    128\\n  //    128\\n  // ------\\n  //    256\\n  // ------\\n  // The supply of the pooled token in this pool (this is the token that pool participants\\n  // will claim, not the DRIP token):\\n  uint128 public supplyInThePool;\\n  // Store of the amount of ETH funded into LP:\\n  uint128 public lpFundedETH;\\n\\n  // Slot 4: accessed when claiming from the pool\\n  //     16\\n  //    160\\n  //     80\\n  // ------\\n  //    256\\n  // ------\\n  // If there is a vesting period for token claims this var will be that period\\n  // in DAYS:\\n  uint16 public poolVestingInDays;\\n\\n  // This is the contract address of the metadrop ERC20 that is being placed in this\\n  // pool:\\n  IERC20ByMetadrop public createdERC20;\\n\\n  // Minimum amount for the pool to proceed:\\n  uint80 public poolMinETH;\\n\\n  // Slot 5: accessed as part of claims / refunds\\n  //     96\\n  //    160\\n  // ------\\n  //    256\\n  // ------\\n  uint96 public projectSeedContributionETH;\\n  address public projectSeedContributionAddress;\\n\\n  // Slot 6: not accessed as part of any standard processing\\n  //      8\\n  // ------\\n  //      8\\n  // ------\\n  // Bool that controls initialisation and only allows it to occur ONCE. This is\\n  // needed as this contract is clonable, threfore the constructor is not called\\n  // on cloned instances. We setup state of this contract through the initialise\\n  // function.\\n  bool public initialised;\\n\\n  // Slot 7 to n:\\n  // ------\\n  //    256\\n  // ------\\n  string private _dripName;\\n  string private _dripSymbol;\\n\\n  /**\\n   * @dev constructor\\n   *\\n   * The constructor is not called when the contract is cloned.\\n   * In this we just set the template contract to initialised.\\n   */\\n  constructor() ERC20(\\\"Metadrop DRI Pool Token\\\", \\\"DRIP\\\") {\\n    initialised = true;\\n  }\\n\\n  /**\\n   * @dev {onlyDuringPoolPhase}\\n   *\\n   * Throws if NOT during the pool phase\\n   */\\n  modifier onlyDuringPoolPhase() {\\n    if (_poolPhaseStatus() != PhaseStatus.duringPoolPhase) {\\n      _revert(PoolPhaseIsClosed.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev {onlyAfterPoolPhase}\\n   *\\n   * Throws if NOT after the pool phase\\n   */\\n  modifier onlyAfterPoolPhase() {\\n    if (_poolPhaseStatus() != PhaseStatus.afterPoolPhase) {\\n      _revert(PoolPhaseIsNotAfter.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev {onlyWhenPoolIsAboveMinimum}\\n   *\\n   * Throws if the pool is not above the minimum\\n   */\\n  modifier onlyWhenPoolIsAboveMinimum() {\\n    if (!poolIsAboveMinimum()) {\\n      _revert(PoolIsBelowMinimum.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev {onlyWhenPoolIsBelowMinimum}\\n   *\\n   * Throws if the pool is not below the minimum\\n   */\\n  modifier onlyWhenPoolIsBelowMinimum() {\\n    if (poolIsAboveMinimum()) {\\n      _revert(PoolIsAboveMinimum.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev {onlyWithinLimits}\\n   *\\n   * Throws if this addition would exceed the cap\\n   */\\n  modifier onlyWithinLimits() {\\n    // Check the overall pool limit:\\n    if (poolMaxETH > 0 && (totalETHContributed() > poolMaxETH)) {\\n      _revert(AdditionToPoolWouldExceedPoolCap.selector);\\n    }\\n\\n    // Check the per address limit:\\n    if (\\n      poolPerAddressMaxETH > 0 &&\\n      (balanceOf(_msgSender()) + (msg.value * ETH_TO_DRIP_MULTIPLIER) >\\n        (poolPerAddressMaxETH * ETH_TO_DRIP_MULTIPLIER))\\n    ) {\\n      _revert(AdditionToPoolWouldExceedPerAddressCap.selector);\\n    }\\n\\n    // Check the contribution meets the minimium contribution size:\\n    if (msg.value < poolPerTransactionMinETH) {\\n      _revert(AdditionToPoolIsBelowPerTransactionMinimum.selector);\\n    }\\n\\n    _;\\n  }\\n\\n  /**\\n   * @dev {onlyWhenTokensVested}\\n   *\\n   * Throws if NOT after the token vesting date\\n   */\\n  modifier onlyWhenTokensVested() {\\n    if (block.timestamp < vestingEndDate()) {\\n      _revert(PoolVestingNotYetComplete.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view override returns (string memory) {\\n    return _dripName;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view override returns (string memory) {\\n    return _dripSymbol;\\n  }\\n\\n  /**\\n   * @dev {initialiseDRIP}\\n   *\\n   * Initalise configuration on a new minimal proxy clone\\n   *\\n   * @param poolParams_ bytes parameter object that will be decoded into configuration\\n   * items.\\n   * @param name_ the name of the associated ERC20 token\\n   * @param symbol_ the symbol of the associated ERC20 token\\n   */\\n  function initialiseDRIP(\\n    bytes calldata poolParams_,\\n    string calldata name_,\\n    string calldata symbol_\\n  ) external {\\n    if (initialised) {\\n      _revert(AlreadyInitialised.selector);\\n    }\\n\\n    initialised = true;\\n\\n    _dripName = string.concat(name_, \\\" - Metadrop Launch Pool Token\\\");\\n\\n    _dripSymbol = _getDripSymbol(symbol_);\\n\\n    ERC20PoolParameters memory poolParams = _validatePoolParams(poolParams_);\\n\\n    poolStartDate = uint32(poolParams.poolStartDate);\\n    poolEndDate = uint32(poolParams.poolEndDate);\\n    poolMaxETH = poolParams.poolMaxETH;\\n    poolMinETH = uint80(poolParams.poolMinETH);\\n    poolPerAddressMaxETH = uint128(poolParams.poolPerAddressMaxETH);\\n    poolVestingInDays = uint16(poolParams.poolVestingInDays);\\n    supplyInThePool = uint128(poolParams.poolSupply * (10 ** decimals()));\\n    poolPerTransactionMinETH = uint64(poolParams.poolPerTransactionMinETH);\\n  }\\n\\n  /**\\n   * @dev Get the drip symbol, being the first six chars of the token symbol + '-DRIP'\\n   * We get just the first six chars as metamask has a default limit of 11 chars per token\\n   * symbol. You can get around this by manually editing the symbol when adding the token,\\n   * but it seems prudent to avoid the user having to do this.\\n   *\\n   * @param erc20Symbol_ The symbol of the ERC20\\n   * @return dripSymbol_ the symbol of our DRIP token\\n   */\\n  function _getDripSymbol(\\n    string memory erc20Symbol_\\n  ) internal pure returns (string memory dripSymbol_) {\\n    bytes memory erc20SymbolBytes = bytes(erc20Symbol_);\\n\\n    if (erc20SymbolBytes.length < 6) {\\n      return string(abi.encodePacked(erc20SymbolBytes, \\\"-DRIP\\\"));\\n    } else {\\n      bytes memory result = new bytes(6);\\n      for (uint i = 0; i < 6; i++) {\\n        result[i] = erc20SymbolBytes[i];\\n      }\\n      return string(abi.encodePacked(result, \\\"-DRIP\\\"));\\n    }\\n  }\\n\\n  /**\\n   * @dev Decode and validate pool parameters\\n   *\\n   * @return poolParamsDecoded_ the decoded pool params\\n   */\\n  function _validatePoolParams(\\n    bytes calldata poolParams_\\n  ) internal pure returns (ERC20PoolParameters memory poolParamsDecoded_) {\\n    poolParamsDecoded_ = abi.decode(poolParams_, (ERC20PoolParameters));\\n\\n    if (poolParamsDecoded_.poolStartDate > type(uint32).max) {\\n      _revert(ParamTooLargeStartDate.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolEndDate > type(uint32).max) {\\n      _revert(ParamTooLargeEndDate.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolMinETH > type(uint80).max) {\\n      _revert(ParamTooLargeMinETH.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolPerAddressMaxETH > type(uint128).max) {\\n      _revert(ParamTooLargePerAddressMax.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolVestingInDays > type(uint16).max) {\\n      _revert(ParamTooLargeVestingDays.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolSupply > type(uint128).max) {\\n      _revert(ParamTooLargePoolSupply.selector);\\n    }\\n\\n    if (poolParamsDecoded_.poolPerTransactionMinETH > type(uint64).max) {\\n      _revert(ParamTooLargePoolPerTxnMinETH.selector);\\n    }\\n\\n    return (poolParamsDecoded_);\\n  }\\n\\n  /**\\n   * @dev {supplyForLP}\\n   *\\n   * Convenience function to return the LP supply from the ERC-20 token contract.\\n   *\\n   * @return supplyForLP_ The total supply for LP creation.\\n   */\\n  function supplyForLP() public view returns (uint256 supplyForLP_) {\\n    return (createdERC20.balanceOf(address(createdERC20)));\\n  }\\n\\n  /**\\n   * @dev {poolPhaseStatus}\\n   *\\n   * Convenience function to return the pool status in string format.\\n   *\\n   * @return poolPhaseStatus_ The pool phase status as a string\\n   */\\n  function poolPhaseStatus()\\n    external\\n    view\\n    returns (string memory poolPhaseStatus_)\\n  {\\n    // BEFORE the pool phase has started:\\n    if (_poolPhaseStatus() == PhaseStatus.beforePoolPhase) {\\n      return (\\\"before\\\");\\n    }\\n\\n    // AFTER the pool phase has ended:\\n    if (_poolPhaseStatus() == PhaseStatus.afterPoolPhase) {\\n      // IF successful\\n      if (poolIsAboveMinimum()) {\\n        return (\\\"succeeded\\\");\\n      }\\n      return (\\\"failed\\\");\\n    }\\n\\n    // DURING the pool phase:\\n    return (\\\"open\\\");\\n  }\\n\\n  /**\\n   * @dev {_poolPhaseStatus}\\n   *\\n   * Internal function to return the pool phase status as an enum\\n   *\\n   * @return poolPhaseStatus_ The pool phase status as an enum\\n   */\\n  function _poolPhaseStatus()\\n    internal\\n    view\\n    returns (PhaseStatus poolPhaseStatus_)\\n  {\\n    // BEFORE the pool phase has started:\\n    if (block.timestamp < poolStartDate) {\\n      return (PhaseStatus.beforePoolPhase);\\n    }\\n\\n    // AFTER the pool phase has ended:\\n    if (block.timestamp >= poolEndDate) {\\n      return (PhaseStatus.afterPoolPhase);\\n    }\\n\\n    // DURING the pool phase:\\n    return (PhaseStatus.duringPoolPhase);\\n  }\\n\\n  /**\\n   * @dev {vestingEndDate}\\n   *\\n   * The vesting end date, being the end of the pool phase plus number of days vesting, if any\\n   *\\n   * @return vestingEndDate_ The vesting end date as a timestamp\\n   */\\n  function vestingEndDate() public view returns (uint256 vestingEndDate_) {\\n    return (poolEndDate + (poolVestingInDays * 1 days));\\n  }\\n\\n  /**\\n   * @dev Return if the pool total has exceeded the minimum:\\n   *\\n   * @return poolIsAboveMinimum_ If the pool is above the minimum (or not)\\n   */\\n  function poolIsAboveMinimum() public view returns (bool poolIsAboveMinimum_) {\\n    return totalETHContributed() >= poolMinETH;\\n  }\\n\\n  /**\\n   * @dev Return if the pool is at the maximum.\\n   *\\n   * @return poolIsAtMaximum_ If the pool is at the maximum ETH.\\n   */\\n  function poolIsAtMaximum() public view returns (bool poolIsAtMaximum_) {\\n    return totalETHContributed() == poolMaxETH;\\n  }\\n\\n  /**\\n   * @dev Return the total ETH pooled (whether in the balance of this contract\\n   * or supplied as LP already).\\n   *\\n   * Note that this INCLUDES any seed ETH from the project on create.\\n   *\\n   * @return totalETHPooled_ the total ETH pooled in this contract\\n   */\\n  function totalETHPooled() public view returns (uint256 totalETHPooled_) {\\n    return address(this).balance + lpFundedETH;\\n  }\\n\\n  /**\\n   * @dev Return the total ETH contributed (whether in the balance of this contract\\n   * or supplied as LP already).\\n   *\\n   * Note that this EXCLUDES any seed ETH from the project on create.\\n   *\\n   * @return totalETHContributed_ the total ETH pooled in this contract\\n   */\\n  function totalETHContributed()\\n    public\\n    view\\n    returns (uint256 totalETHContributed_)\\n  {\\n    return totalETHPooled() - projectSeedContributionETH;\\n  }\\n\\n  /**\\n   * @dev {loadERC20AddressAndSeedETH}\\n   *\\n   * Load the target ERC-20 address. This is called by the factory in the same transaction as the clone\\n   * is instantiated\\n   *\\n   * @param createdERC20_ The ERC-20 address\\n   * @param poolCreator_ The creator of this pool\\n   */\\n  function loadERC20AddressAndSeedETH(\\n    address createdERC20_,\\n    address poolCreator_\\n  ) external payable {\\n    if (address(createdERC20) != address(0)) {\\n      _revert(AddressAlreadySet.selector);\\n    }\\n\\n    // If there is ETH on this call then it is the ETH amount that the project team\\n    // is seeding into the pool. This seed amount does NOT mint DRIP token to the team,\\n    // as will be the case with any contributions to an open pool. It will be included in\\n    // the ETH paired with the token when the pool closes, if it closes above the minimum\\n    // contribution threshold.\\n    //\\n    // In the event that the pool closes below the minimum contribution threshold the project\\n    // team will be able to claim a refund of the seeded amount, in just the same way\\n    // that contributors can get a refund of ETH when the pool closes below the minimum.\\n\\n    if (msg.value > 0) {\\n      if (msg.value > type(uint96).max) {\\n        _revert(ValueExceedsMaximum.selector);\\n      }\\n      projectSeedContributionETH = uint96(msg.value);\\n      projectSeedContributionAddress = poolCreator_;\\n    }\\n    createdERC20 = IERC20ByMetadrop(createdERC20_);\\n  }\\n\\n  /**\\n   * @dev {addToPool}\\n   *\\n   * A user calls this to contribute to the pool\\n   *\\n   * Note that we could have used the receive method for this, and processed any ETH send to the\\n   * contract as a contribution to the pool. We've opted for the clarity of a specific method,\\n   * with the recieve method reverting an unidentified ETH.\\n   */\\n  function addToPool() external payable onlyDuringPoolPhase onlyWithinLimits {\\n    _mint(_msgSender(), (msg.value * ETH_TO_DRIP_MULTIPLIER));\\n\\n    if (poolIsAtMaximum()) {\\n      poolEndDate = uint32(block.timestamp);\\n    }\\n\\n    // Emit the event:\\n    emit AddToPool(_msgSender(), msg.value);\\n  }\\n\\n  /**\\n   * @dev {claimFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim their ERC-20 tokens\\n   *\\n   */\\n  function claimFromPool()\\n    external\\n    onlyWhenPoolIsAboveMinimum\\n    onlyWhenTokensVested\\n  {\\n    uint256 holdersDRIP = balanceOf(_msgSender());\\n\\n    // Calculate the holders share of the pooled token:\\n    uint256 holdersClaim = ((supplyInThePool * holdersDRIP) / totalSupply());\\n\\n    // If they are getting no tokens, there is nothing to do here:\\n    if (holdersClaim == 0) {\\n      _revert(NothingToClaim.selector);\\n    }\\n\\n    // Burn the holders DRIP to the dead address. We do this so that the totalSupply()\\n    // figure remains constant allowing us to calculate subsequent shares of the total\\n    // ERC20 pool\\n    _burnToDead(_msgSender(), holdersDRIP);\\n\\n    // Send them their createdERC20 token:\\n    createdERC20.safeTransfer(_msgSender(), holdersClaim);\\n\\n    // Emit the event:\\n    emit ClaimFromPool(_msgSender(), holdersDRIP, holdersClaim);\\n  }\\n\\n  /**\\n   */\\n  function _burnToDead(address caller_, uint256 callersDRIP_) internal {\\n    _transfer(caller_, DEAD_ADDRESS, callersDRIP_);\\n  }\\n\\n  /**\\n   * @dev {refundFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim an ETH refund where the\\n   * minimum ETH pooled amount was not exceeded\\n   *\\n   */\\n  function refundFromPool()\\n    external\\n    onlyAfterPoolPhase\\n    onlyWhenPoolIsBelowMinimum\\n  {\\n    // This was looks for standard contributions based on balance of DRIP:\\n    uint256 holdersDRIP = balanceOf(_msgSender());\\n\\n    // Calculate the holders share of the pooled ETH.\\n    uint256 refundAmount = holdersDRIP / ETH_TO_DRIP_MULTIPLIER;\\n\\n    // Add on the project seed ETH amount if relevant:\\n    if (_msgSender() == projectSeedContributionAddress) {\\n      // This was a project seed contribution. We include the project seed ETH in any\\n      // refund to this address. We combine this with any refund they are owed\\n      // for a DRIP balance as it is possible (although unlikely) that the seed\\n      // contributor also made a standard contribution to the launch pool and minted\\n      // DRIP.\\n\\n      // Add the seed ETH contribution to the refund amount:\\n      refundAmount += projectSeedContributionETH;\\n\\n      // Zero out the contribution as this is being refunded:\\n      projectSeedContributionETH = 0;\\n    }\\n\\n    // If they are getting no ETH, there is nothing to do here:\\n    if (refundAmount == 0) {\\n      _revert(NothingToClaim.selector);\\n    }\\n\\n    // Burn tokens if the holder's DRIP is greater than 0. We need this check for zero\\n    // here as this could be a seed ETH refund:\\n    if (holdersDRIP > 0) {\\n      // Burn the holders DRIP to the dead address. We do this so that the totalSupply()\\n      // figure remains constant allowing us to calculate subsequent shares of the total\\n      // ERC20 pool\\n      _burnToDead(_msgSender(), holdersDRIP);\\n    }\\n\\n    // Send them their ETH refund\\n    (bool success, ) = _msgSender().call{value: refundAmount}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n\\n    // Emit the event:\\n    emit RefundFromPool(_msgSender(), holdersDRIP, refundAmount);\\n  }\\n\\n  /**\\n   * @dev {supplyLiquidity}\\n   *\\n   * When the pool phase is over this can be called to supply the pooled ETH to\\n   * the token contract. There it will be forwarded along with the LP supply of\\n   * tokens to uniswap to create the funded pair\\n   *\\n   * Note that this function can be called by anyone. While clearly it is likely\\n   * that this will be the project team, having this method open to anyone ensures that\\n   * liquidity will not be trapped in this contract if the team as unable to perform\\n   * this action.\\n   *\\n   * @param lockerFee_ The ETH fee required to lock LP tokens\\n   *\\n   */\\n  function supplyLiquidity(\\n    uint256 lockerFee_\\n  ) external payable onlyAfterPoolPhase onlyWhenPoolIsAboveMinimum {\\n    // The caller can elect to send the locker fee with this call, or the locker\\n    // fee will automatically taken from the supplied ETH. In either scenario the only\\n    // acceptable values that can be passed to this method are a) 0 or b) the locker fee\\n    if (msg.value > 0 && msg.value != lockerFee_) {\\n      _revert(IncorrectPayment.selector);\\n    }\\n\\n    // We store the pooledETH for future reference. After funding liquidity this pool\\n    // will hold no ETH\\n    uint256 contractBalance = address(this).balance;\\n    uint256 pooledETH = contractBalance;\\n\\n    // If the locker fee was passed in it is in the balance of this contract, BUT is\\n    // not contributed ETH. Deduct this from the stored total:\\n    if (msg.value == lockerFee_) {\\n      pooledETH -= lockerFee_;\\n    }\\n\\n    lpFundedETH = uint128(pooledETH);\\n\\n    createdERC20.addInitialLiquidity{value: contractBalance}(\\n      lockerFee_,\\n      0,\\n      false\\n    );\\n\\n    // Emit the event:\\n    emit LiquidityAddedFromPool(pooledETH, supplyForLP());\\n  }\\n\\n  /**\\n   * @dev {receive}\\n   *\\n   * Revert any unidentified ETH\\n   *\\n   */\\n  receive() external payable {\\n    revert();\\n  }\\n\\n  /**\\n   * @dev {fallback}\\n   *\\n   * No fallback allowed\\n   *\\n   */\\n  fallback() external payable {\\n    revert();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Pools/IERC20DRIPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {IERC20ConfigByMetadrop} from \\\"../ERC20/IERC20ConfigByMetadrop.sol\\\";\\nimport {IErrors} from \\\"../../Global/IErrors.sol\\\";\\n\\ninterface IERC20DRIPool is IERC20ConfigByMetadrop, IErrors {\\n  enum PhaseStatus {\\n    beforePoolPhase,\\n    duringPoolPhase,\\n    afterPoolPhase\\n  }\\n\\n  event AddToPool(address dripHolder, uint256 dripTokenMinted);\\n\\n  event ClaimFromPool(\\n    address dripHolder,\\n    uint256 dripTokenBurned,\\n    uint256 pooledTokenClaimed\\n  );\\n\\n  event RefundFromPool(\\n    address dripHolder,\\n    uint256 dripTokenBurned,\\n    uint256 ethRefunded\\n  );\\n\\n  event LiquidityAddedFromPool(uint256 ethTotal, uint256 tokenTotal);\\n\\n  /**\\n   * @dev {initialiseDRIP}\\n   *\\n   * Initalise configuration on a new minimal proxy clone\\n   *\\n   * @param poolParams_ bytes parameter object that will be decoded into configuration\\n   * items.\\n   * @param name_ the name of the associated ERC20 token\\n   * @param symbol_ the symbol of the associated ERC20 token\\n   */\\n  function initialiseDRIP(\\n    bytes calldata poolParams_,\\n    string calldata name_,\\n    string calldata symbol_\\n  ) external;\\n\\n  /**\\n   * @dev {supplyForLP}\\n   *\\n   * Convenience function to return the LP supply from the ERC-20 token contract.\\n   *\\n   * @return supplyForLP_ The total supply for LP creation.\\n   */\\n  function supplyForLP() external view returns (uint256 supplyForLP_);\\n\\n  /**\\n   * @dev {poolPhaseStatus}\\n   *\\n   * Convenience function to return the pool status in string format.\\n   *\\n   * @return poolPhaseStatus_ The pool phase status as a string\\n   */\\n  function poolPhaseStatus()\\n    external\\n    view\\n    returns (string memory poolPhaseStatus_);\\n\\n  /**\\n   * @dev {vestingEndDate}\\n   *\\n   * The vesting end date, being the end of the pool phase plus number of days vesting, if any\\n   *\\n   * @return vestingEndDate_ The vesting end date as a timestamp\\n   */\\n  function vestingEndDate() external view returns (uint256 vestingEndDate_);\\n\\n  /**\\n   * @dev Return if the pool total has exceeded the minimum:\\n   *\\n   * @return poolIsAboveMinimum_ If the pool is above the minimum (or not)\\n   */\\n  function poolIsAboveMinimum()\\n    external\\n    view\\n    returns (bool poolIsAboveMinimum_);\\n\\n  /**\\n   * @dev {loadERC20AddressAndSeedETH}\\n   *\\n   * Load the target ERC-20 address. This is called by the factory in the same transaction as the clone\\n   * is instantiated\\n   *\\n   * @param createdERC20_ The ERC-20 address\\n   * @param poolCreator_ The creator of this pool\\n   */\\n  function loadERC20AddressAndSeedETH(\\n    address createdERC20_,\\n    address poolCreator_\\n  ) external payable;\\n\\n  /**\\n   * @dev {addToPool}\\n   *\\n   * A user calls this to contribute to the pool\\n   *\\n   * Note that we could have used the receive method for this, and processed any ETH send to the\\n   * contract as a contribution to the pool. We've opted for the clarity of a specific method,\\n   * with the recieve method reverting an unidentified ETH.\\n   */\\n  function addToPool() external payable;\\n\\n  /**\\n   * @dev {claimFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim their ERC-20 tokens\\n   *\\n   */\\n  function claimFromPool() external;\\n\\n  /**\\n   * @dev {refundFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim an ETH refund where the\\n   * minimum ETH pooled amount was not exceeded\\n   *\\n   */\\n  function refundFromPool() external;\\n\\n  /**\\n   * @dev {supplyLiquidity}\\n   *\\n   * When the pool phase is over this can be called to supply the pooled ETH to\\n   * the token contract. There it will be forwarded along with the LP supply of\\n   * tokens to uniswap to create the funded pair\\n   *\\n   * Note that this function can be called by anyone. While clearly it is likely\\n   * that this will be the project team, having this method open to anyone ensures that\\n   * liquidity will not be trapped in this contract if the team as unable to perform\\n   * this action.\\n   *\\n   * @param lockerFee_ The ETH fee required to lock LP tokens\\n   *\\n   */\\n  function supplyLiquidity(uint256 lockerFee_) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IConfigStructures.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IConfigStructures.sol. Interface for common config structures used accross the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IConfigStructures {\\n  enum DropStatus {\\n    approved,\\n    deployed,\\n    cancelled\\n  }\\n\\n  enum TemplateStatus {\\n    live,\\n    terminated\\n  }\\n\\n  // The current status of the mint:\\n  //   - notEnabled: This type of mint is not part of this drop\\n  //   - notYetOpen: This type of mint is part of the drop, but it hasn't started yet\\n  //   - open: it's ready for ya, get in there.\\n  //   - finished: been and gone.\\n  //   - unknown: theoretically impossible.\\n  enum MintStatus {\\n    notEnabled,\\n    notYetOpen,\\n    open,\\n    finished,\\n    unknown\\n  }\\n\\n  struct SubListConfig {\\n    uint256 start;\\n    uint256 end;\\n    uint256 phaseMaxSupply;\\n  }\\n\\n  struct PrimarySaleModuleInstance {\\n    address instanceAddress;\\n    string instanceDescription;\\n  }\\n\\n  struct NFTModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n    bytes vestingData;\\n  }\\n\\n  struct PrimarySaleModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct ProjectBeneficiary {\\n    address payable payeeAddress;\\n    uint256 payeeShares;\\n  }\\n\\n  struct VestingConfig {\\n    uint256 start;\\n    uint256 projectUpFrontShare;\\n    uint256 projectVestedShare;\\n    uint256 vestingPeriodInDays;\\n    uint256 vestingCliff;\\n    ProjectBeneficiary[] projectPayees;\\n  }\\n\\n  struct RoyaltySplitterModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModules {\\n    InLifeModuleConfig[] modules;\\n  }\\n\\n  struct NFTConfig {\\n    uint256 supply;\\n    string name;\\n    string symbol;\\n    bytes32 positionProof;\\n    bool includePriorPhasesInMintTracking;\\n    bool singleMetadataCollection;\\n    uint256 reservedAllocation;\\n    uint256 assistanceRequestWindowInSeconds;\\n  }\\n\\n  struct Template {\\n    TemplateStatus status;\\n    uint16 templateNumber;\\n    uint32 loadedDate;\\n    address payable templateAddress;\\n    string templateDescription;\\n  }\\n\\n  struct RoyaltyDetails {\\n    address newRoyaltyPaymentSplitterInstance;\\n    uint96 royaltyFromSalesInBasisPoints;\\n  }\\n\\n  struct SignedDropMessageDetails {\\n    uint256 messageTimeStamp;\\n    bytes32 messageHash;\\n    bytes messageSignature;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IErrors.sol. Interface for error definitions used across the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IErrors {\\n  enum BondingCurveErrorType {\\n    OK, //                                                  No error\\n    INVALID_NUMITEMS, //                                    The numItem value is 0\\n    SPOT_PRICE_OVERFLOW //                                  The updated spot price doesn't fit into 128 bits\\n  }\\n\\n  error AdapterParamsMustBeEmpty(); //                      The adapter parameters on this LZ call must be empty.\\n\\n  error AdditionToPoolIsBelowPerTransactionMinimum(); //    The contribution amount is less than the minimum.\\n\\n  error AdditionToPoolWouldExceedPoolCap(); //              This addition to the pool would exceed the pool cap.\\n\\n  error AdditionToPoolWouldExceedPerAddressCap(); //        This addition to the pool would exceed the per address cap.\\n\\n  error AddressAlreadySet(); //                             The address being set can only be set once, and is already non-0.\\n\\n  error AllowanceDecreasedBelowZero(); //                   You cannot decrease the allowance below zero.\\n\\n  error AlreadyInitialised(); //                            The contract is already initialised: it cannot be initialised twice!\\n\\n  error ApprovalCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error ApproveFromTheZeroAddress(); //                     Approval cannot be called from the zero address (indeed, how have you??).\\n\\n  error ApproveToTheZeroAddress(); //                       Approval cannot be given to the zero address.\\n\\n  error ApprovalQueryForNonexistentToken(); //              The token does not exist.\\n\\n  error AuctionStatusIsNotEnded(); //                       Throw if the action required the auction to be closed, and it isn't.\\n\\n  error AuctionStatusIsNotOpen(); //                        Throw if the action requires the auction to be open, and it isn't.\\n\\n  error AuxCallFailed(\\n    address[] modules,\\n    uint256 value,\\n    bytes data,\\n    uint256 txGas\\n  ); //                                                     An auxilliary call from the drop factory failed.\\n\\n  error BalanceMismatch(); //                               An error when comparing balance amounts.\\n\\n  error BalanceQueryForZeroAddress(); //                    Cannot query the balance for the zero address.\\n\\n  error BidMustBeBelowTheFloorWhenReducingQuantity(); //    Only bids that are below the floor can reduce the quantity of the bid.\\n\\n  error BidMustBeBelowTheFloorForRefundDuringAuction(); //  Only bids that are below the floor can be refunded during the auction.\\n\\n  error BondingCurveError(BondingCurveErrorType error); //  An error of the type specified has occured in bonding curve processing.\\n\\n  error BurnExceedsBalance(); //                            The amount you have selected to burn exceeds the addresses balance.\\n\\n  error BurnFromTheZeroAddress(); //                        Tokens cannot be burned from the zero address. (Also, how have you called this!?!)\\n\\n  error CallerIsNotDepositBoxOwner(); //                    The caller is not the owner of the deposit box.\\n\\n  error CallerIsNotFactory(); //                            The caller of this function must match the factory address in storage.\\n\\n  error CallerIsNotFactoryOrProjectOwner(); //              The caller of this function must match the factory address OR project owner address.\\n\\n  error CallerIsNotFactoryProjectOwnerOrPool(); //          The caller of this function must match the factory address, project owner or pool address.\\n\\n  error CallerIsNotTheOwner(); //                           The caller is not the owner of this contract.\\n\\n  error CallerIsNotTheManager(); //                         The caller is not the manager of this contract.\\n\\n  error CallerMustBeLzApp(); //                             The caller must be an LZ application.\\n\\n  error CallerIsNotPlatformAdmin(address caller); //        The caller of this function must be part of the platformAdmin group.\\n\\n  error CallerIsNotSuperAdmin(address caller); //           The caller of this function must match the superAdmin address in storage.\\n\\n  error CannotAddLiquidityOnCreateAndUseDRIPool(); //       Cannot use both liquidity added on create and a DRIPool in the same token.\\n\\n  error CannotSetNewOwnerToTheZeroAddress(); //             You can't set the owner of this contract to the zero address (address(0)).\\n\\n  error CannotSetToZeroAddress(); //                        The corresponding address cannot be set to the zero address (address(0)).\\n\\n  error CannotSetNewManagerToTheZeroAddress(); //           Cannot transfer the manager to the zero address (address(0)).\\n\\n  error CannotWithdrawThisToken(); //                       Cannot withdraw the specified token.\\n\\n  error CanOnlyReduce(); //                                 The given operation can only reduce the value specified.\\n\\n  error CollectionAlreadyRevealed(); //                     The collection is already revealed; you cannot call reveal again.\\n\\n  error ContractIsDecommissioned(); //                      This contract is decommissioned!\\n\\n  error ContractIsPaused(); //                              The call requires the contract to be unpaused, and it is paused.\\n\\n  error ContractIsNotPaused(); //                           The call required the contract to be paused, and it is NOT paused.\\n\\n  error DecreasedAllowanceBelowZero(); //                   The request would decrease the allowance below zero, and that is not allowed.\\n\\n  error DestinationIsNotTrustedSource(); //                 The destination that is being called through LZ has not been set as trusted.\\n\\n  error DeployerOnly(); //                                  This method can only be called by the deployer address.\\n\\n  error DeploymentError(); //                               Error on deployment.\\n\\n  error DepositBoxIsNotOpen(); //                           This action cannot complete as the deposit box is not open.\\n\\n  error DriPoolAddressCannotBeAddressZero(); //             The Dri Pool address cannot be the zero address.\\n\\n  error GasLimitIsTooLow(); //                              The gas limit for the LayerZero call is too low.\\n\\n  error IncorrectConfirmationValue(); //                    You need to enter the right confirmation value to call this funtion (usually 69420).\\n\\n  error IncorrectPayment(); //                              The function call did not include passing the correct payment.\\n\\n  error InitialLiquidityAlreadyAdded(); //                  Initial liquidity has already been added. You can't do it again.\\n\\n  error InitialLiquidityNotYetAdded(); //                   Initial liquidity needs to have been added for this to succedd.\\n\\n  error InsufficientAllowance(); //                         There is not a high enough allowance for this operation.\\n\\n  error InvalidAdapterParams(); //                          The current adapter params for LayerZero on this contract won't work :(.\\n\\n  error InvalidAddress(); //                                An address being processed in the function is not valid.\\n\\n  error InvalidEndpointCaller(); //                         The calling address is not a valid LZ endpoint. The LZ endpoint was set at contract creation\\n  //                                                        and cannot be altered after. Check the address LZ endpoint address on the contract.\\n\\n  error InvalidMinGas(); //                                 The minimum gas setting for LZ in invalid.\\n\\n  error InvalidOracleSignature(); //                        The signature provided with the contract call is not valid, either in format or signer.\\n\\n  error InvalidPayload(); //                                The LZ payload is invalid\\n\\n  error InvalidReceiver(); //                               The address used as a target for funds is not valid.\\n\\n  error InvalidSourceSendingContract(); //                  The LZ message is being related from a source contract on another chain that is NOT trusted.\\n\\n  error InvalidTotalShares(); //                            Total shares must equal 100 percent in basis points.\\n\\n  error LimitsCanOnlyBeRaised(); //                          Limits are UP ONLY.\\n\\n  error ListLengthMismatch(); //                            Two or more lists were compared and they did not match length.\\n\\n  error LiquidityPoolMustBeAContractAddress(); //           Cannot add a non-contract as a liquidity pool.\\n\\n  error LiquidityPoolCannotBeAddressZero(); //              Cannot add a liquidity pool from the zero address.\\n\\n  error LPLockUpMustFitUint88(); //                         LP lockup is held in a uint88, so must fit.\\n\\n  error NoTrustedPathRecord(); //                           LZ needs a trusted path record for this to work. What's that, you ask?\\n\\n  error MachineAddressCannotBeAddressZero(); //             Cannot set the machine address to the zero address.\\n\\n  error ManagerUnauthorizedAccount(); //                    The caller is not the pending manager.\\n\\n  error MaxBidQuantityIs255(); //                           Validation: as we use a uint8 array to track bid positions the max bid quantity is 255.\\n\\n  error MaxPublicMintAllowanceExceeded(\\n    uint256 requested,\\n    uint256 alreadyMinted,\\n    uint256 maxAllowance\\n  ); //                                                     The calling address has requested a quantity that would exceed the max allowance.\\n\\n  error MaxSupplyTooHigh(); //                              Max supply must fit in a uint128.\\n\\n  error MaxTokensPerWalletExceeded(); //                    The transfer would exceed the max tokens per wallet limit.\\n\\n  error MaxTokensPerTxnExceeded(); //                       The transfer would exceed the max tokens per transaction limit.\\n\\n  error MetadataIsLocked(); //                              The metadata on this contract is locked; it cannot be altered!\\n\\n  error MetadropFactoryOnlyOncePerReveal(); //              This function can only be called (a) by the factory and, (b) just one time!\\n\\n  error MetadropModulesOnly(); //                           Can only be called from a metadrop contract.\\n\\n  error MetadropOracleCannotBeAddressZero(); //             The metadrop Oracle cannot be the zero address (address(0)).\\n\\n  error MinGasLimitNotSet(); //                             The minimum gas limit for LayerZero has not been set.\\n\\n  error MintERC2309QuantityExceedsLimit(); //               The `quantity` minted with ERC2309 exceeds the safety limit.\\n\\n  error MintingIsClosedForever(); //                        Minting is, as the error suggests, so over (and locked forever).\\n\\n  error MintToZeroAddress(); //                             Cannot mint to the zero address.\\n\\n  error MintZeroQuantity(); //                              The quantity of tokens minted must be more than zero.\\n\\n  error NewBuyTaxBasisPointsExceedsMaximum(); //            Project owner trying to set the tax rate too high.\\n\\n  error NewSellTaxBasisPointsExceedsMaximum(); //           Project owner trying to set the tax rate too high.\\n\\n  error NoETHForLiquidityPair(); //                         No ETH has been provided for the liquidity pair.\\n\\n  error TaxPeriodStillInForce(); //                         The minimum tax period has not yet expired.\\n\\n  error NoPaymentDue(); //                                  No payment is due for this address.\\n\\n  error NoRefundForCaller(); //                             Error thrown when the calling address has no refund owed.\\n\\n  error NoStoredMessage(); //                               There is no stored message matching the passed parameters.\\n\\n  error NothingToClaim(); //                                The calling address has nothing to claim.\\n\\n  error NoTokenForLiquidityPair(); //                       There is no token to add to the LP.\\n\\n  error OperationDidNotSucceed(); //                        The operation failed (vague much?).\\n\\n  error OracleSignatureHasExpired(); //                     A signature has been provided but it is too old.\\n\\n  error OwnableUnauthorizedAccount(); //                    The caller is not the pending owner.\\n\\n  error OwnershipNotInitializedForExtraData(); //           The `extraData` cannot be set on an uninitialized ownership slot.\\n\\n  error OwnerQueryForNonexistentToken(); //                 The token does not exist.\\n\\n  error ParametersDoNotMatchSignedMessage(); //             The parameters passed with the signed message do not match the message itself.\\n\\n  error ParamTooLargeStartDate(); //                        The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeEndDate(); //                          The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeMinETH(); //                           The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePerAddressMax(); //                    The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeVestingDays(); //                      The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePoolSupply(); //                       The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePoolPerTxnMinETH(); //                 The passed parameter exceeds the var type max.\\n\\n  error PassedConfigDoesNotMatchApproved(); //              The config provided on the call does not match the approved config.\\n\\n  error PauseCutOffHasPassed(); //                          The time period in which we can pause has passed; this contract can no longer be paused.\\n\\n  error PaymentMustCoverPerMintFee(); //                    The payment passed must at least cover the per mint fee for the quantity requested.\\n\\n  error PermitDidNotSucceed(); //                           The safeERC20 permit failed.\\n\\n  error PlatformAdminCannotBeAddressZero(); //              We cannot use the zero address (address(0)) as a platformAdmin.\\n\\n  error PlatformTreasuryCannotBeAddressZero(); //           The treasury address cannot be set to the zero address.\\n\\n  error PoolIsAboveMinimum(); //                            You required the pool to be below the minimum, and it is not\\n\\n  error PoolIsBelowMinimum(); //                            You required the pool to be above the minimum, and it is not\\n\\n  error PoolPhaseIsClosed(); //                             The block.timestamp is either before the pool is open or after it is closed.\\n\\n  error PoolPhaseIsNotAfter(); //                           The block.timestamp is either before or during the pool open phase.\\n\\n  error PoolVestingNotYetComplete(); //                     Tokens in the pool are not yet vested.\\n\\n  error ProjectOwnerCannotBeAddressZero(); //               The project owner has to be a non zero address.\\n\\n  error ProofInvalid(); //                                  The provided proof is not valid with the provided arguments.\\n\\n  error QuantityExceedsRemainingCollectionSupply(); //      The requested quantity would breach the collection supply.\\n\\n  error QuantityExceedsRemainingPhaseSupply(); //           The requested quantity would breach the phase supply.\\n\\n  error QuantityExceedsMaxPossibleCollectionSupply(); //    The requested quantity would breach the maximum trackable supply\\n\\n  error ReferralIdAlreadyUsed(); //                         This referral ID has already been used; they are one use only.\\n\\n  error RequestingMoreThanAvailableBalance(); //             The request exceeds the available balance.\\n\\n  error RequestingMoreThanRemainingAllocation(\\n    uint256 previouslyMinted,\\n    uint256 requested,\\n    uint256 remainingAllocation\\n  ); //                                                     Number of tokens requested for this mint exceeds the remaining allocation (taking the\\n  //                                                        original allocation from the list and deducting minted tokens).\\n\\n  error RoyaltyFeeWillExceedSalePrice(); //                 The ERC2981 royalty specified will exceed the sale price.\\n\\n  error ShareTotalCannotBeZero(); //                        The total of all the shares cannot be nothing.\\n\\n  error SliceOutOfBounds(); //                              The bytes slice operation was out of bounds.\\n\\n  error SliceOverflow(); //                                 The bytes slice operation overlowed.\\n\\n  error SuperAdminCannotBeAddressZero(); //                 The superAdmin cannot be the sero address (address(0)).\\n\\n  error SupplyTotalMismatch(); //                           The sum of the team supply and lp supply does not match.\\n\\n  error SupportWindowIsNotOpen(); //                        The project owner has not requested support within the support request expiry window.\\n\\n  error TaxFreeAddressCannotBeAddressZero(); //             A tax free address cannot be address(0)\\n\\n  error TemplateCannotBeAddressZero(); //                   The address for a template cannot be address zero (address(0)).\\n\\n  error TemplateNotFound(); //                              There is no template that matches the passed template Id.\\n\\n  error ThisMintIsClosed(); //                              It's over (well, this mint is, anyway).\\n\\n  error TotalSharesMustMatchDenominator(); //               The total of all shares must equal the denominator value.\\n\\n  error TransferAmountExceedsBalance(); //                  The transfer amount exceeds the accounts available balance.\\n\\n  error TransferCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error TransferFailed(); //                                The transfer has failed.\\n\\n  error TransferFromIncorrectOwner(); //                    The token must be owned by `from`.\\n\\n  error TransferToNonERC721ReceiverImplementer(); //        Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n\\n  error TransferFromZeroAddress(); //                       Cannot transfer from the zero address. Indeed, this surely is impossible, and likely a waste to check??\\n\\n  error TransferToZeroAddress(); //                         Cannot transfer to the zero address.\\n\\n  error UnrecognisedVRFMode(); //                           Currently supported VRF modes are 0: chainlink and 1: arrng\\n\\n  error URIQueryForNonexistentToken(); //                   The token does not exist.\\n\\n  error ValueExceedsMaximum(); //                           The value sent exceeds the maximum allowed (super useful explanation huh?).\\n\\n  error VRFCoordinatorCannotBeAddressZero(); //             The VRF coordinator cannot be the zero address (address(0)).\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IErrors} from \\\"../IErrors.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n  }\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n   * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeCall(token.transferFrom, (from, to, value))\\n    );\\n  }\\n\\n  /**\\n   * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    forceApprove(token, spender, oldAllowance + value);\\n  }\\n\\n  /**\\n   * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      if (oldAllowance < value) {\\n        revert IErrors.DecreasedAllowanceBelowZero();\\n      }\\n      forceApprove(token, spender, oldAllowance - value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n   * 0 before setting it to a non-zero value.\\n   */\\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n    bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n    if (!_callOptionalReturnBool(token, approvalCall)) {\\n      _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n      _callOptionalReturn(token, approvalCall);\\n    }\\n  }\\n\\n  /**\\n   * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n   * Revert on invalid signature.\\n   */\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    if (nonceAfter != (nonceBefore + 1)) {\\n      revert IErrors.PermitDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"call fail\\\");\\n    if ((returndata.length != 0) && !abi.decode(returndata, (bool))) {\\n      revert IErrors.OperationDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   *\\n   * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n   */\\n  function _callOptionalReturnBool(\\n    IERC20 token,\\n    bytes memory data\\n  ) private returns (bool) {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n    // and not revert is the subcall reverts.\\n\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    return\\n      success &&\\n      (returndata.length == 0 || abi.decode(returndata, (bool))) &&\\n      address(token).code.length > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title Revert.sol. For efficient reverts\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\nabstract contract Revert {\\n  /**\\n   * @dev For more efficient reverts.\\n   */\\n  function _revert(bytes4 errorSelector) internal pure {\\n    assembly {\\n      mstore(0x00, errorSelector)\\n      revert(0x00, 0x04)\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdapterParamsMustBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolIsBelowPerTransactionMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolWouldExceedPerAddressCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolWouldExceedPoolCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceDecreasedBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotOpen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"AuxCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorForRefundDuringAuction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorWhenReducingQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum IErrors.BondingCurveErrorType\",\"name\":\"error\",\"type\":\"uint8\"}],\"name\":\"BondingCurveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotDepositBoxOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactoryOrProjectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactoryProjectOwnerOrPool\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotPlatformAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotSuperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerMustBeLzApp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CanOnlyReduce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotAddLiquidityOnCreateAndUseDRIPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewManagerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewOwnerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotWithdrawThisToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionAlreadyRevealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsDecommissioned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DecreasedAllowanceBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeploymentError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositBoxIsNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestinationIsNotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DriPoolAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitIsTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectConfirmationValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialLiquidityAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialLiquidityNotYetAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdapterParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOracleSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayload\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSourceSendingContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LPLockUpMustFitUint88\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitsCanOnlyBeRaised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolMustBeAContractAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MachineAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ManagerUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxBidQuantityIs255\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowance\",\"type\":\"uint256\"}],\"name\":\"MaxPublicMintAllowanceExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerTxnExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerWalletExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadataIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropFactoryOnlyOncePerReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropModulesOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropOracleCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinGasLimitNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingIsClosedForever\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewBuyTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewSellTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoETHForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPaymentDue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRefundForCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStoredMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokenForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTrustedPathRecord\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleSignatureHasExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeEndDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeMinETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePerAddressMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePoolPerTxnMinETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePoolSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeStartDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeVestingDays\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersDoNotMatchSignedMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PassedConfigDoesNotMatchApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PauseCutOffHasPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentMustCoverPerMintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformTreasuryCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolIsAboveMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolIsBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolPhaseIsClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolPhaseIsNotAfter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolVestingNotYetComplete\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProjectOwnerCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProofInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsMaxPossibleCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingPhaseSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralIdAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestingMoreThanAvailableBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previouslyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAllocation\",\"type\":\"uint256\"}],\"name\":\"RequestingMoreThanRemainingAllocation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltyFeeWillExceedSalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShareTotalCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SuperAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyTotalMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupportWindowIsNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxFreeAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxPeriodStillInForce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThisMintIsClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSharesMustMatchDenominator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognisedVRFMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VRFCoordinatorCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueExceedsMaximum\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dripHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dripTokenMinted\",\"type\":\"uint256\"}],\"name\":\"AddToPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dripHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dripTokenBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pooledTokenClaimed\",\"type\":\"uint256\"}],\"name\":\"ClaimFromPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenTotal\",\"type\":\"uint256\"}],\"name\":\"LiquidityAddedFromPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dripHolder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dripTokenBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRefunded\",\"type\":\"uint256\"}],\"name\":\"RefundFromPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"addToPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdERC20\",\"outputs\":[{\"internalType\":\"contract IERC20ByMetadrop\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolParams_\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"name\":\"initialiseDRIP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"createdERC20_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolCreator_\",\"type\":\"address\"}],\"name\":\"loadERC20AddressAndSeedETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFundedETH\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolEndDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolIsAboveMinimum\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"poolIsAboveMinimum_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolIsAtMaximum\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"poolIsAtMaximum_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolMaxETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolMinETH\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPerAddressMaxETH\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPerTransactionMinETH\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPhaseStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"poolPhaseStatus_\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolStartDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolVestingInDays\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectSeedContributionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectSeedContributionETH\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyForLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyForLP_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyInThePool\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockerFee_\",\"type\":\"uint256\"}],\"name\":\"supplyLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalETHContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalETHContributed_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalETHPooled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalETHPooled_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingEndDate_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC20DRIPool", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}