{"SourceCode": "// Verified using https://dapp.tools\n\n// hevm: flattened sources of lib/radicle-drips-hub/src/ManagedDripsHub.sol\n// SPDX-License-Identifier: MIT AND GPL-3.0-only\npragma solidity >=0.8.0 <0.9.0 >=0.8.2 <0.9.0 >=0.8.7 <0.9.0;\n\n////// lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Address.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\n\n/* pragma solidity ^0.8.2; */\n\n/* import \"../beacon/IBeacon.sol\"; */\n/* import \"../../utils/Address.sol\"; */\n/* import \"../../utils/StorageSlot.sol\"; */\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../Proxy.sol\"; */\n/* import \"./ERC1967Upgrade.sol\"; */\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/utils/UUPSUpgradeable.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../ERC1967/ERC1967Upgrade.sol\"; */\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n\n////// lib/radicle-drips-hub/src/Structs.sol\n/* pragma solidity ^0.8.7; */\n\nstruct DripsReceiver {\n    address receiver;\n    uint128 amtPerSec;\n}\n\nstruct SplitsReceiver {\n    address receiver;\n    uint32 weight;\n}\n\n////// lib/radicle-drips-hub/src/DripsHub.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {DripsReceiver, SplitsReceiver} from \"./Structs.sol\"; */\n\n/// @notice Drips hub contract. Automatically drips and splits funds between users.\n///\n/// The user can transfer some funds to their drips balance in the contract\n/// and configure a list of receivers, to whom they want to drip these funds.\n/// As soon as the drips balance is enough to cover at least 1 second of dripping\n/// to the configured receivers, the funds start dripping automatically.\n/// Every second funds are deducted from the drips balance and moved to their receivers' accounts.\n/// The process stops automatically when the drips balance is not enough to cover another second.\n///\n/// The user can have any number of independent configurations and drips balances by using accounts.\n/// An account is identified by the user address and an account identifier.\n/// Accounts of different users are separate entities, even if they have the same identifiers.\n/// An account can be used to drip or give, but not to receive funds.\n///\n/// Every user has a receiver balance, in which they have funds received from other users.\n/// The dripped funds are added to the receiver balances in global cycles.\n/// Every `cycleSecs` seconds the drips hub adds dripped funds to the receivers' balances,\n/// so recently dripped funds may not be collectable immediately.\n/// `cycleSecs` is a constant configured when the drips hub is deployed.\n/// The receiver balance is independent from the drips balance,\n/// to drip received funds they need to be first collected and then added to the drips balance.\n///\n/// The user can share collected funds with other users by using splits.\n/// When collecting, the user gives each of their splits receivers a fraction of the received funds.\n/// Funds received from splits are available for collection immediately regardless of the cycle.\n/// They aren't exempt from being split, so they too can be split when collected.\n/// Users can build chains and networks of splits between each other.\n/// Anybody can request collection of funds for any user,\n/// which can be used to enforce the flow of funds in the network of splits.\n///\n/// The concept of something happening periodically, e.g. every second or every `cycleSecs` are\n/// only high-level abstractions for the user, Ethereum isn't really capable of scheduling work.\n/// The actual implementation emulates that behavior by calculating the results of the scheduled\n/// events based on how many seconds have passed and only when the user needs their outcomes.\n///\n/// The contract assumes that all amounts in the system can be stored in signed 128-bit integers.\n/// It's guaranteed to be safe only when working with assets with supply lower than `2 ^ 127`.\nabstract contract DripsHub {\n    /// @notice On every timestamp `T`, which is a multiple of `cycleSecs`, the receivers\n    /// gain access to drips collected during `T - cycleSecs` to `T - 1`.\n    uint64 public immutable cycleSecs;\n    /// @notice Timestamp at which all drips must be finished\n    uint64 internal constant MAX_TIMESTAMP = type(uint64).max - 2;\n    /// @notice Maximum number of drips receivers of a single user.\n    /// Limits cost of changes in drips configuration.\n    uint32 public constant MAX_DRIPS_RECEIVERS = 100;\n    /// @notice Maximum number of splits receivers of a single user.\n    /// Limits cost of collecting.\n    uint32 public constant MAX_SPLITS_RECEIVERS = 200;\n    /// @notice The total splits weight of a user\n    uint32 public constant TOTAL_SPLITS_WEIGHT = 1_000_000;\n    /// @notice The ERC-1967 storage slot for the contract.\n    /// It holds a single `DripsHubStorage` structure.\n    bytes32 private constant SLOT_STORAGE =\n        bytes32(uint256(keccak256(\"eip1967.dripsHub.storage\")) - 1);\n\n    /// @notice Emitted when drips from a user to a receiver are updated.\n    /// Funds are being dripped on every second between the event block's timestamp (inclusively)\n    /// and`endTime` (exclusively) or until the timestamp of the next drips update (exclusively).\n    /// @param user The dripping user\n    /// @param receiver The receiver of the updated drips\n    /// @param amtPerSec The new amount per second dripped from the user\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop,\n    /// always larger than the block timestamp or equal to it if the drips are stopped\n    event Dripping(\n        address indexed user,\n        address indexed receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    );\n\n    /// @notice Emitted when drips from a user's account to a receiver are updated.\n    /// Funds are being dripped on every second between the event block's timestamp (inclusively)\n    /// and`endTime` (exclusively) or until the timestamp of the next drips update (exclusively).\n    /// @param user The user\n    /// @param account The dripping account\n    /// @param receiver The receiver of the updated drips\n    /// @param amtPerSec The new amount per second dripped from the user's account\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop,\n    /// always larger than the block timestamp or equal to it if the drips are stopped\n    event Dripping(\n        address indexed user,\n        uint256 indexed account,\n        address indexed receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    );\n\n    /// @notice Emitted when the drips configuration of a user is updated.\n    /// @param user The user\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param receivers The new list of the drips receivers.\n    event DripsUpdated(address indexed user, uint128 balance, DripsReceiver[] receivers);\n\n    /// @notice Emitted when the drips configuration of a user's account is updated.\n    /// @param user The user\n    /// @param account The account\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param receivers The new list of the drips receivers.\n    event DripsUpdated(\n        address indexed user,\n        uint256 indexed account,\n        uint128 balance,\n        DripsReceiver[] receivers\n    );\n\n    /// @notice Emitted when the user's splits are updated.\n    /// @param user The user\n    /// @param receivers The list of the user's splits receivers.\n    event SplitsUpdated(address indexed user, SplitsReceiver[] receivers);\n\n    /// @notice Emitted when a user collects funds\n    /// @param user The user\n    /// @param collected The collected amount\n    /// @param split The amount split to the user's splits receivers\n    event Collected(address indexed user, uint128 collected, uint128 split);\n\n    /// @notice Emitted when funds are split from a user to a receiver.\n    /// This is caused by the user collecting received funds.\n    /// @param user The user\n    /// @param receiver The splits receiver\n    /// @param amt The amount split to the receiver\n    event Split(address indexed user, address indexed receiver, uint128 amt);\n\n    /// @notice Emitted when funds are given from the user to the receiver.\n    /// @param user The address of the user\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    event Given(address indexed user, address indexed receiver, uint128 amt);\n\n    /// @notice Emitted when funds are given from the user's account to the receiver.\n    /// @param user The address of the user\n    /// @param account The user's account\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    event Given(\n        address indexed user,\n        uint256 indexed account,\n        address indexed receiver,\n        uint128 amt\n    );\n\n    struct ReceiverState {\n        // The amount collectable independently from cycles\n        uint128 collectable;\n        // The next cycle to be collected\n        uint64 nextCollectedCycle;\n        // --- SLOT BOUNDARY\n        // The changes of collected amounts on specific cycle.\n        // The keys are cycles, each cycle `C` becomes collectable on timestamp `C * cycleSecs`.\n        // Values for cycles before `nextCollectedCycle` are guaranteed to be zeroed.\n        // This means that the value of `amtDeltas[nextCollectedCycle].thisCycle` is always\n        // relative to 0 or in other words it's an absolute value independent from other cycles.\n        mapping(uint64 => AmtDelta) amtDeltas;\n    }\n\n    struct AmtDelta {\n        // Amount delta applied on this cycle\n        int128 thisCycle;\n        // Amount delta applied on the next cycle\n        int128 nextCycle;\n    }\n\n    struct UserOrAccount {\n        bool isAccount;\n        address user;\n        uint256 account;\n    }\n\n    struct DripsHubStorage {\n        /// @notice Users' splits configuration hashes, see `hashSplits`.\n        /// The key is the user address.\n        mapping(address => bytes32) splitsHash;\n        /// @notice Users' drips configuration hashes, see `hashDrips`.\n        /// The key is the user address.\n        mapping(address => bytes32) userDripsHashes;\n        /// @notice Users' accounts' configuration hashes, see `hashDrips`.\n        /// The key are the user address and the account.\n        mapping(address => mapping(uint256 => bytes32)) accountDripsHashes;\n        /// @notice Users' receiver states.\n        /// The key is the user address.\n        mapping(address => ReceiverState) receiverStates;\n    }\n\n    /// @param _cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being collectable by their receivers.\n    /// High value makes collecting cheaper by making it process less cycles for a given time range.\n    constructor(uint64 _cycleSecs) {\n        cycleSecs = _cycleSecs;\n    }\n\n    /// @notice Returns the contract storage.\n    /// @return dripsHubStorage The storage.\n    function _storage() internal pure returns (DripsHubStorage storage dripsHubStorage) {\n        bytes32 slot = SLOT_STORAGE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Based on OpenZeppelin's StorageSlot\n            dripsHubStorage.slot := slot\n        }\n    }\n\n    /// @notice Returns amount of received funds available for collection for a user.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collectable(address user, SplitsReceiver[] memory currReceivers)\n        public\n        view\n        returns (uint128 collected, uint128 split)\n    {\n        ReceiverState storage receiver = _storage().receiverStates[user];\n        _assertCurrSplits(user, currReceivers);\n\n        // Collectable independently from cycles\n        collected = receiver.collectable;\n\n        // Collectable from cycles\n        uint64 collectedCycle = receiver.nextCollectedCycle;\n        uint64 currFinishedCycle = _currTimestamp() / cycleSecs;\n        if (collectedCycle != 0 && collectedCycle <= currFinishedCycle) {\n            int128 cycleAmt = 0;\n            for (; collectedCycle <= currFinishedCycle; collectedCycle++) {\n                cycleAmt += receiver.amtDeltas[collectedCycle].thisCycle;\n                collected += uint128(cycleAmt);\n                cycleAmt += receiver.amtDeltas[collectedCycle].nextCycle;\n            }\n        }\n\n        // split when collected\n        if (collected > 0 && currReceivers.length > 0) {\n            uint32 splitsWeight = 0;\n            for (uint256 i = 0; i < currReceivers.length; i++) {\n                splitsWeight += currReceivers[i].weight;\n            }\n            split = uint128((uint160(collected) * splitsWeight) / TOTAL_SPLITS_WEIGHT);\n            collected -= split;\n        }\n    }\n\n    /// @notice Collects all received funds available for the user\n    /// and transfers them out of the drips hub contract to that user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collect(address user, SplitsReceiver[] memory currReceivers)\n        public\n        virtual\n        returns (uint128 collected, uint128 split)\n    {\n        (collected, split) = _collectInternal(user, currReceivers);\n        _transfer(user, int128(collected));\n    }\n\n    /// @notice Counts cycles which will need to be analyzed when collecting or flushing.\n    /// This function can be used to detect that there are too many cycles\n    /// to analyze in a single transaction and flushing is needed.\n    /// @param user The user\n    /// @return flushable The number of cycles which can be flushed\n    function flushableCycles(address user) public view returns (uint64 flushable) {\n        uint64 nextCollectedCycle = _storage().receiverStates[user].nextCollectedCycle;\n        if (nextCollectedCycle == 0) return 0;\n        uint64 currFinishedCycle = _currTimestamp() / cycleSecs;\n        return currFinishedCycle + 1 - nextCollectedCycle;\n    }\n\n    /// @notice Flushes uncollected cycles of the user.\n    /// Flushed cycles won't need to be analyzed when the user collects from them.\n    /// Calling this function does not collect and does not affect the collectable amount.\n    ///\n    /// This function is needed when collecting funds received over a period so long, that the gas\n    /// needed for analyzing all the uncollected cycles can't fit in a single transaction.\n    /// Calling this function allows spreading the analysis cost over multiple transactions.\n    /// A cycle is never flushed more than once, even if this function is called many times.\n    /// @param user The user\n    /// @param maxCycles The maximum number of flushed cycles.\n    /// If too low, flushing will be cheap, but will cut little gas from the next collection.\n    /// If too high, flushing may become too expensive to fit in a single transaction.\n    /// @return flushable The number of cycles which can be flushed\n    function flushCycles(address user, uint64 maxCycles) public virtual returns (uint64 flushable) {\n        flushable = flushableCycles(user);\n        uint64 cycles = maxCycles < flushable ? maxCycles : flushable;\n        flushable -= cycles;\n        uint128 collected = _flushCyclesInternal(user, cycles);\n        if (collected > 0) _storage().receiverStates[user].collectable += collected;\n    }\n\n    /// @notice Collects all received funds available for the user,\n    /// but doesn't transfer them to the user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function _collectInternal(address user, SplitsReceiver[] memory currReceivers)\n        internal\n        returns (uint128 collected, uint128 split)\n    {\n        mapping(address => ReceiverState) storage receiverStates = _storage().receiverStates;\n        ReceiverState storage receiver = receiverStates[user];\n        _assertCurrSplits(user, currReceivers);\n\n        // Collectable independently from cycles\n        collected = receiver.collectable;\n        if (collected > 0) receiver.collectable = 0;\n\n        // Collectable from cycles\n        uint64 cycles = flushableCycles(user);\n        collected += _flushCyclesInternal(user, cycles);\n\n        // split when collected\n        if (collected > 0 && currReceivers.length > 0) {\n            uint32 splitsWeight = 0;\n            for (uint256 i = 0; i < currReceivers.length; i++) {\n                splitsWeight += currReceivers[i].weight;\n                uint128 splitsAmt = uint128(\n                    (uint160(collected) * splitsWeight) / TOTAL_SPLITS_WEIGHT - split\n                );\n                split += splitsAmt;\n                address splitsReceiver = currReceivers[i].receiver;\n                receiverStates[splitsReceiver].collectable += splitsAmt;\n                emit Split(user, splitsReceiver, splitsAmt);\n            }\n            collected -= split;\n        }\n        emit Collected(user, collected, split);\n    }\n\n    /// @notice Collects and clears user's cycles\n    /// @param user The user\n    /// @param count The number of flushed cycles.\n    /// @return collectedAmt The collected amount\n    function _flushCyclesInternal(address user, uint64 count)\n        internal\n        returns (uint128 collectedAmt)\n    {\n        if (count == 0) return 0;\n        ReceiverState storage receiver = _storage().receiverStates[user];\n        uint64 cycle = receiver.nextCollectedCycle;\n        int128 cycleAmt = 0;\n        for (uint256 i = 0; i < count; i++) {\n            cycleAmt += receiver.amtDeltas[cycle].thisCycle;\n            collectedAmt += uint128(cycleAmt);\n            cycleAmt += receiver.amtDeltas[cycle].nextCycle;\n            delete receiver.amtDeltas[cycle];\n            cycle++;\n        }\n        // The next cycle delta must be relative to the last collected cycle, which got zeroed.\n        // In other words the next cycle delta must be an absolute value.\n        if (cycleAmt != 0) receiver.amtDeltas[cycle].thisCycle += cycleAmt;\n        receiver.nextCollectedCycle = cycle;\n    }\n\n    /// @notice Gives funds from the user or their account to the receiver.\n    /// The receiver can collect them immediately.\n    /// Transfers the funds to be given from the user's wallet to the drips hub contract.\n    /// @param userOrAccount The user or their account\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    function _give(\n        UserOrAccount memory userOrAccount,\n        address receiver,\n        uint128 amt\n    ) internal {\n        _storage().receiverStates[receiver].collectable += amt;\n        if (userOrAccount.isAccount) {\n            emit Given(userOrAccount.user, userOrAccount.account, receiver, amt);\n        } else {\n            emit Given(userOrAccount.user, receiver, amt);\n        }\n        _transfer(userOrAccount.user, -int128(amt));\n    }\n\n    /// @notice Current user's drips hash, see `hashDrips`.\n    /// @param user The user\n    /// @return currDripsHash The current user's drips hash\n    function dripsHash(address user) public view returns (bytes32 currDripsHash) {\n        return _storage().userDripsHashes[user];\n    }\n\n    /// @notice Current user account's drips hash, see `hashDrips`.\n    /// @param user The user\n    /// @param account The account\n    /// @return currDripsHash The current user account's drips hash\n    function dripsHash(address user, uint256 account) public view returns (bytes32 currDripsHash) {\n        return _storage().accountDripsHashes[user][account];\n    }\n\n    /// @notice Sets the user's or the account's drips configuration.\n    /// Transfers funds between the user's wallet and the drips hub contract\n    /// to fulfill the change of the drips balance.\n    /// @param userOrAccount The user or their account\n    /// @param lastUpdate The timestamp of the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @param newReceivers The list of the drips receivers of the user or the account to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @return newBalance The new drips balance of the user or the account.\n    /// Pass it as `lastBalance` when updating that user or the account for the next time.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    function _setDrips(\n        UserOrAccount memory userOrAccount,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers\n    ) internal returns (uint128 newBalance, int128 realBalanceDelta) {\n        _assertCurrDrips(userOrAccount, lastUpdate, lastBalance, currReceivers);\n        uint128 newAmtPerSec = _assertDripsReceiversValid(newReceivers);\n        uint128 currAmtPerSec = _totalDripsAmtPerSec(currReceivers);\n        uint64 currEndTime = _dripsEndTime(lastUpdate, lastBalance, currAmtPerSec);\n        (newBalance, realBalanceDelta) = _updateDripsBalance(\n            lastUpdate,\n            lastBalance,\n            currEndTime,\n            currAmtPerSec,\n            balanceDelta\n        );\n        uint64 newEndTime = _dripsEndTime(_currTimestamp(), newBalance, newAmtPerSec);\n        _updateDripsReceiversStates(\n            userOrAccount,\n            currReceivers,\n            currEndTime,\n            newReceivers,\n            newEndTime\n        );\n        _storeNewDrips(userOrAccount, newBalance, newReceivers);\n        _emitDripsUpdated(userOrAccount, newBalance, newReceivers);\n        _transfer(userOrAccount.user, -realBalanceDelta);\n    }\n\n    /// @notice Validates a list of drips receivers.\n    /// @param receivers The list of drips receivers.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @return totalAmtPerSec The total amount per second of all drips receivers.\n    function _assertDripsReceiversValid(DripsReceiver[] memory receivers)\n        internal\n        pure\n        returns (uint128 totalAmtPerSec)\n    {\n        require(receivers.length <= MAX_DRIPS_RECEIVERS, \"Too many drips receivers\");\n        uint256 amtPerSec = 0;\n        address prevReceiver;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint128 amt = receivers[i].amtPerSec;\n            require(amt != 0, \"Drips receiver amtPerSec is zero\");\n            amtPerSec += amt;\n            address receiver = receivers[i].receiver;\n            if (i > 0) {\n                require(prevReceiver != receiver, \"Duplicate drips receivers\");\n                require(prevReceiver < receiver, \"Drips receivers not sorted by address\");\n            }\n            prevReceiver = receiver;\n        }\n        require(amtPerSec <= type(uint128).max, \"Total drips receivers amtPerSec too high\");\n        return uint128(amtPerSec);\n    }\n\n    /// @notice Calculates the total amount per second of all the drips receivers.\n    /// @param receivers The list of the receivers.\n    /// It must have passed `_assertDripsReceiversValid` in the past.\n    /// @return totalAmtPerSec The total amount per second of all the drips receivers\n    function _totalDripsAmtPerSec(DripsReceiver[] memory receivers)\n        internal\n        pure\n        returns (uint128 totalAmtPerSec)\n    {\n        uint256 length = receivers.length;\n        uint256 i = 0;\n        while (i < length) {\n            // Safe, because `receivers` passed `_assertDripsReceiversValid` in the past\n            unchecked {\n                totalAmtPerSec += receivers[i++].amtPerSec;\n            }\n        }\n    }\n\n    /// @notice Updates drips balance.\n    /// @param lastUpdate The timestamp of the last drips update.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update.\n    /// If this is the first update, pass zero.\n    /// @param currEndTime Time when drips were supposed to end according to the last drips update.\n    /// @param currAmtPerSec The total amount per second of all drips receivers\n    /// according to the last drips update.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @return newBalance The new drips balance.\n    /// Pass it as `lastBalance` when updating for the next time.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    /// If positive, this is the amount which should be transferred from the user to the drips hub,\n    /// or if negative, from the drips hub to the user.\n    function _updateDripsBalance(\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        uint64 currEndTime,\n        uint128 currAmtPerSec,\n        int128 balanceDelta\n    ) internal view returns (uint128 newBalance, int128 realBalanceDelta) {\n        if (currEndTime > _currTimestamp()) currEndTime = _currTimestamp();\n        uint128 dripped = (currEndTime - lastUpdate) * currAmtPerSec;\n        int128 currBalance = int128(lastBalance - dripped);\n        int136 balance = currBalance + int136(balanceDelta);\n        if (balance < 0) balance = 0;\n        return (uint128(uint136(balance)), int128(balance - currBalance));\n    }\n\n    /// @notice Emit an event when drips are updated.\n    /// @param userOrAccount The user or their account\n    /// @param balance The new drips balance.\n    /// @param receivers The new list of the drips receivers.\n    function _emitDripsUpdated(\n        UserOrAccount memory userOrAccount,\n        uint128 balance,\n        DripsReceiver[] memory receivers\n    ) internal {\n        if (userOrAccount.isAccount) {\n            emit DripsUpdated(userOrAccount.user, userOrAccount.account, balance, receivers);\n        } else {\n            emit DripsUpdated(userOrAccount.user, balance, receivers);\n        }\n    }\n\n    /// @notice Updates the user's or the account's drips receivers' states.\n    /// It applies the effects of the change of the drips configuration.\n    /// @param userOrAccount The user or their account\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    /// @param currEndTime Time when drips were supposed to end according to the last drips update.\n    /// @param newReceivers  The list of the drips receivers of the user or the account to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @param newEndTime Time when drips will end according to the new drips configuration.\n    function _updateDripsReceiversStates(\n        UserOrAccount memory userOrAccount,\n        DripsReceiver[] memory currReceivers,\n        uint64 currEndTime,\n        DripsReceiver[] memory newReceivers,\n        uint64 newEndTime\n    ) internal {\n        // Skip iterating over `currReceivers` if dripping has run out\n        uint256 currIdx = currEndTime > _currTimestamp() ? 0 : currReceivers.length;\n        // Skip iterating over `newReceivers` if no new dripping is started\n        uint256 newIdx = newEndTime > _currTimestamp() ? 0 : newReceivers.length;\n        while (true) {\n            // Each iteration gets the next drips update and applies it on the receiver state.\n            // A drips update is composed of two drips receiver configurations,\n            // one current and one new, or from a single drips receiver configuration\n            // if the drips receiver is being added or removed.\n            bool pickCurr = currIdx < currReceivers.length;\n            bool pickNew = newIdx < newReceivers.length;\n            if (!pickCurr && !pickNew) break;\n            if (pickCurr && pickNew) {\n                // There are two candidate drips receiver configurations to create a drips update.\n                // Pick both if they describe the same receiver or the one with a lower address.\n                // The one with a higher address won't be used in this iteration.\n                // Because drips receivers lists are sorted by addresses and deduplicated,\n                // all matching pairs of drips receiver configurations will be found.\n                address currReceiver = currReceivers[currIdx].receiver;\n                address newReceiver = newReceivers[newIdx].receiver;\n                pickCurr = currReceiver <= newReceiver;\n                pickNew = newReceiver <= currReceiver;\n            }\n            // The drips update parameters\n            address receiver;\n            int128 currAmtPerSec = 0;\n            int128 newAmtPerSec = 0;\n            if (pickCurr) {\n                receiver = currReceivers[currIdx].receiver;\n                currAmtPerSec = int128(currReceivers[currIdx].amtPerSec);\n                // Clear the obsolete drips end\n                _setDelta(receiver, currEndTime, currAmtPerSec);\n                currIdx++;\n            }\n            if (pickNew) {\n                receiver = newReceivers[newIdx].receiver;\n                newAmtPerSec = int128(newReceivers[newIdx].amtPerSec);\n                // Apply the new drips end\n                _setDelta(receiver, newEndTime, -newAmtPerSec);\n                newIdx++;\n            }\n            // Apply the drips update since now\n            _setDelta(receiver, _currTimestamp(), newAmtPerSec - currAmtPerSec);\n            _emitDripping(userOrAccount, receiver, uint128(newAmtPerSec), newEndTime);\n            // The receiver may have never been used\n            if (!pickCurr) {\n                ReceiverState storage receiverState = _storage().receiverStates[receiver];\n                // The receiver has never been used, initialize it\n                if (receiverState.nextCollectedCycle == 0) {\n                    receiverState.nextCollectedCycle = _currTimestamp() / cycleSecs + 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Emit an event when drips from a user to a receiver are updated.\n    /// @param userOrAccount The user or their account\n    /// @param receiver The receiver\n    /// @param amtPerSec The new amount per second dripped from the user or the account\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop\n    function _emitDripping(\n        UserOrAccount memory userOrAccount,\n        address receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    ) internal {\n        if (amtPerSec == 0) endTime = _currTimestamp();\n        if (userOrAccount.isAccount) {\n            emit Dripping(userOrAccount.user, userOrAccount.account, receiver, amtPerSec, endTime);\n        } else {\n            emit Dripping(userOrAccount.user, receiver, amtPerSec, endTime);\n        }\n    }\n\n    /// @notice Calculates the timestamp when dripping will end.\n    /// @param startTime Time when dripping is started.\n    /// @param startBalance The drips balance when dripping is started.\n    /// @param totalAmtPerSec The total amount per second of all the drips receivers\n    /// @return dripsEndTime The dripping end time.\n    function _dripsEndTime(\n        uint64 startTime,\n        uint128 startBalance,\n        uint128 totalAmtPerSec\n    ) internal pure returns (uint64 dripsEndTime) {\n        if (totalAmtPerSec == 0) return startTime;\n        uint256 endTime = startTime + uint256(startBalance / totalAmtPerSec);\n        return endTime > MAX_TIMESTAMP ? MAX_TIMESTAMP : uint64(endTime);\n    }\n\n    /// @notice Asserts that the drips configuration is the currently used one.\n    /// @param userOrAccount The user or their account\n    /// @param lastUpdate The timestamp of the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    function _assertCurrDrips(\n        UserOrAccount memory userOrAccount,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers\n    ) internal view {\n        bytes32 expectedHash;\n        if (userOrAccount.isAccount) {\n            expectedHash = _storage().accountDripsHashes[userOrAccount.user][userOrAccount.account];\n        } else {\n            expectedHash = _storage().userDripsHashes[userOrAccount.user];\n        }\n        bytes32 actualHash = hashDrips(lastUpdate, lastBalance, currReceivers);\n        require(actualHash == expectedHash, \"Invalid current drips configuration\");\n    }\n\n    /// @notice Stores the hash of the new drips configuration to be used in `_assertCurrDrips`.\n    /// @param userOrAccount The user or their account\n    /// @param newBalance The user or the account drips balance.\n    /// @param newReceivers The list of the drips receivers of the user or the account.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    function _storeNewDrips(\n        UserOrAccount memory userOrAccount,\n        uint128 newBalance,\n        DripsReceiver[] memory newReceivers\n    ) internal {\n        bytes32 newDripsHash = hashDrips(_currTimestamp(), newBalance, newReceivers);\n        if (userOrAccount.isAccount) {\n            _storage().accountDripsHashes[userOrAccount.user][userOrAccount.account] = newDripsHash;\n        } else {\n            _storage().userDripsHashes[userOrAccount.user] = newDripsHash;\n        }\n    }\n\n    /// @notice Calculates the hash of the drips configuration.\n    /// It's used to verify if drips configuration is the previously set one.\n    /// @param update The timestamp of the drips update.\n    /// If the drips have never been updated, pass zero.\n    /// @param balance The drips balance.\n    /// If the drips have never been updated, pass zero.\n    /// @param receivers The list of the drips receivers.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// If the drips have never been updated, pass an empty array.\n    /// @return dripsConfigurationHash The hash of the drips configuration\n    function hashDrips(\n        uint64 update,\n        uint128 balance,\n        DripsReceiver[] memory receivers\n    ) public pure returns (bytes32 dripsConfigurationHash) {\n        if (update == 0 && balance == 0 && receivers.length == 0) return bytes32(0);\n        return keccak256(abi.encode(receivers, update, balance));\n    }\n\n    /// @notice Collects funds received by the user and sets their splits.\n    /// The collected funds are split according to `currReceivers`.\n    /// @param user The user\n    /// @param currReceivers The list of the user's splits receivers which is currently in use.\n    /// If this function is called for the first time for the user, should be an empty array.\n    /// @param newReceivers The new list of the user's splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// Each splits receiver will be getting `weight / TOTAL_SPLITS_WEIGHT`\n    /// share of the funds collected by the user.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function _setSplits(\n        address user,\n        SplitsReceiver[] memory currReceivers,\n        SplitsReceiver[] memory newReceivers\n    ) internal returns (uint128 collected, uint128 split) {\n        (collected, split) = _collectInternal(user, currReceivers);\n        _assertSplitsValid(newReceivers);\n        _storage().splitsHash[user] = hashSplits(newReceivers);\n        emit SplitsUpdated(user, newReceivers);\n        _transfer(user, int128(collected));\n    }\n\n    /// @notice Validates a list of splits receivers\n    /// @param receivers The list of splits receivers\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    function _assertSplitsValid(SplitsReceiver[] memory receivers) internal pure {\n        require(receivers.length <= MAX_SPLITS_RECEIVERS, \"Too many splits receivers\");\n        uint64 totalWeight = 0;\n        address prevReceiver;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint32 weight = receivers[i].weight;\n            require(weight != 0, \"Splits receiver weight is zero\");\n            totalWeight += weight;\n            address receiver = receivers[i].receiver;\n            if (i > 0) {\n                require(prevReceiver != receiver, \"Duplicate splits receivers\");\n                require(prevReceiver < receiver, \"Splits receivers not sorted by address\");\n            }\n            prevReceiver = receiver;\n        }\n        require(totalWeight <= TOTAL_SPLITS_WEIGHT, \"Splits weights sum too high\");\n    }\n\n    /// @notice Current user's splits hash, see `hashSplits`.\n    /// @param user The user\n    /// @return currSplitsHash The current user's splits hash\n    function splitsHash(address user) public view returns (bytes32 currSplitsHash) {\n        return _storage().splitsHash[user];\n    }\n\n    /// @notice Asserts that the list of splits receivers is the user's currently used one.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    function _assertCurrSplits(address user, SplitsReceiver[] memory currReceivers) internal view {\n        require(\n            hashSplits(currReceivers) == _storage().splitsHash[user],\n            \"Invalid current splits receivers\"\n        );\n    }\n\n    /// @notice Calculates the hash of the list of splits receivers.\n    /// @param receivers The list of the splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// @return receiversHash The hash of the list of splits receivers.\n    function hashSplits(SplitsReceiver[] memory receivers)\n        public\n        pure\n        returns (bytes32 receiversHash)\n    {\n        if (receivers.length == 0) return bytes32(0);\n        return keccak256(abi.encode(receivers));\n    }\n\n    /// @notice Called when funds need to be transferred between the user and the drips hub.\n    /// The function must be called no more than once per transaction.\n    /// @param user The user\n    /// @param amt The transferred amount.\n    /// Positive to transfer funds to the user, negative to transfer from them.\n    function _transfer(address user, int128 amt) internal virtual;\n\n    /// @notice Sets amt delta of a user on a given timestamp\n    /// @param user The user\n    /// @param timestamp The timestamp from which the delta takes effect\n    /// @param amtPerSecDelta Change of the per-second receiving rate\n    function _setDelta(\n        address user,\n        uint64 timestamp,\n        int128 amtPerSecDelta\n    ) internal {\n        if (amtPerSecDelta == 0) return;\n        mapping(uint64 => AmtDelta) storage amtDeltas = _storage().receiverStates[user].amtDeltas;\n        // In order to set a delta on a specific timestamp it must be introduced in two cycles.\n        // The cycle delta is split proportionally based on how much this cycle is affected.\n        // The next cycle has the rest of the delta applied, so the update is fully completed.\n        uint64 thisCycle = timestamp / cycleSecs + 1;\n        uint64 nextCycleSecs = timestamp % cycleSecs;\n        uint64 thisCycleSecs = cycleSecs - nextCycleSecs;\n        amtDeltas[thisCycle].thisCycle += int128(uint128(thisCycleSecs)) * amtPerSecDelta;\n        amtDeltas[thisCycle].nextCycle += int128(uint128(nextCycleSecs)) * amtPerSecDelta;\n    }\n\n    function _userOrAccount(address user) internal pure returns (UserOrAccount memory) {\n        return UserOrAccount({isAccount: false, user: user, account: 0});\n    }\n\n    function _userOrAccount(address user, uint256 account)\n        internal\n        pure\n        returns (UserOrAccount memory)\n    {\n        return UserOrAccount({isAccount: true, user: user, account: account});\n    }\n\n    function _currTimestamp() internal view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n}\n\n////// lib/radicle-drips-hub/src/ManagedDripsHub.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {UUPSUpgradeable} from \"openzeppelin-contracts/proxy/utils/UUPSUpgradeable.sol\"; */\n/* import {ERC1967Proxy} from \"openzeppelin-contracts/proxy/ERC1967/ERC1967Proxy.sol\"; */\n/* import {ERC1967Upgrade} from \"openzeppelin-contracts/proxy/ERC1967/ERC1967Upgrade.sol\"; */\n/* import {StorageSlot} from \"openzeppelin-contracts/utils/StorageSlot.sol\"; */\n/* import {DripsHub, SplitsReceiver} from \"./DripsHub.sol\"; */\n\n/// @notice The DripsHub which is UUPS-upgradable, pausable and has an admin.\n/// It can't be used directly, only via a proxy.\n///\n/// ManagedDripsHub uses the ERC-1967 admin slot to store the admin address.\n/// All instances of the contracts are owned by address `0x00`.\n/// While this contract is capable of updating the admin,\n/// the proxy is expected to set up the initial value of the ERC-1967 admin.\n///\n/// All instances of the contracts are paused and can't be unpaused.\n/// When a proxy uses such contract via delegation, it's initially unpaused.\nabstract contract ManagedDripsHub is DripsHub, UUPSUpgradeable {\n    /// @notice The ERC-1967 storage slot for the contract.\n    /// It holds a single boolean indicating if the contract is paused.\n    bytes32 private constant SLOT_PAUSED =\n        bytes32(uint256(keccak256(\"eip1967.managedDripsHub.paused\")) - 1);\n\n    /// @notice Emitted when the pause is triggered.\n    /// @param account The account which triggered the change.\n    event Paused(address account);\n\n    /// @notice Emitted when the pause is lifted.\n    /// @param account The account which triggered the change.\n    event Unpaused(address account);\n\n    /// @notice Initializes the contract in paused state and with no admin.\n    /// The contract instance can be used only as a call delegation target for a proxy.\n    /// @param cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being collectable by their receivers.\n    /// High value makes collecting cheaper by making it process less cycles for a given time range.\n    constructor(uint64 cycleSecs) DripsHub(cycleSecs) {\n        _pausedSlot().value = true;\n    }\n\n    /// @notice Collects all received funds available for the user\n    /// and transfers them out of the drips hub contract to that user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collect(address user, SplitsReceiver[] memory currReceivers)\n        public\n        override\n        whenNotPaused\n        returns (uint128 collected, uint128 split)\n    {\n        return super.collect(user, currReceivers);\n    }\n\n    /// @notice Flushes uncollected cycles of the user.\n    /// Flushed cycles won't need to be analyzed when the user collects from them.\n    /// Calling this function does not collect and does not affect the collectable amount.\n    ///\n    /// This function is needed when collecting funds received over a period so long, that the gas\n    /// needed for analyzing all the uncollected cycles can't fit in a single transaction.\n    /// Calling this function allows spreading the analysis cost over multiple transactions.\n    /// A cycle is never flushed more than once, even if this function is called many times.\n    /// @param user The user\n    /// @param maxCycles The maximum number of flushed cycles.\n    /// If too low, flushing will be cheap, but will cut little gas from the next collection.\n    /// If too high, flushing may become too expensive to fit in a single transaction.\n    /// @return flushable The number of cycles which can be flushed\n    function flushCycles(address user, uint64 maxCycles)\n        public\n        override\n        whenNotPaused\n        returns (uint64 flushable)\n    {\n        return super.flushCycles(user, maxCycles);\n    }\n\n    /// @notice Authorizes the contract upgrade. See `UUPSUpgradable` docs for more details.\n    function _authorizeUpgrade(address newImplementation) internal view override onlyAdmin {\n        newImplementation;\n    }\n\n    /// @notice Returns the address of the current admin.\n    function admin() public view returns (address) {\n        return _getAdmin();\n    }\n\n    /// @notice Changes the admin of the contract.\n    /// Can only be called by the current admin.\n    function changeAdmin(address newAdmin) public onlyAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /// @notice Throws if called by any account other than the admin.\n    modifier onlyAdmin() {\n        require(admin() == msg.sender, \"Caller is not the admin\");\n        _;\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    function paused() public view returns (bool isPaused) {\n        return _pausedSlot().value;\n    }\n\n    /// @notice Triggers stopped state.\n    function pause() public whenNotPaused onlyAdmin {\n        _pausedSlot().value = true;\n        emit Paused(msg.sender);\n    }\n\n    /// @notice Returns to normal state.\n    function unpause() public whenPaused onlyAdmin {\n        _pausedSlot().value = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /// @notice Modifier to make a function callable only when the contract is not paused.\n    modifier whenNotPaused() {\n        require(!paused(), \"Contract paused\");\n        _;\n    }\n\n    /// @notice Modifier to make a function callable only when the contract is paused.\n    modifier whenPaused() {\n        require(paused(), \"Contract not paused\");\n        _;\n    }\n\n    /// @notice Gets the storage slot holding the paused flag.\n    function _pausedSlot() private pure returns (StorageSlot.BooleanSlot storage) {\n        return StorageSlot.getBooleanSlot(SLOT_PAUSED);\n    }\n}\n\n/// @notice A generic ManagedDripsHub proxy.\ncontract ManagedDripsHubProxy is ERC1967Proxy {\n    constructor(ManagedDripsHub hubLogic, address admin)\n        ERC1967Proxy(address(hubLogic), new bytes(0))\n    {\n        _changeAdmin(admin);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ManagedDripsHub\",\"name\":\"hubLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ManagedDripsHubProxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000008d321e80487356c846f34456d31ce761776ef697000000000000000000000000abadefe1ce7bb6f1d5146f3f476701f791b18c6c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x8d321e80487356c846f34456d31ce761776ef697", "SwarmSource": ""}