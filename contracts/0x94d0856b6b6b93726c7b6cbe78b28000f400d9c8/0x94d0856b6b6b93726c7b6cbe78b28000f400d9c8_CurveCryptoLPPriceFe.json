{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/access/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Claimable\\n/// @dev Implements logic for a two-step ownership transfer on top of Ownable\\ncontract Claimable is Ownable {\\n    /// @dev The new owner that has not claimed ownership yet\\n    address public pendingOwner;\\n\\n    /// @dev A modifier that restricts the function to the pending owner only\\n    modifier onlyPendingOwner() {\\n        if (msg.sender != pendingOwner) {\\n            revert(\\\"Claimable: Sender is not pending owner\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Sets pending owner to the new owner, but does not\\n    /// transfer ownership yet\\n    /// @param newOwner The address to become the future owner\\n    function transferOwnership(address newOwner) public override onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Claimable: new owner is the zero address\\\"\\n        );\\n        pendingOwner = newOwner;\\n    }\\n\\n    /// @dev Used by the pending owner to claim ownership after transferOwnership\\n    function claimOwnership() external onlyPendingOwner {\\n        _transferOwnership(pendingOwner);\\n        pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/ACLNonReentrantTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport { AddressProvider } from \\\"./AddressProvider.sol\\\";\\nimport { IACL } from \\\"../interfaces/IACL.sol\\\";\\nimport { ZeroAddressException, CallerNotConfiguratorException, CallerNotPausableAdminException, CallerNotUnPausableAdminException, CallerNotControllerException } from \\\"../interfaces/IErrors.sol\\\";\\n\\n/// @title ACL Trait\\n/// @notice Utility class for ACL consumers\\nabstract contract ACLNonReentrantTrait is Pausable {\\n    uint8 private constant _NOT_ENTERED = 1;\\n    uint8 private constant _ENTERED = 2;\\n\\n    // ACL contract to check rights\\n    IACL public immutable _acl;\\n\\n    address public controller;\\n    bool public externalController;\\n\\n    uint8 private _status = _NOT_ENTERED;\\n\\n    /// @dev Modifier that allow pausable admin to call the function if pause is needed\\n    /// and for unpausable admins if unpause is needed\\n    /// @param callToPause True if pause action is needed\\n    modifier pausableUnpausableAdminsOnly(bool callToPause) {\\n        if (callToPause && !_acl.isPausableAdmin(msg.sender)) {\\n            revert CallerNotPausableAdminException();\\n        } else if (!callToPause && !_acl.isUnpausableAdmin(msg.sender)) {\\n            revert CallerNotUnPausableAdminException();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\\n    /// Calling a `nonReentrant` function from another `nonReentrant`\\n    /// function is not supported. It is possible to prevent this from happening\\n    /// by making the `nonReentrant` function external, and making it call a\\n    /// `private` function that does the actual work.\\n    ///\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    event NewController(address indexed newController);\\n\\n    /// @dev constructor\\n    /// @param addressProvider Address of address repository\\n    constructor(address addressProvider) {\\n        if (addressProvider == address(0)) revert ZeroAddressException(); // F:[AA-2]\\n\\n        _acl = IACL(AddressProvider(addressProvider).getACL());\\n        controller = IACL(AddressProvider(addressProvider).getACL()).owner();\\n    }\\n\\n    /// @dev  Reverts if msg.sender is not configurator\\n    modifier configuratorOnly() {\\n        if (!_acl.isConfigurator(msg.sender)) {\\n            revert CallerNotConfiguratorException();\\n        }\\n        _;\\n    }\\n\\n    /// @dev  Reverts if msg.sender is not external controller (if it is set) or configurator\\n    modifier controllerOnly() {\\n        if (externalController) {\\n            if (msg.sender != controller) {\\n                revert CallerNotControllerException();\\n            }\\n        } else {\\n            if (!_acl.isConfigurator(msg.sender)) {\\n                revert CallerNotControllerException();\\n            }\\n        }\\n        _;\\n    }\\n\\n    ///@dev Pause contract\\n    function pause() external {\\n        if (!_acl.isPausableAdmin(msg.sender)) {\\n            revert CallerNotPausableAdminException();\\n        }\\n        _pause();\\n    }\\n\\n    /// @dev Unpause contract\\n    function unpause() external {\\n        if (!_acl.isUnpausableAdmin(msg.sender)) {\\n            revert CallerNotUnPausableAdminException();\\n        }\\n\\n        _unpause();\\n    }\\n\\n    function setController(address newController) external configuratorOnly {\\n        externalController = !_acl.isConfigurator(newController);\\n        controller = newController;\\n        emit NewController(newController);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/core/AddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IAddressProvider } from \\\"../interfaces/IAddressProvider.sol\\\";\\nimport { Claimable } from \\\"./access/Claimable.sol\\\";\\nimport { Errors } from \\\"../libraries/Errors.sol\\\";\\n\\n// Repositories & services\\nbytes32 constant CONTRACTS_REGISTER = \\\"CONTRACTS_REGISTER\\\";\\nbytes32 constant ACL = \\\"ACL\\\";\\nbytes32 constant PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\nbytes32 constant ACCOUNT_FACTORY = \\\"ACCOUNT_FACTORY\\\";\\nbytes32 constant DATA_COMPRESSOR = \\\"DATA_COMPRESSOR\\\";\\nbytes32 constant TREASURY_CONTRACT = \\\"TREASURY_CONTRACT\\\";\\nbytes32 constant GEAR_TOKEN = \\\"GEAR_TOKEN\\\";\\nbytes32 constant WETH_TOKEN = \\\"WETH_TOKEN\\\";\\nbytes32 constant WETH_GATEWAY = \\\"WETH_GATEWAY\\\";\\nbytes32 constant LEVERAGED_ACTIONS = \\\"LEVERAGED_ACTIONS\\\";\\n\\n/// @title AddressRepository\\n/// @notice Stores addresses of deployed contracts\\ncontract AddressProvider is Claimable, IAddressProvider {\\n    // Mapping from contract keys to respective addresses\\n    mapping(bytes32 => address) public addresses;\\n\\n    /// @dev Contract version\\n    function version() external view virtual override returns (uint256) {\\n        return 2;\\n    }\\n\\n    constructor() {\\n        // @dev Emits first event for contract discovery\\n        emit AddressSet(\\\"ADDRESS_PROVIDER\\\", address(this));\\n    }\\n\\n    /// @return Address of ACL contract\\n    function getACL() external view returns (address) {\\n        return _getAddress(ACL); // F:[AP-3]\\n    }\\n\\n    /// @dev Sets address of ACL contract\\n    /// @param _address Address of ACL contract\\n    function setACL(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(ACL, _address); // F:[AP-3]\\n    }\\n\\n    /// @return Address of ContractsRegister\\n    function getContractsRegister() external view returns (address) {\\n        return _getAddress(CONTRACTS_REGISTER); // F:[AP-4]\\n    }\\n\\n    /// @dev Sets address of ContractsRegister\\n    /// @param _address Address of ContractsRegister\\n    function setContractsRegister(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(CONTRACTS_REGISTER, _address); // F:[AP-4]\\n    }\\n\\n    /// @return Address of PriceOracle\\n    function getPriceOracle() external view override returns (address) {\\n        return _getAddress(PRICE_ORACLE); // F:[AP-5]\\n    }\\n\\n    /// @dev Sets address of PriceOracle\\n    /// @param _address Address of PriceOracle\\n    function setPriceOracle(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(PRICE_ORACLE, _address); // F:[AP-5]\\n    }\\n\\n    /// @return Address of AccountFactory\\n    function getAccountFactory() external view returns (address) {\\n        return _getAddress(ACCOUNT_FACTORY); // F:[AP-6]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setAccountFactory(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(ACCOUNT_FACTORY, _address); // F:[AP-6]\\n    }\\n\\n    /// @return Address of DataCompressor\\n    function getDataCompressor() external view override returns (address) {\\n        return _getAddress(DATA_COMPRESSOR); // F:[AP-7]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setDataCompressor(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(DATA_COMPRESSOR, _address); // F:[AP-7]\\n    }\\n\\n    /// @return Address of Treasury contract\\n    function getTreasuryContract() external view returns (address) {\\n        return _getAddress(TREASURY_CONTRACT); // F:[AP-8]\\n    }\\n\\n    /// @dev Sets address of Treasury Contract\\n    /// @param _address Address of Treasury Contract\\n    function setTreasuryContract(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(TREASURY_CONTRACT, _address); // F:[AP-8]\\n    }\\n\\n    /// @return Address of GEAR token\\n    function getGearToken() external view override returns (address) {\\n        return _getAddress(GEAR_TOKEN); // F:[AP-9]\\n    }\\n\\n    /// @dev Sets address of GEAR token\\n    /// @param _address Address of GEAR token\\n    function setGearToken(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(GEAR_TOKEN, _address); // F:[AP-9]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWethToken() external view override returns (address) {\\n        return _getAddress(WETH_TOKEN); // F:[AP-10]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWethToken(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(WETH_TOKEN, _address); // F:[AP-10]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWETHGateway() external view override returns (address) {\\n        return _getAddress(WETH_GATEWAY); // F:[AP-11]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWETHGateway(address _address)\\n        external\\n        onlyOwner // F:[AP-12]\\n    {\\n        _setAddress(WETH_GATEWAY, _address); // F:[AP-11]\\n    }\\n\\n    /// @return Address of PathFinder\\n    function getLeveragedActions() external view returns (address) {\\n        return _getAddress(LEVERAGED_ACTIONS); // T:[AP-7]\\n    }\\n\\n    /// @dev Sets address of  PathFinder\\n    /// @param _address Address of  PathFinder\\n    function setLeveragedActions(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(LEVERAGED_ACTIONS, _address); // T:[AP-7]\\n    }\\n\\n    /// @return Address of key, reverts if the key doesn't exist\\n    function _getAddress(bytes32 key) internal view returns (address) {\\n        address result = addresses[key];\\n        require(result != address(0), Errors.AS_ADDRESS_NOT_FOUND); // F:[AP-1]\\n        return result; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\\n    }\\n\\n    /// @dev Sets address to map by its key\\n    /// @param key Key in string format\\n    /// @param value Address\\n    function _setAddress(bytes32 key, address value) internal {\\n        addresses[key] = value; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\\n        emit AddressSet(key, value); // F:[AP-2]\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IACLExceptions {\\n    /// @dev Thrown when attempting to delete an address from a set that is not a pausable admin\\n    error AddressNotPausableAdminException(address addr);\\n\\n    /// @dev Thrown when attempting to delete an address from a set that is not a unpausable admin\\n    error AddressNotUnpausableAdminException(address addr);\\n}\\n\\ninterface IACLEvents {\\n    /// @dev Emits when a new admin is added that can pause contracts\\n    event PausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when a Pausable admin is removed\\n    event PausableAdminRemoved(address indexed admin);\\n\\n    /// @dev Emits when a new admin is added that can unpause contracts\\n    event UnpausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when an Unpausable admin is removed\\n    event UnpausableAdminRemoved(address indexed admin);\\n}\\n\\n/// @title ACL interface\\ninterface IACL is IACLEvents, IACLExceptions, IVersion {\\n    /// @dev Returns true if the address is a pausable admin and false if not\\n    /// @param addr Address to check\\n    function isPausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if the address is unpausable admin and false if not\\n    /// @param addr Address to check\\n    function isUnpausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if an address has configurator rights\\n    /// @param account Address to check\\n    function isConfigurator(address account) external view returns (bool);\\n\\n    /// @dev Returns address of configurator\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IAddressProviderEvents {\\n    /// @dev Emits when an address is set for a contract role\\n    event AddressSet(bytes32 indexed service, address indexed newAddress);\\n}\\n\\n/// @title Optimised for front-end Address Provider interface\\ninterface IAddressProvider is IAddressProviderEvents, IVersion {\\n    /// @return Address of ACL contract\\n    function getACL() external view returns (address);\\n\\n    /// @return Address of ContractsRegister\\n    function getContractsRegister() external view returns (address);\\n\\n    /// @return Address of AccountFactory\\n    function getAccountFactory() external view returns (address);\\n\\n    /// @return Address of DataCompressor\\n    function getDataCompressor() external view returns (address);\\n\\n    /// @return Address of GEAR token\\n    function getGearToken() external view returns (address);\\n\\n    /// @return Address of WETH token\\n    function getWethToken() external view returns (address);\\n\\n    /// @return Address of WETH Gateway\\n    function getWETHGateway() external view returns (address);\\n\\n    /// @return Address of PriceOracle\\n    function getPriceOracle() external view returns (address);\\n\\n    /// @return Address of DAO Treasury Multisig\\n    function getTreasuryContract() external view returns (address);\\n\\n    /// @return Address of PathFinder\\n    function getLeveragedActions() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @dev Common contract exceptions\\n\\n/// @dev Thrown on attempting to set an important address to zero address\\nerror ZeroAddressException();\\n\\n/// @dev Thrown on attempting to call a non-implemented function\\nerror NotImplementedException();\\n\\n/// @dev Thrown on attempting to set an EOA as an important contract in the system\\nerror AddressIsNotContractException(address);\\n\\n/// @dev Thrown on attempting to use a non-ERC20 contract or an EOA as a token\\nerror IncorrectTokenContractException();\\n\\n/// @dev Thrown on attempting to set a token price feed to an address that is not a\\n///      correct price feed\\nerror IncorrectPriceFeedException();\\n\\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\\nerror CallerNotConfiguratorException();\\n\\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\\nerror CallerNotControllerException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Pausable admin\\nerror CallerNotPausableAdminException();\\n\\n/// @dev Thrown on attempting to pause a contract as a non-Unpausable admin\\nerror CallerNotUnPausableAdminException();\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/ILPPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { IPriceFeedType } from \\\"./IPriceFeedType.sol\\\";\\n\\ninterface ILPPriceFeedEvents {\\n    /// @dev Emits on updating the virtual price bounds\\n    event NewLimiterParams(uint256 lowerBound, uint256 upperBound);\\n}\\n\\ninterface ILPPriceFeedExceptions {\\n    /// @dev Thrown on returning a value that violates the current bounds\\n    error ValueOutOfRangeException();\\n\\n    /// @dev Thrown on failing sanity checks when setting new bounds\\n    error IncorrectLimitsException();\\n}\\n\\n/// @title Interface for LP PriceFeeds with limiter\\ninterface ILPPriceFeed is\\n    AggregatorV3Interface,\\n    IPriceFeedType,\\n    ILPPriceFeedEvents,\\n    ILPPriceFeedExceptions\\n{\\n    /// @dev Sets the lower and upper bounds for virtual price.\\n    /// @param _lowerBound The new lower bound\\n    /// @notice The upper bound is computed automatically\\n    function setLimiter(uint256 _lowerBound) external;\\n\\n    /// @dev Returns the lower bound\\n    function lowerBound() external view returns (uint256);\\n\\n    /// @dev Returns the upper bound\\n    function upperBound() external view returns (uint256);\\n\\n    /// @dev Returns the pre-defined window between the lower and upper bounds\\n    /// @notice In bp format\\n    function delta() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IPriceFeedType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { PriceFeedType } from \\\"@gearbox-protocol/integration-types/contracts/PriceFeedType.sol\\\";\\n\\ninterface IPriceFeedType {\\n    /// @dev Returns the price feed type\\n    function priceFeedType() external view returns (PriceFeedType);\\n\\n    /// @dev Returns whether sanity checks on price feed result should be skipped\\n    function skipPriceCheck() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IPriceOracleV2Events {\\n    /// @dev Emits when a new price feed is added\\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\\n}\\n\\ninterface IPriceOracleV2Exceptions {\\n    /// @dev Thrown if a price feed returns 0\\n    error ZeroPriceException();\\n\\n    /// @dev Thrown if the last recorded result was not updated in the last round\\n    error ChainPriceStaleException();\\n\\n    /// @dev Thrown on attempting to get a result for a token that does not have a price feed\\n    error PriceOracleNotExistsException();\\n}\\n\\n/// @title Price oracle interface\\ninterface IPriceOracleV2 is\\n    IPriceOracleV2Events,\\n    IPriceOracleV2Exceptions,\\n    IVersion\\n{\\n    /// @dev Converts a quantity of an asset to USD (decimals = 8).\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token to be converted\\n    function convertToUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts a quantity of USD (decimals = 8) to an equivalent amount of an asset\\n    /// @param amount Amount to convert\\n    /// @param token Address of the token converted to\\n    function convertFromUSD(uint256 amount, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Converts one asset into another\\n    ///\\n    /// @param amount Amount to convert\\n    /// @param tokenFrom Address of the token to convert from\\n    /// @param tokenTo Address of the token to convert to\\n    function convert(\\n        uint256 amount,\\n        address tokenFrom,\\n        address tokenTo\\n    ) external view returns (uint256);\\n\\n    /// @dev Returns collateral values for two tokens, required for a fast check\\n    /// @param amountFrom Amount of the outbound token\\n    /// @param tokenFrom Address of the outbound token\\n    /// @param amountTo Amount of the inbound token\\n    /// @param tokenTo Address of the inbound token\\n    /// @return collateralFrom Value of the outbound token amount in USD\\n    /// @return collateralTo Value of the inbound token amount in USD\\n    function fastCheck(\\n        uint256 amountFrom,\\n        address tokenFrom,\\n        uint256 amountTo,\\n        address tokenTo\\n    ) external view returns (uint256 collateralFrom, uint256 collateralTo);\\n\\n    /// @dev Returns token's price in USD (8 decimals)\\n    /// @param token The token to compute the price for\\n    function getPrice(address token) external view returns (uint256);\\n\\n    /// @dev Returns the price feed address for the passed token\\n    /// @param token Token to get the price feed for\\n    function priceFeeds(address token)\\n        external\\n        view\\n        returns (address priceFeed);\\n\\n    /// @dev Returns the price feed for the passed token,\\n    ///      with additional parameters\\n    /// @param token Token to get the price feed for\\n    function priceFeedsWithFlags(address token)\\n        external\\n        view\\n        returns (\\n            address priceFeed,\\n            bool skipCheck,\\n            uint256 decimals\\n        );\\n}\\n\\ninterface IPriceOracleV2Ext is IPriceOracleV2 {\\n    /// @dev Sets a price feed if it doesn't exist, or updates an existing one\\n    /// @param token Address of the token to set the price feed for\\n    /// @param priceFeed Address of a USD price feed adhering to Chainlink's interface\\n    function addPriceFeed(address token, address priceFeed) external;\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title IVersion\\n/// @dev Declares a version function which returns the contract's version\\ninterface IVersion {\\n    /// @dev Returns contract version\\n    function version() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n// Denominations\\n\\nuint256 constant WAD = 1e18;\\nuint256 constant RAY = 1e27;\\nuint16 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n\\n// 25% of type(uint256).max\\nuint256 constant ALLOWANCE_THRESHOLD = type(uint96).max >> 3;\\n\\n// FEE = 50%\\nuint16 constant DEFAULT_FEE_INTEREST = 50_00; // 50%\\n\\n// LIQUIDATION_FEE 1.5%\\nuint16 constant DEFAULT_FEE_LIQUIDATION = 1_50; // 1.5%\\n\\n// LIQUIDATION PREMIUM 4%\\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM = 4_00; // 4%\\n\\n// LIQUIDATION_FEE_EXPIRED 2%\\nuint16 constant DEFAULT_FEE_LIQUIDATION_EXPIRED = 1_00; // 2%\\n\\n// LIQUIDATION PREMIUM EXPIRED 2%\\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM_EXPIRED = 2_00; // 2%\\n\\n// DEFAULT PROPORTION OF MAX BORROWED PER BLOCK TO MAX BORROWED PER ACCOUNT\\nuint16 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\\n\\n// Seconds in a year\\nuint256 constant SECONDS_PER_YEAR = 365 days;\\nuint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = (SECONDS_PER_YEAR * 3) / 2;\\n\\n// OPERATIONS\\n\\n// Leverage decimals - 100 is equal to 2x leverage (100% * collateral amount + 100% * borrowed amount)\\nuint8 constant LEVERAGE_DECIMALS = 100;\\n\\n// Maximum withdraw fee for pool in PERCENTAGE_FACTOR format\\nuint8 constant MAX_WITHDRAW_FEE = 100;\\n\\nuint256 constant EXACT_INPUT = 1;\\nuint256 constant EXACT_OUTPUT = 2;\\n\\naddress constant UNIVERSAL_CONTRACT = 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC;\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title Errors library\\nlibrary Errors {\\n    //\\n    // COMMON\\n    //\\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \\\"Z0\\\";\\n    string public constant NOT_IMPLEMENTED = \\\"NI\\\";\\n    string public constant INCORRECT_PATH_LENGTH = \\\"PL\\\";\\n    string public constant INCORRECT_ARRAY_LENGTH = \\\"CR\\\";\\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \\\"CP\\\";\\n    string public constant REGISTERED_POOLS_ONLY = \\\"RP\\\";\\n    string public constant INCORRECT_PARAMETER = \\\"IP\\\";\\n\\n    //\\n    // MATH\\n    //\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"M1\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"M2\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"M3\\\";\\n\\n    //\\n    // POOL\\n    //\\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \\\"PS0\\\";\\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \\\"PS1\\\";\\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \\\"PS2\\\";\\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \\\"PS3\\\";\\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \\\"PS4\\\";\\n\\n    //\\n    // ACCOUNT FACTORY\\n    //\\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\\n        \\\"AF1\\\";\\n    string public constant AF_MINING_IS_FINISHED = \\\"AF2\\\";\\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \\\"AF3\\\";\\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \\\"AF4\\\";\\n\\n    //\\n    // ADDRESS PROVIDER\\n    //\\n    string public constant AS_ADDRESS_NOT_FOUND = \\\"AP1\\\";\\n\\n    //\\n    // CONTRACTS REGISTER\\n    //\\n    string public constant CR_POOL_ALREADY_ADDED = \\\"CR1\\\";\\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \\\"CR2\\\";\\n\\n    //\\n    // CREDIT ACCOUNT\\n    //\\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \\\"CA1\\\";\\n    string public constant CA_FACTORY_ONLY = \\\"CA2\\\";\\n\\n    //\\n    // ACL\\n    //\\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \\\"ACL1\\\";\\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \\\"ACL2\\\";\\n\\n    //\\n    // WETH GATEWAY\\n    //\\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \\\"WG1\\\";\\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \\\"WG2\\\";\\n    string public constant WG_NOT_ENOUGH_FUNDS = \\\"WG3\\\";\\n\\n    //\\n    // TOKEN DISTRIBUTOR\\n    //\\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \\\"TD1\\\";\\n    string public constant TD_INCORRECT_WEIGHTS = \\\"TD2\\\";\\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \\\"TD3\\\";\\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \\\"TD4\\\";\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/libraries/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.10;\\n\\nimport { Errors } from \\\"./Errors.sol\\\";\\nimport { PERCENTAGE_FACTOR } from \\\"./Constants.sol\\\";\\n\\nuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n    /**\\n     * @dev Executes a percentage multiplication\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The percentage of value\\n     **/\\n    function percentMul(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (value == 0 || percentage == 0) {\\n            return 0; // T:[PM-1]\\n        }\\n\\n        //        require(\\n        //            value <= (type(uint256).max - HALF_PERCENT) / percentage,\\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        //        ); // T:[PM-1]\\n\\n        return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; // T:[PM-1]\\n    }\\n\\n    /**\\n     * @dev Executes a percentage division\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The value divided the percentage\\n     **/\\n    function percentDiv(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[PM-2]\\n        uint256 halfPercentage = percentage / 2; // T:[PM-2]\\n\\n        //        require(\\n        //            value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        //        ); // T:[PM-2]\\n\\n        return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/oracles/LPPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { ILPPriceFeed } from \\\"../interfaces/ILPPriceFeed.sol\\\";\\nimport { PriceFeedChecker } from \\\"./PriceFeedChecker.sol\\\";\\nimport { ACLNonReentrantTrait } from \\\"../core/ACLNonReentrantTrait.sol\\\";\\nimport { PERCENTAGE_FACTOR } from \\\"../libraries/PercentageMath.sol\\\";\\n\\n// EXCEPTIONS\\nimport { NotImplementedException } from \\\"../interfaces/IErrors.sol\\\";\\n\\n/// @title Abstract PriceFeed for an LP token\\n/// @notice For most pools/vaults, the LP token price depends on Chainlink prices of pool assets and the pool's\\n/// internal exchange rate.\\nabstract contract LPPriceFeed is\\n    ILPPriceFeed,\\n    PriceFeedChecker,\\n    ACLNonReentrantTrait\\n{\\n    /// @dev The lower bound for the contract's token-to-underlying exchange rate.\\n    /// @notice Used to protect against LP token / share price manipulation.\\n    uint256 public lowerBound;\\n\\n    /// @dev Window size in PERCENTAGE format. Upper bound = lowerBound * (1 + delta)\\n    uint256 public immutable delta;\\n\\n    /// @dev Decimals of the returned result.\\n    uint8 public constant override decimals = 8;\\n\\n    /// @dev Price feed description\\n    string public override description;\\n\\n    /// @dev Constructor\\n    /// @param addressProvider Address of address provier which is use for getting ACL\\n    /// @param _delta Pre-defined window in PERCENTAGE FORMAT which is allowed for SC value\\n    /// @param _description Price feed description\\n    constructor(\\n        address addressProvider,\\n        uint256 _delta,\\n        string memory _description\\n    ) ACLNonReentrantTrait(addressProvider) {\\n        description = _description; // F:[LPF-1]\\n        delta = _delta; // F:[LPF-1]\\n    }\\n\\n    /// @dev Implemented for compatibility, but reverts since Gearbox's price feeds\\n    ///      do not store historical data.\\n    function getRoundData(uint80)\\n        external\\n        pure\\n        virtual\\n        override\\n        returns (\\n            uint80, // roundId,\\n            int256, // answer,\\n            uint256, // startedAt,\\n            uint256, // updatedAt,\\n            uint80 // answeredInRound\\n        )\\n    {\\n        revert NotImplementedException(); // F:[LPF-2]\\n    }\\n\\n    /// @dev Checks that value is in range [lowerBound; upperBound],\\n    /// Reverts if below lowerBound and returns min(value, upperBound)\\n    /// @param value Value to be checked and bounded\\n    function _checkAndUpperBoundValue(uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 lb = lowerBound;\\n        if (value < lb) revert ValueOutOfRangeException(); // F:[LPF-3]\\n\\n        uint256 uBound = _upperBound(lb);\\n\\n        return (value > uBound) ? uBound : value;\\n    }\\n\\n    /// @dev Updates the bounds for the exchange rate value\\n    /// @param _lowerBound The new lower bound (the upper bound is computed dynamically)\\n    ///                    from the lower bound\\n    function setLimiter(uint256 _lowerBound)\\n        external\\n        override\\n        controllerOnly // F:[LPF-4]\\n    {\\n        _setLimiter(_lowerBound); // F:[LPF-4,5]\\n    }\\n\\n    /// @dev IMPLEMENTATION: setLimiter\\n    function _setLimiter(uint256 _lowerBound) internal {\\n        if (\\n            _lowerBound == 0 ||\\n            !_checkCurrentValueInBounds(_lowerBound, _upperBound(_lowerBound))\\n        ) revert IncorrectLimitsException(); // F:[LPF-4]\\n\\n        lowerBound = _lowerBound; // F:[LPF-5]\\n        emit NewLimiterParams(lowerBound, _upperBound(_lowerBound)); // F:[LPF-5]\\n    }\\n\\n    function _upperBound(uint256 lb) internal view returns (uint256) {\\n        return (lb * (PERCENTAGE_FACTOR + delta)) / PERCENTAGE_FACTOR; // F:[LPF-5]\\n    }\\n\\n    /// @dev Returns the upper bound, calculated based on the lower bound\\n    function upperBound() external view returns (uint256) {\\n        return _upperBound(lowerBound); // F:[LPF-5]\\n    }\\n\\n    function _checkCurrentValueInBounds(\\n        uint256 _lowerBound,\\n        uint256 _upperBound\\n    ) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/core-v2/contracts/oracles/PriceFeedChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\nimport { IPriceOracleV2Exceptions } from \\\"../interfaces/IPriceOracle.sol\\\";\\n\\n/// @title Sanity checker for Chainlink price feed results\\ncontract PriceFeedChecker is IPriceOracleV2Exceptions {\\n    function _checkAnswer(\\n        uint80 roundID,\\n        int256 price,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    ) internal pure {\\n        if (price <= 0) revert ZeroPriceException(); // F:[PO-5]\\n        if (answeredInRound < roundID || updatedAt == 0)\\n            revert ChainPriceStaleException(); // F:[PO-5]\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integration-types/contracts/PriceFeedType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2023\\npragma solidity ^0.8.10;\\n\\n// NOTE: new values must always be added at the end of the enum\\n\\nenum PriceFeedType {\\n    CHAINLINK_ORACLE,\\n    YEARN_ORACLE,\\n    CURVE_2LP_ORACLE,\\n    CURVE_3LP_ORACLE,\\n    CURVE_4LP_ORACLE,\\n    ZERO_ORACLE,\\n    WSTETH_ORACLE,\\n    BOUNDED_ORACLE,\\n    COMPOSITE_ORACLE,\\n    AAVE_ORACLE,\\n    COMPOUND_ORACLE,\\n    BALANCER_STABLE_LP_ORACLE,\\n    BALANCER_WEIGHTED_LP_ORACLE,\\n    CURVE_CRYPTO_ORACLE,\\n    REDSTONE_ORACLE\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/integrations/balancer/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    // solhint-disable no-inline-assembly\\n\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant TWO = 2 * ONE;\\n    uint256 internal constant FOUR = 4 * ONE;\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * b) / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256 result) {\\n        uint256 product = a * b;\\n\\n        assembly {\\n            result := mul(iszero(iszero(product)), add(div(sub(product, 1), ONE), 1))\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a * ONE) / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256 result) {\\n        require(b != 0, \\\"zero division\\\");\\n\\n        uint256 aInflated = a * ONE;\\n\\n        assembly {\\n            result := mul(iszero(iszero(aInflated)), add(div(sub(aInflated, 1), b), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\\n        // and 80/20 Weighted Pools\\n        if (y == ONE) {\\n            return x;\\n        } else if (y == TWO) {\\n            return mulDown(x, x);\\n        } else if (y == FOUR) {\\n            uint256 square = mulDown(x, x);\\n            return mulDown(square, square);\\n        } else {\\n            uint256 raw = LogExpMath.pow(x, y);\\n            uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n            if (raw < maxError) {\\n                return 0;\\n            } else {\\n                return sub(raw, maxError);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\\n        // and 80/20 Weighted Pools\\n        if (y == ONE) {\\n            return x;\\n        } else if (y == TWO) {\\n            return mulUp(x, x);\\n        } else if (y == FOUR) {\\n            uint256 square = mulUp(x, x);\\n            return mulUp(square, square);\\n        } else {\\n            uint256 raw = LogExpMath.pow(x, y);\\n            uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n            return add(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mul(lt(x, ONE), sub(ONE, x))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/integrations/balancer/LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.0;\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2 ** 254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x >> 255 == 0, \\\"x out of bounds\\\");\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, \\\"y out of bounds\\\");\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT, \\\"product out of bounds\\\"\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        unchecked {\\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \\\"invalid exponent\\\");\\n\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        unchecked {\\n            // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n            // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n            // upscaling.\\n\\n            int256 logBase;\\n            if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n                logBase = _ln_36(base);\\n            } else {\\n                logBase = _ln(base) * ONE_18;\\n            }\\n\\n            int256 logArg;\\n            if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n                logArg = _ln_36(arg);\\n            } else {\\n                logArg = _ln(arg) * ONE_18;\\n            }\\n\\n            // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n            return (logArg * ONE_18) / logBase;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, \\\"out of bounds\\\");\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/integrations/curve/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface ICurvePool {\\n    function coins(uint256 i) external view returns (address);\\n\\n    function underlying_coins(uint256 i) external view returns (address);\\n\\n    function balances(uint256 i) external view returns (uint256);\\n\\n    function coins(int128) external view returns (address);\\n\\n    function underlying_coins(int128) external view returns (address);\\n\\n    function balances(int128) external view returns (uint256);\\n\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\n\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\\n\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\n\\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\\n\\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n    function get_dy_underlying(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\\n\\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\\n\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function virtual_price() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\\n\\n    function remove_liquidity_one_coin(uint256 _token_amount, uint256 i, uint256 min_amount) external;\\n\\n    function A() external view returns (uint256);\\n\\n    function A_precise() external view returns (uint256);\\n\\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\\n\\n    function calc_withdraw_one_coin(uint256 _burn_amount, uint256 i) external view returns (uint256);\\n\\n    function admin_balances(uint256 i) external view returns (uint256);\\n\\n    function admin() external view returns (address);\\n\\n    function fee() external view returns (uint256);\\n\\n    function admin_fee() external view returns (uint256);\\n\\n    function block_timestamp_last() external view returns (uint256);\\n\\n    function initial_A() external view returns (uint256);\\n\\n    function future_A() external view returns (uint256);\\n\\n    function initial_A_time() external view returns (uint256);\\n\\n    function future_A_time() external view returns (uint256);\\n\\n    function mid_fee() external view returns (uint256);\\n\\n    // Some pools implement ERC20\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint256);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/oracles/curve/AbstractCurveLPPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2023\\npragma solidity ^0.8.17;\\n\\nimport {LPPriceFeed} from \\\"../LPPriceFeed.sol\\\";\\nimport {ICurvePool} from \\\"../../integrations/curve/ICurvePool.sol\\\";\\n\\n// EXCEPTIONS\\nimport {\\n    ZeroAddressException, NotImplementedException\\n} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol\\\";\\n\\nuint256 constant RANGE_WIDTH = 200; // 2%\\n\\n/// @title Abstract CurveLP pricefeed\\nabstract contract AbstractCurveLPPriceFeed is LPPriceFeed {\\n    /// @dev The Curve pool associated with the evaluated LP token\\n    ICurvePool public immutable curvePool;\\n\\n    /// @dev Format of pool's virtual_price\\n    int256 public immutable decimalsDivider;\\n\\n    /// @dev Contract version\\n    uint256 public constant override version = 1;\\n\\n    /// @dev Whether to skip price sanity checks.\\n    /// @notice Always set to true for LP price feeds,\\n    ///         since they perform their own sanity checks\\n    bool public constant override skipPriceCheck = true;\\n\\n    constructor(address addressProvider, address _curvePool, string memory _description)\\n        LPPriceFeed(addressProvider, RANGE_WIDTH, _description)\\n    {\\n        if (_curvePool == address(0)) revert ZeroAddressException();\\n\\n        curvePool = ICurvePool(_curvePool); // F:[OCLP-1]\\n        decimalsDivider = 10 ** 18;\\n\\n        uint256 virtualPrice = ICurvePool(_curvePool).get_virtual_price();\\n        _setLimiter(virtualPrice);\\n    }\\n\\n    function _checkCurrentValueInBounds(uint256 _lowerBound, uint256 _upperBound)\\n        internal\\n        view\\n        override\\n        returns (bool)\\n    {\\n        uint256 virtualPrice = curvePool.get_virtual_price();\\n        if (virtualPrice < _lowerBound || virtualPrice > _upperBound) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/oracles/curve/CurveCryptoLPPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2023\\npragma solidity ^0.8.17;\\n\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {AbstractCurveLPPriceFeed} from \\\"./AbstractCurveLPPriceFeed.sol\\\";\\n\\nimport {PriceFeedType} from \\\"../LPPriceFeed.sol\\\";\\nimport {FixedPoint} from \\\"../../integrations/balancer/FixedPoint.sol\\\";\\n\\n// EXCEPTIONS\\nimport {ZeroAddressException} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol\\\";\\n\\nuint256 constant DECIMALS = 10 ** 18;\\nuint256 constant USD_FEED_DECIMALS = 10 ** 8;\\n\\n/// @title CurveLP price feed for crypto pools\\ncontract CurveCryptoLPPriceFeed is AbstractCurveLPPriceFeed {\\n    using FixedPoint for uint256;\\n\\n    /// @dev Price feed of coin 0 in the pool\\n    AggregatorV3Interface public immutable priceFeed1;\\n\\n    /// @dev Price feed of coin 1 in the pool\\n    AggregatorV3Interface public immutable priceFeed2;\\n\\n    /// @dev Price feed of coin 2 in the pool\\n    AggregatorV3Interface public immutable priceFeed3;\\n\\n    /// @dev Number of coins in the pool (2 or 3)\\n    uint16 public immutable nCoins;\\n\\n    PriceFeedType public constant override priceFeedType = PriceFeedType.CURVE_CRYPTO_ORACLE;\\n\\n    constructor(\\n        address addressProvider,\\n        address _curvePool,\\n        address _priceFeed1,\\n        address _priceFeed2,\\n        address _priceFeed3,\\n        string memory _description\\n    ) AbstractCurveLPPriceFeed(addressProvider, _curvePool, _description) {\\n        if (_priceFeed1 == address(0) || _priceFeed2 == address(0)) {\\n            revert ZeroAddressException();\\n        }\\n\\n        priceFeed1 = AggregatorV3Interface(_priceFeed1);\\n        priceFeed2 = AggregatorV3Interface(_priceFeed2);\\n        priceFeed3 = AggregatorV3Interface(_priceFeed3);\\n\\n        nCoins = _priceFeed3 == address(0) ? 2 : 3;\\n    }\\n\\n    /// @dev Returns the USD price of Curve Tricrypto pool's LP token\\n    /// @notice Computes the LP token price as n * (prod_i(price(coin_i)))^(1/n) * virtual_price()\\n    function latestRoundData()\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        uint80 roundIdCurrent;\\n        int256 answerCurrent;\\n        uint256 updatedAtCurrent;\\n        uint80 answeredInRoundCurrent;\\n\\n        (roundId, answerCurrent, startedAt, updatedAt, answeredInRound) = priceFeed1.latestRoundData();\\n\\n        // Sanity check for the Chainlink pricefeed\\n        _checkAnswer(roundId, answerCurrent, updatedAt, answeredInRound);\\n\\n        uint256 product = uint256(answerCurrent) * DECIMALS / USD_FEED_DECIMALS;\\n\\n        (roundIdCurrent, answerCurrent,, updatedAtCurrent, answeredInRoundCurrent) = priceFeed2.latestRoundData();\\n\\n        // Sanity check for the Chainlink pricefeed\\n        _checkAnswer(roundIdCurrent, answerCurrent, updatedAtCurrent, answeredInRoundCurrent);\\n\\n        product = product.mulDown(uint256(answerCurrent) * DECIMALS / USD_FEED_DECIMALS);\\n\\n        if (nCoins == 3) {\\n            (roundIdCurrent, answerCurrent,, updatedAtCurrent, answeredInRoundCurrent) = priceFeed3.latestRoundData();\\n\\n            // Sanity check for the Chainlink pricefeed\\n            _checkAnswer(roundIdCurrent, answerCurrent, updatedAtCurrent, answeredInRoundCurrent);\\n\\n            product = product.mulDown(uint256(answerCurrent) * DECIMALS / USD_FEED_DECIMALS);\\n        }\\n\\n        uint256 virtualPrice = curvePool.virtual_price();\\n\\n        // Checks that virtual_price is within bounds\\n        virtualPrice = _checkAndUpperBoundValue(virtualPrice);\\n\\n        answer = int256(product.powDown(DECIMALS / nCoins).mulDown(nCoins * virtualPrice));\\n\\n        answer = answer * int256(USD_FEED_DECIMALS) / int256(DECIMALS);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gearbox-protocol/integrations-v3/contracts/oracles/LPPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2023\\npragma solidity ^0.8.17;\\n\\nimport {PriceFeedType} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IPriceFeedType.sol\\\";\\nimport {LPPriceFeed} from \\\"@gearbox-protocol/core-v2/contracts/oracles/LPPriceFeed.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curvePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed3\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotConfiguratorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotControllerException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotPausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotUnPausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChainPriceStaleException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectLimitsException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotImplementedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceOracleNotExistsException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueOutOfRangeException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroPriceException\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"NewController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lowerBound\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upperBound\",\"type\":\"uint256\"}],\"name\":\"NewLimiterParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_acl\",\"outputs\":[{\"internalType\":\"contract IACL\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimalsDivider\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"externalController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowerBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nCoins\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed1\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed2\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed3\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedType\",\"outputs\":[{\"internalType\":\"enum PriceFeedType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lowerBound\",\"type\":\"uint256\"}],\"name\":\"setLimiter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skipPriceCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upperBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CurveCryptoLPPriceFeed", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000cf64698aff7e5f27a11dff868af228653ba53be0000000000000000000000000fc1e8bf3e81383ef07be24c3fd146745719de48d0000000000000000000000004db228fb6f9ce91a966c347e17881ba7ea26b13700000000000000000000000008aec6d32c8e24ec6a672ddff80f17fb7d24feb9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000135052494345464545445f4f484d46524158425000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}