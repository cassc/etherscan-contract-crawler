{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ISafeswapRouter01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface ISafeSwapRouter is ISafeswapRouter01 {\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IFeeJar {\r\n    function fee() external payable;\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\ncontract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            _initializing || _isConstructor() || !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function decimals() external pure returns (uint8);\r\n}\r\n\r\ninterface ISafeswapFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface ISafeswapPair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function sync() external;\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        );\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{ value: value }(new bytes(0));\r\n        require(success, \"SafeSwapTradeRouter::safeTransferETH: ETH transfer failed\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SafeSwapTradeRouter::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SafeSwapTradeRouter::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SafeSwapTradeRouter::safeApprove: approve failed\"\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeSwapTradeRouter\r\n * @dev Allows SFM Router-compliant trades to be paid via bsc\r\n */\r\ncontract SafeSwapTradeRouter is Initializable {\r\n    /// @notice Receive function to allow contract to accept BNB\r\n    receive() external payable {}\r\n\r\n    /// @notice Fallback function in case receive function is not matched\r\n    fallback() external payable {}\r\n\r\n    /// @notice FeepJar proxy\r\n    IFeeJar public feeJar;\r\n    address public swapRouter;\r\n    address public admin;\r\n    uint256 public percent;\r\n    uint256 public feePercent;\r\n    mapping(address => bool) public whitelistFfsFee;\r\n\r\n    mapping(address => mapping(TransactionType => TokenFee)) private tokensFeeList;\r\n    address[] private tokenFeeAddresses;\r\n\r\n    mapping(address => AdaptiveLpPriceRange) private adaptiveLpPriceRange;\r\n    bool public isARCBEnabled;\r\n\r\n    uint256 private constant LP_PRICE_BASE_AMOUNT = 6;\r\n\r\n    event NewFeeJar(address indexed _feeJar);\r\n    event SetTokenFeeStatus(address indexed _tokenAddress, TransactionType _transactionType, bool _isEnabled);\r\n    event SetTokenDeletionStatus(address indexed _tokenAddress, TransactionType _transactionType, bool _status);\r\n    event SubmitLpPriceRange(address indexed _pair, uint256 indexed _upl, uint256 indexed _lpl, uint256 _lastPrice);\r\n    event SetLpPriceRangeStatus(address indexed _pair, bool _isEnabled);\r\n    event SetARCBStatus(bool _isARCBEnabled);\r\n    event SetTokenSwapFeeStatus(\r\n        address indexed _tokenAddress,\r\n        TransactionType _transactionType,\r\n        bool _isEnabled,\r\n        uint256 indexed _index\r\n    );\r\n    event SubmitTokenSwapFee(\r\n        address indexed _tokenAddress,\r\n        TransactionType _transactionType,\r\n        uint256 _tokenFeePercentage,\r\n        SwapKind _swapKind,\r\n        address indexed _assetOut,\r\n        address indexed _beneficiary,\r\n        uint256 swapFeePercentage,\r\n        bool isEnabled\r\n    );\r\n    event TokenFeeSwapped(\r\n        address indexed _beneficiary,\r\n        address indexed _assetIn,\r\n        address indexed _assetOut,\r\n        uint256 _feeAmount\r\n    );\r\n\r\n    /// @notice Trade details\r\n    struct Trade {\r\n        uint256 amountIn;\r\n        uint256 amountOut;\r\n        address[] path;\r\n        address payable to;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice TMI details\r\n    struct TokenFee {\r\n        TokenInfo tokenInfo;\r\n        SingleSwapFee[] singleSwapFees;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        TransactionType transactionType;\r\n        address tokenAddress;\r\n        uint256 feePercentage;\r\n        bool isEnabled;\r\n        bool isDeleted;\r\n    }\r\n\r\n    /// @notice adaptive Lp Price Range details\r\n    struct AdaptiveLpPriceRange {\r\n        address tokenAddress;\r\n        uint256 lastPrice;\r\n        uint256 upl;\r\n        uint256 lpl;\r\n        bool isEnabled;\r\n    }\r\n\r\n    enum SwapKind {\r\n        SEND_ONLY,\r\n        SWAP_AND_SEND,\r\n        SWAP_AND_BURN\r\n    }\r\n\r\n    enum FeeKind {\r\n        TOKEN_FEE,\r\n        PORTAL_FEE\r\n    }\r\n\r\n    enum TransactionType {\r\n        SELL,\r\n        BUY\r\n    }\r\n\r\n    /// @notice FM details\r\n    struct SingleSwapFee {\r\n        SwapKind swapKind;\r\n        address assetOut;\r\n        address beneficiary;\r\n        uint256 percentage;\r\n        bool isEnabled;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(admin == msg.sender, \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function _isSwapRangeValid(address[] memory _path) private {\r\n        require(_isLpsPriceInRange(_path), \"SafeswapRouter: Transaction rejected by ARC-B\");\r\n    }\r\n\r\n    function _isTokenInfoDeleted(bool _isTokenDeleted) private pure {\r\n        require(_isTokenDeleted == false, \"SafeSwapTradeRouter: Token already deleted\");\r\n    }\r\n\r\n    function _isValidAdd(address _address) private pure {\r\n        require(_address != address(0), \"SafeSwapTradeRouter: Token does not exist\");\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    modifier isSwapRangeValid(address[] memory _path) {\r\n        _isSwapRangeValid(_path);\r\n        _;\r\n    }\r\n\r\n    modifier isTokenInfoDelted(bool _isTokenDeleted) {\r\n        _isTokenInfoDeleted(_isTokenDeleted);\r\n        _;\r\n    }\r\n\r\n    modifier isValidAdd(address _address) {\r\n        _isValidAdd(_address);\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _feeJar,\r\n        address _router,\r\n        uint256 _feePercent,\r\n        uint256 _percent\r\n    ) external initializer {\r\n        feeJar = IFeeJar(_feeJar);\r\n        swapRouter = _router;\r\n        admin = msg.sender;\r\n        feePercent = _feePercent;\r\n        percent = _percent;\r\n        isARCBEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * @notice set SFM router address\r\n     * @param _router Address of SFM Router contract\r\n     */\r\n    function setRouter(address _router) external onlyOwner {\r\n        swapRouter = _router;\r\n    }\r\n\r\n    function setAdmin(address _admin) external onlyOwner {\r\n        admin = _admin;\r\n    }\r\n\r\n    function setFeePercent(uint256 _feePercent) external onlyOwner {\r\n        feePercent = _feePercent;\r\n    }\r\n\r\n    function sePercent(uint256 _percent) external onlyOwner {\r\n        percent = _percent;\r\n    }\r\n\r\n    function addFfsWhitelist(address _wl) external onlyOwner {\r\n        whitelistFfsFee[_wl] = true;\r\n    }\r\n\r\n    function removeFfsWhitelist(address _wl) external onlyOwner {\r\n        whitelistFfsFee[_wl] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice set feeJar address\r\n     * @param _feeJar Address of FeeJar contract\r\n     */\r\n    function setFeeJar(address _feeJar) external onlyOwner {\r\n        feeJar = IFeeJar(_feeJar);\r\n        emit NewFeeJar(_feeJar);\r\n    }\r\n\r\n    function submitLpPriceRange(\r\n        address _pair,\r\n        uint256 _upl,\r\n        uint256 _lpl\r\n    ) external onlyOwner {\r\n        _submitLpPriceRange(_pair, _upl, _lpl);\r\n    }\r\n\r\n    function resetLpLastPrice(address _pair) external onlyOwner isValidAdd(adaptiveLpPriceRange[_pair].tokenAddress) {\r\n        ISafeswapPair(_pair).sync();\r\n        adaptiveLpPriceRange[_pair].lastPrice = _getLPPrice(\r\n            ISafeswapPair(_pair).token0(),\r\n            ISafeswapPair(_pair).token1()\r\n        );\r\n        emit SubmitLpPriceRange(\r\n            _pair,\r\n            adaptiveLpPriceRange[_pair].upl,\r\n            adaptiveLpPriceRange[_pair].lpl,\r\n            adaptiveLpPriceRange[_pair].lastPrice\r\n        );\r\n    }\r\n\r\n    function switchARCBActivation() external onlyOwner {\r\n        isARCBEnabled = !isARCBEnabled;\r\n        emit SetARCBStatus(isARCBEnabled);\r\n    }\r\n\r\n    function switchLpPriceRangeActivation(address _pair)\r\n        external\r\n        onlyOwner\r\n        isValidAdd(adaptiveLpPriceRange[_pair].tokenAddress)\r\n    {\r\n        adaptiveLpPriceRange[_pair].isEnabled = !adaptiveLpPriceRange[_pair].isEnabled;\r\n\r\n        emit SetLpPriceRangeStatus(_pair, adaptiveLpPriceRange[_pair].isEnabled);\r\n    }\r\n\r\n    function updateLpPriceRange(\r\n        address _pair,\r\n        uint256 _upl,\r\n        uint256 _lpl\r\n    ) external onlyOwner isValidAdd(adaptiveLpPriceRange[_pair].tokenAddress) {\r\n        adaptiveLpPriceRange[_pair].lpl = _lpl;\r\n        adaptiveLpPriceRange[_pair].upl = _upl;\r\n        emit SubmitLpPriceRange(_pair, _upl, _lpl, adaptiveLpPriceRange[_pair].lastPrice);\r\n    }\r\n\r\n    function getLpPriceRangeInfo(address _pair) external view returns (AdaptiveLpPriceRange memory) {\r\n        return adaptiveLpPriceRange[_pair];\r\n    }\r\n\r\n    function submitTokenSwapFee(\r\n        address _tokenAddress,\r\n        TransactionType _transactionType,\r\n        SingleSwapFee memory _singleSwapFee\r\n    ) external onlyOwner {\r\n        uint256 feePercentage = tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage;\r\n        require(\r\n            (feePercentage + _singleSwapFee.percentage) <= (percent - feePercent),\r\n            \"SafeSwapTradeRouter: FeePercentage >100%\"\r\n        );\r\n\r\n        if (tokensFeeList[_tokenAddress][_transactionType].tokenInfo.tokenAddress == address(0)) {\r\n            if (\r\n                !tokensFeeList[_tokenAddress][TransactionType.BUY].tokenInfo.isEnabled &&\r\n                !tokensFeeList[_tokenAddress][TransactionType.SELL].tokenInfo.isEnabled\r\n            ) {\r\n                tokenFeeAddresses.push(_tokenAddress);\r\n            }\r\n            TokenFee storage _tokenFee = tokensFeeList[_tokenAddress][_transactionType];\r\n            _tokenFee.singleSwapFees.push(\r\n                SingleSwapFee(\r\n                    _singleSwapFee.swapKind,\r\n                    _singleSwapFee.assetOut,\r\n                    _singleSwapFee.beneficiary,\r\n                    _singleSwapFee.percentage,\r\n                    _singleSwapFee.isEnabled\r\n                )\r\n            );\r\n            _tokenFee.tokenInfo = TokenInfo(\r\n                _transactionType,\r\n                _tokenAddress,\r\n                (feePercentage + _singleSwapFee.percentage),\r\n                true,\r\n                false\r\n            );\r\n        } else {\r\n            tokensFeeList[_tokenAddress][_transactionType].singleSwapFees.push(\r\n                SingleSwapFee(\r\n                    _singleSwapFee.swapKind,\r\n                    _singleSwapFee.assetOut,\r\n                    _singleSwapFee.beneficiary,\r\n                    _singleSwapFee.percentage,\r\n                    _singleSwapFee.isEnabled\r\n                )\r\n            );\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage += _singleSwapFee.percentage;\r\n        }\r\n        emit SubmitTokenSwapFee(\r\n            _tokenAddress,\r\n            _transactionType,\r\n            feePercentage,\r\n            _singleSwapFee.swapKind,\r\n            _singleSwapFee.assetOut,\r\n            _singleSwapFee.beneficiary,\r\n            _singleSwapFee.percentage,\r\n            _singleSwapFee.isEnabled\r\n        );\r\n    }\r\n\r\n    function updateTokenSwapFee(\r\n        address _tokenAddress,\r\n        TransactionType _transactionType,\r\n        SingleSwapFee memory _singleSwapFee,\r\n        uint256 _index\r\n    ) external onlyOwner isValidAdd(tokensFeeList[_tokenAddress][_transactionType].tokenInfo.tokenAddress) {\r\n        require(\r\n            tokensFeeList[_tokenAddress][_transactionType].singleSwapFees[_index].isEnabled,\r\n            \"SafeSwapTradeRouter: Token's swap fee not active\"\r\n        );\r\n        require(\r\n            _index < tokensFeeList[_tokenAddress][_transactionType].singleSwapFees.length,\r\n            \"SafeSwapTradeRouter: Invalid index\"\r\n        );\r\n        require(\r\n            (tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage +\r\n                _singleSwapFee.percentage -\r\n                tokensFeeList[_tokenAddress][_transactionType].singleSwapFees[_index].percentage) <=\r\n                (percent - feePercent),\r\n            \"SafeSwapTradeRouter: FeePercentage >100%\"\r\n        );\r\n\r\n        tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage -= tokensFeeList[_tokenAddress][\r\n            _transactionType\r\n        ].singleSwapFees[_index].percentage;\r\n        tokensFeeList[_tokenAddress][_transactionType].singleSwapFees[_index] = SingleSwapFee(\r\n            _singleSwapFee.swapKind,\r\n            _singleSwapFee.assetOut,\r\n            _singleSwapFee.beneficiary,\r\n            _singleSwapFee.percentage,\r\n            _singleSwapFee.isEnabled\r\n        );\r\n        tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage += _singleSwapFee.percentage;\r\n\r\n        emit SubmitTokenSwapFee(\r\n            _tokenAddress,\r\n            _transactionType,\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage,\r\n            _singleSwapFee.swapKind,\r\n            _singleSwapFee.assetOut,\r\n            _singleSwapFee.beneficiary,\r\n            _singleSwapFee.percentage,\r\n            _singleSwapFee.isEnabled\r\n        );\r\n    }\r\n\r\n    function switchTokenDeletion(address _tokenAddress, TransactionType _transactionType)\r\n        external\r\n        onlyOwner\r\n        isValidAdd(tokensFeeList[_tokenAddress][_transactionType].tokenInfo.tokenAddress)\r\n    {\r\n        tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isDeleted = !tokensFeeList[_tokenAddress][\r\n            _transactionType\r\n        ].tokenInfo.isDeleted;\r\n\r\n        tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isEnabled = !tokensFeeList[_tokenAddress][\r\n            _transactionType\r\n        ].tokenInfo.isEnabled;\r\n\r\n        emit SetTokenDeletionStatus(\r\n            _tokenAddress,\r\n            _transactionType,\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isDeleted\r\n        );\r\n    }\r\n\r\n    function switchTokenActivation(address _tokenAddress, TransactionType _transactionType)\r\n        external\r\n        onlyOwner\r\n        isTokenInfoDelted(tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isDeleted)\r\n    {\r\n        tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isEnabled = !tokensFeeList[_tokenAddress][\r\n            _transactionType\r\n        ].tokenInfo.isEnabled;\r\n\r\n        emit SetTokenFeeStatus(\r\n            _tokenAddress,\r\n            _transactionType,\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isEnabled\r\n        );\r\n    }\r\n\r\n    function switchSingleSwapActivation(\r\n        address _tokenAddress,\r\n        TransactionType _transactionType,\r\n        uint256 _index\r\n    ) external onlyOwner isTokenInfoDelted(tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isDeleted) {\r\n        require(\r\n            _index < tokensFeeList[_tokenAddress][_transactionType].singleSwapFees.length,\r\n            \"SafeSwapTradeRouter: Invalid index\"\r\n        );\r\n\r\n        if (tokensFeeList[_tokenAddress][_transactionType].singleSwapFees[_index].isEnabled) {\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage -= tokensFeeList[_tokenAddress][\r\n                _transactionType\r\n            ].singleSwapFees[_index].percentage;\r\n        } else {\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.feePercentage += tokensFeeList[_tokenAddress][\r\n                _transactionType\r\n            ].singleSwapFees[_index].percentage;\r\n        }\r\n\r\n        tokensFeeList[_tokenAddress][_transactionType].singleSwapFees[_index].isEnabled = !tokensFeeList[_tokenAddress][\r\n            _transactionType\r\n        ].singleSwapFees[_index].isEnabled;\r\n\r\n        emit SetTokenSwapFeeStatus(\r\n            _tokenAddress,\r\n            _transactionType,\r\n            tokensFeeList[_tokenAddress][_transactionType].tokenInfo.isEnabled,\r\n            _index\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the tokens fee information list.\r\n     * @return the tokens fee information list\r\n     */\r\n    function getTokenFeeAddresses() external view returns (address[] memory) {\r\n        return tokenFeeAddresses;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token swap fee information for a given identifier.\r\n     * @return the token fee information\r\n     */\r\n    function getTokenInfoDetails(address _tokenAddress, TransactionType _transactionType)\r\n        external\r\n        view\r\n        returns (TokenFee memory)\r\n    {\r\n        return tokensFeeList[_tokenAddress][_transactionType];\r\n    }\r\n\r\n    /**\r\n     * @notice Swap tokens for BNB and pay amount of BNB as fee\r\n     * @param trade Trade details\r\n     */\r\n    function swapExactTokensForETHAndFeeAmount(Trade memory trade) external payable isSwapRangeValid(trade.path) {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, uint256 tokenAFee, ) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(msg.value >= dexFee, \"SafeswapRouter: You must send enough BNB to cover fee\");\r\n\r\n        _feeAmountBNB(address(this).balance);\r\n\r\n        if (tokenAFee > 0) {\r\n            _claimTokenFee(trade.path[0], msg.sender, TransactionType.SELL, trade.amountIn, tokenAFee, false);\r\n            _swapExactTokensForETH(\r\n                _getContractBalance(trade.path[0]),\r\n                trade.amountOut,\r\n                trade.path,\r\n                address(this),\r\n                trade.to,\r\n                trade.deadline\r\n            );\r\n        } else {\r\n            _swapExactTokensForETH(trade.amountIn, trade.amountOut, trade.path, msg.sender, trade.to, trade.deadline);\r\n        }\r\n\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap tokens for BNB and pay amount of BNB as fee\r\n     * @param trade Trade details\r\n     */\r\n    function swapTokensForExactETHAndFeeAmount(Trade memory trade) external payable isSwapRangeValid(trade.path) {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, uint256 tokenAFee, ) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(msg.value >= dexFee, \"SafeswapRouter: You must send enough BNB to cover fee\");\r\n        _feeAmountBNB(address(this).balance);\r\n\r\n        if (tokenAFee > 0) {\r\n            _claimTokenFee(trade.path[0], msg.sender, TransactionType.SELL, trade.amountIn, tokenAFee, false);\r\n            _swapTokensForExactETH(\r\n                _getAmountsOut(_getContractBalance(trade.path[0]), trade.path),\r\n                _getContractBalance(trade.path[0]),\r\n                trade.path,\r\n                address(this),\r\n                trade.to,\r\n                trade.deadline\r\n            );\r\n        } else {\r\n            _swapTokensForExactETH(trade.amountOut, trade.amountIn, trade.path, msg.sender, trade.to, trade.deadline);\r\n        }\r\n\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap BNB for tokens and pay % of BNB input as fee\r\n     * @param trade Trade details\r\n     * @param _feeAmount Fee value\r\n     */\r\n    function swapExactETHForTokensWithFeeAmount(Trade memory trade, uint256 _feeAmount)\r\n        external\r\n        payable\r\n        isSwapRangeValid(trade.path)\r\n    {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, , uint256 tokenBFee) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(\r\n            _feeAmount >= dexFee && (msg.value >= trade.amountIn + dexFee),\r\n            \"SafeswapRouter: You must send enough BNB to cover fee \"\r\n        );\r\n        _distributeTokenFee(trade.path[trade.path.length - 1], TransactionType.BUY, tokenBFee);\r\n        _feeAmountBNB(dexFee);\r\n\r\n        _swapExactETHForTokens((trade.amountIn - tokenBFee), trade.amountOut, trade.path, trade.to, trade.deadline);\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap BNB for tokens and pay amount of BNB input as fee\r\n     * @param trade Trade details\r\n     * @param _feeAmount Fee value\r\n     */\r\n    function swapETHForExactTokensWithFeeAmount(Trade memory trade, uint256 _feeAmount)\r\n        external\r\n        payable\r\n        isSwapRangeValid(trade.path)\r\n    {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, , uint256 tokenBFee) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(\r\n            _feeAmount >= dexFee && (msg.value >= trade.amountIn + dexFee),\r\n            \"SafeswapRouter: You must send enough BNB to cover fee \"\r\n        );\r\n        _distributeTokenFee(trade.path[trade.path.length - 1], TransactionType.BUY, tokenBFee);\r\n        _feeAmountBNB(dexFee);\r\n\r\n        _swapETHForExactTokens(trade.amountOut, (trade.amountIn - tokenBFee), trade.path, trade.to, trade.deadline);\r\n\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap tokens for tokens and pay BNB amount as fee\r\n     * @param trade Trade details\r\n     */\r\n    function swapExactTokensForTokensWithFeeAmount(Trade memory trade) external payable isSwapRangeValid(trade.path) {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, uint256 tokenAFee, uint256 tokenBFee) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(msg.value >= dexFee, \"SafeswapRouter: You must send enough BNB to cover fee\");\r\n        _feeAmountBNB(address(this).balance);\r\n\r\n        if (tokenAFee > 0) {\r\n            _claimTokenFee(trade.path[0], msg.sender, TransactionType.SELL, trade.amountIn, tokenAFee, false);\r\n        }\r\n\r\n        if (tokenBFee > 0) {\r\n            if (tokenAFee == 0) {\r\n                TransferHelper.safeTransferFrom(trade.path[0], msg.sender, address(this), trade.amountIn);\r\n                TransferHelper.safeApprove(trade.path[0], address(swapRouter), _getContractBalance(trade.path[0]));\r\n            }\r\n\r\n            _swapExactTokensForTokens(\r\n                _getContractBalance(trade.path[0]),\r\n                trade.amountOut,\r\n                trade.path,\r\n                address(this),\r\n                address(this),\r\n                trade.deadline\r\n            );\r\n            _claimTokenFee(\r\n                trade.path[trade.path.length - 1],\r\n                trade.to,\r\n                TransactionType.BUY,\r\n                trade.amountOut,\r\n                tokenBFee,\r\n                true\r\n            );\r\n        } else {\r\n            if (tokenAFee > 0) {\r\n                _swapExactTokensForTokens(\r\n                    _getContractBalance(trade.path[0]),\r\n                    trade.amountOut,\r\n                    trade.path,\r\n                    address(this),\r\n                    trade.to,\r\n                    trade.deadline\r\n                );\r\n            } else {\r\n                _swapExactTokensForTokens(\r\n                    trade.amountIn,\r\n                    trade.amountOut,\r\n                    trade.path,\r\n                    msg.sender,\r\n                    trade.to,\r\n                    trade.deadline\r\n                );\r\n            }\r\n        }\r\n\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap tokens for tokens and pay BNB amount as fee\r\n     * @param trade Trade details\r\n     */\r\n    function swapTokensForExactTokensWithFeeAmount(Trade memory trade) external payable isSwapRangeValid(trade.path) {\r\n        uint256[] memory lastLpsPrices = _calcLpsLastPrice(trade.path);\r\n\r\n        (, uint256 dexFee, uint256 tokenAFee, uint256 tokenBFee) = getFees(trade.path, trade.amountIn, msg.sender);\r\n        require(msg.value >= dexFee, \"SafeswapRouter: You must send enough BNB to cover fee\");\r\n        _feeAmountBNB(address(this).balance);\r\n\r\n        if (tokenAFee > 0) {\r\n            _claimTokenFee(trade.path[0], msg.sender, TransactionType.SELL, trade.amountIn, tokenAFee, false);\r\n        }\r\n\r\n        if (tokenBFee > 0) {\r\n            if (tokenAFee == 0) {\r\n                TransferHelper.safeTransferFrom(trade.path[0], msg.sender, address(this), trade.amountIn);\r\n                TransferHelper.safeApprove(trade.path[0], address(swapRouter), _getContractBalance(trade.path[0]));\r\n            }\r\n            _swapTokensForExactTokens(\r\n                trade.amountOut,\r\n                _getContractBalance(trade.path[0]),\r\n                trade.path,\r\n                address(this),\r\n                address(this),\r\n                trade.deadline\r\n            );\r\n            _claimTokenFee(\r\n                trade.path[trade.path.length - 1],\r\n                trade.to,\r\n                TransactionType.BUY,\r\n                trade.amountOut,\r\n                tokenBFee,\r\n                true\r\n            );\r\n        } else {\r\n            if (tokenAFee > 0) {\r\n                _swapTokensForExactTokens(\r\n                    trade.amountOut,\r\n                    trade.amountIn,\r\n                    trade.path,\r\n                    msg.sender,\r\n                    trade.to,\r\n                    trade.deadline\r\n                );\r\n            } else {\r\n                _swapTokensForExactTokens(\r\n                    // _getAmountsOut(_getContractBalance(trade.path[0]), trade.path),\r\n                    trade.amountOut,\r\n                    _getContractBalance(trade.path[0]),\r\n                    trade.path,\r\n                    address(this),\r\n                    trade.to,\r\n                    trade.deadline\r\n                );\r\n            }\r\n        }\r\n\r\n        _updateLastPairsPrice(trade.path, lastLpsPrices);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap BNB for tokens\r\n     * @param amountIn Amount to swap\r\n     * @param amountOutMin Minimum amount out\r\n     * @param path Path for swap\r\n     * @param to Address to receive tokens\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapExactETHForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amountIn }(\r\n            amountOutMin,\r\n            path,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap BNB for tokens\r\n     * @param amountOut Amount of BNB out\r\n     * @param amountInMax Max amount in\r\n     * @param path Path for swap\r\n     * @param to Address to receive BNB\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] memory path,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapETHForExactTokens{ value: amountInMax }(amountOut, path, to, deadline);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap tokens for BNB\r\n     * @param amountOut Amount of BNB out\r\n     * @param amountInMax Max amount in\r\n     * @param path Path for swap\r\n     * @param from address to swap token from\r\n     * @param to Address to receive BNB\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] memory path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapTokensForExactETH(amountOut, amountInMax, path, from, to, deadline);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap tokens for BNB\r\n     * @param amountIn Amount to swap\r\n     * @param amountOutMin Minimum amount out\r\n     * @param path Path for swap\r\n     * @param from address to swap token from\r\n     * @param to Address to receive tokens\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            from,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap tokens for tokens\r\n     * @param amountIn Amount to swap\r\n     * @param amountOutMin Minimum amount out\r\n     * @param path Path for swap\r\n     * @param from address to swap token from\r\n     * @param to Address to receive tokens\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            from,\r\n            to,\r\n            deadline\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of swap tokens for tokens\r\n     * @param amountOut Amount of tokens out\r\n     * @param amountInMax Max amount in\r\n     * @param path Path for swap\r\n     * @param from address to swap token from\r\n     * @param to Address to receive tokens\r\n     * @param deadline Block timestamp deadline for trade\r\n     */\r\n    function _swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] memory path,\r\n        address from,\r\n        address to,\r\n        uint256 deadline\r\n    ) internal {\r\n        ISafeSwapRouter(swapRouter).swapTokensForExactTokens(amountOut, amountInMax, path, from, to, deadline);\r\n    }\r\n\r\n    function WETH() internal view returns (address) {\r\n        return ISafeSwapRouter(swapRouter).WETH();\r\n    }\r\n\r\n    function getReserves(address pair) public view returns (uint256 reserve0, uint256 reserve1) {\r\n        if (pair == address(0)) {\r\n            return (0, 0);\r\n        }\r\n        (reserve0, reserve1) = getReserves(pair, true);\r\n    }\r\n\r\n    function getReserves(address pair, bool getByBalance) private view returns (uint256 reserve0, uint256 reserve1) {\r\n        (reserve0, reserve1, ) = ISafeswapPair(pair).getReserves();\r\n\r\n        if (getByBalance) {\r\n            (reserve0, reserve1) = (\r\n                _getAddressBalance(ISafeswapPair(pair).token0(), pair),\r\n                _getAddressBalance(ISafeswapPair(pair).token1(), pair)\r\n            );\r\n        }\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 _amountIn,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        bool _getByBalance\r\n    ) internal view returns (uint256 _amountOut) {\r\n        (uint256 reserveInput, uint256 reserveOutput) = getReserves(pairFor(_tokenA, _tokenB), _getByBalance);\r\n        (address token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (reserveInput, reserveOutput) = _tokenA == token0\r\n            ? (reserveInput, reserveOutput)\r\n            : (reserveOutput, reserveInput);\r\n\r\n        try ISafeSwapRouter(swapRouter).getAmountOut(_amountIn, reserveInput, reserveOutput) returns (\r\n            uint256 amountOut\r\n        ) {\r\n            _amountOut = amountOut;\r\n        } catch {\r\n            _amountOut = 0;\r\n        }\r\n    }\r\n\r\n    function _isNativeToken(address _token) internal view returns (bool isNative) {\r\n        isNative = _token == WETH();\r\n    }\r\n\r\n    function _getContractBalance(address _token) internal view returns (uint256) {\r\n        return IERC20(_token).balanceOf(address(this));\r\n    }\r\n\r\n    function _getAddressBalance(address _token, address _owner) internal view returns (uint256) {\r\n        return IERC20(_token).balanceOf(address(_owner));\r\n    }\r\n\r\n    function _mapPath(address _token0, address _token1) internal pure returns (address[] memory _path) {\r\n        _path = new address[](2);\r\n        _path[0] = _token0;\r\n        _path[1] = _token1;\r\n    }\r\n\r\n    function _getTokenDecimals(address _token) internal pure returns (uint256) {\r\n        return IERC20(_token).decimals();\r\n    }\r\n\r\n    function _getAmountsOut(uint256 _amountIn, address[] memory _path) internal view returns (uint256 amountOut) {\r\n        try ISafeSwapRouter(swapRouter).getAmountsOut(_amountIn, _path) returns (uint256[] memory amounts) {\r\n            amountOut = amounts[amounts.length - 1];\r\n        } catch {\r\n            amountOut = 0;\r\n        }\r\n    }\r\n\r\n    function _getLPPrice(address token0, address token1) internal view returns (uint256) {\r\n        return\r\n            _getAmountsOut(10**(_getTokenDecimals(token0) - LP_PRICE_BASE_AMOUNT), _mapPath(token0, token1)) *\r\n            10**LP_PRICE_BASE_AMOUNT;\r\n    }\r\n\r\n    /**\r\n     * @notice returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n     * @param tokenA Address\r\n     * @param tokenB Address\r\n     */\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"SafeswapRouter: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \"SafeswapRouter: ZERO_ADDRESS\");\r\n    }\r\n\r\n    function pairFor(address _token0, address _token1) internal view returns (address pair) {\r\n        pair = ISafeswapFactory(ISafeSwapRouter(swapRouter).factory()).getPair(_token0, _token1);\r\n        require(pair != address(0), \"SafeswapRouter: Cannot find pair\");\r\n    }\r\n\r\n    function getAdaptiveLpPriceRange(address _pair)\r\n        internal\r\n        returns (\r\n            uint256 upl,\r\n            uint256 lpl,\r\n            uint256 lastPrice\r\n        )\r\n    {\r\n        if (adaptiveLpPriceRange[_pair].tokenAddress == address(0)) {\r\n            _submitLpPriceRange(_pair, 150, 50);\r\n        }\r\n\r\n        upl = adaptiveLpPriceRange[_pair].upl;\r\n        lpl = adaptiveLpPriceRange[_pair].lpl;\r\n        lastPrice = adaptiveLpPriceRange[_pair].lastPrice;\r\n    }\r\n\r\n    function _syncPair(address _tokenA, address _tokenB) internal {\r\n        address pair = pairFor(_tokenA, _tokenB);\r\n        (uint256 reserveInput, uint256 reserveOutput) = getReserves(pair, false);\r\n\r\n        (address token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (reserveInput, reserveOutput) = _tokenA == token0\r\n            ? (reserveInput, reserveOutput)\r\n            : (reserveOutput, reserveInput);\r\n\r\n        if (\r\n            _getAddressBalance(_tokenA, pair) - reserveInput > 0 ||\r\n            _getAddressBalance(_tokenB, pair) - reserveOutput > 0\r\n        ) {\r\n            ISafeswapPair(pair).sync();\r\n        }\r\n    }\r\n\r\n    function _isLpPriceInRange(address _tokenA, address _tokenB) private returns (bool) {\r\n        address pair = pairFor(_tokenA, _tokenB);\r\n        (uint256 upl, uint256 lpl, uint256 lastPrice) = getAdaptiveLpPriceRange(pair);\r\n\r\n        if (isARCBEnabled) {\r\n            if (adaptiveLpPriceRange[pair].isEnabled) {\r\n                (address token0, address token1) = sortTokens(_tokenA, _tokenB);\r\n                uint256 decimals = _getTokenDecimals(token0);\r\n                decimals = decimals + _getTokenDecimals(token1);\r\n                lastPrice = _tokenA == token0 ? lastPrice : 10**decimals / lastPrice;\r\n\r\n                uint256 amountIn = 10**(_getTokenDecimals(_tokenA) - LP_PRICE_BASE_AMOUNT);\r\n                uint256 numerator = amountIn * _getAddressBalance(_tokenB, pair);\r\n                uint256 denominator = _getAddressBalance(_tokenA, pair) + amountIn;\r\n                uint256 currentPrice = (numerator / denominator) * 10**LP_PRICE_BASE_AMOUNT;\r\n\r\n                if (currentPrice > ((upl * lastPrice) / 100) || currentPrice < ((lpl * lastPrice) / 100)) return false;\r\n            }\r\n            _syncPair(_tokenA, _tokenB);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _isLpsPriceInRange(address[] memory _path) private returns (bool isInRange) {\r\n        // if (isARCBEnabled) {\r\n        for (uint256 i; i < _path.length - 1; i++) {\r\n            // bool isLpPriceInRange = _isLpPriceInRange(_path[i], _path[i + 1]);\r\n            if (!_isLpPriceInRange(_path[i], _path[i + 1])) {\r\n                return false;\r\n            }\r\n        }\r\n        // }\r\n        return true;\r\n    }\r\n\r\n    function _calcLpsLastPrice(address[] memory _path) internal view returns (uint256[] memory amounts) {\r\n        amounts = new uint256[](_path.length - 1);\r\n        for (uint256 i; i < _path.length - 1; i++) {\r\n            amounts[i] = _getLPPrice(_path[i], _path[i + 1]);\r\n        }\r\n    }\r\n\r\n    // /**\r\n    //  * @notice Get swap fee based on the amounts\r\n    //  * @param amountIn Amount in to calculate fee\r\n    //  * @param tokenA token1 for swap\r\n    //  * @param tokenB token2 for swap\r\n    //  * @return _fee the tokens fee amount value\r\n    //  */\r\n    function getDexSwapFee(\r\n        uint256 amountIn,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 _fee) {\r\n        uint256 amountOut;\r\n\r\n        if (!_isNativeToken(tokenA)) {\r\n            amountOut = _getAmountOut(amountIn, tokenA, WETH(), true);\r\n            if (amountOut == 0) {\r\n                amountOut = _getAmountOut(amountIn, tokenA, tokenB, true);\r\n                amountOut = _getAmountOut(amountOut, tokenB, WETH(), true);\r\n            }\r\n\r\n            _fee = (amountOut * feePercent) / percent;\r\n        }\r\n\r\n        if (_isNativeToken(tokenA) || amountOut == 0) {\r\n            int256 decimals = 18 - int8(IERC20(tokenA).decimals());\r\n            if (decimals < 0) {\r\n                decimals = decimals * -1;\r\n                _fee = ((amountIn * feePercent) / percent) / 10**uint256(decimals);\r\n            } else {\r\n                _fee = ((amountIn * feePercent) / percent) * 10**uint256(decimals);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get token swap fee for single token\r\n     * @param _amount Amount to calculate fee\r\n     * @param _transactionType BUY or SELL\r\n     * @param _token token addresses\r\n     * @param _tokenADecimals decimals for tokenA\r\n     * @param _tokenBDecimals decimals for tokenB\r\n     * @return _fee token swap fees amount\r\n     */\r\n    function getTokenSwapFee(\r\n        uint256 _amount,\r\n        TransactionType _transactionType,\r\n        address _token,\r\n        uint256 _tokenADecimals,\r\n        uint256 _tokenBDecimals\r\n    ) internal view returns (uint256 _fee) {\r\n        if (\r\n            !_isNativeToken(_token) &&\r\n            tokensFeeList[_token][_transactionType].tokenInfo.isEnabled &&\r\n            tokensFeeList[_token][_transactionType].tokenInfo.feePercentage > 0 &&\r\n            !whitelistFfsFee[msg.sender]\r\n        ) {\r\n            int256 decimals = int256(_tokenADecimals) - int256(_tokenBDecimals);\r\n\r\n            if (decimals < 0) {\r\n                decimals = decimals * -1;\r\n                _fee = (((_amount * tokensFeeList[_token][_transactionType].tokenInfo.feePercentage) / percent) /\r\n                    10**uint256(decimals));\r\n            } else {\r\n                _fee =\r\n                    ((_amount * tokensFeeList[_token][_transactionType].tokenInfo.feePercentage) / percent) *\r\n                    10**uint256(decimals);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getFees(\r\n        address[] memory _path,\r\n        uint256 _amountIn,\r\n        address _address\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalBNBFee,\r\n            uint256 dexFee,\r\n            uint256 tokenAFee,\r\n            uint256 tokenBFee\r\n        )\r\n    {\r\n        if (whitelistFfsFee[_address]) {\r\n            return (0, 0, 0, 0);\r\n        }\r\n\r\n        uint256 length = _path.length - 1;\r\n        (address _tokenInput, address _tokenOutput) = (_path[0], _path[length]);\r\n\r\n        uint256 amountInput = _amountIn;\r\n\r\n        for (uint256 i; i < length; i++) {\r\n            (address input, address output) = (_path[i], _path[i + 1]);\r\n\r\n            dexFee += getDexSwapFee(amountInput, input, output);\r\n\r\n            uint256 feeA = getTokenSwapFee(\r\n                amountInput,\r\n                TransactionType.SELL,\r\n                input,\r\n                _getTokenDecimals(_tokenInput),\r\n                _getTokenDecimals(input)\r\n            );\r\n\r\n            uint256 amountOutput = _getAmountOut(amountInput, input, output, true);\r\n\r\n            amountInput = amountOutput;\r\n\r\n            uint256 feeB = getTokenSwapFee(\r\n                amountOutput,\r\n                TransactionType.BUY,\r\n                output,\r\n                _getTokenDecimals(_tokenOutput),\r\n                _getTokenDecimals(output)\r\n            );\r\n\r\n            if (_isNativeToken(_tokenInput)) {\r\n                tokenAFee += feeA;\r\n                tokenBFee += _getAmountOut(feeB, output, WETH(), true);\r\n            } else {\r\n                tokenAFee += feeA;\r\n                tokenBFee += feeB;\r\n            }\r\n        }\r\n\r\n        if (_isNativeToken(_tokenInput)) {\r\n            totalBNBFee = tokenAFee + tokenBFee + dexFee;\r\n        } else {\r\n            if (_isNativeToken(_tokenOutput)) {\r\n                totalBNBFee = _getAmountOut(tokenAFee, _tokenInput, WETH(), true) + tokenBFee + dexFee;\r\n            } else {\r\n                totalBNBFee =\r\n                    _getAmountOut(tokenAFee, _tokenInput, WETH(), true) +\r\n                    _getAmountOut(tokenBFee, _tokenOutput, WETH(), true) +\r\n                    dexFee;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getSwapFees(uint256 amountIn, address[] memory path) public view returns (uint256 _fees) {\r\n        (, _fees, , ) = getFees(path, amountIn, msg.sender);\r\n    }\r\n\r\n    function _submitLpPriceRange(\r\n        address _pair,\r\n        uint256 _upl,\r\n        uint256 _lpl\r\n    ) private isValidAdd(_pair) {\r\n        uint256 lastPrice = _getLPPrice(ISafeswapPair(_pair).token0(), ISafeswapPair(_pair).token1());\r\n\r\n        AdaptiveLpPriceRange storage _adaptiveLpPriceRange = adaptiveLpPriceRange[_pair];\r\n        _adaptiveLpPriceRange.lastPrice = lastPrice;\r\n        _adaptiveLpPriceRange.tokenAddress = _pair;\r\n        _adaptiveLpPriceRange.upl = _upl;\r\n        _adaptiveLpPriceRange.lpl = _lpl;\r\n        _adaptiveLpPriceRange.isEnabled = true;\r\n\r\n        emit SubmitLpPriceRange(_pair, _upl, _lpl, lastPrice);\r\n    }\r\n\r\n    function _updateLastPairPrice(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _updatedPrice\r\n    ) private {\r\n        address pair = pairFor(_tokenA, _tokenB);\r\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\r\n        // uint256 decimals = _getTokenDecimals(token0);\r\n        // decimals = decimals + _getTokenDecimals(token1);\r\n        _updatedPrice = _tokenA == token0\r\n            ? _updatedPrice\r\n            : 10**(_getTokenDecimals(token0) + _getTokenDecimals(token1)) / _updatedPrice;\r\n        adaptiveLpPriceRange[pair].lastPrice = _updatedPrice;\r\n    }\r\n\r\n    function _updateLastPairsPrice(address[] memory _path, uint256[] memory _lastPrices) private {\r\n        for (uint256 i; i < _path.length - 1; i++) {\r\n            _updateLastPairPrice(_path[i], _path[i + 1], _lastPrices[i]);\r\n        }\r\n    }\r\n\r\n    function _distributeTokenFee(\r\n        address _token,\r\n        TransactionType _transactionType,\r\n        uint256 _totalFeeAmount\r\n    ) private {\r\n        uint256 feeAmount;\r\n        uint256 claimedAmount;\r\n\r\n        if (tokensFeeList[_token][_transactionType].tokenInfo.isEnabled && _totalFeeAmount > 0) {\r\n            uint256 length = tokensFeeList[_token][_transactionType].singleSwapFees.length;\r\n\r\n            for (uint256 i; i < length; i++) {\r\n                if (\r\n                    tokensFeeList[_token][_transactionType].singleSwapFees[i].isEnabled &&\r\n                    tokensFeeList[_token][_transactionType].singleSwapFees[i].percentage > 0\r\n                ) {\r\n                    address beneficiary = tokensFeeList[_token][_transactionType].singleSwapFees[i].beneficiary;\r\n                    address assetOut = tokensFeeList[_token][_transactionType].singleSwapFees[i].assetOut;\r\n                    if (i == (length - 1)) {\r\n                        feeAmount = _totalFeeAmount - claimedAmount;\r\n                    } else {\r\n                        uint256 swapKindPercentage = (tokensFeeList[_token][_transactionType]\r\n                            .singleSwapFees[i]\r\n                            .percentage * percent) / tokensFeeList[_token][_transactionType].tokenInfo.feePercentage;\r\n\r\n                        feeAmount = ((_totalFeeAmount * swapKindPercentage) / percent);\r\n                        claimedAmount = claimedAmount + feeAmount;\r\n                    }\r\n\r\n                    if (tokensFeeList[_token][_transactionType].singleSwapFees[i].swapKind == SwapKind.SEND_ONLY) {\r\n                        TransferHelper.safeTransferETH(beneficiary, feeAmount);\r\n                    } else {\r\n                        _swapExactETHForTokens(\r\n                            feeAmount,\r\n                            0,\r\n                            _mapPath(WETH(), assetOut),\r\n                            beneficiary,\r\n                            block.timestamp + 20\r\n                        );\r\n                    }\r\n\r\n                    emit TokenFeeSwapped(beneficiary, _token, assetOut, feeAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _claimTokenFee(\r\n        address _token,\r\n        address _address,\r\n        TransactionType _transactionType,\r\n        uint256 _amountIn,\r\n        uint256 _totalFeeAmount,\r\n        bool _transferBalance\r\n    ) private {\r\n        if (tokensFeeList[_token][_transactionType].tokenInfo.isEnabled && _totalFeeAmount > 0) {\r\n            if (!_transferBalance) {\r\n                TransferHelper.safeTransferFrom(_token, _address, address(this), _amountIn);\r\n            }\r\n\r\n            _feeWithTokens(_totalFeeAmount, _token, false);\r\n\r\n            _distributeTokenFee(_token, _transactionType, address(this).balance);\r\n\r\n            if (_transferBalance) {\r\n                _transferContractBalance(_token, _address);\r\n            } else {\r\n                TransferHelper.safeApprove(_token, address(swapRouter), _getContractBalance(_token));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transferContractBalance(address _token, address _to) internal {\r\n        TransferHelper.safeTransfer(_token, payable(_to), _getContractBalance(_token));\r\n    }\r\n\r\n    /**\r\n     * @notice Fee specific amount of BNB\r\n     * @param feeAmount Amount to fee\r\n     */\r\n    function _feeAmountBNB(uint256 feeAmount) internal {\r\n        if (feeAmount > 0) {\r\n            feeJar.fee{ value: feeAmount }();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Convert a token balance into BNB and then fee\r\n     * @param _fee Amount to swap\r\n     * @param _payInToken token address would be used to pay with\r\n     * @param _claimFee indicate to transfer fee or not\r\n     */\r\n    function _feeWithTokens(\r\n        uint256 _fee,\r\n        address _payInToken,\r\n        bool _claimFee\r\n    ) internal {\r\n        TransferHelper.safeApprove(_payInToken, address(swapRouter), _fee);\r\n\r\n        _swapExactTokensForETH(_fee, 0, _mapPath(_payInToken, WETH()), address(this), address(this), block.timestamp);\r\n        if (_claimFee) {\r\n            _feeAmountBNB(address(this).balance);\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeJar\",\"type\":\"address\"}],\"name\":\"NewFeeJar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isARCBEnabled\",\"type\":\"bool\"}],\"name\":\"SetARCBStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"SetLpPriceRangeStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"SetTokenDeletionStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"SetTokenFeeStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"SetTokenSwapFeeStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_upl\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lpl\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastPrice\",\"type\":\"uint256\"}],\"name\":\"SubmitLpPriceRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenFeePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum SafeSwapTradeRouter.SwapKind\",\"name\":\"_swapKind\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_assetOut\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"SubmitTokenSwapFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_assetIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_assetOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"name\":\"TokenFeeSwapped\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wl\",\"type\":\"address\"}],\"name\":\"addFfsWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeJar\",\"outputs\":[{\"internalType\":\"contract IFeeJar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBNBFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dexFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getLpPriceRangeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpl\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct SafeSwapTradeRouter.AdaptiveLpPriceRange\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getSwapFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenFeeAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"}],\"name\":\"getTokenInfoDetails\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDeleted\",\"type\":\"bool\"}],\"internalType\":\"struct SafeSwapTradeRouter.TokenInfo\",\"name\":\"tokenInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum SafeSwapTradeRouter.SwapKind\",\"name\":\"swapKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct SafeSwapTradeRouter.SingleSwapFee[]\",\"name\":\"singleSwapFees\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SafeSwapTradeRouter.TokenFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeJar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isARCBEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wl\",\"type\":\"address\"}],\"name\":\"removeFfsWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"resetLpLastPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"sePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeJar\",\"type\":\"address\"}],\"name\":\"setFeeJar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_upl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpl\",\"type\":\"uint256\"}],\"name\":\"submitLpPriceRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"enum SafeSwapTradeRouter.SwapKind\",\"name\":\"swapKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct SafeSwapTradeRouter.SingleSwapFee\",\"name\":\"_singleSwapFee\",\"type\":\"tuple\"}],\"name\":\"submitTokenSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokensWithFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensWithFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForETHAndFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"}],\"name\":\"swapExactTokensForTokensWithFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"}],\"name\":\"swapTokensForExactETHAndFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeSwapTradeRouter.Trade\",\"name\":\"trade\",\"type\":\"tuple\"}],\"name\":\"swapTokensForExactTokensWithFeeAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchARCBActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"switchLpPriceRangeActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"switchSingleSwapActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"}],\"name\":\"switchTokenActivation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"}],\"name\":\"switchTokenDeletion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_upl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpl\",\"type\":\"uint256\"}],\"name\":\"updateLpPriceRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum SafeSwapTradeRouter.TransactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"enum SafeSwapTradeRouter.SwapKind\",\"name\":\"swapKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"assetOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"internalType\":\"struct SafeSwapTradeRouter.SingleSwapFee\",\"name\":\"_singleSwapFee\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"updateTokenSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFfsFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SafeSwapTradeRouter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8df71691c5afd5665fb7c07d10da6811121e1ddda6c97120650bf76c17a0b0da"}