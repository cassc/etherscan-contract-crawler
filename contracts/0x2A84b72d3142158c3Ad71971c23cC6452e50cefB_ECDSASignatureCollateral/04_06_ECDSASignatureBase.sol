// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "./interfaces/IECDSASignature.sol";

abstract contract ECDSASignatureBase {
    uint256 constant _timePeriodInSeconds = 600; //10 minutes
    IECDSASignature internal signature;

    struct HashToSign {
        bytes32 hashMessage;
        bytes32 markedHash;
        uint256 timestamp;
        uint256 nonce;
    }

    constructor(address _signature) {
        signature = IECDSASignature(_signature);
    }

    /// @dev create a hash with timestamp and nonce with the claim data
    /// @notice This function is called by the signature servers to generate the hash that will be applied to the signature with the private key.
    /// @param hashMessage hash to sign
    /// @param externalRandom this is a number randomly generated by the server
    function makeHashToSign(bytes32 hashMessage, uint256 externalRandom) external view returns (HashToSign memory){
        uint256 timestamp = _timeStamp();

        uint256 nonce = uint256(
            keccak256(abi.encodePacked(block.timestamp, block.difficulty, externalRandom, hashMessage))
        );

        require(signature.checkNonce(nonce) == false, "nonce was already used");

        bytes32 markedHash = watermark(hashMessage, timestamp, nonce);

        return HashToSign(hashMessage, markedHash, timestamp, nonce);
    }
    
    function _timeStamp() internal view returns (uint256) {
        uint256 timePeriod = block.timestamp + _timePeriodInSeconds;
        return timePeriod;
    }
 
    function watermark(bytes32 message, uint256 timestamp, uint256 nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(message, timestamp, nonce));
    }

}