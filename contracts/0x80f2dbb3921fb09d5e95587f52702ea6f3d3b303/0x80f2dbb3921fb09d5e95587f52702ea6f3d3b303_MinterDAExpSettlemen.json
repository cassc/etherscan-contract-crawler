{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.7/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/archive/minter-suite/Minters/MinterDAExpSettlement/MinterDAExpSettlementV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../../../interfaces/v0.8.x/IMinterFilterV0.sol\\\";\\nimport \\\"../../../../interfaces/v0.8.x/IFilteredMinterDAExpSettlementV0.sol\\\";\\nimport \\\"../../../../minter-suite/Minters/MinterBase_v0_1_1.sol\\\";\\n\\nimport \\\"@openzeppelin-4.7/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\\\";\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\\n * Pricing is achieved using an automated Dutch-auction mechanism, with a\\n * settlement mechanism for tokens purchased before the auction ends.\\n * This is designed to be used with GenArt721CoreContractV3 flagship or\\n * engine contracts.\\n * @author Art Blocks Inc.\\n * @notice Privileged Roles and Ownership:\\n * This contract is designed to be managed, with limited powers.\\n * Privileged roles and abilities are controlled by the core contract's Admin\\n * ACL contract and a project's artist. Both of these roles hold extensive\\n * power and can modify minter details.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * Additionally, the purchaser of a token has some trust assumptions regarding\\n * settlement, beyond typical minter Art Blocks trust assumptions. In general,\\n * Artists and Admin are trusted to not abuse their powers in a way that\\n * would artifically inflate the sellout price of a project. They are\\n * incentivized to not do so, as it would diminish their reputation and\\n * ability to sell future projects. Agreements between Admin and Artist\\n * may or may not be in place to further dissuade artificial inflation of an\\n * auction's sellout price.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to the core contract's Admin ACL\\n * contract:\\n * - setAllowablePriceDecayHalfLifeRangeSeconds (note: this range is only\\n *   enforced when creating new auctions)\\n * - resetAuctionDetails (note: this will prevent minting until a new auction\\n *   is created)\\n * - adminEmergencyReduceSelloutPrice\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist or the core\\n * contract's Admin ACL contract:\\n * - withdrawArtistAndAdminRevenues (note: this may only be called after an\\n *   auction has sold out or has reached base price)\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist:\\n * - setAuctionDetails (note: this may only be called when there is no active\\n *   auction, and must start at a price less than or equal to any previously\\n *   made purchases)\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on other\\n * contracts that this minter integrates with.\\n *\\n * @dev Note that while this minter makes use of `block.timestamp` and it is\\n * technically possible that this value is manipulated by block producers via\\n * denial of service (in PoS), such manipulation will not have material impact\\n * on the price values of this minter given the business practices for how\\n * pricing is congfigured for this minter and that variations on the order of\\n * less than a minute should not meaningfully impact price given the minimum\\n * allowable price decay rate that this minter intends to support.\\n */\\ncontract MinterDAExpSettlementV1 is\\n    ReentrancyGuard,\\n    MinterBase,\\n    IFilteredMinterDAExpSettlementV0\\n{\\n    using SafeCast for uint256;\\n\\n    /// Core contract address this minter interacts with\\n    address public immutable genArt721CoreAddress;\\n    /// The core contract integrates with V3 contracts\\n    IGenArt721CoreContractV3_Base private immutable genArtCoreContract_Base;\\n\\n    /// Minter filter address this minter interacts with\\n    address public immutable minterFilterAddress;\\n\\n    /// Minter filter this minter may interact with.\\n    IMinterFilterV0 private immutable minterFilter;\\n\\n    /// minterType for this minter\\n    string public constant minterType = \\\"MinterDAExpSettlementV1\\\";\\n\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    struct ProjectConfig {\\n        // on this minter, hasMaxBeenInvoked is updated only during every\\n        // purchase, and is only true if this minter minted the final token.\\n        // this enables the minter to know when a sellout price is greater than\\n        // the auction's base price.\\n        bool maxHasBeenInvoked;\\n        // set to true only after artist + admin revenues have been collected\\n        bool auctionRevenuesCollected;\\n        // number of tokens minted that have potential of future settlement.\\n        // max uint24 > 16.7 million tokens > 1 million tokens/project max\\n        uint24 numSettleableInvocations;\\n        // max uint64 ~= 1.8e19 sec ~= 570 billion years\\n        uint64 timestampStart;\\n        uint64 priceDecayHalfLifeSeconds;\\n        // Prices are packed internally as uint128, resulting in a maximum\\n        // allowed price of ~3.4e20 ETH. This is many orders of magnitude\\n        // greater than current ETH supply.\\n        uint128 startPrice;\\n        // base price is non-zero for all configured auctions on this minter\\n        uint128 basePrice;\\n        // This value is only zero if no purchases have been made on this\\n        // minter.\\n        // When non-zero, this value is used as a reference when an auction is\\n        // reset by admin, and then a new auction is configured by an artist.\\n        // In that case, the new auction will be required to have a starting\\n        // price less than or equal to this value, if one or more purchases\\n        // have been made on this minter.\\n        uint256 latestPurchasePrice;\\n    }\\n\\n    mapping(uint256 => ProjectConfig) public projectConfig;\\n\\n    /// Minimum price decay half life: price must decay with a half life of at\\n    /// least this amount (must cut in half at least every N seconds).\\n    uint256 public minimumPriceDecayHalfLifeSeconds = 300; // 5 minutes\\n    /// Maximum price decay half life: price may decay with a half life of no\\n    /// more than this amount (may cut in half at no more than every N seconds).\\n    uint256 public maximumPriceDecayHalfLifeSeconds = 3600; // 60 minutes\\n\\n    struct Receipt {\\n        // max uint232 allows for > 1e51 ETH (much more than max supply)\\n        uint232 netPosted;\\n        // max uint24 still allows for > max project supply of 1 million tokens\\n        uint24 numPurchased;\\n    }\\n    /// user address => project ID => receipt\\n    mapping(address => mapping(uint256 => Receipt)) receipts;\\n\\n    // modifier to restrict access to only AdminACL or the artist\\n    modifier onlyCoreAdminACLOrArtist(uint256 _projectId, bytes4 _selector) {\\n        require(\\n            (msg.sender ==\\n                genArtCoreContract_Base.projectIdToArtistAddress(_projectId)) ||\\n                (\\n                    genArtCoreContract_Base.adminACLAllowed(\\n                        msg.sender,\\n                        address(this),\\n                        _selector\\n                    )\\n                ),\\n            \\\"Only Artist or Admin ACL\\\"\\n        );\\n        _;\\n    }\\n\\n    // modifier to restrict access to only AdminACL allowed calls\\n    // @dev defers which ACL contract is used to the core contract\\n    modifier onlyCoreAdminACL(bytes4 _selector) {\\n        require(\\n            genArtCoreContract_Base.adminACLAllowed(\\n                msg.sender,\\n                address(this),\\n                _selector\\n            ),\\n            \\\"Only Core AdminACL allowed\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyArtist(uint256 _projectId) {\\n        require(\\n            (msg.sender ==\\n                genArtCoreContract_Base.projectIdToArtistAddress(_projectId)),\\n            \\\"Only Artist\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes contract to be a Filtered Minter for\\n     * `_minterFilter`, integrated with Art Blocks core contract\\n     * at address `_genArt721Address`.\\n     * @param _genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     * @param _minterFilter Minter filter for which\\n     * this will a filtered minter.\\n     */\\n    constructor(\\n        address _genArt721Address,\\n        address _minterFilter\\n    ) ReentrancyGuard() MinterBase(_genArt721Address) {\\n        genArt721CoreAddress = _genArt721Address;\\n        // always populate immutable engine contracts, but only use appropriate\\n        // interface based on isEngine in the rest of the contract\\n        genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\\n            _genArt721Address\\n        );\\n        minterFilterAddress = _minterFilter;\\n        minterFilter = IMinterFilterV0(_minterFilter);\\n        require(\\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\\n            \\\"Illegal contract pairing\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice This function is not implemented on this minter, and exists only\\n     * for interface conformance reasons. This minter checks if max invocations\\n     * have been reached during every purchase to determine if a sellout has\\n     * occurred. Therefore, the local caching of max invocations is not\\n     * beneficial or necessary.\\n     */\\n    function setProjectMaxInvocations(uint256 /*_projectId*/) external pure {\\n        // not implemented because maxInvocations must be checked during every mint\\n        // to know if final price should be set\\n        revert(\\n            \\\"setProjectMaxInvocations not implemented - updated during every mint\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\\n     * This method exists purely for interface-conformance purposes.\\n     */\\n    function togglePurchaseToDisabled(\\n        uint256 _projectId\\n    ) external view onlyArtist(_projectId) {\\n        revert(\\\"Action not supported\\\");\\n    }\\n\\n    /**\\n     * @notice projectId => has project reached its maximum number of\\n     * invocations while being minted with this minter?\\n     * Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional. A false negative will only result in a gas cost increase,\\n     * since the core contract will still enforce max invocations during during\\n     * minting. A false negative will also only occur if the max invocations\\n     * was either reduced on the core contract to equal current invocations, or\\n     * if the max invocations was reached by minting on a different minter.\\n     * In both of these cases, we expect the net purchase price (after\\n     * settlement) shall be the base price of the project's auction. This\\n     * prevents an artist from benefiting by reducing max invocations on the\\n     * core mid-auction, or by minting on a different minter.\\n     * Note that if an artist wishes to reduce the max invocations on the core\\n     * to something less than the current invocations, but more than max\\n     * invocations (with the hope of increasing the sellout price), an admin\\n     * function is provided to manually reduce the sellout price to a lower\\n     * value, if desired, in the `adminEmergencyReduceSelloutPrice`\\n     * function.\\n     * @param _projectId projectId to be queried\\n     *\\n     */\\n    function projectMaxHasBeenInvoked(\\n        uint256 _projectId\\n    ) external view returns (bool) {\\n        return projectConfig[_projectId].maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice projectId => auction parameters\\n     */\\n    function projectAuctionParameters(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 timestampStart,\\n            uint256 priceDecayHalfLifeSeconds,\\n            uint256 startPrice,\\n            uint256 basePrice\\n        )\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        return (\\n            _projectConfig.timestampStart,\\n            _projectConfig.priceDecayHalfLifeSeconds,\\n            _projectConfig.startPrice,\\n            _projectConfig.basePrice\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the minimum and maximum values that are settable for\\n     * `_priceDecayHalfLifeSeconds` across all projects.\\n     * @param _minimumPriceDecayHalfLifeSeconds Minimum price decay half life\\n     * (in seconds).\\n     * @param _maximumPriceDecayHalfLifeSeconds Maximum price decay half life\\n     * (in seconds).\\n     */\\n    function setAllowablePriceDecayHalfLifeRangeSeconds(\\n        uint256 _minimumPriceDecayHalfLifeSeconds,\\n        uint256 _maximumPriceDecayHalfLifeSeconds\\n    )\\n        external\\n        onlyCoreAdminACL(\\n            this.setAllowablePriceDecayHalfLifeRangeSeconds.selector\\n        )\\n    {\\n        require(\\n            _maximumPriceDecayHalfLifeSeconds >\\n                _minimumPriceDecayHalfLifeSeconds,\\n            \\\"Maximum half life must be greater than minimum\\\"\\n        );\\n        require(\\n            _minimumPriceDecayHalfLifeSeconds > 0,\\n            \\\"Half life of zero not allowed\\\"\\n        );\\n        minimumPriceDecayHalfLifeSeconds = _minimumPriceDecayHalfLifeSeconds;\\n        maximumPriceDecayHalfLifeSeconds = _maximumPriceDecayHalfLifeSeconds;\\n        emit AuctionHalfLifeRangeSecondsUpdated(\\n            _minimumPriceDecayHalfLifeSeconds,\\n            _maximumPriceDecayHalfLifeSeconds\\n        );\\n    }\\n\\n    ////// Auction Functions\\n    /**\\n     * @notice Sets auction details for project `_projectId`.\\n     * @param _projectId Project ID to set auction details for.\\n     * @param _auctionTimestampStart Timestamp at which to start the auction.\\n     * @param _priceDecayHalfLifeSeconds The half life with which to decay the\\n     *  price (in seconds).\\n     * @param _startPrice Price at which to start the auction, in Wei.\\n     * If a previous auction existed on this minter and at least one settleable\\n     * purchase has been made, this value must be less than or equal to the\\n     * price when the previous auction was paused. This enforces an overall\\n     * monatonically decreasing auction. Must be greater than or equal to\\n     * max(uint128) for internal storage packing purposes.\\n     * @param _basePrice Resting price of the auction, in Wei. Must be greater\\n     * than or equal to max(uint128) for internal storage packing purposes.\\n     * @dev Note that setting the auction price explicitly to `0` is\\n     * intentionally not allowed. This allows the minter to use the assumption\\n     * that a price of `0` indicates that the auction is not configured.\\n     * @dev Note that prices must be <= max(128) for internal storage packing\\n     * efficiency purposes only. This function's interface remains unchanged\\n     * for interface conformance purposes.\\n     */\\n    function setAuctionDetails(\\n        uint256 _projectId,\\n        uint256 _auctionTimestampStart,\\n        uint256 _priceDecayHalfLifeSeconds,\\n        uint256 _startPrice,\\n        uint256 _basePrice\\n    ) external onlyArtist(_projectId) {\\n        // CHECKS\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        require(\\n            _projectConfig.timestampStart == 0 ||\\n                block.timestamp < _projectConfig.timestampStart,\\n            \\\"No modifications mid-auction\\\"\\n        );\\n        require(\\n            block.timestamp < _auctionTimestampStart,\\n            \\\"Only future auctions\\\"\\n        );\\n        require(\\n            _startPrice > _basePrice,\\n            \\\"Auction start price must be greater than auction end price\\\"\\n        );\\n        // require _basePrice is non-zero to simplify logic of this minter\\n        require(_basePrice > 0, \\\"Base price must be non-zero\\\");\\n        // If previous purchases have been made, require monotonically\\n        // decreasing purchase prices to preserve settlement and revenue\\n        // claiming logic. Since base price is always non-zero, if\\n        // latestPurchasePrice is zero, then no previous purchases have been\\n        // made, and startPrice may be set to any value.\\n        require(\\n            _projectConfig.latestPurchasePrice == 0 || // never purchased\\n                _startPrice <= _projectConfig.latestPurchasePrice,\\n            \\\"Auction start price must be <= latest purchase price\\\"\\n        );\\n        require(\\n            (_priceDecayHalfLifeSeconds >= minimumPriceDecayHalfLifeSeconds) &&\\n                (_priceDecayHalfLifeSeconds <=\\n                    maximumPriceDecayHalfLifeSeconds),\\n            \\\"Price decay half life must fall between min and max allowable values\\\"\\n        );\\n        // EFFECTS\\n        _projectConfig.timestampStart = _auctionTimestampStart.toUint64();\\n        _projectConfig.priceDecayHalfLifeSeconds = _priceDecayHalfLifeSeconds\\n            .toUint64();\\n        _projectConfig.startPrice = _startPrice.toUint128();\\n        _projectConfig.basePrice = _basePrice.toUint128();\\n\\n        emit SetAuctionDetails(\\n            _projectId,\\n            _auctionTimestampStart,\\n            _priceDecayHalfLifeSeconds,\\n            _startPrice,\\n            _basePrice\\n        );\\n    }\\n\\n    /**\\n     * @notice Resets auction details for project `_projectId`, zero-ing out all\\n     * relevant auction fields. Not intended to be used in normal auction\\n     * operation, but rather only in case of the need to reset an ongoing\\n     * auction. An expected time this might occur would be when a frontend\\n     * issue was occuring, and many typical users are actively being prevented\\n     * from easily minting (even though minting would technically be possible\\n     * directly from the contract).\\n     * This function is only callable by the core admin during an active\\n     * auction, before revenues have been collected.\\n     * The price at the time of the reset will be the maximum starting price\\n     * when re-configuring the next auction if one or more settleable purchases\\n     * have been made.\\n     * This is to ensure that purchases up through the block that this is\\n     * called on will remain settleable, and that revenue claimed does not\\n     * surpass (payments - excess_settlement_funds) for a given project.\\n     * @param _projectId Project ID to set auction details for.\\n     */\\n    function resetAuctionDetails(\\n        uint256 _projectId\\n    ) external onlyCoreAdminACL(this.resetAuctionDetails.selector) {\\n        // CHECKS\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        require(_projectConfig.startPrice != 0, \\\"Auction must be configured\\\");\\n        // no reset after revenues collected, since that solidifies amount due\\n        require(\\n            !_projectConfig.auctionRevenuesCollected,\\n            \\\"Only before revenues collected\\\"\\n        );\\n        // EFFECTS\\n        // reset to initial values\\n        _projectConfig.timestampStart = 0;\\n        _projectConfig.priceDecayHalfLifeSeconds = 0;\\n        _projectConfig.startPrice = 0;\\n        _projectConfig.basePrice = 0;\\n        // Since auction revenues have not been collected, we can safely assume\\n        // that numSettleableInvocations is the number of purchases made on\\n        // this minter. A dummy value of 0 is used for latest purchase price if\\n        // no purchases have been made.\\n        emit ResetAuctionDetails(\\n            _projectId,\\n            _projectConfig.numSettleableInvocations,\\n            _projectConfig.latestPurchasePrice\\n        );\\n    }\\n\\n    /**\\n     * @notice This represents an admin stepping in and reducing the sellout\\n     * price of an auction. This is only callable by the core admin, only\\n     * after the auction is complete, but before project revenues are\\n     * withdrawn.\\n     * This is only intended to be used in the case where for some reason,\\n     * whether malicious or accidental, the sellout price was too high.\\n     * Examples of this include:\\n     *  - The artist reducing a project's maxInvocations on the core contract\\n     *    after an auction has started, but before it ends, eliminating the\\n     *    ability of purchasers to fairly determine market price under the\\n     *    original, expected auction parameters.\\n     *  - Any other reason the admin deems to be a valid reason to reduce the\\n     *    sellout price of an auction, prior to marking it as valid.\\n     * @param _projectId Project ID to reduce auction sellout price for.\\n     * @param _newSelloutPrice New sellout price to set for the auction. Must\\n     * be less than the current sellout price.\\n     */\\n    function adminEmergencyReduceSelloutPrice(\\n        uint256 _projectId,\\n        uint256 _newSelloutPrice\\n    )\\n        external\\n        onlyCoreAdminACL(this.adminEmergencyReduceSelloutPrice.selector)\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        require(_projectConfig.maxHasBeenInvoked, \\\"Auction must be complete\\\");\\n        // @dev no need to check that auction max invocations has been reached,\\n        // because if it was, the sellout price will be zero, and the following\\n        // check will fail.\\n        require(\\n            _newSelloutPrice < _projectConfig.latestPurchasePrice,\\n            \\\"May only reduce sellout price\\\"\\n        );\\n        require(\\n            _newSelloutPrice >= _projectConfig.basePrice,\\n            \\\"May only reduce sellout price to base price or greater\\\"\\n        );\\n        // ensure latestPurchasePrice is non-zero if any purchases on minter\\n        // @dev only possible to fail this if auction is in a reset state\\n        require(_newSelloutPrice > 0, \\\"Only sellout prices > 0\\\");\\n        require(\\n            !_projectConfig.auctionRevenuesCollected,\\n            \\\"Only before revenues collected\\\"\\n        );\\n        _projectConfig.latestPurchasePrice = _newSelloutPrice;\\n        emit SelloutPriceUpdated(_projectId, _newSelloutPrice);\\n    }\\n\\n    /**\\n     * @notice This withdraws project revenues for the artist and admin.\\n     * This function is only callable by the artist or admin, and only after\\n     * one of the following is true:\\n     * - the auction has sold out above base price\\n     * - the auction has reached base price\\n     * Note that revenues are not claimable if in a temporary state after\\n     * an auction is reset.\\n     * Revenues may only be collected a single time per project.\\n     * After revenues are collected, auction parameters will never be allowed\\n     * to be reset, and excess settlement funds will become immutable and fully\\n     * deterministic.\\n     */\\n    function withdrawArtistAndAdminRevenues(\\n        uint256 _projectId\\n    )\\n        external\\n        nonReentrant\\n        onlyCoreAdminACLOrArtist(\\n            _projectId,\\n            this.withdrawArtistAndAdminRevenues.selector\\n        )\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        // CHECKS\\n        // require revenues to not have already been collected\\n        require(\\n            !_projectConfig.auctionRevenuesCollected,\\n            \\\"Revenues already collected\\\"\\n        );\\n        // get the current net price of the auction - reverts if no auction\\n        // is configured.\\n        // @dev _getPrice is guaranteed <= _projectConfig.latestPurchasePrice,\\n        // since this minter enforces monotonically decreasing purchase prices.\\n        uint256 _price = _getPrice(_projectId);\\n        // if the price is not base price, require that the auction have\\n        // reached max invocations. This prevents premature withdrawl\\n        // before final auction price is possible to know.\\n        if (_price != _projectConfig.basePrice) {\\n            // prefer to use locally cached value of maxHasBeenInvoked, which\\n            // is only updated when a purchase is made. This is to handle the\\n            // case where an artist reduced max invocations to current\\n            // invocations on the core contract mid-auction. In that case, the\\n            // the following _projectConfig.maxHasBeenInvoked check will fail\\n            // (only a local cache is used). This is a valid state, and in that\\n            // somewhat suspicious case, the artist must wait until the auction\\n            // reaches base price before withdrawing funds, at which point the\\n            // latestPurchasePrice will be set to base price, maximizing\\n            // purchaser excess settlement amounts, and minimizing artist/admin\\n            // revenue.\\n            require(\\n                _projectConfig.maxHasBeenInvoked,\\n                \\\"Active auction not yet sold out\\\"\\n            );\\n        } else {\\n            // update the latest purchase price to the base price, to ensure\\n            // the base price is used for all future settlement calculations\\n            _projectConfig.latestPurchasePrice = _projectConfig.basePrice;\\n        }\\n        // EFFECTS\\n        _projectConfig.auctionRevenuesCollected = true;\\n        // if the price is base price, the auction is valid and may be claimed\\n        // calculate the artist and admin revenues (no check requuired)\\n        uint256 netRevenues = _projectConfig.numSettleableInvocations * _price;\\n        // INTERACTIONS\\n        splitRevenuesETH(_projectId, netRevenues, genArt721CoreAddress);\\n        emit ArtistAndAdminRevenuesWithdrawn(_projectId);\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId`.\\n     * @param _projectId Project ID to mint a token on.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of purchase(uint256).\\n     */\\n    function purchase_H4M(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId` and sets\\n     * the token's owner to `_to`.\\n     * @param _to Address to be the new token's owner.\\n     * @param _projectId Project ID to mint a token on.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId) {\\n        return purchaseTo_do6(_to, _projectId);\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of purchaseTo(address, uint256).\\n     */\\n    function purchaseTo_do6(\\n        address _to,\\n        uint256 _projectId\\n    ) public payable nonReentrant returns (uint256 tokenId) {\\n        // CHECKS\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n\\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\\n        // consumption after a project has been fully minted.\\n        // `_projectConfig.maxHasBeenInvoked` is locally cached during every\\n        // purchase to reduce gas consumption and enable recording of sellout\\n        // price, but if not in sync with the core contract's value,\\n        // the core contract also enforces its own max invocation check during\\n        // minting.\\n        require(\\n            !_projectConfig.maxHasBeenInvoked,\\n            \\\"Maximum number of invocations reached\\\"\\n        );\\n\\n        // _getPrice reverts if auction is unconfigured or has not started\\n        uint256 currentPriceInWei = _getPrice(_projectId);\\n\\n        // EFFECTS\\n        // update the purchaser's receipt and require sufficient net payment\\n        Receipt storage receipt = receipts[msg.sender][_projectId];\\n\\n        // in memory copy + update\\n        uint256 netPosted = receipt.netPosted + msg.value;\\n        uint256 numPurchased = receipt.numPurchased + 1;\\n\\n        // require sufficient payment on project\\n        require(\\n            netPosted >= numPurchased * currentPriceInWei,\\n            \\\"Must send minimum value to mint\\\"\\n        );\\n\\n        // update Receipt in storage\\n        // @dev overflow checks are not required since the added values cannot\\n        // be enough to overflow due to maximum invocations or supply of ETH\\n        receipt.netPosted = uint232(netPosted);\\n        receipt.numPurchased = uint24(numPurchased);\\n\\n        // emit event indicating new receipt state\\n        emit ReceiptUpdated(msg.sender, _projectId, numPurchased, netPosted);\\n\\n        // update latest purchase price (on this minter) in storage\\n        // @dev this is used to enforce monotonically decreasing purchase price\\n        // across multiple auctions\\n        _projectConfig.latestPurchasePrice = currentPriceInWei;\\n\\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\\n\\n        // Note that this requires that the core contract's maxInvocations\\n        // be accurate to ensure that the minters maxHasBeenInvoked is\\n        // accurate, so we get the value from the core contract directly.\\n        uint256 maxInvocations;\\n        (, maxInvocations, , , , ) = genArtCoreContract_Base.projectStateData(\\n            _projectId\\n        );\\n        // okay if this underflows because if statement will always eval false.\\n        // this is only for gas optimization and recording sellout price in\\n        // an event (core enforces maxInvocations).\\n        unchecked {\\n            if (tokenId % ONE_MILLION == maxInvocations - 1) {\\n                _projectConfig.maxHasBeenInvoked = true;\\n                emit SelloutPriceUpdated(_projectId, currentPriceInWei);\\n            }\\n        }\\n\\n        // INTERACTIONS\\n        if (_projectConfig.auctionRevenuesCollected) {\\n            // if revenues have been collected, split funds immediately.\\n            // @dev note that we are guaranteed to be at auction base price,\\n            // since we know we didn't sellout prior to this tx.\\n            // note that we don't refund msg.sender here, since a separate\\n            // settlement mechanism is provided on this minter, unrelated to\\n            // msg.value\\n            splitRevenuesETH(\\n                _projectId,\\n                currentPriceInWei,\\n                genArt721CoreAddress\\n            );\\n        } else {\\n            // increment the number of settleable invocations that will be\\n            // claimable by the artist and admin once auction is validated.\\n            // do not split revenue here since will be claimed at a later time.\\n            _projectConfig.numSettleableInvocations++;\\n        }\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * project `_projectId`. The current settled price is the the price paid\\n     * for the most recently purchased token, or the base price if the artist\\n     * has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends excess settlement funds to msg.sender.\\n     * @param _projectId Project ID to reclaim excess settlement funds on.\\n     */\\n    function reclaimProjectExcessSettlementFunds(uint256 _projectId) external {\\n        reclaimProjectExcessSettlementFundsTo(payable(msg.sender), _projectId);\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * project `_projectId`. The current settled price is the the price paid\\n     * for the most recently purchased token, or the base price if the artist\\n     * has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds.\\n     * Sends excess settlement funds to address `_to`.\\n     * @param _to Address to send excess settlement funds to.\\n     * @param _projectId Project ID to reclaim excess settlement funds on.\\n     */\\n    function reclaimProjectExcessSettlementFundsTo(\\n        address payable _to,\\n        uint256 _projectId\\n    ) public nonReentrant {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        Receipt storage receipt = receipts[msg.sender][_projectId];\\n        uint256 numPurchased = receipt.numPurchased;\\n        // CHECKS\\n        // input validation\\n        require(_to != address(0), \\\"No claiming to the zero address\\\");\\n        // require that a user has purchased at least one token on this project\\n        require(numPurchased > 0, \\\"No purchases made by this address\\\");\\n        // get the latestPurchasePrice, which returns the sellout price if the\\n        // auction sold out before reaching base price, or returns the base\\n        // price if auction has reached base price and artist has withdrawn\\n        // revenues.\\n        // @dev if user is eligible for a reclaiming, they have purchased a\\n        // token, therefore we are guaranteed to have a populated\\n        // latestPurchasePrice\\n        uint256 currentSettledTokenPrice = _projectConfig.latestPurchasePrice;\\n\\n        // EFFECTS\\n        // calculate the excess settlement funds amount\\n        // implicit overflow/underflow checks in solidity ^0.8\\n        uint256 requiredAmountPosted = numPurchased * currentSettledTokenPrice;\\n        uint256 excessSettlementFunds = receipt.netPosted -\\n            requiredAmountPosted;\\n        // update Receipt in storage\\n        receipt.netPosted = requiredAmountPosted.toUint232();\\n        // emit event indicating new receipt state\\n        emit ReceiptUpdated(\\n            msg.sender,\\n            _projectId,\\n            numPurchased,\\n            requiredAmountPosted\\n        );\\n\\n        // INTERACTIONS\\n        bool success_;\\n        (success_, ) = _to.call{value: excessSettlementFunds}(\\\"\\\");\\n        require(success_, \\\"Reclaiming failed\\\");\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * projects in `_projectIds`. The current settled price is the the price\\n     * paid for the most recently purchased token, or the base price if the\\n     * artist has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends total of all excess settlement funds to msg.sender in a single\\n     * chunk. Entire transaction reverts if any excess settlement calculation\\n     * fails.\\n     * @param _projectIds Array of project IDs to reclaim excess settlement\\n     * funds on.\\n     */\\n    function reclaimProjectsExcessSettlementFunds(\\n        uint256[] calldata _projectIds\\n    ) external {\\n        reclaimProjectsExcessSettlementFundsTo(\\n            payable(msg.sender),\\n            _projectIds\\n        );\\n    }\\n\\n    /**\\n     * @notice Reclaims the sender's payment above current settled price for\\n     * projects in `_projectIds`. The current settled price is the the price\\n     * paid for the most recently purchased token, or the base price if the\\n     * artist has withdrawn revenues after the auction reached base price.\\n     * This function is callable at any point, but is expected to typically be\\n     * called after auction has sold out above base price or after the auction\\n     * has been purchased at base price. This minimizes the amount of gas\\n     * required to send all excess settlement funds to the sender.\\n     * Sends total of all excess settlement funds to `_to` in a single\\n     * chunk. Entire transaction reverts if any excess settlement calculation\\n     * fails.\\n     * @param _to Address to send excess settlement funds to.\\n     * @param _projectIds Array of project IDs to reclaim excess settlement\\n     * funds on.\\n     */\\n    function reclaimProjectsExcessSettlementFundsTo(\\n        address payable _to,\\n        uint256[] memory _projectIds\\n    ) public nonReentrant {\\n        // CHECKS\\n        // input validation\\n        require(_to != address(0), \\\"No claiming to the zero address\\\");\\n        // EFFECTS\\n        // for each project, tally up the excess settlement funds and update\\n        // the receipt in storage\\n        uint256 excessSettlementFunds;\\n        uint256 projectIdsLength = _projectIds.length;\\n        for (uint256 i; i < projectIdsLength; ) {\\n            uint256 projectId = _projectIds[i];\\n            ProjectConfig storage _projectConfig = projectConfig[projectId];\\n            Receipt storage receipt = receipts[msg.sender][projectId];\\n            uint256 numPurchased = receipt.numPurchased;\\n            // input validation\\n            // require that a user has purchased at least one token on this project\\n            require(numPurchased > 0, \\\"No purchases made by this address\\\");\\n            // get the latestPurchasePrice, which returns the sellout price if the\\n            // auction sold out before reaching base price, or returns the base\\n            // price if auction has reached base price and artist has withdrawn\\n            // revenues.\\n            // @dev if user is eligible for a claim, they have purchased a token,\\n            // therefore we are guaranteed to have a populated\\n            // latestPurchasePrice\\n            uint256 currentSettledTokenPrice = _projectConfig\\n                .latestPurchasePrice;\\n            // calculate the excessSettlementFunds amount\\n            // implicit overflow/underflow checks in solidity ^0.8\\n            uint256 requiredAmountPosted = numPurchased *\\n                currentSettledTokenPrice;\\n            excessSettlementFunds += (receipt.netPosted - requiredAmountPosted);\\n            // reduce the netPosted (in storage) to value after excess settlement\\n            // funds deducted\\n            receipt.netPosted = requiredAmountPosted.toUint232();\\n            // emit event indicating new receipt state\\n            emit ReceiptUpdated(\\n                msg.sender,\\n                projectId,\\n                numPurchased,\\n                requiredAmountPosted\\n            );\\n            // gas efficiently increment i\\n            // won't overflow due to for loop, as well as gas limts\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // INTERACTIONS\\n        // send excess settlement funds in a single chunk for all\\n        // projects\\n        bool success_;\\n        (success_, ) = _to.call{value: excessSettlementFunds}(\\\"\\\");\\n        require(success_, \\\"Reclaiming failed\\\");\\n    }\\n\\n    /**\\n     * @notice Gets price of minting a token on project `_projectId` given\\n     * the project's AuctionParameters and current block timestamp.\\n     * Reverts if auction has not yet started or auction is unconfigured.\\n     * Returns auction last purchase price if auction sold out before reaching\\n     * base price.\\n     * @param _projectId Project ID to get price of token for.\\n     * @return current price of token in Wei\\n     * @dev This method calculates price decay using a linear interpolation\\n     * of exponential decay based on the artist-provided half-life for price\\n     * decay, `_priceDecayHalfLifeSeconds`.\\n     */\\n    function _getPrice(uint256 _projectId) private view returns (uint256) {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        // if auction sold out on this minter, return the latest purchase\\n        // price (which is the sellout price). This is the price that is due\\n        // after an auction is complete.\\n        if (_projectConfig.maxHasBeenInvoked) {\\n            return _projectConfig.latestPurchasePrice;\\n        }\\n        // otherwise calculate price based on current block timestamp and\\n        // auction configuration (will revert if auction has not started)\\n        // move parameters to memory if used more than once\\n        uint256 _timestampStart = uint256(_projectConfig.timestampStart);\\n        uint256 _priceDecayHalfLifeSeconds = uint256(\\n            _projectConfig.priceDecayHalfLifeSeconds\\n        );\\n        uint256 _basePrice = _projectConfig.basePrice;\\n\\n        require(block.timestamp > _timestampStart, \\\"Auction not yet started\\\");\\n        require(_priceDecayHalfLifeSeconds > 0, \\\"Only configured auctions\\\");\\n        uint256 decayedPrice = _projectConfig.startPrice;\\n        uint256 elapsedTimeSeconds;\\n        unchecked {\\n            // already checked that block.timestamp > _timestampStart above\\n            elapsedTimeSeconds = block.timestamp - _timestampStart;\\n        }\\n        // Divide by two (via bit-shifting) for the number of entirely completed\\n        // half-lives that have elapsed since auction start time.\\n        unchecked {\\n            // already required _priceDecayHalfLifeSeconds > 0\\n            decayedPrice >>= elapsedTimeSeconds / _priceDecayHalfLifeSeconds;\\n        }\\n        // Perform a linear interpolation between partial half-life points, to\\n        // approximate the current place on a perfect exponential decay curve.\\n        unchecked {\\n            // value of expression is provably always less than decayedPrice,\\n            // so no underflow is possible when the subtraction assignment\\n            // operator is used on decayedPrice.\\n            decayedPrice -=\\n                (decayedPrice *\\n                    (elapsedTimeSeconds % _priceDecayHalfLifeSeconds)) /\\n                _priceDecayHalfLifeSeconds /\\n                2;\\n        }\\n        if (decayedPrice < _basePrice) {\\n            // Price may not decay below stay `basePrice`.\\n            return _basePrice;\\n        }\\n        return decayedPrice;\\n    }\\n\\n    /**\\n     * @notice Gets the current excess settlement funds on project `_projectId`\\n     * for address `_walletAddress`. The returned value is expected to change\\n     * throughtout an auction, since the latest purchase price is used when\\n     * determining excess settlement funds.\\n     * A user may claim excess settlement funds by calling the function\\n     * `reclaimProjectExcessSettlementFunds(_projectId)`.\\n     * @param _projectId Project ID to query.\\n     * @param _walletAddress Account address for which the excess posted funds\\n     * is being queried.\\n     * @return excessSettlementFundsInWei Amount of excess settlement funds, in\\n     * wei\\n     */\\n    function getProjectExcessSettlementFunds(\\n        uint256 _projectId,\\n        address _walletAddress\\n    ) external view returns (uint256 excessSettlementFundsInWei) {\\n        // input validation\\n        require(_walletAddress != address(0), \\\"No zero address\\\");\\n        // load struct from storage\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        Receipt storage receipt = receipts[_walletAddress][_projectId];\\n        // require that a user has purchased at least one token on this project\\n        require(receipt.numPurchased > 0, \\\"No purchases made by this address\\\");\\n        // get the latestPurchasePrice, which returns the sellout price if the\\n        // auction sold out before reaching base price, or returns the base\\n        // price if auction has reached base price and artist has withdrawn\\n        // revenues.\\n        // @dev if user is eligible for a reclaiming, they have purchased a\\n        // token, therefore we are guaranteed to have a populated\\n        // latestPurchasePrice\\n        uint256 currentSettledTokenPrice = _projectConfig.latestPurchasePrice;\\n\\n        // EFFECTS\\n        // calculate the excess settlement funds amount and return\\n        // implicit overflow/underflow checks in solidity ^0.8\\n        uint256 requiredAmountPosted = receipt.numPurchased *\\n            currentSettledTokenPrice;\\n        excessSettlementFundsInWei = receipt.netPosted - requiredAmountPosted;\\n        return excessSettlementFundsInWei;\\n    }\\n\\n    /**\\n     * @notice Gets the latest purchase price for project `_projectId`, or 0 if\\n     * no purchases have been made.\\n     */\\n    function getProjectLatestPurchasePrice(\\n        uint256 _projectId\\n    ) external view returns (uint256 latestPurchasePrice) {\\n        return projectConfig[_projectId].latestPurchasePrice;\\n    }\\n\\n    /**\\n     * @notice Gets the number of settleable invocations for project `_projectId`.\\n     */\\n    function getNumSettleableInvocations(\\n        uint256 _projectId\\n    ) external view returns (uint256 numSettleableInvocations) {\\n        return projectConfig[_projectId].numSettleableInvocations;\\n    }\\n\\n    /**\\n     * @notice Gets if price of token is configured, price of minting a\\n     * token on project `_projectId`, and currency symbol and address to be\\n     * used as payment. Supersedes any core contract price information.\\n     * @param _projectId Project ID to get price information for.\\n     * @return isConfigured true only if project's auction parameters have been\\n     * configured on this minter\\n     * @return tokenPriceInWei current price of token on this minter - invalid\\n     * if auction has not yet been configured\\n     * @return currencySymbol currency symbol for purchases of project on this\\n     * minter. This minter always returns \\\"ETH\\\"\\n     * @return currencyAddress currency address for purchases of project on\\n     * this minter. This minter always returns null address, reserved for ether\\n     */\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        )\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n\\n        isConfigured = (_projectConfig.startPrice > 0);\\n        if (block.timestamp <= _projectConfig.timestampStart) {\\n            // Provide a reasonable value for `tokenPriceInWei` when it would\\n            // otherwise revert, using the starting price before auction starts.\\n            tokenPriceInWei = _projectConfig.startPrice;\\n        } else if (_projectConfig.startPrice == 0) {\\n            // In the case of unconfigured auction, return price of zero when\\n            // it would otherwise revert\\n            tokenPriceInWei = 0;\\n        } else {\\n            tokenPriceInWei = _getPrice(_projectId);\\n        }\\n        currencySymbol = \\\"ETH\\\";\\n        currencyAddress = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterDAExpSettlement_Mixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface is a mixin for IFilteredMinterExpSettlementV<version>\\n * interfaces to use when defining settlement minter interfaces.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterDAExpSettlement_Mixin {\\n    /// Auction details cleared for project `projectId`.\\n    /// At time of reset, the project has had `numPurchases` purchases on this\\n    /// minter, with a most recent purchase price of `latestPurchasePrice`. If\\n    /// the number of purchases is 0, the latest purchase price will have a\\n    /// dummy value of 0.\\n    event ResetAuctionDetails(\\n        uint256 indexed projectId,\\n        uint256 numPurchases,\\n        uint256 latestPurchasePrice\\n    );\\n\\n    /// sellout price updated for project `projectId`.\\n    /// @dev does not use generic event because likely will trigger additional\\n    /// actions in indexing layer\\n    event SelloutPriceUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _selloutPrice\\n    );\\n\\n    /// artist and admin have withdrawn revenues from settleable purchases for\\n    /// project `projectId`.\\n    /// @dev does not use generic event because likely will trigger additional\\n    /// actions in indexing layer\\n    event ArtistAndAdminRevenuesWithdrawn(uint256 indexed _projectId);\\n\\n    /// receipt has an updated state\\n    event ReceiptUpdated(\\n        address indexed _purchaser,\\n        uint256 indexed _projectId,\\n        uint256 _numPurchased,\\n        uint256 _netPosted\\n    );\\n\\n    /// returns latest purchase price for project `_projectId`, or 0 if no\\n    /// purchases have been made.\\n    function getProjectLatestPurchasePrice(\\n        uint256 _projectId\\n    ) external view returns (uint256 latestPurchasePrice);\\n\\n    /// returns the number of settleable invocations for project `_projectId`.\\n    function getNumSettleableInvocations(\\n        uint256 _projectId\\n    ) external view returns (uint256 numSettleableInvocations);\\n\\n    /// Returns the current excess settlement funds on project `_projectId`\\n    /// for address `_walletAddress`.\\n    function getProjectExcessSettlementFunds(\\n        uint256 _projectId,\\n        address _walletAddress\\n    ) external view returns (uint256 excessSettlementFundsInWei);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterDAExpSettlementV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterDAExpSettlement_Mixin.sol\\\";\\nimport \\\"./IFilteredMinterV1.sol\\\";\\nimport \\\"./IFilteredMinterDAExpV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface combines the set of interfaces that add support for\\n * a Dutch Auction with Settlement minter.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterDAExpSettlementV0 is\\n    IFilteredMinterDAExpSettlement_Mixin,\\n    IFilteredMinterV1,\\n    IFilteredMinterDAExpV0\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterDAExpV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for exponential descending auctions.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterDAExpV0 is IFilteredMinterV0 {\\n    /// Auction details updated for project `projectId`.\\n    event SetAuctionDetails(\\n        uint256 indexed projectId,\\n        uint256 _auctionTimestampStart,\\n        uint256 _priceDecayHalfLifeSeconds,\\n        uint256 _startPrice,\\n        uint256 _basePrice\\n    );\\n\\n    /// Auction details cleared for project `projectId`.\\n    event ResetAuctionDetails(uint256 indexed projectId);\\n\\n    /// Maximum and minimum allowed price decay half lifes updated.\\n    event AuctionHalfLifeRangeSecondsUpdated(\\n        uint256 _minimumPriceDecayHalfLifeSeconds,\\n        uint256 _maximumPriceDecayHalfLifeSeconds\\n    );\\n\\n    function minimumPriceDecayHalfLifeSeconds() external view returns (uint256);\\n\\n    function maximumPriceDecayHalfLifeSeconds() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFilteredMinterV0 {\\n    /**\\n     * @notice Price per token in wei updated for project `_projectId` to\\n     * `_pricePerTokenInWei`.\\n     */\\n    event PricePerTokenInWeiUpdated(\\n        uint256 indexed _projectId,\\n        uint256 indexed _pricePerTokenInWei\\n    );\\n\\n    /**\\n     * @notice Currency updated for project `_projectId` to symbol\\n     * `_currencySymbol` and address `_currencyAddress`.\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed _projectId,\\n        address indexed _currencyAddress,\\n        string _currencySymbol\\n    );\\n\\n    /// togglePurchaseToDisabled updated\\n    event PurchaseToDisabledUpdated(\\n        uint256 indexed _projectId,\\n        bool _purchaseToDisabled\\n    );\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Toggles the ability for `purchaseTo` to be called directly with a\\n    // specified receiving address that differs from the TX-sending address.\\n    function togglePurchaseToDisabled(uint256 _projectId) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function setProjectMaxInvocations(uint256 _projectId) external;\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for generic project minter configuration updates.\\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\\n * gas.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\\n    /// ANY\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `_key`\\n     * for project `_projectId`.\\n     */\\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\\n\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\\n\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @dev Strings not supported. Recommend conversion of (short) strings to\\n     * bytes32 to remain gas-efficient.\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\\n    /**\\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\\n     * updated to `_maxInvocations`.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _maxInvocations\\n    );\\n\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 renderProviderRevenue_,\\n            address payable renderProviderAddress_,\\n            uint256 platformProviderRevenue_,\\n            address payable platformProviderAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev The render provider primary sales payment address\\n    function renderProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider primary sales payment address\\n    function platformProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to the render provider\\n    function renderProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev Percentage of primary sales allocated to the platform provider\\n    function platformProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev The render provider secondary sales royalties payment address\\n    function renderProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider secondary sales royalties payment address\\n    function platformProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to the render provider\\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\\n\\n    // @dev Basis points of secondary sales allocated to the platform provider\\n    function platformProviderSecondarySalesBPS()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\n/**\\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\\n * that are part of the Art Blocks Flagship core contract.\\n * @author Art Blocks Inc.\\n */\\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\\n// in part of the Art Blocks Flagship core contract.\\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 artblocksRevenue_,\\n            address payable artblocksAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev Art Blocks primary sales payment address\\n    function artblocksPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\\n     */\\n    function artblocksAddress() external view returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to Art Blocks\\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\\n     */\\n    function artblocksPercentage() external view returns (uint256);\\n\\n    // @dev Art Blocks secondary sales royalties payment address\\n    function artblocksSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to Art Blocks\\n    function artblocksSecondarySalesBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\\n     * artist's additional payee royalty data for token ID `_tokenId`.\\n     * WARNING: Does not include Art Blocks portion of royalties.\\n     */\\n    function getRoyaltyData(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterBaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface defines any events or functions required for a minter\\n * to conform to the MinterBase contract.\\n * @dev The MinterBase contract was not implemented from the beginning of the\\n * MinterSuite contract suite, therefore early versions of some minters may not\\n * conform to this interface.\\n * @author Art Blocks Inc.\\n */\\ninterface IMinterBaseV0 {\\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\\n    // Returns true only if the minter is configured to integrate with an engine contract.\\n    function isEngine() external returns (bool isEngine);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMinterFilterV0 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Approved minter `_minterAddress`.\\n     */\\n    event MinterApproved(address indexed _minterAddress, string _minterType);\\n\\n    /**\\n     * @notice Revoked approval for minter `_minterAddress`\\n     */\\n    event MinterRevoked(address indexed _minterAddress);\\n\\n    /**\\n     * @notice Minter `_minterAddress` of type `_minterType`\\n     * registered for project `_projectId`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed _projectId,\\n        address indexed _minterAddress,\\n        string _minterType\\n    );\\n\\n    /**\\n     * @notice Any active minter removed for project `_projectId`.\\n     */\\n    event ProjectMinterRemoved(uint256 indexed _projectId);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function setMinterForProject(uint256, address) external;\\n\\n    function removeMinterForProject(uint256) external;\\n\\n    function mint(\\n        address _to,\\n        uint256 _projectId,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function getMinterForProject(uint256) external view returns (address);\\n\\n    function projectHasMinter(uint256) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterBase_v0_1_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../interfaces/v0.8.x/IMinterBaseV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\\\";\\n\\nimport \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Minter Base Class\\n * @notice A base class for Art Blocks minter contracts that provides common\\n * functionality used across minter contracts.\\n * This contract is not intended to be deployed directly, but rather to be\\n * inherited by other minter contracts.\\n * From a design perspective, this contract is intended to remain simple and\\n * easy to understand. It is not intended to cause a complex inheritance tree,\\n * and instead should keep minter contracts as readable as possible for\\n * collectors and developers.\\n * @dev Semantic versioning is used in the solidity file name, and is therefore\\n * controlled by contracts importing the appropriate filename version.\\n * @author Art Blocks Inc.\\n */\\nabstract contract MinterBase is IMinterBaseV0 {\\n    /// state variable that tracks whether this contract's associated core\\n    /// contract is an Engine contract, where Engine contracts have an\\n    /// additional revenue split for the platform provider\\n    bool public immutable isEngine;\\n\\n    // @dev we do not track an initialization state, as the only state variable\\n    // is immutable, which the compiler enforces to be assigned during\\n    // construction.\\n\\n    /**\\n     * @notice Initializes contract to ensure state variable `isEngine` is set\\n     * appropriately based on the minter's associated core contract address.\\n     * @param genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     */\\n    constructor(address genArt721Address) {\\n        // set state variable isEngine\\n        isEngine = _getV3CoreIsEngine(genArt721Address);\\n    }\\n\\n    /**\\n     * @notice splits ETH funds between sender (if refund), providers,\\n     * artist, and artist's additional payee for a token purchased on\\n     * project `_projectId`.\\n     * WARNING: This function uses msg.value and msg.sender to determine\\n     * refund amounts, and therefore may not be applicable to all use cases\\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerTokenInWei Current price of token, in Wei.\\n     */\\n    function splitFundsETH(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address genArt721CoreAddress\\n    ) internal {\\n        if (msg.value > 0) {\\n            bool success_;\\n            // send refund to sender\\n            uint256 refund = msg.value - pricePerTokenInWei;\\n            if (refund > 0) {\\n                (success_, ) = msg.sender.call{value: refund}(\\\"\\\");\\n                require(success_, \\\"Refund failed\\\");\\n            }\\n            // split revenues\\n            splitRevenuesETH(\\n                projectId,\\n                pricePerTokenInWei,\\n                genArt721CoreAddress\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ETH revenues between providers, artist, and artist's\\n     * additional payee for revenue generated by project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param valueInWei Value to be split, in Wei.\\n     */\\n    function splitRevenuesETH(\\n        uint256 projectId,\\n        uint256 valueInWei,\\n        address genArtCoreContract\\n    ) internal {\\n        if (valueInWei <= 0) {\\n            return; // return early\\n        }\\n        bool success;\\n        // split funds between platforms, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                (success, ) = platformProviderAddress_.call{\\n                    value: platformProviderRevenue_\\n                }(\\\"\\\");\\n                require(success, \\\"Platform Provider payment failed\\\");\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n        }\\n        // Render Provider / Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            (success, ) = renderProviderAddress_.call{\\n                value: renderProviderRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Render Provider payment failed\\\");\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            (success, ) = artistAddress_.call{value: artistRevenue_}(\\\"\\\");\\n            require(success, \\\"Artist payment failed\\\");\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            (success, ) = additionalPayeePrimaryAddress_.call{\\n                value: additionalPayeePrimaryRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Additional Payee payment failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ERC-20 funds between providers, artist, and artist's\\n     * additional payee, for a token purchased on project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     */\\n    function splitFundsERC20(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address currencyAddress,\\n        address genArtCoreContract\\n    ) internal {\\n        IERC20 _projectCurrency = IERC20(currencyAddress);\\n        // split remaining funds between foundation, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                _projectCurrency.transferFrom(\\n                    msg.sender,\\n                    platformProviderAddress_,\\n                    platformProviderRevenue_\\n                );\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n        }\\n        // Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                renderProviderAddress_,\\n                renderProviderRevenue_\\n            );\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                artistAddress_,\\n                artistRevenue_\\n            );\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                additionalPayeePrimaryAddress_,\\n                additionalPayeePrimaryRevenue_\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\\n     * contract or not. Return value of false indicates that the core is a\\n     * flagship contract.\\n     * @dev this function reverts if a core contract does not return the\\n     * expected number of return values from getPrimaryRevenueSplits() for\\n     * either a flagship or engine core contract.\\n     * @dev this function uses the length of the return data (in bytes) to\\n     * determine whether the core is an engine or not.\\n     * @param genArt721CoreV3 The address of the deployed core contract.\\n     */\\n    function _getV3CoreIsEngine(\\n        address genArt721CoreV3\\n    ) private returns (bool) {\\n        // call getPrimaryRevenueSplits() on core contract\\n        bytes memory payload = abi.encodeWithSignature(\\n            \\\"getPrimaryRevenueSplits(uint256,uint256)\\\",\\n            0,\\n            0\\n        );\\n        (bool success, bytes memory returnData) = genArt721CoreV3.call(payload);\\n        require(success, \\\"getPrimaryRevenueSplits() call failed\\\");\\n        // determine whether core is engine or not, based on return data length\\n        uint256 returnDataLength = returnData.length;\\n        if (returnDataLength == 6 * 32) {\\n            // 6 32-byte words returned if flagship (not engine)\\n            // @dev 6 32-byte words are expected because the non-engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, and artist's additional payee, and Art Blocks.\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return false;\\n        } else if (returnDataLength == 8 * 32) {\\n            // 8 32-byte words returned if engine\\n            // @dev 8 32-byte words are expected because the engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, artist's additional payee, render provider\\n            // typically Art Blocks, and platform provider (partner).\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return true;\\n        } else {\\n            // unexpected return value length\\n            revert(\\\"Unexpected revenue split bytes\\\");\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_genArt721Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minterFilter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"ArtistAndAdminRevenuesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minimumPriceDecayHalfLifeSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maximumPriceDecayHalfLifeSeconds\",\"type\":\"uint256\"}],\"name\":\"AuctionHalfLifeRangeSecondsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"ConfigKeyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_pricePerTokenInWei\",\"type\":\"uint256\"}],\"name\":\"PricePerTokenInWeiUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_currencySymbol\",\"type\":\"string\"}],\"name\":\"ProjectCurrencyInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_purchaseToDisabled\",\"type\":\"bool\"}],\"name\":\"PurchaseToDisabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numPurchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_netPosted\",\"type\":\"uint256\"}],\"name\":\"ReceiptUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"ResetAuctionDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numPurchases\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"latestPurchasePrice\",\"type\":\"uint256\"}],\"name\":\"ResetAuctionDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_selloutPrice\",\"type\":\"uint256\"}],\"name\":\"SelloutPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_auctionTimestampStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_priceDecayHalfLifeSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_basePrice\",\"type\":\"uint256\"}],\"name\":\"SetAuctionDetails\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSelloutPrice\",\"type\":\"uint256\"}],\"name\":\"adminEmergencyReduceSelloutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genArt721CoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getNumSettleableInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numSettleableInvocations\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"getProjectExcessSettlementFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"excessSettlementFundsInWei\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getProjectLatestPurchasePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"latestPurchasePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEngine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumPriceDecayHalfLifeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumPriceDecayHalfLifeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectAuctionParameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestampStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDecayHalfLifeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"maxHasBeenInvoked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"auctionRevenuesCollected\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"numSettleableInvocations\",\"type\":\"uint24\"},{\"internalType\":\"uint64\",\"name\":\"timestampStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"priceDecayHalfLifeSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"startPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"basePrice\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"latestPurchasePrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchaseTo_do6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"purchase_H4M\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"reclaimProjectExcessSettlementFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"reclaimProjectExcessSettlementFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_projectIds\",\"type\":\"uint256[]\"}],\"name\":\"reclaimProjectsExcessSettlementFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_projectIds\",\"type\":\"uint256[]\"}],\"name\":\"reclaimProjectsExcessSettlementFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"resetAuctionDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumPriceDecayHalfLifeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumPriceDecayHalfLifeSeconds\",\"type\":\"uint256\"}],\"name\":\"setAllowablePriceDecayHalfLifeRangeSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionTimestampStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceDecayHalfLifeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_basePrice\",\"type\":\"uint256\"}],\"name\":\"setAuctionDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"togglePurchaseToDisabled\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"withdrawArtistAndAdminRevenues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterDAExpSettlementV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "00000000000000000000000031a1bfb7ad3e3e6198d7a50012a4213594875d1400000000000000000000000070598d7abc7cfa3c4b5ba94fe2a779c92bf69ed4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}