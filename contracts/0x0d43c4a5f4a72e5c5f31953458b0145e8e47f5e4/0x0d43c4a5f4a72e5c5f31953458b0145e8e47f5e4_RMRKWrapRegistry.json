{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"../library/RMRKErrors.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @author RMRK team\\n * @notice A minimal ownable smart contractf or owner and contributors.\\n * @dev This smart contract is based on \\\"openzeppelin's access/Ownable.sol\\\".\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n    mapping(address => uint256) private _contributors;\\n\\n    /**\\n     * @notice Used to anounce the transfer of ownership.\\n     * @param previousOwner Address of the account that transferred their ownership role\\n     * @param newOwner Address of the account receiving the ownership role\\n     */\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @notice Event that signifies that an address was granted contributor role or that the permission has been\\n     *  revoked.\\n     * @dev This can only be triggered by a current owner, so there is no need to include that information in the event.\\n     * @param contributor Address of the account that had contributor role status updated\\n     * @param isContributor A boolean value signifying whether the role has been granted (`true`) or revoked (`false`)\\n     */\\n    event ContributorUpdate(address indexed contributor, bool isContributor);\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner or an approved contributor.\\n     */\\n    modifier onlyOwnerOrContributor() {\\n        _onlyOwnerOrContributor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract by setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     * @return Address of the current owner\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. Functions using the `onlyOwner` modifier will be disabled.\\n     * @dev Can only be called by the current owner.\\n     * @dev Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is\\n     *  only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) revert RMRKNewOwnerIsZeroAddress();\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new owner.\\n     * @dev Internal function without access restriction.\\n     * @dev Emits ***OwnershipTransferred*** event.\\n     * @param newOwner Address of the new owner's account\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @notice Adds or removes a contributor to the smart contract.\\n     * @dev Can only be called by the owner.\\n     * @dev Emits ***ContributorUpdate*** event.\\n     * @param contributor Address of the contributor's account\\n     * @param grantRole A boolean value signifying whether the contributor role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function manageContributor(\\n        address contributor,\\n        bool grantRole\\n    ) external onlyOwner {\\n        if (contributor == address(0)) revert RMRKNewContributorIsZeroAddress();\\n        grantRole\\n            ? _contributors[contributor] = 1\\n            : _contributors[contributor] = 0;\\n        emit ContributorUpdate(contributor, grantRole);\\n    }\\n\\n    /**\\n     * @notice Used to check if the address is one of the contributors.\\n     * @param contributor Address of the contributor whose status we are checking\\n     * @return Boolean value indicating whether the address is a contributor or not\\n     */\\n    function isContributor(address contributor) public view returns (bool) {\\n        return _contributors[contributor] == 1;\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner or a contributor.\\n     * @dev If the caller is not the owner or a contributor, the execution will be reverted.\\n     */\\n    function _onlyOwnerOrContributor() private view {\\n        if (owner() != _msgSender() && !isContributor(_msgSender()))\\n            revert RMRKNotOwnerOrContributor();\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is the owner.\\n     * @dev If the caller is not the owner, the execution will be reverted.\\n     */\\n    function _onlyOwner() private view {\\n        if (owner() != _msgSender()) revert RMRKNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/library/RMRKErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\n/// @title RMRKErrors\\n/// @author RMRK team\\n/// @notice A collection of errors used in the RMRK suite\\n/// @dev Errors are kept in a centralised file in order to provide a central point of reference and to avoid error\\n///  naming collisions due to inheritance\\n\\n/// Attempting to grant the token to 0x0 address\\nerror ERC721AddressZeroIsNotaValidOwner();\\n/// Attempting to grant approval to the current owner of the token\\nerror ERC721ApprovalToCurrentOwner();\\n/// Attempting to grant approval when not being owner or approved for all should not be permitted\\nerror ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to get approvals for a token owned by 0x0 (considered non-existent)\\nerror ERC721ApprovedQueryForNonexistentToken();\\n/// Attempting to grant approval to self\\nerror ERC721ApproveToCaller();\\n/// Attempting to use an invalid token ID\\nerror ERC721InvalidTokenId();\\n/// Attempting to mint to 0x0 address\\nerror ERC721MintToTheZeroAddress();\\n/// Attempting to manage a token without being its owner or approved by the owner\\nerror ERC721NotApprovedOrOwner();\\n/// Attempting to mint an already minted token\\nerror ERC721TokenAlreadyMinted();\\n/// Attempting to transfer the token from an address that is not the owner\\nerror ERC721TransferFromIncorrectOwner();\\n/// Attempting to safe transfer to an address that is unable to receive the token\\nerror ERC721TransferToNonReceiverImplementer();\\n/// Attempting to transfer the token to a 0x0 address\\nerror ERC721TransferToTheZeroAddress();\\n/// Attempting to grant approval of assets to their current owner\\nerror RMRKApprovalForAssetsToCurrentOwner();\\n/// Attempting to grant approval of assets without being the caller or approved for all\\nerror RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to incorrectly configue a Catalog item\\nerror RMRKBadConfig();\\n/// Attempting to set the priorities with an array of length that doesn't match the length of active assets array\\nerror RMRKBadPriorityListLength();\\n/// Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\\nerror RMRKCatalogRequiredForParts();\\n/// Attempting to transfer a soulbound (non-transferrable) token\\nerror RMRKCannotTransferSoulbound();\\n/// Attempting to accept a child that has already been accepted\\nerror RMRKChildAlreadyExists();\\n/// Attempting to interact with a child, using index that is higher than the number of children\\nerror RMRKChildIndexOutOfRange();\\n/// Attempting to find the index of a child token on a parent which does not own it.\\nerror RMRKChildNotFoundInParent();\\n/// Attempting to pass collaborator address array and collaborator permission array of different lengths\\nerror RMRKCollaboratorArraysNotEqualLength();\\n/// Attempting to register a collection that is already registered\\nerror RMRKCollectionAlreadyRegistered();\\n/// Attempting to manage or interact with colleciton that is not registered\\nerror RMRKCollectionNotRegistered();\\n/// Attempting to equip a `Part` with a child not approved by the Catalog\\nerror RMRKEquippableEquipNotAllowedByCatalog();\\n/// Attempting to pass an epired ECDSA deadline\\nerror RMRKExpiredDeadline();\\n/// Attempting to use ID 0, which is not supported\\n/// @dev The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\\nerror RMRKIdZeroForbidden();\\n/// Attempting to interact with an asset, using index greater than number of assets\\nerror RMRKIndexOutOfRange();\\n/// Attempting to reclaim a child that can't be reclaimed\\nerror RMRKInvalidChildReclaim();\\n/// Attempting to use and invalid ECDSA signature\\nerror RMRKInvalidSignature();\\n/// Attempting to interact with an end-user account when the contract account is expected\\nerror RMRKIsNotContract();\\n/// Attempting to interact with a contract that had its operation locked\\nerror RMRKLocked();\\n/// Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\\nerror RMRKMaxPendingChildrenReached();\\n/// Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is\\n///  128)\\nerror RMRKMaxPendingAssetsReached();\\n/// Attempting to burn a total number of recursive children higher than maximum set\\n/// @param childContract Address of the collection smart contract in which the maximum number of recursive burns was reached\\n/// @param childId ID of the child token at which the maximum number of recursive burns was reached\\nerror RMRKMaxRecursiveBurnsReached(address childContract, uint256 childId);\\n/// Attempting to mint a number of tokens that would cause the total supply to be greater than maximum supply\\nerror RMRKMintOverMax();\\n/// Attempting to mint a nested token to a smart contract that doesn't support nesting\\nerror RMRKMintToNonRMRKNestableImplementer();\\n/// Attempting to mint zero tokens\\nerror RMRKMintZero();\\n/// Attempting to pass complementary arrays of different lengths\\nerror RMRKMismachedArrayLength();\\n/// Attempting to transfer a child before it is unequipped\\nerror RMRKMustUnequipFirst();\\n/// Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\\nerror RMRKNestableTooDeep();\\n/// Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\\nerror RMRKNestableTransferToDescendant();\\n/// Attempting to nest the token to a smart contract that doesn't support nesting\\nerror RMRKNestableTransferToNonRMRKNestableImplementer();\\n/// Attempting to nest the token into itself\\nerror RMRKNestableTransferToSelf();\\n/// Attempting to interact with an asset that can not be found\\nerror RMRKNoAssetMatchingId();\\n/// Attempting to manage an asset without owning it or having been granted permission by the owner to do so\\nerror RMRKNotApprovedForAssetsOrOwner();\\n/// Attempting to interact with a token without being its owner or having been granted permission by the\\n///  owner to do so\\n/// @dev When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are\\n///  not allowed to manage it, in order to ensure the expected behaviour\\nerror RMRKNotApprovedOrDirectOwner();\\n/// Attempting to manage a collection without being the collection's collaborator\\nerror RMRKNotCollectionCollaborator();\\n/// Attemting to manage a collection without being the collection's issuer\\nerror RMRKNotCollectionIssuer();\\n/// Attempting to manage a collection without being the collection's issuer or collaborator\\nerror RMRKNotCollectionIssuerOrCollaborator();\\n/// Attempting to compose an asset wihtout having an associated Catalog\\nerror RMRKNotComposableAsset();\\n/// Attempting to unequip an item that isn't equipped\\nerror RMRKNotEquipped();\\n/// Attempting to interact with a management function without being the smart contract's owner\\nerror RMRKNotOwner();\\n/// Attempting to interact with a function without being the owner or contributor of the collection\\nerror RMRKNotOwnerOrContributor();\\n/// Attempting to manage a collection without being the specific address\\nerror RMRKNotSpecificAddress();\\n/// Attempting to manage a token without being its owner\\nerror RMRKNotTokenOwner();\\n/// Attempting to transfer the ownership to the 0x0 address\\nerror RMRKNewOwnerIsZeroAddress();\\n/// Attempting to assign a 0x0 address as a contributor\\nerror RMRKNewContributorIsZeroAddress();\\n/// Attemtping to use `Ownable` interface without implementing it\\nerror RMRKOwnableNotImplemented();\\n/// Attempting an operation requiring the token being nested, while it is not\\nerror RMRKParentIsNotNFT();\\n/// Attempting to add a `Part` with an ID that is already used\\nerror RMRKPartAlreadyExists();\\n/// Attempting to use a `Part` that doesn't exist\\nerror RMRKPartDoesNotExist();\\n/// Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\\nerror RMRKPartIsNotSlot();\\n/// Attempting to interact with a pending child using an index greater than the size of pending array\\nerror RMRKPendingChildIndexOutOfRange();\\n/// Attempting to add an asset using an ID that has already been used\\nerror RMRKAssetAlreadyExists();\\n/// Attempting to equip an item into a slot that already has an item equipped\\nerror RMRKSlotAlreadyUsed();\\n/// Attempting to equip an item into a `Slot` that the target asset does not implement\\nerror RMRKTargetAssetCannotReceiveSlot();\\n/// Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\\nerror RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n/// Attempting to compose a NFT of a token without active assets\\nerror RMRKTokenDoesNotHaveAsset();\\n/// Attempting to determine the asset with the top priority on a token without assets\\nerror RMRKTokenHasNoAssets();\\n/// Attempting to accept or transfer a child which does not match the one at the specified index\\nerror RMRKUnexpectedChildId();\\n/// Attempting to reject all pending assets but more assets than expected are pending\\nerror RMRKUnexpectedNumberOfAssets();\\n/// Attempting to reject all pending children but children assets than expected are pending\\nerror RMRKUnexpectedNumberOfChildren();\\n/// Attempting to accept or reject an asset which does not match the one at the specified index\\nerror RMRKUnexpectedAssetId();\\n/// Attempting an operation expecting a parent to the token which is not the actual one\\nerror RMRKUnexpectedParent();\\n/// Attempting not to pass an empty array of equippable addresses when adding or setting the equippable addresses\\nerror RMRKZeroLengthIdsPassed();\\n/// Attempting to set the royalties to a value higher than 100% (10000 in basis points)\\nerror RMRKRoyaltiesTooHigh();\\n/// Attempting to do a bulk operation on a token that is not owned by the caller\\nerror RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n/// Attempting to do a bulk operation with multiple tokens at a time\\nerror RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n/// Attempting to pay with native token with a value different than expected\\nerror RMRKWrongValueSent();\\n\"\r\n    },\r\n    \"contracts/IRMRKWrapRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Apache 2.0\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title RMRK Wrap Registry\\n * @notice This contract keeps track of the mapping between original and wrapped collections.\\n */\\ninterface IRMRKWrapRegistry {\\n    /**\\n     * @notice Returns the address of the wrapped collection corresponding to an original collection.\\n     * @param originalCollection The address of the original collection\\n     * @return wrappedCollection The address of the wrapped collection\\n     */\\n    function getWrappedCollection(\\n        address originalCollection\\n    ) external view returns (address wrappedCollection);\\n\\n    /**\\n     * @notice Returns the address of the original collection corresponding to a wrapped collection.\\n     * @param wrappedCollection The address of the wrapped collection\\n     * @return originalCollection The address of the original collection\\n     */\\n    function getOriginalCollection(\\n        address wrappedCollection\\n    ) external view returns (address originalCollection);\\n\\n    /**\\n     * @notice Maps an original collection to a wrapped collection.\\n     * @param original The address of the original collection\\n     * @param wrapped The address of the wrapped collection\\n     */\\n    function setOriginalAndWrappedCollection(\\n        address original,\\n        address wrapped\\n    ) external;\\n\\n    /**\\n     * @notice Removes the mapping from original to wrapped collection. Removed collections can be retrieved through getPreviousWraps method.\\n     * @param original The address of the original collection\\n     */\\n    function removeWrappedCollection(address original) external;\\n\\n    /**\\n     * @notice Returns the list of previous wraps for a collection.\\n     * @param original The address of the original collection\\n     * @return previousWraps The list of previous wraps\\n     */\\n    function getPreviousWraps(\\n        address original\\n    ) external view returns (address[] memory previousWraps);\\n}\\n\"\r\n    },\r\n    \"contracts/RMRKWrapRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Apache 2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@rmrk-team/evm-contracts/contracts/RMRK/access/Ownable.sol\\\";\\nimport \\\"./IRMRKWrapRegistry.sol\\\";\\n\\nerror OnlyWrapperCanAddOrRemoveCollections();\\n\\n/**\\n * @title RMRKWrapRegistry\\n * @author RMRK team\\n * @notice This smart contract serves as a repository mapping wrapped collections to the original ones.\\n */\\ncontract RMRKWrapRegistry is IRMRKWrapRegistry, Ownable {\\n    mapping(address => address) private _originalToWrappedCollection;\\n    mapping(address => address) private _wrappedToOriginalCollection;\\n    mapping(address => address[]) private _previousWraps;\\n    address private _currentWrapper;\\n\\n    /**\\n     * @inheritdoc IRMRKWrapRegistry\\n     */\\n    function getWrappedCollection(\\n        address originalCollection\\n    ) public view returns (address wrappedCollection) {\\n        return _originalToWrappedCollection[originalCollection];\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKWrapRegistry\\n     */\\n    function getOriginalCollection(\\n        address wrappedCollection\\n    ) public view returns (address originalCollection) {\\n        return _wrappedToOriginalCollection[wrappedCollection];\\n    }\\n\\n    // -------------- ADMIN SETTERS --------------\\n\\n    /**\\n     * @inheritdoc IRMRKWrapRegistry\\n     */\\n    function setOriginalAndWrappedCollection(\\n        address original,\\n        address wrapped\\n    ) public {\\n        if (_msgSender() != _currentWrapper)\\n            revert OnlyWrapperCanAddOrRemoveCollections();\\n        _originalToWrappedCollection[original] = wrapped;\\n        _wrappedToOriginalCollection[wrapped] = original;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKWrapRegistry\\n     */\\n    function removeWrappedCollection(address original) public {\\n        if (_msgSender() != _currentWrapper)\\n            revert OnlyWrapperCanAddOrRemoveCollections();\\n        address wrapped = _originalToWrappedCollection[original];\\n        delete _originalToWrappedCollection[original];\\n        delete _wrappedToOriginalCollection[wrapped];\\n        _previousWraps[original].push(wrapped);\\n    }\\n\\n    /**\\n     * @notice Sets the address of the current wrapper, which is the contract that is allowed to add collections.\\n     * @param wrapper The address of the current wrapper\\n     */\\n    function setCurrentWrapper(address wrapper) public onlyOwner {\\n        _currentWrapper = wrapper;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKWrapRegistry\\n     */\\n    function getPreviousWraps(\\n        address original\\n    ) public view returns (address[] memory previousWraps) {\\n        previousWraps = _previousWraps[original];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"OnlyWrapperCanAddOrRemoveCollections\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewContributorIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isContributor\",\"type\":\"bool\"}],\"name\":\"ContributorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wrappedCollection\",\"type\":\"address\"}],\"name\":\"getOriginalCollection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"originalCollection\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"original\",\"type\":\"address\"}],\"name\":\"getPreviousWraps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"previousWraps\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"originalCollection\",\"type\":\"address\"}],\"name\":\"getWrappedCollection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wrappedCollection\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"isContributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"grantRole\",\"type\":\"bool\"}],\"name\":\"manageContributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"original\",\"type\":\"address\"}],\"name\":\"removeWrappedCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"}],\"name\":\"setCurrentWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"original\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapped\",\"type\":\"address\"}],\"name\":\"setOriginalAndWrappedCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RMRKWrapRegistry", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}