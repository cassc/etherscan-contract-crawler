{"SourceCode": "// SPDX-License-Identifier: NONE\n\npragma solidity 0.6.12;\n\n\n\n// Part: IMintableAirdrop\n\ninterface IMintableAirdrop {\n\n  function mintAirdrops(\n    address _owner,\n    uint256 _amount,\n    uint256 _upfront,\n    uint256 _start,\n    uint256 _end) external returns(uint256);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.2.0/MerkleProof\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n// File: MerkleMinter.sol\n\ncontract MerkleMinter {\n  using MerkleProof for bytes32[];\n\n  IMintableAirdrop public toAirdrop;\n\n  bytes32 public merkleRoot;\n  mapping(uint256 => uint256) public claimedBitMap;\n  uint256 public start;\n  uint256 public end;\n  uint256 upfrontDivisor;\n\n\n  event Claimed(uint256 index, address account, uint256 amount);\n\n  constructor(address _toAirdrop, bytes32 _root, uint256 _start, uint256 _end, uint _upfrontDivisor) public {\n    toAirdrop = IMintableAirdrop(_toAirdrop);\n    merkleRoot = _root;\n    start = _start;\n    end = _end;\n    upfrontDivisor = _upfrontDivisor;\n  }\n\n\n  function isClaimed(uint256 _index) public view returns(bool) {\n    uint256 wordIndex = _index / 256;\n    uint256 bitIndex = _index % 256;\n    uint256 word = claimedBitMap[wordIndex];\n    uint256 bitMask = 1 << bitIndex;\n    return word & bitMask == bitMask;\n  }\n\n  function _setClaimed(uint256 _index) internal {\n    uint256 wordIndex = _index / 256;\n    uint256 bitIndex = _index % 256;\n    claimedBitMap[wordIndex] |= 1 << bitIndex;\n  }\n\n  function claim(address account, uint256 _index, uint256 _amount, bytes32[] memory _proof) external {\n    require(!isClaimed(_index), \"Claimed already\");\n\n    bytes32 node = keccak256(abi.encodePacked(_index, account, _amount));\n    require(_proof.verify(merkleRoot, node), \"Wrong proof\");\n\n    _setClaimed(_index);\n    uint256 upfront = _amount / upfrontDivisor;\n    uint256 adjustedAmount = _amount - upfront;\n\n    toAirdrop.mintAirdrops(account, adjustedAmount, upfront, start, end);\n    emit Claimed(_index, account, _amount);\n  }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAirdrop\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upfrontDivisor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedBitMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toAirdrop\",\"outputs\":[{\"internalType\":\"contract IMintableAirdrop\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MerkleMinter", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009bb26200691a21e8f737424e6d800609e3c5b2feee66fda93e6f009147bdb1dba568da0c381b85485e1affb9f054e2755cd8029900000000000000000000000000000000000000000000000000000000617091600000000000000000000000000000000000000000000000000000000061e73860000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}