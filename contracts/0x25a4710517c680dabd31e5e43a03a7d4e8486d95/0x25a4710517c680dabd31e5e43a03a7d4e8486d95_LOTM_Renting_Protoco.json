{"SourceCode": "# @version 0.3.9\r\n\r\n\"\"\"\r\n@title LOTM Renting Protocol Contract\r\n@author [Zharta](https://zharta.io/)\r\n@notice This contract manages the renting process for NFTs in the LOTM Renting Protocol.\r\n@dev This contract is the single user-facing contract for each Renting Market. It does not hold any assets, it manages the creation of vaults (as minimal proxies to the vault implementation) and delegates the calls to the vaults, with the exception of the admin functions.\r\n\"\"\"\r\n\r\n# Interfaces\r\n\r\ninterface ISelf:\r\n    def tokenid_to_vault(token_id: uint256) -> address: view\r\n    def is_vault_available(token_id: uint256) -> bool: view\r\n\r\n\r\ninterface IVault:\r\n    def is_initialised() -> bool: view\r\n    def initialise(owner: address): nonpayable\r\n    def deposit(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address): nonpayable\r\n    def set_listing(state: VaultState, token_id: uint256, sender: address, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address): nonpayable\r\n    def start_rental(state: VaultState, renter: address, expiration: uint256, delegate: address, protocol_fee: uint256, protocol_wallet: address) -> Rental: nonpayable\r\n    def close_rental(state: VaultState, sender: address) -> uint256: nonpayable\r\n    def claim(state: VaultState, sender: address) -> (Rental, uint256, uint256): nonpayable\r\n    def withdraw(state: VaultState, sender: address) -> (uint256, uint256): nonpayable\r\n    def delegate_to_wallet(state: VaultState, sender: address, delegate: address): nonpayable\r\n\r\n\r\n# Structs\r\n\r\nstruct TokenContext:\r\n    token_id: uint256\r\n    active_rental: Rental\r\n    listing: Listing\r\n\r\nstruct VaultState:\r\n    active_rental: Rental\r\n    listing: Listing\r\n\r\nstruct Rental:\r\n    id: bytes32 # keccak256 of the renter, token_id, start and expiration\r\n    owner: address\r\n    renter: address\r\n    delegate: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n    protocol_fee: uint256\r\n    protocol_wallet: address\r\n\r\nstruct Listing:\r\n    token_id: uint256\r\n    price: uint256 # price per hour, 0 means not listed\r\n    min_duration: uint256 # min duration in hours\r\n    max_duration: uint256 # max duration in hours, 0 means unlimited\r\n\r\nstruct VaultLog:\r\n    vault: address\r\n    token_id: uint256\r\n\r\nstruct RentalLog:\r\n    id: bytes32\r\n    vault: address\r\n    owner: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n    protocol_fee: uint256\r\n    protocol_wallet: address\r\n\r\nstruct RewardLog:\r\n    vault: address\r\n    token_id: uint256\r\n    amount: uint256\r\n    protocol_fee_amount: uint256\r\n    active_rental_amount: uint256\r\n\r\nstruct WithdrawalLog:\r\n    vault: address\r\n    token_id: uint256\r\n    rewards: uint256\r\n    protocol_fee_amount: uint256\r\n\r\n\r\n# Events\r\n\r\nevent VaultsCreated:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n    delegate: address\r\n\r\nevent NftsDeposited:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n    delegate: address\r\n\r\nevent NftsWithdrawn:\r\n    owner: address\r\n    nft_contract: address\r\n    total_rewards: uint256\r\n    withdrawals: DynArray[WithdrawalLog, 32]\r\n\r\nevent ListingsChanged:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n    delegate: address\r\n\r\nevent ListingsCancelled:\r\n    owner: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n    delegate: address\r\n\r\nevent RentalStarted:\r\n    renter: address\r\n    delegate: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RentalClosed:\r\n    renter: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RewardsClaimed:\r\n    owner: address\r\n    nft_contract: address\r\n    rewards: DynArray[RewardLog, 32]\r\n\r\nevent DelegatedToWallet:\r\n    owner: address\r\n    delegate: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent ProtocolFeeSet:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n    fee_wallet: address\r\n\r\nevent ProtocolWalletChanged:\r\n    old_wallet: address\r\n    new_wallet: address\r\n\r\nevent AdminProposed:\r\n    admin: address\r\n    proposed_admin: address\r\n\r\nevent OwnershipTransferred:\r\n    old_admin: address\r\n    new_admin: address\r\n\r\n\r\n# Global Variables\r\n\r\n_COLLISION_OFFSET: constant(bytes1) = 0xFF\r\n_DEPLOYMENT_CODE: constant(bytes9) = 0x602D3D8160093D39F3\r\n_PRE: constant(bytes10) = 0x363d3d373d3d3d363d73\r\n_POST: constant(bytes15) = 0x5af43d82803e903d91602b57fd5bf3\r\n\r\nvault_impl_addr: public(immutable(address))\r\npayment_token_addr: public(immutable(address))\r\nnft_contract_addr: public(immutable(address))\r\ndelegation_registry_addr: public(immutable(address))\r\nmax_protocol_fee: public(immutable(uint256))\r\n\r\nprotocol_wallet: public(address)\r\nprotocol_fee: public(uint256)\r\nprotocol_admin: public(address)\r\nproposed_admin: public(address)\r\n\r\nactive_vaults: public(HashMap[uint256, address]) # token_id -> vault\r\n\r\n\r\n##### EXTERNAL METHODS - WRITE #####\r\n\r\n@external\r\ndef __init__(\r\n    _vault_impl_addr: address,\r\n    _payment_token_addr: address,\r\n    _nft_contract_addr: address,\r\n    _delegation_registry_addr: address,\r\n    _max_protocol_fee: uint256,\r\n    _protocol_fee: uint256,\r\n    _protocol_wallet: address,\r\n    _protocol_admin: address\r\n):\r\n\r\n    \"\"\"\r\n    @notice Initialize the renting contract with necessary parameters and addresses.\r\n    @dev Sets up the contract by initializing various addresses and fees.\r\n    @param _vault_impl_addr The address of the vault implementation.\r\n    @param _payment_token_addr The address of the payment token.\r\n    @param _nft_contract_addr The address of the NFT contract.\r\n    @param _delegation_registry_addr The address of the delegation registry.\r\n    @param _max_protocol_fee The maximum protocol fee that can be set.\r\n    @param _protocol_fee The initial protocol fee.\r\n    @param _protocol_wallet The wallet to receive protocol fees.\r\n    @param _protocol_admin The administrator of the protocol.\r\n    \"\"\"\r\n\r\n    assert _vault_impl_addr != empty(address), \"vault impl is the zero addr\"\r\n    assert _payment_token_addr != empty(address), \"payment token is the zero addr\"\r\n    assert _nft_contract_addr != empty(address), \"nft contract is the zero addr\"\r\n    assert _delegation_registry_addr != empty(address), \"deleg registry is the zero addr\"\r\n    assert _max_protocol_fee <= 10000, \"max protocol fee > 100%\"\r\n    assert _protocol_fee <= _max_protocol_fee, \"protocol fee > max fee\"\r\n    assert _protocol_wallet != empty(address), \"protocol wallet not set\"\r\n    assert _protocol_admin != empty(address), \"admin wallet not set\"\r\n\r\n    vault_impl_addr = _vault_impl_addr\r\n    payment_token_addr = _payment_token_addr\r\n    nft_contract_addr = _nft_contract_addr\r\n    delegation_registry_addr = _delegation_registry_addr\r\n    max_protocol_fee = _max_protocol_fee\r\n\r\n    self.protocol_wallet = _protocol_wallet\r\n    self.protocol_fee = _protocol_fee\r\n    self.protocol_admin = _protocol_admin\r\n\r\n\r\n@external\r\ndef create_vaults_and_deposit(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Create new vaults and deposit NFTs with specified listing terms.\r\n    @dev Iterates over a list of token ids, creating vaults and depositing NFTs with the given listing terms.\r\n    @param token_ids An array of NFT token ids to create vaults for and deposit.\r\n    @param price Rental price per hour for each NFT, 0 meaning unlisted.\r\n    @param min_duration Minimum rental duration in hours.\r\n    @param max_duration Maximum rental duration in hours, 0 for unlimited.\r\n    @param delegate Address to delegate the NFT to while listed.\r\n    \"\"\"\r\n\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self._create_vault_and_deposit(token_id, price, min_duration, max_duration, delegate)\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log VaultsCreated(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs,\r\n        delegate\r\n    )\r\n\r\n\r\n@external\r\ndef deposit(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Deposit NFTs into existing vaults with specified listing terms.\r\n    @dev Iterates over a list of token ids, depositing NFTs into their respective vaults with the given listing terms.\r\n    @param token_ids An array of NFT token ids to deposit.\r\n    @param price Rental price per hour for each NFT, 0 meaning unlisted.\r\n    @param min_duration Minimum rental duration in hours.\r\n    @param max_duration Maximum rental duration in hours, 0 for unlimited.\r\n    @param delegate Address to delegate the NFT to while listed.\r\n    \"\"\"\r\n\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self._deposit_nft(token_id, price, min_duration, max_duration, delegate)\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log NftsDeposited(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs,\r\n        delegate\r\n    )\r\n\r\n\r\n@external\r\ndef set_listings(\r\n    token_contexts: DynArray[TokenContext, 32],\r\n    price: uint256,\r\n    min_duration: uint256,\r\n    max_duration: uint256,\r\n    delegate: address\r\n):\r\n\r\n    \"\"\"\r\n    @notice Set listings for multiple NFTs in their respective vaults.\r\n    @dev Iterates over a list of token contexts, updating the listings with the given terms.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param price Rental price per hour for each NFT, 0 meaning unlisted.\r\n    @param min_duration Minimum rental duration in hours.\r\n    @param max_duration Maximum rental duration in hours, 0 for unlimited.\r\n    @param delegate Address to delegate the NFT to while listed.\r\n    \"\"\"\r\n\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            token_context.token_id,\r\n            msg.sender,\r\n            price,\r\n            min_duration,\r\n            max_duration,\r\n            delegate\r\n        )\r\n\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_context.token_id\r\n        }))\r\n\r\n    log ListingsChanged(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs,\r\n        delegate,\r\n    )\r\n\r\n@external\r\ndef cancel_listings(token_contexts: DynArray[TokenContext, 32], delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Cancel listings for multiple NFTs in their respective vaults.\r\n    @dev Iterates over a list of token contexts, canceling the listings in their respective vaults.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param delegate Address to delegate the NFT to while unlisted.\r\n    \"\"\"\r\n\r\n    vaults: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            token_context.token_id,\r\n            msg.sender,\r\n            0,\r\n            0,\r\n            0,\r\n            delegate\r\n        )\r\n\r\n        vaults.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_context.token_id\r\n        }))\r\n\r\n    log ListingsCancelled(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        vaults,\r\n        delegate\r\n    )\r\n\r\n\r\n@external\r\ndef start_rentals(token_contexts: DynArray[TokenContext, 32], duration: uint256, delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Start rentals for multiple NFTs based on their token contexts.\r\n    @dev Iterates over token contexts to begin rentals for each NFT in their respective vaults.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param duration The duration of the rentals in hours.\r\n    @param delegate The address to delegate the NFT to during the rental period.\r\n    \"\"\"\r\n\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n\r\n    expiration: uint256 = block.timestamp + duration * 3600\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        rental: Rental = IVault(vault).start_rental(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing,\r\n            }),\r\n            msg.sender,\r\n            expiration,\r\n            delegate,\r\n            self.protocol_fee,\r\n            self.protocol_wallet\r\n        )\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: rental.id,\r\n            vault: vault,\r\n            owner: rental.owner,\r\n            token_id: token_context.token_id,\r\n            start: rental.start,\r\n            min_expiration: rental.min_expiration,\r\n            expiration: expiration,\r\n            amount: rental.amount,\r\n            protocol_fee: rental.protocol_fee,\r\n            protocol_wallet: rental.protocol_wallet\r\n        }))\r\n\r\n    log RentalStarted(msg.sender, delegate, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef close_rentals(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Close rentals for multiple NFTs, allowing for early rental cancelation by the renter.\r\n    @dev Iterates over token contexts to end rentals for each NFT in their respective vaults.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    \"\"\"\r\n\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        amount: uint256 = IVault(vault).close_rental(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            msg.sender\r\n        )\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: token_context.active_rental.id,\r\n            vault: vault,\r\n            owner: token_context.active_rental.owner,\r\n            token_id: token_context.active_rental.token_id,\r\n            start: token_context.active_rental.start,\r\n            min_expiration: token_context.active_rental.min_expiration,\r\n            expiration: block.timestamp,\r\n            amount: amount,\r\n            protocol_fee: token_context.active_rental.protocol_fee,\r\n            protocol_wallet: token_context.active_rental.protocol_wallet\r\n        }))\r\n\r\n    log RentalClosed(msg.sender, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef claim(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Claim rewards and protocol fees for multiple NFTs.\r\n    @dev Iterates over token contexts to claim any unclaimed rewards and fees from the vaults.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    \"\"\"\r\n\r\n    reward_logs: DynArray[RewardLog, 32] = []\r\n    active_rental: Rental = empty(Rental)\r\n    rewards: uint256 = 0\r\n    protocol_fee_amount: uint256 = 0\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        active_rental, rewards, protocol_fee_amount = IVault(vault).claim(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            msg.sender\r\n        )\r\n\r\n        reward_logs.append(RewardLog({\r\n            vault: vault,\r\n            token_id: token_context.token_id,\r\n            amount: rewards,\r\n            protocol_fee_amount: protocol_fee_amount,\r\n            active_rental_amount: active_rental.amount\r\n        }))\r\n\r\n    log RewardsClaimed(msg.sender, nft_contract_addr, reward_logs)\r\n\r\n\r\n@external\r\ndef withdraw(token_contexts: DynArray[TokenContext, 32]):\r\n\r\n    \"\"\"\r\n    @notice Withdraw multiple NFTs and claim rewards and protocol fees.\r\n    @dev Iterates over token contexts to withdraw NFTs from their vaults and claim any unclaimed rewards and fees.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    \"\"\"\r\n\r\n    withdrawal_log: DynArray[WithdrawalLog, 32] = empty(DynArray[WithdrawalLog, 32])\r\n    total_rewards: uint256 = 0\r\n    rewards: uint256 = 0\r\n    protocol_fee_amount: uint256 = 0\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        self.active_vaults[token_context.token_id] = empty(address)\r\n\r\n        rewards, protocol_fee_amount = IVault(vault).withdraw(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            msg.sender\r\n        )\r\n\r\n        withdrawal_log.append(WithdrawalLog({\r\n            vault: vault,\r\n            token_id: token_context.token_id,\r\n            rewards: rewards,\r\n            protocol_fee_amount: protocol_fee_amount\r\n        }))\r\n        total_rewards += rewards\r\n\r\n    log NftsWithdrawn(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        total_rewards,\r\n        withdrawal_log\r\n    )\r\n\r\n@external\r\ndef delegate_to_wallet(token_contexts: DynArray[TokenContext, 32], delegate: address):\r\n\r\n    \"\"\"\r\n    @notice Delegate NFTs to a specified wallet.\r\n    @dev Iterates over token contexts to set the delegation of NFTs in their vaults.\r\n    @param token_contexts An array of token contexts, each containing the vault state for an NFT.\r\n    @param delegate The address to delegate the NFTs to.\r\n    \"\"\"\r\n\r\n    vaults: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_context in token_contexts:\r\n        vault: address = self.active_vaults[token_context.token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).delegate_to_wallet(\r\n            VaultState({\r\n                active_rental: token_context.active_rental,\r\n                listing: token_context.listing\r\n            }),\r\n            msg.sender,\r\n            delegate\r\n        )\r\n\r\n        vaults.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_context.token_id\r\n        }))\r\n\r\n    log DelegatedToWallet(\r\n        msg.sender,\r\n        delegate,\r\n        nft_contract_addr,\r\n        vaults,\r\n    )\r\n\r\n@external\r\ndef set_protocol_fee(protocol_fee: uint256):\r\n\r\n    \"\"\"\r\n    @notice Set the protocol fee for the renting process.\r\n    @dev Updates the protocol fee, ensuring it doesn't exceed the maximum allowed.\r\n    @param protocol_fee The new protocol fee to be set, in bps (e.g., 500 for 5%).\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n    assert protocol_fee <= max_protocol_fee, \"protocol fee > max fee\"\r\n    assert protocol_fee != self.protocol_fee, \"protocol fee is the same\"\r\n\r\n    log ProtocolFeeSet(\r\n        self.protocol_fee,\r\n        protocol_fee,\r\n        self.protocol_wallet\r\n    )\r\n\r\n    self.protocol_fee = protocol_fee\r\n\r\n\r\n@external\r\ndef change_protocol_wallet(new_protocol_wallet: address):\r\n\r\n    \"\"\"\r\n    @notice Change the wallet address that receives the protocol fees.\r\n    @dev Updates the protocol wallet address.\r\n    @param new_protocol_wallet The new address for the protocol wallet.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not protocol admin\"\r\n    assert new_protocol_wallet != empty(address), \"wallet is the zero address\"\r\n\r\n    log ProtocolWalletChanged(\r\n        self.protocol_wallet,\r\n        new_protocol_wallet\r\n    )\r\n\r\n    self.protocol_wallet = new_protocol_wallet\r\n\r\n\r\n@external\r\ndef propose_admin(_address: address):\r\n\r\n    \"\"\"\r\n    @notice Propose a new administrator for the protocol.\r\n    @dev Sets a new proposed admin, which needs to claim ownership to become effective.\r\n    @param _address The address of the proposed new admin.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.protocol_admin, \"not the admin\"\r\n    assert _address != empty(address), \"_address is the zero address\"\r\n    assert self.protocol_admin != _address, \"proposed admin addr is the admin\"\r\n    assert self.proposed_admin != _address, \"proposed admin addr is the same\"\r\n\r\n    self.proposed_admin = _address\r\n\r\n    log AdminProposed(\r\n        self.protocol_admin,\r\n        _address\r\n    )\r\n\r\n\r\n@external\r\ndef claim_ownership():\r\n\r\n    \"\"\"\r\n    @notice Claim the role of protocol administrator.\r\n    @dev Finalizes the admin transfer process by setting the caller as the new admin.\r\n    \"\"\"\r\n\r\n    assert msg.sender == self.proposed_admin, \"not the proposed\"\r\n\r\n    log OwnershipTransferred(\r\n        self.protocol_admin,\r\n        self.proposed_admin\r\n    )\r\n\r\n    self.protocol_admin = self.proposed_admin\r\n    self.proposed_admin = empty(address)\r\n\r\n\r\n##### INTERNAL METHODS #####\r\n\r\n@pure\r\n@internal\r\ndef _compute_address(salt: bytes32, bytecode_hash: bytes32, deployer: address) -> address:\r\n    \"\"\"\r\n    @dev An `internal` helper function that returns the address\r\n         where a contract will be stored if deployed via `deployer`\r\n         using the `CREATE2` opcode. Any change in the `bytecode_hash`\r\n         or `salt` values will result in a new destination address.\r\n    @param salt The 32-byte random value used to create the contract\r\n           address.\r\n    @param bytecode_hash The 32-byte bytecode digest of the contract\r\n           creation bytecode.\r\n    @param deployer The 20-byte deployer address.\r\n    @return address The 20-byte address where a contract will be stored.\r\n    \"\"\"\r\n    data: bytes32 = keccak256(concat(_COLLISION_OFFSET, convert(deployer, bytes20), salt, bytecode_hash))\r\n    return self._convert_keccak256_2_address(data)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _convert_keccak256_2_address(digest: bytes32) -> address:\r\n    \"\"\"\r\n    @dev Converts a 32-byte keccak256 digest to an address.\r\n    @param digest The 32-byte keccak256 digest.\r\n    @return address The converted 20-byte address.\r\n    \"\"\"\r\n    return convert(convert(digest, uint256) & convert(max_value(uint160), uint256), address)\r\n\r\n\r\n@internal\r\ndef _create_vault_and_deposit(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address) -> address:\r\n    assert self.active_vaults[token_id] == empty(address), \"vault exists for token_id\"\r\n\r\n    vault: address = create_minimal_proxy_to(vault_impl_addr, salt=convert(token_id, bytes32))\r\n\r\n    self.active_vaults[token_id] = vault\r\n\r\n    IVault(vault).initialise(msg.sender)\r\n    IVault(vault).deposit(token_id, price, min_duration, max_duration, delegate)\r\n\r\n    return vault\r\n\r\n\r\n@internal\r\ndef _deposit_nft(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256, delegate: address) -> address:\r\n    assert ISelf(self).is_vault_available(token_id), \"vault is not available\"\r\n\r\n    vault: address = ISelf(self).tokenid_to_vault(token_id)\r\n    self.active_vaults[token_id] = vault\r\n\r\n    IVault(vault).initialise(msg.sender)\r\n\r\n    IVault(vault).deposit(token_id, price, min_duration, max_duration, delegate)\r\n\r\n    return vault\r\n\r\n\r\n##### EXTERNAL METHODS - VIEW #####\r\n\r\n@view\r\n@external\r\ndef is_vault_available(token_id: uint256) -> bool:\r\n\r\n    \"\"\"\r\n    @notice Check if a vault is available for a given NFT token id.\r\n    @dev Determines if a vault exists and is available, ie not in use.\r\n    @param token_id The NFT token id to check.\r\n    @return True if the vault is available, False otherwise.\r\n    \"\"\"\r\n\r\n    vault: address = ISelf(self).tokenid_to_vault(token_id)\r\n    return self.active_vaults[token_id] == empty(address) and vault.is_contract and not IVault(vault).is_initialised()\r\n\r\n\r\n@view\r\n@external\r\ndef tokenid_to_vault(token_id: uint256) -> address:\r\n\r\n    \"\"\"\r\n    @notice Get the vault address for a given NFT token id.\r\n    @dev Computes the address of the vault (existent or yet to be created) associated with the specified token id.\r\n    @param token_id The NFT token id.\r\n    @return The address of the vault associated with the given token id.\r\n    \"\"\"\r\n\r\n    return self._compute_address(\r\n        convert(token_id, bytes32),\r\n        keccak256(concat(\r\n            _DEPLOYMENT_CODE,\r\n            _PRE,\r\n            convert(vault_impl_addr, bytes20),\r\n            _POST\r\n        )),\r\n        self\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef get_nft_contract() -> address:\r\n    return nft_contract_addr\r\n\r\n\r\n@view\r\n@external\r\ndef get_payment_token() -> address:\r\n    return payment_token_addr\r\n\r\n\r\n@view\r\n@external\r\ndef get_delegation_registry() -> address:\r\n    return delegation_registry_addr", "ABI": "[{\"name\":\"VaultsCreated\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NftsDeposited\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NftsWithdrawn\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"total_rewards\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"},{\"name\":\"protocol_fee_amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingsChanged\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingsCancelled\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalStarted\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalClosed\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsClaimed\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rewards\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee_amount\",\"type\":\"uint256\"},{\"name\":\"active_rental_amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DelegatedToWallet\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ProtocolFeeSet\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ProtocolWalletChanged\",\"inputs\":[{\"name\":\"old_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AdminProposed\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"proposed_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"old_admin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_vault_impl_addr\",\"type\":\"address\"},{\"name\":\"_payment_token_addr\",\"type\":\"address\"},{\"name\":\"_nft_contract_addr\",\"type\":\"address\"},{\"name\":\"_delegation_registry_addr\",\"type\":\"address\"},{\"name\":\"_max_protocol_fee\",\"type\":\"uint256\"},{\"name\":\"_protocol_fee\",\"type\":\"uint256\"},{\"name\":\"_protocol_wallet\",\"type\":\"address\"},{\"name\":\"_protocol_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_vaults_and_deposit\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_listings\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_listings\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_rentals\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"close_rentals\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_to_wallet\",\"inputs\":[{\"name\":\"token_contexts\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"active_rental\",\"type\":\"tuple\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protocol_fee\",\"type\":\"uint256\"},{\"name\":\"protocol_wallet\",\"type\":\"address\"}]},{\"name\":\"listing\",\"type\":\"tuple\",\"components\":[{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}]}]},{\"name\":\"delegate\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_protocol_fee\",\"inputs\":[{\"name\":\"protocol_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_protocol_wallet\",\"inputs\":[{\"name\":\"new_protocol_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"propose_admin\",\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_vault_available\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenid_to_vault\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_nft_contract\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_payment_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegation_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_impl_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payment_token_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_contract_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_registry_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_protocol_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"protocol_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proposed_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"active_vaults\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "LOTM Renting Protocol Contract", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000fd586c11ca3d9feb3ab762078db92cd021b0c2ad0000000000000000000000004d224452801aced8b2f0aebe155379bb5d594381000000000000000000000000e012baf811cf9c05c408e879c399960d1f305903000000000000000000000000c3aa9bc72bd623168860a1e5c6a4530d3d80456c00000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007d96cc26566bfca358c61fbe7be3ca771da7ea6000000000000000000000000314ba3811129ae06fc35894a3bb62157028a9fd9", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}