{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n *\\r\\n * Copyright (c) 2016-2019 zOS Global Limited\\r\\n *\\r\\n */\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns always true. Throws error on failure.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value can change when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * > Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns always true. Throws error on failure.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IFrankencoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IReserve.sol\\\";\\r\\n\\r\\ninterface IFrankencoin is IERC20 {\\r\\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\\r\\n\\r\\n    function registerPosition(address position) external;\\r\\n\\r\\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\\r\\n\\r\\n    function reserve() external view returns (IReserve);\\r\\n\\r\\n    function minterReserve() external view returns (uint256);\\r\\n\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\\r\\n\\r\\n    function equity() external view returns (uint256);\\r\\n\\r\\n    function isMinter(address minter) external view returns (bool);\\r\\n\\r\\n    function getPositionParent(address position) external view returns (address);\\r\\n\\r\\n    function mint(address target, uint256 amount) external;\\r\\n\\r\\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\\r\\n\\r\\n    function burnFrom(address target, uint256 amount) external;\\r\\n\\r\\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\\r\\n\\r\\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\\r\\n\\r\\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\\r\\n\\r\\n    function coverLoss(address source, uint256 amount) external;\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IReserve.sol\\\";\\r\\nimport \\\"./IFrankencoin.sol\\\";\\r\\n\\r\\ninterface IPosition {\\r\\n\\r\\n    function original() external returns (address);\\r\\n\\r\\n    function collateral() external returns (IERC20);\\r\\n\\r\\n    function minimumCollateral() external returns (uint256);\\r\\n\\r\\n    function challengePeriod() external returns (uint64);\\r\\n\\r\\n    function expiration() external returns (uint256);\\r\\n\\r\\n    function price() external returns (uint256);\\r\\n\\r\\n    function reduceLimitForClone(uint256 amount) external;\\r\\n\\r\\n    function initializeClone(address owner, uint256 _price, uint256 _coll, uint256 _mint, uint256 expiration) external;\\r\\n\\r\\n    function deny(address[] calldata helpers, string calldata message) external;\\r\\n\\r\\n    function mint(address target, uint256 amount) external;\\r\\n\\r\\n    function minted() external returns (uint256);\\r\\n\\r\\n    function reserveContribution() external returns (uint32);\\r\\n\\r\\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\\r\\n\\r\\n    function challengeData(uint256 challengeStart) external view returns (uint256 liqPrice, uint64 phase1, uint64 phase2);\\r\\n\\r\\n    function notifyChallengeStarted(uint256 size) external;\\r\\n\\r\\n    function notifyChallengeAverted(uint256 size) external;\\r\\n\\r\\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interface/IPositionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPositionFactory {\\r\\n    function createNewPosition(\\r\\n        address _owner,\\r\\n        address _zchf,\\r\\n        address _collateral,\\r\\n        uint256 _minCollateral,\\r\\n        uint256 _initialLimit,\\r\\n        uint256 _initPeriodSeconds,\\r\\n        uint256 _duration,\\r\\n        uint64 _challengePeriod,\\r\\n        uint32 _annualInterestPPM,\\r\\n        uint256 _liqPrice,\\r\\n        uint32 _reserve\\r\\n    ) external returns (address);\\r\\n\\r\\n    function clonePosition(address _existing) external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IReserve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IReserve is IERC20 {\\r\\n   function invest(uint256 amount, uint256 expected) external returns (uint256);\\r\\n   function checkQualified(address sender, address[] calldata helpers) external view;\\r\\n}\"\r\n    },\r\n    \"contracts/MintingHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interface/IERC20.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\nimport \\\"./interface/IPosition.sol\\\";\\r\\nimport \\\"./interface/IPositionFactory.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Minting Hub\\r\\n * @notice The central hub for creating, cloning and challenging collateralized Frankencoin positions.\\r\\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\\r\\n * contract. Pending challenges are stored as structs in an array.\\r\\n */\\r\\ncontract MintingHub {\\r\\n    /**\\r\\n     * @notice Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\\r\\n     */\\r\\n    uint256 public constant OPENING_FEE = 1000 * 10 ** 18;\\r\\n\\r\\n    /**\\r\\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\\r\\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\\r\\n     */\\r\\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\\r\\n\\r\\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\\r\\n\\r\\n    IFrankencoin public immutable zchf; // currency\\r\\n    Challenge[] public challenges; // list of open challenges\\r\\n\\r\\n    /**\\r\\n     * @notice Map to remember pending postponed collateral returns.\\r\\n     * @dev It maps collateral => beneficiary => amount.\\r\\n     */\\r\\n    mapping(address collateral => mapping(address owner => uint256 amount)) public pendingReturns;\\r\\n\\r\\n    struct Challenge {\\r\\n        address challenger; // the address from which the challenge was initiated\\r\\n        uint64 start; // the start of the challenge\\r\\n        IPosition position; // the position that was challenged\\r\\n        uint256 size; // how much collateral the challenger provided\\r\\n    }\\r\\n\\r\\n    event PositionOpened(\\r\\n        address indexed owner,\\r\\n        address indexed position,\\r\\n        address zchf,\\r\\n        address collateral,\\r\\n        uint256 price\\r\\n    );\\r\\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\\r\\n    event ChallengeAverted(address indexed position, uint256 number, uint256 size);\\r\\n    event ChallengeSucceeded(\\r\\n        address indexed position,\\r\\n        uint256 number,\\r\\n        uint256 bid,\\r\\n        uint256 acquiredCollateral,\\r\\n        uint256 challengeSize\\r\\n    );\\r\\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\\r\\n\\r\\n    error UnexpectedPrice();\\r\\n    error InvalidPos();\\r\\n\\r\\n    modifier validPos(address position) {\\r\\n        if (zchf.getPositionParent(position) != address(this)) revert InvalidPos();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _zchf, address _factory) {\\r\\n        zchf = IFrankencoin(_zchf);\\r\\n        POSITION_FACTORY = IPositionFactory(_factory);\\r\\n    }\\r\\n\\r\\n    function openPositionOneWeek(\\r\\n        address _collateralAddress,\\r\\n        uint256 _minCollateral,\\r\\n        uint256 _initialCollateral,\\r\\n        uint256 _mintingMaximum,\\r\\n        uint256 _expirationSeconds,\\r\\n        uint64 _challengeSeconds,\\r\\n        uint32 _annualInterestPPM,\\r\\n        uint256 _liqPrice,\\r\\n        uint32 _reservePPM\\r\\n    ) public returns (address) {\\r\\n        return\\r\\n            openPosition(\\r\\n                _collateralAddress,\\r\\n                _minCollateral,\\r\\n                _initialCollateral,\\r\\n                _mintingMaximum,\\r\\n                7 days,\\r\\n                _expirationSeconds,\\r\\n                _challengeSeconds,\\r\\n                _annualInterestPPM,\\r\\n                _liqPrice,\\r\\n                _reservePPM\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\\r\\n     * @dev For a successful call, you must set an allowance for the collateral token, allowing\\r\\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\\r\\n     * withdraw the fees.\\r\\n     *\\r\\n     * @param _collateralAddress        address of collateral token\\r\\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\\r\\n     * @param _initialCollateral amount of initial collateral to be deposited\\r\\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\\r\\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\\r\\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\\r\\n     * @param _annualInterestPPM ppm of minted amount that is paid as fee for each year of duration\\r\\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\\r\\n     *                           e.g. 18 decimals for an 18 dec collateral, 36 decs for a 0 dec collateral.\\r\\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\\r\\n     * @return address           address of created position\\r\\n     */\\r\\n    function openPosition(\\r\\n        address _collateralAddress,\\r\\n        uint256 _minCollateral,\\r\\n        uint256 _initialCollateral,\\r\\n        uint256 _mintingMaximum,\\r\\n        uint256 _initPeriodSeconds,\\r\\n        uint256 _expirationSeconds,\\r\\n        uint64 _challengeSeconds,\\r\\n        uint32 _annualInterestPPM,\\r\\n        uint256 _liqPrice,\\r\\n        uint32 _reservePPM\\r\\n    ) public returns (address) {\\r\\n        require(_annualInterestPPM <= 1000000);\\r\\n        require(CHALLENGER_REWARD <= _reservePPM && _reservePPM <= 1000000);\\r\\n        require(IERC20(_collateralAddress).decimals() <= 24); // leaves 12 digits for price\\r\\n        require(_initialCollateral >= _minCollateral, \\\"must start with min col\\\");\\r\\n        require(_minCollateral * _liqPrice >= 5000 ether * 10 ** 18); // must start with at least 5000 ZCHF worth of collateral\\r\\n        IPosition pos = IPosition(\\r\\n            POSITION_FACTORY.createNewPosition(\\r\\n                msg.sender,\\r\\n                address(zchf),\\r\\n                _collateralAddress,\\r\\n                _minCollateral,\\r\\n                _mintingMaximum,\\r\\n                _initPeriodSeconds,\\r\\n                _expirationSeconds,\\r\\n                _challengeSeconds,\\r\\n                _annualInterestPPM,\\r\\n                _liqPrice,\\r\\n                _reservePPM\\r\\n            )\\r\\n        );\\r\\n        zchf.registerPosition(address(pos));\\r\\n        zchf.collectProfits(msg.sender, OPENING_FEE);\\r\\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\\r\\n\\r\\n        emit PositionOpened(msg.sender, address(pos), address(zchf), _collateralAddress, _liqPrice);\\r\\n        return address(pos);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Clones an existing position and immediately tries to mint the specified amount using the given collateral.\\r\\n     * @dev This needs an allowance to be set on the collateral contract such that the minting hub can get the collateral.\\r\\n     */\\r\\n    function clone(\\r\\n        address position,\\r\\n        uint256 _initialCollateral,\\r\\n        uint256 _initialMint,\\r\\n        uint256 expiration\\r\\n    ) public validPos(position) returns (address) {\\r\\n        IPosition existing = IPosition(position);\\r\\n        require(expiration <= IPosition(existing.original()).expiration());\\r\\n        existing.reduceLimitForClone(_initialMint);\\r\\n        address pos = POSITION_FACTORY.clonePosition(position);\\r\\n        zchf.registerPosition(pos);\\r\\n        IPosition(pos).initializeClone(msg.sender, existing.price(), _initialCollateral, _initialMint, expiration);\\r\\n        existing.collateral().transferFrom(msg.sender, pos, _initialCollateral);\\r\\n\\r\\n        emit PositionOpened(\\r\\n            msg.sender,\\r\\n            address(pos),\\r\\n            address(zchf),\\r\\n            address(IPosition(pos).collateral()),\\r\\n            IPosition(pos).price()\\r\\n        );\\r\\n        return address(pos);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Launch a challenge (Dutch auction) on a position\\r\\n     * @param _positionAddr      address of the position we want to challenge\\r\\n     * @param _collateralAmount  amount of the collateral we want to challenge\\r\\n     * @param expectedPrice      position.price() to guard against the minter fruntrunning with a price change\\r\\n     * @return index of the challenge in challenge-array\\r\\n     */\\r\\n    function challenge(\\r\\n        address _positionAddr,\\r\\n        uint256 _collateralAmount,\\r\\n        uint256 expectedPrice\\r\\n    ) external validPos(_positionAddr) returns (uint256) {\\r\\n        IPosition position = IPosition(_positionAddr);\\r\\n        if (position.price() != expectedPrice) revert UnexpectedPrice();\\r\\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\\r\\n        uint256 pos = challenges.length;\\r\\n        challenges.push(Challenge(msg.sender, uint64(block.timestamp), position, _collateralAmount));\\r\\n        position.notifyChallengeStarted(_collateralAmount);\\r\\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\\r\\n        return pos;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Post a bid in ZCHF given an open challenge.\\r\\n     *\\r\\n     * @dev In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token\\r\\n     * has a blacklist and the challenger is on it), it is possible to postpone the return of the collateral.\\r\\n     *\\r\\n     * @param _challengeNumber  index of the challenge as broadcast in the event\\r\\n     * @param size              how much of the collateral the caller wants to bid for at most\\r\\n     *                          (automatically reduced to the available amount)\\r\\n     * @param postponeCollateralReturn To postpone the return of the collateral to the challenger. Usually false.\\r\\n     */\\r\\n    function bid(uint32 _challengeNumber, uint256 size, bool postponeCollateralReturn) external {\\r\\n        Challenge memory _challenge = challenges[_challengeNumber];\\r\\n        (uint256 liqPrice, uint64 phase1, uint64 phase2) = _challenge.position.challengeData(_challenge.start);\\r\\n        size = _challenge.size < size ? _challenge.size : size; // cannot bid for more than the size of the challenge\\r\\n\\r\\n        if (block.timestamp <= _challenge.start + phase1) {\\r\\n            _avertChallenge(_challenge, _challengeNumber, liqPrice, size);\\r\\n            emit ChallengeAverted(address(_challenge.position), _challengeNumber, size);\\r\\n        } else {\\r\\n            _returnChallengerCollateral(_challenge, _challengeNumber, size, postponeCollateralReturn);\\r\\n            (uint256 transferredCollateral, uint256 offer) = _finishChallenge(\\r\\n                _challenge,\\r\\n                liqPrice,\\r\\n                phase1,\\r\\n                phase2,\\r\\n                size\\r\\n            );\\r\\n            emit ChallengeSucceeded(address(_challenge.position), _challengeNumber, offer, transferredCollateral, size);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _finishChallenge(\\r\\n        Challenge memory _challenge,\\r\\n        uint256 liqPrice,\\r\\n        uint64 phase1,\\r\\n        uint64 phase2,\\r\\n        uint256 size\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        // Repayments depend on what was actually minted, whereas bids depend on the available collateral\\r\\n        (address owner, uint256 collateral, uint256 repayment, uint32 reservePPM) = _challenge\\r\\n            .position\\r\\n            .notifyChallengeSucceeded(msg.sender, size);\\r\\n\\r\\n        // No overflow possible thanks to invariant (col * price <= limit * 10**18)\\r\\n        // enforced in Position.setPrice and knowing that collateral <= col.\\r\\n        uint256 offer = (_calculatePrice(_challenge.start + phase1, phase2, liqPrice) * collateral) / 10 ** 18;\\r\\n        zchf.transferFrom(msg.sender, address(this), offer); // get money from bidder\\r\\n        uint256 reward = (offer * CHALLENGER_REWARD) / 1000_000;\\r\\n        zchf.transfer(_challenge.challenger, reward); // pay out the challenger reward\\r\\n        uint256 fundsAvailable = offer - reward; // funds available after reward\\r\\n\\r\\n        // Example: available funds are 90, repayment is 50, reserve 20%. Then 20%*(90-50)=16 are collected as profits\\r\\n        // and the remaining 34 are sent to the position owner. If the position owner maxed out debt before the challenge\\r\\n        // started and the liquidation price was 100, they would be slightly better off as they would get away with 80\\r\\n        // instead of 40+36 = 76 in this example.\\r\\n        if (fundsAvailable > repayment) {\\r\\n            // The excess amount is distributed between the system and the owner using the reserve ratio\\r\\n            // At this point, we cannot rely on the liquidation price because the challenge might have been started as a\\r\\n            // response to an unreasonable increase of the liquidation price, such that we have to use this heuristic\\r\\n            // for excess fund distribution, which make position owners that maxed out their positions slightly better\\r\\n            // off in comparison to those who did not.\\r\\n            uint256 profits = reservePPM * (fundsAvailable - repayment) / 1000_000;\\r\\n            zchf.collectProfits(address(this), profits);\\r\\n            zchf.transfer(owner, fundsAvailable - repayment - profits);\\r\\n        } else if (fundsAvailable < repayment) {\\r\\n            zchf.coverLoss(address(this), repayment - fundsAvailable); // ensure we have enough to pay everything\\r\\n        }\\r\\n        zchf.burnWithoutReserve(repayment, reservePPM); // Repay the challenged part, example: 50 ZCHF leading to 10 ZCHf in implicit profits\\r\\n        return (collateral, offer);\\r\\n    }\\r\\n\\r\\n    function _avertChallenge(Challenge memory _challenge, uint32 number, uint256 liqPrice, uint256 size) internal {\\r\\n        require(block.timestamp != _challenge.start); // do not allow to avert the challenge in the same transaction, see CS-ZCHF-037\\r\\n        if (msg.sender == _challenge.challenger) {\\r\\n            // allow challenger to cancel challenge without paying themselves\\r\\n        } else {\\r\\n            zchf.transferFrom(msg.sender, _challenge.challenger, (size * liqPrice) / (10 ** 18));\\r\\n        }\\r\\n\\r\\n        _challenge.position.notifyChallengeAverted(size);\\r\\n        _challenge.position.collateral().transfer(msg.sender, size);\\r\\n        if (size < _challenge.size) {\\r\\n            challenges[number].size = _challenge.size - size;\\r\\n        } else {\\r\\n            require(size == _challenge.size);\\r\\n            delete challenges[number];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns 'amount' of the collateral to the challenger and reduces or deletes the relevant challenge.\\r\\n     */\\r\\n    function _returnChallengerCollateral(\\r\\n        Challenge memory _challenge,\\r\\n        uint32 number,\\r\\n        uint256 amount,\\r\\n        bool postpone\\r\\n    ) internal {\\r\\n        _returnCollateral(_challenge.position.collateral(), _challenge.challenger, amount, postpone);\\r\\n        if (_challenge.size == amount) {\\r\\n            // bid on full amount\\r\\n            delete challenges[number];\\r\\n        } else {\\r\\n            // bid on partial amount\\r\\n            challenges[number].size -= amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current Dutch auction price.\\r\\n     * @dev Starts at the full price at time 'start' and linearly goes to 0 as 'phase2' passes.\\r\\n     */\\r\\n    function _calculatePrice(uint64 start, uint64 phase2, uint256 liqPrice) internal view returns (uint256) {\\r\\n        uint64 timeNow = uint64(block.timestamp);\\r\\n        if (timeNow <= start) {\\r\\n            return liqPrice;\\r\\n        } else if (timeNow >= start + phase2) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            uint256 timeLeft = phase2 - (timeNow - start);\\r\\n            return (liqPrice / phase2) * timeLeft;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the price per unit of the collateral for the given challenge.\\r\\n     * @dev The price comes with (36-collateral.decimals()) digits, such that multiplying it with the\\r\\n     * raw collateral amount always yields a price with 36 digits, or 18 digits after dividing by 10**18 again.\\r\\n     */\\r\\n    function price(uint32 challengeNumber) public view returns (uint256) {\\r\\n        Challenge memory _challenge = challenges[challengeNumber];\\r\\n        if (_challenge.challenger == address(0x0)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            (uint256 liqPrice, uint64 phase1, uint64 phase2) = _challenge.position.challengeData(_challenge.start);\\r\\n            return _calculatePrice(_challenge.start + phase1, phase2, liqPrice);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Challengers can call this method to withdraw collateral whose return was postponed.\\r\\n     */\\r\\n    function returnPostponedCollateral(address collateral, address target) external {\\r\\n        uint256 amount = pendingReturns[collateral][msg.sender];\\r\\n        delete pendingReturns[collateral][msg.sender];\\r\\n        IERC20(collateral).transfer(target, amount);\\r\\n    }\\r\\n\\r\\n    function _returnCollateral(IERC20 collateral, address recipient, uint256 amount, bool postpone) internal {\\r\\n        if (postpone) {\\r\\n            // Postponing helps in case the challenger was blacklisted or otherwise cannot receive at the moment.\\r\\n            pendingReturns[address(collateral)][recipient] += amount;\\r\\n            emit PostPonedReturn(address(collateral), recipient, amount);\\r\\n        } else {\\r\\n            collateral.transfer(recipient, amount); // return the challenger's collateral\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zchf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidPos\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedPrice\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"ChallengeAverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"ChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"acquiredCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeSize\",\"type\":\"uint256\"}],\"name\":\"ChallengeSucceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zchf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PostPonedReturn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHALLENGER_REWARD\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPENING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_challengeNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"postponeCollateralReturn\",\"type\":\"bool\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedPrice\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"challenges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"contract IPosition\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintingMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initPeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expirationSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_challengeSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_annualInterestPPM\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_liqPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reservePPM\",\"type\":\"uint32\"}],\"name\":\"openPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintingMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expirationSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_challengeSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_annualInterestPPM\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_liqPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reservePPM\",\"type\":\"uint32\"}],\"name\":\"openPositionOneWeek\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"pendingReturns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"challengeNumber\",\"type\":\"uint32\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"returnPostponedCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zchf\",\"outputs\":[{\"internalType\":\"contract IFrankencoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MintingHub", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b58e61c3098d85632df34eecfb899a1ed80921cb0000000000000000000000000cde500e6940931ed190ded77bb48640c9486392", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}