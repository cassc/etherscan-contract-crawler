{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BettingContract_23.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n//version 23.0\\n//0x03eB7Fe6801893F6006127B5248809e8CFbdd89D\\n\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/ERC20.sol\\\";\\n\\n\\nimport \\\"https://github.com/BetterSmartContract/BetterV0/blob/main/BettingOracle_ChainLink.sol\\\";\\n\\ncontract BettingContract {\\n    address public developer;\\n\\n    BettingOracle_ChainLink public better_oracle;\\n\\n    struct SupportedToken {\\n        uint256 id;\\n        address token;\\n        uint256 decimails;\\n        bool valid;\\n        address oracle_address;\\n    }\\n\\n    struct Bet {\\n        uint256 bet_id;\\n        uint256 betting_id;\\n        address user;\\n        uint256 predictedPrice;\\n        uint256 amount;\\n        bool winner;\\n        bool claimed;\\n        bool rebeted;\\n        uint256 winningsRatio;\\n        uint256 winningsAmount;\\n    }\\n\\n    enum Status {\\n        Open,\\n        Pending,\\n        Closed\\n    }\\n\\n    Status constant default_value = Status.Open;\\n\\n    struct Betting {\\n        uint256 id;\\n        address token;\\n        address creater;\\n        uint256 startTime;\\n        uint256 endTime;\\n        uint256 pendingTime;\\n        uint256 correctPrice;\\n        uint256 totalBets;\\n        uint256 totalAmount;\\n        Status status;\\n        bool hadWinner;\\n    }\\n\\n    uint256 public bettingCount;\\n    uint256 public betCount;\\n    uint256 public SupportedTokenCount;\\n    mapping(uint256 => Betting) public bettings;\\n    mapping(uint256 => Bet) public bets;\\n    mapping(uint256 => SupportedToken) public supported_tokens;\\n\\n    \\n\\n    event SupportedTokenAdded(\\n        uint256 id,\\n        address token,\\n        address oracle_address\\n    );\\n    event BettingCreated(\\n        uint256 id,\\n        address token,\\n        address creater,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 pendingTime,\\n        bool hadWinner\\n    );\\n    event BetPlaced(\\n        uint256 bet_id,\\n        uint256 betting_id,\\n        address user,\\n        uint256 predictedPrice,\\n        uint256 amount,\\n        bool winner,\\n        bool claimed,\\n        bool rebeted,\\n        uint256 winningsRatio,\\n        uint256 winningsAmount\\n    );\\n    event BettingClosed(uint256 id, uint256 correctPrice);\\n    event WinningClaimed(address user, uint256 amount);\\n\\n    //timeLeap\\n    //1209600 = 14 days\\n    //604800 = 7 days\\n    //1080 = 18 minutes\\n    //720 = 12 minutes\\n    //360 = 6 minutes\\n    //60 = 1 minute\\n\\n    uint256 timeLeap_start = 60;\\n    uint256 public timeLeap_end;\\n    uint256 public timeLeap_pending;\\n\\n    uint256 public fee_percentage; // 4 = 4%\\n    uint256 public range_percentage; // 6 = 6%\\n    uint256 ratio_decimails; //10 ** 18 = 1000000000000000000\\n\\n\\n    constructor(uint256 in_timeLeap_end, uint256 in_timeLeap_pending, uint256 in_fee_percentage, uint256 in_range_percentage, uint256 in_ratio_decimails) {\\n\\n        developer = msg.sender;\\n        timeLeap_end = in_timeLeap_end;\\n        timeLeap_pending = in_timeLeap_pending;\\n\\n        fee_percentage = in_fee_percentage;\\n        range_percentage = in_range_percentage;\\n        ratio_decimails = in_ratio_decimails;\\n\\n    }\\n\\n    /**\\n     * to update timeLeap\\n     */\\n    function update_timeLeap(uint256 in_timeLeap_end, uint256 in_timeLeap_pending) public {\\n        require(\\n            developer == msg.sender,\\n            \\\"only developer can update timeLeap\\\"\\n        );\\n        \\n        timeLeap_end = in_timeLeap_end;\\n        timeLeap_pending = in_timeLeap_pending;\\n    }\\n        \\n\\n    /**\\n     * to add supported token for betting\\n     */\\n    function AddSupportedToken(\\n        address token_address,\\n        uint256 decimails,\\n        address oracle_address\\n    ) public returns (bool) {\\n        require(\\n            developer == msg.sender,\\n            \\\"only developer can add supported tokens @ AddSupportedToken()\\\"\\n        );\\n        bool newToken = true;\\n\\n        for (uint256 i = 0; i <= SupportedTokenCount; i++) {\\n            if (supported_tokens[i].token == token_address) {\\n                newToken = false;\\n            }\\n        }\\n\\n        if (newToken) {\\n            SupportedTokenCount++;\\n\\n            SupportedToken storage newSupportedToken = supported_tokens[\\n                SupportedTokenCount\\n            ];\\n            newSupportedToken.id = SupportedTokenCount;\\n            newSupportedToken.token = token_address;\\n            newSupportedToken.decimails = decimails;\\n            newSupportedToken.valid = true;\\n            newSupportedToken.oracle_address = oracle_address;\\n\\n            emit SupportedTokenAdded(\\n                SupportedTokenCount,\\n                token_address,\\n                oracle_address\\n            );\\n        }\\n\\n        return newToken;\\n    }\\n\\n    /**\\n     * to update supported token at supported_tokens[]\\n     */\\n    function UpdateSupportedToken(\\n        uint256 id,\\n        address token_address,\\n        bool valid,\\n        address oracle_address\\n    ) public {\\n        require(\\n            developer == msg.sender,\\n            \\\"only developer can update supported tokens @ UpdateSupportedToken()\\\"\\n        );\\n        require(\\n            supported_tokens[id].token == token_address,\\n            \\\"token address is not matched @ UpdateSupportedToken()\\\"\\n        );\\n\\n        supported_tokens[id].oracle_address = oracle_address;\\n        supported_tokens[id].valid = valid;\\n    }\\n\\n    /**\\n     * main function\\n     * to create Betting for Bet\\n     * endTime means due time of predict price\\n     */\\n    function CreateBetting(\\n        address token_address,\\n        uint256 endTime\\n    ) public returns (uint256) {\\n\\n        uint256 startTime = block.timestamp + timeLeap_start;\\n\\n        require(\\n            startTime >= block.timestamp,\\n            \\\"Betting cannot start in the past @ CreateBetting()\\\"\\n        );\\n\\n        uint256 check_endTime = endTime - timeLeap_end;\\n        require(check_endTime > startTime, \\\"Invalid end time (endTime < startTime) @ CreateBetting()\\\");\\n\\n        uint256 pendingTime = endTime - timeLeap_pending;\\n        require(pendingTime > startTime, \\\"Invalid pending time (pendingTime < startTime) @ CreateBetting()\\\");\\n   \\n\\n        address creater = msg.sender;\\n        bettingCount++;\\n\\n        bool supportedToken = false;\\n\\n        for (uint256 i = 0; i <= SupportedTokenCount; i++) {\\n            if (\\n                supported_tokens[i].token == token_address &&\\n                supported_tokens[i].valid == true\\n            ) {\\n                supportedToken = true;\\n            }\\n        }\\n\\n        require(\\n            supportedToken == true,\\n            \\\"token address not supported! @ CreateBetting()\\\"\\n        );\\n\\n        Betting storage newBetting = bettings[bettingCount];\\n        newBetting.token = token_address;\\n        newBetting.creater = creater;\\n        newBetting.id = bettingCount;\\n        newBetting.startTime = startTime;\\n        newBetting.endTime = endTime;\\n        newBetting.pendingTime = pendingTime;\\n        newBetting.correctPrice = 0;\\n        newBetting.totalBets = 0;\\n        newBetting.totalAmount = 0;\\n        newBetting.status = Status.Open;\\n        newBetting.hadWinner = false;\\n\\n        emit BettingCreated(\\n            bettingCount,\\n            token_address,\\n            creater,\\n            startTime,\\n            endTime,\\n            pendingTime,\\n            false\\n        );\\n\\n        return bettingCount;\\n    }\\n\\n    /**\\n     * main function\\n     * to create Bets\\n     */\\n    function CreateBet(\\n        address token_address,\\n        uint256 betting_id,\\n        uint256 predictedPrice,\\n        uint256 amount\\n    ) public returns (uint256) {\\n        require(\\n            token_address == bettings[betting_id].token,\\n            \\\"incompatible token address @ CreateBet()\\\"\\n        );\\n        require(\\n            betting_id > 0 && betting_id <= bettingCount,\\n            \\\"Invalid betting ID @ CreateBet()\\\"\\n        );\\n        require(\\n            bettings[betting_id].status == Status.Open,\\n            \\\"Betting is not open for bets @ CreateBet()\\\"\\n        );\\n        require(\\n            block.timestamp < bettings[betting_id].pendingTime,\\n            \\\"Betting is closed for new bets @ CreateBet()\\\"\\n        );\\n        require(amount > 0, \\\"Invalid bet amount @ CreateBet()\\\");\\n\\n        (\\n            uint256 bet_id_in_current_betting_id,\\n            uint256 bet_id_in_all_bet_list\\n        ) = bet_id_by_user(betting_id, msg.sender);\\n        require(bet_id_in_all_bet_list == 0, \\\"wrong betting id @ CreateBet()\\\");\\n        require(\\n            bet_id_in_current_betting_id == 0,\\n            \\\"You already bed on this betting! @ CreateBet()\\\"\\n        );\\n\\n        IERC20 token = IERC20(token_address);\\n        require(\\n            token.balanceOf(msg.sender) >= amount,\\n            \\\"Insufficient token balance @ CreateBet()\\\"\\n        );\\n        require(\\n            token.approve(address(this), amount),\\n            \\\"Not approving token transfer! @ CreateBet()\\\"\\n        );\\n        require(\\n            token.transferFrom(msg.sender, address(this), amount),\\n            \\\"Transfer failed @ CreateBet()\\\"\\n        );\\n\\n        uint256 total_fee = FeeCollector(\\n                betting_id,\\n                amount\\n            );\\n\\n        uint256 new_bet_amount = amount - total_fee;\\n\\n        betCount++;\\n\\n        uint256 currrent_bet_length = bet_length(betting_id);\\n        uint256 new_bet_id = currrent_bet_length + 1;\\n\\n        bettings[betting_id].totalBets++;\\n        bettings[betting_id].totalAmount += new_bet_amount;\\n\\n        Bet storage newBet = bets[betCount];\\n        newBet.bet_id = new_bet_id;\\n        newBet.betting_id = betting_id;\\n        newBet.user = msg.sender;\\n        newBet.predictedPrice = predictedPrice;\\n        newBet.amount = new_bet_amount;\\n        newBet.winner = false;\\n        newBet.claimed = false;\\n        newBet.rebeted = false;\\n        newBet.winningsRatio = 0;\\n        newBet.winningsAmount = 0;\\n\\n        emit BetPlaced(\\n            new_bet_id,\\n            betting_id,\\n            msg.sender,\\n            predictedPrice,\\n            amount,\\n            false,\\n            false,\\n            false,\\n            0,\\n            0\\n        );\\n\\n        return betCount;\\n    }\\n\\n    /**\\n     * all betters can close betting if betting is passing pending time\\n     * loop current betting by betting id to calculate winners\\n     */\\n    function CloseBetting(uint256 _betting_id) public {\\n        (\\n            ,\\n            uint256 bet_id_in_all_bet_list\\n        ) = bet_id_by_user(_betting_id, msg.sender);\\n\\n        bool better = false;\\n        Betting storage betting = bettings[_betting_id];\\n\\n        if (bets[bet_id_in_all_bet_list].betting_id == _betting_id && bets[bet_id_in_all_bet_list].amount > 0 ) {\\n            better = true;\\n        }\\n        \\n        if( betting.creater == msg.sender){\\n            better = true;\\n        }\\n\\n        require(\\n            better == true,\\n            \\\"only betters or creater can close betting @ CloseBetting()\\\"\\n        );\\n\\n        require(\\n            betting.status == Status.Open,\\n            \\\"Betting is not open @ CloseBetting()\\\"\\n        );\\n        require(\\n            block.timestamp >= betting.pendingTime,\\n            \\\"Betting pendingTime has not passed yet @ CloseBetting()\\\"\\n        );\\n        require(\\n            block.timestamp >= betting.endTime,\\n            \\\"Betting endTime has not passed yet @ CloseBetting()\\\"\\n        );\\n\\n        uint256 token_decimails;\\n        address oracle_address;\\n\\n        // get token decimals\\n        for (uint256 i = 0; i <= SupportedTokenCount; i++) {\\n            if (\\n                supported_tokens[i].token == betting.token &&\\n                supported_tokens[i].valid == true\\n            ) {\\n                token_decimails = supported_tokens[i].decimails;\\n                oracle_address = supported_tokens[i].oracle_address;\\n            }\\n        }\\n\\n        better_oracle = BettingOracle_ChainLink(oracle_address);\\n\\n        (uint256 _correctPrice, ) = better_oracle\\n            .fetch_closest_price_to_timestamp(\\n                betting.token,\\n                betting.endTime,\\n                token_decimails\\n            );\\n\\n        //to do: use oracle to replace this line\\n        bettings[_betting_id].correctPrice = _correctPrice;\\n\\n        bool hasWinner = false;\\n\\n        uint256 all_winner_bet_amount = 0;\\n\\n        uint256 correct_price_range = (_correctPrice * range_percentage) / 200;\\n\\n        uint256 correct_price_upper_bond = _correctPrice + correct_price_range;\\n\\n        uint256 correct_price_lower_bond = _correctPrice - correct_price_range;\\n\\n        //loop current betting to calculate winners\\n        for (uint256 i = 0; i <= betCount; i++) {\\n            if (bets[i].betting_id == _betting_id) {\\n                if (bets[i].amount != 0) {\\n                    // meet the price range\\n                    if (\\n                        bets[i].predictedPrice >= correct_price_lower_bond &&\\n                        bets[i].predictedPrice <= correct_price_upper_bond\\n                    ) {\\n                        bets[i].winner = true;\\n                        hasWinner = true;\\n\\n                        all_winner_bet_amount += bets[i].amount;\\n                    }\\n                }\\n            }\\n        }\\n\\n        //loop current betting to calculate winning ratio and winning amount\\n        if (hasWinner == true) {\\n            for (uint256 i = 0; i <= betCount; i++) {\\n                if (bets[i].betting_id == _betting_id) {\\n                    if (bets[i].winner == true) {\\n                        //uint256 winnings_ratio = (bets[i].amount * ratio_decimails )/ all_winner_bet_amount;\\n\\n                        //bets[i].winningsRatio = (bets[i].amount * ratio_decimails )/ all_winner_bet_amount;\\n                        //bets[i].winningsAmount = (((bets[i].amount * ratio_decimails )/ all_winner_bet_amount) * (bettings[_betting_id].totalAmount - all_winner_bet_amount)) / ratio_decimails;\\n                        bets[i].winningsRatio = calculate_winningsRatio(\\n                            i,\\n                            all_winner_bet_amount\\n                        );\\n                        bets[i].winningsAmount = calculate_winningsAmount(\\n                            _betting_id,\\n                            i,\\n                            all_winner_bet_amount\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        //betting is closed, waiting for user to claim winnings\\n        betting.status = Status.Pending;\\n        betting.hadWinner = hasWinner;\\n    }\\n\\n    /**\\n     * calculate_winningsRatio for CloseBetting(uint256 _betting_id)\\n     */\\n    function calculate_winningsRatio(\\n        uint256 bet_id,\\n        uint256 all_winner_bet_amount\\n    ) private view returns (uint256) {\\n        return (bets[bet_id].amount * ratio_decimails) / all_winner_bet_amount;\\n    }\\n\\n    /**\\n     * calculate_winningsAmount for CloseBetting(uint256 _betting_id)\\n     */\\n    function calculate_winningsAmount(\\n        uint256 _betting_id,\\n        uint256 bet_id,\\n        uint256 all_winner_bet_amount\\n    ) private view returns (uint256) {\\n        return\\n            (((bets[bet_id].amount * ratio_decimails) / all_winner_bet_amount) *\\n                (bettings[_betting_id].totalAmount - all_winner_bet_amount)) /\\n            ratio_decimails;\\n    }\\n\\n    /**\\n     * if betting has no winners, all better can not claims\\n     * if betting has winner, only winners can claims\\n     */\\n    function WinningClaims(address token_address, uint256 _bettingId) public {\\n        (\\n            uint256 bet_id_in_current_betting_id,\\n            uint256 bet_id_in_all_bet_list\\n        ) = bet_id_by_user(_bettingId, msg.sender);\\n\\n        require(\\n            bet_id_in_all_bet_list > 0,\\n            \\\"wrong bet id in bet list @ WinningClaims()\\\"\\n        );\\n        require(\\n            bet_id_in_current_betting_id > 0,\\n            \\\"wrong bet id in betting list @ WinningClaims()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].betting_id == _bettingId,\\n            \\\"wrong betting id @ WinningClaims()\\\"\\n        );\\n\\n        require(\\n            bettings[_bettingId].status == Status.Pending,\\n            \\\"Betting is not pending @ WinningClaims()\\\"\\n        );\\n\\n        require(\\n            bettings[_bettingId].hadWinner == true,\\n            \\\"This betting has no winner. @ WinningClaims()\\\"\\n        );\\n\\n        require(\\n            bets[bet_id_in_all_bet_list].user == msg.sender,\\n            \\\"You did not bet on this betting. @ WinningClaims()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].winner == true,\\n            \\\"You did not win over this bet. @ WinningClaims()\\\"\\n        );\\n\\n        uint256 winnings = bets[bet_id_in_all_bet_list].winningsAmount;\\n        uint256 bet_amount = bets[bet_id_in_all_bet_list].amount;\\n        uint256 transfer_amount = winnings + bet_amount;\\n\\n        require(\\n            transfer_amount > 0,\\n            \\\"Your winning amount is zero. @ WinningClaims()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].claimed == false,\\n            \\\"You have already claimed your winnings. @ WinningClaims()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].rebeted == false,\\n            \\\"You have already rebeted your winnings. @ WinningClaims()\\\"\\n        );\\n\\n        if (transfer_amount > 0) {\\n\\n            IERC20 token = IERC20(token_address);\\n\\n            token.transfer(msg.sender, transfer_amount);\\n\\n            bets[bet_id_in_all_bet_list].claimed = true;\\n\\n            emit WinningClaimed(msg.sender, transfer_amount);\\n        }\\n    }\\n\\n    /**\\n     * if betting has no winners, all better can rebet\\n     * if betting has winner, only winners can rebet\\n     */\\n    function ReBet(\\n        address token_address,\\n        uint256 _originalbetting_bettingId,\\n        uint256 _newbetting_bettingId,\\n        uint256 predictedPrice\\n    ) public returns (bool) {\\n        (\\n            uint256 bet_id_in_current_betting_id,\\n            uint256 bet_id_in_all_bet_list\\n        ) = bet_id_by_user(_originalbetting_bettingId, msg.sender);\\n        require(\\n            bet_id_in_all_bet_list > 0,\\n            \\\"wrong bet id in bet list @ ReBet()\\\"\\n        );\\n        require(\\n            bet_id_in_current_betting_id > 0,\\n            \\\"wrong bet id in betting list @ ReBet()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].betting_id ==\\n                _originalbetting_bettingId,\\n            \\\"wrong betting id @ ReBet()\\\"\\n        );\\n\\n        require(\\n            bettings[_originalbetting_bettingId].status == Status.Pending,\\n            \\\"Betting is not pending @ ReBet()\\\"\\n        );\\n        require(\\n            bettings[_originalbetting_bettingId].token == token_address,\\n            \\\"incompatible token address for _originalbetting_bettingId @ ReBet()\\\"\\n        );\\n\\n        require(\\n            bets[bet_id_in_all_bet_list].user == msg.sender,\\n            \\\"You did not bet on this betting. @ ReBet()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].claimed == false,\\n            \\\"You have already claimed your winnings. @ ReBet()\\\"\\n        );\\n        require(\\n            bets[bet_id_in_all_bet_list].rebeted == false,\\n            \\\"You have already rebeted your winnings. @ ReBet()\\\"\\n        );\\n\\n        uint256 rebet_amount = 0;\\n\\n        if (bettings[_originalbetting_bettingId].hadWinner == true) {\\n            require(\\n                bets[bet_id_in_all_bet_list].winner == true,\\n                \\\"Only winner can rebet. @ ReBet()\\\"\\n            );\\n            //only winner can rebet\\n            uint256 winnings = bets[bet_id_in_all_bet_list].winningsAmount;\\n            uint256 bet_amount = bets[bet_id_in_all_bet_list].amount;\\n            rebet_amount = winnings + bet_amount;\\n        } else {\\n            // if betting has no winners, all better can rebet\\n            rebet_amount = bets[bet_id_in_all_bet_list].amount;\\n        }\\n\\n        require(\\n            rebet_amount > 0,\\n            \\\"You don't have enough amount to rebet @ ReBet()\\\"\\n        );\\n\\n        if (rebet_amount > 0) {\\n\\n            uint256 new_bet_length = CreateBet(\\n                token_address,\\n                _newbetting_bettingId,\\n                predictedPrice,\\n                rebet_amount\\n            );\\n\\n            if (new_bet_length > bet_id_in_all_bet_list) {\\n                bets[bet_id_in_all_bet_list].rebeted = true;\\n\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * total fee eaquals 2 times of fee_percentage for betting creater and developer\\n     */\\n    function FeeCollector(\\n        uint256 _bettingId,\\n        uint256 amount\\n    ) private returns (uint256) {\\n       \\n\\n        address token_address = bettings[_bettingId].token;\\n\\n        IERC20 token = IERC20(token_address);\\n\\n        uint256 fee = (amount * fee_percentage) / 100;\\n\\n        address recipient = bettings[_bettingId].creater;\\n\\n        //fee for betting creater\\n        token.transferFrom(msg.sender, recipient, fee/2);\\n\\n        //fee for developer\\n        token.transferFrom(msg.sender, developer, fee/2);\\n\\n        return fee;\\n    }\\n\\n    /**\\n    return last uint256 key index of bet from indicated bettingId\\n    */\\n    function bet_length(uint256 _bettingId) public view returns (uint256) {\\n        uint256 currentBetting_bet_length = bettings[_bettingId].totalBets;\\n\\n        return currentBetting_bet_length;\\n    }\\n\\n    /**\\n    return uint256 key index of specific bet from indicated bettingId\\n    */\\n    function bet_id_by_user(\\n        uint256 _bettingId,\\n        address user\\n    ) public view returns (uint256, uint256) {\\n        uint256 bet_id_in_all_bet_list = 0;\\n        uint256 bet_id_in_current_betting_id = 0;\\n\\n        for (uint256 i = 0; i <= betCount; i++) {\\n            if (bets[i].betting_id == _bettingId) {\\n                if (bets[i].user == user) {\\n                    bet_id_in_all_bet_list = i;\\n                    bet_id_in_current_betting_id = bets[i].bet_id;\\n                    break;\\n                }\\n            }\\n        }\\n        return (bet_id_in_current_betting_id, bet_id_in_all_bet_list);\\n    }\\n    \\n\\n    /**\\n     * to render all bettings\\n     * parameters : uint256 pagetion = page number\\n     * parameters : uint256 bettingPerPage = render how many bettings per page\\n     *\\n     * return Betting [] in reverse index by page\\n     * return Betting [] length\\n     *\\n    function render_bettings(uint256 pagetion, uint256 bettingPerPage ) public view returns (Betting[] memory, uint256, bool) {\\n        \\n\\n        uint256 currentBettingCount = 0;\\n        uint256 currentBettingIndexStart = 0;\\n        uint256 currentBettingIndexEnd = 0;\\n        bool lastPage = true;\\n\\n        //to check if bettingPerPage is suffieient\\n        if(bettingPerPage * pagetion < bettingCount){\\n            currentBettingCount = bettingPerPage;\\n            if (pagetion == 1){\\n                currentBettingIndexStart = bettingCount;\\n                currentBettingIndexEnd = bettingCount - bettingPerPage;\\n            }else {\\n                currentBettingIndexStart = (bettingCount - (bettingPerPage * (pagetion-1))) - 1;\\n                currentBettingIndexEnd = bettingCount - bettingPerPage * pagetion;\\n            }\\n            lastPage = false;\\n        }else if(bettingPerPage * pagetion < (bettingCount + bettingPerPage)){\\n            currentBettingCount = bettingCount - bettingPerPage * (pagetion - 1);\\n            currentBettingIndexStart = (bettingCount - (bettingPerPage * (pagetion-1))) - 1;\\n            currentBettingIndexEnd = 0;\\n            lastPage = true;\\n        }\\n        \\n        Betting[] memory allBettings = new Betting[](currentBettingCount);\\n\\n        uint256 k = 0;\\n\\n        for (uint256 i = currentBettingIndexStart; i > currentBettingIndexEnd; i--) {\\n            allBettings[k] = bettings[i];\\n            k++;\\n        }\\n\\n        return (allBettings, k, lastPage);\\n    }\\n    */\\n\\n    /**\\n     * to render all bettings\\n     *\\n     * return Betting [] in reverse index\\n     * return Betting [] length\\n     */\\n    function render_bettings() public view returns (Betting[] memory, uint256) {\\n        Betting[] memory allBettings = new Betting[](bettingCount);\\n\\n        uint256 k = 0;\\n\\n        for (uint256 i = bettingCount; i > 0; i--) {\\n            allBettings[k] = bettings[i];\\n            k++;\\n        }\\n\\n        return (allBettings, k);\\n    }\\n\\n    /**\\n     * to render betting of specific betting id\\n     * parameter:\\n     * uint256 _betting_id\\n     * return Betting []\\n     */\\n    function render_betting_data_of_specific_betting_id(\\n        uint256 _betting_id\\n    ) public view returns (Betting[] memory) {\\n\\n        Betting[] memory thisBetting = new Betting[](1);\\n\\n        uint _length = bettingCount;\\n\\n        for (uint256 i = _length; i > 0; i--) {\\n\\n            if (bettings[i].id == _betting_id) {\\n                thisBetting[0] = bettings[i];\\n                break;\\n            }\\n\\n        }\\n\\n        return thisBetting;\\n\\n    }\\n\\n     /**\\n     * to render bettings of specific bet creater\\n     * parameter:\\n     * address _user\\n     * return Betting [] in reverse index\\n     * return Betting [] length\\n     */\\n    function render_bettings_of_specific_betting_creater( address _creater ) public view returns (Betting[] memory, uint256) {\\n        uint256 current_bettings_length = 0;\\n\\n        uint _length = bettingCount;\\n\\n        for (uint256 i = 0; i <= _length; i++) {\\n            if (bettings[i].creater == _creater) {\\n                current_bettings_length++;\\n            }\\n        }\\n\\n        Betting[] memory myBettings = new Betting[](current_bettings_length);\\n\\n        uint256 render_count = 0;\\n        uint256 k = 0;\\n\\n        for (uint256 i = _length; i > 0; i--) {\\n            if (bettings[i].creater == _creater) {\\n                myBettings[k] = bettings[i];\\n                render_count++;\\n                k++;\\n            }\\n\\n            if (render_count >= current_bettings_length) {\\n                break;\\n            }\\n        }\\n\\n        return (myBettings, k);\\n    }\\n\\n    /**\\n     * to render bets of specific betting id\\n     * parameter:\\n     * uint256 _betting_id\\n     * return Bet [] in reverse index\\n     * return Bet [] length\\n     */\\n    function render_bets_of_specific_betting_id(\\n        uint256 _betting_id\\n    ) public view returns (Bet[] memory, uint256) {\\n        uint256 current_bets_length = 0;\\n\\n        uint _length = betCount;\\n\\n        for (uint256 i = 0; i <= _length; i++) {\\n            if (bets[i].betting_id == _betting_id) {\\n                current_bets_length++;\\n            }\\n        }\\n\\n        Bet[] memory allBets = new Bet[](current_bets_length);\\n\\n        uint256 render_count = 0;\\n        uint256 k = 0;\\n\\n        //for (uint256 i = _shifts; i < betCount; i++){\\n        for (uint256 i = _length; i > 0; i--) {\\n            if (bets[i].betting_id == _betting_id) {\\n                allBets[k] = bets[i];\\n                render_count++;\\n                k++;\\n            }\\n\\n            if (render_count >= current_bets_length) {\\n                break;\\n            }\\n        }\\n\\n        return (allBets, k);\\n    }\\n\\n    /**\\n     * to render bets of specific bet creater\\n     * parameter:\\n     * address _user\\n     * return Bet [] in reverse index\\n     * return Bet [] length\\n     */\\n    function render_bets_of_specific_bet_creater(\\n        address _user\\n    ) public view returns (Bet[] memory, uint256) {\\n        uint256 current_bets_length = 0;\\n\\n        uint _length = betCount;\\n\\n        for (uint256 i = 0; i <= _length; i++) {\\n            if (bets[i].user == _user) {\\n                current_bets_length++;\\n            }\\n        }\\n\\n        Bet[] memory allBets = new Bet[](current_bets_length);\\n\\n        uint256 render_count = 0;\\n        uint256 k = 0;\\n\\n        //for (uint256 i = _shifts; i < betCount; i++){\\n        for (uint256 i = _length; i > 0; i--) {\\n            if (bets[i].user == _user) {\\n                allBets[k] = bets[i];\\n                render_count++;\\n                k++;\\n            }\\n\\n            if (render_count >= current_bets_length) {\\n                break;\\n            }\\n        }\\n\\n        return (allBets, k);\\n    }\\n\\n    /**\\n     * to render supported token by valid parameter\\n     * parameter:\\n     * bool _valid\\n     * return SupportedToken [] in reverse index\\n     *\\n    function render_supported_tokens_of_valid(\\n        bool _valid\\n    ) public view returns (SupportedToken[] memory) {\\n        uint256 current_supported_tokens_length = 0;\\n\\n        uint _length = SupportedTokenCount;\\n\\n        for (uint256 i = 0; i <= _length; i++) {\\n            if (supported_tokens[i].valid == _valid) {\\n                current_supported_tokens_length++;\\n            }\\n        }\\n\\n        SupportedToken[] memory allSupported_tokens = new SupportedToken[](\\n            current_supported_tokens_length\\n        );\\n\\n        uint256 render_count = 0;\\n        uint256 k = 0;\\n\\n        for (uint256 i = _length; i > 0; i--) {\\n            if (supported_tokens[i].valid == _valid) {\\n                allSupported_tokens[k] = supported_tokens[i];\\n                render_count++;\\n                k++;\\n            }\\n\\n            if (render_count >= current_supported_tokens_length) {\\n                break;\\n            }\\n        }\\n\\n        return allSupported_tokens;\\n    }\\n    */\\n}\"\r\n    },\r\n    \"https://github.com/BetterSmartContract/BetterV0/blob/main/BettingOracle_ChainLink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\ncontract BettingOracle_ChainLink {\\n    address public developer;\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n    struct ChainLink_Price_Feed_Contract_Addresses {\\n        uint256 id;\\n        address token_address;\\n        address ENS_address;\\n        AggregatorV3Interface this_priceFeed;\\n        uint ENS_address_decimails;\\n        bool valid;\\n    }\\n\\n    mapping(uint256 => ChainLink_Price_Feed_Contract_Addresses)\\n        public token_address_in_contract_addresses;\\n\\n    uint256 public ContractAddresses_Id;\\n    uint256 public current_ContractAddresses_Id;\\n\\n    /*\\n    struct TokenPrice {\\n        uint256 id;\\n        address token_address;\\n        address ENS_address;\\n        uint80 roundID;\\n        uint256 Timestamp;\\n        int price;\\n    }\\n\\n    mapping(uint256 => TokenPrice) public Token_Price;  \\n\\n    uint256 public TokenPrice_Id;\\n    */\\n    uint public returned_target_price;\\n    int256 public target_price;\\n    uint80 public target_roundID;\\n\\n    /**\\n     * Network: Sepolia\\n     * Aggregator: ETH/USD\\n     * Address:\\t0x694AA1769357215DE4FAC081bf1f309aDC325306\\n     */\\n    /**\\n     * Network: Sepolia\\n     * Aggregator: BTC/USD\\n     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43\\n     */\\n    /**\\n     * Network: Sepolia\\n     * Aggregator: USDC / USD\\n     * Address: 0xA2F78ab2355fe2f984D808B5CeE7FD0A93D5270E\\n     */\\n    constructor() {\\n        developer = msg.sender;\\n    }\\n\\n    /**\\n     * to add ChainLink ENS address into struct ChainLink_Price_Feed_Contract_Addresses.\\n     * parameters:\\n     * token_address:supported ERC20 token.\\n     * ENS_address: https://docs.chain.link/data-feeds/price-feeds/addresses\\n     */\\n    function add_ENS_address(\\n        address token_address,\\n        address ENS_address\\n    ) public returns (uint256) {\\n        require(developer == msg.sender, \\\"only developer can add ENS address!\\\");\\n\\n        ContractAddresses_Id++;\\n\\n        AggregatorV3Interface this_priceFeed = AggregatorV3Interface(\\n            ENS_address\\n        );\\n\\n        uint ENS_address_decimails = this_priceFeed.decimals();\\n\\n        ChainLink_Price_Feed_Contract_Addresses\\n            storage new_ChainLink_Price_Feed_Contract_Addresses = token_address_in_contract_addresses[\\n                ContractAddresses_Id\\n            ];\\n        new_ChainLink_Price_Feed_Contract_Addresses.id = ContractAddresses_Id;\\n        new_ChainLink_Price_Feed_Contract_Addresses\\n            .token_address = token_address;\\n        new_ChainLink_Price_Feed_Contract_Addresses.ENS_address = ENS_address;\\n        new_ChainLink_Price_Feed_Contract_Addresses\\n            .this_priceFeed = this_priceFeed;\\n        new_ChainLink_Price_Feed_Contract_Addresses\\n            .ENS_address_decimails = ENS_address_decimails;\\n        new_ChainLink_Price_Feed_Contract_Addresses.valid = true;\\n\\n        return ContractAddresses_Id;\\n    }\\n\\n    /**\\n     * to set ChainLink ENS address for current price feed query of indicated token address.\\n     * parameters:\\n     * token_address:supported ERC20 token address in struct ChainLink_Price_Feed_Contract_Addresses.\\n     * returns: AggregatorV3Interface object\\n     */\\n    function set_ENS_address(\\n        address token_address\\n    ) public returns (AggregatorV3Interface) {\\n        if (\\n            current_ContractAddresses_Id != 0 &&\\n            token_address_in_contract_addresses[current_ContractAddresses_Id]\\n                .token_address ==\\n            token_address\\n        ) {\\n            return\\n                token_address_in_contract_addresses[\\n                    current_ContractAddresses_Id\\n                ].this_priceFeed;\\n        } else {\\n            bool priceFeed_exist = false;\\n\\n            for (uint256 i = 0; i <= ContractAddresses_Id; i++) {\\n                if (\\n                    token_address_in_contract_addresses[i].token_address ==\\n                    token_address &&\\n                    token_address_in_contract_addresses[i].valid == true\\n                ) {\\n                    priceFeed = token_address_in_contract_addresses[i]\\n                        .this_priceFeed;\\n                    current_ContractAddresses_Id = i;\\n                    priceFeed_exist = true;\\n                }\\n            }\\n\\n            require(\\n                priceFeed_exist == true,\\n                \\\"token address is not supported @ set_ENS_address()!\\\"\\n            );\\n\\n            return priceFeed;\\n        }\\n    }\\n\\n    /**\\n     * to update ChainLink ENS address in struct ChainLink_Price_Feed_Contract_Addresses.\\n     * parameters:\\n     * id: id of ChainLink_Price_Feed_Contract_Addresses\\n     * token_address:supported ERC20 token in the ChainLink_Price_Feed_Contract_Addresses.\\n     * ENS_address: https://docs.chain.link/data-feeds/price-feeds/addresses\\n     * valid: valid or not for this address in the ChainLink_Price_Feed_Contract_Addresses.\\n     */\\n    function update_ENS_address(\\n        uint256 id,\\n        address token_address,\\n        address ENS_address,\\n        bool valid\\n    ) public {\\n        require(\\n            developer == msg.sender,\\n            \\\"only developer can update ENS address!\\\"\\n        );\\n\\n        AggregatorV3Interface this_priceFeed = AggregatorV3Interface(\\n            ENS_address\\n        );\\n\\n        uint ENS_address_decimails = this_priceFeed.decimals();\\n\\n        token_address_in_contract_addresses[id].token_address = token_address;\\n        token_address_in_contract_addresses[id].ENS_address = ENS_address;\\n        token_address_in_contract_addresses[id].this_priceFeed = this_priceFeed;\\n        token_address_in_contract_addresses[id]\\n            .ENS_address_decimails = ENS_address_decimails;\\n        token_address_in_contract_addresses[id].valid = valid;\\n    }\\n\\n    /**\\n     * Returns the round data.\\n     */\\n    function getRoundData(\\n        uint80 _roundId\\n    ) public view returns (uint80, int256, uint256, uint256, uint80) {\\n        // prettier-ignore\\n        (\\n            uint80 roundID,\\n            int256 answer,\\n            uint startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        ) = priceFeed.getRoundData(_roundId);\\n        return (roundID, answer, startedAt, updatedAt, answeredInRound);\\n    }\\n\\n    /**\\n     * Returns the latest price.\\n     */\\n    function getLatestPrice()\\n        public\\n        view\\n        returns (uint80, int, uint, uint, uint80)\\n    {\\n        // prettier-ignore\\n        (\\n            uint80 roundID,\\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        return (roundID, price, startedAt, timeStamp, answeredInRound);\\n    }\\n\\n    /**\\n     * to add last price from ChainLink price feed into struct TokenPrice\\n     * parameters:\\n     * token_address:supported ERC20 token in the ChainLink_Price_Feed_Contract_Addresses.\\n     * returns:\\n     * priceFeed.latestRoundData object\\n     * uint80 roundID, int price, uint startedAt,uint timeStamp, uint80 answeredInRound\\n     */\\n    /*\\n    function add_last_token_price(address token_address) public returns (uint80, int, uint, uint,uint80) {\\n\\n        priceFeed = set_ENS_address(token_address);\\n\\n        (\\n            uint80 roundID,\\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = getLatestPrice();\\n\\n        bool exist = false;\\n\\n        for (uint256 i = 0; i <= TokenPrice_Id; i++) {\\n            \\n            if( Token_Price[i].token_address == token_address && Token_Price[i].roundID == roundID ) {\\n\\n                exist = true;\\n\\n                break;\\n\\n            }\\n\\n        }\\n\\n        if(exist == false){\\n\\n            TokenPrice_Id++;\\n    \\n\\n            TokenPrice storage new_Token_Price = Token_Price[TokenPrice_Id];\\n            new_Token_Price.id = TokenPrice_Id;\\n            new_Token_Price.token_address = token_address_in_contract_addresses[current_ContractAddresses_Id].token_address;\\n            new_Token_Price.ENS_address = token_address_in_contract_addresses[current_ContractAddresses_Id].ENS_address;\\n            new_Token_Price.roundID = roundID;\\n            new_Token_Price.Timestamp = timeStamp;\\n            new_Token_Price.price = price;\\n\\n\\n        }\\n\\n        return (roundID, price, startedAt,timeStamp, answeredInRound );\\n\\n        \\n\\n    }\\n    */\\n\\n    /**\\n     * Returns historical price for a round id.\\n     * roundId is NOT incremental. Not all roundIds are valid.\\n     * You must know a valid roundId before consuming historical data.\\n     *\\n     * ROUNDID VALUES:\\n     *    InValid:      18446744073709562300\\n     *    Valid:        18446744073709554683\\n     *\\n     * @dev A timestamp with zero value means the round is not complete and should not be used.\\n     */\\n    function getHistoricalPrice(\\n        uint80 roundId\\n    ) public view returns (int256, uint) {\\n        // prettier-ignore\\n        (\\n            /*uint80 roundID*/,\\n            int price,\\n            /*uint startedAt*/,\\n            uint timeStamp,\\n            /*uint80 answeredInRound*/\\n        ) = priceFeed.getRoundData(roundId);\\n        //require(timeStamp > 0, \\\"Round not complete\\\");\\n        if (timeStamp == 0) {\\n            price = 0;\\n        }\\n        return (price, timeStamp);\\n    }\\n\\n    /**\\n     * to fetch the price from ChainLink price feed of specified timeStamp\\n     * parameters:\\n     * token_address:supported ERC20 token in the ChainLink_Price_Feed_Contract_Addresses.\\n     * timeStamp:preffered timestamp.\\n     * token_decimails:token_decimails of supported ERC20 token\\n     * returns:\\n     * priceFeed.getRoundData() object by roundId\\n     * int256 price.\\n     * uint80 timeStamp.\\n     */\\n    function fetch_closest_price_to_timestamp(\\n        address token_address,\\n        uint timeStamp,\\n        uint token_decimails\\n    ) public returns (uint256, uint80) {\\n        set_ENS_address(token_address);\\n\\n        uint80 roundID;\\n        int price;\\n        uint startedAt;\\n        uint last_timeStamp;\\n        uint80 answeredInRound;\\n\\n        /*first get roundID of last price*/\\n        (\\n            roundID,\\n            price,\\n            startedAt,\\n            last_timeStamp,\\n            answeredInRound\\n        ) = getLatestPrice();\\n\\n        /*use roundID of last price to find old data*/\\n        bool found = false;\\n        uint80 next_roundID = roundID;\\n        uint ENS_address_decimails;\\n\\n        int next_price;\\n        uint next_timeStamp;\\n\\n        while (found == false) {\\n            (next_price, next_timeStamp) = getHistoricalPrice(next_roundID);\\n\\n            target_price = next_price;\\n            target_roundID = next_roundID;\\n\\n            /*find the smallest timestamp_difference, means closest timestamp to the target*/\\n            if (\\n                next_timeStamp <= timeStamp &&\\n                next_timeStamp > 0 &&\\n                next_price > 0\\n            ) {\\n                ENS_address_decimails = token_address_in_contract_addresses[\\n                    current_ContractAddresses_Id\\n                ].ENS_address_decimails;\\n                found = true;\\n                break;\\n            }\\n\\n            next_roundID--;\\n        }\\n\\n        /* calculates correct deciamls */\\n        uint correct_decimals = token_decimails - ENS_address_decimails;\\n        returned_target_price = uint(target_price) * (10 ** correct_decimals);\\n\\n        return (returned_target_price, target_roundID);\\n    }\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"in_timeLeap_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"in_timeLeap_pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"in_fee_percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"in_range_percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"in_ratio_decimails\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betting_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"winner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rebeted\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningsRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningsAmount\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"}],\"name\":\"BettingClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creater\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hadWinner\",\"type\":\"bool\"}],\"name\":\"BettingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle_address\",\"type\":\"address\"}],\"name\":\"SupportedTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinningClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimails\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oracle_address\",\"type\":\"address\"}],\"name\":\"AddSupportedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betting_id\",\"type\":\"uint256\"}],\"name\":\"CloseBetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betting_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreateBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"CreateBetting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originalbetting_bettingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newbetting_bettingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"}],\"name\":\"ReBet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SupportedTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"oracle_address\",\"type\":\"address\"}],\"name\":\"UpdateSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bettingId\",\"type\":\"uint256\"}],\"name\":\"WinningClaims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bettingId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"bet_id_by_user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bettingId\",\"type\":\"uint256\"}],\"name\":\"bet_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betting_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rebeted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winningsRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winningsAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"better_oracle\",\"outputs\":[{\"internalType\":\"contract BettingOracle_ChainLink\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bettingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creater\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BettingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hadWinner\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee_percentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"range_percentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"render_bets_of_specific_bet_creater\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betting_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rebeted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winningsRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winningsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BettingContract.Bet[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betting_id\",\"type\":\"uint256\"}],\"name\":\"render_bets_of_specific_betting_id\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bet_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betting_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"predictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"winner\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rebeted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winningsRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winningsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BettingContract.Bet[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betting_id\",\"type\":\"uint256\"}],\"name\":\"render_betting_data_of_specific_betting_id\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creater\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BettingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hadWinner\",\"type\":\"bool\"}],\"internalType\":\"struct BettingContract.Betting[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"render_bettings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creater\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BettingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hadWinner\",\"type\":\"bool\"}],\"internalType\":\"struct BettingContract.Betting[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creater\",\"type\":\"address\"}],\"name\":\"render_bettings_of_specific_betting_creater\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creater\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"correctPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BettingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"hadWinner\",\"type\":\"bool\"}],\"internalType\":\"struct BettingContract.Betting[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supported_tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimails\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"oracle_address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLeap_end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLeap_pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"in_timeLeap_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"in_timeLeap_pending\",\"type\":\"uint256\"}],\"name\":\"update_timeLeap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BettingContract", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000002d00000000000000000000000000000000000000000000000000000000000000168000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000de0b6b3a7640000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}