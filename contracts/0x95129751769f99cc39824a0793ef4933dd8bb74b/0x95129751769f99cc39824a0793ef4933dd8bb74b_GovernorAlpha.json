{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"temp-contracts/governance/GovernorAlpha.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/ITimelock.sol\\\";\\n\\n\\ncontract GovernorAlpha {\\n  /// @dev The name of this contract\\n  string public constant name = \\\"Indexed Governor Alpha\\\";\\n  \\n  /// @dev The voting period which will be set after setVotingPeriodAfter has passed.\\n  uint256 public constant permanentVotingPeriod = 17_280; // ~3 days in blocks (assuming 15s blocks)\\n\\n  /**\\n   * @dev The number of votes in support of a proposal required in order for a\\n   * quorum to be reached and for a vote to succeed\\n   */ \\n  function quorumVotes() public pure returns (uint256) {\\n    return 400_000e18; // 4% of NDX\\n  }\\n\\n  /**\\n   * @dev The number of votes required in order for a voter to become a proposer\\n   */\\n  function proposalThreshold() public pure returns (uint256) {\\n    return 100_000e18; // 1% of NDX\\n  }\\n\\n  /**\\n   * @dev The maximum number of actions that can be included in a proposal\\n   */\\n  function proposalMaxOperations() public pure returns (uint256) {\\n    return 10;\\n  }\\n\\n  /**\\n   * @dev The delay before voting on a proposal may take place, once proposed\\n   */\\n  function votingDelay() public pure returns (uint256) {\\n    return 1;\\n  }\\n\\n  /**\\n   * @dev The duration of voting on a proposal, in blocks\\n   */\\n  uint256 public votingPeriod = 2_880; // ~12 hours in blocks (assuming 15s blocks)\\n\\n  /**\\n   * @dev The timestamp after which votingPeriod can be set to the permanent value.\\n   */\\n  uint256 public immutable setVotingPeriodAfter;\\n\\n  /**\\n   * @dev The address of the Indexed Protocol Timelock\\n   */\\n  ITimelock public immutable timelock;\\n\\n  /**\\n   * @dev The address of the Indexed governance token\\n   */\\n  NdxInterface public immutable ndx;\\n\\n  /**\\n   * @dev The total number of proposals\\n   */\\n  uint256 public proposalCount;\\n\\n  /**\\n   * @param id Unique id for looking up a proposal\\n   * @param proposer Creator of the proposal\\n   * @param eta The timestamp that the proposal will be available for execution, set once the vote succeeds\\n   * @param targets The ordered list of target addresses for calls to be made\\n   * @param values The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n   * @param signatures The ordered list of function signatures to be called\\n   * @param calldatas The ordered list of calldata to be passed to each call\\n   * @param startBlock The block at which voting begins: holders must delegate their votes prior to this block\\n   * @param endBlock The block at which voting ends: votes must be cast prior to this block\\n   * @param forVotes Current number of votes in favor of this proposal\\n   * @param againstVotes Current number of votes in opposition to this proposal\\n   * @param canceled Flag marking whether the proposal has been canceled\\n   * @param executed Flag marking whether the proposal has been executed\\n   * @param receipts Receipts of ballots for the entire set of voters\\n   */\\n  struct Proposal {\\n    uint256 id;\\n    address proposer;\\n    uint256 eta;\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    uint256 startBlock;\\n    uint256 endBlock;\\n    uint256 forVotes;\\n    uint256 againstVotes;\\n    bool canceled;\\n    bool executed;\\n    mapping(address => Receipt) receipts;\\n  }\\n\\n  /**\\n   * @dev Ballot receipt record for a voter\\n   * @param hasVoted Whether or not a vote has been cast\\n   * @param support Whether or not the voter supports the proposal\\n   * @param votes The number of votes the voter had, which were cast\\n   */\\n  struct Receipt {\\n    bool hasVoted;\\n    bool support;\\n    uint96 votes;\\n  }\\n\\n  /**\\n   * @dev Possible states that a proposal may be in\\n   */\\n  enum ProposalState {\\n    Pending,\\n    Active,\\n    Canceled,\\n    Defeated,\\n    Succeeded,\\n    Queued,\\n    Expired,\\n    Executed\\n  }\\n\\n  /**\\n   * @dev The official record of all proposals ever proposed\\n   */\\n  mapping(uint256 => Proposal) public proposals;\\n\\n  /**\\n   * @dev The latest proposal for each proposer\\n   */\\n  mapping(address => uint256) public latestProposalIds;\\n\\n  /**\\n   * @dev The EIP-712 typehash for the contract's domain\\n   */\\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\n    \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n  );\\n\\n  /**\\n   * @dev The EIP-712 typehash for the ballot struct used by the contract\\n   */\\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\\n    \\\"Ballot(uint256 proposalId,bool support)\\\"\\n  );\\n\\n  /**\\n   * @dev An event emitted when a new proposal is created\\n   */\\n  event ProposalCreated(\\n    uint256 id,\\n    address proposer,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    uint256 startBlock,\\n    uint256 endBlock,\\n    string description\\n  );\\n\\n  /**\\n   * @dev An event emitted when a vote has been cast on a proposal\\n   */\\n  event VoteCast(\\n    address voter,\\n    uint256 proposalId,\\n    bool support,\\n    uint256 votes\\n  );\\n\\n  /**\\n   * @dev An event emitted when a proposal has been canceled\\n   */\\n  event ProposalCanceled(uint256 id);\\n\\n  /**\\n   * @dev An event emitted when a proposal has been queued in the Timelock\\n   */\\n  event ProposalQueued(uint256 id, uint256 eta);\\n\\n  /**\\n   * @dev An event emitted when a proposal has been executed in the Timelock\\n   */\\n  event ProposalExecuted(uint256 id);\\n\\n  constructor(address timelock_, address ndx_, uint256 setVotingPeriodAfter_) public {\\n    timelock = ITimelock(timelock_);\\n    ndx = NdxInterface(ndx_);\\n    setVotingPeriodAfter = setVotingPeriodAfter_;\\n  }\\n\\n  /**\\n   * @dev Sets votingPeriod to the permanent value.\\n   * Can only be called after setVotingPeriodAfter\\n   */\\n  function setPermanentVotingPeriod() external {\\n    require(\\n      block.timestamp >= setVotingPeriodAfter,\\n      \\\"GovernorAlpha::setPermanentVotingPeriod: setting permanent voting period not allowed yet\\\"\\n    );\\n    votingPeriod = permanentVotingPeriod;\\n  }\\n\\n  function propose(\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    string memory description\\n  ) public returns (uint256) {\\n    require(\\n      ndx.getPriorVotes(msg.sender, sub256(block.number, 1)) >\\n        proposalThreshold(),\\n      \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\"\\n    );\\n    require(\\n      targets.length == values.length &&\\n        targets.length == signatures.length &&\\n        targets.length == calldatas.length,\\n      \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\"\\n    );\\n    require(\\n      targets.length != 0,\\n      \\\"GovernorAlpha::propose: must provide actions\\\"\\n    );\\n    require(\\n      targets.length <= proposalMaxOperations(),\\n      \\\"GovernorAlpha::propose: too many actions\\\"\\n    );\\n\\n    uint256 latestProposalId = latestProposalIds[msg.sender];\\n    if (latestProposalId != 0) {\\n      ProposalState proposersLatestProposalState = state(latestProposalId);\\n      require(\\n        proposersLatestProposalState != ProposalState.Active,\\n        \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\"\\n      );\\n      require(\\n        proposersLatestProposalState != ProposalState.Pending,\\n        \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\"\\n      );\\n    }\\n\\n    uint256 startBlock = add256(block.number, votingDelay());\\n    uint256 endBlock = add256(startBlock, votingPeriod);\\n\\n    proposalCount++;\\n    Proposal memory newProposal = Proposal({\\n      id: proposalCount,\\n      proposer: msg.sender,\\n      eta: 0,\\n      targets: targets,\\n      values: values,\\n      signatures: signatures,\\n      calldatas: calldatas,\\n      startBlock: startBlock,\\n      endBlock: endBlock,\\n      forVotes: 0,\\n      againstVotes: 0,\\n      canceled: false,\\n      executed: false\\n    });\\n\\n    proposals[newProposal.id] = newProposal;\\n    latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n    emit ProposalCreated(\\n      newProposal.id,\\n      msg.sender,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      startBlock,\\n      endBlock,\\n      description\\n    );\\n    return newProposal.id;\\n  }\\n\\n  function queue(uint256 proposalId) public {\\n    require(\\n      state(proposalId) == ProposalState.Succeeded,\\n      \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    uint256 eta = add256(block.timestamp, timelock.delay());\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      _queueOrRevert(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        eta\\n      );\\n    }\\n    proposal.eta = eta;\\n    emit ProposalQueued(proposalId, eta);\\n  }\\n\\n  function _queueOrRevert(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 eta\\n  ) internal {\\n    require(\\n      !timelock.queuedTransactions(\\n        keccak256(abi.encode(target, value, signature, data, eta))\\n      ),\\n      \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\"\\n    );\\n    timelock.queueTransaction(target, value, signature, data, eta);\\n  }\\n\\n  function execute(uint256 proposalId) public payable {\\n    require(\\n      state(proposalId) == ProposalState.Queued,\\n      \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    proposal.executed = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      timelock.executeTransaction.value(proposal.values[i])(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.eta\\n      );\\n    }\\n    emit ProposalExecuted(proposalId);\\n  }\\n\\n  function cancel(uint256 proposalId) public {\\n    ProposalState state = state(proposalId);\\n    require(\\n      state != ProposalState.Executed,\\n      \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\"\\n    );\\n\\n    Proposal storage proposal = proposals[proposalId];\\n    require(\\n      ndx.getPriorVotes(proposal.proposer, sub256(block.number, 1)) <\\n        proposalThreshold(),\\n      \\\"GovernorAlpha::cancel: proposer above threshold\\\"\\n    );\\n\\n    proposal.canceled = true;\\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\\n      timelock.cancelTransaction(\\n        proposal.targets[i],\\n        proposal.values[i],\\n        proposal.signatures[i],\\n        proposal.calldatas[i],\\n        proposal.eta\\n      );\\n    }\\n\\n    emit ProposalCanceled(proposalId);\\n  }\\n\\n  function getActions(uint256 proposalId)\\n    public\\n    view\\n    returns (\\n      address[] memory targets,\\n      uint256[] memory values,\\n      string[] memory signatures,\\n      bytes[] memory calldatas\\n    )\\n  {\\n    Proposal storage p = proposals[proposalId];\\n    return (p.targets, p.values, p.signatures, p.calldatas);\\n  }\\n\\n  function getReceipt(uint256 proposalId, address voter)\\n    public\\n    view\\n    returns (Receipt memory)\\n  {\\n    return proposals[proposalId].receipts[voter];\\n  }\\n\\n  function state(uint256 proposalId) public view returns (ProposalState) {\\n    require(\\n      proposalCount >= proposalId && proposalId > 0,\\n      \\\"GovernorAlpha::state: invalid proposal id\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    if (proposal.canceled) {\\n      return ProposalState.Canceled;\\n    } else if (block.number <= proposal.startBlock) {\\n      return ProposalState.Pending;\\n    } else if (block.number <= proposal.endBlock) {\\n      return ProposalState.Active;\\n    } else if (\\n      proposal.forVotes <= proposal.againstVotes ||\\n      proposal.forVotes < quorumVotes()\\n    ) {\\n      return ProposalState.Defeated;\\n    } else if (proposal.eta == 0) {\\n      return ProposalState.Succeeded;\\n    } else if (proposal.executed) {\\n      return ProposalState.Executed;\\n    } else if (\\n      block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())\\n    ) {\\n      return ProposalState.Expired;\\n    } else {\\n      return ProposalState.Queued;\\n    }\\n  }\\n\\n  function castVote(uint256 proposalId, bool support) public {\\n    return _castVote(msg.sender, proposalId, support);\\n  }\\n\\n  function castVoteBySig(\\n    uint256 proposalId,\\n    bool support,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public {\\n    bytes32 domainSeparator = keccak256(\\n      abi.encode(\\n        DOMAIN_TYPEHASH,\\n        keccak256(bytes(name)),\\n        getChainId(),\\n        address(this)\\n      )\\n    );\\n    bytes32 structHash = keccak256(\\n      abi.encode(BALLOT_TYPEHASH, proposalId, support)\\n    );\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n    );\\n    address signatory = ecrecover(digest, v, r, s);\\n    require(\\n      signatory != address(0),\\n      \\\"GovernorAlpha::castVoteBySig: invalid signature\\\"\\n    );\\n    return _castVote(signatory, proposalId, support);\\n  }\\n\\n  function _castVote(\\n    address voter,\\n    uint256 proposalId,\\n    bool support\\n  ) internal {\\n    require(\\n      state(proposalId) == ProposalState.Active,\\n      \\\"GovernorAlpha::_castVote: voting is closed\\\"\\n    );\\n    Proposal storage proposal = proposals[proposalId];\\n    Receipt storage receipt = proposal.receipts[voter];\\n    require(\\n      receipt.hasVoted == false,\\n      \\\"GovernorAlpha::_castVote: voter already voted\\\"\\n    );\\n    uint96 votes = ndx.getPriorVotes(voter, proposal.startBlock);\\n\\n    if (support) {\\n      proposal.forVotes = add256(proposal.forVotes, votes);\\n    } else {\\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\\n    }\\n\\n    receipt.hasVoted = true;\\n    receipt.support = support;\\n    receipt.votes = votes;\\n\\n    emit VoteCast(voter, proposalId, support, votes);\\n  }\\n\\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"addition overflow\\\");\\n    return c;\\n  }\\n\\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"subtraction underflow\\\");\\n    return a - b;\\n  }\\n\\n  function getChainId() internal pure returns (uint256) {\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    return chainId;\\n  }\\n}\\n\\ninterface NdxInterface {\\n  function getPriorVotes(address account, uint256 blockNumber)\\n    external\\n    view\\n    returns (uint96);\\n}\\n\"\r\n    },\r\n    \"temp-contracts/interfaces/ITimelock.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n\\ninterface ITimelock {\\n  event NewAdmin(address indexed newAdmin);\\n  event NewPendingAdmin(address indexed newPendingAdmin);\\n  event NewDelay(uint256 indexed newDelay);\\n  event CancelTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event ExecuteTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n  event QueueTransaction(\\n    bytes32 indexed txHash,\\n    address indexed target,\\n    uint256 value,\\n    string signature,\\n    bytes data,\\n    uint256 eta\\n  );\\n\\n  function GRACE_PERIOD() external pure returns (uint256);\\n  \\n  function MINIMUM_DELAY() external pure returns (uint256);\\n  \\n  function MAXIMUM_DELAY() external pure returns (uint256);\\n\\n  function admin() external view returns (address);\\n\\n  function pendingAdmin() external view returns (address);\\n\\n  function delay() external view returns (uint256);\\n\\n  function queuedTransactions(bytes32) external view returns (bool);\\n\\n  function setDelay(uint256 delay_) external;\\n\\n  function acceptAdmin() external;\\n\\n  function setPendingAdmin(address pendingAdmin_) external;\\n\\n  function queueTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external returns (bytes32);\\n\\n  function cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external;\\n\\n  function executeTransaction(\\n    address target,\\n    uint256 value,\\n    string calldata signature,\\n    bytes calldata data,\\n    uint256 eta\\n  ) external payable returns (bytes memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ndx_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setVotingPeriodAfter_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"internalType\":\"struct GovernorAlpha.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ndx\",\"outputs\":[{\"internalType\":\"contract NdxInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentVotingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPermanentVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setVotingPeriodAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum GovernorAlpha.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract ITimelock\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GovernorAlpha", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000078a3ef33cf033381feb43ba4212f2af5a5a0a2ea00000000000000000000000086772b1409b61c639eaac9ba0acfbb6e238e5f83000000000000000000000000000000000000000000000000000000005ff64f00", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}