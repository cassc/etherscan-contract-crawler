{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/NounsDAOV3DynamicQuorum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Library for NounsDAOLogicV3 contract containing functions related to quorum calculations\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.19;\\n\\nimport './NounsDAOInterfaces.sol';\\nimport { NounsDAOV3Fork } from './fork/NounsDAOV3Fork.sol';\\n\\nlibrary NounsDAOV3DynamicQuorum {\\n    using NounsDAOV3Fork for NounsDAOStorageV3.StorageV3;\\n\\n    error UnsafeUint16Cast();\\n\\n    /**\\n     * @notice Quorum votes required for a specific proposal to succeed\\n     * Differs from `GovernerBravo` which uses fixed amount\\n     */\\n    function quorumVotes(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) internal view returns (uint256) {\\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\\n        if (proposal.totalSupply == 0) {\\n            return proposal.quorumVotes;\\n        }\\n\\n        return\\n            dynamicQuorumVotes(\\n                proposal.againstVotes,\\n                proposal.totalSupply,\\n                getDynamicQuorumParamsAt(ds, proposal.creationBlock)\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the required quorum of for-votes based on the amount of against-votes\\n     *     The more against-votes there are for a proposal, the higher the required quorum is.\\n     *     The quorum BPS is between `params.minQuorumVotesBPS` and params.maxQuorumVotesBPS.\\n     *     The additional quorum is calculated as:\\n     *       quorumCoefficient * againstVotesBPS\\n     * @dev Note the coefficient is a fixed point integer with 6 decimals\\n     * @param againstVotes Number of against-votes in the proposal\\n     * @param totalSupply The total supply of Nouns at the time of proposal creation\\n     * @param params Configurable parameters for calculating the quorum based on againstVotes. See `DynamicQuorumParams` definition for additional details.\\n     * @return quorumVotes The required quorum\\n     */\\n    function dynamicQuorumVotes(\\n        uint256 againstVotes,\\n        uint256 totalSupply,\\n        NounsDAOStorageV3.DynamicQuorumParams memory params\\n    ) public pure returns (uint256) {\\n        uint256 againstVotesBPS = (10000 * againstVotes) / totalSupply;\\n        uint256 quorumAdjustmentBPS = (params.quorumCoefficient * againstVotesBPS) / 1e6;\\n        uint256 adjustedQuorumBPS = params.minQuorumVotesBPS + quorumAdjustmentBPS;\\n        uint256 quorumBPS = min(params.maxQuorumVotesBPS, adjustedQuorumBPS);\\n        return bps2Uint(quorumBPS, totalSupply);\\n    }\\n\\n    /**\\n     * @notice returns the dynamic quorum parameters values at a certain block number\\n     * @dev The checkpoints array must not be empty, and the block number must be higher than or equal to\\n     *     the block of the first checkpoint\\n     * @param blockNumber_ the block number to get the params at\\n     * @return The dynamic quorum parameters that were set at the given block number\\n     */\\n    function getDynamicQuorumParamsAt(NounsDAOStorageV3.StorageV3 storage ds, uint256 blockNumber_)\\n        internal\\n        view\\n        returns (NounsDAOStorageV3.DynamicQuorumParams memory)\\n    {\\n        uint32 blockNumber = safe32(blockNumber_, 'NounsDAO::getDynamicQuorumParamsAt: block number exceeds 32 bits');\\n        uint256 len = ds.quorumParamsCheckpoints.length;\\n\\n        if (len == 0) {\\n            return\\n                NounsDAOStorageV3.DynamicQuorumParams({\\n                    minQuorumVotesBPS: safe16(ds.quorumVotesBPS),\\n                    maxQuorumVotesBPS: safe16(ds.quorumVotesBPS),\\n                    quorumCoefficient: 0\\n                });\\n        }\\n\\n        if (ds.quorumParamsCheckpoints[len - 1].fromBlock <= blockNumber) {\\n            return ds.quorumParamsCheckpoints[len - 1].params;\\n        }\\n\\n        if (ds.quorumParamsCheckpoints[0].fromBlock > blockNumber) {\\n            return\\n                NounsDAOStorageV3.DynamicQuorumParams({\\n                    minQuorumVotesBPS: safe16(ds.quorumVotesBPS),\\n                    maxQuorumVotesBPS: safe16(ds.quorumVotesBPS),\\n                    quorumCoefficient: 0\\n                });\\n        }\\n\\n        uint256 lower = 0;\\n        uint256 upper = len - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2;\\n            NounsDAOStorageV3.DynamicQuorumParamsCheckpoint memory cp = ds.quorumParamsCheckpoints[center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.params;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return ds.quorumParamsCheckpoints[lower].params;\\n    }\\n\\n    /**\\n     * @notice Current min quorum votes using Nouns adjusted total supply\\n     */\\n    function minQuorumVotes(NounsDAOStorageV3.StorageV3 storage ds, uint256 adjustedTotalSupply)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return bps2Uint(getDynamicQuorumParamsAt(ds, block.number).minQuorumVotesBPS, adjustedTotalSupply);\\n    }\\n\\n    /**\\n     * @notice Current max quorum votes using Nouns adjusted total supply\\n     */\\n    function maxQuorumVotes(NounsDAOStorageV3.StorageV3 storage ds, uint256 adjustedTotalSupply)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return bps2Uint(getDynamicQuorumParamsAt(ds, block.number).maxQuorumVotesBPS, adjustedTotalSupply);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe16(uint256 n) internal pure returns (uint16) {\\n        if (n > type(uint16).max) {\\n            revert UnsafeUint16Cast();\\n        }\\n        return uint16(n);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\\n        return (number * bps) / 10000;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/NounsDAOInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\n/// @title Nouns DAO Logic interfaces and events\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\n// LICENSE\\n// NounsDAOInterfaces.sol is a modified version of Compound Lab's GovernorBravoInterfaces.sol:\\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoInterfaces.sol\\n//\\n// GovernorBravoInterfaces.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\\n// With modifications by Nounders DAO.\\n//\\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\\n//\\n// MODIFICATIONS\\n// NounsDAOEvents, NounsDAOProxyStorage, NounsDAOStorageV1 add support for changes made by Nouns DAO to GovernorBravo.sol\\n// See NounsDAOLogicV1.sol for more details.\\n// NounsDAOStorageV1Adjusted and NounsDAOStorageV2 add support for a dynamic vote quorum.\\n// See NounsDAOLogicV2.sol for more details.\\n// NounsDAOStorageV3\\n// See NounsDAOLogicV3.sol for more details.\\n\\npragma solidity ^0.8.6;\\n\\ncontract NounsDAOEvents {\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(\\n        uint256 id,\\n        address proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        string description\\n    );\\n\\n    /// @notice An event emitted when a new proposal is created, which includes additional information\\n    event ProposalCreatedWithRequirements(\\n        uint256 id,\\n        address proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 proposalThreshold,\\n        uint256 quorumVotes,\\n        string description\\n    );\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    /// @param voter The address which casted a vote\\n    /// @param proposalId The proposal id which was voted on\\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\\n    /// @param votes Number of votes which were cast by the voter\\n    /// @param reason The reason given for the vote by the voter\\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the NounsDAOExecutor\\n    event ProposalQueued(uint256 id, uint256 eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the NounsDAOExecutor\\n    event ProposalExecuted(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\\n    event ProposalVetoed(uint256 id);\\n\\n    /// @notice An event emitted when the voting delay is set\\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\\n\\n    /// @notice An event emitted when the voting period is set\\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\\n\\n    /// @notice Emitted when implementation is changed\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /// @notice Emitted when proposal threshold basis points is set\\n    event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\\n\\n    /// @notice Emitted when quorum votes basis points is set\\n    event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\\n\\n    /// @notice Emitted when pendingAdmin is changed\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /// @notice Emitted when vetoer is changed\\n    event NewVetoer(address oldVetoer, address newVetoer);\\n}\\n\\ncontract NounsDAOEventsV2 is NounsDAOEvents {\\n    /// @notice Emitted when minQuorumVotesBPS is set\\n    event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\\n\\n    /// @notice Emitted when maxQuorumVotesBPS is set\\n    event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\\n\\n    /// @notice Emitted when quorumCoefficient is set\\n    event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\\n\\n    /// @notice Emitted when a voter cast a vote requesting a gas refund.\\n    event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\\n\\n    /// @notice Emitted when admin withdraws the DAO's balance.\\n    event Withdraw(uint256 amount, bool sent);\\n\\n    /// @notice Emitted when pendingVetoer is changed\\n    event NewPendingVetoer(address oldPendingVetoer, address newPendingVetoer);\\n}\\n\\ncontract NounsDAOEventsV3 is NounsDAOEventsV2 {\\n    /// @notice An event emitted when a new proposal is created, which includes additional information\\n    /// @dev V3 adds `signers`, `updatePeriodEndBlock` compared to the V1/V2 event.\\n    event ProposalCreatedWithRequirements(\\n        uint256 id,\\n        address proposer,\\n        address[] signers,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 updatePeriodEndBlock,\\n        uint256 proposalThreshold,\\n        uint256 quorumVotes,\\n        string description\\n    );\\n\\n    /// @notice Emitted when a proposal is created to be executed on timelockV1\\n    event ProposalCreatedOnTimelockV1(uint256 id);\\n\\n    /// @notice Emitted when a proposal is updated\\n    event ProposalUpdated(\\n        uint256 indexed id,\\n        address indexed proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        string description,\\n        string updateMessage\\n    );\\n\\n    /// @notice Emitted when a proposal's transactions are updated\\n    event ProposalTransactionsUpdated(\\n        uint256 indexed id,\\n        address indexed proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        string updateMessage\\n    );\\n\\n    /// @notice Emitted when a proposal's description is updated\\n    event ProposalDescriptionUpdated(\\n        uint256 indexed id,\\n        address indexed proposer,\\n        string description,\\n        string updateMessage\\n    );\\n\\n    /// @notice Emitted when a proposal is set to have an objection period\\n    event ProposalObjectionPeriodSet(uint256 indexed id, uint256 objectionPeriodEndBlock);\\n\\n    /// @notice Emitted when someone cancels a signature\\n    event SignatureCancelled(address indexed signer, bytes sig);\\n\\n    /// @notice An event emitted when the objection period duration is set\\n    event ObjectionPeriodDurationSet(\\n        uint32 oldObjectionPeriodDurationInBlocks,\\n        uint32 newObjectionPeriodDurationInBlocks\\n    );\\n\\n    /// @notice An event emitted when the objection period last minute window is set\\n    event LastMinuteWindowSet(uint32 oldLastMinuteWindowInBlocks, uint32 newLastMinuteWindowInBlocks);\\n\\n    /// @notice An event emitted when the proposal updatable period is set\\n    event ProposalUpdatablePeriodSet(\\n        uint32 oldProposalUpdatablePeriodInBlocks,\\n        uint32 newProposalUpdatablePeriodInBlocks\\n    );\\n\\n    /// @notice Emitted when the proposal id at which vote snapshot block changes is set\\n    event VoteSnapshotBlockSwitchProposalIdSet(\\n        uint256 oldVoteSnapshotBlockSwitchProposalId,\\n        uint256 newVoteSnapshotBlockSwitchProposalId\\n    );\\n\\n    /// @notice Emitted when the erc20 tokens to include in a fork are set\\n    event ERC20TokensToIncludeInForkSet(address[] oldErc20Tokens, address[] newErc20tokens);\\n\\n    /// @notice Emitted when the fork DAO deployer is set\\n    event ForkDAODeployerSet(address oldForkDAODeployer, address newForkDAODeployer);\\n\\n    /// @notice Emitted when the during of the forking period is set\\n    event ForkPeriodSet(uint256 oldForkPeriod, uint256 newForkPeriod);\\n\\n    /// @notice Emitted when the threhsold for forking is set\\n    event ForkThresholdSet(uint256 oldForkThreshold, uint256 newForkThreshold);\\n\\n    /// @notice Emitted when the main timelock, timelockV1 and admin are set\\n    event TimelocksAndAdminSet(address timelock, address timelockV1, address admin);\\n\\n    /// @notice Emitted when someones adds nouns to the fork escrow\\n    event EscrowedToFork(\\n        uint32 indexed forkId,\\n        address indexed owner,\\n        uint256[] tokenIds,\\n        uint256[] proposalIds,\\n        string reason\\n    );\\n\\n    /// @notice Emitted when the owner withdraws their nouns from the fork escrow\\n    event WithdrawFromForkEscrow(uint32 indexed forkId, address indexed owner, uint256[] tokenIds);\\n\\n    /// @notice Emitted when the fork is executed and the forking period begins\\n    event ExecuteFork(\\n        uint32 indexed forkId,\\n        address forkTreasury,\\n        address forkToken,\\n        uint256 forkEndTimestamp,\\n        uint256 tokensInEscrow\\n    );\\n\\n    /// @notice Emitted when someone joins a fork during the forking period\\n    event JoinFork(\\n        uint32 indexed forkId,\\n        address indexed owner,\\n        uint256[] tokenIds,\\n        uint256[] proposalIds,\\n        string reason\\n    );\\n\\n    /// @notice Emitted when the DAO withdraws nouns from the fork escrow after a fork has been executed\\n    event DAOWithdrawNounsFromEscrow(uint256[] tokenIds, address to);\\n\\n    /// @notice Emitted when withdrawing nouns from escrow increases adjusted total supply\\n    event DAONounsSupplyIncreasedFromEscrow(uint256 numTokens, address to);\\n}\\n\\ncontract NounsDAOProxyStorage {\\n    /// @notice Administrator for this contract\\n    address public admin;\\n\\n    /// @notice Pending administrator for this contract\\n    address public pendingAdmin;\\n\\n    /// @notice Active brains of Governor\\n    address public implementation;\\n}\\n\\n/**\\n * @title Storage for Governor Bravo Delegate\\n * @notice For future upgrades, do not change NounsDAOStorageV1. Create a new\\n * contract which implements NounsDAOStorageV1 and following the naming convention\\n * NounsDAOStorageVX.\\n */\\ncontract NounsDAOStorageV1 is NounsDAOProxyStorage {\\n    /// @notice Vetoer who has the ability to veto any proposal\\n    address public vetoer;\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint256 public votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint256 public votingPeriod;\\n\\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\\n    uint256 public proposalThresholdBPS;\\n\\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\\n    uint256 public quorumVotesBPS;\\n\\n    /// @notice The total number of proposals\\n    uint256 public proposalCount;\\n\\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\\n    INounsDAOExecutor public timelock;\\n\\n    /// @notice The address of the Nouns tokens\\n    NounsTokenLike public nouns;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping(uint256 => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping(address => uint256) public latestProposalIds;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(address => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed,\\n        Vetoed\\n    }\\n}\\n\\n/**\\n * @title Extra fields added to the `Proposal` struct from NounsDAOStorageV1\\n * @notice The following fields were added to the `Proposal` struct:\\n * - `Proposal.totalSupply`\\n * - `Proposal.creationBlock`\\n */\\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\\n    /// @notice Vetoer who has the ability to veto any proposal\\n    address public vetoer;\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint256 public votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint256 public votingPeriod;\\n\\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\\n    uint256 public proposalThresholdBPS;\\n\\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\\n    uint256 public quorumVotesBPS;\\n\\n    /// @notice The total number of proposals\\n    uint256 public proposalCount;\\n\\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\\n    INounsDAOExecutor public timelock;\\n\\n    /// @notice The address of the Nouns tokens\\n    NounsTokenLike public nouns;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping(uint256 => Proposal) internal _proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping(address => uint256) public latestProposalIds;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(address => Receipt) receipts;\\n        /// @notice The total supply at the time of proposal creation\\n        uint256 totalSupply;\\n        /// @notice The block at which this proposal was created\\n        uint256 creationBlock;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed,\\n        Vetoed\\n    }\\n}\\n\\n/**\\n * @title Storage for Governor Bravo Delegate\\n * @notice For future upgrades, do not change NounsDAOStorageV2. Create a new\\n * contract which implements NounsDAOStorageV2 and following the naming convention\\n * NounsDAOStorageVX.\\n */\\ncontract NounsDAOStorageV2 is NounsDAOStorageV1Adjusted {\\n    DynamicQuorumParamsCheckpoint[] public quorumParamsCheckpoints;\\n\\n    /// @notice Pending new vetoer\\n    address public pendingVetoer;\\n\\n    struct DynamicQuorumParams {\\n        /// @notice The minimum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\\n        uint16 minQuorumVotesBPS;\\n        /// @notice The maximum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\\n        uint16 maxQuorumVotesBPS;\\n        /// @notice The dynamic quorum coefficient\\n        /// @dev Assumed to be fixed point integer with 6 decimals, i.e 0.2 is represented as 0.2 * 1e6 = 200000\\n        uint32 quorumCoefficient;\\n    }\\n\\n    /// @notice A checkpoint for storing dynamic quorum params from a given block\\n    struct DynamicQuorumParamsCheckpoint {\\n        /// @notice The block at which the new values were set\\n        uint32 fromBlock;\\n        /// @notice The parameter values of this checkpoint\\n        DynamicQuorumParams params;\\n    }\\n\\n    struct ProposalCondensed {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice The total supply at the time of proposal creation\\n        uint256 totalSupply;\\n        /// @notice The block at which this proposal was created\\n        uint256 creationBlock;\\n    }\\n}\\n\\ninterface INounsDAOExecutor {\\n    function delay() external view returns (uint256);\\n\\n    function GRACE_PERIOD() external view returns (uint256);\\n\\n    function acceptAdmin() external;\\n\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n\\n    function queueTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external returns (bytes32);\\n\\n    function cancelTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external;\\n\\n    function executeTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external payable returns (bytes memory);\\n}\\n\\ninterface NounsTokenLike {\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function minter() external view returns (address);\\n\\n    function mint() external returns (uint256);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n}\\n\\ninterface IForkDAODeployer {\\n    function deployForkDAO(uint256 forkingPeriodEndTimestamp, INounsDAOForkEscrow forkEscrowAddress)\\n        external\\n        returns (address treasury, address token);\\n\\n    function tokenImpl() external view returns (address);\\n\\n    function auctionImpl() external view returns (address);\\n\\n    function governorImpl() external view returns (address);\\n\\n    function treasuryImpl() external view returns (address);\\n}\\n\\ninterface INounsDAOExecutorV2 is INounsDAOExecutor {\\n    function sendETH(address recipient, uint256 ethToSend) external;\\n\\n    function sendERC20(\\n        address recipient,\\n        address erc20Token,\\n        uint256 tokensToSend\\n    ) external;\\n}\\n\\ninterface INounsDAOForkEscrow {\\n    function markOwner(address owner, uint256[] calldata tokenIds) external;\\n\\n    function returnTokensToOwner(address owner, uint256[] calldata tokenIds) external;\\n\\n    function closeEscrow() external returns (uint32);\\n\\n    function numTokensInEscrow() external view returns (uint256);\\n\\n    function numTokensOwnedByDAO() external view returns (uint256);\\n\\n    function withdrawTokens(uint256[] calldata tokenIds, address to) external;\\n\\n    function forkId() external view returns (uint32);\\n\\n    function nounsToken() external view returns (NounsTokenLike);\\n\\n    function dao() external view returns (address);\\n\\n    function ownerOfEscrowedToken(uint32 forkId_, uint256 tokenId) external view returns (address);\\n}\\n\\ncontract NounsDAOStorageV3 {\\n    StorageV3 ds;\\n\\n    struct StorageV3 {\\n        // ================ PROXY ================ //\\n        /// @notice Administrator for this contract\\n        address admin;\\n        /// @notice Pending administrator for this contract\\n        address pendingAdmin;\\n        /// @notice Active brains of Governor\\n        address implementation;\\n        // ================ V1 ================ //\\n        /// @notice Vetoer who has the ability to veto any proposal\\n        address vetoer;\\n        /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n        uint256 votingDelay;\\n        /// @notice The duration of voting on a proposal, in blocks\\n        uint256 votingPeriod;\\n        /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\\n        uint256 proposalThresholdBPS;\\n        /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\\n        uint256 quorumVotesBPS;\\n        /// @notice The total number of proposals\\n        uint256 proposalCount;\\n        /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\\n        INounsDAOExecutorV2 timelock;\\n        /// @notice The address of the Nouns tokens\\n        NounsTokenLike nouns;\\n        /// @notice The official record of all proposals ever proposed\\n        mapping(uint256 => Proposal) _proposals;\\n        /// @notice The latest proposal for each proposer\\n        mapping(address => uint256) latestProposalIds;\\n        // ================ V2 ================ //\\n        DynamicQuorumParamsCheckpoint[] quorumParamsCheckpoints;\\n        /// @notice Pending new vetoer\\n        address pendingVetoer;\\n        // ================ V3 ================ //\\n        /// @notice user => sig => isCancelled: signatures that have been cancelled by the signer and are no longer valid\\n        mapping(address => mapping(bytes32 => bool)) cancelledSigs;\\n        /// @notice The number of blocks before voting ends during which the objection period can be initiated\\n        uint32 lastMinuteWindowInBlocks;\\n        /// @notice Length of the objection period in blocks\\n        uint32 objectionPeriodDurationInBlocks;\\n        /// @notice Length of proposal updatable period in block\\n        uint32 proposalUpdatablePeriodInBlocks;\\n        /// @notice address of the DAO's fork escrow contract\\n        INounsDAOForkEscrow forkEscrow;\\n        /// @notice address of the DAO's fork deployer contract\\n        IForkDAODeployer forkDAODeployer;\\n        /// @notice ERC20 tokens to include when sending funds to a deployed fork\\n        address[] erc20TokensToIncludeInFork;\\n        /// @notice The treasury contract of the last deployed fork\\n        address forkDAOTreasury;\\n        /// @notice The token contract of the last deployed fork\\n        address forkDAOToken;\\n        /// @notice Timestamp at which the last fork period ends\\n        uint256 forkEndTimestamp;\\n        /// @notice Fork period in seconds\\n        uint256 forkPeriod;\\n        /// @notice Threshold defined in basis points (10,000 = 100%) required for forking\\n        uint256 forkThresholdBPS;\\n        /// @notice Address of the original timelock\\n        INounsDAOExecutor timelockV1;\\n        /// @notice The proposal at which to start using `startBlock` instead of `creationBlock` for vote snapshots\\n        /// @dev Make sure this stays the last variable in this struct, so we can delete it in the next version\\n        /// @dev To be zeroed-out and removed in a V3.1 fix version once the switch takes place\\n        uint256 voteSnapshotBlockSwitchProposalId;\\n    }\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(address => Receipt) receipts;\\n        /// @notice The total supply at the time of proposal creation\\n        uint256 totalSupply;\\n        /// @notice The block at which this proposal was created\\n        uint64 creationBlock;\\n        /// @notice The last block which allows updating a proposal's description and transactions\\n        uint64 updatePeriodEndBlock;\\n        /// @notice Starts at 0 and is set to the block at which the objection period ends when the objection period is initiated\\n        uint64 objectionPeriodEndBlock;\\n        /// @dev unused for now\\n        uint64 placeholder;\\n        /// @notice The signers of a proposal, when using proposeBySigs\\n        address[] signers;\\n        /// @notice When true, a proposal would be executed on timelockV1 instead of the current timelock\\n        bool executeOnTimelockV1;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    struct ProposerSignature {\\n        /// @notice Signature of a proposal\\n        bytes sig;\\n        /// @notice The address of the signer\\n        address signer;\\n        /// @notice The timestamp until which the signature is valid\\n        uint256 expirationTimestamp;\\n    }\\n\\n    struct ProposalCondensed {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice The total supply at the time of proposal creation\\n        uint256 totalSupply;\\n        /// @notice The block at which this proposal was created\\n        uint256 creationBlock;\\n        /// @notice The signers of a proposal, when using proposeBySigs\\n        address[] signers;\\n        /// @notice The last block which allows updating a proposal's description and transactions\\n        uint256 updatePeriodEndBlock;\\n        /// @notice Starts at 0 and is set to the block at which the objection period ends when the objection period is initiated\\n        uint256 objectionPeriodEndBlock;\\n        /// @notice When true, a proposal would be executed on timelockV1 instead of the current timelock\\n        bool executeOnTimelockV1;\\n    }\\n\\n    struct DynamicQuorumParams {\\n        /// @notice The minimum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\\n        uint16 minQuorumVotesBPS;\\n        /// @notice The maximum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\\n        uint16 maxQuorumVotesBPS;\\n        /// @notice The dynamic quorum coefficient\\n        /// @dev Assumed to be fixed point integer with 6 decimals, i.e 0.2 is represented as 0.2 * 1e6 = 200000\\n        uint32 quorumCoefficient;\\n    }\\n\\n    struct NounsDAOParams {\\n        uint256 votingPeriod;\\n        uint256 votingDelay;\\n        uint256 proposalThresholdBPS;\\n        uint32 lastMinuteWindowInBlocks;\\n        uint32 objectionPeriodDurationInBlocks;\\n        uint32 proposalUpdatablePeriodInBlocks;\\n    }\\n\\n    /// @notice A checkpoint for storing dynamic quorum params from a given block\\n    struct DynamicQuorumParamsCheckpoint {\\n        /// @notice The block at which the new values were set\\n        uint32 fromBlock;\\n        /// @notice The parameter values of this checkpoint\\n        DynamicQuorumParams params;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed,\\n        Vetoed,\\n        ObjectionPeriod,\\n        Updatable\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/fork/NounsDAOV3Fork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Library for NounsDAOLogicV3 contract containing the dao fork logic\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.19;\\n\\nimport { NounsDAOStorageV3, INounsDAOForkEscrow, INounsDAOExecutorV2 } from '../NounsDAOInterfaces.sol';\\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport { NounsTokenFork } from './newdao/token/NounsTokenFork.sol';\\n\\nlibrary NounsDAOV3Fork {\\n    error ForkThresholdNotMet();\\n    error ForkPeriodNotActive();\\n    error ForkPeriodActive();\\n    error AdminOnly();\\n    error UseAlternativeWithdrawFunction();\\n\\n    /// @notice Emitted when someones adds nouns to the fork escrow\\n    event EscrowedToFork(\\n        uint32 indexed forkId,\\n        address indexed owner,\\n        uint256[] tokenIds,\\n        uint256[] proposalIds,\\n        string reason\\n    );\\n\\n    /// @notice Emitted when the owner withdraws their nouns from the fork escrow\\n    event WithdrawFromForkEscrow(uint32 indexed forkId, address indexed owner, uint256[] tokenIds);\\n\\n    /// @notice Emitted when the fork is executed and the forking period begins\\n    event ExecuteFork(\\n        uint32 indexed forkId,\\n        address forkTreasury,\\n        address forkToken,\\n        uint256 forkEndTimestamp,\\n        uint256 tokensInEscrow\\n    );\\n\\n    /// @notice Emitted when someone joins a fork during the forking period\\n    event JoinFork(\\n        uint32 indexed forkId,\\n        address indexed owner,\\n        uint256[] tokenIds,\\n        uint256[] proposalIds,\\n        string reason\\n    );\\n\\n    /// @notice Emitted when the DAO withdraws nouns from the fork escrow after a fork has been executed\\n    event DAOWithdrawNounsFromEscrow(uint256[] tokenIds, address to);\\n\\n    /// @notice Emitted when withdrawing nouns from escrow increases adjusted total supply\\n    event DAONounsSupplyIncreasedFromEscrow(uint256 numTokens, address to);\\n\\n    /**\\n     * @notice Escrow Nouns to contribute to the fork threshold\\n     * @dev Requires approving the tokenIds or the entire noun token to the DAO contract\\n     * @param tokenIds the tokenIds to escrow. They will be sent to the DAO once the fork threshold is reached and the escrow is closed.\\n     * @param proposalIds array of proposal ids which are the reason for wanting to fork. This will only be used to emit event.\\n     * @param reason the reason for want to fork. This will only be used to emit event.\\n     */\\n    function escrowToFork(\\n        NounsDAOStorageV3.StorageV3 storage ds,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata proposalIds,\\n        string calldata reason\\n    ) external {\\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ds.nouns.safeTransferFrom(msg.sender, address(forkEscrow), tokenIds[i]);\\n        }\\n\\n        emit EscrowedToFork(forkEscrow.forkId(), msg.sender, tokenIds, proposalIds, reason);\\n    }\\n\\n    /**\\n     * @notice Withdraw Nouns from the fork escrow. Only possible if the fork has not been executed.\\n     * Only allowed to withdraw tokens that the sender has escrowed.\\n     * @param tokenIds the tokenIds to withdraw\\n     */\\n    function withdrawFromForkEscrow(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds) external {\\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\\n\\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\\n        forkEscrow.returnTokensToOwner(msg.sender, tokenIds);\\n\\n        emit WithdrawFromForkEscrow(forkEscrow.forkId(), msg.sender, tokenIds);\\n    }\\n\\n    /**\\n     * @notice Execute the fork. Only possible if the fork threshold has been exceeded.\\n     * This will deploy a new DAO and send the prorated part of the treasury to the new DAO's treasury.\\n     * This will also close the active escrow and all nouns in the escrow will belong to the original DAO.\\n     * @return forkTreasury The address of the new DAO's treasury\\n     * @return forkToken The address of the new DAO's token\\n     */\\n    function executeFork(NounsDAOStorageV3.StorageV3 storage ds)\\n        external\\n        returns (address forkTreasury, address forkToken)\\n    {\\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\\n\\n        uint256 tokensInEscrow = forkEscrow.numTokensInEscrow();\\n        if (tokensInEscrow <= forkThreshold(ds)) revert ForkThresholdNotMet();\\n\\n        uint256 forkEndTimestamp = block.timestamp + ds.forkPeriod;\\n\\n        (forkTreasury, forkToken) = ds.forkDAODeployer.deployForkDAO(forkEndTimestamp, forkEscrow);\\n        sendProRataTreasury(ds, forkTreasury, tokensInEscrow, adjustedTotalSupply(ds));\\n        uint32 forkId = forkEscrow.closeEscrow();\\n\\n        ds.forkDAOTreasury = forkTreasury;\\n        ds.forkDAOToken = forkToken;\\n        ds.forkEndTimestamp = forkEndTimestamp;\\n\\n        emit ExecuteFork(forkId, forkTreasury, forkToken, forkEndTimestamp, tokensInEscrow);\\n    }\\n\\n    /**\\n     * @notice Joins a fork while a fork is active\\n     * Sends the tokens to the timelock contract.\\n     * Sends a prorated part of the treasury to the new fork DAO's treasury.\\n     * Mints new tokens in the new fork DAO with the same token ids.\\n     * @param tokenIds the tokenIds to send to the DAO in exchange for joining the fork\\n     */\\n    function joinFork(\\n        NounsDAOStorageV3.StorageV3 storage ds,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata proposalIds,\\n        string calldata reason\\n    ) external {\\n        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\\n\\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\\n        address timelock = address(ds.timelock);\\n        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\\n        }\\n\\n        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\\n\\n        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\\n    }\\n\\n    /**\\n     * @notice Withdraws nouns from the fork escrow to the treasury after the fork has been executed\\n     * @dev Only the DAO can call this function\\n     * @param tokenIds the tokenIds to withdraw\\n     */\\n    function withdrawDAONounsFromEscrowToTreasury(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds)\\n        external\\n    {\\n        withdrawDAONounsFromEscrow(ds, tokenIds, address(ds.timelock));\\n    }\\n\\n    /**\\n     * @notice Withdraws nouns from the fork escrow after the fork has been executed to an address other than the treasury\\n     * @dev Only the DAO can call this function\\n     * @param tokenIds the tokenIds to withdraw\\n     * @param to the address to send the nouns to\\n     */\\n    function withdrawDAONounsFromEscrowIncreasingTotalSupply(\\n        NounsDAOStorageV3.StorageV3 storage ds,\\n        uint256[] calldata tokenIds,\\n        address to\\n    ) external {\\n        if (to == address(ds.timelock)) revert UseAlternativeWithdrawFunction();\\n\\n        withdrawDAONounsFromEscrow(ds, tokenIds, to);\\n\\n        emit DAONounsSupplyIncreasedFromEscrow(tokenIds.length, to);\\n    }\\n\\n    function withdrawDAONounsFromEscrow(\\n        NounsDAOStorageV3.StorageV3 storage ds,\\n        uint256[] calldata tokenIds,\\n        address to\\n    ) private {\\n        if (msg.sender != ds.admin) {\\n            revert AdminOnly();\\n        }\\n\\n        ds.forkEscrow.withdrawTokens(tokenIds, to);\\n\\n        emit DAOWithdrawNounsFromEscrow(tokenIds, to);\\n    }\\n\\n    /**\\n     * @notice Returns the required number of tokens to escrow to trigger a fork\\n     */\\n    function forkThreshold(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\\n        return (adjustedTotalSupply(ds) * ds.forkThresholdBPS) / 10_000;\\n    }\\n\\n    /**\\n     * @notice Returns the number of tokens currently in escrow, contributing to the fork threshold\\n     */\\n    function numTokensInForkEscrow(NounsDAOStorageV3.StorageV3 storage ds) public view returns (uint256) {\\n        return ds.forkEscrow.numTokensInEscrow();\\n    }\\n\\n    /**\\n     * @notice Returns the number of nouns in supply minus nouns owned by the DAO, i.e. held in the treasury or in an\\n     * escrow after it has closed.\\n     * This is used when calculating proposal threshold, quorum, fork threshold & treasury split.\\n     */\\n    function adjustedTotalSupply(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (uint256) {\\n        return ds.nouns.totalSupply() - ds.nouns.balanceOf(address(ds.timelock)) - ds.forkEscrow.numTokensOwnedByDAO();\\n    }\\n\\n    /**\\n     * @notice Returns true if noun holders can currently join a fork\\n     */\\n    function isForkPeriodActive(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (bool) {\\n        return ds.forkEndTimestamp > block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Sends part of the DAO's treasury to the `newDAOTreasury` address.\\n     * The amount sent is proportional to the `tokenCount` out of `totalSupply`.\\n     * Sends ETH and ERC20 tokens listed in `ds.erc20TokensToIncludeInFork`.\\n     */\\n    function sendProRataTreasury(\\n        NounsDAOStorageV3.StorageV3 storage ds,\\n        address newDAOTreasury,\\n        uint256 tokenCount,\\n        uint256 totalSupply\\n    ) internal {\\n        INounsDAOExecutorV2 timelock = ds.timelock;\\n        uint256 ethToSend = (address(timelock).balance * tokenCount) / totalSupply;\\n\\n        timelock.sendETH(newDAOTreasury, ethToSend);\\n\\n        uint256 erc20Count = ds.erc20TokensToIncludeInFork.length;\\n        for (uint256 i = 0; i < erc20Count; ++i) {\\n            IERC20 erc20token = IERC20(ds.erc20TokensToIncludeInFork[i]);\\n            uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenCount) / totalSupply;\\n            if (tokensToSend > 0) {\\n                timelock.sendERC20(newDAOTreasury, address(erc20token), tokensToSend);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/fork/newdao/token/NounsTokenFork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The Nouns ERC-721 token, adjusted for forks\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.19;\\n\\nimport { OwnableUpgradeable } from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\nimport { ERC721CheckpointableUpgradeable } from './base/ERC721CheckpointableUpgradeable.sol';\\nimport { INounsDescriptorMinimal } from '../../../../interfaces/INounsDescriptorMinimal.sol';\\nimport { INounsSeeder } from '../../../../interfaces/INounsSeeder.sol';\\nimport { INounsTokenFork } from './INounsTokenFork.sol';\\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\\nimport { INounsDAOForkEscrow } from '../../../NounsDAOInterfaces.sol';\\n\\n/**\\n * @dev This contract is a fork of NounsToken, with the following changes:\\n * - Added upgradeablity via UUPSUpgradeable.\\n * - Inheriting from an unmodified ERC721, so that the double Transfer event emission that\\n *   NounsToken performs is gone, in favor of the standard single event.\\n * - Added functions to claim tokens from a Nouns Fork escrow, or during the forking period.\\n * - Removed the proxyRegistry feature that whitelisted OpenSea.\\n * - Removed `noundersDAO` and the founder reward every 10 mints.\\n * For additional context see `ERC721CheckpointableUpgradeable`.\\n */\\ncontract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721CheckpointableUpgradeable, UUPSUpgradeable {\\n    error OnlyOwner();\\n    error OnlyTokenOwnerCanClaim();\\n    error OnlyOriginalDAO();\\n    error NoundersCannotBeAddressZero();\\n    error OnlyDuringForkingPeriod();\\n\\n    string public constant NAME = 'NounsTokenFork';\\n\\n    /// @notice  An address who has permissions to mint Nouns\\n    address public minter;\\n\\n    /// @notice The Nouns token URI descriptor\\n    INounsDescriptorMinimal public descriptor;\\n\\n    /// @notice The Nouns token seeder\\n    INounsSeeder public seeder;\\n\\n    /// @notice The escrow contract used to verify ownership of the original Nouns in the post-fork claiming process\\n    INounsDAOForkEscrow public escrow;\\n\\n    /// @notice The fork ID, used when querying the escrow for token ownership\\n    uint32 public forkId;\\n\\n    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\\n    uint256 public remainingTokensToClaim;\\n\\n    /// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\\n    uint256 public forkingPeriodEndTimestamp;\\n\\n    /// @notice Whether the minter can be updated\\n    bool public isMinterLocked;\\n\\n    /// @notice Whether the descriptor can be updated\\n    bool public isDescriptorLocked;\\n\\n    /// @notice Whether the seeder can be updated\\n    bool public isSeederLocked;\\n\\n    /// @notice The noun seeds\\n    mapping(uint256 => INounsSeeder.Seed) public seeds;\\n\\n    /// @notice The internal noun ID tracker\\n    uint256 private _currentNounId;\\n\\n    /// @notice IPFS content hash of contract-level metadata\\n    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\\n\\n    /**\\n     * @notice Require that the minter has not been locked.\\n     */\\n    modifier whenMinterNotLocked() {\\n        require(!isMinterLocked, 'Minter is locked');\\n        _;\\n    }\\n\\n    /**\\n     * @notice Require that the descriptor has not been locked.\\n     */\\n    modifier whenDescriptorNotLocked() {\\n        require(!isDescriptorLocked, 'Descriptor is locked');\\n        _;\\n    }\\n\\n    /**\\n     * @notice Require that the seeder has not been locked.\\n     */\\n    modifier whenSeederNotLocked() {\\n        require(!isSeederLocked, 'Seeder is locked');\\n        _;\\n    }\\n\\n    /**\\n     * @notice Require that the sender is the minter.\\n     */\\n    modifier onlyMinter() {\\n        require(msg.sender == minter, 'Sender is not the minter');\\n        _;\\n    }\\n\\n    constructor() initializer {}\\n\\n    function initialize(\\n        address _owner,\\n        address _minter,\\n        INounsDAOForkEscrow _escrow,\\n        uint32 _forkId,\\n        uint256 startNounId,\\n        uint256 tokensToClaim,\\n        uint256 _forkingPeriodEndTimestamp\\n    ) external initializer {\\n        __ERC721_init('Nouns', 'NOUN');\\n        _transferOwnership(_owner);\\n        minter = _minter;\\n        escrow = _escrow;\\n        forkId = _forkId;\\n        _currentNounId = startNounId;\\n        remainingTokensToClaim = tokensToClaim;\\n        forkingPeriodEndTimestamp = _forkingPeriodEndTimestamp;\\n\\n        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\\n        descriptor = originalToken.descriptor();\\n        seeder = originalToken.seeder();\\n    }\\n\\n    /**\\n     * @notice Claim new tokens if you escrowed original Nouns and forked into a new DAO governed by holders of this\\n     * token.\\n     * @dev Reverts if the sender is not the owner of the escrowed token.\\n     * @param tokenIds The token IDs to claim\\n     */\\n    function claimFromEscrow(uint256[] calldata tokenIds) external {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 nounId = tokenIds[i];\\n            if (escrow.ownerOfEscrowedToken(forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\\n\\n            _mintWithOriginalSeed(msg.sender, nounId);\\n        }\\n\\n        remainingTokensToClaim -= tokenIds.length;\\n    }\\n\\n    /**\\n     * @notice The original DAO can claim tokens during the forking period, on behalf of Nouners who choose to join\\n     * a new fork DAO. Does not allow the original DAO to claim once the forking period has ended.\\n     * @dev Assumes the original DAO is honest during the forking period.\\n     * @param to The recipient of the tokens\\n     * @param tokenIds The token IDs to claim\\n     */\\n    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\\n        uint256 currentNounId = _currentNounId;\\n        uint256 maxNounId = 0;\\n        if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\\n        if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 nounId = tokenIds[i];\\n            _mintWithOriginalSeed(to, nounId);\\n\\n            if (tokenIds[i] > maxNounId) maxNounId = tokenIds[i];\\n        }\\n\\n        // This treats an important case:\\n        // During a forking period, people can buy new Nouns on auction, with a higher ID than the auction ID at forking\\n        // They can then join the fork with those IDs\\n        // If we don't increment currentNounId, unpausing the fork auction house would revert\\n        // Since it would attempt to mint a noun with an ID that already exists\\n        if (maxNounId >= currentNounId) _currentNounId = maxNounId + 1;\\n    }\\n\\n    /**\\n     * @notice The IPFS URI of contract-level metadata.\\n     */\\n    function contractURI() public view returns (string memory) {\\n        return string(abi.encodePacked('ipfs://', _contractURIHash));\\n    }\\n\\n    /**\\n     * @notice Set the _contractURIHash.\\n     * @dev Only callable by the owner.\\n     */\\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\\n        _contractURIHash = newContractURIHash;\\n    }\\n\\n    /**\\n     * @notice Mint a Noun to the minter\\n     * @dev Call _mintTo with the to address(es).\\n     */\\n    function mint() public override onlyMinter returns (uint256) {\\n        return _mintTo(minter, _currentNounId++);\\n    }\\n\\n    /**\\n     * @notice Burn a noun.\\n     */\\n    function burn(uint256 nounId) public override onlyMinter {\\n        _burn(nounId);\\n        emit NounBurned(nounId);\\n    }\\n\\n    /**\\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\\n        return descriptor.tokenURI(tokenId, seeds[tokenId]);\\n    }\\n\\n    /**\\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\\n     * with the JSON contents directly inlined.\\n     */\\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), 'NounsToken: URI query for nonexistent token');\\n        return descriptor.dataURI(tokenId, seeds[tokenId]);\\n    }\\n\\n    /**\\n     * @notice Set the token minter.\\n     * @dev Only callable by the owner when not locked.\\n     */\\n    function setMinter(address _minter) external override onlyOwner whenMinterNotLocked {\\n        minter = _minter;\\n\\n        emit MinterUpdated(_minter);\\n    }\\n\\n    /**\\n     * @notice Lock the minter.\\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\\n     */\\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\\n        isMinterLocked = true;\\n\\n        emit MinterLocked();\\n    }\\n\\n    /**\\n     * @notice Set the token URI descriptor.\\n     * @dev Only callable by the owner when not locked.\\n     */\\n    function setDescriptor(INounsDescriptorMinimal _descriptor) external override onlyOwner whenDescriptorNotLocked {\\n        descriptor = _descriptor;\\n\\n        emit DescriptorUpdated(_descriptor);\\n    }\\n\\n    /**\\n     * @notice Lock the descriptor.\\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\\n     */\\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\\n        isDescriptorLocked = true;\\n\\n        emit DescriptorLocked();\\n    }\\n\\n    /**\\n     * @notice Set the token seeder.\\n     * @dev Only callable by the owner when not locked.\\n     */\\n    function setSeeder(INounsSeeder _seeder) external override onlyOwner whenSeederNotLocked {\\n        seeder = _seeder;\\n\\n        emit SeederUpdated(_seeder);\\n    }\\n\\n    /**\\n     * @notice Lock the seeder.\\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\\n     */\\n    function lockSeeder() external override onlyOwner whenSeederNotLocked {\\n        isSeederLocked = true;\\n\\n        emit SeederLocked();\\n    }\\n\\n    /**\\n     * @notice Mint a Noun with `nounId` to the provided `to` address.\\n     */\\n    function _mintTo(address to, uint256 nounId) internal returns (uint256) {\\n        INounsSeeder.Seed memory seed = seeds[nounId] = seeder.generateSeed(nounId, descriptor);\\n\\n        _mint(to, nounId);\\n        emit NounCreated(nounId, seed);\\n\\n        return nounId;\\n    }\\n\\n    /**\\n     * @notice Mint a new token using the original Nouns seed.\\n     */\\n    function _mintWithOriginalSeed(address to, uint256 nounId) internal {\\n        (uint48 background, uint48 body, uint48 accessory, uint48 head, uint48 glasses) = NounsTokenFork(\\n            address(escrow.nounsToken())\\n        ).seeds(nounId);\\n        INounsSeeder.Seed memory seed = INounsSeeder.Seed(background, body, accessory, head, glasses);\\n\\n        seeds[nounId] = seed;\\n        _mint(to, nounId);\\n\\n        emit NounCreated(nounId, seed);\\n    }\\n\\n    /**\\n     * @dev Reverts when `msg.sender` is not the owner of this contract; in the case of Noun DAOs it should be the\\n     * DAO's treasury contract.\\n     */\\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\n/// @title Vote checkpointing for an ERC-721 token\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\n// LICENSE\\n// ERC721CheckpointableUpgradeable.sol is a modified version of ERC721Checkpointable.sol in this repository.\\n// ERC721Checkpointable.sol uses and modifies part of Compound Lab's Comp.sol:\\n// https://github.com/compound-finance/compound-protocol/blob/ae4388e780a8d596d97619d9704a931a2752c2bc/contracts/Governance/Comp.sol\\n//\\n// Comp.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\\n// With modifications by Nounders DAO.\\n//\\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\\n//\\n// ERC721CheckpointableUpgradeable.sol MODIFICATIONS:\\n// - Inherits from OpenZeppelin's ERC721EnumerableUpgradeable.sol, removing the original modification Nouns made to\\n//   ERC721.sol, where for each mint two Transfer events were emitted; this modified implementation sticks with the\\n//   OpenZeppelin standard.\\n// - More importantly, this inheritance change makes the token upgradable, which we deemed important in the context of\\n//   forks, in order to give new Nouns forks enough of a chance to modify their contracts to the new DAO's needs.\\n// - Fixes a critical bug in `delegateBySig`, where the previous version allowed delegating to address zero, which then\\n//   reverts whenever that owner tries to delegate anew or transfer their tokens. The fix is simply to revert on any\\n//   attempt to delegate to address zero.\\n//\\n// ERC721Checkpointable.sol MODIFICATIONS:\\n// Checkpointing logic from Comp.sol has been used with the following modifications:\\n// - `delegates` is renamed to `_delegates` and is set to private\\n// - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\\n//   Comp.sol, returns the delegator's own address if there is no delegate.\\n//   This avoids the delegator needing to \\\"delegate to self\\\" with an additional transaction\\n// - `_transferTokens()` is renamed `_beforeTokenTransfer()` and adapted to hook into OpenZeppelin's ERC721 hooks.\\n\\npragma solidity ^0.8.19;\\n\\nimport { ERC721EnumerableUpgradeable } from '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\\n\\nabstract contract ERC721CheckpointableUpgradeable is ERC721EnumerableUpgradeable {\\n    /// @notice Defines decimals as per ERC-20 convention to make integrations with 3rd party governance platforms easier\\n    uint8 public constant decimals = 0;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping(address => address) private _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping(address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping(address => uint256) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n    /**\\n     * @notice The votes a delegator can delegate, which is the current balance of the delegator.\\n     * @dev Used when calling `_delegate()`\\n     */\\n    function votesToDelegate(address delegator) public view returns (uint96) {\\n        return safe96(balanceOf(delegator), 'ERC721Checkpointable::votesToDelegate: amount exceeds 96 bits');\\n    }\\n\\n    /**\\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\\n     * the delegator's own address if they haven't delegated.\\n     * This avoids having to delegate to oneself.\\n     */\\n    function delegates(address delegator) public view returns (address) {\\n        address current = _delegates[delegator];\\n        return current == address(0) ? delegator : current;\\n    }\\n\\n    /**\\n     * @notice Adapted from `_transferTokens()` in `Comp.sol` to update delegate votes.\\n     * @dev hooks into OpenZeppelin's `ERC721._transfer`\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation\\n        _moveDelegates(delegates(from), delegates(to), 1);\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) public {\\n        if (delegatee == address(0)) delegatee = msg.sender;\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public {\\n        require(delegatee != address(0), 'ERC721Checkpointable::delegateBySig: delegatee cannot be zero address');\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), block.chainid, address(this))\\n        );\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked('\\\\x19\\\\x01', domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');\\n        require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');\\n        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, 'ERC721Checkpointable::getPriorVotes: not yet determined');\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\\n        address currentDelegate = delegates(delegator);\\n\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        uint96 amount = votesToDelegate(delegator);\\n\\n        _moveDelegates(currentDelegate, delegatee, amount);\\n    }\\n\\n    function _moveDelegates(\\n        address srcRep,\\n        address dstRep,\\n        uint96 amount\\n    ) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows');\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount overflows');\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint96 oldVotes,\\n        uint96 newVotes\\n    ) internal {\\n        uint32 blockNumber = safe32(\\n            block.number,\\n            'ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits'\\n        );\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(\\n        uint96 a,\\n        uint96 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(\\n        uint96 a,\\n        uint96 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsDescriptorMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Common interface for NounsDescriptor versions, as used by NounsToken and NounsSeeder.\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsSeeder } from './INounsSeeder.sol';\\n\\ninterface INounsDescriptorMinimal {\\n    ///\\n    /// USED BY TOKEN\\n    ///\\n\\n    function tokenURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view returns (string memory);\\n\\n    function dataURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view returns (string memory);\\n\\n    ///\\n    /// USED BY SEEDER\\n    ///\\n\\n    function backgroundCount() external view returns (uint256);\\n\\n    function bodyCount() external view returns (uint256);\\n\\n    function accessoryCount() external view returns (uint256);\\n\\n    function headCount() external view returns (uint256);\\n\\n    function glassesCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsSeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsSeeder\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsDescriptorMinimal } from './INounsDescriptorMinimal.sol';\\n\\ninterface INounsSeeder {\\n    struct Seed {\\n        uint48 background;\\n        uint48 body;\\n        uint48 accessory;\\n        uint48 head;\\n        uint48 glasses;\\n    }\\n\\n    function generateSeed(uint256 nounId, INounsDescriptorMinimal descriptor) external view returns (Seed memory);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/fork/newdao/token/INounsTokenFork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsTokenFork\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.19;\\n\\nimport { IERC721Upgradeable } from '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\\nimport { INounsDescriptorMinimal } from '../../../../interfaces/INounsDescriptorMinimal.sol';\\nimport { INounsSeeder } from '../../../../interfaces/INounsSeeder.sol';\\n\\ninterface INounsTokenFork is IERC721Upgradeable {\\n    event NounCreated(uint256 indexed tokenId, INounsSeeder.Seed seed);\\n\\n    event NounBurned(uint256 indexed tokenId);\\n\\n    event MinterUpdated(address minter);\\n\\n    event MinterLocked();\\n\\n    event DescriptorUpdated(INounsDescriptorMinimal descriptor);\\n\\n    event DescriptorLocked();\\n\\n    event SeederUpdated(INounsSeeder seeder);\\n\\n    event SeederLocked();\\n\\n    function mint() external returns (uint256);\\n\\n    function burn(uint256 tokenId) external;\\n\\n    function dataURI(uint256 tokenId) external returns (string memory);\\n\\n    function setMinter(address minter) external;\\n\\n    function lockMinter() external;\\n\\n    function setDescriptor(INounsDescriptorMinimal descriptor) external;\\n\\n    function lockDescriptor() external;\\n\\n    function setSeeder(INounsSeeder seeder) external;\\n\\n    function lockSeeder() external;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721EnumerableUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\\n    function __ERC721Enumerable_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721Enumerable_init_unchained();\\n    }\\n\\n    function __ERC721Enumerable_init_unchained() internal initializer {\\n    }\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Upgradeable.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721Upgradeable.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n    uint256[46] private __gap;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n    uint256[44] private __gap;\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@ensdomains/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@ensdomains/\",\r\n      \"@nouns/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@nouns/\",\r\n      \"@openzeppelin/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/@openzeppelin/\",\r\n      \"base64-sol/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/base64-sol/\",\r\n      \"eth-gas-reporter/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/eth-gas-reporter/\",\r\n      \"hardhat/=/Users/elad/code/nounsDAO/nouns-monorepo/node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"UnsafeUint16Cast\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"minQuorumVotesBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxQuorumVotesBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"quorumCoefficient\",\"type\":\"uint32\"}],\"internalType\":\"struct NounsDAOStorageV3.DynamicQuorumParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"dynamicQuorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "NounsDAOV3DynamicQuorum", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}