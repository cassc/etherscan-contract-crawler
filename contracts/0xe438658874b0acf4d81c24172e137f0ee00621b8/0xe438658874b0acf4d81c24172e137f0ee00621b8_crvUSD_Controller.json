{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title crvUSD Controller\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n\"\"\"\r\n\r\ninterface LLAMMA:\r\n    def A() -> uint256: view\r\n    def get_p() -> uint256: view\r\n    def get_base_price() -> uint256: view\r\n    def active_band() -> int256: view\r\n    def active_band_with_skip() -> int256: view\r\n    def p_oracle_up(n: int256) -> uint256: view\r\n    def p_oracle_down(n: int256) -> uint256: view\r\n    def deposit_range(user: address, amount: uint256, n1: int256, n2: int256): nonpayable\r\n    def read_user_tick_numbers(_for: address) -> int256[2]: view\r\n    def get_sum_xy(user: address) -> uint256[2]: view\r\n    def withdraw(user: address, frac: uint256) -> uint256[2]: nonpayable\r\n    def get_x_down(user: address) -> uint256: view\r\n    def get_rate_mul() -> uint256: view\r\n    def set_rate(rate: uint256) -> uint256: nonpayable\r\n    def set_fee(fee: uint256): nonpayable\r\n    def set_admin_fee(fee: uint256): nonpayable\r\n    def price_oracle() -> uint256: view\r\n    def can_skip_bands(n_end: int256) -> bool: view\r\n    def admin_fees_x() -> uint256: view\r\n    def admin_fees_y() -> uint256: view\r\n    def reset_admin_fees(): nonpayable\r\n    def has_liquidity(user: address) -> bool: view\r\n    def bands_x(n: int256) -> uint256: view\r\n    def bands_y(n: int256) -> uint256: view\r\n    def set_callback(user: address): nonpayable\r\n\r\ninterface ERC20:\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def decimals() -> uint256: view\r\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\r\n    def balanceOf(_from: address) -> uint256: view\r\n\r\ninterface MonetaryPolicy:\r\n    def rate_write() -> uint256: nonpayable\r\n\r\ninterface Factory:\r\n    def stablecoin() -> address: view\r\n    def admin() -> address: view\r\n    def fee_receiver() -> address: view\r\n\r\n    # Only if lending vault\r\n    def borrowed_token() -> address: view\r\n    def collateral_token() -> address: view\r\n\r\ninterface PriceOracle:\r\n    def price() -> uint256: view\r\n    def price_w() -> uint256: nonpayable\r\n\r\n\r\nevent UserState:\r\n    user: indexed(address)\r\n    collateral: uint256\r\n    debt: uint256\r\n    n1: int256\r\n    n2: int256\r\n    liquidation_discount: uint256\r\n\r\nevent Borrow:\r\n    user: indexed(address)\r\n    collateral_increase: uint256\r\n    loan_increase: uint256\r\n\r\nevent Repay:\r\n    user: indexed(address)\r\n    collateral_decrease: uint256\r\n    loan_decrease: uint256\r\n\r\nevent RemoveCollateral:\r\n    user: indexed(address)\r\n    collateral_decrease: uint256\r\n\r\nevent Liquidate:\r\n    liquidator: indexed(address)\r\n    user: indexed(address)\r\n    collateral_received: uint256\r\n    stablecoin_received: uint256\r\n    debt: uint256\r\n\r\nevent SetMonetaryPolicy:\r\n    monetary_policy: address\r\n\r\nevent SetBorrowingDiscounts:\r\n    loan_discount: uint256\r\n    liquidation_discount: uint256\r\n\r\nevent CollectFees:\r\n    amount: uint256\r\n    new_supply: uint256\r\n\r\n\r\nstruct Loan:\r\n    initial_debt: uint256\r\n    rate_mul: uint256\r\n\r\nstruct Position:\r\n    user: address\r\n    x: uint256\r\n    y: uint256\r\n    debt: uint256\r\n    health: int256\r\n\r\nstruct CallbackData:\r\n    active_band: int256\r\n    stablecoins: uint256\r\n    collateral: uint256\r\n\r\n\r\nFACTORY: immutable(Factory)\r\nMAX_LOAN_DISCOUNT: constant(uint256) = 5 * 10**17\r\nMIN_LIQUIDATION_DISCOUNT: constant(uint256) = 10**16 # Start liquidating when threshold reached\r\nMAX_TICKS: constant(int256) = 50\r\nMAX_TICKS_UINT: constant(uint256) = 50\r\nMIN_TICKS: constant(int256) = 4\r\nMAX_SKIP_TICKS: constant(uint256) = 1024\r\nMAX_P_BASE_BANDS: constant(int256) = 5\r\n\r\nMAX_RATE: constant(uint256) = 43959106799  # 300% APY\r\n\r\nloan: HashMap[address, Loan]\r\nliquidation_discounts: public(HashMap[address, uint256])\r\n_total_debt: Loan\r\n\r\nloans: public(address[2**64 - 1])  # Enumerate existing loans\r\nloan_ix: public(HashMap[address, uint256])  # Position of the loan in the list\r\nn_loans: public(uint256)  # Number of nonzero loans\r\n\r\nminted: public(uint256)\r\nredeemed: public(uint256)\r\n\r\nmonetary_policy: public(MonetaryPolicy)\r\nliquidation_discount: public(uint256)\r\nloan_discount: public(uint256)\r\n\r\nCOLLATERAL_TOKEN: immutable(ERC20)\r\nCOLLATERAL_PRECISION: immutable(uint256)\r\n\r\nBORROWED_TOKEN: immutable(ERC20)\r\nBORROWED_PRECISION: immutable(uint256)\r\n\r\nAMM: immutable(LLAMMA)\r\nA: immutable(uint256)\r\nAminus1: immutable(uint256)\r\nLOGN_A_RATIO: immutable(int256)  # log(A / (A - 1))\r\nSQRT_BAND_RATIO: immutable(uint256)\r\n\r\nMAX_ADMIN_FEE: constant(uint256) = 5 * 10**17  # 50%\r\nMIN_FEE: constant(uint256) = 10**6  # 1e-12, still needs to be above 0\r\nMAX_FEE: immutable(uint256)  # let's set to MIN_TICKS / A: for example, 4% max fee for A=100\r\n\r\nCALLBACK_DEPOSIT: constant(bytes4) = method_id(\"callback_deposit(address,uint256,uint256,uint256,uint256[])\", output_type=bytes4)\r\nCALLBACK_REPAY: constant(bytes4) = method_id(\"callback_repay(address,uint256,uint256,uint256,uint256[])\", output_type=bytes4)\r\nCALLBACK_LIQUIDATE: constant(bytes4) = method_id(\"callback_liquidate(address,uint256,uint256,uint256,uint256[])\", output_type=bytes4)\r\n\r\nDEAD_SHARES: constant(uint256) = 1000\r\n\r\nMAX_ETH_GAS: constant(uint256) = 10000  # Forward this much gas to ETH transfers (2300 is what send() does)\r\n\r\n\r\n@external\r\ndef __init__(\r\n        collateral_token: address,\r\n        monetary_policy: address,\r\n        loan_discount: uint256,\r\n        liquidation_discount: uint256,\r\n        amm: address):\r\n    \"\"\"\r\n    @notice Controller constructor deployed by the factory from blueprint\r\n    @param collateral_token Token to use for collateral\r\n    @param monetary_policy Address of monetary policy\r\n    @param loan_discount Discount of the maximum loan size compare to get_x_down() value\r\n    @param liquidation_discount Discount of the maximum loan size compare to\r\n           get_x_down() for \"bad liquidation\" purposes\r\n    @param amm AMM address (Already deployed from blueprint)\r\n    \"\"\"\r\n    FACTORY = Factory(msg.sender)\r\n\r\n    self.monetary_policy = MonetaryPolicy(monetary_policy)\r\n\r\n    self.liquidation_discount = liquidation_discount\r\n    self.loan_discount = loan_discount\r\n    self._total_debt.rate_mul = 10**18\r\n\r\n    AMM = LLAMMA(amm)\r\n    _A: uint256 = LLAMMA(amm).A()\r\n    A = _A\r\n    Aminus1 = unsafe_sub(_A, 1)\r\n    LOGN_A_RATIO = self.wad_ln(unsafe_div(_A * 10**18, unsafe_sub(_A, 1)))\r\n    MAX_FEE = min(unsafe_div(10**18 * MIN_TICKS, A), 10**17)\r\n\r\n    _collateral_token: ERC20 = ERC20(collateral_token)\r\n    _borrowed_token: ERC20 = empty(ERC20)\r\n\r\n    if collateral_token == empty(address):\r\n        # Lending vault factory\r\n        _collateral_token = ERC20(Factory(msg.sender).collateral_token())\r\n        _borrowed_token = ERC20(Factory(msg.sender).borrowed_token())\r\n    else:\r\n        # Stablecoin factory\r\n        # _collateral_token is already set\r\n        _borrowed_token = ERC20(Factory(msg.sender).stablecoin())\r\n\r\n    COLLATERAL_TOKEN = _collateral_token\r\n    BORROWED_TOKEN = _borrowed_token\r\n    COLLATERAL_PRECISION = pow_mod256(10, 18 - _collateral_token.decimals())\r\n    BORROWED_PRECISION = pow_mod256(10, 18 - _borrowed_token.decimals())\r\n\r\n    SQRT_BAND_RATIO = isqrt(unsafe_div(10**36 * _A, unsafe_sub(_A, 1)))\r\n\r\n    _borrowed_token.approve(msg.sender, max_value(uint256))\r\n\r\n\r\n@internal\r\n@pure\r\ndef _log_2(x: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev An `internal` helper function that returns the log in base 2\r\n         of `x`, following the selected rounding direction.\r\n    @notice Note that it returns 0 if given 0. The implementation is\r\n            inspired by OpenZeppelin's implementation here:\r\n            https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol.\r\n            This code is taken from snekmate.\r\n    @param x The 32-byte variable.\r\n    @return uint256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: uint256 = x\r\n    result: uint256 = empty(uint256)\r\n\r\n    # The following lines cannot overflow because we have the well-known\r\n    # decay behaviour of `log_2(max_value(uint256)) < max_value(uint256)`.\r\n    if (x >> 128 != empty(uint256)):\r\n        value = x >> 128\r\n        result = 128\r\n    if (value >> 64 != empty(uint256)):\r\n        value = value >> 64\r\n        result = unsafe_add(result, 64)\r\n    if (value >> 32 != empty(uint256)):\r\n        value = value >> 32\r\n        result = unsafe_add(result, 32)\r\n    if (value >> 16 != empty(uint256)):\r\n        value = value >> 16\r\n        result = unsafe_add(result, 16)\r\n    if (value >> 8 != empty(uint256)):\r\n        value = value >> 8\r\n        result = unsafe_add(result, 8)\r\n    if (value >> 4 != empty(uint256)):\r\n        value = value >> 4\r\n        result = unsafe_add(result, 4)\r\n    if (value >> 2 != empty(uint256)):\r\n        value = value >> 2\r\n        result = unsafe_add(result, 2)\r\n    if (value >> 1 != empty(uint256)):\r\n        result = unsafe_add(result, 1)\r\n\r\n    return result\r\n\r\n\r\n@internal\r\n@pure\r\ndef wad_ln(x: uint256) -> int256:\r\n    \"\"\"\r\n    @dev Calculates the natural logarithm of a signed integer with a\r\n         precision of 1e18.\r\n    @notice Note that it returns 0 if given 0. Furthermore, this function\r\n            consumes about 1,400 to 1,650 gas units depending on the value\r\n            of `x`. The implementation is inspired by Remco Bloemen's\r\n            implementation under the MIT license here:\r\n            https://xn--2-umb.com/22/exp-ln.\r\n            This code is taken from snekmate.\r\n    @param x The 32-byte variable.\r\n    @return int256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: int256 = convert(x, int256)\r\n\r\n    assert x > 0\r\n\r\n    # We want to convert `x` from \"10 ** 18\" fixed point to \"2 ** 96\"\r\n    # fixed point. We do this by multiplying by \"2 ** 96 / 10 ** 18\".\r\n    # But since \"ln(x * C) = ln(x) + ln(C)\" holds, we can just do nothing\r\n    # here and add \"ln(2 ** 96 / 10 ** 18)\" at the end.\r\n\r\n    # Reduce the range of `x` to \"(1, 2) * 2 ** 96\".\r\n    # Also remember that \"ln(2 ** k * x) = k * ln(2) + ln(x)\" holds.\r\n    k: int256 = unsafe_sub(convert(self._log_2(x), int256), 96)\r\n    # Note that to circumvent Vyper's safecast feature for the potentially\r\n    # negative expression `value <<= uint256(159 - k)`, we first convert the\r\n    # expression `value <<= uint256(159 - k)` to `bytes32` and subsequently\r\n    # to `uint256`. Remember that the EVM default behaviour is to use two's\r\n    # complement representation to handle signed integers.\r\n    value = convert(convert(convert(value << convert(unsafe_sub(159, k), uint256), bytes32), uint256) >> 159, int256)\r\n\r\n    # Evaluate using a \"(8, 8)\"-term rational approximation. Since `p` is monic,\r\n    # we will multiply by a scaling factor later.\r\n    p: int256 = unsafe_add(unsafe_mul(unsafe_add(value, 3_273_285_459_638_523_848_632_254_066_296), value) >> 96, 24_828_157_081_833_163_892_658_089_445_524)\r\n    p = unsafe_add(unsafe_mul(p, value) >> 96, 43_456_485_725_739_037_958_740_375_743_393)\r\n    p = unsafe_sub(unsafe_mul(p, value) >> 96, 11_111_509_109_440_967_052_023_855_526_967)\r\n    p = unsafe_sub(unsafe_mul(p, value) >> 96, 45_023_709_667_254_063_763_336_534_515_857)\r\n    p = unsafe_sub(unsafe_mul(p, value) >> 96, 14_706_773_417_378_608_786_704_636_184_526)\r\n    p = unsafe_sub(unsafe_mul(p, value), 795_164_235_651_350_426_258_249_787_498 << 96)\r\n\r\n    # We leave `p` in the \"2 ** 192\" base so that we do not have to scale it up\r\n    # again for the division. Note that `q` is monic by convention.\r\n    q: int256 = unsafe_add(unsafe_mul(unsafe_add(value, 5_573_035_233_440_673_466_300_451_813_936), value) >> 96, 71_694_874_799_317_883_764_090_561_454_958)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 283_447_036_172_924_575_727_196_451_306_956)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 401_686_690_394_027_663_651_624_208_769_553)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 204_048_457_590_392_012_362_485_061_816_622)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 31_853_899_698_501_571_402_653_359_427_138)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 909_429_971_244_387_300_277_376_558_375)\r\n\r\n    # It is known that the polynomial `q` has no zeros in the domain.\r\n    # No scaling is required, as `p` is already \"2 ** 96\" too large. Also,\r\n    # `r` is in the range \"(0, 0.125) * 2 ** 96\" after the division.\r\n    r: int256 = unsafe_div(p, q)\r\n\r\n    # To finalise the calculation, we have to proceed with the following steps:\r\n    #   - multiply by the scaling factor \"s = 5.549...\",\r\n    #   - add \"ln(2 ** 96 / 10 ** 18)\",\r\n    #   - add \"k * ln(2)\", and\r\n    #   - multiply by \"10 ** 18 / 2 ** 96 = 5 ** 18 >> 78\".\r\n    # In order to perform the most gas-efficient calculation, we carry out all\r\n    # these steps in one expression.\r\n    return unsafe_add(unsafe_add(unsafe_mul(r, 1_677_202_110_996_718_588_342_820_967_067_443_963_516_166),\\\r\n           unsafe_mul(k, 16_597_577_552_685_614_221_487_285_958_193_947_469_193_820_559_219_878_177_908_093_499_208_371)),\\\r\n           600_920_179_829_731_861_736_702_779_321_621_459_595_472_258_049_074_101_567_377_883_020_018_308) >> 174\r\n\r\n\r\n@external\r\n@pure\r\ndef factory() -> Factory:\r\n    \"\"\"\r\n    @notice Address of the factory\r\n    \"\"\"\r\n    return FACTORY\r\n\r\n\r\n@external\r\n@pure\r\ndef amm() -> LLAMMA:\r\n    \"\"\"\r\n    @notice Address of the AMM\r\n    \"\"\"\r\n    return AMM\r\n\r\n\r\n@external\r\n@pure\r\ndef collateral_token() -> ERC20:\r\n    \"\"\"\r\n    @notice Address of the collateral token\r\n    \"\"\"\r\n    return COLLATERAL_TOKEN\r\n\r\n\r\n@external\r\n@pure\r\ndef borrowed_token() -> ERC20:\r\n    \"\"\"\r\n    @notice Address of the borrowed token\r\n    \"\"\"\r\n    return BORROWED_TOKEN\r\n\r\n\r\n@internal\r\ndef _save_rate():\r\n    \"\"\"\r\n    @notice Save current rate\r\n    \"\"\"\r\n    rate: uint256 = min(self.monetary_policy.rate_write(), MAX_RATE)\r\n    AMM.set_rate(rate)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef save_rate():\r\n    \"\"\"\r\n    @notice Save current rate\r\n    \"\"\"\r\n    self._save_rate()\r\n\r\n\r\n@internal\r\n@view\r\ndef _debt(user: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the value of debt and rate_mul and update the rate_mul counter\r\n    @param user User address\r\n    @return (debt, rate_mul)\r\n    \"\"\"\r\n    rate_mul: uint256 = AMM.get_rate_mul()\r\n    loan: Loan = self.loan[user]\r\n    if loan.initial_debt == 0:\r\n        return (0, rate_mul)\r\n    else:\r\n        # Let user repay 1 smallest decimal more so that the system doesn't lose on precision\r\n        # Use ceil div\r\n        debt: uint256 = loan.initial_debt * rate_mul\r\n        if debt % loan.rate_mul > 0:  # if only one loan -> don't have to do it\r\n            if self.n_loans > 1:\r\n                debt += loan.rate_mul\r\n        debt /= loan.rate_mul\r\n        return (debt, rate_mul)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef debt(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the value of debt without changing the state\r\n    @param user User address\r\n    @return Value of debt\r\n    \"\"\"\r\n    return self._debt(user)[0]\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef loan_exists(user: address) -> bool:\r\n    \"\"\"\r\n    @notice Check whether there is a loan of `user` in existence\r\n    \"\"\"\r\n    return self.loan[user].initial_debt > 0\r\n\r\n\r\n# No decorator because used in monetary policy\r\n@external\r\n@view\r\ndef total_debt() -> uint256:\r\n    \"\"\"\r\n    @notice Total debt of this controller\r\n    \"\"\"\r\n    rate_mul: uint256 = AMM.get_rate_mul()\r\n    loan: Loan = self._total_debt\r\n    return loan.initial_debt * rate_mul / loan.rate_mul\r\n\r\n\r\n@internal\r\n@pure\r\ndef get_y_effective(collateral: uint256, N: uint256, discount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Intermediary method which calculates y_effective defined as x_effective / p_base,\r\n            however discounted by loan_discount.\r\n            x_effective is an amount which can be obtained from collateral when liquidating\r\n    @param collateral Amount of collateral to get the value for\r\n    @param N Number of bands the deposit is made into\r\n    @param discount Loan discount at 1e18 base (e.g. 1e18 == 100%)\r\n    @return y_effective\r\n    \"\"\"\r\n    # x_effective = sum_{i=0..N-1}(y / N * p(n_{n1+i})) =\r\n    # = y / N * p_oracle_up(n1) * sqrt((A - 1) / A) * sum_{0..N-1}(((A-1) / A)**k)\r\n    # === d_y_effective * p_oracle_up(n1) * sum(...) === y_effective * p_oracle_up(n1)\r\n    # d_y_effective = y / N / sqrt(A / (A - 1))\r\n    # d_y_effective: uint256 = collateral * unsafe_sub(10**18, discount) / (SQRT_BAND_RATIO * N)\r\n    # Make some extra discount to always deposit lower when we have DEAD_SHARES rounding\r\n    d_y_effective: uint256 = collateral * unsafe_sub(\r\n        10**18, min(discount + unsafe_div((DEAD_SHARES * 10**18), max(unsafe_div(collateral, N), DEAD_SHARES)), 10**18)\r\n    ) / unsafe_mul(SQRT_BAND_RATIO, N)\r\n    y_effective: uint256 = d_y_effective\r\n    for i in range(1, MAX_TICKS_UINT):\r\n        if i == N:\r\n            break\r\n        d_y_effective = unsafe_div(d_y_effective * Aminus1, A)\r\n        y_effective = unsafe_add(y_effective, d_y_effective)\r\n    return y_effective\r\n\r\n\r\n@internal\r\n@view\r\ndef _calculate_debt_n1(collateral: uint256, debt: uint256, N: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate the upper band number for the deposit to sit in to support\r\n            the given debt. Reverts if requested debt is too high.\r\n    @param collateral Amount of collateral (at its native precision)\r\n    @param debt Amount of requested debt\r\n    @param N Number of bands to deposit into\r\n    @return Upper band n1 (n1 <= n2) to deposit into. Signed integer\r\n    \"\"\"\r\n    assert debt > 0, \"No loan\"\r\n    n0: int256 = AMM.active_band()\r\n    p_base: uint256 = AMM.p_oracle_up(n0)\r\n\r\n    # x_effective = y / N * p_oracle_up(n1) * sqrt((A - 1) / A) * sum_{0..N-1}(((A-1) / A)**k)\r\n    # === d_y_effective * p_oracle_up(n1) * sum(...) === y_effective * p_oracle_up(n1)\r\n    # d_y_effective = y / N / sqrt(A / (A - 1))\r\n    y_effective: uint256 = self.get_y_effective(collateral * COLLATERAL_PRECISION, N, self.loan_discount)\r\n    # p_oracle_up(n1) = base_price * ((A - 1) / A)**n1\r\n\r\n    # We borrow up until min band touches p_oracle,\r\n    # or it touches non-empty bands which cannot be skipped.\r\n    # We calculate required n1 for given (collateral, debt),\r\n    # and if n1 corresponds to price_oracle being too high, or unreachable band\r\n    # - we revert.\r\n\r\n    # n1 is band number based on adiabatic trading, e.g. when p_oracle ~ p\r\n    y_effective = unsafe_div(y_effective * p_base, debt * BORROWED_PRECISION + 1)  # Now it's a ratio\r\n\r\n    # n1 = floor(log(y_effective) / self.logAratio)\r\n    # EVM semantics is not doing floor unlike Python, so we do this\r\n    assert y_effective > 0, \"Amount too low\"\r\n    n1: int256 = self.wad_ln(y_effective)\r\n    if n1 < 0:\r\n        n1 -= unsafe_sub(LOGN_A_RATIO, 1)  # This is to deal with vyper's rounding of negative numbers\r\n    n1 = unsafe_div(n1, LOGN_A_RATIO)\r\n\r\n    n1 = min(n1, 1024 - convert(N, int256)) + n0\r\n    if n1 <= n0:\r\n        assert AMM.can_skip_bands(n1 - 1), \"Debt too high\"\r\n\r\n    # Let's not rely on active_band corresponding to price_oracle:\r\n    # this will be not correct if we are in the area of empty bands\r\n    assert AMM.p_oracle_up(n1) < AMM.price_oracle(), \"Debt too high\"\r\n\r\n    return n1\r\n\r\n\r\n@internal\r\n@view\r\ndef max_p_base() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate max base price including skipping bands\r\n    \"\"\"\r\n    p_oracle: uint256 = AMM.price_oracle()\r\n    # Should be correct unless price changes suddenly by MAX_P_BASE_BANDS+ bands\r\n    n1: int256 = self.wad_ln(AMM.get_base_price() * 10**18 / p_oracle)\r\n    if n1 < 0:\r\n        n1 -= LOGN_A_RATIO - 1  # This is to deal with vyper's rounding of negative numbers\r\n    n1 = unsafe_div(n1, LOGN_A_RATIO) + MAX_P_BASE_BANDS\r\n    n_min: int256 = AMM.active_band_with_skip()\r\n    n1 = max(n1, n_min + 1)\r\n    p_base: uint256 = AMM.p_oracle_up(n1)\r\n\r\n    for i in range(MAX_SKIP_TICKS + 1):\r\n        n1 -= 1\r\n        if n1 <= n_min:\r\n            break\r\n        p_base_prev: uint256 = p_base\r\n        p_base = unsafe_div(p_base * A, Aminus1)\r\n        if p_base > p_oracle:\r\n            return p_base_prev\r\n\r\n    return p_base\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef max_borrowable(collateral: uint256, N: uint256, current_debt: uint256 = 0) -> uint256:\r\n    \"\"\"\r\n    @notice Calculation of maximum which can be borrowed (details in comments)\r\n    @param collateral Collateral amount against which to borrow\r\n    @param N number of bands to have the deposit into\r\n    @param current_debt Current debt of the user (if any)\r\n    @return Maximum amount of stablecoin to borrow\r\n    \"\"\"\r\n    # Calculation of maximum which can be borrowed.\r\n    # It corresponds to a minimum between the amount corresponding to price_oracle\r\n    # and the one given by the min reachable band.\r\n    #\r\n    # Given by p_oracle (perhaps needs to be multiplied by (A - 1) / A to account for mid-band effects)\r\n    # x_max ~= y_effective * p_oracle\r\n    #\r\n    # Given by band number:\r\n    # if n1 is the lowest empty band in the AMM\r\n    # xmax ~= y_effective * amm.p_oracle_up(n1)\r\n    #\r\n    # When n1 -= 1:\r\n    # p_oracle_up *= A / (A - 1)\r\n\r\n    y_effective: uint256 = self.get_y_effective(collateral * COLLATERAL_PRECISION, N, self.loan_discount)\r\n\r\n    x: uint256 = unsafe_sub(max(unsafe_div(y_effective * self.max_p_base(), 10**18), 1), 1)\r\n    x = unsafe_div(x * (10**18 - 10**14), unsafe_mul(10**18, BORROWED_PRECISION))  # Make it a bit smaller\r\n    return min(x, BORROWED_TOKEN.balanceOf(self) + current_debt)  # Cannot borrow beyond the amount of coins Controller has\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef min_collateral(debt: uint256, N: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Minimal amount of collateral required to support debt\r\n    @param debt The debt to support\r\n    @param N Number of bands to deposit into\r\n    @return Minimal collateral required\r\n    \"\"\"\r\n    # Add N**2 to account for precision loss in multiple bands, e.g. N / (y/N) = N**2 / y\r\n    return unsafe_div(\r\n        unsafe_div(\r\n            debt * unsafe_mul(10**18, BORROWED_PRECISION) / self.max_p_base() * 10**18 / self.get_y_effective(10**18, N, self.loan_discount) + N * (N + 2 * DEAD_SHARES) + unsafe_sub(COLLATERAL_PRECISION, 1),\r\n            COLLATERAL_PRECISION\r\n        ) * 10**18,\r\n        10**18 - 10**14)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef calculate_debt_n1(collateral: uint256, debt: uint256, N: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate the upper band number for the deposit to sit in to support\r\n            the given debt. Reverts if requested debt is too high.\r\n    @param collateral Amount of collateral (at its native precision)\r\n    @param debt Amount of requested debt\r\n    @param N Number of bands to deposit into\r\n    @return Upper band n1 (n1 <= n2) to deposit into. Signed integer\r\n    \"\"\"\r\n    return self._calculate_debt_n1(collateral, debt, N)\r\n\r\n\r\n@internal\r\ndef transferFrom(token: ERC20, _from: address, _to: address, amount: uint256):\r\n    if amount > 0:\r\n        assert token.transferFrom(_from, _to, amount, default_return_value=True)\r\n\r\n\r\n@internal\r\ndef transfer(token: ERC20, _to: address, amount: uint256):\r\n    if amount > 0:\r\n        assert token.transfer(_to, amount, default_return_value=True)\r\n\r\n\r\n@internal\r\ndef execute_callback(callbacker: address, callback_sig: bytes4,\r\n                     user: address, stablecoins: uint256, collateral: uint256, debt: uint256,\r\n                     callback_args: DynArray[uint256, 5]) -> CallbackData:\r\n    assert callbacker != COLLATERAL_TOKEN.address\r\n\r\n    data: CallbackData = empty(CallbackData)\r\n    data.active_band = AMM.active_band()\r\n    band_x: uint256 = AMM.bands_x(data.active_band)\r\n    band_y: uint256 = AMM.bands_y(data.active_band)\r\n\r\n    # Callback\r\n    response: Bytes[64] = raw_call(\r\n        callbacker,\r\n        concat(callback_sig, _abi_encode(user, stablecoins, collateral, debt, callback_args)),\r\n        max_outsize=64\r\n    )\r\n    data.stablecoins = convert(slice(response, 0, 32), uint256)\r\n    data.collateral = convert(slice(response, 32, 32), uint256)\r\n\r\n    # Checks after callback\r\n    assert data.active_band == AMM.active_band()\r\n    assert band_x == AMM.bands_x(data.active_band)\r\n    assert band_y == AMM.bands_y(data.active_band)\r\n\r\n    return data\r\n\r\n@internal\r\ndef _create_loan(collateral: uint256, debt: uint256, N: uint256, transfer_coins: bool):\r\n    assert self.loan[msg.sender].initial_debt == 0, \"Loan already created\"\r\n    assert N > MIN_TICKS-1, \"Need more ticks\"\r\n    assert N < MAX_TICKS+1, \"Need less ticks\"\r\n\r\n    n1: int256 = self._calculate_debt_n1(collateral, debt, N)\r\n    n2: int256 = n1 + convert(N - 1, int256)\r\n\r\n    rate_mul: uint256 = AMM.get_rate_mul()\r\n    self.loan[msg.sender] = Loan({initial_debt: debt, rate_mul: rate_mul})\r\n    liquidation_discount: uint256 = self.liquidation_discount\r\n    self.liquidation_discounts[msg.sender] = liquidation_discount\r\n\r\n    n_loans: uint256 = self.n_loans\r\n    self.loans[n_loans] = msg.sender\r\n    self.loan_ix[msg.sender] = n_loans\r\n    self.n_loans = unsafe_add(n_loans, 1)\r\n\r\n    self._total_debt.initial_debt = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul + debt\r\n    self._total_debt.rate_mul = rate_mul\r\n\r\n    AMM.deposit_range(msg.sender, collateral, n1, n2)\r\n    self.minted += debt\r\n\r\n    if transfer_coins:\r\n        self.transferFrom(COLLATERAL_TOKEN, msg.sender, AMM.address, collateral)\r\n        self.transfer(BORROWED_TOKEN, msg.sender, debt)\r\n\r\n    self._save_rate()\r\n\r\n    log UserState(msg.sender, collateral, debt, n1, n2, liquidation_discount)\r\n    log Borrow(msg.sender, collateral, debt)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef create_loan(collateral: uint256, debt: uint256, N: uint256):\r\n    \"\"\"\r\n    @notice Create loan\r\n    @param collateral Amount of collateral to use\r\n    @param debt Stablecoin debt to take\r\n    @param N Number of bands to deposit into (to do autoliquidation-deliquidation),\r\n           can be from MIN_TICKS to MAX_TICKS\r\n    \"\"\"\r\n    self._create_loan(collateral, debt, N, True)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef create_loan_extended(collateral: uint256, debt: uint256, N: uint256, callbacker: address, callback_args: DynArray[uint256,5]):\r\n    \"\"\"\r\n    @notice Create loan but pass stablecoin to a callback first so that it can build leverage\r\n    @param collateral Amount of collateral to use\r\n    @param debt Stablecoin debt to take\r\n    @param N Number of bands to deposit into (to do autoliquidation-deliquidation),\r\n           can be from MIN_TICKS to MAX_TICKS\r\n    @param callbacker Address of the callback contract\r\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\r\n    \"\"\"\r\n    # Before callback\r\n    self.transfer(BORROWED_TOKEN, callbacker, debt)\r\n\r\n    # Callback\r\n    # If there is any unused debt, callbacker can send it to the user\r\n    more_collateral: uint256 = self.execute_callback(\r\n        callbacker, CALLBACK_DEPOSIT, msg.sender, 0, collateral, debt, callback_args).collateral\r\n\r\n    # After callback\r\n    self._create_loan(collateral + more_collateral, debt, N, False)\r\n    self.transferFrom(COLLATERAL_TOKEN, msg.sender, AMM.address, collateral)\r\n    self.transferFrom(COLLATERAL_TOKEN, callbacker, AMM.address, more_collateral)\r\n\r\n\r\n@internal\r\ndef _add_collateral_borrow(d_collateral: uint256, d_debt: uint256, _for: address, remove_collateral: bool):\r\n    \"\"\"\r\n    @notice Internal method to borrow and add or remove collateral\r\n    @param d_collateral Amount of collateral to add\r\n    @param d_debt Amount of debt increase\r\n    @param _for Address to transfer tokens to\r\n    @param remove_collateral Remove collateral instead of adding\r\n    \"\"\"\r\n    debt: uint256 = 0\r\n    rate_mul: uint256 = 0\r\n    debt, rate_mul = self._debt(_for)\r\n    assert debt > 0, \"Loan doesn't exist\"\r\n    debt += d_debt\r\n    ns: int256[2] = AMM.read_user_tick_numbers(_for)\r\n    size: uint256 = convert(unsafe_add(unsafe_sub(ns[1], ns[0]), 1), uint256)\r\n\r\n    xy: uint256[2] = AMM.withdraw(_for, 10**18)\r\n    assert xy[0] == 0, \"Already in underwater mode\"\r\n    if remove_collateral:\r\n        xy[1] -= d_collateral\r\n    else:\r\n        xy[1] += d_collateral\r\n    n1: int256 = self._calculate_debt_n1(xy[1], debt, size)\r\n    n2: int256 = n1 + unsafe_sub(ns[1], ns[0])\r\n\r\n    AMM.deposit_range(_for, xy[1], n1, n2)\r\n    self.loan[_for] = Loan({initial_debt: debt, rate_mul: rate_mul})\r\n\r\n    liquidation_discount: uint256 = 0\r\n    if _for == msg.sender:\r\n        liquidation_discount = self.liquidation_discount\r\n        self.liquidation_discounts[_for] = liquidation_discount\r\n    else:\r\n        liquidation_discount = self.liquidation_discounts[_for]\r\n\r\n    if d_debt != 0:\r\n        self._total_debt.initial_debt = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul + d_debt\r\n        self._total_debt.rate_mul = rate_mul\r\n\r\n    if remove_collateral:\r\n        log RemoveCollateral(_for, d_collateral)\r\n    else:\r\n        log Borrow(_for, d_collateral, d_debt)\r\n\r\n    log UserState(_for, xy[1], debt, n1, n2, liquidation_discount)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_collateral(collateral: uint256, _for: address = msg.sender):\r\n    \"\"\"\r\n    @notice Add extra collateral to avoid bad liqidations\r\n    @param collateral Amount of collateral to add\r\n    @param _for Address to add collateral for\r\n    \"\"\"\r\n    if collateral == 0:\r\n        return\r\n    self._add_collateral_borrow(collateral, 0, _for, False)\r\n    self.transferFrom(COLLATERAL_TOKEN, msg.sender, AMM.address, collateral)\r\n    self._save_rate()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_collateral(collateral: uint256, use_eth: bool = True):\r\n    \"\"\"\r\n    @notice Remove some collateral without repaying the debt\r\n    @param collateral Amount of collateral to remove\r\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\r\n    \"\"\"\r\n    if collateral == 0:\r\n        return\r\n    self._add_collateral_borrow(collateral, 0, msg.sender, True)\r\n    self.transferFrom(COLLATERAL_TOKEN, AMM.address, msg.sender, collateral)\r\n    self._save_rate()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef borrow_more(collateral: uint256, debt: uint256):\r\n    \"\"\"\r\n    @notice Borrow more stablecoins while adding more collateral (not necessary)\r\n    @param collateral Amount of collateral to add\r\n    @param debt Amount of stablecoin debt to take\r\n    \"\"\"\r\n    if debt == 0:\r\n        return\r\n    self._add_collateral_borrow(collateral, debt, msg.sender, False)\r\n    self.minted += debt\r\n    self.transferFrom(COLLATERAL_TOKEN, msg.sender, AMM.address, collateral)\r\n    self.transfer(BORROWED_TOKEN, msg.sender, debt)\r\n    self._save_rate()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef borrow_more_extended(collateral: uint256, debt: uint256, callbacker: address, callback_args: DynArray[uint256,5]):\r\n    \"\"\"\r\n    @notice Borrow more stablecoins while adding more collateral using a callback (to leverage more)\r\n    @param collateral Amount of collateral to add\r\n    @param debt Amount of stablecoin debt to take\r\n    @param callbacker Address of the callback contract\r\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\r\n    \"\"\"\r\n    if debt == 0:\r\n        return\r\n\r\n    # Before callback\r\n    self.transfer(BORROWED_TOKEN, callbacker, debt)\r\n\r\n    # Callback\r\n    # If there is any unused debt, callbacker can send it to the user\r\n    more_collateral: uint256 = self.execute_callback(\r\n        callbacker, CALLBACK_DEPOSIT, msg.sender, 0, collateral, debt, callback_args).collateral\r\n\r\n    # After callback\r\n    self._add_collateral_borrow(collateral + more_collateral, debt, msg.sender, False)\r\n    self.minted += debt\r\n    self.transferFrom(COLLATERAL_TOKEN, msg.sender, AMM.address, collateral)\r\n    self.transferFrom(COLLATERAL_TOKEN, callbacker, AMM.address, more_collateral)\r\n    self._save_rate()\r\n\r\n\r\n@internal\r\ndef _remove_from_list(_for: address):\r\n    last_loan_ix: uint256 = self.n_loans - 1\r\n    loan_ix: uint256 = self.loan_ix[_for]\r\n    assert self.loans[loan_ix] == _for  # dev: should never fail but safety first\r\n    self.loan_ix[_for] = 0\r\n    if loan_ix < last_loan_ix:  # Need to replace\r\n        last_loan: address = self.loans[last_loan_ix]\r\n        self.loans[loan_ix] = last_loan\r\n        self.loan_ix[last_loan] = loan_ix\r\n    self.n_loans = last_loan_ix\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef repay(_d_debt: uint256, _for: address = msg.sender, max_active_band: int256 = 2**255-1, use_eth: bool = True):\r\n    \"\"\"\r\n    @notice Repay debt (partially or fully)\r\n    @param _d_debt The amount of debt to repay. If higher than the current debt - will do full repayment\r\n    @param _for The user to repay the debt for\r\n    @param max_active_band Don't allow active band to be higher than this (to prevent front-running the repay)\r\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\r\n    \"\"\"\r\n    if _d_debt == 0:\r\n        return\r\n    # Or repay all for MAX_UINT256\r\n    # Withdraw if debt become 0\r\n    debt: uint256 = 0\r\n    rate_mul: uint256 = 0\r\n    debt, rate_mul = self._debt(_for)\r\n    assert debt > 0, \"Loan doesn't exist\"\r\n    d_debt: uint256 = min(debt, _d_debt)\r\n    debt = unsafe_sub(debt, d_debt)\r\n\r\n    if debt == 0:\r\n        # Allow to withdraw all assets even when underwater\r\n        xy: uint256[2] = AMM.withdraw(_for, 10**18)\r\n        if xy[0] > 0:\r\n            # Only allow full repayment when underwater for the sender to do\r\n            assert _for == msg.sender\r\n            self.transferFrom(BORROWED_TOKEN, AMM.address, _for, xy[0])\r\n        if xy[1] > 0:\r\n            self.transferFrom(COLLATERAL_TOKEN, AMM.address, _for, xy[1])\r\n        log UserState(_for, 0, 0, 0, 0, 0)\r\n        log Repay(_for, xy[1], d_debt)\r\n        self._remove_from_list(_for)\r\n\r\n    else:\r\n        active_band: int256 = AMM.active_band_with_skip()\r\n        assert active_band <= max_active_band\r\n\r\n        ns: int256[2] = AMM.read_user_tick_numbers(_for)\r\n        size: uint256 = convert(unsafe_add(unsafe_sub(ns[1], ns[0]), 1), uint256)\r\n        liquidation_discount: uint256 = self.liquidation_discounts[_for]\r\n\r\n        if ns[0] > active_band:\r\n            # Not in liquidation - can move bands\r\n            xy: uint256[2] = AMM.withdraw(_for, 10**18)\r\n            n1: int256 = self._calculate_debt_n1(xy[1], debt, size)\r\n            n2: int256 = n1 + unsafe_sub(ns[1], ns[0])\r\n            AMM.deposit_range(_for, xy[1], n1, n2)\r\n            if _for == msg.sender:\r\n                # Update liquidation discount only if we are that same user. No rugs\r\n                liquidation_discount = self.liquidation_discount\r\n                self.liquidation_discounts[_for] = liquidation_discount\r\n            log UserState(_for, xy[1], debt, n1, n2, liquidation_discount)\r\n            log Repay(_for, 0, d_debt)\r\n        else:\r\n            # Underwater - cannot move band but can avoid a bad liquidation\r\n            log UserState(_for, max_value(uint256), debt, ns[0], ns[1], liquidation_discount)\r\n            log Repay(_for, 0, d_debt)\r\n\r\n        if _for != msg.sender:\r\n            # Doesn't allow non-sender to repay in a way which ends with unhealthy state\r\n            # full = False to make this condition non-manipulatable (and also cheaper on gas)\r\n            assert self._health(_for, debt, False, liquidation_discount) > 0\r\n\r\n    # If we withdrew already - will burn less!\r\n    self.transferFrom(BORROWED_TOKEN, msg.sender, self, d_debt)  # fail: insufficient funds\r\n    self.redeemed += d_debt\r\n\r\n    self.loan[_for] = Loan({initial_debt: debt, rate_mul: rate_mul})\r\n    total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul\r\n    self._total_debt.initial_debt = unsafe_sub(max(total_debt, d_debt), d_debt)\r\n    self._total_debt.rate_mul = rate_mul\r\n\r\n    self._save_rate()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef repay_extended(callbacker: address, callback_args: DynArray[uint256,5]):\r\n    \"\"\"\r\n    @notice Repay loan but get a stablecoin for that from callback (to deleverage)\r\n    @param callbacker Address of the callback contract\r\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\r\n    \"\"\"\r\n    # Before callback\r\n    ns: int256[2] = AMM.read_user_tick_numbers(msg.sender)\r\n    xy: uint256[2] = AMM.withdraw(msg.sender, 10**18)\r\n    debt: uint256 = 0\r\n    rate_mul: uint256 = 0\r\n    debt, rate_mul = self._debt(msg.sender)\r\n    self.transferFrom(COLLATERAL_TOKEN, AMM.address, callbacker, xy[1])\r\n\r\n    cb: CallbackData = self.execute_callback(\r\n        callbacker, CALLBACK_REPAY, msg.sender, xy[0], xy[1], debt, callback_args)\r\n\r\n    # After callback\r\n    total_stablecoins: uint256 = cb.stablecoins + xy[0]\r\n    assert total_stablecoins > 0  # dev: no coins to repay\r\n\r\n    # d_debt: uint256 = min(debt, total_stablecoins)\r\n\r\n    d_debt: uint256 = 0\r\n\r\n    # If we have more stablecoins than the debt - full repayment and closing the position\r\n    if total_stablecoins >= debt:\r\n        d_debt = debt\r\n        debt = 0\r\n        self._remove_from_list(msg.sender)\r\n\r\n        # Transfer debt to self, everything else to sender\r\n        self.transferFrom(BORROWED_TOKEN, callbacker, self, cb.stablecoins)\r\n        self.transferFrom(BORROWED_TOKEN, AMM.address, self, xy[0])\r\n        if total_stablecoins > d_debt:\r\n            self.transfer(BORROWED_TOKEN, msg.sender, unsafe_sub(total_stablecoins, d_debt))\r\n        self.transferFrom(COLLATERAL_TOKEN, callbacker, msg.sender, cb.collateral)\r\n\r\n        log UserState(msg.sender, 0, 0, 0, 0, 0)\r\n\r\n    # Else - partial repayment -> deleverage, but only if we are not underwater\r\n    else:\r\n        size: uint256 = convert(unsafe_add(unsafe_sub(ns[1], ns[0]), 1), uint256)\r\n        assert ns[0] > cb.active_band\r\n        d_debt = cb.stablecoins  # cb.stablecoins <= total_stablecoins < debt\r\n        debt = unsafe_sub(debt, cb.stablecoins)\r\n\r\n        # Not in liquidation - can move bands\r\n        n1: int256 = self._calculate_debt_n1(cb.collateral, debt, size)\r\n        n2: int256 = n1 + unsafe_sub(ns[1], ns[0])\r\n        AMM.deposit_range(msg.sender, cb.collateral, n1, n2)\r\n        liquidation_discount: uint256 = self.liquidation_discount\r\n        self.liquidation_discounts[msg.sender] = liquidation_discount\r\n\r\n        self.transferFrom(COLLATERAL_TOKEN, callbacker, AMM.address, cb.collateral)\r\n        # Stablecoin is all spent to repay debt -> all goes to self\r\n        self.transferFrom(BORROWED_TOKEN, callbacker, self, cb.stablecoins)\r\n        # We are above active band, so xy[0] is 0 anyway\r\n\r\n        log UserState(msg.sender, cb.collateral, debt, n1, n2, liquidation_discount)\r\n        xy[1] -= cb.collateral\r\n\r\n        # No need to check _health() because it's the sender\r\n\r\n    # Common calls which we will do regardless of whether it's a full repay or not\r\n    log Repay(msg.sender, xy[1], d_debt)\r\n    self.redeemed += d_debt\r\n    self.loan[msg.sender] = Loan({initial_debt: debt, rate_mul: rate_mul})\r\n    total_debt: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul\r\n    self._total_debt.initial_debt = unsafe_sub(max(total_debt, d_debt), d_debt)\r\n    self._total_debt.rate_mul = rate_mul\r\n\r\n    self._save_rate()\r\n\r\n\r\n@internal\r\n@view\r\ndef _health(user: address, debt: uint256, full: bool, liquidation_discount: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Returns position health normalized to 1e18 for the user.\r\n            Liquidation starts when < 0, however devaluation of collateral doesn't cause liquidation\r\n    @param user User address to calculate health for\r\n    @param debt The amount of debt to calculate health for\r\n    @param full Whether to take into account the price difference above the highest user's band\r\n    @param liquidation_discount Liquidation discount to use (can be 0)\r\n    @return Health: > 0 = good.\r\n    \"\"\"\r\n    assert debt > 0, \"Loan doesn't exist\"\r\n    health: int256 = 10**18 - convert(liquidation_discount, int256)\r\n    health = unsafe_div(convert(AMM.get_x_down(user), int256) * health, convert(debt, int256)) - 10**18\r\n\r\n    if full:\r\n        ns0: int256 = AMM.read_user_tick_numbers(user)[0] # ns[1] > ns[0]\r\n        if ns0 > AMM.active_band():  # We are not in liquidation mode\r\n            p: uint256 = AMM.price_oracle()\r\n            p_up: uint256 = AMM.p_oracle_up(ns0)\r\n            if p > p_up:\r\n                health += convert(unsafe_div(unsafe_sub(p, p_up) * AMM.get_sum_xy(user)[1] * COLLATERAL_PRECISION, debt * BORROWED_PRECISION), int256)\r\n\r\n    return health\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef health_calculator(user: address, d_collateral: int256, d_debt: int256, full: bool, N: uint256 = 0) -> int256:\r\n    \"\"\"\r\n    @notice Health predictor in case user changes the debt or collateral\r\n    @param user Address of the user\r\n    @param d_collateral Change in collateral amount (signed)\r\n    @param d_debt Change in debt amount (signed)\r\n    @param full Whether it's a 'full' health or not\r\n    @param N Number of bands in case loan doesn't yet exist\r\n    @return Signed health value\r\n    \"\"\"\r\n    ns: int256[2] = AMM.read_user_tick_numbers(user)\r\n    debt: int256 = convert(self._debt(user)[0], int256)\r\n    n: uint256 = N\r\n    ld: int256 = 0\r\n    if debt != 0:\r\n        ld = convert(self.liquidation_discounts[user], int256)\r\n        n = convert(unsafe_add(unsafe_sub(ns[1], ns[0]), 1), uint256)\r\n    else:\r\n        ld = convert(self.liquidation_discount, int256)\r\n        ns[0] = max_value(int256)  # This will trigger a \"re-deposit\"\r\n\r\n    n1: int256 = 0\r\n    collateral: int256 = 0\r\n    x_eff: int256 = 0\r\n    debt += d_debt\r\n    assert debt > 0, \"Non-positive debt\"\r\n\r\n    active_band: int256 = AMM.active_band_with_skip()\r\n\r\n    if ns[0] > active_band:  # re-deposit\r\n        collateral = convert(AMM.get_sum_xy(user)[1], int256) + d_collateral\r\n        n1 = self._calculate_debt_n1(convert(collateral, uint256), convert(debt, uint256), n)\r\n        collateral *= convert(COLLATERAL_PRECISION, int256)  # now has 18 decimals\r\n    else:\r\n        n1 = ns[0]\r\n        x_eff = convert(AMM.get_x_down(user) * unsafe_mul(10**18, BORROWED_PRECISION), int256)\r\n\r\n    debt *= convert(BORROWED_PRECISION, int256)\r\n\r\n    p0: int256 = convert(AMM.p_oracle_up(n1), int256)\r\n    if ns[0] > active_band:\r\n        x_eff = convert(self.get_y_effective(convert(collateral, uint256), n, 0), int256) * p0\r\n\r\n    health: int256 = unsafe_div(x_eff, debt)\r\n    health = health - unsafe_div(health * ld, 10**18) - 10**18\r\n\r\n    if full:\r\n        if n1 > active_band:  # We are not in liquidation mode\r\n            p_diff: int256 = max(p0, convert(AMM.price_oracle(), int256)) - p0\r\n            if p_diff > 0:\r\n                health += unsafe_div(p_diff * collateral, debt)\r\n\r\n    return health\r\n\r\n\r\n@internal\r\n@pure\r\ndef _get_f_remove(frac: uint256, health_limit: uint256) -> uint256:\r\n    # f_remove = ((1 + h / 2) / (1 + h) * (1 - frac) + frac) * frac\r\n    f_remove: uint256 = 10 ** 18\r\n    if frac < 10 ** 18:\r\n        f_remove = unsafe_div(unsafe_mul(unsafe_add(10 ** 18, unsafe_div(health_limit, 2)), unsafe_sub(10 ** 18, frac)), unsafe_add(10 ** 18, health_limit))\r\n        f_remove = unsafe_div(unsafe_mul(unsafe_add(f_remove, frac), frac), 10 ** 18)\r\n\r\n    return f_remove\r\n\r\n@internal\r\ndef _liquidate(user: address, min_x: uint256, health_limit: uint256, frac: uint256, use_eth: bool,\r\n               callbacker: address, callback_args: DynArray[uint256,5]):\r\n    \"\"\"\r\n    @notice Perform a bad liquidation of user if the health is too bad\r\n    @param user Address of the user\r\n    @param min_x Minimal amount of stablecoin withdrawn (to avoid liquidators being sandwiched)\r\n    @param health_limit Minimal health to liquidate at\r\n    @param frac Fraction to liquidate; 100% = 10**18\r\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\r\n    @param callbacker Address of the callback contract\r\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\r\n    \"\"\"\r\n    debt: uint256 = 0\r\n    rate_mul: uint256 = 0\r\n    debt, rate_mul = self._debt(user)\r\n\r\n    if health_limit != 0:\r\n        assert self._health(user, debt, True, health_limit) < 0, \"Not enough rekt\"\r\n\r\n    final_debt: uint256 = debt\r\n    debt = unsafe_div(debt * frac, 10**18)\r\n    assert debt > 0\r\n    final_debt = unsafe_sub(final_debt, debt)\r\n\r\n    # Withdraw sender's stablecoin and collateral to our contract\r\n    # When frac is set - we withdraw a bit less for the same debt fraction\r\n    # f_remove = ((1 + h/2) / (1 + h) * (1 - frac) + frac) * frac\r\n    # where h is health limit.\r\n    # This is less than full h discount but more than no discount\r\n    xy: uint256[2] = AMM.withdraw(user, self._get_f_remove(frac, health_limit))  # [stable, collateral]\r\n\r\n    # x increase in same block -> price up -> good\r\n    # x decrease in same block -> price down -> bad\r\n    assert xy[0] >= min_x, \"Slippage\"\r\n\r\n    min_amm_burn: uint256 = min(xy[0], debt)\r\n    self.transferFrom(BORROWED_TOKEN, AMM.address, self, min_amm_burn)\r\n\r\n    if debt > xy[0]:\r\n        to_repay: uint256 = unsafe_sub(debt, xy[0])\r\n\r\n        if callbacker == empty(address):\r\n            # Withdraw collateral if no callback is present\r\n            self.transferFrom(COLLATERAL_TOKEN, AMM.address, msg.sender, xy[1])\r\n            # Request what's left from user\r\n            self.transferFrom(BORROWED_TOKEN, msg.sender, self, to_repay)\r\n\r\n        else:\r\n            # Move collateral to callbacker, call it and remove everything from it back in\r\n            self.transferFrom(COLLATERAL_TOKEN, AMM.address, callbacker, xy[1])\r\n            # Callback\r\n            cb: CallbackData = self.execute_callback(\r\n                callbacker, CALLBACK_LIQUIDATE, user, xy[0], xy[1], debt, callback_args)\r\n            assert cb.stablecoins >= to_repay, \"not enough proceeds\"\r\n            if cb.stablecoins > to_repay:\r\n                self.transferFrom(BORROWED_TOKEN, callbacker, msg.sender, unsafe_sub(cb.stablecoins, to_repay))\r\n            self.transferFrom(BORROWED_TOKEN, callbacker, self, to_repay)\r\n            self.transferFrom(COLLATERAL_TOKEN, callbacker, msg.sender, cb.collateral)\r\n\r\n    else:\r\n        # Withdraw collateral\r\n        self.transferFrom(COLLATERAL_TOKEN, AMM.address, msg.sender, xy[1])\r\n        # Return what's left to user\r\n        if xy[0] > debt:\r\n            self.transferFrom(BORROWED_TOKEN, AMM.address, msg.sender, unsafe_sub(xy[0], debt))\r\n\r\n    self.redeemed += debt\r\n    self.loan[user] = Loan({initial_debt: final_debt, rate_mul: rate_mul})\r\n    log Repay(user, xy[1], debt)\r\n    log Liquidate(msg.sender, user, xy[1], xy[0], debt)\r\n    if final_debt == 0:\r\n        log UserState(user, 0, 0, 0, 0, 0)  # Not logging partial removeal b/c we have not enough info\r\n        self._remove_from_list(user)\r\n\r\n    d: uint256 = self._total_debt.initial_debt * rate_mul / self._total_debt.rate_mul\r\n    self._total_debt.initial_debt = unsafe_sub(max(d, debt), debt)\r\n    self._total_debt.rate_mul = rate_mul\r\n\r\n    self._save_rate()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef liquidate(user: address, min_x: uint256, use_eth: bool = True):\r\n    \"\"\"\r\n    @notice Peform a bad liquidation (or self-liquidation) of user if health is not good\r\n    @param min_x Minimal amount of stablecoin to receive (to avoid liquidators being sandwiched)\r\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\r\n    \"\"\"\r\n    discount: uint256 = 0\r\n    if user != msg.sender:\r\n        discount = self.liquidation_discounts[user]\r\n    self._liquidate(user, min_x, discount, 10**18, use_eth, empty(address), [])\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef liquidate_extended(user: address, min_x: uint256, frac: uint256, use_eth: bool,\r\n                       callbacker: address, callback_args: DynArray[uint256,5]):\r\n    \"\"\"\r\n    @notice Peform a bad liquidation (or self-liquidation) of user if health is not good\r\n    @param min_x Minimal amount of stablecoin to receive (to avoid liquidators being sandwiched)\r\n    @param frac Fraction to liquidate; 100% = 10**18\r\n    @param use_eth Use wrapping/unwrapping if collateral is ETH\r\n    @param callbacker Address of the callback contract\r\n    @param callback_args Extra arguments for the callback (up to 5) such as min_amount etc\r\n    \"\"\"\r\n    discount: uint256 = 0\r\n    if user != msg.sender:\r\n        discount = self.liquidation_discounts[user]\r\n    self._liquidate(user, min_x, discount, min(frac, 10**18), use_eth, callbacker, callback_args)\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef tokens_to_liquidate(user: address, frac: uint256 = 10 ** 18) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount of stablecoins to have in liquidator's wallet to liquidate a user\r\n    @param user Address of the user to liquidate\r\n    @param frac Fraction to liquidate; 100% = 10**18\r\n    @return The amount of stablecoins needed\r\n    \"\"\"\r\n    health_limit: uint256 = 0\r\n    if user != msg.sender:\r\n        health_limit = self.liquidation_discounts[user]\r\n    stablecoins: uint256 = unsafe_div(AMM.get_sum_xy(user)[0] * self._get_f_remove(frac, health_limit), 10 ** 18)\r\n    debt: uint256 = unsafe_div(self._debt(user)[0] * frac, 10 ** 18)\r\n\r\n    return unsafe_sub(max(debt, stablecoins), stablecoins)\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef health(user: address, full: bool = False) -> int256:\r\n    \"\"\"\r\n    @notice Returns position health normalized to 1e18 for the user.\r\n            Liquidation starts when < 0, however devaluation of collateral doesn't cause liquidation\r\n    \"\"\"\r\n    return self._health(user, self._debt(user)[0], full, self.liquidation_discounts[user])\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef users_to_liquidate(_from: uint256=0, _limit: uint256=0) -> DynArray[Position, 1000]:\r\n    \"\"\"\r\n    @notice Returns a dynamic array of users who can be \"hard-liquidated\".\r\n            This method is designed for convenience of liquidation bots.\r\n    @param _from Loan index to start iteration from\r\n    @param _limit Number of loans to look over\r\n    @return Dynamic array with detailed info about positions of users\r\n    \"\"\"\r\n    n_loans: uint256 = self.n_loans\r\n    limit: uint256 = _limit\r\n    if _limit == 0:\r\n        limit = n_loans\r\n    ix: uint256 = _from\r\n    out: DynArray[Position, 1000] = []\r\n    for i in range(10**6):\r\n        if ix >= n_loans or i == limit:\r\n            break\r\n        user: address = self.loans[ix]\r\n        debt: uint256 = self._debt(user)[0]\r\n        health: int256 = self._health(user, debt, True, self.liquidation_discounts[user])\r\n        if health < 0:\r\n            xy: uint256[2] = AMM.get_sum_xy(user)\r\n            out.append(Position({\r\n                user: user,\r\n                x: xy[0],\r\n                y: xy[1],\r\n                debt: debt,\r\n                health: health\r\n            }))\r\n        ix += 1\r\n    return out\r\n\r\n\r\n# AMM has a nonreentrant decorator\r\n@view\r\n@external\r\ndef amm_price() -> uint256:\r\n    \"\"\"\r\n    @notice Current price from the AMM\r\n    \"\"\"\r\n    return AMM.get_p()\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef user_prices(user: address) -> uint256[2]:  # Upper, lower\r\n    \"\"\"\r\n    @notice Lowest price of the lower band and highest price of the upper band the user has deposit in the AMM\r\n    @param user User address\r\n    @return (upper_price, lower_price)\r\n    \"\"\"\r\n    assert AMM.has_liquidity(user)\r\n    ns: int256[2] = AMM.read_user_tick_numbers(user) # ns[1] > ns[0]\r\n    return [AMM.p_oracle_up(ns[0]), AMM.p_oracle_down(ns[1])]\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef user_state(user: address) -> uint256[4]:\r\n    \"\"\"\r\n    @notice Return the user state in one call\r\n    @param user User to return the state for\r\n    @return (collateral, stablecoin, debt, N)\r\n    \"\"\"\r\n    xy: uint256[2] = AMM.get_sum_xy(user)\r\n    ns: int256[2] = AMM.read_user_tick_numbers(user) # ns[1] > ns[0]\r\n    return [xy[1], xy[0], self._debt(user)[0], convert(unsafe_add(unsafe_sub(ns[1], ns[0]), 1), uint256)]\r\n\r\n\r\n# AMM has nonreentrant decorator\r\n@external\r\ndef set_amm_fee(fee: uint256):\r\n    \"\"\"\r\n    @notice Set the AMM fee (factory admin only)\r\n    @param fee The fee which should be no higher than MAX_FEE\r\n    \"\"\"\r\n    assert msg.sender == FACTORY.admin()\r\n    assert fee <= MAX_FEE and fee >= MIN_FEE, \"Fee\"\r\n    AMM.set_fee(fee)\r\n\r\n\r\n# AMM has nonreentrant decorator\r\n@external\r\ndef set_amm_admin_fee(fee: uint256):\r\n    \"\"\"\r\n    @notice Set AMM's admin fee\r\n    @param fee New admin fee (not higher than MAX_ADMIN_FEE)\r\n    \"\"\"\r\n    assert msg.sender == FACTORY.admin()\r\n    assert fee <= MAX_ADMIN_FEE, \"High fee\"\r\n    AMM.set_admin_fee(fee)\r\n\r\n\r\n@nonreentrant('lock')\r\n@external\r\ndef set_monetary_policy(monetary_policy: address):\r\n    \"\"\"\r\n    @notice Set monetary policy contract\r\n    @param monetary_policy Address of the monetary policy contract\r\n    \"\"\"\r\n    assert msg.sender == FACTORY.admin()\r\n    self.monetary_policy = MonetaryPolicy(monetary_policy)\r\n    MonetaryPolicy(monetary_policy).rate_write()\r\n    log SetMonetaryPolicy(monetary_policy)\r\n\r\n\r\n@nonreentrant('lock')\r\n@external\r\ndef set_borrowing_discounts(loan_discount: uint256, liquidation_discount: uint256):\r\n    \"\"\"\r\n    @notice Set discounts at which we can borrow (defines max LTV) and where bad liquidation starts\r\n    @param loan_discount Discount which defines LTV\r\n    @param liquidation_discount Discount where bad liquidation starts\r\n    \"\"\"\r\n    assert msg.sender == FACTORY.admin()\r\n    assert loan_discount > liquidation_discount\r\n    assert liquidation_discount >= MIN_LIQUIDATION_DISCOUNT\r\n    assert loan_discount <= MAX_LOAN_DISCOUNT\r\n    self.liquidation_discount = liquidation_discount\r\n    self.loan_discount = loan_discount\r\n    log SetBorrowingDiscounts(loan_discount, liquidation_discount)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_callback(cb: address):\r\n    \"\"\"\r\n    @notice Set liquidity mining callback\r\n    \"\"\"\r\n    assert msg.sender == FACTORY.admin()\r\n    AMM.set_callback(cb)\r\n\r\n\r\n@external\r\n@view\r\ndef admin_fees() -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount of fees obtained from the interest\r\n    \"\"\"\r\n    rate_mul: uint256 = AMM.get_rate_mul()\r\n    loan: Loan = self._total_debt\r\n    loan.initial_debt = loan.initial_debt * rate_mul / loan.rate_mul + self.redeemed\r\n    minted: uint256 = self.minted\r\n    return unsafe_sub(max(loan.initial_debt, minted), minted)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef collect_fees() -> uint256:\r\n    \"\"\"\r\n    @notice Collect the fees charged as interest\r\n            None of this fees are collected if factory has no fee_receiver - e.g. for lending\r\n            This is by design: lending does NOT earn interest, system makes money by using crvUSD\r\n    \"\"\"\r\n    # Calling fee_receiver will fail for lending markets because everything gets to lenders\r\n    _to: address = FACTORY.fee_receiver()\r\n    # AMM-based fees\r\n    borrowed_fees: uint256 = AMM.admin_fees_x()\r\n    collateral_fees: uint256 = AMM.admin_fees_y()\r\n    self.transferFrom(BORROWED_TOKEN, AMM.address, _to, borrowed_fees)\r\n    self.transferFrom(COLLATERAL_TOKEN, AMM.address, _to, collateral_fees)\r\n    AMM.reset_admin_fees()\r\n\r\n    # Borrowing-based fees\r\n    rate_mul: uint256 = AMM.get_rate_mul()\r\n    loan: Loan = self._total_debt\r\n    loan.initial_debt = loan.initial_debt * rate_mul / loan.rate_mul\r\n    loan.rate_mul = rate_mul\r\n    self._total_debt = loan\r\n\r\n    self._save_rate()\r\n\r\n    # Amount which would have been redeemed if all the debt was repaid now\r\n    to_be_redeemed: uint256 = loan.initial_debt + self.redeemed\r\n    # Amount which was minted when borrowing + all previously claimed admin fees\r\n    minted: uint256 = self.minted\r\n    # Difference between to_be_redeemed and minted amount is exactly due to interest charged\r\n    if to_be_redeemed > minted:\r\n        self.minted = to_be_redeemed\r\n        to_be_redeemed = unsafe_sub(to_be_redeemed, minted)  # Now this is the fees to charge\r\n        self.transfer(BORROWED_TOKEN, _to, to_be_redeemed)\r\n        log CollectFees(to_be_redeemed, loan.initial_debt)\r\n        return to_be_redeemed\r\n    else:\r\n        log CollectFees(0, loan.initial_debt)\r\n        return 0\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef check_lock() -> bool:\r\n    return True", "ABI": "[{\"name\":\"UserState\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"collateral\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"n1\",\"type\":\"int256\",\"indexed\":false},{\"name\":\"n2\",\"type\":\"int256\",\"indexed\":false},{\"name\":\"liquidation_discount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Borrow\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"collateral_increase\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loan_increase\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Repay\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"collateral_decrease\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loan_decrease\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveCollateral\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"collateral_decrease\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Liquidate\",\"inputs\":[{\"name\":\"liquidator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"collateral_received\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"stablecoin_received\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"debt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMonetaryPolicy\",\"inputs\":[{\"name\":\"monetary_policy\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetBorrowingDiscounts\",\"inputs\":[{\"name\":\"loan_discount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"liquidation_discount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CollectFees\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"collateral_token\",\"type\":\"address\"},{\"name\":\"monetary_policy\",\"type\":\"address\"},{\"name\":\"loan_discount\",\"type\":\"uint256\"},{\"name\":\"liquidation_discount\",\"type\":\"uint256\"},{\"name\":\"amm\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"amm\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"collateral_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"borrowed_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"save_rate\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"debt\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"loan_exists\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_debt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_borrowable\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_borrowable\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"},{\"name\":\"current_debt\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"min_collateral\",\"inputs\":[{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calculate_debt_n1\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_loan\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_loan_extended\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"N\",\"type\":\"uint256\"},{\"name\":\"callbacker\",\"type\":\"address\"},{\"name\":\"callback_args\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_collateral\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrow_more\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"borrow_more_extended\",\"inputs\":[{\"name\":\"collateral\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"callbacker\",\"type\":\"address\"},{\"name\":\"callback_args\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"_d_debt\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"_d_debt\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"_d_debt\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"max_active_band\",\"type\":\"int256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"_d_debt\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"max_active_band\",\"type\":\"int256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"repay_extended\",\"inputs\":[{\"name\":\"callbacker\",\"type\":\"address\"},{\"name\":\"callback_args\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"health_calculator\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"d_collateral\",\"type\":\"int256\"},{\"name\":\"d_debt\",\"type\":\"int256\"},{\"name\":\"full\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"health_calculator\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"d_collateral\",\"type\":\"int256\"},{\"name\":\"d_debt\",\"type\":\"int256\"},{\"name\":\"full\",\"type\":\"bool\"},{\"name\":\"N\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"liquidate\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"min_x\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"liquidate\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"min_x\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"liquidate_extended\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"min_x\",\"type\":\"uint256\"},{\"name\":\"frac\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"callbacker\",\"type\":\"address\"},{\"name\":\"callback_args\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokens_to_liquidate\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokens_to_liquidate\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"frac\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"health\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"health\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"full\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"users_to_liquidate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"health\",\"type\":\"int256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"users_to_liquidate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"health\",\"type\":\"int256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"users_to_liquidate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"debt\",\"type\":\"uint256\"},{\"name\":\"health\",\"type\":\"int256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"amm_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_prices\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_state\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_amm_fee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_amm_admin_fee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_monetary_policy\",\"inputs\":[{\"name\":\"monetary_policy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_borrowing_discounts\",\"inputs\":[{\"name\":\"loan_discount\",\"type\":\"uint256\"},{\"name\":\"liquidation_discount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_callback\",\"inputs\":[{\"name\":\"cb\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fees\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"collect_fees\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"check_lock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"liquidation_discounts\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"loans\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"loan_ix\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"n_loans\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minted\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"redeemed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"monetary_policy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"liquidation_discount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"loan_discount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "crvUSD Controller", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000062cd08cadabf473315d8953995de0dc0928b7d3c00000000000000000000000000000000000000000000000000e6ed27d6668000000000000000000000000000000000000000000000000000007c585087238004000000000000000000000000fcb53ed72dab68091aa6a2ab68b5116639ed8805", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}