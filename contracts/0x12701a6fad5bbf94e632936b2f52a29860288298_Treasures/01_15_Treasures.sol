// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
                  ``.-::://:::-.``                 
             `-/oydmmmmmmmmmmmmdyo/.`             
          `:ohmmdhysssssssssssyyhmmmho-`          
        .+ymmhyssssssssssssssssssssyhmmy+.        
      .+hNdysssssssssssssssydmysssssssymmy+.      
    `:smmyssssssssssssssshmMMMmsssssssssymms:     
   `+hNhssssssssssssssshNMMMMMMhsssssssssshNy+`   
  `/hNysssssssssssssydNMMMMMMMMNyssssssssssyNy+`  
  /yMhssssssssssssydMMMMMMMMMMMMdssssssssssshNy/  
 .ommsssssssssssydMMMMMMMMMMMMMMMysssssssssssmmo. 
 /yMysssssssssshMMMMMMMMMMMMMMMMMmsssssssssssyMy: 
 +hNsssssssssssdMMMMMMMMMMMMMMMMMMysssssssssssMh+ 
 +hNsssssssssssyMMMMMMMMMMMMMMMMMMdsssssssssssNh+ 
 +hMssssssssssssdMMMMMMMMMMMMMMMMMNsssssssssssMy/ 
 -sNhsssssssssssyMMMMMMMMMMMMMMMMNhsssssssssshNs- 
 `odNssssssssssssdMMMMMMMMMMMMMNhssssssssssssNd+` 
  -smdsssssssssssyNMMMMMMMMMMNhsssssssssssssmms-  
   :sNdssssssssssshMMMMMMMMmhssssssssssssssdms:   
    :smmyssssssssssmMMMMMmyssssssssssssssymms-    
     `+hNdsssssssssyMMNdysssssssssssssssdNh+`     
       -odNdysssssssyysssssssssssssssydNho-       
         -+ymmdyssssssssssssssssssydmmy+.         
           `-+ydmmddhyyyyyyyyhddmmdy+-`           
              ``-/+syhddddddhyy+/-.`              
                    ````..````                    

  /$$$$$$            /$$$$$$$  /$$   /$$                         /$$                   
 /$$$_  $$          | $$__  $$|__/  | $$                        |__/                   
| $$$$\ $$ /$$   /$$| $$  \ $$ /$$ /$$$$$$    /$$$$$$$  /$$$$$$  /$$ /$$$$$$$          
| $$ $$ $$|  $$ /$$/| $$$$$$$ | $$|_  $$_/   /$$_____/ /$$__  $$| $$| $$__  $$         
| $$\ $$$$ \  $$$$/ | $$__  $$| $$  | $$    | $$      | $$  \ $$| $$| $$  \ $$         
| $$ \ $$$  >$$  $$ | $$  \ $$| $$  | $$ /$$| $$      | $$  | $$| $$| $$  | $$         
|  $$$$$$/ /$$/\  $$| $$$$$$$/| $$  |  $$$$/|  $$$$$$$|  $$$$$$/| $$| $$  | $$         
 \______/ |__/  \__/|_______/ |__/   \___/   \_______/ \______/ |__/|__/  |__/         
 /$$$$$$$$                                                                             
|__  $$__/                                                                             
   | $$  /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$$ /$$   /$$  /$$$$$$   /$$$$$$   /$$$$$$$
   | $$ /$$__  $$ /$$__  $$ |____  $$ /$$_____/| $$  | $$ /$$__  $$ /$$__  $$ /$$_____/
   | $$| $$  \__/| $$$$$$$$  /$$$$$$$|  $$$$$$ | $$  | $$| $$  \__/| $$$$$$$$|  $$$$$$ 
   | $$| $$      | $$_____/ /$$__  $$ \____  $$| $$  | $$| $$      | $$_____/ \____  $$
   | $$| $$      |  $$$$$$$|  $$$$$$$ /$$$$$$$/|  $$$$$$/| $$      |  $$$$$$$ /$$$$$$$/
   |__/|__/       \_______/ \_______/|_______/  \______/ |__/       \_______/|_______/ 



 */

abstract contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;
}

contract Treasures is Context, ERC721Enumerable, ERC721Burnable, ApproveAndCallFallBack, Ownable {
    //// Random index assignment
    uint internal nonce = 0;
    uint public constant TOKEN_LIMIT = 1024;
    uint internal numTokens = 0;

    uint[TOKEN_LIMIT] internal indices;

    address private xbtc = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; 
    address private dev = 0x23aD59Cc6aFff2E508772F69D22b19FfEBf579e7; 
    address private guild = 0x167152A46E8616D4a6892A6AfD8E52F060151C70;
    
    uint256 private devFunds = 0;
    uint256 private guildFunds = 0;

    uint256 private _mintPrice;

    string private _baseTokenURI;
    bool public saleStarted = false;

    /**
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(string memory name, string memory symbol, string memory baseTokenURI,uint256 mintPrice) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        _mintPrice = mintPrice;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }   

    function randomIndex() internal returns (uint) {
        uint totalSize = TOKEN_LIMIT - numTokens;
        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
        uint value = 0;

        if (indices[index] != 0) {
            value = indices[index];
        } else {
            value = index;
        }

        // Move last value to selected position
        if (indices[totalSize - 1] == 0) {
            // Array position not initialized, so use position
            indices[index] = totalSize - 1;
        } else {
            // Array position holds a value so use that
            indices[index] = indices[totalSize - 1];
        }
        nonce++;
        // Don't allow a zero index, start counting at 1
        return value+1;
    }

    event Mint(uint256 tokenId);
    
    /**
     * @dev Creates a new token. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     * 
     */
    function mint(address from) internal returns (bool){
        require(saleStarted == true);

        //only 1024 treasures
        require(numTokens < TOKEN_LIMIT, 'all treasures minted');

        //receive payment
        require(IERC20(xbtc).transferFrom(from, address(this), _mintPrice), 'transfer failed');
        
        //keep 16 tokens "locked" inside the minted NFT
        uint256 toDistribute = _mintPrice - 1600000000;
        
        //90% of the payment goes to devs
        uint256 devFees = (toDistribute * 20 / 100);
        devFunds = devFunds + devFees;

        //the rest goes to the guild
        guildFunds = guildFunds + (toDistribute - devFees);

        uint id = randomIndex();

        _mint(from, id);

        numTokens = numTokens + 1;

        emit Mint(id);

        return true;
    }

    /**
     * @dev Withdraws funds to dev wallet and to miners guild
     *
     */
    function withdrawAndShare() public virtual {
        require(devFunds > 0 || guildFunds > 0 ,'nothing to withdraw');

        require(IERC20(xbtc).transfer(dev, devFunds),'transfer failed');
        devFunds = 0;

        require(IERC20(xbtc).transfer(guild, guildFunds),'transfer failed');
        guildFunds = 0;
    }

    /**
    * Deployer can start the sale once but cant stop it
    */
    function startSale() public virtual onlyOwner {
        require(saleStarted == false);
        saleStarted = true;
    }    

    /**
     * burns an NFT to get the token that was locked inside.
     * USE THIS FUNCTION AND DONT JUST CALL BURN()
     */
    function burnAndRedeemLockedToken(uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "Caller is not owner nor approved");
        _burn(tokenId);
        IERC20(xbtc).transfer(_msgSender(), 1600000000);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function getDevFunds() public view returns (uint256) {
        return devFunds;
    }

    function getGuildFunds() public view returns (uint256) {
        return guildFunds;
    }

    function getMintPrice() public view returns (uint256) {
        return _mintPrice;
    }

    function getMintedCounter() public view returns (uint256) {
        return numTokens;
    }
    
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public override   {
        require( token == xbtc );

        require( mint(from) );
    }

    // ------------------------------------------------------------------------

    // Don't accept ETH

    // ------------------------------------------------------------------------
    fallback() external payable { revert(); }
    receive() external payable { revert(); }
}