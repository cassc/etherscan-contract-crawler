{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (token/ERC20/extensions/ERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../../interfaces/IERC4626Upgradeable.sol\\\";\\nimport \\\"../../../utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC4626 \\\"Tokenized Vault Standard\\\" as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\\n *\\n * This extension allows the minting and burning of \\\"shares\\\" (represented using the ERC20 inheritance) in exchange for\\n * underlying \\\"assets\\\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\\n * the ERC20 standard. Any additional extensions included along it would affect the \\\"shares\\\" token represented by this\\n * contract and not the \\\"assets\\\" token which is an independent contract.\\n *\\n * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with\\n * a \\\"donation\\\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\\n * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by\\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\\n *\\n * _Available since v4.7._\\n */\\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\\n    using MathUpgradeable for uint256;\\n\\n    IERC20Upgradeable private _asset;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\\n     */\\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\\n        __ERC4626_init_unchained(asset_);\\n    }\\n\\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\\n        _decimals = success ? assetDecimals : super.decimals();\\n        _asset = asset_;\\n    }\\n\\n    /**\\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\\n     */\\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private view returns (bool, uint8) {\\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\\n        );\\n        if (success && encodedDecimals.length >= 32) {\\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\\n            if (returnedDecimals <= type(uint8).max) {\\n                return (true, uint8(returnedDecimals));\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\\n     * See {IERC20Metadata-decimals}.\\n     */\\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /** @dev See {IERC4626-asset}. */\\n    function asset() public view virtual override returns (address) {\\n        return address(_asset);\\n    }\\n\\n    /** @dev See {IERC4626-totalAssets}. */\\n    function totalAssets() public view virtual override returns (uint256) {\\n        return _asset.balanceOf(address(this));\\n    }\\n\\n    /** @dev See {IERC4626-convertToShares}. */\\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-convertToAssets}. */\\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxDeposit}. */\\n    function maxDeposit(address) public view virtual override returns (uint256) {\\n        return _isVaultCollateralized() ? type(uint256).max : 0;\\n    }\\n\\n    /** @dev See {IERC4626-maxMint}. */\\n    function maxMint(address) public view virtual override returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    /** @dev See {IERC4626-maxWithdraw}. */\\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxRedeem}. */\\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\\n        return balanceOf(owner);\\n    }\\n\\n    /** @dev See {IERC4626-previewDeposit}. */\\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-previewMint}. */\\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewWithdraw}. */\\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewRedeem}. */\\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-deposit}. */\\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\\n        require(assets <= maxDeposit(receiver), \\\"ERC4626: deposit more than max\\\");\\n\\n        uint256 shares = previewDeposit(assets);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-mint}.\\n     *\\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\\n     * In this case, the shares will be minted without requiring any assets to be deposited.\\n     */\\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\\n        require(shares <= maxMint(receiver), \\\"ERC4626: mint more than max\\\");\\n\\n        uint256 assets = previewMint(shares);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /** @dev See {IERC4626-withdraw}. */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(assets <= maxWithdraw(owner), \\\"ERC4626: withdraw more than max\\\");\\n\\n        uint256 shares = previewWithdraw(assets);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-redeem}. */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(shares <= maxRedeem(owner), \\\"ERC4626: redeem more than max\\\");\\n\\n        uint256 assets = previewRedeem(shares);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\\n     *\\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\\n     * would represent an infinite amount of shares.\\n     */\\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\\n        uint256 supply = totalSupply();\\n        return\\n            (assets == 0 || supply == 0)\\n                ? _initialConvertToShares(assets, rounding)\\n                : assets.mulDiv(supply, totalAssets(), rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\\n     */\\n    function _initialConvertToShares(\\n        uint256 assets,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 shares) {\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\\n     */\\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\\n        uint256 supply = totalSupply();\\n        return\\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\\n     */\\n    function _initialConvertToAssets(\\n        uint256 shares,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 assets) {\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Deposit/mint common workflow.\\n     */\\n    function _deposit(\\n        address caller,\\n        address receiver,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\\n        // assets are transferred and before the shares are minted, which is a valid state.\\n        // slither-disable-next-line reentrancy-no-eth\\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\\n        _mint(receiver, shares);\\n\\n        emit Deposit(caller, receiver, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Withdraw/redeem common workflow.\\n     */\\n    function _withdraw(\\n        address caller,\\n        address receiver,\\n        address owner,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        if (caller != owner) {\\n            _spendAllowance(owner, caller, shares);\\n        }\\n\\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\\n        // shares are burned and after the assets are transferred, which is a valid state.\\n        _burn(owner, shares);\\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\\n\\n        emit Withdraw(caller, receiver, owner, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Checks if vault is \\\"healthy\\\" in the sense of having assets backing the circulating shares.\\n     */\\n    function _isVaultCollateralized() private view returns (bool) {\\n        return totalAssets() > 0 || totalSupply() == 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/infiniteProxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_)\\n        external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_)\\n        external\\n        view\\n        returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./variables.sol\\\";\\nimport \\\"../../infiniteProxy/IProxy.sol\\\";\\n\\ncontract PrimaryHelpers is Variables {\\n    /***********************************|\\n    |              ERRORS               |\\n    |__________________________________*/\\n    error Helpers__UnsupportedProtocolId();\\n    error Helpers__NotRebalancer();\\n    error Helpers__Reentrant();\\n    error Helpers__EulerDisabled();\\n\\n\\n    /***********************************|\\n    |              MODIFIERS            |\\n    |__________________________________*/\\n    modifier onlyRebalancer() {\\n        if (\\n            !(isRebalancer[msg.sender] ||\\n                IProxy(address(this)).getAdmin() == msg.sender)\\n        ) {\\n            revert Helpers__NotRebalancer();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev reentrancy gaurd.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) revert Helpers__Reentrant();\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n}\\n\\ncontract Helpers is PrimaryHelpers {\\n    struct ProtocolAssetsInStETH {\\n        uint256 stETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct ProtocolAssetsInWstETH {\\n        uint256 wstETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct IdealBalances {\\n        uint256 stETH;\\n        uint256 wstETH;\\n        uint256 wETH;\\n    }\\n\\n    struct NetAssetsHelper {\\n        ProtocolAssetsInStETH aaveV2;\\n        ProtocolAssetsInWstETH aaveV3;\\n        ProtocolAssetsInWstETH compoundV3;\\n        ProtocolAssetsInWstETH euler;\\n        ProtocolAssetsInStETH morphoAaveV2;\\n        ProtocolAssetsInWstETH morphoAaveV3;\\n        ProtocolAssetsInWstETH spark;\\n        IdealBalances vaultBalances;\\n        IdealBalances dsaBalances;\\n    }\\n\\n\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = ((x * y) + RAY / 2) / RAY;\\n    }\\n\\n    /// @dev Executes the ray-based multiplication of 2 numbers, rounded down.\\n    /// @param x Ray.\\n    /// @param y Ray.\\n    /// @return z The result of x * y, in ray.\\n    function rayMulDown(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // Load the state variable into a local variable so it can be accessed to inline assembly\\n        uint256 maxUint = MAX_UINT256;\\n        // Overflow if\\n        //     x * y > type(uint256).max\\n        // <=> y > 0 and x > type(uint256).max / y\\n        assembly {\\n            if mul(y, gt(x, div(maxUint, y))) { revert(0, 0) }\\n\\n            z := div(mul(x, y), RAY)\\n        }\\n    }\\n\\n    /// @dev Executes the ray-based multiplication of 2 numbers, rounded up.\\n    /// @param x Ray.\\n    /// @param y Wad.\\n    /// @return z The result of x * y, in ray.\\n    function rayMulUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        uint256 maxUintMinusRayMinusOne = MAX_UINT256_MINUS_RAY_MINUS_ONE;\\n        uint256 rayMinusOne = RAY_MINUS_ONE;\\n        // Overflow if\\n        //     x * y + RAY_MINUS_ONE > type(uint256).max\\n        // <=> x * y > type(uint256).max - RAY_MINUS_ONE\\n        // <=> y > 0 and x > (type(uint256).max - RAY_MINUS_ONE) / y\\n        assembly {\\n            if mul(y, gt(x, div(maxUintMinusRayMinusOne, y))) { revert(0, 0) }\\n\\n            z := div(add(mul(x, y), rayMinusOne), RAY)\\n        }\\n    }\\n\\n    /// Returns ratio of Aave V2 in terms of `WETH` and `STETH`.\\n    function getRatioAaveV2()\\n        public\\n        view\\n        returns (uint256 stEthAmount_, uint256 ethAmount_, uint256 ratio_)\\n    {\\n        stEthAmount_ = IERC20(A_STETH_ADDRESS).balanceOf(address(vaultDSA));\\n        ethAmount_ = IERC20(D_WETH_ADDRESS).balanceOf(address(vaultDSA));\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Aave V3 in terms of `WETH` and `STETH`.\\n    function getRatioAaveV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = IERC20(A_WSTETH_ADDRESS_AAVEV3).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = IERC20(D_WETH_ADDRESS_AAVEV3).balanceOf(address(vaultDSA));\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Compound V3 in terms of `ETH` and `STETH`.\\n    function getRatioCompoundV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        ethAmount_ = COMP_ETH_MARKET_CONTRACT.borrowBalanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        ICompoundMarket.UserCollateral\\n            memory collateralData_ = COMP_ETH_MARKET_CONTRACT.userCollateral(\\n                address(vaultDSA),\\n                WSTETH_ADDRESS\\n            );\\n\\n        wstEthAmount_ = uint256(collateralData_.balance);\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Euler in terms of `ETH` and `STETH`.\\n    function getRatioEuler(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = 0;\\n        stEthAmount_ = 0;\\n        ethAmount_ = 0;\\n        ratio_ = 0;\\n\\n        // wstEthAmount_ = IEulerTokens(E_WSTETH_ADDRESS).balanceOfUnderlying(\\n        //     address(vaultDSA)\\n        // );\\n\\n        // if (stEthPerWsteth_ > 0) {\\n        //     // Convert wstETH collateral balance to stETH.\\n        //     stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        // } else {\\n        //     stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        // }\\n        // ethAmount_ = IEulerTokens(D_WETH_ADDRESS_EULER).balanceOf(\\n        //     address(vaultDSA)\\n        // );\\n\\n        // ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// Returns ratio of Morpho Aave in terms of `ETH` and `STETH`.\\n    function getRatioMorphoAaveV2()\\n        public\\n        view\\n        returns (\\n            uint256 stEthAmount_, // Aggreagted value of stETH in Pool and P2P\\n            uint256 stEthAmountPool_,\\n            uint256 stEthAmountP2P_,\\n            uint256 ethAmount_, // Aggreagted value of eth in Pool and P2P\\n            uint256 ethAmountPool_,\\n            uint256 ethAmountP2P_,\\n            uint256 ratio_\\n        )\\n    {\\n        // `supplyBalanceInOf` => The supply balance of a user. aToken -> user -> balances.\\n        IMorphoAaveV2.SupplyBalance memory supplyBalanceSteth_ = MORPHO_CONTRACT\\n            .supplyBalanceInOf(A_STETH_ADDRESS, address(vaultDSA));\\n\\n        // For a given market, the borrow balance of a user. aToken -> user -> balances.\\n        IMorphoAaveV2.BorrowBalance memory borrowBalanceWeth_ = MORPHO_CONTRACT\\n            .borrowBalanceInOf(\\n                A_WETH_ADDRESS, // aToken is used in mapping\\n                address(vaultDSA)\\n            );\\n\\n        stEthAmountPool_ = rmul(\\n            supplyBalanceSteth_.onPool,\\n            (MORPHO_CONTRACT.poolIndexes(A_STETH_ADDRESS).poolSupplyIndex)\\n        );\\n\\n        stEthAmountP2P_ = rmul(\\n            supplyBalanceSteth_.inP2P,\\n            MORPHO_CONTRACT.p2pSupplyIndex(A_STETH_ADDRESS)\\n        );\\n\\n        // Supply balance = (pool supply * pool supply index) + (p2p supply * p2p supply index)\\n        stEthAmount_ = stEthAmountPool_ + stEthAmountP2P_;\\n\\n        ethAmountPool_ = rmul(\\n            borrowBalanceWeth_.onPool,\\n            (MORPHO_CONTRACT.poolIndexes(A_WETH_ADDRESS).poolBorrowIndex)\\n        );\\n\\n        ethAmountP2P_ = rmul(\\n            borrowBalanceWeth_.inP2P,\\n            (MORPHO_CONTRACT.p2pBorrowIndex(A_WETH_ADDRESS))\\n        );\\n\\n        // Borrow balance = (pool borrow * pool borrow index) + (p2p borrow * p2p borrow index)\\n        ethAmount_ = ethAmountPool_ + ethAmountP2P_;\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @notice Returns the borrow balance in underlying in a given market.\\n    /// @param underlying_ The address of the underlying asset.\\n    /// @return totalBalance_ The total balance of the user (in underlying). Includes pool and P2P amounts.\\n    function borrowBalanceMorphoAaveV3(address underlying_)\\n        public\\n        view\\n        returns (uint256 totalBalance_)\\n    {\\n        IMorphoAaveV3.Indexes256 memory indexes_ = MORPHO_AAVE_V3.updatedIndexes(underlying_);\\n\\n        uint256 borrowedBalanceP2P_ = rayMulUp(\\n            MORPHO_AAVE_V3.scaledP2PBorrowBalance(underlying_, address(vaultDSA)),\\n            indexes_.borrow.p2pIndex\\n        );\\n\\n        uint256 borrowedBalancePool_ = rayMulUp(\\n            MORPHO_AAVE_V3.scaledPoolBorrowBalance(underlying_, address(vaultDSA)),\\n            indexes_.borrow.poolIndex\\n        );\\n\\n        // Includes Pool and P2P amounts.\\n        totalBalance_ = borrowedBalanceP2P_ + borrowedBalancePool_;\\n    }\\n\\n    /// @notice Returns the supply collateral balance on the `underlying` market (in underlying).\\n    /// @param underlying_ The address of the underlying asset.\\n    function collateralBalanceMorphoAaveV3(address underlying_)\\n        public\\n        view\\n        returns (uint256 collateralBalance_)\\n    {\\n        IMorphoAaveV3.Indexes256 memory indexes_ = MORPHO_AAVE_V3.updatedIndexes(underlying_);\\n\\n        collateralBalance_ = rayMulDown(\\n            MORPHO_AAVE_V3.scaledCollateralBalance(underlying_, address(vaultDSA)),\\n            indexes_.supply.poolIndex\\n        );\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Morpho Aave V3 in terms of `WETH` and `STETH`.\\n    function getRatioMorphoAaveV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = collateralBalanceMorphoAaveV3(WSTETH_ADDRESS);\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = borrowBalanceMorphoAaveV3(WETH_ADDRESS);\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Spark in terms of `WETH` and `STETH`.\\n    function getRatioSpark(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = IERC20(SP_WSTETH_ADDRESS_SPARK).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = IERC20(D_WETH_ADDRESS_SPARK).balanceOf(address(vaultDSA));\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    function getProtocolRatio(\\n        uint8 protocolId_\\n    ) public view returns (uint256 ratio_) {\\n        if (protocolId_ == 1) {\\n            // stETH based protocol\\n            (, , ratio_) = getRatioAaveV2();\\n        } else if (protocolId_ == 2) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioAaveV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 3) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioCompoundV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 4) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioEuler(stEthPerWsteth_);\\n        } else if (protocolId_ == 5) {\\n            // stETH based protocol\\n            (, , , , , , ratio_) = getRatioMorphoAaveV2();\\n        } else if (protocolId_ == 6) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioMorphoAaveV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 7) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioSpark(stEthPerWsteth_);\\n        } else {\\n            revert Helpers__UnsupportedProtocolId();\\n        }\\n    }\\n\\n    function getNetAssets()\\n        public\\n        view\\n        returns (\\n            uint256 totalAssets_, // Total assets(collaterals + ideal balances) inlcuding reveune\\n            uint256 totalDebt_, // Total debt\\n            uint256 netAssets_, // Total assets - Total debt - Reveune\\n            uint256 aggregatedRatio_, // Aggregated ratio of vault (Total debt/ (Total assets - revenue))\\n            NetAssetsHelper memory assets_\\n        )\\n    {\\n        uint256 stETHPerWstETH_ = WSTETH_CONTRACT.stEthPerToken();\\n\\n        // Calculate collateral and debt values for all the protocols\\n\\n        // stETH based protocols\\n        (assets_.aaveV2.stETH, assets_.aaveV2.wETH, ) = getRatioAaveV2();\\n\\n        (\\n            assets_.morphoAaveV2.stETH,\\n            ,\\n            ,\\n            assets_.morphoAaveV2.wETH,\\n            ,\\n            ,\\n\\n        ) = getRatioMorphoAaveV2();\\n\\n        // wstETH based protocols\\n        (assets_.aaveV3.wstETH, , assets_.aaveV3.wETH, ) = getRatioAaveV3(\\n            stETHPerWstETH_\\n        );\\n\\n        (\\n            assets_.compoundV3.wstETH,\\n            ,\\n            assets_.compoundV3.wETH,\\n\\n        ) = getRatioCompoundV3(stETHPerWstETH_);\\n\\n        (assets_.euler.wstETH, , assets_.euler.wETH, ) = getRatioEuler(\\n            stETHPerWstETH_\\n        );\\n\\n        // wstETH based protocols\\n        (assets_.morphoAaveV3.wstETH, , assets_.morphoAaveV3.wETH, ) = getRatioMorphoAaveV3(\\n            stETHPerWstETH_\\n        );\\n\\n        // wstETH based protocols\\n        (assets_.spark.wstETH, , assets_.spark.wETH, ) = getRatioSpark(\\n            stETHPerWstETH_\\n        );\\n\\n        // Ideal wstETH balances in vault and DSA\\n        assets_.vaultBalances.wstETH = IERC20(WSTETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.wstETH = IERC20(WSTETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Ideal stETH balances in vault and DSA\\n        assets_.vaultBalances.stETH = IERC20(STETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.stETH = IERC20(STETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Ideal wETH balances in vault and DSA\\n        assets_.vaultBalances.wETH = IERC20(WETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.wETH = IERC20(WETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Aggregating total wstETH\\n        uint256 totalWstETH_ = // Protocols\\n            assets_.aaveV3.wstETH +\\n            assets_.compoundV3.wstETH +\\n            assets_.euler.wstETH +\\n            assets_.morphoAaveV3.wstETH +\\n            assets_.spark.wstETH +\\n            // Ideal balances\\n            assets_.vaultBalances.wstETH +\\n            assets_.dsaBalances.wstETH;\\n\\n        // Net assets are always calculated as STETH supplied - ETH borrowed.\\n\\n        // Convert all wstETH to stETH to get the same base token.\\n        uint256 convertedStETH = IWstETH(WSTETH_ADDRESS).getStETHByWstETH(\\n            totalWstETH_\\n        );\\n\\n        // Aggregating total stETH + wETH including revenue\\n        totalAssets_ =\\n            // Protocol stETH collateral\\n            assets_.vaultBalances.stETH +\\n            assets_.dsaBalances.stETH +\\n            assets_.aaveV2.stETH +\\n            assets_.morphoAaveV2.stETH +\\n            convertedStETH +\\n            // Ideal wETH balance and assuming wETH 1:1 stETH\\n            assets_.vaultBalances.wETH +\\n            assets_.dsaBalances.wETH +\\n            // Lido queued withdraw assets\\n            queuedWithdrawStEth;\\n\\n        // Aggregating total wETH debt from protocols\\n        totalDebt_ =\\n            assets_.aaveV2.wETH +\\n            assets_.aaveV3.wETH +\\n            assets_.compoundV3.wETH +\\n            assets_.morphoAaveV2.wETH +\\n            assets_.euler.wETH +\\n            assets_.morphoAaveV3.wETH +\\n            assets_.spark.wETH;\\n\\n        netAssets_ = totalAssets_ - totalDebt_ - revenue; // Assuming wETH 1:1 stETH\\n        aggregatedRatio_ = totalAssets_ == 0\\n            ? 0\\n            : ((totalDebt_ * 1e6) / (totalAssets_ - revenue));\\n    }\\n\\n    /// @notice calculates the withdraw fee: max(percentage amount, absolute amount)\\n    /// @param stETHAmount_ the amount of assets being withdrawn\\n    /// @return the withdraw fee amount in assets\\n    function getWithdrawFee(\\n        uint256 stETHAmount_\\n    ) public view returns (uint256) {\\n        // percentage is in 1e4(1% is 10_000) here we want to have 100% as denominator\\n        uint256 withdrawFee = (stETHAmount_ * withdrawalFeePercentage) / 1e6;\\n\\n        if (withdrawFeeAbsoluteMin > withdrawFee) {\\n            return withdrawFeeAbsoluteMin;\\n        }\\n        return withdrawFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n\\n    function transfer(address, uint) external;\\n\\n    function transferFrom(address, address, uint) external;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function decimals() external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n}\\n\\ninterface IInstaIndex {\\n    function build(\\n        address owner_,\\n        uint256 accountVersion_,\\n        address origin_\\n    ) external returns (address account_);\\n}\\n\\ninterface IDSA {\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32);\\n}\\n\\ninterface IWstETH {\\n    function tokensPerStEth() external view returns (uint256);\\n\\n    function getStETHByWstETH(\\n        uint256 _wstETHAmount\\n    ) external view returns (uint256);\\n\\n    function getWstETHByStETH(\\n        uint256 _stETHAmount\\n    ) external view returns (uint256);\\n\\n    function stEthPerToken() external view returns (uint256);\\n}\\n\\ninterface ICompoundMarket {\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    function borrowBalanceOf(address account) external view returns (uint256);\\n\\n    function userCollateral(\\n        address,\\n        address\\n    ) external view returns (UserCollateral memory);\\n}\\n\\ninterface IEulerTokens {\\n    function balanceOfUnderlying(\\n        address account\\n    ) external view returns (uint256); //To be used for E-Tokens\\n\\n    function balanceOf(address) external view returns (uint256); //To be used for D-Tokens\\n}\\n\\ninterface ILiteVaultV1 {\\n    function deleverageAndWithdraw(\\n        uint256 deleverageAmt_,\\n        uint256 withdrawAmount_,\\n        address to_\\n    ) external;\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n}\\n\\ninterface IAavePoolProviderInterface {\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IAavePool {\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256); // Returns underlying amount withdrawn.\\n}\\n\\ninterface IMorphoAaveV2 {\\n    struct PoolIndexes {\\n        uint32 lastUpdateTimestamp; // The last time the local pool and peer-to-peer indexes were updated.\\n        uint112 poolSupplyIndex; // Last pool supply index. Note that for the stEth market, the pool supply index is tweaked to take into account the staking rewards.\\n        uint112 poolBorrowIndex; // Last pool borrow index. Note that for the stEth market, the pool borrow index is tweaked to take into account the staking rewards.\\n    }\\n\\n    function poolIndexes(address) external view returns (PoolIndexes memory);\\n\\n    // Current index from supply peer-to-peer unit to underlying (in ray).\\n    function p2pSupplyIndex(address) external view returns (uint256);\\n\\n    // Current index from borrow peer-to-peer unit to underlying (in ray).\\n    function p2pBorrowIndex(address) external view returns (uint256);\\n\\n    struct SupplyBalance {\\n        uint256 inP2P; // In peer-to-peer supply scaled unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\\n        uint256 onPool; // In pool supply scaled unit. Multiply by the pool supply index to get the underlying amount.\\n    }\\n\\n    struct BorrowBalance {\\n        uint256 inP2P; // In peer-to-peer borrow scaled unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\\n        uint256 onPool; // In pool borrow scaled unit, a unit that grows in value, to keep track of the debt increase when borrowers are on Aave. Multiply by the pool borrow index to get the underlying amount.\\n    }\\n\\n    // For a given market, the supply balance of a user. aToken -> user -> balances.\\n    function supplyBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (SupplyBalance memory);\\n\\n    // For a given market, the borrow balance of a user. aToken -> user -> balances.\\n    function borrowBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (BorrowBalance memory);\\n\\n    /// @notice Updates the peer-to-peer indexes and pool indexes (only stored locally).\\n    function updateIndexes(address _poolToken) external;\\n}\\n\\ninterface ILidoWithdrawalQueue {\\n    // code below from Lido WithdrawalQueueBase.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueueBase.sol\\n\\n    /// @notice output format struct for `_getWithdrawalStatus()` method\\n    struct WithdrawalRequestStatus {\\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\\n        uint256 amountOfStETH;\\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\\n        uint256 amountOfShares;\\n        /// @notice address that can claim or transfer this request\\n        address owner;\\n        /// @notice timestamp of when the request was created, in seconds\\n        uint256 timestamp;\\n        /// @notice true, if request is finalized\\n        bool isFinalized;\\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\\n        bool isClaimed;\\n    }\\n\\n    /// @notice length of the checkpoints. Last possible value for the claim hint\\n    function getLastCheckpointIndex() external view returns (uint256);\\n\\n    // code below from Lido WithdrawalQueue.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueue.sol\\n\\n    /// @notice Request the sequence of stETH withdrawals according to passed `withdrawalRequestInputs` data\\n    /// @param amounts an array of stETH amount values. The standalone withdrawal request will\\n    ///  be created for each item in the passed list.\\n    /// @param _owner address that will be able to transfer or claim the request.\\n    ///  If `owner` is set to `address(0)`, `msg.sender` will be used as owner.\\n    /// @return requestIds an array of the created withdrawal requests\\n    function requestWithdrawals(\\n        uint256[] calldata amounts,\\n        address _owner\\n    ) external returns (uint256[] memory requestIds);\\n\\n    /// @notice Claim one`_requestId` request once finalized sending locked ether to the owner\\n    /// @param _requestId request id to claim\\n    /// @dev use unbounded loop to find a hint, which can lead to OOG\\n    /// @dev\\n    ///  Reverts if requestId or hint are not valid\\n    ///  Reverts if request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of request\\n    function claimWithdrawal(uint256 _requestId) external;\\n\\n    /// @notice Claim a batch of withdrawal requests once finalized (claimable) sending locked ether to the owner\\n    /// @param _requestIds array of request ids to claim\\n    /// @param _hints checkpoint hint for each id.\\n    ///   Can be retrieved with `findCheckpointHints()`\\n    /// @dev\\n    ///  Reverts if any requestId or hint in arguments are not valid\\n    ///  Reverts if any request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of the requests\\n    function claimWithdrawals(\\n        uint256[] calldata _requestIds,\\n        uint256[] calldata _hints\\n    ) external;\\n\\n    /// @notice Returns all withdrawal requests that belongs to the `_owner` address\\n    ///\\n    /// WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n    /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n    /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n    /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n    function getWithdrawalRequests(\\n        address _owner\\n    ) external view returns (uint256[] memory requestsIds);\\n\\n    /// @notice Finds the list of hints for the given `_requestIds` searching among the checkpoints with indices\\n    ///  in the range  `[_firstIndex, _lastIndex]`. NB! Array of request ids should be sorted\\n    /// @param _requestIds ids of the requests sorted in the ascending order to get hints for\\n    /// @param _firstIndex left boundary of the search range\\n    /// @param _lastIndex right boundary of the search range\\n    /// @return hintIds the hints for `claimWithdrawal` to find the checkpoint for the passed request ids\\n    function findCheckpointHints(\\n        uint256[] calldata _requestIds,\\n        uint256 _firstIndex,\\n        uint256 _lastIndex\\n    ) external view returns (uint256[] memory hintIds);\\n\\n    /// @notice Returns statuses for the array of request ids\\n    /// @param _requestIds array of withdrawal request ids\\n    function getWithdrawalStatus(\\n        uint256[] calldata _requestIds\\n    ) external view returns (WithdrawalRequestStatus[] memory statuses);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n}\\n\\ninterface IWeth {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n}\\n\\ninterface IMorphoAaveV3 {\\n    function marketsCreated() external view returns (address[] memory);\\n\\n    /// @notice Contains the market side indexes as uint256 instead of uint128.\\n    struct MarketSideIndexes256 {\\n        uint256 poolIndex; // The pool index (in ray).\\n        uint256 p2pIndex; // The peer-to-peer index (in ray).\\n    }\\n\\n    /// @notice Contains the indexes as uint256 instead of uint128.\\n    struct Indexes256 {\\n        MarketSideIndexes256 supply; // The `MarketSideIndexes` related to the supply as uint256.\\n        MarketSideIndexes256 borrow; // The `MarketSideIndexes` related to the borrow as uint256.\\n    }\\n\\n    /// @notice Returns the updated indexes (peer-to-peer and pool).\\n    function updatedIndexes(address underlying) external view returns (Indexes256 memory);\\n\\n    /// @notice Returns the total borrow balance of `user` on the `underlying` market (in underlying).\\n    function borrowBalance(address underlying, address user) external view returns (uint256);\\n\\n    /// @notice Returns the supply collateral balance of `user` on the `underlying` market (in underlying).\\n    function collateralBalance(address underlying, address user) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, supplied on pool & used as collateral (with `underlying` decimals).\\n    function scaledCollateralBalance(address underlying, address user) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed peer-to-peer (with `underlying` decimals).\\n    function scaledP2PBorrowBalance(address underlying, address user) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed from pool (with `underlying` decimals).\\n    function scaledPoolBorrowBalance(address underlying, address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ERC4626Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n\\n/// @title      Variables\\n/// @notice     Contains common storage variables of all modules of Infinite proxy.\\ncontract ConstantVariables {\\n    uint256 internal constant RAY = 10**27;\\n    uint256 internal constant MAX_UINT256 = type(uint256).max;\\n    uint256 internal constant RAY_MINUS_ONE = RAY - 1;\\n    uint256 internal constant MAX_UINT256_MINUS_RAY_MINUS_ONE = MAX_UINT256 - RAY_MINUS_ONE;\\n\\n    uint256 internal constant MORPHO_V3_MAX_ITERATIONS = 10;\\n\\n    IInstaIndex internal constant INSTA_INDEX_CONTRACT =\\n        IInstaIndex(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\\n    address internal constant IETH_TOKEN_V1 =\\n        0xc383a3833A87009fD9597F8184979AF5eDFad019;\\n\\n    /***********************************|\\n    |           STETH ADDRESSES         |\\n    |__________________________________*/\\n    address internal constant STETH_ADDRESS =\\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n    // IERC20 internal constant STETH_CONTRACT = IERC20(STETH_ADDRESS);\\n    address internal constant A_STETH_ADDRESS =\\n        0x1982b2F5814301d4e9a8b0201555376e62F82428;\\n\\n    /***********************************|\\n    |           WSTETH ADDRESSES        |\\n    |__________________________________*/\\n    address internal constant WSTETH_ADDRESS =\\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n    IWstETH internal constant WSTETH_CONTRACT = IWstETH(WSTETH_ADDRESS);\\n    address internal constant A_WSTETH_ADDRESS_AAVEV3 =\\n        0x0B925eD163218f6662a35e0f0371Ac234f9E9371;\\n    address internal constant E_WSTETH_ADDRESS =\\n        0xbd1bd5C956684f7EB79DA40f582cbE1373A1D593;\\n    address internal constant SP_WSTETH_ADDRESS_SPARK =\\n        0x12B54025C112Aa61fAce2CDB7118740875A566E9;\\n\\n    /***********************************|\\n    |           ETH ADDRESSES           |\\n    |__________________________________*/\\n    address internal constant ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant WETH_ADDRESS =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant A_WETH_ADDRESS =\\n        0x030bA81f1c18d280636F32af80b9AAd02Cf0854e;\\n    address internal constant D_WETH_ADDRESS =\\n        0xF63B34710400CAd3e044cFfDcAb00a0f32E33eCf;\\n    address internal constant D_WETH_ADDRESS_AAVEV3 =\\n        0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\\n    address internal constant D_WETH_ADDRESS_EULER =\\n        0x62e28f054efc24b26A794F5C1249B6349454352C;\\n    address internal constant D_WETH_ADDRESS_SPARK =\\n        0x2e7576042566f8D6990e07A1B61Ad1efd86Ae70d;\\n\\n    address internal constant COMP_ETH_MARKET_ADDRESS =\\n        0xA17581A9E3356d9A858b789D68B4d866e593aE94;\\n\\n    ILiteVaultV1 internal constant LITE_VAULT_V1 = ILiteVaultV1(IETH_TOKEN_V1);\\n\\n    ICompoundMarket internal constant COMP_ETH_MARKET_CONTRACT =\\n        ICompoundMarket(COMP_ETH_MARKET_ADDRESS);\\n\\n    IMorphoAaveV2 internal constant MORPHO_CONTRACT =\\n        IMorphoAaveV2(0x777777c9898D384F785Ee44Acfe945efDFf5f3E0);\\n\\n    IAavePoolProviderInterface internal constant AAVE_POOL_PROVIDER =\\n        IAavePoolProviderInterface(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n\\n    ILidoWithdrawalQueue internal constant LIDO_WITHDRAWAL_QUEUE =\\n        ILidoWithdrawalQueue(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\\n\\n    IMorphoAaveV3 internal constant MORPHO_AAVE_V3 =\\n        IMorphoAaveV3(0x33333aea097c193e66081E930c33020272b33333);\\n}\\n\\ncontract Variables is ERC4626Upgradeable, ConstantVariables {\\n    /****************************************************************************|\\n    |   @notice Ids associated with protocols at the time of deployment.         |\\n    |   New protocols might have been added or removed at the time of viewing.   |\\n    |                          AAVE_V2 => 1                                      |\\n    |                          AAVE_V3 => 2                                      |\\n    |                          COMPOUND_V3 => 3                                  |\\n    |                          EULER => 4 // Disabled                            |\\n    |                          MORPHO_AAVE_V2 => 5                               |\\n    |                          MORPHO_AAVE_V3 => 6                               |\\n    |                          SPARK => 7                                      |\\n    |___________________________________________________________________________*/\\n\\n    /***********************************|\\n    |           STATE VARIABLES         |\\n    |__________________________________*/\\n    /*\\n     * Includes variables from ERC4626Upgradeable\\n     */\\n\\n    /// @notice variables.sol is imported in all the files. Adding _disableInitializers() so the implementation can't be manipulated\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    // 1: open; 2: closed\\n    uint8 internal _status;\\n\\n    IDSA public vaultDSA;\\n\\n    /// @notice Max limit (in wei) allowed for wsteth per eth unit amount.\\n    uint256 public leverageMaxUnitAmountLimit;\\n\\n    /// @notice Secondary auth that only has the power to reduce max risk ratio.\\n    address public secondaryAuth;\\n\\n    // Current exchange price.\\n    uint256 public exchangePrice;\\n\\n    // Revenue exchange price (helps in calculating revenue).\\n    // Exchange price when revenue got updated last. It'll only increase overtime.\\n    uint256 public revenueExchangePrice;\\n\\n    /// @notice mapping to store allowed rebalancers\\n    ///         modifiable by auth\\n    mapping(address => bool) public isRebalancer;\\n\\n    // Mapping of protocol id => max risk ratio, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    // 1 = Aave v2\\n    // 2 = Aave v3\\n    // 3 = Compound v3 (ETH market)\\n    // 4 = Euler // Disabled\\n    // 5 = Morpho Aave v2\\n    // 6 = Morpho Aave v3\\n    // 7 = Spark\\n    mapping(uint8 => uint256) public maxRiskRatio;\\n\\n    // Max aggregated risk ratio of the vault that can be reached, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    uint256 public aggrMaxVaultRatio;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the percentage in 1e6\\n    /// this number is given in 1e4, i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    /// modifiable by owner\\n    uint256 public withdrawalFeePercentage;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the absolute minimum\\n    /// this number is given in decimals for the respective asset of the vault.\\n    /// modifiable by owner\\n    uint256 public withdrawFeeAbsoluteMin; // in underlying base asset, i.e. stEth\\n\\n    // charge from the profits, scaled to factor 4.\\n    // 100,000 would be 10% cut from profit\\n    uint256 public revenueFeePercentage;\\n\\n    /// @notice Stores profit revenue and withdrawal fees collected.\\n    uint256 public revenue;\\n\\n    /// @notice Revenue will be transffered to this address upon collection.\\n    address public treasury;\\n\\n    /// @notice Tracker for amount of stETH queued for withdrawal.\\n    uint256 public queuedWithdrawStEth;\\n}\\n\"\r\n    },\r\n    \"contracts/vault/modules/rebalancerModule/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract Events {\\n    /// @notice Emitted when stETH is deposited from vault to protocols.\\n    event LogVaultToProtocolDeposit(\\n        uint8 indexed protocol,\\n        uint256 depositAmount\\n    );\\n\\n    /// @notice Emitted whenever stETH is deposited from protocol\\n    /// to vault to craete withdrawal vaialability.\\n    event LogFillVaultAvailability(\\n        uint8 indexed protocol,\\n        uint256 withdrawAmount\\n    );\\n\\n    /// @notice Emitted whenever ideal Weth DSA balance is swapped to stETH.\\n    event LogWethSweep(uint256 wethAmount);\\n\\n    /// @notice Emitted whenever ideal Eth DSA balance is swapped to stETH.\\n    event LogEthSweep(uint256 ethAmount);\\n\\n    /// @notice Emitted whenever revenue is collected.\\n    event LogCollectRevenue(uint256 amount, address indexed to);\\n\\n    /// @notice Emitted whenever exchange price is updated.\\n    event LogUpdateExchangePrice(\\n        uint256 indexed exchangePriceBefore,\\n        uint256 indexed exchangePriceAfter\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/vault/modules/rebalancerModule/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../common/helpers.sol\\\";\\n\\nimport \\\"./events.sol\\\";\\n\\n/// @title RebalancerModule\\n/// @dev Actions are executable by allowed rebalancers only\\ncontract RebalancerModule is Helpers, Events {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    /***********************************|\\n    |              ERRORS               |\\n    |__________________________________*/\\n    // Revert if protocol ratio after withdraw is more than max risk ratio.\\n    error RebalancerModule__VaultUnsafeAfterWithdraw();\\n    error RebalancerModule__NotValidDepositAmount();\\n    error RebalancerModule__NotValidWithdrawAmount();\\n    error RebalancerModule__AggregatedRatioExceeded();\\n    error RebalancerModule__InvalidSweepAmount();\\n    error RebalancerModule__NotValidCollectReveuneAmount();\\n    error RebalancerModule__CollectReveuneAmountIsHigh();\\n\\n    /***********************************|\\n    |          REBALANCER CORE          |\\n    |__________________________________*/\\n    /// @notice Deposits assets from the Vault to Protocol.\\n    /// Moves asset from vault\\n    /// @param protocolId_ Protocol Id in which stETH will be deposited.\\n    /// @param depositAmount_ stETH amount to deposit.\\n    /// Note Users can only deposit and withdraw `STETH` from the vault.\\n    function vaultToProtocolDeposit(uint8 protocolId_, uint256 depositAmount_)\\n        external\\n        nonReentrant\\n        onlyRebalancer\\n    {\\n        if (protocolId_ == 4) {\\n            revert Helpers__EulerDisabled();\\n        }\\n\\n        if (depositAmount_ == 0)\\n            revert RebalancerModule__NotValidDepositAmount();\\n\\n        if (depositAmount_ == type(uint256).max) {\\n            depositAmount_ = IERC20Upgradeable(STETH_ADDRESS).balanceOf(\\n                address(this)\\n            );\\n        }\\n\\n        IERC20Upgradeable(STETH_ADDRESS).safeTransfer(\\n            address(vaultDSA),\\n            depositAmount_\\n        );\\n\\n        uint256 spellCount_;\\n        uint256 spellIndex_;\\n\\n        if (protocolId_ == 1 || protocolId_ == 5) {\\n            spellCount_ = 1;\\n        } else {\\n            spellCount_ = 2;\\n        }\\n\\n        string[] memory targets_ = new string[](spellCount_);\\n        bytes[] memory calldatas_ = new bytes[](spellCount_);\\n\\n        // Note Depositing max amount from DSA to protocol to deposit any ideal (if remaining) in the vault.\\n\\n        // Protocol 2, 3, 4, 6 & 7 support wstETH; So converting stETH into wstETH before depositing\\n        if (\\n            protocolId_ == 2 \\n            || protocolId_ == 3 \\n            || protocolId_ == 4 \\n            || protocolId_ == 6 \\n            || protocolId_ == 7\\n        ) {\\n            targets_[spellIndex_] = \\\"WSTETH-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(uint256,uint256,uint256)\\\",\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n\\n            spellIndex_++;\\n        }\\n\\n        if (protocolId_ == 1) {\\n            targets_[spellIndex_] = \\\"AAVE-V2-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                STETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 2) {\\n            targets_[spellIndex_] = \\\"AAVE-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 3) {\\n            targets_[spellIndex_] = \\\"COMPOUND-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                COMP_ETH_MARKET_ADDRESS,\\n                WSTETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 4) {\\n            targets_[spellIndex_] = \\\"EULER-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(uint256,address,uint256,bool,uint256,uint256)\\\",\\n                0,\\n                WSTETH_ADDRESS,\\n                type(uint256).max,\\n                true,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 5) {\\n            targets_[spellIndex_] = \\\"MORPHO-AAVE-V2-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(address,address,uint256,uint256,uint256)\\\",\\n                STETH_ADDRESS,\\n                A_STETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 6) {\\n            targets_[spellIndex_] = \\\"MORPHO-AAVE-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"depositCollateral(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 7) {\\n            targets_[spellIndex_] = \\\"SPARK-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"deposit(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n        }\\n\\n        vaultDSA.cast(targets_, calldatas_, address(this));\\n\\n        /// Note: No need for checking end ratio here since deposit will always make the ratio less.\\n\\n        emit LogVaultToProtocolDeposit(protocolId_, depositAmount_);\\n    }\\n\\n    /// @notice Fills vault with `STETH` withdrawal availability.\\n    /// @param protocolId_ Protocol id from which amount will be withdrawn.\\n    /// @param withdrawAmount_ stEth amount to withdraw based on the protocol.\\n    /// Note Only keeping STETH in the withdrawal to avoid complexity and follow ERC4626 standards properly.\\n    function fillVaultAvailability(uint8 protocolId_, uint256 withdrawAmount_)\\n        external\\n        nonReentrant\\n        onlyRebalancer\\n    {\\n        if (protocolId_ == 4) {\\n            revert Helpers__EulerDisabled();\\n        }\\n\\n        if (withdrawAmount_ == 0)\\n            revert RebalancerModule__NotValidWithdrawAmount();\\n\\n        uint256 spellIndex_;\\n        uint256 spellCount_;\\n        uint256 wstethPerSteth_ = WSTETH_CONTRACT.tokensPerStEth();\\n        uint256 internalWithdrawAmount_;\\n\\n        if (protocolId_ == 1 || protocolId_ == 5) {\\n            spellCount_ = 2;\\n            internalWithdrawAmount_ = withdrawAmount_;\\n        } else {\\n            spellCount_ = 3;\\n\\n            // Note withdraw amount will always be in stETH.\\n            // Converting stETH to wstETH for wstETH based protocols.\\n            internalWithdrawAmount_ =\\n                (withdrawAmount_ * wstethPerSteth_) /\\n                1e18;\\n        }\\n\\n        string[] memory targets_ = new string[](spellCount_);\\n        bytes[] memory calldatas_ = new bytes[](spellCount_);\\n\\n        if (protocolId_ == 1) {\\n            // stETH based protocol\\n            targets_[spellIndex_] = \\\"AAVE-V2-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                STETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 2) {\\n            // wstETH based protocol\\n            targets_[spellIndex_] = \\\"AAVE-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 3) {\\n            // wstETH based protocol\\n            targets_[spellIndex_] = \\\"COMPOUND-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                COMP_ETH_MARKET_ADDRESS,\\n                WSTETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 4) {\\n            // wstETH based protocol\\n            targets_[spellIndex_] = \\\"EULER-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(uint256,address,uint256,uint256,uint256)\\\",\\n                0,\\n                WSTETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 5) {\\n            // stETH based protocol\\n            targets_[spellIndex_] = \\\"MORPHO-AAVE-V2-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(address,address,uint256,uint256,uint256)\\\",\\n                STETH_ADDRESS,\\n                A_STETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 6) {\\n            // wstETH based protocol\\n            targets_[spellIndex_] = \\\"MORPHO-AAVE-V3-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdrawCollateral(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        } else if (protocolId_ == 7) {\\n            // wstETH based protocol\\n            targets_[spellIndex_] = \\\"SPARK-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(address,uint256,uint256,uint256)\\\",\\n                WSTETH_ADDRESS,\\n                internalWithdrawAmount_,\\n                0,\\n                0\\n            );\\n        }\\n\\n        spellIndex_++;\\n\\n        // Protocol 2,3 & 4 support wstETH; So converting wstETH into stETH before withdrawing.\\n        if (protocolId_ == 2 || protocolId_ == 3 || protocolId_ == 4 || protocolId_ == 6 || protocolId_ == 7) {\\n            targets_[spellIndex_] = \\\"WSTETH-A\\\";\\n            calldatas_[spellIndex_] = abi.encodeWithSignature(\\n                \\\"withdraw(uint256,uint256,uint256)\\\",\\n                type(uint256).max,\\n                0,\\n                0\\n            );\\n\\n            spellIndex_++;\\n        }\\n\\n        // Using max amount to withdraw stETH from DSA to vault to withdraw any ideal stETH from DSA.\\n        targets_[spellIndex_] = \\\"BASIC-A\\\";\\n        calldatas_[spellIndex_] = abi.encodeWithSignature(\\n            \\\"withdraw(address,uint256,address,uint256,uint256)\\\",\\n            STETH_ADDRESS,\\n            type(uint256).max,\\n            address(this),\\n            0,\\n            0\\n        );\\n\\n        vaultDSA.cast(targets_, calldatas_, address(this));\\n\\n        uint256 protocolRatio_ = getProtocolRatio(protocolId_);\\n\\n        if (protocolRatio_ > maxRiskRatio[protocolId_])\\n            revert RebalancerModule__VaultUnsafeAfterWithdraw();\\n\\n        emit LogFillVaultAvailability(protocolId_, withdrawAmount_);\\n    }\\n\\n    function sweepWethToSteth() public nonReentrant onlyRebalancer {\\n        uint256 dsaWethBal_ = IERC20Upgradeable(WETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        if (dsaWethBal_ < 1e6) {\\n            revert RebalancerModule__InvalidSweepAmount();\\n        }\\n\\n        string[] memory targets_ = new string[](2); // wETH => eth; eth => stETH\\n        bytes[] memory calldatas_ = new bytes[](2);\\n        uint256 withdrawId_ = 113734774;\\n\\n        // Withdraw ETH from wETH.\\n        targets_[0] = \\\"WETH-A\\\";\\n        calldatas_[0] = abi.encodeWithSignature(\\n            \\\"withdraw(uint256,uint256,uint256)\\\",\\n            type(uint256).max,\\n            0,\\n            withdrawId_\\n        );\\n\\n        // convert ETH into stETH\\n        targets_[1] = \\\"LIDO-STETH-A\\\";\\n        calldatas_[1] = abi.encodeWithSignature(\\n            \\\"deposit(uint256,uint256,uint256)\\\",\\n            dsaWethBal_,\\n            withdrawId_,\\n            0\\n        );\\n\\n        vaultDSA.cast(targets_, calldatas_, address(this));\\n\\n        emit LogWethSweep(dsaWethBal_);\\n    }\\n\\n    function sweepEthToSteth() public nonReentrant onlyRebalancer {\\n        uint256 dsaEthBal_ = address(vaultDSA).balance;\\n\\n        if (dsaEthBal_ < 1e6) {\\n            revert RebalancerModule__InvalidSweepAmount();\\n        }\\n\\n        string[] memory targets_ = new string[](1); // ETH => stETH\\n        bytes[] memory calldatas_ = new bytes[](1);\\n\\n        // convert ETH into stETH\\n        targets_[0] = \\\"LIDO-STETH-A\\\";\\n        calldatas_[0] = abi.encodeWithSignature(\\n            \\\"deposit(uint256,uint256,uint256)\\\",\\n            dsaEthBal_,\\n            0,\\n            0\\n        );\\n\\n        vaultDSA.cast(targets_, calldatas_, address(this));\\n\\n        emit LogEthSweep(dsaEthBal_);\\n    }\\n\\n    /// @notice Open function to collect the revenue stored.\\n    /// @param amount_ Amount of `STETH` revenue to collect.\\n    /// Note The amount will be transferred to the `treasury` address stored.\\n    function collectRevenue(uint256 amount_)\\n        external\\n        nonReentrant\\n        onlyRebalancer\\n    {\\n        if (amount_ == type(uint256).max) amount_ = revenue;\\n\\n        if (amount_ == 0)\\n            revert RebalancerModule__NotValidCollectReveuneAmount();\\n        if (amount_ > revenue)\\n            revert RebalancerModule__CollectReveuneAmountIsHigh();\\n\\n        /// @dev Deducting the amount from revenue before transfering so that\\n        /// if any reentrancy happens, amount is deducted first and then the\\n        /// assets are transferred, which is a valid state.\\n        revenue -= amount_;\\n\\n        /// @dev transferring to `treasury` address stored.\\n        IERC20Upgradeable(STETH_ADDRESS).safeTransfer(\\n            treasury,\\n            amount_\\n        );\\n\\n        emit LogCollectRevenue(amount_, treasury);\\n    }\\n\\n    /// @notice Sets the exchange price and revenue based on current net assets(excluding reveune)\\n    /// @dev Revenue is only collected if there is a profit\\n    function updateExchangePrice()\\n        public\\n        nonReentrant\\n        onlyRebalancer\\n        returns (uint256 newExchangePrice_, uint256 newRevenue_)\\n    {\\n        uint256 iTokenSupply_ = totalSupply();\\n\\n        //  If iToken supply doesn't exist yet, the exchange rate will be 1e18 or last updated exchangePrice.\\n        if (iTokenSupply_ == 0) {\\n            return (exchangePrice, revenue);\\n        }\\n\\n        // Based on old net assets.\\n        uint256 oldExchangePrice_ = exchangePrice;\\n\\n        // Updates the peer-to-peer indexes and pool indexes for stETH and ETH.\\n        MORPHO_CONTRACT.updateIndexes(A_STETH_ADDRESS);\\n        MORPHO_CONTRACT.updateIndexes(A_WETH_ADDRESS);\\n\\n        // Current total net assets (totalAssets - totalDebt - reveune)\\n        (, , uint256 currentNetAssets_, , ) = getNetAssets();\\n\\n        // Calculating new exchangePrice based on currentNetAssets(excluding revenue)\\n        newExchangePrice_ = (currentNetAssets_ * 1e18) / iTokenSupply_;\\n\\n        // Set the new exchange price in storage. revenueFeePercentage of this profit is revenue.\\n        // Calculate the revenue only if new exchange price > the last updated revenue exchange price.\\n        // Note In case the vault experiences a loss, the vault will be\\n        // recovered first to its old state before collecting any new profits.\\n        if (newExchangePrice_ > revenueExchangePrice) {\\n            uint256 newProfit_ = currentNetAssets_ -\\n                ((revenueExchangePrice * iTokenSupply_) / 1e18); // currentNetAssets_(excluding reveune) - oldNetAssets_(excluding reveune)\\n\\n            // revenueFeePercentage is scaled by factor 4. 1% = 1e4; 100% = 1e6.\\n            newRevenue_ = (newProfit_ * revenueFeePercentage) / 1e6;\\n\\n            // updating revenue on storage\\n            revenue += newRevenue_;\\n\\n            // updating exchange price on storage\\n            exchangePrice =\\n                ((currentNetAssets_ - newRevenue_) * 1e18) /\\n                iTokenSupply_;\\n\\n            revenueExchangePrice = exchangePrice;\\n        } else {\\n            // updating exchange price on storage without calculating reveune\\n            exchangePrice = newExchangePrice_;\\n        }\\n\\n        emit LogUpdateExchangePrice(oldExchangePrice_, exchangePrice);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"Helpers__EulerDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__NotRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__UnsupportedProtocolId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__AggregatedRatioExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__CollectReveuneAmountIsHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__InvalidSweepAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__NotValidCollectReveuneAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__NotValidDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__NotValidWithdrawAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RebalancerModule__VaultUnsafeAfterWithdraw\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogCollectRevenue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LogEthSweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"LogFillVaultAvailability\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangePriceBefore\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangePriceAfter\",\"type\":\"uint256\"}],\"name\":\"LogUpdateExchangePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"LogVaultToProtocolDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wethAmount\",\"type\":\"uint256\"}],\"name\":\"LogWethSweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aggrMaxVaultRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"borrowBalanceMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"collateralBalanceMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"collectRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"protocolId_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount_\",\"type\":\"uint256\"}],\"name\":\"fillVaultAvailability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAssets_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netAssets_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aggregatedRatio_\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInStETH\",\"name\":\"aaveV2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"aaveV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"compoundV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"euler\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInStETH\",\"name\":\"morphoAaveV2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"morphoAaveV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"spark\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.IdealBalances\",\"name\":\"vaultBalances\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.IdealBalances\",\"name\":\"dsaBalances\",\"type\":\"tuple\"}],\"internalType\":\"struct Helpers.NetAssetsHelper\",\"name\":\"assets_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"protocolId_\",\"type\":\"uint8\"}],\"name\":\"getProtocolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRatioAaveV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioCompoundV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioEuler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRatioMorphoAaveV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmountPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmountP2P_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountP2P_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioSpark\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stETHAmount_\",\"type\":\"uint256\"}],\"name\":\"getWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRebalancer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverageMaxUnitAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"maxRiskRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queuedWithdrawStEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueExchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryAuth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepEthToSteth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepWethToSteth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateExchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newExchangePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRevenue_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDSA\",\"outputs\":[{\"internalType\":\"contract IDSA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"protocolId_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount_\",\"type\":\"uint256\"}],\"name\":\"vaultToProtocolDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeAbsoluteMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RebalancerModule", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}