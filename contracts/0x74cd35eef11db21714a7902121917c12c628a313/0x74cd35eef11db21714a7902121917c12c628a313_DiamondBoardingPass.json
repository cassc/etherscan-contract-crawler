{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract DiamondBoardingPass is Context, ERC165, IERC721, IERC721Metadata, Ownable, ReentrancyGuard {\r\n\r\n    using Address for address;\r\n\r\n    // Token name\r\n    string private constant _name = \"Diamond Boarding Pass\";\r\n\r\n    // Token symbol\r\n    string private constant _symbol = \"DIAMOND\";\r\n\r\n    // Precision Value For Rewards\r\n    uint256 private constant precision = 10**6;\r\n\r\n    // total number of NFTs Minted\r\n    uint256 private _totalSupply;\r\n\r\n    // NFT Structure\r\n    struct Token {\r\n        address owner;\r\n        uint256 membershipExpirationDate;\r\n        uint256 stakeBountyAmount;\r\n        bool isStaked;\r\n        uint256 totalExcluded;\r\n        bool isWavedFromFee;\r\n    }\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => Token) public tokens;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping owner address to their specific tokenId\r\n    mapping(address => uint256) private IDForOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Mapping for whitelist\r\n    mapping ( address => bool ) public isWhitelisted;\r\n\r\n    // Whitelist enabled toggle\r\n    bool public whitelistEnabled;\r\n\r\n    // base URI\r\n    string private baseURI = \"\";\r\n    string private ending = \".json\";\r\n\r\n    // Enable Trading\r\n    uint256 public mintCap;\r\n\r\n    // membership activation cost\r\n    uint256 public membershipCost;\r\n\r\n    // Duration of Membership\r\n    uint256 public membershipDuration = 30 days;\r\n\r\n    // Membership Token\r\n    address public membershipToken;\r\n\r\n    // Membership Payment Recipient\r\n    address public membershipRecipient;\r\n\r\n    // Security Deposit Cost\r\n    uint256 public securityDepositCost;\r\n\r\n    // Total Number Of NFTs In the Contract\r\n    uint256 public totalStaked;\r\n\r\n    // dividends per staked nft\r\n    uint256 public dividendsPerNFT;\r\n\r\n    // reward token\r\n    address public immutable rewardToken;\r\n\r\n    // total rewards paid out in `rewardToken`\r\n    uint256 public totalRewards;\r\n\r\n    constructor(\r\n        address membershipRecipient_,\r\n        address membershipToken_,\r\n        address rewardToken_,\r\n        uint256 membershipCost_,\r\n        uint256 securityDepositCost_\r\n    ) { \r\n        require(\r\n            membershipRecipient_ != address(0),\r\n            'Cannot Have No Recipient'\r\n        );\r\n        require(\r\n            membershipCost_ > 0,\r\n            'Cannot Have No Cost'\r\n        );\r\n        require(\r\n            rewardToken_ != address(0),\r\n            'Zero Reward Token'\r\n        );\r\n        membershipRecipient = membershipRecipient_;\r\n        membershipToken = membershipToken_;\r\n        membershipCost = membershipCost_;\r\n        rewardToken = rewardToken_;\r\n        securityDepositCost = securityDepositCost_;\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////   RESTRICTED FUNCTIONS   ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    function setMintCap(uint newCap) external onlyOwner {\r\n        mintCap = newCap;\r\n    }\r\n\r\n    function setWhitelistEnabled(bool enabled) external onlyOwner {\r\n        whitelistEnabled = enabled;\r\n    }\r\n\r\n    function setWaiveFromFee(uint256 tokenId, bool isWaived) external onlyOwner {\r\n        tokens[tokenId].isWavedFromFee = isWaived;\r\n    }\r\n\r\n    function setIsWhitelisted(address[] calldata users, bool isWhitelisted_) external onlyOwner {\r\n        uint len = users.length;\r\n        for (uint i = 0; i < len;) {\r\n            isWhitelisted[users[i]] = isWhitelisted_;\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    function withdrawNative(uint256 amount) external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: amount}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function withdrawToken(address token_, uint256 amount) external onlyOwner {\r\n        require(token_ != address(0), 'Zero Address');\r\n        IERC20(token_).transfer(msg.sender, amount);\r\n    }\r\n\r\n    function setMembershipCost(uint256 newCost) external onlyOwner {\r\n        require(\r\n            newCost > 0,\r\n            'Cannot Have No Cost'\r\n        );\r\n        membershipCost = newCost;\r\n    }\r\n\r\n    function setBaseURI(string calldata newURI) external onlyOwner {\r\n        baseURI = newURI;\r\n    }\r\n\r\n    function setURIExtention(string calldata newExtention) external onlyOwner {\r\n        ending = newExtention;\r\n    }\r\n\r\n    function setMembershipDuration(uint numDays) external onlyOwner {\r\n        require(\r\n            numDays > 0,\r\n            'Cannot Have Zero Day Stake Time'\r\n        );\r\n        membershipDuration = numDays * 1 days;\r\n    }\r\n\r\n    /**\r\n        Setting `token` to address(0) will turn it into native ETH for payments instead of an ERC20\r\n     */\r\n    function setMembershipToken(address token) external onlyOwner {\r\n        membershipToken = token;\r\n    }\r\n\r\n    function setSecurityDepositCost(uint256 newCost) external onlyOwner {\r\n        securityDepositCost = newCost;\r\n    }\r\n\r\n    function claimFor(address user) external onlyOwner {\r\n        _claim(user);\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////     PUBLIC FUNCTIONS     ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    /**\r\n        Stakes the Membership NFT associated with `msg.sender`\r\n     */\r\n    function stake() external payable nonReentrant {\r\n        require(\r\n            hasMembershipNFT(msg.sender),\r\n            'Must Own Membership NFT'\r\n        );\r\n        require(\r\n            msg.value >= securityDepositCost,\r\n            'Insufficient Cost Supplied'\r\n        );\r\n        uint256 tokenId = getTokenIDForOwner(msg.sender);\r\n        require(\r\n            tokenId < ~uint256(0),\r\n            'ID Out Of Bounds'\r\n        );\r\n        require(\r\n            !tokens[tokenId].isStaked,\r\n            'Already Staked'\r\n        );\r\n        require(\r\n            isMembershipActive(tokenId),\r\n            'Membership Not Activated'\r\n        );\r\n\r\n        // set stake bounty amount\r\n        tokens[tokenId].stakeBountyAmount = securityDepositCost;\r\n\r\n        // set is staked\r\n        tokens[tokenId].isStaked = true;\r\n\r\n        // increase total number of NFTs staked\r\n        unchecked {\r\n            ++totalStaked;\r\n        }\r\n\r\n        // set their total excluded\r\n        tokens[tokenId].totalExcluded = getTotalExcluded();\r\n    }\r\n\r\n    function claim() external nonReentrant {\r\n        _claim(msg.sender);\r\n    }\r\n\r\n    function unstake() external nonReentrant {\r\n        require(\r\n            hasMembershipNFT(msg.sender),\r\n            'No Membership NFT'\r\n        );\r\n        uint256 tokenId = getTokenIDForOwner(msg.sender);\r\n        require(\r\n            tokenId < _totalSupply,\r\n            'ID Out Of Bounds'\r\n        );\r\n        require(\r\n            tokens[tokenId].isStaked,\r\n            'Not Staked'\r\n        );\r\n        \r\n        // fetch bounty\r\n        uint256 bounty = tokens[tokenId].stakeBountyAmount;\r\n\r\n        // remove bounty to protect against reentrancy\r\n        delete tokens[tokenId].stakeBountyAmount;\r\n\r\n        // unstake user's token Id\r\n        _unstake(tokenId);\r\n\r\n        // send bounty to caller\r\n        if (bounty > 0) {\r\n            (bool s,) = payable(msg.sender).call{value: bounty}(\"\");\r\n            require(s, 'Transfer Failed');\r\n        }\r\n    }\r\n\r\n    function kickOutForBounty(uint256 tokenId) external nonReentrant {\r\n\r\n        // ensure tokenId is active\r\n        require(\r\n            tokenId < _totalSupply,\r\n            'ID Out Of Bounds'\r\n        );\r\n        require(\r\n            isMembershipActive(tokenId) == false,\r\n            'Membership Is Still Active'\r\n        );\r\n        require(\r\n            tokens[tokenId].isStaked,\r\n            'User Not Staked'\r\n        );\r\n\r\n        // fetch bounty\r\n        uint256 bounty = tokens[tokenId].stakeBountyAmount;\r\n\r\n        // remove bounty to protect against reentrancy\r\n        delete tokens[tokenId].stakeBountyAmount;\r\n\r\n        // unstake user's token Id\r\n        _unstake(tokenId);\r\n\r\n        // send bounty to caller\r\n        if (bounty > 0) {\r\n            (bool s,) = payable(msg.sender).call{value: bounty}(\"\");\r\n            require(s, 'Transfer Failed');\r\n        }\r\n    }\r\n\r\n    function addRewards(uint256 amount) external nonReentrant {\r\n        require(\r\n            totalStaked > 0,\r\n            'Zero Rewards To Give Out'\r\n        );\r\n        uint256 received = _transferIn(rewardToken, amount);\r\n        unchecked {\r\n            dividendsPerNFT += (received * precision) / totalStaked;\r\n            totalRewards += received;\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Mints `numberOfMints` NFTs To Caller\r\n     */\r\n    function mint() external nonReentrant {\r\n        if (whitelistEnabled) {\r\n            require(\r\n                isWhitelisted[msg.sender],\r\n                'User Not Whitelisted'\r\n            );\r\n        }\r\n        require(\r\n            _totalSupply < mintCap,\r\n            'Trading Not Enabled'\r\n        );\r\n        require(\r\n            balanceOf(msg.sender) == 0, \r\n            'Cannot Own More Than 1'\r\n        );\r\n        _safeMint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    /**\r\n        Allows user to pay membership\r\n     */\r\n    function payMembership(uint256 tokenId, uint256 nMonths) external payable nonReentrant {\r\n        require(\r\n            nMonths > 0,\r\n            'Cannot Pay Zero Months'\r\n        );\r\n\r\n        // ensure tokenId is valid\r\n        require(\r\n            tokenId < _totalSupply, \r\n            'Invalid Id'\r\n        );\r\n\r\n        // save gas, define cost\r\n        uint256 cost = nMonths * membershipCost;\r\n\r\n        if (membershipToken == address(0)) {\r\n            require(\r\n                msg.value >= cost,\r\n                'Incorrect Amount'\r\n            );\r\n            (bool s,) = payable(membershipRecipient).call{value: msg.value}(\"\");\r\n            require(s);\r\n        } else {\r\n            require(\r\n                msg.value == 0,\r\n                'Zero Cost'\r\n            );\r\n\r\n            // ensure the user has enough tokens for the membership\r\n            require(\r\n                IERC20(membershipToken).balanceOf(msg.sender) >= cost,\r\n                'Insufficient Balance'\r\n            );\r\n            require(\r\n                IERC20(membershipToken).allowance(msg.sender, address(this)) >= cost,\r\n                'Insufficient Allowance'\r\n            );\r\n\r\n            // burn the necessary amount of tokens\r\n            require(\r\n                IERC20(membershipToken).transferFrom(msg.sender, membershipRecipient, cost),\r\n                'Failure to burn tokens'\r\n            );\r\n        }\r\n\r\n        // update state\r\n        tokens[tokenId].membershipExpirationDate = block.timestamp + ( nMonths * membershipDuration );\r\n    }\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address wpowner = ownerOf(tokenId);\r\n        require(to != wpowner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == wpowner || isApprovedForAll(wpowner, _msgSender()),\r\n            \"ERC721: not approved or owner\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address _operator, bool approved) public override {\r\n        _setApprovalForAll(_msgSender(), _operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"caller not owner nor approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"caller not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////     READ FUNCTIONS       ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    function canKickOutId(uint256 tokenId) public view returns (bool) {\r\n        return tokens[tokenId].isStaked && isMembershipActive(tokenId) == false && tokenId < _totalSupply;\r\n    }\r\n\r\n    function canKickOutUser(address user) public view returns (bool) {\r\n        return canKickOutId(getTokenIDForOwner(user));\r\n    }\r\n\r\n    function listOfUsersToKick() external view returns (address[] memory) {\r\n        // get length of array\r\n        uint lengthOfList;\r\n        for (uint i = 0; i < _totalSupply;) {\r\n            if (tokens[i].isStaked && isMembershipActive(i) == false) {\r\n                unchecked {\r\n                    ++lengthOfList;\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // instantiate array\r\n        address[] memory list = new address[](lengthOfList);\r\n        uint count;\r\n        for (uint i = 0; i < _totalSupply;) {\r\n            if (tokens[i].isStaked && isMembershipActive(i) == false) {\r\n                list[count] = tokens[i].owner;\r\n                unchecked { ++count; }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // return list\r\n        return list;\r\n    }\r\n\r\n    function listOfIDsToKick() external view returns (uint256[] memory) {\r\n\r\n        // get length of array\r\n        uint lengthOfList;\r\n        for (uint i = 0; i < _totalSupply;) {\r\n            if (tokens[i].isStaked && isMembershipActive(i) == false) {\r\n                unchecked {\r\n                    ++lengthOfList;\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // instantiate array\r\n        uint256[] memory list = new uint256[](lengthOfList);\r\n        uint count;\r\n        for (uint i = 0; i < _totalSupply;) {\r\n            if (tokens[i].isStaked && isMembershipActive(i) == false) {\r\n                list[count] = i;\r\n                unchecked { ++count; }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // return list\r\n        return list;\r\n    }\r\n\r\n    function paginatedListOfIDsToKick(uint256 startIndex, uint256 endIndex) external view returns (uint256[] memory) {\r\n\r\n        // get length of array\r\n        uint lengthOfList;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            if (canKickOutId(i)) {\r\n                unchecked {\r\n                    ++lengthOfList;\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // instantiate array\r\n        uint256[] memory list = new uint256[](lengthOfList);\r\n        uint count;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            if (canKickOutId(i)) {\r\n                list[count] = i;\r\n                unchecked { ++count; }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // return list\r\n        return list;\r\n    }\r\n\r\n    function paginatedListOfUsersToKick(uint256 startIndex, uint256 endIndex) external view returns (address[] memory) {\r\n\r\n        // get length of array\r\n        uint lengthOfList;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            if (canKickOutId(i)) {\r\n                unchecked {\r\n                    ++lengthOfList;\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // instantiate array\r\n        address[] memory list = new address[](lengthOfList);\r\n        uint count;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            if (canKickOutId(i)) {\r\n                list[count] = tokens[i].owner;\r\n                unchecked { ++count; }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // return list\r\n        return list;\r\n    }\r\n\r\n    function pendingRewards(uint256 tokenId) public view returns (uint256) {\r\n        if (tokens[tokenId].isStaked == false) {\r\n            return 0;\r\n        }\r\n        uint256 tExcluded = getTotalExcluded();\r\n        uint256 userExcluded = tokens[tokenId].totalExcluded;\r\n        return tExcluded > userExcluded ? tExcluded - userExcluded : 0;\r\n    }\r\n\r\n    function getTotalExcluded() public view returns (uint256) {\r\n        return dividendsPerNFT / precision;\r\n    }\r\n\r\n    function isUserMembershipActive(address user) public view returns (bool) {\r\n        if (!hasMembershipNFT(user)) {\r\n            return false;\r\n        }\r\n        return isMembershipActive(IDForOwner[user]);\r\n    }\r\n\r\n    function isMembershipActive(uint256 tokenId) public view returns (bool) {\r\n        return tokens[tokenId].membershipExpirationDate >= block.timestamp || tokens[tokenId].isWavedFromFee;\r\n    }\r\n\r\n    function timeUntilMembershipExpires(uint256 tokenId) external view returns (uint256) {\r\n        uint expiration = tokens[tokenId].membershipExpirationDate;\r\n        return expiration > block.timestamp ? expiration - block.timestamp : 0;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getTokenIDForOwner(address user) public view returns (uint256) {\r\n        return hasMembershipNFT(user) ? IDForOwner[user] : ~uint256(0);\r\n    }\r\n\r\n    function hasMembershipNFT(address user) public view returns (bool) {\r\n        return tokens[IDForOwner[user]].owner == user && user != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address wpowner) public view override returns (uint256) {\r\n        require(wpowner != address(0), \"query for the zero address\");\r\n        return _balances[wpowner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        address wpowner = tokens[tokenId].owner;\r\n        require(wpowner != address(0), \"query for nonexistent token\");\r\n        return wpowner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        require(_exists(tokenId), \"nonexistent token\");\r\n\r\n        string memory fHalf = string.concat(baseURI,\r\n            isMembershipActive(tokenId) ? '1' : '0'\r\n        );\r\n        return string.concat(fHalf, ending);\r\n    }\r\n\r\n    /**\r\n        Converts A Uint Into a String\r\n    */\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address wpowner, address _operator) public view override returns (bool) {\r\n        return _operatorApprovals[wpowner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return tokens[tokenId].owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: nonexistent token\");\r\n        address wpowner = ownerOf(tokenId);\r\n        return (spender == wpowner || getApproved(tokenId) == spender || isApprovedForAll(wpowner, spender));\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    ///////////    INTERNAL FUNCTIONS    ///////////\r\n    ////////////////////////////////////////////////\r\n\r\n    function _claim(address user) internal {\r\n        require(\r\n            hasMembershipNFT(user),\r\n            'Must Own Membership NFT'\r\n        );\r\n\r\n        // fetch token id for caller\r\n        uint256 tokenId = getTokenIDForOwner(user);\r\n        require(\r\n            tokenId < _totalSupply,\r\n            'ID Out Of Bounds'\r\n        );\r\n        require(\r\n            tokens[tokenId].isStaked,\r\n            'Not Staked'\r\n        );\r\n\r\n        // fetch pending rewards\r\n        uint256 pending = pendingRewards(tokenId);\r\n        require(\r\n            pending > 0,\r\n            'Zero Rewards'\r\n        );\r\n\r\n        // reset reward value\r\n        tokens[tokenId].totalExcluded = getTotalExcluded();\r\n\r\n        // send pending reward to user\r\n        _sendRewards(user, pending);\r\n    }\r\n\r\n    function _sendRewards(address to, uint256 amount) internal {\r\n        uint bal = IERC20(rewardToken).balanceOf(address(this));\r\n        if (amount > bal) {\r\n            amount = bal;\r\n        }\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        IERC20(rewardToken).transfer(to, amount);\r\n    }\r\n\r\n    function _unstake(uint256 tokenId) internal {\r\n\r\n        // claim all pending rewards\r\n        uint256 pending = pendingRewards(tokenId);\r\n        require(\r\n            pending > 0,\r\n            'Zero Rewards'\r\n        );\r\n\r\n        // set is staked to false\r\n        delete tokens[tokenId].isStaked;\r\n\r\n        // decrease total number of NFTs staked\r\n        unchecked {\r\n            --totalStaked;\r\n        }\r\n\r\n        // send pending reward to user\r\n        _sendRewards(tokens[tokenId].owner, pending);\r\n    }\r\n\r\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\r\n        // ensure the user has enough tokens to transfer\r\n        require(\r\n            IERC20(token).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            IERC20(token).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n\r\n        // note the balance before\r\n        uint256 before = IERC20(token).balanceOf(address(this));\r\n        // transfer the necessary amount of tokens\r\n        require(\r\n            IERC20(token).transferFrom(msg.sender, address(this), amount),\r\n            'Failure to burn tokens'\r\n        );\r\n        return IERC20(token).balanceOf(address(this)) - before;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, \"\"),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        unchecked {\r\n            _balances[to]++;\r\n            _totalSupply++;\r\n        }\r\n        tokens[tokenId].owner = to;\r\n        IDForOwner[to] = tokenId;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: non ERC721Receiver implementer\");\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal {\r\n        require(ownerOf(tokenId) == from, \"Incorrect owner\");\r\n        require(to != address(0), \"zero address\");\r\n        require(balanceOf(from) > 0, 'Zero Balance');\r\n        require(balanceOf(to) == 0, 'Cannot Own More Than 1');\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        // Allocate balances\r\n        unchecked {\r\n            _balances[from] -= 1;\r\n            _balances[to] += 1;\r\n        }\r\n        tokens[tokenId].owner = to;\r\n\r\n        // remap address to id mapping\r\n        delete IDForOwner[from];\r\n        IDForOwner[to] = tokenId;\r\n\r\n        // emit transfer\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address wpowner,\r\n        address _operator,\r\n        bool approved\r\n    ) internal {\r\n        require(wpowner != _operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[wpowner][_operator] = approved;\r\n        emit ApprovalForAll(wpowner, _operator, approved);\r\n    }\r\n\r\n    function onReceivedRetval() public pure returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"membershipRecipient_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"membershipToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"membershipCost_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"securityDepositCost_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"canKickOutId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canKickOutUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTokenIDForOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalExcluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"hasMembershipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isMembershipActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserMembershipActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"kickOutForBounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listOfIDsToKick\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listOfUsersToKick\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membershipCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membershipDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membershipRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membershipToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onReceivedRetval\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"paginatedListOfIDsToKick\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"paginatedListOfUsersToKick\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nMonths\",\"type\":\"uint256\"}],\"name\":\"payMembership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"securityDepositCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted_\",\"type\":\"bool\"}],\"name\":\"setIsWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setMembershipCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numDays\",\"type\":\"uint256\"}],\"name\":\"setMembershipDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setMembershipToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCap\",\"type\":\"uint256\"}],\"name\":\"setMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"setSecurityDepositCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newExtention\",\"type\":\"string\"}],\"name\":\"setURIExtention\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWaived\",\"type\":\"bool\"}],\"name\":\"setWaiveFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setWhitelistEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"timeUntilMembershipExpires\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"membershipExpirationDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeBountyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWavedFromFee\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DiamondBoardingPass", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "0000000000000000000000005522a89d4eb749bcf3baa9fa58d9bee1f8a03478000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000002faf08000000000000000000000000000000000000000000000000000470de4df820000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://641a7261bc2714d29f2b63b3ab02bda1170278fa33c7d54b4145d64334f47d29"}