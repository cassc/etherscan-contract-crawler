{"SourceCode": "// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AddressHelper.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary AddressHelper {\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferEther(address to, uint256 value) internal {\r\n        (bool success, ) = to.call.value(value)(new bytes(0));\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function isContract(address token) internal view returns (bool) {\r\n        if (token == address(0x0)) {\r\n            return false;\r\n        }\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(token)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/XNum.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\nlibrary XNum {\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n}\r\n\r\n// File: contracts/XHalfLife.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract XHalfLife is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using AddressHelper for address;\r\n\r\n    uint256 private constant ONE = 10**18;\r\n\r\n    /**\r\n     * @notice Counter for new stream ids.\r\n     */\r\n    uint256 public nextStreamId = 1;\r\n\r\n    /**\r\n     * @notice key: stream id, value: minimum effective value(0.0001 TOKEN)\r\n     */\r\n    mapping(uint256 => uint256) public effectiveValues;\r\n\r\n    // halflife stream\r\n    struct Stream {\r\n        uint256 depositAmount; // total deposited amount, must >= 0.0001 TOKEN\r\n        uint256 remaining; // un-withdrawable balance\r\n        uint256 withdrawable; // withdrawable balance\r\n        uint256 startBlock; // when should start\r\n        uint256 kBlock; // interval K blocks\r\n        uint256 unlockRatio; // must be between [1-999], which means 0.1% to 99.9%\r\n        uint256 denom; // one readable coin represent\r\n        uint256 lastRewardBlock; // update by create(), fund() and withdraw()\r\n        address token; // ERC20 token address or 0xEe for Ether\r\n        address recipient;\r\n        address sender;\r\n        bool cancelable; // can be cancelled or not\r\n        bool isEntity;\r\n    }\r\n\r\n    /**\r\n     * @notice The stream objects identifiable by their unsigned integer ids.\r\n     */\r\n    mapping(uint256 => Stream) public streams;\r\n\r\n    /**\r\n     * @dev Throws if the provided id does not point to a valid stream.\r\n     */\r\n    modifier streamExists(uint256 streamId) {\r\n        require(streams[streamId].isEntity, \"stream does not exist\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the caller is not the sender of the recipient of the stream.\r\n     *  Throws if the recipient is the zero address, the contract itself or the caller.\r\n     *  Throws if the depositAmount is 0.\r\n     *  Throws if the start block is before `block.number`.\r\n     */\r\n    modifier createStreamPreflight(\r\n        address recipient,\r\n        uint256 depositAmount,\r\n        uint256 startBlock,\r\n        uint256 kBlock\r\n    ) {\r\n        require(recipient != address(0), \"stream to the zero address\");\r\n        require(recipient != address(this), \"stream to the contract itself\");\r\n        require(recipient != msg.sender, \"stream to the caller\");\r\n        require(depositAmount > 0, \"deposit amount is zero\");\r\n        require(startBlock >= block.number, \"start block before block.number\");\r\n        require(kBlock > 0, \"k block is zero\");\r\n        _;\r\n    }\r\n\r\n    event StreamCreated(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address token,\r\n        uint256 depositAmount,\r\n        uint256 startBlock,\r\n        uint256 kBlock,\r\n        uint256 unlockRatio,\r\n        bool cancelable\r\n    );\r\n\r\n    event WithdrawFromStream(\r\n        uint256 indexed streamId,\r\n        address indexed recipient,\r\n        uint256 amount\r\n    );\r\n\r\n    event StreamCanceled(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 senderBalance,\r\n        uint256 recipientBalance\r\n    );\r\n\r\n    event StreamFunded(uint256 indexed streamId, uint256 amount);\r\n\r\n    /**\r\n     * @notice Creates a new stream funded by `msg.sender` and paid towards `recipient`.\r\n     * @dev Throws if paused.\r\n     *  Throws if the token is not a contract address\r\n     *  Throws if the recipient is the zero address, the contract itself or the caller.\r\n     *  Throws if the depositAmount is 0.\r\n     *  Throws if the start block is before `block.number`.\r\n     *  Throws if the rate calculation has a math error.\r\n     *  Throws if the next stream id calculation has a math error.\r\n     *  Throws if the contract is not allowed to transfer enough tokens.\r\n     * @param token The ERC20 token address\r\n     * @param recipient The address towards which the money is streamed.\r\n     * @param depositAmount The amount of money to be streamed.\r\n     * @param startBlock stream start block\r\n     * @param kBlock unlock every k blocks\r\n     * @param unlockRatio unlock ratio from remaining balance,\r\n     *                    value must be between [1-1000], which means 0.1% to 1%\r\n     * @param cancelable can be cancelled or not\r\n     * @return The uint256 id of the newly created stream.\r\n     */\r\n    function createStream(\r\n        address token,\r\n        address recipient,\r\n        uint256 depositAmount,\r\n        uint256 startBlock,\r\n        uint256 kBlock,\r\n        uint256 unlockRatio,\r\n        bool cancelable\r\n    )\r\n        external\r\n        createStreamPreflight(recipient, depositAmount, startBlock, kBlock)\r\n        returns (uint256 streamId)\r\n    {\r\n        require(unlockRatio < 1000, \"unlockRatio must < 1000\");\r\n        require(unlockRatio > 0, \"unlockRatio must > 0\");\r\n\r\n        require(token.isContract(), \"not contract\");\r\n        token.safeTransferFrom(msg.sender, address(this), depositAmount);\r\n\r\n        streamId = nextStreamId;\r\n        {\r\n            uint256 denom = 10**uint256(IERC20(token).decimals());\r\n            require(denom >= 10**6, \"token decimal too small\");\r\n\r\n            // 0.0001 TOKEN\r\n            effectiveValues[streamId] = denom.div(10**4);\r\n            require(\r\n                depositAmount >= effectiveValues[streamId],\r\n                \"deposit too small\"\r\n            );\r\n\r\n            streams[streamId] = Stream({\r\n                token: token,\r\n                remaining: depositAmount,\r\n                withdrawable: 0,\r\n                depositAmount: depositAmount,\r\n                startBlock: startBlock,\r\n                kBlock: kBlock,\r\n                unlockRatio: unlockRatio,\r\n                denom: denom,\r\n                lastRewardBlock: startBlock,\r\n                recipient: recipient,\r\n                sender: msg.sender,\r\n                isEntity: true,\r\n                cancelable: cancelable\r\n            });\r\n        }\r\n\r\n        nextStreamId = nextStreamId.add(1);\r\n        emit StreamCreated(\r\n            streamId,\r\n            msg.sender,\r\n            recipient,\r\n            token,\r\n            depositAmount,\r\n            startBlock,\r\n            kBlock,\r\n            unlockRatio,\r\n            cancelable\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new ether stream funded by `msg.sender` and paid towards `recipient`.\r\n     * @dev Throws if paused.\r\n     *  Throws if the recipient is the zero address, the contract itself or the caller.\r\n     *  Throws if the depositAmount is 0.\r\n     *  Throws if the start block is before `block.number`.\r\n     *  Throws if the rate calculation has a math error.\r\n     *  Throws if the next stream id calculation has a math error.\r\n     *  Throws if the contract is not allowed to transfer enough tokens.\r\n     * @param recipient The address towards which the money is streamed.\r\n     * @param startBlock stream start block\r\n     * @param kBlock unlock every k blocks\r\n     * @param unlockRatio unlock ratio from remaining balance\r\n     * @param cancelable can be cancelled or not\r\n     * @return The uint256 id of the newly created stream.\r\n     */\r\n    function createEtherStream(\r\n        address recipient,\r\n        uint256 startBlock,\r\n        uint256 kBlock,\r\n        uint256 unlockRatio,\r\n        bool cancelable\r\n    )\r\n        external\r\n        payable\r\n        createStreamPreflight(recipient, msg.value, startBlock, kBlock)\r\n        returns (uint256 streamId)\r\n    {\r\n        require(unlockRatio < 1000, \"unlockRatio must < 1000\");\r\n        require(unlockRatio > 0, \"unlockRatio must > 0\");\r\n        require(msg.value >= 10**14, \"deposit too small\");\r\n\r\n        /* Create and store the stream object. */\r\n        streamId = nextStreamId;\r\n        streams[streamId] = Stream({\r\n            token: AddressHelper.ethAddress(),\r\n            remaining: msg.value,\r\n            withdrawable: 0,\r\n            depositAmount: msg.value,\r\n            startBlock: startBlock,\r\n            kBlock: kBlock,\r\n            unlockRatio: unlockRatio,\r\n            denom: 10**18,\r\n            lastRewardBlock: startBlock,\r\n            recipient: recipient,\r\n            sender: msg.sender,\r\n            isEntity: true,\r\n            cancelable: cancelable\r\n        });\r\n\r\n        nextStreamId = nextStreamId.add(1);\r\n        emit StreamCreated(\r\n            streamId,\r\n            msg.sender,\r\n            recipient,\r\n            AddressHelper.ethAddress(),\r\n            msg.value,\r\n            startBlock,\r\n            kBlock,\r\n            unlockRatio,\r\n            cancelable\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Check if given stream exists.\r\n     * @param streamId The id of the stream to query.\r\n     * @return bool true=exists, otherwise false.\r\n     */\r\n    function hasStream(uint256 streamId) external view returns (bool) {\r\n        return streams[streamId].isEntity;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the stream with all its properties.\r\n     * @dev Throws if the id does not point to a valid stream.\r\n     * @param streamId The id of the stream to query.\r\n     * @return sender\r\n     * @return recipient\r\n     * @return token\r\n     * @return depositAmount\r\n     * @return startBlock\r\n     * @return kBlock\r\n     * @return remaining\r\n     * @return withdrawable\r\n     * @return unlockRatio\r\n     * @return lastRewardBlock\r\n     * @return cancelable\r\n     */\r\n    function getStream(uint256 streamId)\r\n        external\r\n        view\r\n        streamExists(streamId)\r\n        returns (\r\n            address sender,\r\n            address recipient,\r\n            address token,\r\n            uint256 depositAmount,\r\n            uint256 startBlock,\r\n            uint256 kBlock,\r\n            uint256 remaining,\r\n            uint256 withdrawable,\r\n            uint256 unlockRatio,\r\n            uint256 lastRewardBlock,\r\n            bool cancelable\r\n        )\r\n    {\r\n        Stream memory stream = streams[streamId];\r\n        sender = stream.sender;\r\n        recipient = stream.recipient;\r\n        token = stream.token;\r\n        depositAmount = stream.depositAmount;\r\n        startBlock = stream.startBlock;\r\n        kBlock = stream.kBlock;\r\n        remaining = stream.remaining;\r\n        withdrawable = stream.withdrawable;\r\n        unlockRatio = stream.unlockRatio;\r\n        lastRewardBlock = stream.lastRewardBlock;\r\n        cancelable = stream.cancelable;\r\n    }\r\n\r\n    /**\r\n     * @notice funds to an existing stream(for general purpose), \r\n     the amount of fund should be simply added to un-withdrawable.\r\n     * @dev Throws if the caller is not the stream.sender\r\n     * @param streamId The id of the stream to query.\r\n     * @param amount deposit amount by stream sender\r\n     */\r\n    function singleFundStream(uint256 streamId, uint256 amount)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        streamExists(streamId)\r\n        returns (bool)\r\n    {\r\n        Stream storage stream = streams[streamId];\r\n        require(\r\n            msg.sender == stream.sender,\r\n            \"caller must be the sender of the stream\"\r\n        );\r\n        require(amount > effectiveValues[streamId], \"amount not effective\");\r\n        if (stream.token == AddressHelper.ethAddress()) {\r\n            require(amount == msg.value, \"bad ether fund\");\r\n        } else {\r\n            stream.token.safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n\r\n        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\r\n\r\n        // update remaining and withdrawable balance\r\n        stream.lastRewardBlock = block.number;\r\n        stream.remaining = remaining.add(amount); // = remaining + amount\r\n        stream.withdrawable = withdrawable; // = withdrawable\r\n\r\n        //add funds to total deposit amount\r\n        stream.depositAmount = stream.depositAmount.add(amount);\r\n        emit StreamFunded(streamId, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Implemented for XDEX farming and vesting,\r\n     * the amount of fund should be splited to withdrawable and un-withdrawable according to lastRewardBlock.\r\n     * @dev Throws if the caller is not the stream.sender\r\n     * @param streamId The id of the stream to query.\r\n     * @param amount deposit amount by stream sender\r\n     * @param blockHeightDiff diff of block.number and farmPool's lastRewardBlock\r\n     */\r\n    function lazyFundStream(\r\n        uint256 streamId,\r\n        uint256 amount,\r\n        uint256 blockHeightDiff\r\n    ) external payable nonReentrant streamExists(streamId) returns (bool) {\r\n        Stream storage stream = streams[streamId];\r\n        require(\r\n            msg.sender == stream.sender,\r\n            \"caller must be the sender of the stream\"\r\n        );\r\n        require(amount > effectiveValues[streamId], \"amount not effective\");\r\n        if (stream.token == AddressHelper.ethAddress()) {\r\n            require(amount == msg.value, \"bad ether fund\");\r\n        } else {\r\n            stream.token.safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n\r\n        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\r\n\r\n        //uint256 blockHeightDiff = block.number.sub(stream.lastRewardBlock);\r\n        // If underflow m might be 0, peg true kBlock to 1, if bHD 0 then error.\r\n        // Minimum amount is 100\r\n        uint256 m = amount.mul(ONE).div(blockHeightDiff);\r\n        // peg true kBlock to 1 so n over k always greater or equal 1\r\n        uint256 noverk = blockHeightDiff.mul(ONE);\r\n        // peg true mu to mu/kBlock\r\n        uint256 mu = stream.unlockRatio.mul(ONE).div(1000).div(stream.kBlock);\r\n        // Enlarged due to mu divided by kBlock\r\n        uint256 onesubmu = ONE.sub(mu);\r\n        // uint256 s = m.mul(ONE.sub(XNum.bpow(onesubmu,noverk))).div(ONE).div(mu).mul(ONE);\r\n        uint256 s =\r\n            m.mul(ONE.sub(XNum.bpow(onesubmu, noverk))).div(mu).div(ONE);\r\n\r\n        // update remaining and withdrawable balance\r\n        stream.lastRewardBlock = block.number;\r\n        stream.remaining = remaining.add(s); // = remaining + s\r\n        stream.withdrawable = withdrawable.add(amount).sub(s); // = withdrawable + (amount - s)\r\n\r\n        // add funds to total deposit amount\r\n        stream.depositAmount = stream.depositAmount.add(amount);\r\n        emit StreamFunded(streamId, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the available funds for the given stream id and address.\r\n     * @dev Throws if the id does not point to a valid stream.\r\n     * @param streamId The id of the stream for which to query the balance.\r\n     * @return withdrawable The total funds allocated to `recipient` and `sender` as uint256.\r\n     * @return remaining The total funds allocated to `recipient` and `sender` as uint256.\r\n     */\r\n    function balanceOf(uint256 streamId)\r\n        public\r\n        view\r\n        streamExists(streamId)\r\n        returns (uint256 withdrawable, uint256 remaining)\r\n    {\r\n        Stream memory stream = streams[streamId];\r\n\r\n        if (block.number < stream.startBlock) {\r\n            return (0, stream.depositAmount);\r\n        }\r\n\r\n        uint256 lastBalance = stream.withdrawable;\r\n\r\n        uint256 n =\r\n            block.number.sub(stream.lastRewardBlock).mul(ONE).div(\r\n                stream.kBlock\r\n            );\r\n        uint256 k = stream.unlockRatio.mul(ONE).div(1000);\r\n        uint256 mu = ONE.sub(k);\r\n        uint256 r = stream.remaining.mul(XNum.bpow(mu, n)).div(ONE);\r\n        uint256 w = stream.remaining.sub(r); // withdrawable, if n is float this process will be smooth and slightly\r\n\r\n        if (lastBalance > 0) {\r\n            w = w.add(lastBalance);\r\n        }\r\n\r\n        //If `remaining` + `withdrawable` < `depositAmount`, it means there have withdraws.\r\n        require(\r\n            r.add(w) <= stream.depositAmount,\r\n            \"balanceOf: remaining or withdrawable amount is bad\"\r\n        );\r\n\r\n        if (w >= effectiveValues[streamId]) {\r\n            withdrawable = w;\r\n        } else {\r\n            withdrawable = 0;\r\n        }\r\n\r\n        if (r >= effectiveValues[streamId]) {\r\n            remaining = r;\r\n        } else {\r\n            remaining = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws from the contract to the recipient's account.\r\n     * @dev Throws if the id does not point to a valid stream.\r\n     *  Throws if the amount exceeds the withdrawable balance.\r\n     *  Throws if the amount < the effective withdraw value.\r\n     *  Throws if the caller is not the recipient.\r\n     * @param streamId The id of the stream to withdraw tokens from.\r\n     * @param amount The amount of tokens to withdraw.\r\n     * @return bool true=success, otherwise false.\r\n     */\r\n    function withdrawFromStream(uint256 streamId, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        streamExists(streamId)\r\n        returns (bool)\r\n    {\r\n        Stream storage stream = streams[streamId];\r\n\r\n        require(\r\n            msg.sender == stream.recipient,\r\n            \"caller must be the recipient of the stream\"\r\n        );\r\n\r\n        require(\r\n            amount >= effectiveValues[streamId],\r\n            \"amount is zero or not effective\"\r\n        );\r\n\r\n        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\r\n\r\n        require(\r\n            withdrawable >= amount,\r\n            \"withdraw amount exceeds the available balance\"\r\n        );\r\n\r\n        if (stream.token == AddressHelper.ethAddress()) {\r\n            stream.recipient.safeTransferEther(amount);\r\n        } else {\r\n            stream.token.safeTransfer(stream.recipient, amount);\r\n        }\r\n\r\n        stream.lastRewardBlock = block.number;\r\n        stream.remaining = remaining;\r\n        stream.withdrawable = withdrawable.sub(amount);\r\n\r\n        emit WithdrawFromStream(streamId, stream.recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Cancels the stream and transfers the tokens back\r\n     * @dev Throws if the id does not point to a valid stream.\r\n     *  Throws if the caller is not the sender or the recipient of the stream.\r\n     *  Throws if there is a token transfer failure.\r\n     * @param streamId The id of the stream to cancel.\r\n     * @return bool true=success, otherwise false.\r\n     */\r\n    function cancelStream(uint256 streamId)\r\n        external\r\n        nonReentrant\r\n        streamExists(streamId)\r\n        returns (bool)\r\n    {\r\n        Stream memory stream = streams[streamId];\r\n\r\n        require(stream.cancelable, \"non cancelable stream\");\r\n        require(\r\n            msg.sender == streams[streamId].sender ||\r\n                msg.sender == streams[streamId].recipient,\r\n            \"caller must be the sender or the recipient\"\r\n        );\r\n\r\n        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\r\n\r\n        //save gas\r\n        delete streams[streamId];\r\n        delete effectiveValues[streamId];\r\n\r\n        if (withdrawable > 0) {\r\n            if (stream.token == AddressHelper.ethAddress()) {\r\n                stream.recipient.safeTransferEther(withdrawable);\r\n            } else {\r\n                stream.token.safeTransfer(stream.recipient, withdrawable);\r\n            }\r\n        }\r\n\r\n        if (remaining > 0) {\r\n            if (stream.token == AddressHelper.ethAddress()) {\r\n                stream.sender.safeTransferEther(remaining);\r\n            } else {\r\n                stream.token.safeTransfer(stream.sender, remaining);\r\n            }\r\n        }\r\n\r\n        emit StreamCanceled(\r\n            streamId,\r\n            stream.sender,\r\n            stream.recipient,\r\n            remaining,\r\n            withdrawable\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function getVersion() external pure returns (bytes32) {\r\n        return bytes32(\"APOLLO\");\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"senderBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipientBalance\",\"type\":\"uint256\"}],\"name\":\"StreamCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"cancelable\",\"type\":\"bool\"}],\"name\":\"StreamCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StreamFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStream\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"cancelStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancelable\",\"type\":\"bool\"}],\"name\":\"createEtherStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancelable\",\"type\":\"bool\"}],\"name\":\"createStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"effectiveValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancelable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"hasStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockHeightDiff\",\"type\":\"uint256\"}],\"name\":\"lazyFundStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextStreamId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"singleFundStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"streams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"kBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"cancelable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEntity\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XHalfLife", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://5e87d3ee6db25103178fda07cfdb9332ee39f260f532b3b317b3622d96ff5100"}