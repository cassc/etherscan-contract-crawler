/** 

PEPE + ELON = PEPELON ðŸ¸

$PEPELON is a crypto token based on a post created by Elon Musk

ðŸ“ˆ No Tax 

ðŸ–‡ï¸ Official links

ðŸ¸ Website & dApp : pepelon.vip

ðŸ¸ Community: t.me/pepelonvip

ðŸ¸ Blog: medium.com/@pepelonvip

â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£â£¹â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ¿â ¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£‡â €â €â €â €â¡€â£»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ›â¢‰â£‰â£›â ‹â â „â¡ˆâ ™â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â¡â ¾â¢½â£»â¢°â¢¿â£¹â£¿â£¿â£¿â£¿â£¿â£¿â£½â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£Ÿâ£¿â¢›â£›â ¶â ´â Ÿâ¢©â£â ›â ¡â¡¶â â¡â¢»â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£Žâ¡‡â €â£€â  â£¶â£†â£¼â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£‡â£¨â£¿â£¿
â£â¡·â£¹â£®â£·â¡™â¡®â£½â£¯â£¿â£»â£Ÿâ£¿â£¿â£´â£¿â£§â£¤â£œâ¡¿â¢â£ â žâ¢€â â¢€â ’â¢»â£¿â£¿â£¿â ¿â Ÿâ£»â ‰â ‹â¢£â£„â Šâ â ˜â£¯â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£­â£“â¢§â£“â ®â£µâ ³â£œâ£²â¢£â¡—â£ºâ ¼â£­â£¿â¢‹â ¶â ‘â¡‰â ƒâ£ˆâ£â£¤â£¦â£¾â¡§â¢€â¢¸â¡Ÿâ ‡â €â €â €â ¶â €â â ˜â ›â Ÿâ ›â ›â ƒâ €â ˜â¢·â£“â ®â£•â¢®â¡±â¢Žâ¡µâ¢ªâ¡•â£Žâ¢³â¢Žâ¡µâ¢«â¡â£­â¢“â¢®â¡±â¢Ž
â¢¶â¡¹â£Žâ ¾â£¹â¢–â¡»â£œâ¢§â¡³â£â££â¢Ÿâ¡â£¿â£¿â¢¿â¡·â ¿â ¿â£¿â£Ÿâ£©â£¿â£¿â â¢ â£¼â¡¿â †â €â €â €â €â €â €â €â €â¢°â €â €â¢€â¡²â †â¢¸â£Žâ ¿â£œâ¢®â¡½â£­â¡žâ£§â¢½â¡¾â£·â¢¾â¡žâ£§â¢»â£¬â¢›â¡¶â¡¿â£­
â£³â¡â£®â¢»â¡µâ£«â¢·â¡¹â£Žâ¢·â¡¹â£Žâ ·â£½â£·â£¿â£¿â£¶â£¶â£¾â¡¿â ¿â¡Ÿâ¢â£ â¢´â£¾â£¿â¡·â ¾â ‹â ‰â£¤â¢°â €â €â €â €â¢¸â¡€â °â¡¼â â €â ¸â¢¯â¡Ÿâ£¼â¢£â¡Ÿâ£µâ¢»â£¬â¢³â¡â£®â¢³â¡â£®â¢³â£Žâ ¿â£œâ¡³â¢§
â¢§â¢»â¡œâ£§â¢»â¡µâ£«â¢·â¡¹â£Žâ¢·â£­â¢»â£­â£¿â¢·â ¦â ¤â£¤â£¤â£¬â¡´â¢¶â ‹â â €â£¼â¢¹â¢»â£¦â¡„â£¿â£¿â ‚â£€â â ’â Šâ ‰â¢£â â£¼â£·â£„â €â¢»â£¿â¡œâ£§â¢»â£œâ¡³â£Žâ¢·â¡¹â¢®â¢·â£¹â¢®â¢·â£šâ ¿â¡¼â¢¯â£·
â¡Ÿâ£¯â¢¿â¡žâ¡·â£â¢·â£«â¢—â¡»â£žâ¡¼â£«â£Ÿâ¡³â¢šâ¡¹â¢³â£¬â¢ â¢†â£°â¢‹â£‡â£°â¢‹â¢®â¡‘â¢®â œâ£¿â£¤â£¶â ¤â¢·â¡„â ‚â ’â ‚â ˆâ£¿â£¿â¡¹â£¿â£§â£³â â¢¿â£§â£»â£œâ¡³â¡½â£Žâ¢¿â¡¹â£Žâ¢·â£«â¢žâ£­â¢»â£â¡³â¢®
â¡½â£Žâ¢¿â£¹â¢³â¡â£žâ£³â¡Ÿâ£·â¢»â£œâ£¿â¡‡â¡‡â¢â¡²â¢ƒâ¡–â£‡â¡ˆâ¡–â£â ²â¡¬â¢â¢¦â¡™â¢¦â£‹â£¿â£›â£€â €â¢â¡€â €â¢ â¡€â¢€â£¿â£–â¡»â¡½â£·â¡Žâ¢¦â €â »â£¶â£â ·â£â¢®â¡³â£â¢®â¡³â£â ¾â£œâ¡³â¢®â£â¡³
â¢·â¡¹â£Žâ¢·â¡â£¾â¢±â£‡â¢¿â¡¸â¢·â¡¾â£¿â¢‡â¡¹â¢Žâ ±â¢â¡°â£†â¢¹â¡°â¡Žâ¡±â¢‡â¡¾â£¶â¢‰â¡¶â£ˆâ£¿â ‰â ‰â¡€â¢¸â£¿â£¶â ¸â ‡â ¸â£¿â¡¸â£·â¢¹â£¹â¢¿â¡€â €â €â¢¿â£¸â ¿â£Žâ¢·â¡¹â£Žâ¢·â¡¹â£Žâ¢¿â£¸â¢¹â£·â£Žâ£¹
â£â£·â¡¹â¢®â£â¡®â£—â¢®â¡³â£â¢§â¢¿â£â žâ£°â¢‹â£â ¶â£‘â£®â¡¶â¡µâ¢®â£µâ¡¿â£¶â¢¯â¢£â¢œâ£±â£¿â €â €â ‰â »â¡¶â¡€â£¶â¡„â£ â ¿â¡¿â£·â£¿â£œâ£¯â¢¿â£¶â¡¤â£»â£­â¡Ÿâ£®â¢³â£â¢®â£³â¢»â¡¼â£›â¡¿â£·â¢¿â£¾â£µ
â¢¯â¡»â£â¡³â£Žâ¢·â¡¹â£Žâ¢·â¡¹â¢¾â¡¿â¢‡â¡«â¢–â£¿â£§â ³â£Œâ¢¿â£‡â£€â£¸â£¯â£•â£Žâ£²â£­â£¾â£·â Ÿâ â ‰â¢¼â ¶â ¡â µâ£©â£°â£â¡·â£­â¡¾â Ÿâ ‰â ‰â ³â¢¾â ¶â ‰â ·â£¿â¡œâ£¯â¢žâ¡§â£â¢·â¡¹â¢§â¡»â£œâ¢¯â¡žâ£¼
â¢·â¡¹â£Žâ¡·â£¹â¢®â¡·â¢¿â£¾â£â£¿â¡Ÿâ£¬â£µâ£¿â¡¿â£¿â£½â£”â£®â£™â£Ÿâ£»â£¿â£¿â£¿â£¿â£¾â£¿â£§â¡–â£¶â €â ˆâ €â €â €â €â ™â£¯â¡›â ªâ¢²â¡†â €â €â €â ¸â¢¶â ¶â ›â£â£»â£Žâ ¿â£¼â¡¹â¢®â¡â£§â¢»â¡œâ£§â¢»â£œ
â¡¿â£â¢®â¡³â£­â¢³â£â¢·â££â¢Ÿâ£§â ˆâ â£½â£Ÿâ£³â¢­â¡â ¿â â¢¹â£¿â£¿â¡¿â ¿â ‰â ¾â â ‰â¢³â£¿â£€â£¿â ›â¢‚â¡¸â ƒâ €â €â €â¢»â£´â£¯â£µâ£‚â£¤â£°â£„â£ˆâ €â¡â ‹â£ºâ¡žâ£½â¢²â£â¢·â£¹â¢Žâ¡·â£¹â¢Žâ¡·â£º
â¡·â£¹â¢Žâ¡·â£­â¢³â£Žâ¢·â¡¹â£Žâ¢¿â¡»â¢¿â¡»â£œâ¢§â£¿â â €â €â €â €â €â €â €â €â €â €â €â¢ˆâ£¿â£¿â¡¿â£¿â¡¿â£¾â €â¢€â¡€â €â£¾â£¿â¢¯â£Ÿâ¡¿â£Ÿâ£¿â£¾â ¯â â¢â£€â£¿â¡»â£œâ¡³â¢®â¡»â£œâ¢¯â¡žâ£µâ¢«â¡žâ£µ
â£â¢§â¡»â£œâ¢§â¡»â£œâ¢§â¡»â£œâ¢§â£›â¢§â£›â¡¼â¢£â¡‡â €â €â €â €â €â €â €â €â €â €â €â €â¢ˆâ£¿â£½â£¿â¡¿â¡¿â ƒâ €â “â €â¢¶â£¿â£¿â£»â ¾â£½â¢¿â£¿â ƒâ €â €â ˜â¢¿â¡·â£»â¢¼â¡¹â¢§â¡»â£œâ¢§â¡»â£œâ¢§â¡»â£¼
â¢¯â¡žâ£µâ¢«â¡žâ£µâ¢«â¡žâ£µâ¢«â¢žâ¡±â¢®â£±â£®â£·â¡‡â €â €â €â €â €â£¤â €â €â €â €â €â €â  â£¿â¢¿â¡¹â¡½â£·â£¦â¡„â €â¢°â£¿â¢·â£»â¢¿â£¿â£½â£žâ£¯â “â ‚â¡›â¢€â£¿â£¿â£µâ£«â¡â£§â¢»â¡œâ£§â¢»â¡œâ£§â£›â¢¶
â¡·â£¹â¢Žâ¡Ÿâ£¿â¢£â¡Ÿâ¢¾â¢¶â¡›â¢¶â£¿â£¿â£·â£¿â¡Ÿâ €â €â €â €â €â €â£¿â£„â €â €â €â €â €â â£¿â£¶â¡¿â£³â£§â¢„â  â£¼â£¿â¢¯â£³â£½â£¾â£½â£¿â ¾â£½â ’â €â €â£¾â¡Ÿâ£¿â£»â£·â£½â£Žâ¢·â¡¹â£Žâ¢·â¡¹â¢¶â¡¹â£ž
â£³â¡â£®â¡â£®â¢³â£¹â¢‹â¡¶â¡¹â¢­â£²â ±â£Žâ¢¿â â €â €â €â €â €â¢¸â£¿â¡§â €â €â €â €â €â ˆâ£·â£¿â£·â£¹â¡Ÿâ£ƒâ£°â£¿â¢¿â¡Ÿâ¡¶â£­â£Ÿâ£»â£¯â¡Ÿâ£¿â â €â£¼â£¿â¡¹â£žâ¢¿â£¾â£½â£¾â£§â£Ÿâ£¼â¢£â¡Ÿâ££â¢Ÿâ¡¼
â£§â£›â¢¶â£¹â¢¾â¡·â£·â¢¿â¡¶â¢¿â£·â£¾â£·â£¾â£¿â¡€â €â €â €â €â €â¢¸â£¿â£â €â €â €â €â €â €â£¿â£¿â¡³â¢¿â ‹â €â¡¿â¡½â¡žâ£¿â¡µâ£³â£¿â£¿â¢¯â£½â¡â €â¢ â£¿â¢¿â£¿â£½â£ºâ¡œâ£¿â£¶â£Ÿâ£¯â£Ÿâ¡¿â£žâ¡·â¢¿â¡œ
â¡¶â£¹â¢Žâ¡·â¢«â¡œâ£§â¢â ¾â£â¡»â¡œâ¢®â »â¡â¡¿â£†â£€â¡€â¢€â¡¼â£¯â£¿â££â €â €â €â €â¢€â£¼â£¿â£¯â ½â£¿â ‰â ¸â¡¿â£½â£¿â£·â¡½â££â£¿â£¿â£¿â¡Ÿâ ƒâ €â ™â£¿â£Ÿâ£¿â£·â£¿â£¿â£·â£¿â£¿â¡¯â¢¿â£Ÿâ¡»â£â¡³â£ž
â¢·â¡¹â¢®â¡â£§â¢»â¡œâ£®â¢»â£œâ¡³â¡½â£½â£­â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡³â£Žâ¡½â£¾â£¶â£¶â£¾â£¾â£¿â¢¿â ¾â£½â£¿â €â €â£Ÿâ ¿â¡¿â¢¿â¢¾â¡±â£¿â¢¿â ¾â£§â¢¤â£½â£¡â €â ™â¢¯â¢¯â ½â£­â¢«â¢­â£»â¢»â¢â¡¯â£µâ¢«â¡µâ£«
â¢·â¡¹â¢§â¡»â£œâ¢§â¡»â£œâ¡³â£Žâ¢·â¡¹â£½â¢»â¡Ÿâ£¿â¢»â¡Ÿâ¢¶â¡œâ£§â¢³â¡­â¢¶â£½â£¿â£¿â£¿â£¿â¢¯â ¯â£â ¶â£¿â£„â£†â£½â£¿â¡â¡¯â¢¶â¡¹â£Žâ£­â¢»â£œâ¡³â£Žâ¢¿â£¹â ¶â¡¾â£â¡žâ¡¶â¢«â¡žâ¡–â£¯â¢ºâ µâ£Žâ ·â£­â¢³
â¡¯â£â¢§â¡»â£œâ¢§â¡»â£œâ¡³â£â¢®â¡³â£­â£·â¡»â£œâ£§â£›â¢§â¡»â£œâ¢§â£›â ¶â£“â¢®â¡³â£â¢®â¢â¡¿â£¹â¢»â¡œâ£®â¡â£®â¢³â¡½â£¹â¢§â¢»â¡œâ£®â¢³â¢Žâ¡·â£¹â¢Žâ¡¾â¡¹â¡µâ¢®â£â¢³â£â¢¾â¡¹â£–â¢¯â¡»â£œâ¡»â£œâ£³


â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œðŸ¸â¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œðŸ¸â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œðŸ¸â¬œðŸ¸â¬œâ¬œâ¬œâ¬œðŸ¸â¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œðŸ¸â¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œðŸ¸â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ


**/
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "./Ownable.sol";
import "./SafeMath.sol";
import "./IDEXFactory.sol";
import "./IDEXRouter.sol";
import "./IERC20.sol";

contract PEPELON is IERC20, Ownable {
    using SafeMath for uint256;
    address routerAdress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address DEAD = 0x000000000000000000000000000000000000dEaD;

    string constant _name = "pepelon.vip";
    string constant _symbol = "PEPELON";
    uint8 constant _decimals = 9;

    uint256 _totalSupply = 666_666_999_999 * (10 ** _decimals);
    uint256 public _maxWalletAmount = (_totalSupply * 1) / 100;

    mapping(address => uint256) _balances;
    mapping(address => mapping(address => uint256)) _allowances;

    mapping(address => bool) isFeeExempt;
    mapping(address => bool) isTxLimitExempt;

    uint256 liquidityFee = 0;
    uint256 marketingFee = 30;
    uint256 totalFee = liquidityFee + marketingFee;
    uint256 feeDenominator = 1000;

    address public marketingFeeReceiver = 0xf5BA4336CbF7C66fa54C4D8CB705437A14819dA7;

    IDEXRouter public router;
    address public pair;

    bool public swapEnabled = true;
    uint256 public swapThreshold = _totalSupply / 10000 * 20; // 0.2%
    bool inSwap;

    modifier swapping() {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () Ownable(msg.sender) {
        turnMF(false);
        router = IDEXRouter(routerAdress);
        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));
        _allowances[address(this)][address(router)] = type(uint256).max;

        address _owner = owner;
        isFeeExempt[0xf5BA4336CbF7C66fa54C4D8CB705437A14819dA7] = true;
        isTxLimitExempt[_owner] = true;
        isTxLimitExempt[0xf5BA4336CbF7C66fa54C4D8CB705437A14819dA7] = true;
        isTxLimitExempt[DEAD] = true;

        _balances[_owner] = _totalSupply;
        emit Transfer(address(0), _owner, _totalSupply);
    }

    receive() external payable {}

    function totalSupply() external view override returns (uint256) {return _totalSupply;}

    function decimals() external pure override returns (uint8) {return _decimals;}

    function symbol() external pure override returns (string memory) {return _symbol;}

    function name() external pure override returns (string memory) {return _name;}

    function getOwner() external view override returns (address) {return owner;}

    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}

    function allowance(address holder, address spender) external view override returns (uint256) {return _allowances[holder][spender];}

    function approve(address spender, uint256 amount) public override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function approveMax(address spender) external returns (bool) {
        return approve(spender, type(uint256).max);
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        return _transferFrom(msg.sender, recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        if (_allowances[sender][msg.sender] != type(uint256).max) {
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, "Insufficient Allowance");
        }

        return _transferFrom(sender, recipient, amount);
    }

    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if (inSwap) {
            return _basicTransfer(sender, recipient, amount);
        }

        if (recipient != pair && recipient != DEAD) {
            require(isTxLimitExempt[recipient] || _balances[recipient] + amount <= _maxWalletAmount, "Transfer amount exceeds the bag size.");
        }if (shouldSwapBack()) {
            swapBack();
        }

        _balances[sender] = _balances[sender].sub(amount, "Insufficient Balance");

        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountReceived);

        emit Transfer(sender, recipient, amountReceived);
        return true;
    }

    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
        _balances[sender] = _balances[sender].sub(amount, "Insufficient Balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function shouldTakeFee(address sender) internal view returns (bool) {
        return !isFeeExempt[sender];
    }

    function takeFee(address sender, uint256 amount) internal returns (uint256) {
        uint256 feeAmount = amount.mul(totalFee).div(feeDenominator);
        _balances[address(this)] = _balances[address(this)].add(feeAmount);
        emit Transfer(sender, address(this), feeAmount);
        return amount.sub(feeAmount);
    }

    function shouldSwapBack() internal view returns (bool) {
        return msg.sender != pair
        && !inSwap
        && swapEnabled
        && _balances[address(this)] >= swapThreshold;
    }

    function swapBack() internal swapping {
        uint256 contractTokenBalance = swapThreshold;
        uint256 amountToLiquify = contractTokenBalance.mul(liquidityFee).div(totalFee).div(2);
        uint256 amountToSwap = contractTokenBalance.sub(amountToLiquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();

        uint256 balanceBefore = address(this).balance;

        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            amountToSwap,
            0,
            path,
            address(this),
            block.timestamp
        );
        uint256 amountETH = address(this).balance.sub(balanceBefore);
        uint256 totalETHFee = totalFee.sub(liquidityFee.div(2));
        uint256 amountETHLiquidity = amountETH.mul(liquidityFee).div(totalETHFee).div(2);
        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(totalETHFee);


        (bool MarketingSuccess, /* bytes memory data */) = payable(marketingFeeReceiver).call{value : amountETHMarketing, gas : 30000}("");
        require(MarketingSuccess, "receiver rejected ETH transfer");

        if (amountToLiquify > 0) {
            router.addLiquidityETH{value : amountETHLiquidity}(
                address(this),
                amountToLiquify,
                0,
                0,
                DEAD,
                block.timestamp
            );
            emit AutoLiquify(amountETHLiquidity, amountToLiquify);
        }
    }

    function buyTokens(uint256 amount, address to) internal swapping {
        address[] memory path = new address[](2);
        path[0] = router.WETH();
        path[1] = address(this);

        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value : amount}(
            0,
            path,
            to,
            block.timestamp
        );
    }

    function clearStuckBalance() external {
        payable(marketingFeeReceiver).transfer(address(this).balance);
    }

    function clearStuckTBalance() external {
        _basicTransfer(address(this), marketingFeeReceiver, balanceOf(address(this)));
    }

    function setWalletLimit(uint256 amountPercent) external onlyOwner {
        _maxWalletAmount = (_totalSupply * amountPercent) / 1000;
    }

    function setSwapThreshold(uint256 _swapThreshold) external onlyOwner {
        swapThreshold = _totalSupply / 100000 * _swapThreshold;
    }

    function turnMF(bool _on) public onlyOwner {
        if (_on) {
            marketingFee = 30;
            totalFee = liquidityFee + marketingFee;
        } else {
            marketingFee = 0;
            totalFee = liquidityFee + marketingFee;
        }
    }

    event AutoLiquify(uint256 amountETH, uint256 amountBOG);
}