{"SourceCode": "// BLOCKCLOUT is a social DeFi network for cryptocurrency enthusiasts \r\n// https://blockclout.com\r\n// https://blockclout.com/staking\r\n// https://discord.gg/HDc2U5M\r\n// https://t.me/blockcloutENG\r\n// https://reddit.com/r/blockcloutENG\r\n// https://medium.com/@blockclout\r\npragma solidity ^ 0.4.26;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(\r\n        uint256 a, \r\n        uint256 b\r\n    ) \r\n        internal \r\n        pure \r\n        returns(uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(\r\n        uint256 a, \r\n        uint256 b\r\n    ) \r\n        internal \r\n        pure \r\n        returns(uint256) \r\n    {\r\n        return a / b;\r\n    }\r\n    \r\n    function sub(\r\n        uint256 a, \r\n        uint256 b\r\n    ) \r\n        internal \r\n        pure \r\n        returns(uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(\r\n        uint256 a, \r\n        uint256 b\r\n    ) \r\n        internal \r\n        pure \r\n        returns(uint256 c) \r\n    {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract IERC20 {\r\n\r\n    function totalSupply() \r\n        external \r\n        view \r\n        returns(uint256);\r\n    \r\n    function balanceOf(\r\n        address account\r\n    ) \r\n        external \r\n        view \r\n        returns(uint256);\r\n    \r\n    function transfer(\r\n        address recipient, \r\n        uint256 amount\r\n    ) \r\n        external \r\n        returns(bool);\r\n    \r\n    function allowance(\r\n        address owner, \r\n        address spender\r\n    ) \r\n        external \r\n        view \r\n        returns(uint256);\r\n    \r\n    function approve(\r\n        address spender, \r\n        uint256 amount\r\n    ) \r\n        external returns(bool);\r\n    \r\n    function transferFrom(\r\n        address sender, \r\n        address recipient, \r\n        uint256 amount\r\n    ) \r\n        external returns(bool);\r\n\r\n}\r\n\r\n\r\ncontract BlockStake {\r\n\r\n    mapping(address => bool) internal ambassadors_;\r\n\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1000000e18;\r\n\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n\r\n    bool public onlyAmbassadors = true;\r\n\r\n    uint256 ACTIVATION_TIME = now;\r\n\r\n    modifier antiEarlyWhale(\r\n        uint256 _amountOfERC20, \r\n        address _customerAddress\r\n    )\r\n    {\r\n        if (now >= ACTIVATION_TIME) {\r\n            onlyAmbassadors = false;\r\n        }\r\n        \r\n        if (onlyAmbassadors) {\r\n            \r\n            require((ambassadors_[_customerAddress] == true && \r\n            \r\n            (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfERC20) <= \r\n                ambassadorMaxPurchase_));\r\n                \r\n            ambassadorAccumulatedQuota_[_customerAddress] = \r\n                SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfERC20);\r\n    \r\n            _;\r\n        \r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyTokenHolders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDivis {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n    event onDistribute(\r\n        address indexed customerAddress,\r\n        uint256 price\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingERC20,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ERC20Earned,\r\n        uint timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ERC20Reinvested,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ERC20Withdrawn\r\n    );\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n    string public name = \"BlockStake\";\r\n    \r\n    string public symbol = \"BLOCK\";\r\n    \r\n    uint8 constant public decimals = 18;\r\n    \r\n    uint256 internal entryFee_ = 5;\r\n    \r\n    uint256 internal exitFee_ = 15;\r\n    \r\n    uint256 internal referralFee_ = 10;\r\n    \r\n    uint256 internal maintenanceFee_ = 5;\r\n    \r\n    address internal maintenanceAddress;\r\n    \r\n    uint256 constant internal magnitude = 2 ** 64;\r\n    \r\n    mapping(address => uint256) public tokenBalanceLedger_;\r\n    \r\n    mapping(address => uint256) public referralBalance_;\r\n    \r\n    mapping(address => uint256) public totalReferralEarnings_;\r\n    \r\n    mapping(address => int256) public payoutsTo_;\r\n    \r\n    mapping(address => uint256) public invested_;\r\n    \r\n    uint256 internal tokenSupply_;\r\n    \r\n    uint256 internal profitPerShare_;\r\n    \r\n    IERC20 erc20;\r\n\r\n    constructor() public {\r\n        maintenanceAddress = address(0x03298351da3fceED5Ad95Bd3e32829b4740EA277);\r\n        erc20 = IERC20(address(0xa10ae543db5d967a73e9abcc69c81a18a7fc0a78));\r\n    }\r\n    \r\n    function checkAndTransfer(\r\n        uint256 _amount\r\n    ) \r\n        private \r\n    {\r\n        require(\r\n            erc20.transferFrom(\r\n                msg.sender, \r\n                address(this), \r\n                _amount\r\n            ) == true, \"transfer must succeed\"\r\n        );\r\n    }\r\n\r\n    function buy(\r\n        uint256 _amount, \r\n        address _referredBy\r\n    ) \r\n        public \r\n        returns(uint256) \r\n    {\r\n        checkAndTransfer(_amount);\r\n        \r\n        return purchaseTokens(\r\n            _referredBy, \r\n            msg.sender, \r\n            _amount\r\n        );\r\n    }\r\n    \r\n    function buyFor(\r\n        uint256 _amount, \r\n        address _customerAddress, \r\n        address _referredBy\r\n    ) \r\n        public \r\n        returns(uint256) \r\n    {\r\n        checkAndTransfer(_amount);\r\n        return purchaseTokens(\r\n            _referredBy, \r\n            _customerAddress,\r\n            _amount\r\n        );\r\n    }\r\n    \r\n    function() payable public {\r\n        revert();\r\n    }\r\n    \r\n    function reinvest() \r\n        onlyDivis \r\n        public \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        uint256 _dividends = myDividends(false);\r\n        \r\n        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n        \r\n        _dividends += referralBalance_[_customerAddress];\r\n        \r\n        referralBalance_[_customerAddress] = 0;\r\n        \r\n        uint256 _tokens = purchaseTokens(0x0, _customerAddress, _dividends);\r\n        \r\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    \r\n    function exit() external {\r\n        \r\n        address _customerAddress = msg.sender;\r\n        \r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        \r\n        if (_tokens > 0) sell(_tokens);\r\n        \r\n        withdraw();\r\n    }\r\n    \r\n    function withdraw() \r\n        onlyDivis\r\n        public \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        uint256 _dividends = myDividends(false);\r\n        \r\n        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n        \r\n        _dividends += referralBalance_[_customerAddress];\r\n        \r\n        referralBalance_[_customerAddress] = 0;\r\n        \r\n        erc20.transfer(_customerAddress, _dividends);\r\n        \r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n    function sell(\r\n        uint256 _amountOfERC20s\r\n    ) \r\n        onlyTokenHolders \r\n        public \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfERC20s <= tokenBalanceLedger_[_customerAddress]);\r\n        \r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_amountOfERC20s, exitFee_), 100);\r\n        uint256 _taxedERC20 = SafeMath.sub(_amountOfERC20s, _dividends);\r\n        \r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfERC20s);\r\n        \r\n        tokenBalanceLedger_[_customerAddress] = \r\n            SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfERC20s);\r\n        \r\n        int256 _updatedPayouts = \r\n            (int256)(profitPerShare_ * _amountOfERC20s + (_taxedERC20 * magnitude));\r\n            \r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        \r\n        if (tokenSupply_ > 0) {\r\n            profitPerShare_ = SafeMath.add(\r\n                profitPerShare_, (_dividends * magnitude) / tokenSupply_\r\n            );\r\n        }\r\n        \r\n        emit Transfer(_customerAddress, address(0), _amountOfERC20s);\r\n        emit onTokenSell(_customerAddress, _amountOfERC20s, _taxedERC20, now);\r\n    }\r\n    \r\n    function transfer(\r\n        address _toAddress, \r\n        uint256 _amountOfERC20s\r\n    ) \r\n        onlyTokenHolders \r\n        external \r\n        returns(bool) \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfERC20s <= tokenBalanceLedger_[_customerAddress]);\r\n    \r\n        if (myDividends(true) > 0) {\r\n            withdraw();\r\n        }\r\n        \r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfERC20s);\r\n        \r\n        tokenBalanceLedger_[_customerAddress] = \r\n            SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfERC20s);\r\n            \r\n        tokenBalanceLedger_[_toAddress] = \r\n            SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfERC20s);\r\n        \r\n        payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfERC20s);\r\n        payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _amountOfERC20s);\r\n        \r\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_amountOfERC20s * magnitude) / tokenSupply_);\r\n        \r\n        emit Transfer(_customerAddress, _toAddress, _amountOfERC20s);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function totalERC20Balance() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return erc20.balanceOf(address(this));\r\n    }\r\n\r\n    function totalSupply() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    function myTokens() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    function myDividends(\r\n        bool _includeReferralBonus\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + \r\n            referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n    }\r\n    \r\n    function balanceOf(\r\n        address _customerAddress\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    function dividendsOf(\r\n        address _customerAddress\r\n    ) \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return (uint256)((int256)(\r\n            profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - \r\n            payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n    \r\n    function sellPrice() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        uint256 _erc20 = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_erc20, exitFee_), 100);\r\n        uint256 _taxedERC20 = SafeMath.sub(_erc20, _dividends);\r\n        \r\n        return _taxedERC20;\r\n    }\r\n    \r\n    function buyPrice() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        uint256 _erc20 = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_erc20, entryFee_), 100);\r\n        uint256 _taxedERC20 = SafeMath.add(_erc20, _dividends);\r\n        \r\n        return _taxedERC20;\r\n    }\r\n    \r\n    function getInvested() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return invested_[msg.sender];\r\n    }\r\n    \r\n    function totalReferralEarnings(\r\n        address _client\r\n    )\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return totalReferralEarnings_[_client];\r\n    }\r\n    \r\n    function referralBalance(\r\n        address _client \r\n    )\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return referralBalance_[_client];\r\n    }\r\n    \r\n    function purchaseTokens(\r\n        address _referredBy, \r\n        address _customerAddress, \r\n        uint256 _incomingERC20\r\n    ) \r\n        internal \r\n        antiEarlyWhale(_incomingERC20, _customerAddress) \r\n        returns(uint256) \r\n    {\r\n    invested_[msg.sender] += _incomingERC20;\r\n    \r\n    uint256 _undividedDividends = \r\n        SafeMath.div(\r\n            SafeMath.mul(\r\n                _incomingERC20, entryFee_\r\n            ), \r\n        100);\r\n    \r\n    uint256 _maintenance = \r\n        SafeMath.div(\r\n            SafeMath.mul(\r\n                _undividedDividends, maintenanceFee_\r\n            ), \r\n        100);\r\n        \r\n        \r\n    uint256 _referralBonus = \r\n        SafeMath.div(\r\n            SafeMath.mul(\r\n                _undividedDividends, referralFee_\r\n            ), \r\n        100);\r\n    \r\n    uint256 _dividends = \r\n        SafeMath.sub(\r\n            _undividedDividends, SafeMath.add(\r\n                _referralBonus, _maintenance\r\n            )\r\n        );\r\n        \r\n    uint256 _amountOfERC20s = \r\n        SafeMath.sub(_incomingERC20, _undividedDividends);\r\n        \r\n    uint256 _fee = _dividends * magnitude;\r\n    \r\n    require(\r\n        _amountOfERC20s > 0 && \r\n        SafeMath.add(_amountOfERC20s, tokenSupply_) > tokenSupply_\r\n    );\r\n    \r\n    referralBalance_[maintenanceAddress] = \r\n        SafeMath.add(referralBalance_[maintenanceAddress], _maintenance);\r\n    \r\n    if (_referredBy != address(0) && \r\n        _referredBy != _customerAddress)\r\n    {\r\n        referralBalance_[_referredBy] = \r\n            SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n            \r\n        totalReferralEarnings_[_referredBy] = \r\n            SafeMath.add(totalReferralEarnings_[_referredBy], _referralBonus);\r\n    } else {\r\n        _dividends = SafeMath.add(_dividends, _referralBonus);\r\n        _fee = _dividends * magnitude;\r\n    }\r\n    \r\n    if (tokenSupply_ > 0) \r\n    {\r\n        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfERC20s);\r\n        \r\n        profitPerShare_ += ((_dividends * magnitude) / (tokenSupply_));\r\n        _fee = _fee - (_fee - (_amountOfERC20s * ((_dividends * magnitude) / (tokenSupply_))));\r\n        \r\n    } else {\r\n        tokenSupply_ = _amountOfERC20s;\r\n    }\r\n\r\n    tokenBalanceLedger_[_customerAddress] = \r\n        SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfERC20s);\r\n    \r\n    int256 _updatedPayouts = (int256)((profitPerShare_ * _amountOfERC20s) - _fee);\r\n        \r\n    payoutsTo_[_customerAddress] += _updatedPayouts;\r\n    \r\n    emit Transfer(\r\n        address(0), \r\n        msg.sender, \r\n        _amountOfERC20s\r\n    );\r\n    \r\n    emit onTokenPurchase(\r\n        _customerAddress, \r\n        _incomingERC20, \r\n        _amountOfERC20s, \r\n        _referredBy, \r\n        now\r\n    );\r\n    \r\n    return _amountOfERC20s;\r\n    }\r\n\r\n    function multiData()\r\n    public\r\n    view\r\n    returns(\r\n        uint256, \r\n        uint256, \r\n        uint256, \r\n        uint256, \r\n        uint256, \r\n        uint256, \r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    )\r\n    {\r\n        return (\r\n        \r\n        // [0] Total ERC20 in contract \r\n        totalERC20Balance(),\r\n        \r\n        // [1] Total STAKE TOKEN supply\r\n        totalSupply(),\r\n        \r\n        // [2] User STAKE TOKEN balance \r\n        balanceOf(msg.sender),\r\n        \r\n        // [3] User ERC20 balance\r\n        erc20.balanceOf(msg.sender),\r\n        \r\n        // [4] User divs \r\n        dividendsOf(msg.sender),\r\n        \r\n        // [5] Buy price \r\n        buyPrice(),\r\n        \r\n        // [6] Sell price \r\n        sellPrice(),\r\n        \r\n        // [7] Total referral earnings  \r\n        totalReferralEarnings(msg.sender),\r\n        \r\n        // [8] Current referral earnings \r\n        referralBalance(msg.sender)\r\n        );\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_customerAddress\",\"type\":\"address\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"totalReferralEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"referralBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceLedger_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralEarnings_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfERC20s\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBalance_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payoutsTo_\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfERC20s\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalERC20Balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingERC20\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ERC20Earned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ERC20Reinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ERC20Withdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "BlockStake", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://25bdbc6d092025c93165d5399ef4cf166651ba07160cf44faac94a2a73f30c5d"}