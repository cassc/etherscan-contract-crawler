{"SourceCode": "// File: contracts/lib/InitializableOwnable.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/FeeRateModel.sol\r\n\r\n\r\ninterface IFeeRateImpl {\r\n    function getFeeRate(address pool, address trader) external view returns (uint256);\r\n}\r\n\r\ninterface IFeeRateModel {\r\n    function getFeeRate(address trader) external view returns (uint256);\r\n}\r\n\r\ncontract FeeRateModel is InitializableOwnable {\r\n    address public feeRateImpl;\r\n\r\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\r\n        feeRateImpl = _feeRateImpl;\r\n    }\r\n    \r\n    function getFeeRate(address trader) external view returns (uint256) {\r\n        if(feeRateImpl == address(0))\r\n            return 0;\r\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\r\n    }\r\n}\r\n\r\n// File: contracts/intf/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author DODO Breeder\r\n *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DODOMath.sol\r\n\r\n\r\n/**\r\n * @title DODOMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\r\n */\r\nlibrary DODOMath {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n        Integrate dodo curve from V1 to V2\r\n        require V0>=V1>=V2>0\r\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\r\n        let V1-V2=delta\r\n        res = i*delta*(1-k+k(V0^2/V1/V2))\r\n\r\n        i is the price of V-res trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _GeneralIntegrate(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 V2,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\r\n        if (k == 0) {\r\n            return fairAmount.div(DecimalMath.ONE);\r\n        }\r\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\r\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\r\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\r\n    }\r\n\r\n    /*\r\n        Follow the integration function above\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\r\n\r\n        i is the price of delta-V trading pair\r\n        give out target of V\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTarget(\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        if (V1 == 0) {\r\n            return 0;\r\n        }\r\n        if (k == 0) {\r\n            return V1.add(DecimalMath.mulFloor(i, delta));\r\n        }\r\n        // V0 = V1*(1+(sqrt-1)/2k)\r\n        // sqrt = \u221a(1+4kidelta/V1)\r\n        // premium = 1+(sqrt-1)/2k\r\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n        uint256 sqrt;\r\n        uint256 ki = (4 * k).mul(i);\r\n        if (ki == 0) {\r\n            sqrt = DecimalMath.ONE;\r\n        } else if ((ki * delta) / ki == delta) {\r\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n        } else {\r\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\r\n        }\r\n        uint256 premium =\r\n            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\r\n        // V0 is greater than or equal to V1 according to the solution\r\n        return DecimalMath.mulFloor(V1, premium);\r\n    }\r\n\r\n    /*\r\n        Follow the integration expression above, we have:\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Given Q1 and deltaB, solve Q2\r\n        This is a quadratic function and the standard version is\r\n        aQ2^2 + bQ2 + c = 0, where\r\n        a=1-k\r\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\r\n        c=-kQ0^2 \r\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\r\n        note: another root is negative, abondan\r\n\r\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\r\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\r\n        return |Q1-Q2|\r\n\r\n        as we only support sell amount as delta, the deltaB is always negative\r\n        the input ideltaB is actually -ideltaB in the equation\r\n\r\n        i is the price of delta-V trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTrade(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        if (delta == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (k == 0) {\r\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\r\n        }\r\n\r\n        if (k == DecimalMath.ONE) {\r\n            // if k==1\r\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\r\n            // temp = ideltaBQ1/Q0/Q0\r\n            // Q2 = Q1/(1+temp)\r\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\r\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\r\n            uint256 temp;\r\n            uint256 idelta = i.mul(delta);\r\n            if (idelta == 0) {\r\n                temp = 0;\r\n            } else if ((idelta * V1) / idelta == V1) {\r\n                temp = (idelta * V1).div(V0.mul(V0));\r\n            } else {\r\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\r\n            }\r\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\r\n        }\r\n\r\n        // calculate -b value and sig\r\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\r\n        // part1 = (1-k)Q1 >=0\r\n        // part2 = kQ0^2/Q1-i*deltaB >=0\r\n        // bAbs = abs(part1-part2)\r\n        // if part1>part2 => b is negative => bSig is false\r\n        // if part2>part1 => b is positive => bSig is true\r\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\r\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\r\n\r\n        bool bSig;\r\n        if (bAbs >= part2) {\r\n            bAbs = bAbs - part2;\r\n            bSig = false;\r\n        } else {\r\n            bAbs = part2 - bAbs;\r\n            bSig = true;\r\n        }\r\n        bAbs = bAbs.div(DecimalMath.ONE);\r\n\r\n        // calculate sqrt\r\n        uint256 squareRoot =\r\n            DecimalMath.mulFloor(\r\n                DecimalMath.ONE.sub(k).mul(4),\r\n                DecimalMath.mulFloor(k, V0).mul(V0)\r\n            ); // 4(1-k)kQ0^2\r\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\r\n\r\n        // final res\r\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\r\n        uint256 numerator;\r\n        if (bSig) {\r\n            numerator = squareRoot.sub(bAbs);\r\n        } else {\r\n            numerator = bAbs.add(squareRoot);\r\n        }\r\n\r\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\r\n        if (V2 > V1) {\r\n            return 0;\r\n        } else {\r\n            return V1 - V2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/PMMPricing.sol\r\n\r\n\r\n/**\r\n * @title Pricing\r\n * @author DODO Breeder\r\n *\r\n * @notice DODO Pricing model\r\n */\r\n\r\nlibrary PMMPricing {\r\n    using SafeMath for uint256;\r\n\r\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\r\n\r\n    struct PMMState {\r\n        uint256 i;\r\n        uint256 K;\r\n        uint256 B;\r\n        uint256 Q;\r\n        uint256 B0;\r\n        uint256 Q0;\r\n        RState R;\r\n    }\r\n\r\n    // ============ buy & sell ============\r\n\r\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveQuoteAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            // case 1: R=1\r\n            // R falls below one\r\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            uint256 backToOnePayBase = state.B0.sub(state.B);\r\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\r\n            // case 2: R>1\r\n            // complex case, R status depends on trading amount\r\n            if (payBaseAmount < backToOnePayBase) {\r\n                // case 2.1: R status do not change\r\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\r\n                newR = RState.ABOVE_ONE;\r\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\r\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\r\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\r\n                    receiveQuoteAmount = backToOneReceiveQuote;\r\n                }\r\n            } else if (payBaseAmount == backToOnePayBase) {\r\n                // case 2.2: R status changes to ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote;\r\n                newR = RState.ONE;\r\n            } else {\r\n                // case 2.3: R status changes to BELOW_ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote.add(\r\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\r\n                );\r\n                newR = RState.BELOW_ONE;\r\n            }\r\n        } else {\r\n            // state.R == RState.BELOW_ONE\r\n            // case 3: R<1\r\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        }\r\n    }\r\n\r\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveBaseAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else {\r\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\r\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\r\n            if (payQuoteAmount < backToOnePayQuote) {\r\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\r\n                newR = RState.BELOW_ONE;\r\n                if (receiveBaseAmount > backToOneReceiveBase) {\r\n                    receiveBaseAmount = backToOneReceiveBase;\r\n                }\r\n            } else if (payQuoteAmount == backToOnePayQuote) {\r\n                receiveBaseAmount = backToOneReceiveBase;\r\n                newR = RState.ONE;\r\n            } else {\r\n                receiveBaseAmount = backToOneReceiveBase.add(\r\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\r\n                );\r\n                newR = RState.ABOVE_ONE;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ R = 1 cases ============\r\n\r\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        // in theory Q2 <= targetQuoteTokenAmount\r\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q0,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B0,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R < 1 cases ============\r\n\r\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._GeneralIntegrate(\r\n                state.Q0,\r\n                state.Q.add(payQuoteAmount),\r\n                state.Q,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R > 1 cases ============\r\n\r\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._GeneralIntegrate(\r\n                state.B0,\r\n                state.B.add(payBaseAmount),\r\n                state.B,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ Helper functions ============\r\n\r\n    function adjustedTarget(PMMState memory state) internal pure {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\r\n                state.Q,\r\n                state.B.sub(state.B0),\r\n                state.i,\r\n                state.K\r\n            );\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\r\n                state.B,\r\n                state.Q.sub(state.Q0),\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n        }\r\n    }\r\n\r\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.divFloor(state.i, R);\r\n        } else {\r\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.mulFloor(state.i, R);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/impl/DVMStorage.sol\r\n\r\n\r\ncontract DVMStorage is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    bool public _IS_OPEN_TWAP_ = false;\r\n\r\n    bool internal _DVM_INITIALIZED_;\r\n\r\n    // ============ Core Address ============\r\n\r\n    address public _MAINTAINER_;\r\n\r\n    IERC20 public _BASE_TOKEN_;\r\n    IERC20 public _QUOTE_TOKEN_;\r\n\r\n    uint112 public _BASE_RESERVE_;\r\n    uint112 public _QUOTE_RESERVE_;\r\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\r\n\r\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    string public name;\r\n\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) internal _SHARES_;\r\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\r\n\r\n    // ================= Permit ======================\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    // ============ Variables for Pricing ============\r\n\r\n    uint256 public _LP_FEE_RATE_;\r\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\r\n    uint256 public _K_;\r\n    uint256 public _I_;\r\n\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\r\n        state.i = _I_;\r\n        state.K = _K_;\r\n        state.B = _BASE_RESERVE_;\r\n        state.Q = _QUOTE_RESERVE_;\r\n        state.B0 = 0; // will be calculated in adjustedTarget\r\n        state.Q0 = 0;\r\n        state.R = PMMPricing.RState.ABOVE_ONE;\r\n        PMMPricing.adjustedTarget(state);\r\n    }\r\n\r\n    function getPMMStateForCall() \r\n        external \r\n        view \r\n        returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        i = state.i;\r\n        K = state.K;\r\n        B = state.B;\r\n        Q = state.Q;\r\n        B0 = state.B0;\r\n        Q0 = state.Q0;\r\n        R = uint256(state.R);\r\n    }\r\n\r\n    function getMidPrice() public view returns (uint256 midPrice) {\r\n        return PMMPricing.getMidPrice(getPMMState());\r\n    }\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/impl/DVMVault.sol\r\n\r\n\r\ncontract DVMVault is DVMStorage {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Events ============\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    event Mint(address indexed user, uint256 value);\r\n\r\n    event Burn(address indexed user, uint256 value);\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\r\n        baseReserve = _BASE_RESERVE_;\r\n        quoteReserve = _QUOTE_RESERVE_;\r\n    }\r\n\r\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\r\n        lpFeeRate = _LP_FEE_RATE_;\r\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\r\n    }\r\n\r\n    // ============ Asset In ============\r\n\r\n    function getBaseInput() public view returns (uint256 input) {\r\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\r\n    }\r\n\r\n    function getQuoteInput() public view returns (uint256 input) {\r\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\r\n    }\r\n\r\n    // ============ TWAP UPDATE ===========\r\n    \r\n    function _twapUpdate() internal {\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\r\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\r\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\r\n        }\r\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\r\n    }\r\n\r\n    // ============ Set States ============\r\n\r\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\r\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\r\n        _BASE_RESERVE_ = uint112(baseReserve);\r\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function _sync() internal {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n        if (baseBalance != _BASE_RESERVE_) {\r\n            _BASE_RESERVE_ = uint112(baseBalance);\r\n        }\r\n        if (quoteBalance != _QUOTE_RESERVE_) {\r\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        }\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n\r\n    function sync() external preventReentrant {\r\n        _sync();\r\n    }\r\n\r\n    // ============ Asset Out ============\r\n\r\n    function _transferBaseOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _BASE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function _transferQuoteOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the the balance of.\r\n     * @return balance An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance) {\r\n        return _SHARES_[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param amount uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[from] = _SHARES_[from].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param spender The address which will spend the funds.\r\n     * @param amount The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        _ALLOWED_[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _ALLOWED_[owner][spender];\r\n    }\r\n\r\n    function _mint(address user, uint256 value) internal {\r\n        require(value > 1000, \"MINT_INVALID\");\r\n        _SHARES_[user] = _SHARES_[user].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(user, value);\r\n        emit Transfer(address(0), user, value);\r\n    }\r\n\r\n    function _burn(address user, uint256 value) internal {\r\n        _SHARES_[user] = _SHARES_[user].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(user, value);\r\n        emit Transfer(user, address(0), value);\r\n    }\r\n\r\n    // ============================ Permit ======================================\r\n    \r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"DODO_DVM_LP: EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)\r\n                )\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"DODO_DVM_LP: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts/intf/IDODOCallee.sol\r\n\r\n\r\ninterface IDODOCallee {\r\n    function DVMSellShareCall(\r\n        address sender,\r\n        uint256 burnShareAmount,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DVMFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DPPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function CPCancelCall(\r\n        address sender,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n\tfunction CPClaimBidCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/impl/DVMTrader.sol\r\n\r\n\r\n\r\ncontract DVMTrader is DVMVault {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    event DODOSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromAmount,\r\n        uint256 toAmount,\r\n        address trader,\r\n        address receiver\r\n    );\r\n\r\n    event DODOFlashLoan(\r\n        address borrower,\r\n        address assetTo,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount\r\n    );\r\n\r\n    // ============ Trade Functions ============\r\n\r\n    function sellBase(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveQuoteAmount)\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n        uint256 mtFee;\r\n        (receiveQuoteAmount, mtFee) = querySellBase(tx.origin, baseInput);\r\n\r\n        _transferQuoteOut(to, receiveQuoteAmount);\r\n        _transferQuoteOut(_MAINTAINER_, mtFee);\r\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\r\n\r\n        emit DODOSwap(\r\n            address(_BASE_TOKEN_),\r\n            address(_QUOTE_TOKEN_),\r\n            baseInput,\r\n            receiveQuoteAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function sellQuote(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveBaseAmount)\r\n    {\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n        uint256 mtFee;\r\n        (receiveBaseAmount, mtFee) = querySellQuote(tx.origin, quoteInput);\r\n\r\n        _transferBaseOut(to, receiveBaseAmount);\r\n        _transferBaseOut(_MAINTAINER_, mtFee);\r\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\r\n\r\n        emit DODOSwap(\r\n            address(_QUOTE_TOKEN_),\r\n            address(_BASE_TOKEN_),\r\n            quoteInput,\r\n            receiveBaseAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function flashLoan(\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        address assetTo,\r\n        bytes calldata data\r\n    ) external preventReentrant {\r\n        _transferBaseOut(assetTo, baseAmount);\r\n        _transferQuoteOut(assetTo, quoteAmount);\r\n\r\n        if (data.length > 0)\r\n            IDODOCallee(assetTo).DVMFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\r\n\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        \r\n        // no input -> pure loss\r\n        require(\r\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\r\n            \"FLASH_LOAN_FAILED\"\r\n        );\r\n\r\n        // sell quote\r\n        if (baseBalance < _BASE_RESERVE_) {\r\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n            (uint256 receiveBaseAmount, uint256 mtFee) = querySellQuote(tx.origin, quoteInput);\r\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferBaseOut(_MAINTAINER_, mtFee);\r\n            emit DODOSwap(\r\n                address(_QUOTE_TOKEN_),\r\n                address(_BASE_TOKEN_),\r\n                quoteInput,\r\n                receiveBaseAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        // sell base\r\n        if (quoteBalance < _QUOTE_RESERVE_) {\r\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n            (uint256 receiveQuoteAmount, uint256 mtFee) = querySellBase(tx.origin, baseInput);\r\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferQuoteOut(_MAINTAINER_, mtFee);\r\n            emit DODOSwap(\r\n                address(_BASE_TOKEN_),\r\n                address(_QUOTE_TOKEN_),\r\n                baseInput,\r\n                receiveQuoteAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        _sync();\r\n        \r\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\r\n    }\r\n\r\n    // ============ Query Functions ============\r\n\r\n    function querySellBase(address trader, uint256 payBaseAmount)\r\n        public\r\n        view\r\n        returns (uint256 receiveQuoteAmount, uint256 mtFee)\r\n    {\r\n        (receiveQuoteAmount, ) = PMMPricing.sellBaseToken(getPMMState(), payBaseAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\r\n        receiveQuoteAmount = receiveQuoteAmount\r\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n    }\r\n\r\n    function querySellQuote(address trader, uint256 payQuoteAmount)\r\n        public\r\n        view\r\n        returns (uint256 receiveBaseAmount, uint256 mtFee)\r\n    {\r\n        (receiveBaseAmount, ) = PMMPricing.sellQuoteToken(getPMMState(), payQuoteAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\r\n        receiveBaseAmount = receiveBaseAmount\r\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n    }\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/impl/DVMFunding.sol\r\n\r\n\r\ncontract DVMFunding is DVMVault {\r\n    // ============ Events ============\r\n\r\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\r\n\r\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\r\n\r\n    // ============ Buy & Sell Shares ============\r\n\r\n    // buy shares [round down]\r\n    function buyShares(address to)\r\n        external\r\n        preventReentrant\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseInput,\r\n            uint256 quoteInput\r\n        )\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseReserve = _BASE_RESERVE_;\r\n        uint256 quoteReserve = _QUOTE_RESERVE_;\r\n\r\n        baseInput = baseBalance.sub(baseReserve);\r\n        quoteInput = quoteBalance.sub(quoteReserve);\r\n        require(baseInput > 0, \"NO_BASE_INPUT\");\r\n\r\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\r\n        // But May Happen\uff0creserve >0 But totalSupply = 0\r\n        if (totalSupply == 0) {\r\n            // case 1. initial supply\r\n            require(baseBalance >= 10**3, \"INSUFFICIENT_LIQUIDITY_MINED\");\r\n            shares = baseBalance; // \u4ee5\u514d\u51fa\u73b0balance\u5f88\u5927\u4f46shares\u5f88\u5c0f\u7684\u60c5\u51b5\r\n        } else if (baseReserve > 0 && quoteReserve == 0) {\r\n            // case 2. supply when quote reserve is 0\r\n            shares = baseInput.mul(totalSupply).div(baseReserve);\r\n        } else if (baseReserve > 0 && quoteReserve > 0) {\r\n            // case 3. normal case\r\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\r\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\r\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\r\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\r\n        }\r\n        _mint(to, shares);\r\n        _setReserve(baseBalance, quoteBalance);\r\n        emit BuyShares(to, shares, _SHARES_[to]);\r\n    }\r\n\r\n    // sell shares [round down]\r\n    function sellShares(\r\n        uint256 shareAmount,\r\n        address to,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        bytes calldata data,\r\n        uint256 deadline\r\n    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\r\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\r\n        require(shareAmount <= _SHARES_[msg.sender], \"DLP_NOT_ENOUGH\");\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 totalShares = totalSupply;\r\n\r\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\r\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\r\n\r\n        require(\r\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\r\n            \"WITHDRAW_NOT_ENOUGH\"\r\n        );\r\n\r\n        _burn(msg.sender, shareAmount);\r\n        _transferBaseOut(to, baseAmount);\r\n        _transferQuoteOut(to, quoteAmount);\r\n        _sync();\r\n\r\n        if (data.length > 0) {\r\n            IDODOCallee(to).DVMSellShareCall(\r\n                msg.sender,\r\n                shareAmount,\r\n                baseAmount,\r\n                quoteAmount,\r\n                data\r\n            );\r\n        }\r\n\r\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\r\n    }\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/impl/DVM.sol\r\n\r\n\r\n\r\n/**\r\n * @title DODO VendingMachine\r\n * @author DODO Breeder\r\n *\r\n * @notice DODOVendingMachine initialization\r\n */\r\ncontract DVM is DVMTrader, DVMFunding {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external {\r\n        require(!_DVM_INITIALIZED_, \"DVM_INITIALIZED\");\r\n        _DVM_INITIALIZED_ = true;\r\n        \r\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\r\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\r\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\r\n\r\n        require(i > 0 && i <= 10**36);\r\n        _I_ = i;\r\n\r\n        require(k <= 10**18);\r\n        _K_ = k;\r\n\r\n        _LP_FEE_RATE_ = lpFeeRate;\r\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\r\n        _MAINTAINER_ = maintainer;\r\n\r\n        _IS_OPEN_TWAP_ = isOpenTWAP;\r\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\r\n\r\n        string memory connect = \"_\";\r\n        string memory suffix = \"DLP\";\r\n\r\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\r\n        symbol = \"DLP\";\r\n        decimals = _BASE_TOKEN_.decimals();\r\n\r\n        // ============================== Permit ====================================\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        // ==========================================================================\r\n    }\r\n\r\n    function addressToShortString(address _addr) public pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(8);\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    // ============ Version Control ============\r\n    \r\n    function version() external pure returns (string memory) {\r\n        return \"DVM 1.0.2\";\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increaseShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"BuyShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"name\":\"DODOFlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"DODOSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreaseShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"SellShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_PRICE_CUMULATIVE_LAST_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_RESERVE_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_TOKEN_\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BLOCK_TIMESTAMP_LAST_\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_IS_OPEN_TWAP_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_I_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_K_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LP_FEE_RATE_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAINTAINER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MT_FEE_RATE_MODEL_\",\"outputs\":[{\"internalType\":\"contract IFeeRateModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_RESERVE_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_TOKEN_\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToShortString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"buyShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteInput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetTo\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMidPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"midPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPMMState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q0\",\"type\":\"uint256\"},{\"internalType\":\"enum PMMPricing.RState\",\"name\":\"R\",\"type\":\"uint8\"}],\"internalType\":\"struct PMMPricing.PMMState\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPMMStateForCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"R\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQuoteInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFeeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteReserve\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mtFeeRateModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpenTWAP\",\"type\":\"bool\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payBaseAmount\",\"type\":\"uint256\"}],\"name\":\"querySellBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveQuoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payQuoteAmount\",\"type\":\"uint256\"}],\"name\":\"querySellQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveBaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveQuoteAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveBaseAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shareAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"sellShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DVM", "CompilerVersion": "v0.6.9+commit.3e3065ac", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://091fc6365a8713bcf05581c2d55f770066459c0adc0542d3a25b6216925faf6e"}