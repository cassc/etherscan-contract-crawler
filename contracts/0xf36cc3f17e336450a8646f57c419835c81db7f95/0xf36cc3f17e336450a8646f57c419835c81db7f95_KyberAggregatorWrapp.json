{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\n\ncontract MainnetAuthAddresses {\n    address internal constant ADMIN_VAULT_ADDR = 0xCCf3d848e08b94478Ed8f46fFead3008faF581fD;\n    address internal constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n    address internal constant ADMIN_ADDR = 0x25eFA336886C74eA8E282ac466BdCd0199f85BB9; // USED IN ADMIN VAULT CONSTRUCTOR\n}\n\n\n\n\n\ncontract AuthHelper is MainnetAuthAddresses {\n}\n\n\n\n\n\ncontract AdminVault is AuthHelper {\n    address public owner;\n    address public admin;\n\n    error SenderNotAdmin();\n\n    constructor() {\n        owner = msg.sender;\n        admin = ADMIN_ADDR;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function changeOwner(address _owner) public {\n        if (admin != msg.sender){\n            revert SenderNotAdmin();\n        }\n        owner = _owner;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function changeAdmin(address _admin) public {\n        if (admin != msg.sender){\n            revert SenderNotAdmin();\n        }\n        admin = _admin;\n    }\n\n}\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\nlibrary Address {\n    //insufficient balance\n    error InsufficientBalance(uint256 available, uint256 required);\n    //unable to send value, recipient may have reverted\n    error SendingValueFail();\n    //insufficient balance for call\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\n    //call to non-contract\n    error NonContractCall();\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        uint256 balance = address(this).balance;\n        if (balance < amount){\n            revert InsufficientBalance(balance, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!(success)){\n            revert SendingValueFail();\n        }\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        uint256 balance = address(this).balance;\n        if (balance < value){\n            revert InsufficientBalanceForCall(balance, value);\n        }\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!(isContract(target))){\n            revert NonContractCall();\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\n\n\n\n\n\ncontract AdminAuth is AuthHelper {\n    using SafeERC20 for IERC20;\n\n    AdminVault public constant adminVault = AdminVault(ADMIN_VAULT_ADDR);\n\n    error SenderNotOwner();\n    error SenderNotAdmin();\n\n    modifier onlyOwner() {\n        if (adminVault.owner() != msg.sender){\n            revert SenderNotOwner();\n        }\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (adminVault.admin() != msg.sender){\n            revert SenderNotAdmin();\n        }\n        _;\n    }\n\n    /// @notice withdraw stuck funds\n    function withdrawStuckFunds(address _token, address _receiver, uint256 _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(_receiver).transfer(_amount);\n        } else {\n            IERC20(_token).safeTransfer(_receiver, _amount);\n        }\n    }\n\n    /// @notice Destroy the contract\n    function kill() public onlyAdmin {\n        selfdestruct(payable(msg.sender));\n    }\n}\n\n\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    error OnlyOwner();\n    error WrongFeeValue();\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        if (msg.sender != owner){\n            revert OnlyOwner();\n        }\n\n        if (!(_fee >= MAX_SERVICE_FEE || _fee == 0)){\n            revert WrongFeeValue();\n        }\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        if (msg.sender != owner){\n            revert OnlyOwner();\n        }\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n\n\n\n\n\nabstract contract IWETH {\n    function allowance(address, address) public virtual view returns (uint256);\n\n    function balanceOf(address) public virtual view returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool);\n\n    function deposit() public payable virtual;\n\n    function withdraw(uint256) public virtual;\n}\n\n\n\n\n\n\nlibrary TokenUtils {\n    using SafeERC20 for IERC20;\n\n    address public constant WSTETH_ADDR = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant STETH_ADDR = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    function approveToken(\n        address _tokenAddr,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_tokenAddr == ETH_ADDR) return;\n\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\n        }\n    }\n\n    function pullTokensIfNeeded(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // handle max uint amount\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, _from);\n        }\n\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        }\n\n        return _amount;\n    }\n\n    function withdrawTokens(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, address(this));\n        }\n\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\n            if (_token != ETH_ADDR) {\n                IERC20(_token).safeTransfer(_to, _amount);\n            } else {\n                (bool success, ) = _to.call{value: _amount}(\"\");\n                require(success, \"Eth send fail\");\n            }\n        }\n\n        return _amount;\n    }\n\n    function depositWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).deposit{value: _amount}();\n    }\n\n    function withdrawWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).withdraw(_amount);\n    }\n\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\n        if (_tokenAddr == ETH_ADDR) {\n            return _acc.balance;\n        } else {\n            return IERC20(_tokenAddr).balanceOf(_acc);\n        }\n    }\n\n    function getTokenDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}\n\n\n\n\n\n\n\ncontract DFSExchangeHelper {\n    \n    using TokenUtils for address;\n    \n    error InvalidOffchainData();\n    error OutOfRangeSlicingError();\n\n    using SafeERC20 for IERC20;\n\n    function sendLeftover(\n        address _srcAddr,\n        address _destAddr,\n        address payable _to\n    ) internal {\n        // clean out any eth leftover\n        TokenUtils.ETH_ADDR.withdrawTokens(_to, type(uint256).max);\n\n        _srcAddr.withdrawTokens(_to, type(uint256).max);\n        _destAddr.withdrawTokens(_to, type(uint256).max);\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        if (bs.length < start + 32){\n            revert OutOfRangeSlicingError();\n        }\n\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n\n    function writeUint256(\n        bytes memory _b,\n        uint256 _index,\n        uint256 _input\n    ) internal pure {\n        if (_b.length < _index + 32) {\n            revert InvalidOffchainData();\n        }\n\n        bytes32 input = bytes32(_input);\n\n        _index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(_b, _index), input)\n        }\n    }\n}\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\ncontract DFSExchangeData {\n\n    // first is empty to keep the legacy order in place\n    // EMPTY was _, but in >0.8.x using underscore as name is forbidden\n    enum ExchangeType { EMPTY, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ExchangeActionType { SELL, BUY }\n\n    struct OffchainData {\n        address wrapper;\n        address exchangeAddr;\n        address allowanceTarget;\n        uint256 price;\n        uint256 protocolFee;\n        bytes callData;\n    }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint256 srcAmount;\n        uint256 destAmount;\n        uint256 minPrice;\n        uint256 dfsFeeDivider; // service fee divider\n        address user; // user to check special fee\n        address wrapper;\n        bytes wrapperData;\n        OffchainData offchainData;\n    }\n\n    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\n        return abi.encode(_exData);\n    }\n\n    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\n        _exData = abi.decode(_data, (ExchangeData));\n    }\n}\n\n\n\n\n\nabstract contract IOffchainWrapper is DFSExchangeData {\n    function takeOrder(\n        ExchangeData memory _exData,\n        ExchangeActionType _type\n    ) virtual public payable returns (bool success, uint256);\n}\n\n\n\n\ninterface IExecutorHelper {\n  struct Swap {\n    bytes data;\n    bytes4 functionSelector;\n  }\n\n  struct SwapExecutorDescription {\n    Swap[][] swapSequences;\n    address tokenIn;\n    address tokenOut;\n    uint256 minTotalAmountOut;\n    address to;\n    uint256 deadline;\n    bytes destTokenFeeData;\n  }\n\n  struct UniSwap {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    address recipient;\n    uint256 collectAmount; // amount that should be transferred to the pool\n    uint32 swapFee;\n    uint32 feePrecision;\n    uint32 tokenWeightInput;\n  }\n\n  struct StableSwap {\n    address pool;\n    address tokenFrom;\n    address tokenTo;\n    uint8 tokenIndexFrom;\n    uint8 tokenIndexTo;\n    uint256 dx;\n    uint256 poolLength;\n    address poolLp;\n    bool isSaddle; // true: saddle, false: stable\n  }\n\n  struct CurveSwap {\n    address pool;\n    address tokenFrom;\n    address tokenTo;\n    int128 tokenIndexFrom;\n    int128 tokenIndexTo;\n    uint256 dx;\n    bool usePoolUnderlying;\n    bool useTriCrypto;\n  }\n\n  struct UniswapV3KSElastic {\n    address recipient;\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    uint256 swapAmount;\n    uint160 sqrtPriceLimitX96;\n    bool isUniV3; // true = UniV3, false = KSElastic\n  }\n\n  struct BalancerV2 {\n    address vault;\n    bytes32 poolId;\n    address assetIn;\n    address assetOut;\n    uint256 amount;\n  }\n\n  struct DODO {\n    address recipient;\n    address pool;\n    address tokenFrom;\n    address tokenTo;\n    uint256 amount;\n    address sellHelper;\n    bool isSellBase;\n    bool isVersion2;\n  }\n\n  struct GMX {\n    address vault;\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    address receiver;\n  }\n\n  struct Synthetix {\n    address synthetixProxy;\n    address tokenIn;\n    address tokenOut;\n    bytes32 sourceCurrencyKey;\n    uint256 sourceAmount;\n    bytes32 destinationCurrencyKey;\n    bool useAtomicExchange;\n  }\n\n  struct Platypus {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    address recipient;\n    uint256 collectAmount; // amount that should be transferred to the pool\n  }\n\n  struct PSM {\n    address router;\n    address tokenIn;\n    address tokenOut;\n    uint256 amountIn;\n    address recipient;\n  }\n\n  struct WSTETH {\n    address pool;\n    uint256 amount;\n    bool isWrapping;\n  }\n\n  struct Maverick {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    address recipient;\n    uint256 swapAmount;\n    uint256 sqrtPriceLimitD18;\n  }\n\n  struct SyncSwap {\n    bytes _data;\n    address vault;\n    address tokenIn;\n    address pool;\n    uint256 collectAmount;\n  }\n\n  struct AlgebraV1 {\n    address recipient;\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    uint256 swapAmount;\n    uint160 sqrtPriceLimitX96;\n    uint256 senderFeeOnTransfer; // [ FoT_FLAG(1 bit) ... SENDER_ADDRESS(160 bits) ]\n  }\n\n  struct BalancerBatch {\n    address vault;\n    bytes32[] poolIds;\n    address[] path; // swap path from assetIn to assetOut\n    bytes[] userDatas;\n    uint256 amountIn; // assetIn amount\n  }\n\n  struct Mantis {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    address recipient;\n  }\n\n  struct IziSwap {\n    address pool;\n    address tokenIn;\n    address tokenOut;\n    address recipient;\n    uint256 swapAmount;\n    int24 limitPoint;\n  }\n\n  function executeUniswap(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeStableSwap(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeCurve(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeKSClassic(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeUniV3KSElastic(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeRfq(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeBalV2(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeDODO(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeVelodrome(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeGMX(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executePlatypus(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeWrappedstETH(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeStEth(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeSynthetix(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeHashflow(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executePSM(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeFrax(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeCamelot(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeKyberLimitOrder(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeMaverick(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeSyncSwap(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeAlgebraV1(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeBalancerBatch(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeWombat(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeMantis(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n\n  function executeIziSwap(\n    bytes memory data,\n    uint256 flagsAndPrevAmountOut\n  ) external payable returns (uint256);\n}\n\n\n\n\ninterface IAggregationExecutor {\n  function callBytes(bytes calldata data) external payable; // 0xd9c45357\n\n  // callbytes per swap sequence\n  function swapSingleSequence(bytes calldata data) external;\n\n  function finalTransactionProcessing(\n    address tokenIn,\n    address tokenOut,\n    address to,\n    bytes calldata destTokenFeeData\n  ) external;\n}\n\n\n\n\n\ninterface IMetaAggregationRouterV2 {\n  struct SwapDescriptionV2 {\n    IERC20 srcToken;\n    IERC20 dstToken;\n    address[] srcReceivers; // transfer src token to these addresses, default\n    uint256[] srcAmounts;\n    address[] feeReceivers;\n    uint256[] feeAmounts;\n    address dstReceiver;\n    uint256 amount;\n    uint256 minReturnAmount;\n    uint256 flags;\n    bytes permit;\n  }\n\n  /// @dev  use for swapGeneric and swap to avoid stack too deep\n  struct SwapExecutionParams {\n    address callTarget; // call this address\n    address approveTarget; // approve this address if _APPROVE_FUND set\n    bytes targetData;\n    SwapDescriptionV2 desc;\n    bytes clientData;\n  }\n\n  function swap(SwapExecutionParams calldata execution) external payable returns (uint256, uint256);\n\n  function swapSimpleMode(\n    IAggregationExecutor caller,\n    SwapDescriptionV2 memory desc,\n    bytes calldata executorData,\n    bytes calldata clientData\n  ) external returns (uint256, uint256);\n}\n\n\n\n\n\ncontract KyberInputScalingHelper {\n    uint256 private constant _PARTIAL_FILL = 0x01;\n    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;\n    uint256 private constant _SHOULD_CLAIM = 0x04;\n    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;\n    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;\n    uint256 private constant _SIMPLE_SWAP = 0x20;\n\n    // fee data in case taking in dest token\n    struct PositiveSlippageFeeData {\n        uint256 partnerPSInfor; // [partnerReceiver (160 bit) + partnerPercent(96bits)]\n        uint256 expectedReturnAmount;\n    }\n\n    struct Swap {\n        bytes data;\n        bytes32 selectorAndFlags; // [selector (32 bits) + flags (224 bits)]; selector is 4 most significant bytes; flags are stored in 4 least significant bytes.\n    }\n\n    struct SimpleSwapData {\n        address[] firstPools;\n        uint256[] firstSwapAmounts;\n        bytes[] swapDatas;\n        uint256 deadline;\n        bytes positiveSlippageData;\n    }\n\n    struct SwapExecutorDescription {\n        Swap[][] swapSequences;\n        address tokenIn;\n        address tokenOut;\n        address to;\n        uint256 deadline;\n        bytes positiveSlippageData;\n    }\n\n    function getScaledInputData(\n        bytes calldata inputData,\n        uint256 newAmount\n    ) public pure returns (bytes memory) {\n        bytes4 selector = bytes4(inputData[:4]);\n        bytes calldata dataToDecode = inputData[4:];\n\n        if (selector == IMetaAggregationRouterV2.swap.selector) {\n            IMetaAggregationRouterV2.SwapExecutionParams memory params = abi.decode(\n                dataToDecode,\n                (IMetaAggregationRouterV2.SwapExecutionParams)\n            );\n\n            (params.desc, params.targetData) = _getScaledInputDataV2(\n                params.desc,\n                params.targetData,\n                newAmount,\n                _flagsChecked(params.desc.flags, _SIMPLE_SWAP)\n            );\n            return abi.encodeWithSelector(selector, params);\n        } else if (selector == IMetaAggregationRouterV2.swapSimpleMode.selector) {\n            (\n                address callTarget,\n                IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\n                bytes memory targetData,\n                bytes memory clientData\n            ) = abi.decode(\n                    dataToDecode,\n                    (address, IMetaAggregationRouterV2.SwapDescriptionV2, bytes, bytes)\n                );\n\n            (desc, targetData) = _getScaledInputDataV2(desc, targetData, newAmount, true);\n            return abi.encodeWithSelector(selector, callTarget, desc, targetData, clientData);\n        } else revert(\"InputScalingHelper: Invalid selector\");\n    }\n\n    function _getScaledInputDataV2(\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\n        bytes memory executorData,\n        uint256 newAmount,\n        bool isSimpleMode\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory, bytes memory) {\n        uint256 oldAmount = desc.amount;\n        if (oldAmount == newAmount) {\n            return (desc, executorData);\n        }\n\n        // simple mode swap\n        if (isSimpleMode) {\n            return (\n                _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\n                _scaledSimpleSwapData(executorData, oldAmount, newAmount)\n            );\n        }\n\n        //normal mode swap\n        return (\n            _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\n            _scaledExecutorCallBytesData(executorData, oldAmount, newAmount)\n        );\n    }\n\n    /// @dev Scale the swap description\n    function _scaledSwapDescriptionV2(\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory) {\n        desc.minReturnAmount = (desc.minReturnAmount * newAmount) / oldAmount;\n        if (desc.minReturnAmount == 0) desc.minReturnAmount = 1;\n        desc.amount = newAmount;\n\n        uint256 nReceivers = desc.srcReceivers.length;\n        for (uint256 i = 0; i < nReceivers; ) {\n            desc.srcAmounts[i] = (desc.srcAmounts[i] * newAmount) / oldAmount;\n            unchecked {\n                ++i;\n            }\n        }\n        return desc;\n    }\n\n    /// @dev Scale the executorData in case swapSimpleMode\n    function _scaledSimpleSwapData(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        SimpleSwapData memory swapData = abi.decode(data, (SimpleSwapData));\n\n        uint256 nPools = swapData.firstPools.length;\n        for (uint256 i = 0; i < nPools; ) {\n            swapData.firstSwapAmounts[i] = (swapData.firstSwapAmounts[i] * newAmount) / oldAmount;\n            unchecked {\n                ++i;\n            }\n        }\n        swapData.positiveSlippageData = _scaledPositiveSlippageFeeData(\n            swapData.positiveSlippageData,\n            oldAmount,\n            newAmount\n        );\n        return abi.encode(swapData);\n    }\n\n    function _scaledExecutorCallBytesData(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        SwapExecutorDescription memory executorDesc = abi.decode(data, (SwapExecutorDescription));\n\n        executorDesc.positiveSlippageData = _scaledPositiveSlippageFeeData(\n            executorDesc.positiveSlippageData,\n            oldAmount,\n            newAmount\n        );\n\n        uint256 nSequences = executorDesc.swapSequences.length;\n        for (uint256 i = 0; i < nSequences; ) {\n            Swap memory swap = executorDesc.swapSequences[i][0];\n            bytes4 functionSelector = bytes4(swap.selectorAndFlags);\n\n            if (functionSelector == IExecutorHelper.executeUniswap.selector) {\n                swap.data = newUniSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeStableSwap.selector) {\n                swap.data = newStableSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeCurve.selector) {\n                swap.data = newCurveSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeKSClassic.selector) {\n                swap.data = newKyberDMM(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeUniV3KSElastic.selector) {\n                swap.data = newUniV3ProMM(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeRfq.selector) {\n                revert(\"InputScalingHelper: Can not scale RFQ swap\");\n            } else if (functionSelector == IExecutorHelper.executeBalV2.selector) {\n                swap.data = newBalancerV2(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeWrappedstETH.selector) {\n                swap.data = newWrappedstETHSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeStEth.selector) {\n                swap.data = newStETHSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeDODO.selector) {\n                swap.data = newDODO(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeVelodrome.selector) {\n                swap.data = newVelodrome(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeGMX.selector) {\n                swap.data = newGMX(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeSynthetix.selector) {\n                swap.data = newSynthetix(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeHashflow.selector) {\n                revert(\"InputScalingHelper: Can not scale RFQ swap\");\n            } else if (functionSelector == IExecutorHelper.executeCamelot.selector) {\n                swap.data = newCamelot(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeKyberLimitOrder.selector) {\n                revert(\"InputScalingHelper: Can not scale RFQ swap\");\n            } else if (functionSelector == IExecutorHelper.executePSM.selector) {\n                swap.data = newPSM(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeFrax.selector) {\n                swap.data = newFrax(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executePlatypus.selector) {\n                swap.data = newPlatypus(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeMaverick.selector) {\n                swap.data = newMaverick(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeSyncSwap.selector) {\n                swap.data = newSyncSwap(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeAlgebraV1.selector) {\n                swap.data = newAlgebraV1(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeBalancerBatch.selector) {\n                swap.data = newBalancerBatch(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeWombat.selector) {\n                swap.data = newMantis(swap.data, oldAmount, newAmount); // @dev struct Mantis is used for both Wombat and Mantis because of same fields\n            } else if (functionSelector == IExecutorHelper.executeMantis.selector) {\n                swap.data = newMantis(swap.data, oldAmount, newAmount);\n            } else if (functionSelector == IExecutorHelper.executeIziSwap.selector) {\n                swap.data = newIziSwap(swap.data, oldAmount, newAmount);\n            } else revert(\"AggregationExecutor: Dex type not supported\");\n            unchecked {\n                ++i;\n            }\n        }\n        return abi.encode(executorDesc);\n    }\n\n    function newUniSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniSwap memory uniSwap = abi.decode(data, (IExecutorHelper.UniSwap));\n        uniSwap.collectAmount = (uniSwap.collectAmount * newAmount) / oldAmount;\n        return abi.encode(uniSwap);\n    }\n\n    function newStableSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.StableSwap memory stableSwap = abi.decode(\n            data,\n            (IExecutorHelper.StableSwap)\n        );\n        stableSwap.dx = (stableSwap.dx * newAmount) / oldAmount;\n        return abi.encode(stableSwap);\n    }\n\n    function newCurveSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.CurveSwap memory curveSwap = abi.decode(data, (IExecutorHelper.CurveSwap));\n        curveSwap.dx = (curveSwap.dx * newAmount) / oldAmount;\n        return abi.encode(curveSwap);\n    }\n\n    function newKyberDMM(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniSwap memory kyberDMMSwap = abi.decode(data, (IExecutorHelper.UniSwap));\n        kyberDMMSwap.collectAmount = (kyberDMMSwap.collectAmount * newAmount) / oldAmount;\n        return abi.encode(kyberDMMSwap);\n    }\n\n    function newUniV3ProMM(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniswapV3KSElastic memory uniSwapV3ProMM = abi.decode(\n            data,\n            (IExecutorHelper.UniswapV3KSElastic)\n        );\n        uniSwapV3ProMM.swapAmount = (uniSwapV3ProMM.swapAmount * newAmount) / oldAmount;\n\n        return abi.encode(uniSwapV3ProMM);\n    }\n\n    function newBalancerV2(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.BalancerV2 memory balancerV2 = abi.decode(\n            data,\n            (IExecutorHelper.BalancerV2)\n        );\n        balancerV2.amount = (balancerV2.amount * newAmount) / oldAmount;\n        return abi.encode(balancerV2);\n    }\n\n    function newDODO(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.DODO memory dodo = abi.decode(data, (IExecutorHelper.DODO));\n        dodo.amount = (dodo.amount * newAmount) / oldAmount;\n        return abi.encode(dodo);\n    }\n\n    function newVelodrome(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniSwap memory velodrome = abi.decode(data, (IExecutorHelper.UniSwap));\n        velodrome.collectAmount = (velodrome.collectAmount * newAmount) / oldAmount;\n        return abi.encode(velodrome);\n    }\n\n    function newGMX(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.GMX memory gmx = abi.decode(data, (IExecutorHelper.GMX));\n        gmx.amount = (gmx.amount * newAmount) / oldAmount;\n        return abi.encode(gmx);\n    }\n\n    function newSynthetix(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.Synthetix memory synthetix = abi.decode(data, (IExecutorHelper.Synthetix));\n        synthetix.sourceAmount = (synthetix.sourceAmount * newAmount) / oldAmount;\n        return abi.encode(synthetix);\n    }\n\n    function newCamelot(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniSwap memory camelot = abi.decode(data, (IExecutorHelper.UniSwap));\n        camelot.collectAmount = (camelot.collectAmount * newAmount) / oldAmount;\n        return abi.encode(camelot);\n    }\n\n    function newPlatypus(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.Platypus memory platypus = abi.decode(data, (IExecutorHelper.Platypus));\n        platypus.collectAmount = (platypus.collectAmount * newAmount) / oldAmount;\n        return abi.encode(platypus);\n    }\n\n    function newWrappedstETHSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.WSTETH memory wstEthData = abi.decode(data, (IExecutorHelper.WSTETH));\n        wstEthData.amount = (wstEthData.amount * newAmount) / oldAmount;\n        return abi.encode(wstEthData);\n    }\n\n    function newPSM(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.PSM memory psm = abi.decode(data, (IExecutorHelper.PSM));\n        psm.amountIn = (psm.amountIn * newAmount) / oldAmount;\n        return abi.encode(psm);\n    }\n\n    function newFrax(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.UniSwap memory frax = abi.decode(data, (IExecutorHelper.UniSwap));\n        frax.collectAmount = (frax.collectAmount * newAmount) / oldAmount;\n        return abi.encode(frax);\n    }\n\n    function newStETHSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        uint256 amount = abi.decode(data, (uint256));\n        amount = (amount * newAmount) / oldAmount;\n        return abi.encode(amount);\n    }\n\n    function newMaverick(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.Maverick memory maverick = abi.decode(data, (IExecutorHelper.Maverick));\n        maverick.swapAmount = (maverick.swapAmount * newAmount) / oldAmount;\n        return abi.encode(maverick);\n    }\n\n    function newSyncSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.SyncSwap memory syncSwap = abi.decode(data, (IExecutorHelper.SyncSwap));\n        syncSwap.collectAmount = (syncSwap.collectAmount * newAmount) / oldAmount;\n        return abi.encode(syncSwap);\n    }\n\n    function newAlgebraV1(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.AlgebraV1 memory algebraV1Swap = abi.decode(data, (IExecutorHelper.AlgebraV1));\n        algebraV1Swap.swapAmount = (algebraV1Swap.swapAmount * newAmount) / oldAmount;\n        return abi.encode(algebraV1Swap);\n    }\n\n    function newBalancerBatch(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.BalancerBatch memory balancerBatch = abi.decode(\n        data,\n        (IExecutorHelper.BalancerBatch)\n        );\n        balancerBatch.amountIn = (balancerBatch.amountIn * newAmount) / oldAmount;\n        return abi.encode(balancerBatch);\n    }\n\n        function newMantis(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.Mantis memory mantis = abi.decode(data, (IExecutorHelper.Mantis));\n        mantis.amount = (mantis.amount * newAmount) / oldAmount;\n        return abi.encode(mantis);\n    }\n\n    function newIziSwap(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory) {\n        IExecutorHelper.IziSwap memory iZi = abi.decode(data, (IExecutorHelper.IziSwap));\n        iZi.swapAmount = (iZi.swapAmount * newAmount) / oldAmount;\n        return abi.encode(iZi);\n    }\n\n    function _scaledPositiveSlippageFeeData(\n        bytes memory data,\n        uint256 oldAmount,\n        uint256 newAmount\n    ) internal pure returns (bytes memory newData) {\n        if (data.length > 32) {\n            PositiveSlippageFeeData memory psData = abi.decode(data, (PositiveSlippageFeeData));\n            psData.expectedReturnAmount = (psData.expectedReturnAmount * newAmount) / oldAmount;\n            data = abi.encode(psData);\n        } else if (data.length == 32) {\n            uint256 expectedReturnAmount = abi.decode(data, (uint256));\n            expectedReturnAmount = (expectedReturnAmount * newAmount) / oldAmount;\n            data = abi.encode(expectedReturnAmount);\n        }\n        return data;\n    }\n\n    function _flagsChecked(uint256 number, uint256 flag) internal pure returns (bool) {\n        return number & flag != 0;\n    }\n}\n\n\n\n\n\n\n\n\n\ncontract KyberAggregatorWrapper is IOffchainWrapper, DFSExchangeHelper, AdminAuth, DSMath, KyberInputScalingHelper{\n\n    using TokenUtils for address;\n\n    //Not enough funds\n    error InsufficientFunds(uint256 available, uint256 required);\n\n    //Order success but amount 0\n    error ZeroTokensSwapped();\n\n    using SafeERC20 for IERC20;\n\n    /// @notice Takes order from Paraswap and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _type Action type (buy or sell)\n    function takeOrder(\n        ExchangeData calldata _exData,\n        ExchangeActionType _type\n    ) override public payable returns (bool success, uint256) {\n        // check that contract have enough balance for exchange and protocol fee\n        uint256 tokenBalance = _exData.srcAddr.getBalance(address(this));\n        if (tokenBalance < _exData.srcAmount){\n            revert InsufficientFunds(tokenBalance, _exData.srcAmount);\n        }\n\n        /// @dev safeApprove is modified to always first set approval to 0, then to exact amount\n        if (_type == ExchangeActionType.SELL) {\n            IERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount);\n        } else {\n            uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up\n            IERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, srcAmount);\n        }\n\n        bytes memory scaledCalldata = getScaledInputData(_exData.offchainData.callData, _exData.srcAmount);\n        \n        uint256 tokensBefore = _exData.destAddr.getBalance(address(this));\n\n        /// @dev the amount of tokens received is checked in DFSExchangeCore\n        /// @dev Exchange wrapper contracts should not be used on their own\n        (success, ) = _exData.offchainData.exchangeAddr.call(scaledCalldata);\n\n        uint256 tokensSwapped = 0;\n\n        if (success) {\n            // get the current balance of the swapped tokens\n            tokensSwapped = _exData.destAddr.getBalance(address(this)) - tokensBefore;\n            if (tokensSwapped == 0){\n                revert ZeroTokensSwapped();\n            }\n        }\n\n        // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers)\n        sendLeftover(_exData.srcAddr, _exData.destAddr, payable(msg.sender));\n\n        return (success, tokensSwapped);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOffchainData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonContractCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OutOfRangeSlicingError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroTokensSwapped\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"adminVault\",\"outputs\":[{\"internalType\":\"contract AdminVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"getScaledInputData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dfsFeeDivider\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"wrapperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct DFSExchangeData.OffchainData\",\"name\":\"offchainData\",\"type\":\"tuple\"}],\"internalType\":\"struct DFSExchangeData.ExchangeData\",\"name\":\"_exData\",\"type\":\"tuple\"}],\"name\":\"packExchangeData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dfsFeeDivider\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"wrapperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct DFSExchangeData.OffchainData\",\"name\":\"offchainData\",\"type\":\"tuple\"}],\"internalType\":\"struct DFSExchangeData.ExchangeData\",\"name\":\"_exData\",\"type\":\"tuple\"},{\"internalType\":\"enum DFSExchangeData.ExchangeActionType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"takeOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"unpackExchangeData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dfsFeeDivider\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"wrapperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct DFSExchangeData.OffchainData\",\"name\":\"offchainData\",\"type\":\"tuple\"}],\"internalType\":\"struct DFSExchangeData.ExchangeData\",\"name\":\"_exData\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KyberAggregatorWrapper", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}