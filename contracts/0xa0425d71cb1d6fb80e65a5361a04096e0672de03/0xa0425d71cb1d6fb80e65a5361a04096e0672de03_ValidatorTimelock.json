{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/interfaces/IBase.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: UNLICENSED\\n\\n\\ninterface IBase {\\n    function getName() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/interfaces/IExecutor.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport {IBase} from \\\"./IBase.sol\\\";\\n\\n/// @dev Enum used by L2 System Contracts to differentiate logs.\\nenum SystemLogKey {\\n    L2_TO_L1_LOGS_TREE_ROOT_KEY,\\n    TOTAL_L2_TO_L1_PUBDATA_KEY,\\n    STATE_DIFF_HASH_KEY,\\n    PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\\n    PREV_BATCH_HASH_KEY,\\n    CHAINED_PRIORITY_TXN_HASH_KEY,\\n    NUMBER_OF_LAYER_1_TXS_KEY,\\n    EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\\n}\\n\\n/// @dev Offset used to pull Address From Log. Equal to 4 (bytes for isService)\\nuint256 constant L2_LOG_ADDRESS_OFFSET = 4;\\n\\n/// @dev Offset used to pull Key From Log. Equal to 4 (bytes for isService) + 20 (bytes for address)\\nuint256 constant L2_LOG_KEY_OFFSET = 24;\\n\\n/// @dev Offset used to pull Value From Log. Equal to 4 (bytes for isService) + 20 (bytes for address) + 32 (bytes for key)\\nuint256 constant L2_LOG_VALUE_OFFSET = 56;\\n\\ninterface IExecutor is IBase {\\n    /// @notice Rollup batch stored data\\n    /// @param batchNumber Rollup batch number\\n    /// @param batchHash Hash of L2 batch\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this batch\\n    /// @param timestamp Rollup batch timestamp, have the same format as Ethereum batch constant\\n    /// @param commitment Verified input for the zkSync circuit\\n    struct StoredBatchInfo {\\n        uint64 batchNumber;\\n        bytes32 batchHash;\\n        uint64 indexRepeatedStorageChanges;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 priorityOperationsHash;\\n        bytes32 l2LogsTreeRoot;\\n        uint256 timestamp;\\n        bytes32 commitment;\\n    }\\n\\n    /// @notice Data needed to commit new batch\\n    /// @param batchNumber Number of the committed batch\\n    /// @param timestamp Unix timestamp denoting the start of the batch execution\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param newStateRoot The state root of the full state tree\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param priorityOperationsHash Hash of all priority operations from this batch\\n    /// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.\\n    /// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.\\n    /// @param systemLogs concatenation of all L2 -> L1 system logs in the batch\\n    /// @param totalL2ToL1Pubdata Total pubdata committed to as part of bootloader run. Contents are: l2Tol1Logs <> l2Tol1Messages <> publishedBytecodes <> stateDiffs\\n    struct CommitBatchInfo {\\n        uint64 batchNumber;\\n        uint64 timestamp;\\n        uint64 indexRepeatedStorageChanges;\\n        bytes32 newStateRoot;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 priorityOperationsHash;\\n        bytes32 bootloaderHeapInitialContentsHash;\\n        bytes32 eventsQueueStateHash;\\n        bytes systemLogs;\\n        bytes totalL2ToL1Pubdata;\\n    }\\n\\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\\n    struct ProofInput {\\n        uint256[] recursiveAggregationInput;\\n        uint256[] serializedProof;\\n    }\\n\\n    function commitBatches(\\n        StoredBatchInfo calldata _lastCommittedBatchData,\\n        CommitBatchInfo[] calldata _newBatchesData\\n    ) external;\\n\\n    function proveBatches(\\n        StoredBatchInfo calldata _prevBatch,\\n        StoredBatchInfo[] calldata _committedBatches,\\n        ProofInput calldata _proof\\n    ) external;\\n\\n    function executeBatches(StoredBatchInfo[] calldata _batchesData) external;\\n\\n    function revertBatches(uint256 _newLastBatch) external;\\n\\n    /// @notice Event emitted when a batch is committed\\n    /// @dev It has the name \\\"BlockCommit\\\" and not \\\"BatchCommit\\\" due to backward compatibility considerations\\n    event BlockCommit(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\\n\\n    /// @notice Event emitted when batches are verified\\n    /// @dev It has the name \\\"BlocksVerification\\\" and not \\\"BatchesVerification\\\" due to backward compatibility considerations\\n    event BlocksVerification(uint256 indexed previousLastVerifiedBatch, uint256 indexed currentLastVerifiedBatch);\\n\\n    /// @notice Event emitted when a batch is executed\\n    /// @dev It has the name \\\"BlockExecution\\\" and not \\\"BatchExecution\\\" due to backward compatibility considerations\\n    event BlockExecution(uint256 indexed batchNumber, bytes32 indexed batchHash, bytes32 indexed commitment);\\n\\n    /// @notice Event emitted when batches are reverted\\n    /// @dev It has the name \\\"BlocksRevert\\\" and not \\\"BatchesRevert\\\" due to backward compatibility considerations\\n    event BlocksRevert(uint256 totalBatchesCommitted, uint256 totalBatchesVerified, uint256 totalBatchesExecuted);\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/libraries/LibMap.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n/// @notice Library for storage of packed unsigned integers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\\nlibrary LibMap {\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\\n    /// @param _index The index of the uint32 value to retrieve.\\n    /// @return result The uint32 value at the specified index.\\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\\n        unchecked {\\n            // Each storage slot can store 256 bits of data.\\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\\n            uint256 mapValue = _map.map[_index / 8];\\n\\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\\n            uint256 bitOffset = (_index & 7) * 32;\\n\\n            // Shift the bits to the right and retrieve the uint32 value.\\n            result = uint32(mapValue >> bitOffset);\\n        }\\n    }\\n\\n    /// @dev Updates the uint32 value at `_index` in `map`.\\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\\n    /// @param _index The index of the uint32 value to retrieve.\\n    /// @param _value The new value at the specified index.\\n    function set(Uint32Map storage _map, uint256 _index, uint32 _value) internal {\\n        unchecked {\\n            // Each storage slot can store 256 bits of data.\\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\\n            uint256 mapIndex = _index / 8;\\n            uint256 mapValue = _map.map[mapIndex];\\n\\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\\n            uint256 bitOffset = (_index & 7) * 32;\\n\\n            // XORing a value A with B, and then with A again, gives the original value B.\\n            // We will use this property to update the uint32 value in the slot.\\n\\n            // Shift the bits to the right and retrieve the uint32 value.\\n            uint32 oldValue = uint32(mapValue >> bitOffset);\\n\\n            // Calculate the XOR of the new value and the existing value.\\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\\n\\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/ValidatorTimelock.sol\": {\r\n      \"content\": \"pragma solidity 0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport \\\"./libraries/LibMap.sol\\\";\\nimport \\\"./interfaces/IExecutor.sol\\\";\\n\\n/// @author Matter Labs\\n/// @custom:security-contact security@matterlabs.dev\\n/// @notice Intermediate smart contract between the validator EOA account and the zkSync smart contract.\\n/// @dev The primary purpose of this contract is to provide a trustless means of delaying batch execution without\\n/// modifying the main zkSync contract. As such, even if this contract is compromised, it will not impact the main\\n/// contract.\\n/// @dev zkSync actively monitors the chain activity and reacts to any suspicious activity by freezing the chain.\\n/// This allows time for investigation and mitigation before resuming normal operations.\\n/// @dev The contract overloads all of the 4 methods, that are used in state transition. When the batch is committed,\\n/// the timestamp is stored for it. Later, when the owner calls the batch execution, the contract checks that batch\\n/// was committed not earlier than X time ago.\\ncontract ValidatorTimelock is IExecutor, Ownable2Step {\\n    using LibMap for LibMap.Uint32Map;\\n\\n    /// @dev Part of the IBase interface. Not used in this contract.\\n    string public constant override getName = \\\"ValidatorTimelock\\\";\\n\\n    /// @notice The delay between committing and executing batches is changed.\\n    event NewExecutionDelay(uint256 _newExecutionDelay);\\n\\n    /// @notice The validator address is changed.\\n    event NewValidator(address _oldValidator, address _newValidator);\\n\\n    /// @dev The main zkSync smart contract.\\n    address public immutable zkSyncContract;\\n\\n    /// @dev The mapping of L2 batch number => timestamp when it was committed.\\n    LibMap.Uint32Map internal committedBatchTimestamp;\\n\\n    /// @dev The address that can commit/revert/validate/execute batches.\\n    address public validator;\\n\\n    /// @dev The delay between committing and executing batches.\\n    uint32 public executionDelay;\\n\\n    constructor(address _initialOwner, address _zkSyncContract, uint32 _executionDelay, address _validator) {\\n        _transferOwnership(_initialOwner);\\n        zkSyncContract = _zkSyncContract;\\n        executionDelay = _executionDelay;\\n        validator = _validator;\\n    }\\n\\n    /// @dev Set new validator address.\\n    function setValidator(address _newValidator) external onlyOwner {\\n        address oldValidator = validator;\\n        validator = _newValidator;\\n        emit NewValidator(oldValidator, _newValidator);\\n    }\\n\\n    /// @dev Set the delay between committing and executing batches.\\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\\n        executionDelay = _executionDelay;\\n        emit NewExecutionDelay(_executionDelay);\\n    }\\n\\n    /// @notice Checks if the caller is a validator.\\n    modifier onlyValidator() {\\n        require(msg.sender == validator, \\\"8h\\\");\\n        _;\\n    }\\n\\n    /// @dev Returns the timestamp when `_l2BatchNumber` was committed.\\n    function getCommittedBatchTimestamp(uint256 _l2BatchNumber) external view returns (uint256) {\\n        return committedBatchTimestamp.get(_l2BatchNumber);\\n    }\\n\\n    /// @dev Records the timestamp for all provided committed batches and make\\n    /// a call to the zkSync contract with the same calldata.\\n    function commitBatches(\\n        StoredBatchInfo calldata,\\n        CommitBatchInfo[] calldata _newBatchesData\\n    ) external onlyValidator {\\n        unchecked {\\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\\n            // It is safe to cast.\\n            uint32 timestamp = uint32(block.timestamp);\\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\\n                committedBatchTimestamp.set(_newBatchesData[i].batchNumber, timestamp);\\n            }\\n        }\\n\\n        _propagateToZkSync();\\n    }\\n\\n    /// @dev Make a call to the zkSync contract with the same calldata.\\n    /// Note: If the batch is reverted, it needs to be committed first before the execution.\\n    /// So it's safe to not override the committed batches.\\n    function revertBatches(uint256) external onlyValidator {\\n        _propagateToZkSync();\\n    }\\n\\n    /// @dev Make a call to the zkSync contract with the same calldata.\\n    /// Note: We don't track the time when batches are proven, since all information about\\n    /// the batch is known on the commit stage and the proved is not finalized (may be reverted).\\n    function proveBatches(\\n        StoredBatchInfo calldata,\\n        StoredBatchInfo[] calldata,\\n        ProofInput calldata\\n    ) external onlyValidator {\\n        _propagateToZkSync();\\n    }\\n\\n    /// @dev Check that batches were committed at least X time ago and\\n    /// make a call to the zkSync contract with the same calldata.\\n    function executeBatches(StoredBatchInfo[] calldata _newBatchesData) external onlyValidator {\\n        uint256 delay = executionDelay; // uint32\\n        unchecked {\\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\\n                uint256 commitBatchTimestamp = committedBatchTimestamp.get(_newBatchesData[i].batchNumber);\\n\\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\\n                // * The batch was committed, but not through this contract.\\n                // * The batch wasn't committed at all, so execution will fail in the zkSync contract.\\n                // We allow executing such batches.\\n                require(block.timestamp >= commitBatchTimestamp + delay, \\\"5c\\\"); // The delay is not passed\\n            }\\n        }\\n\\n        _propagateToZkSync();\\n    }\\n\\n    /// @dev Call the zkSync contract with the same calldata as this contract was called.\\n    /// Note: it is called the zkSync contract, not delegatecalled!\\n    function _propagateToZkSync() internal {\\n        address contractAddress = zkSyncContract;\\n        assembly {\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(0, 0, calldatasize())\\n            // Call method of the zkSync contract returns 0 on error\\n            let result := call(gas(), contractAddress, 0, 0, calldatasize(), 0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(0, 0, size)\\n            // Depending on the result value\\n            switch result\\n            case 0 {\\n                // End execution and revert state changes\\n                revert(0, size)\\n            }\\n            default {\\n                // Return data with length of size at pointers position\\n                return(0, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zkSyncContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_executionDelay\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBatchesCommitted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBatchesVerified\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBatchesExecuted\",\"type\":\"uint256\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousLastVerifiedBatch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentLastVerifiedBatch\",\"type\":\"uint256\"}],\"name\":\"BlocksVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newExecutionDelay\",\"type\":\"uint256\"}],\"name\":\"NewExecutionDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"NewValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"batchNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBatchInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"batchNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bootloaderHeapInitialContentsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"eventsQueueStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"systemLogs\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"totalL2ToL1Pubdata\",\"type\":\"bytes\"}],\"internalType\":\"struct IExecutor.CommitBatchInfo[]\",\"name\":\"_newBatchesData\",\"type\":\"tuple[]\"}],\"name\":\"commitBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"batchNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBatchInfo[]\",\"name\":\"_newBatchesData\",\"type\":\"tuple[]\"}],\"name\":\"executeBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionDelay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2BatchNumber\",\"type\":\"uint256\"}],\"name\":\"getCommittedBatchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"batchNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBatchInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"batchNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBatchInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"recursiveAggregationInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serializedProof\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IExecutor.ProofInput\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"proveBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revertBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_executionDelay\",\"type\":\"uint32\"}],\"name\":\"setExecutionDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkSyncContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ValidatorTimelock", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "0000000000000000000000004e4943346848c4867f81dfb37c4ca9c5715a782800000000000000000000000032400084c286cf3e17e7b677ea9583e60a00032400000000000000000000000000000000000000000000000000000000000127500000000000000000000000003527439923a63f8c13cf72b8fe80a77f6e572092", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}