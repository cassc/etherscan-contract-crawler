{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ncontract BaseMath {\\r\\n    uint256 constant public DECIMAL_PRECISION = 1e18;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/CheckContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ncontract CheckContract {\\r\\n    /**\\r\\n     * Check that the account is an already deployed non-destroyed contract.\\r\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\\r\\n     */\\r\\n    function checkContract(address _account) internal view {\\r\\n        require(_account != address(0), \\\"Account cannot be zero address\\\");\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(_account) }\\r\\n        require(size > 0, \\\"Account code size cannot be zero\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change one's\\r\\n * {IERC20-allowance} without having to send a transaction, by signing a\\r\\n * message. This allows users to spend tokens without having to hold Ether.\\r\\n *\\r\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\r\\n * \\r\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\r\\n */\\r\\ninterface IERC2612 {\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\r\\n     * given `owner`'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(address owner, address spender, uint256 amount, \\r\\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     *\\r\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \\r\\n     * a value in the near future. The deadline argument can be set to uint(-1) to \\r\\n     * create Permits that effectively never expire.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n    \\r\\n    function version() external view returns (string memory);\\r\\n    function permitTypeHash() external view returns (bytes32);\\r\\n    function domainSeparator() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquityBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./BaseMath.sol\\\";\\r\\nimport \\\"./LiquityMath.sol\\\";\\r\\nimport \\\"../Interfaces/IActivePool.sol\\\";\\r\\nimport \\\"../Interfaces/IDefaultPool.sol\\\";\\r\\nimport \\\"../Interfaces/IPriceFeed.sol\\\";\\r\\nimport \\\"../Interfaces/ILiquityBase.sol\\\";\\r\\n\\r\\n/*\\r\\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\\r\\n* common functions.\\r\\n*/\\r\\ncontract LiquityBase is BaseMath, ILiquityBase {\\r\\n\\r\\n    uint256 constant public _100pct = 1e18; // 1e18 == 100%\\r\\n\\r\\n    // Minimum collateral ratio for individual troves\\r\\n    uint256 constant public MCR = 1.1e18; // 110%\\r\\n\\r\\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\r\\n    uint256 constant public CCR = 1.5e18; // 150%\\r\\n\\r\\n    // Amount of THUSD to be locked in gas pool on opening troves\\r\\n    uint256 constant public THUSD_GAS_COMPENSATION = 200e18;\\r\\n\\r\\n    // Minimum amount of net THUSD debt a trove must have\\r\\n    uint256 constant public MIN_NET_DEBT = 1800e18;\\r\\n    // uint256 constant public MIN_NET_DEBT = 0;\\r\\n\\r\\n    uint256 constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\r\\n\\r\\n    uint256 constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\\r\\n\\r\\n    IActivePool public activePool;\\r\\n\\r\\n    IDefaultPool public defaultPool;\\r\\n\\r\\n    IPriceFeed public override priceFeed;\\r\\n\\r\\n    // --- Gas compensation functions ---\\r\\n\\r\\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\\r\\n    function _getCompositeDebt(uint256 _debt) internal pure returns (uint) {\\r\\n        return _debt + THUSD_GAS_COMPENSATION;\\r\\n    }\\r\\n\\r\\n    function _getNetDebt(uint256 _debt) internal pure returns (uint) {\\r\\n        return _debt - THUSD_GAS_COMPENSATION;\\r\\n    }\\r\\n\\r\\n    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.\\r\\n    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint) {\\r\\n        return _entireColl / PERCENT_DIVISOR;\\r\\n    }\\r\\n\\r\\n    function getEntireSystemColl() public view returns (uint256 entireSystemColl) {\\r\\n        uint256 activeColl = activePool.getCollateralBalance();\\r\\n        uint256 liquidatedColl = defaultPool.getCollateralBalance();\\r\\n\\r\\n        return activeColl + liquidatedColl;\\r\\n    }\\r\\n\\r\\n    function getEntireSystemDebt() public view returns (uint256 entireSystemDebt) {\\r\\n        uint256 activeDebt = activePool.getTHUSDDebt();\\r\\n        uint256 closedDebt = defaultPool.getTHUSDDebt();\\r\\n\\r\\n        return activeDebt + closedDebt;\\r\\n    }\\r\\n\\r\\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\\r\\n        uint256 entireSystemColl = getEntireSystemColl();\\r\\n        uint256 entireSystemDebt = getEntireSystemDebt();\\r\\n\\r\\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\\r\\n        return TCR;\\r\\n    }\\r\\n\\r\\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\\r\\n        uint256 TCR = _getTCR(_price);\\r\\n        return TCR < CCR;\\r\\n    }\\r\\n\\r\\n    function _requireUserAcceptsFee(uint256 _fee, uint256 _amount, uint256 _maxFeePercentage) internal pure {\\r\\n        uint256 feePercentage = _fee * DECIMAL_PRECISION / _amount;\\r\\n        require(feePercentage <= _maxFeePercentage, \\\"Fee exceeded provided maximum\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquityMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nlibrary LiquityMath {\\r\\n\\r\\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\\r\\n\\r\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\r\\n     *\\r\\n     * - Making it \u201ctoo high\u201d could lead to overflows.\\r\\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\r\\n     *\\r\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\r\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\r\\n     *\\r\\n     */\\r\\n    uint256 internal constant NICR_PRECISION = 1e20;\\r\\n\\r\\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a < _b) ? _a : _b;\\r\\n    }\\r\\n\\r\\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a >= _b) ? _a : _b;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Multiply two decimal numbers and use normal rounding rules:\\r\\n    * -round product up if 19'th mantissa digit >= 5\\r\\n    * -round product down if 19'th mantissa digit < 5\\r\\n    *\\r\\n    * Used only inside the exponentiation, _decPow().\\r\\n    */\\r\\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\\r\\n        uint256 prod_xy = x * y;\\r\\n\\r\\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\r\\n    *\\r\\n    * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\r\\n    *\\r\\n    * Called by one function that represent time in units of minutes:\\r\\n    * 1) TroveManager._calcDecayedBaseRate\\r\\n    *\\r\\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\r\\n    * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\r\\n    *\\r\\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\r\\n    * negligibly different from just passing the cap, since:\\r\\n    *\\r\\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\r\\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\r\\n    */\\r\\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint) {\\r\\n\\r\\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\\r\\n\\r\\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\\r\\n\\r\\n        uint256 y = DECIMAL_PRECISION;\\r\\n        uint256 x = _base;\\r\\n        uint256 n = _minutes;\\r\\n\\r\\n        // Exponentiation-by-squaring\\r\\n        while (n > 1) {\\r\\n            if (n % 2 == 0) {\\r\\n                x = decMul(x, x);\\r\\n                n = n / 2;\\r\\n            } else { // if (n % 2 != 0)\\r\\n                y = decMul(x, y);\\r\\n                x = decMul(x, x);\\r\\n                n = (n - 1) / 2;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return decMul(x, y);\\r\\n  }\\r\\n\\r\\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint) {\\r\\n        return (_a >= _b) ? _a - _b : _b - _a;\\r\\n    }\\r\\n\\r\\n    function _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint) {\\r\\n        if (_debt > 0) {\\r\\n            return _coll * NICR_PRECISION / _debt;\\r\\n        }\\r\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n        else { // if (_debt == 0)\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint) {\\r\\n        if (_debt > 0) {\\r\\n            uint256 newCollRatio = _coll * _price / _debt;\\r\\n\\r\\n            return newCollRatio;\\r\\n        }\\r\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n        else { // if (_debt == 0)\\r\\n            return type(uint256).max;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/**\\r\\n * Based on OpenZeppelin's Ownable contract:\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\r\\n *\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     *\\r\\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\\r\\n     * Make sure you check it before calling it.\\r\\n     */\\r\\n    function _renounceOwnership() internal {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IActivePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IPool.sol\\\";\\r\\n\\r\\n\\r\\ninterface IActivePool is IPool {\\r\\n    // --- Events ---\\r\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event ActivePoolTHUSDDebtUpdated(uint256 _THUSDDebt);\\r\\n    event ActivePoolCollateralBalanceUpdated(uint256 _collateral);\\r\\n    event CollateralAddressChanged(address _newCollateralAddress);\\r\\n    event CollSurplusPoolAddressChanged(address _newCollSurplusPoolAddress);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function sendCollateral(address _account, uint256 _amount) external;\\r\\n    function updateCollateralBalance(uint256 _amount) external;\\r\\n    function collateralAddress() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IBorrowerOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n// Common interface for the Trove Manager.\\r\\ninterface IBorrowerOperations {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\r\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\r\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\r\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\r\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\r\\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\\r\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\r\\n    event THUSDTokenAddressChanged(address _thusdTokenAddress);\\r\\n    event PCVAddressChanged(address _pcvAddress);\\r\\n    event CollateralAddressChanged(address _newCollateralAddress);\\r\\n\\r\\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\\r\\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\\r\\n    event THUSDBorrowingFeePaid(address indexed _borrower, uint256 _THUSDFee);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    function setAddresses(\\r\\n        address _troveManagerAddress,\\r\\n        address _activePoolAddress,\\r\\n        address _defaultPoolAddress,\\r\\n        address _stabilityPoolAddress,\\r\\n        address _gasPoolAddress,\\r\\n        address _collSurplusPoolAddress,\\r\\n        address _priceFeedAddress,\\r\\n        address _sortedTrovesAddress,\\r\\n        address _thusdTokenAddress,\\r\\n        address _pcvAddress,\\r\\n        address _collateralAddress\\r\\n\\r\\n    ) external;\\r\\n\\r\\n    function openTrove(uint256 _maxFee, uint256 _THUSDAmount, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable;\\r\\n\\r\\n    function addColl(uint256 _assetAmount, address _upperHint, address _lowerHint) external payable;\\r\\n\\r\\n    function moveCollateralGainToTrove(address _user, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable;\\r\\n\\r\\n    function withdrawColl(uint256 _amount, address _upperHint, address _lowerHint) external;\\r\\n\\r\\n    function withdrawTHUSD(uint256 _maxFee, uint256 _amount, address _upperHint, address _lowerHint) external;\\r\\n\\r\\n    function repayTHUSD(uint256 _amount, address _upperHint, address _lowerHint) external;\\r\\n\\r\\n    function closeTrove() external;\\r\\n\\r\\n    function adjustTrove(uint256 _maxFee, uint256 _collWithdrawal, uint256 _debtChange, bool isDebtIncrease, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable;\\r\\n\\r\\n    function claimCollateral() external;\\r\\n\\r\\n    function getCompositeDebt(uint256 _debt) external pure returns (uint);\\r\\n\\r\\n    function collateralAddress() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICollSurplusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ninterface ICollSurplusPool {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\r\\n    event CollateralAddressChanged(address _newCollateralAddress);\\r\\n\\r\\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\\r\\n    event CollateralSent(address _to, uint256 _amount);\\r\\n\\r\\n    // --- Contract setters ---\\r\\n\\r\\n    function setAddresses(\\r\\n        address _borrowerOperationsAddress,\\r\\n        address _troveManagerAddress,\\r\\n        address _activePoolAddress,\\r\\n        address _collateralAddress\\r\\n    ) external;\\r\\n\\r\\n    function getCollateralBalance() external view returns (uint);\\r\\n\\r\\n    function getCollateral(address _account) external view returns (uint);\\r\\n\\r\\n    function accountSurplus(address _account, uint256 _amount) external;\\r\\n\\r\\n    function claimColl(address _account) external;\\r\\n\\r\\n    function updateCollateralBalance(uint256 _amount) external;\\r\\n    \\r\\n    function collateralAddress() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IDefaultPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IPool.sol\\\";\\r\\n\\r\\n\\r\\ninterface IDefaultPool is IPool {\\r\\n    // --- Events ---\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event DefaultPoolTHUSDDebtUpdated(uint256 _THUSDDebt);\\r\\n    event DefaultPoolCollateralBalanceUpdated(uint256 _collateral);\\r\\n    event CollateralAddressChanged(address _newCollateralAddress);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function sendCollateralToActivePool(uint256 _amount) external;\\r\\n    function updateCollateralBalance(uint256 _amount) external;\\r\\n    function collateralAddress() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IGasPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n\\r\\ninterface IGasPool {\\r\\n    // --- Events ---\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event THUSDTokenAddressChanged(address _thusdTokenAddress);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function sendTHUSD(address _account, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILiquityBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./IPriceFeed.sol\\\";\\r\\n\\r\\n\\r\\ninterface ILiquityBase {\\r\\n    function priceFeed() external view returns (IPriceFeed);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPCV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./ITHUSDToken.sol\\\";\\r\\n\\r\\ninterface IPCV {\\r\\n\\r\\n    // --- Events --\\r\\n    event THUSDTokenAddressSet(address _thusdTokenAddress);\\r\\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\\r\\n    event CollateralAddressSet(address _collateralAddress);\\r\\n    event BAMMAddressSet(address _bammAddress);\\r\\n    event RolesSet(address _council, address _treasury);\\r\\n\\r\\n    event BAMMDeposit(uint256 _thusdAmount);\\r\\n    event BAMMWithdraw(uint256 _numShares);\\r\\n    event THUSDWithdraw(address _recipient, uint256 _thusdAmount);\\r\\n    event CollateralWithdraw(address _recipient, uint256 _collateralAmount);\\r\\n\\r\\n    event PCVDebtPaid(uint256 _paidDebt);\\r\\n    \\r\\n    event RecipientAdded(address _recipient);\\r\\n    event RecipientRemoved(address _recipient);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    function debtToPay() external returns(uint256);\\r\\n    function payDebt(uint256 _thusdToBurn) external;\\r\\n\\r\\n    function setAddresses(\\r\\n        address _thusdTokenAddress, \\r\\n        address _borrowerOperations, \\r\\n        address payable _bammAddress,\\r\\n        address _collateralERC20\\r\\n    ) external;\\r\\n    function initialize() external;\\r\\n\\r\\n    function depositToBAMM(uint256 _thusdAmount) external;\\r\\n    function withdrawFromBAMM(uint256 _numShares) external;\\r\\n    function withdrawTHUSD(address _recipient, uint256 _thusdAmount) external;\\r\\n    function withdrawCollateral(address _recipient, uint256 _collateralAmount) external;\\r\\n\\r\\n    function addRecipientToWhitelist(address _recipient) external;\\r\\n    function addRecipientsToWhitelist(address[] calldata _recipients) external;\\r\\n    function removeRecipientFromWhitelist(address _recipient) external;\\r\\n    function removeRecipientsFromWhitelist(address[] calldata _recipients) external;\\r\\n\\r\\n    function startChangingRoles(address _council, address _treasury) external;\\r\\n    function cancelChangingRoles() external;\\r\\n    function finalizeChangingRoles() external;\\r\\n    \\r\\n    function collateralERC20() external view returns(IERC20);\\r\\n    function thusdToken() external view returns(ITHUSDToken);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n// Common interface for the Pools.\\r\\ninterface IPool {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event CollateralBalanceUpdated(uint256 _newBalance);\\r\\n    event THUSDBalanceUpdated(uint256 _newBalance);\\r\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\r\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\r\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\r\\n    event CollateralSent(address _to, uint256 _amount);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    function getCollateralBalance() external view returns (uint);\\r\\n\\r\\n    function getTHUSDDebt() external view returns (uint);\\r\\n\\r\\n    function increaseTHUSDDebt(uint256 _amount) external;\\r\\n\\r\\n    function decreaseTHUSDDebt(uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IPriceFeed {\\r\\n\\r\\n    // --- Events ---\\r\\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\\r\\n   \\r\\n    // --- Function ---\\r\\n    function fetchPrice() external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISortedTroves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n// Common interface for the SortedTroves Doubly Linked List.\\r\\ninterface ISortedTroves {\\r\\n\\r\\n    // --- Events ---\\r\\n    \\r\\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\\r\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\r\\n    event NodeAdded(address _id, uint256 _NICR);\\r\\n    event NodeRemoved(address _id);\\r\\n\\r\\n    // --- Functions ---\\r\\n    \\r\\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\\r\\n\\r\\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\\r\\n\\r\\n    function remove(address _id) external;\\r\\n\\r\\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\\r\\n\\r\\n    function contains(address _id) external view returns (bool);\\r\\n\\r\\n    function isFull() external view returns (bool);\\r\\n\\r\\n    function isEmpty() external view returns (bool);\\r\\n\\r\\n    function getSize() external view returns (uint256);\\r\\n\\r\\n    function getMaxSize() external view returns (uint256);\\r\\n\\r\\n    function getFirst() external view returns (address);\\r\\n\\r\\n    function getLast() external view returns (address);\\r\\n\\r\\n    function getNext(address _id) external view returns (address);\\r\\n\\r\\n    function getPrev(address _id) external view returns (address);\\r\\n\\r\\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\\r\\n\\r\\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IStabilityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/*\\r\\n * The Stability Pool holds THUSD tokens deposited by Stability Pool depositors.\\r\\n *\\r\\n * When a trove is liquidated, then depending on system conditions, some of its THUSD debt gets offset with\\r\\n * THUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of THUSD tokens in the Stability Pool is burned.\\r\\n *\\r\\n * Thus, a liquidation causes each depositor to receive a THUSD loss, in proportion to their deposit as a share of total deposits.\\r\\n * They also receive an collateral gain, as the collateral of the liquidated trove is distributed among Stability depositors,\\r\\n * in the same proportion.\\r\\n *\\r\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\r\\n * of the total THUSD in the Stability Pool, depletes 40% of each deposit.\\r\\n *\\r\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\r\\n * multiplying it by some factor in range ]0,1[\\r\\n *\\r\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / collateral gain derivations:\\r\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\r\\n *\\r\\n */\\r\\ninterface IStabilityPool {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event StabilityPoolCollateralBalanceUpdated(uint256 _newBalance);\\r\\n    event StabilityPoolTHUSDBalanceUpdated(uint256 _newBalance);\\r\\n\\r\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\r\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\r\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\r\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\r\\n    event THUSDTokenAddressChanged(address _newTHUSDTokenAddress);\\r\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\r\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\r\\n    event CollateralAddressChanged(address _newCollateralAddress);\\r\\n\\r\\n    event P_Updated(uint256 _P);\\r\\n    event S_Updated(uint256 _S, uint128 _epoch, uint128 _scale);\\r\\n    event EpochUpdated(uint128 _currentEpoch);\\r\\n    event ScaleUpdated(uint128 _currentScale);\\r\\n\\r\\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _S);\\r\\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\\r\\n\\r\\n    event CollateralGainWithdrawn(address indexed _depositor, uint256 _collateral, uint256 _THUSDLoss);\\r\\n    event CollateralSent(address _to, uint256 _amount);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    /*\\r\\n     * Called only once on init, to set addresses of other Liquity contracts\\r\\n     * Callable only by owner, renounces ownership at the end\\r\\n     */\\r\\n    function setAddresses(\\r\\n        address _borrowerOperationsAddress,\\r\\n        address _troveManagerAddress,\\r\\n        address _activePoolAddress,\\r\\n        address _thusdTokenAddress,\\r\\n        address _sortedTrovesAddress,\\r\\n        address _priceFeedAddress,\\r\\n        address _collateralAddress\\r\\n    ) external;\\r\\n\\r\\n    /*\\r\\n     * Initial checks:\\r\\n     * - _amount is not zero\\r\\n     * ---\\r\\n     * - Sends depositor's accumulated gains (collateral) to depositor\\r\\n     */\\r\\n    function provideToSP(uint256 _amount) external;\\r\\n\\r\\n    /*\\r\\n     * Initial checks:\\r\\n     * - _amount is zero or there are no under collateralized troves left in the system\\r\\n     * - User has a non zero deposit\\r\\n     * ---\\r\\n     * - Sends all depositor's accumulated gains (collateral) to depositor\\r\\n     * - Decreases deposit stake, and takes new snapshot.\\r\\n     *\\r\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\r\\n     */\\r\\n    function withdrawFromSP(uint256 _amount) external;\\r\\n\\r\\n    /*\\r\\n     * Initial checks:\\r\\n     * - User has a non zero deposit\\r\\n     * - User has an open trove\\r\\n     * - User has some collateral gain\\r\\n     * ---\\r\\n     * - Transfers the depositor's entire collateral gain from the Stability Pool to the caller's trove\\r\\n     * - Leaves their compounded deposit in the Stability Pool\\r\\n     * - Updates snapshots for deposit\\r\\n     */\\r\\n    function withdrawCollateralGainToTrove(address _upperHint, address _lowerHint) external;\\r\\n\\r\\n    /*\\r\\n     * Initial checks:\\r\\n     * - Caller is TroveManager\\r\\n     * ---\\r\\n     * Cancels out the specified debt against the THUSD contained in the Stability Pool (as far as possible)\\r\\n     * and transfers the Trove's collateral from ActivePool to StabilityPool.\\r\\n     * Only called by liquidation functions in the TroveManager.\\r\\n     */\\r\\n    function offset(uint256 _debt, uint256 _coll) external;\\r\\n\\r\\n    /*\\r\\n     * Returns the total amount of collateral held by the pool, accounted in an internal variable instead of `balance`,\\r\\n     * to exclude edge cases like collateral received from a self-destruct.\\r\\n     */\\r\\n    function getCollateralBalance() external view returns (uint);\\r\\n\\r\\n    /*\\r\\n     * Returns THUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\r\\n     */\\r\\n    function getTotalTHUSDDeposits() external view returns (uint);\\r\\n\\r\\n    /*\\r\\n     * Calculates the collateral gain earned by the deposit since its last snapshots were taken.\\r\\n     */\\r\\n    function getDepositorCollateralGain(address _depositor) external view returns (uint);\\r\\n\\r\\n    /*\\r\\n     * Return the user's compounded deposit.\\r\\n     */\\r\\n    function getCompoundedTHUSDDeposit(address _depositor) external view returns (uint);\\r\\n\\r\\n    /*\\r\\n     * Only callable by Active Pool, updates ERC20 tokens recieved\\r\\n     */\\r\\n    function updateCollateralBalance(uint256 _amount) external;\\r\\n    /*\\r\\n     * Fallback function\\r\\n     * Only callable by Active Pool, it just accounts for ETH received\\r\\n     * receive() external payable;\\r\\n     */\\r\\n    \\r\\n    function collateralAddress() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITHUSDToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\r\\n\\r\\ninterface ITHUSDToken is IERC20Metadata, IERC2612 {\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event TroveManagerAddressAdded(address _troveManagerAddress);\\r\\n    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);\\r\\n    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);\\r\\n\\r\\n    event THUSDTokenBalanceUpdated(address _user, uint256 _amount);\\r\\n\\r\\n    // --- Functions ---\\r\\n    function mintList(address contractAddress) external view returns (bool);\\r\\n    function burnList(address contractAddress) external view returns (bool);\\r\\n\\r\\n    function mint(address _account, uint256 _amount) external;\\r\\n\\r\\n    function burn(address _account, uint256 _amount) external;\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITroveManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./ILiquityBase.sol\\\";\\r\\nimport \\\"./IStabilityPool.sol\\\";\\r\\nimport \\\"./ITHUSDToken.sol\\\";\\r\\nimport \\\"./IPCV.sol\\\";\\r\\n\\r\\n\\r\\n// Common interface for the Trove Manager.\\r\\ninterface ITroveManager is ILiquityBase {\\r\\n\\r\\n    enum Status {\\r\\n        nonExistent,\\r\\n        active,\\r\\n        closedByOwner,\\r\\n        closedByLiquidation,\\r\\n        closedByRedemption\\r\\n    }\\r\\n\\r\\n    // --- Events ---\\r\\n\\r\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\r\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\r\\n    event THUSDTokenAddressChanged(address _newTHUSDTokenAddress);\\r\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\r\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\r\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\r\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\r\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\r\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\r\\n    event PCVAddressChanged(address _pcvAddress);\\r\\n\\r\\n    event Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _collGasCompensation, uint256 _THUSDGasCompensation);\\r\\n    event Redemption(uint256 _attemptedTHUSDAmount, uint256 _actualTHUSDAmount, uint256 _collateralSent, uint256 _collateralFee);\\r\\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\\r\\n    event TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, uint8 operation);\\r\\n    event BaseRateUpdated(uint256 _baseRate);\\r\\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\\r\\n    event TotalStakesUpdated(uint256 _newTotalStakes);\\r\\n    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\\r\\n    event LTermsUpdated(uint256 _L_Collateral, uint256 _L_THUSDDebt);\\r\\n    event TroveSnapshotsUpdated(uint256 _L_Collateral, uint256 _L_THUSDDebt);\\r\\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\\r\\n\\r\\n    // --- Functions ---\\r\\n\\r\\n    function setAddresses(\\r\\n        address _borrowerOperationsAddress,\\r\\n        address _activePoolAddress,\\r\\n        address _defaultPoolAddress,\\r\\n        address _stabilityPoolAddress,\\r\\n        address _gasPoolAddress,\\r\\n        address _collSurplusPoolAddress,\\r\\n        address _priceFeedAddress,\\r\\n        address _thusdTokenAddress,\\r\\n        address _sortedTrovesAddress,\\r\\n        address _pcvAddress\\r\\n    ) external;\\r\\n\\r\\n    function stabilityPool() external view returns (IStabilityPool);\\r\\n    function thusdToken() external view returns (ITHUSDToken);\\r\\n    function pcv() external view returns (IPCV);\\r\\n\\r\\n    function getTroveOwnersCount() external view returns (uint);\\r\\n\\r\\n    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);\\r\\n\\r\\n    function getNominalICR(address _borrower) external view returns (uint);\\r\\n    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint);\\r\\n\\r\\n    function liquidate(address _borrower) external;\\r\\n\\r\\n    function liquidateTroves(uint256 _n) external;\\r\\n\\r\\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\\r\\n\\r\\n    function redeemCollateral(\\r\\n        uint256 _THUSDAmount,\\r\\n        address _firstRedemptionHint,\\r\\n        address _upperPartialRedemptionHint,\\r\\n        address _lowerPartialRedemptionHint,\\r\\n        uint256 _partialRedemptionHintNICR,\\r\\n        uint256 _maxIterations,\\r\\n        uint256 _maxFee\\r\\n    ) external;\\r\\n\\r\\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\\r\\n\\r\\n    function updateTroveRewardSnapshots(address _borrower) external;\\r\\n\\r\\n    function addTroveOwnerToArray(address _borrower) external returns (uint256 index);\\r\\n\\r\\n    function applyPendingRewards(address _borrower) external;\\r\\n\\r\\n    function getPendingCollateralReward(address _borrower) external view returns (uint);\\r\\n\\r\\n    function getPendingTHUSDDebtReward(address _borrower) external view returns (uint);\\r\\n\\r\\n     function hasPendingRewards(address _borrower) external view returns (bool);\\r\\n\\r\\n    function getEntireDebtAndColl(address _borrower) external view returns (\\r\\n        uint256 debt,\\r\\n        uint256 coll,\\r\\n        uint256 pendingTHUSDDebtReward,\\r\\n        uint256 pendingCollateralReward\\r\\n    );\\r\\n\\r\\n    function closeTrove(address _borrower) external;\\r\\n\\r\\n    function removeStake(address _borrower) external;\\r\\n\\r\\n    function getRedemptionRate() external view returns (uint);\\r\\n    function getRedemptionRateWithDecay() external view returns (uint);\\r\\n\\r\\n    function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint);\\r\\n\\r\\n    function getBorrowingRate() external view returns (uint);\\r\\n    function getBorrowingRateWithDecay() external view returns (uint);\\r\\n\\r\\n    function getBorrowingFee(uint256 THUSDDebt) external view returns (uint);\\r\\n    function getBorrowingFeeWithDecay(uint256 _THUSDDebt) external view returns (uint);\\r\\n\\r\\n    function decayBaseRateFromBorrowing() external;\\r\\n\\r\\n    function getTroveStatus(address _borrower) external view returns (Status);\\r\\n\\r\\n    function getTroveStake(address _borrower) external view returns (uint);\\r\\n\\r\\n    function getTroveDebt(address _borrower) external view returns (uint);\\r\\n\\r\\n    function getTroveColl(address _borrower) external view returns (uint);\\r\\n\\r\\n    function setTroveStatus(address _borrower, Status _status) external;\\r\\n\\r\\n    function increaseTroveColl(address _borrower, uint256 _collIncrease) external returns (uint);\\r\\n\\r\\n    function decreaseTroveColl(address _borrower, uint256 _collDecrease) external returns (uint);\\r\\n\\r\\n    function increaseTroveDebt(address _borrower, uint256 _debtIncrease) external returns (uint);\\r\\n\\r\\n    function decreaseTroveDebt(address _borrower, uint256 _collDecrease) external returns (uint);\\r\\n\\r\\n    function getTCR(uint256 _price) external view returns (uint);\\r\\n\\r\\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MultiTroveGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./TroveManager.sol\\\";\\r\\nimport \\\"./SortedTroves.sol\\\";\\r\\n\\r\\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\\r\\ncontract MultiTroveGetter {\\r\\n    struct CombinedTroveData {\\r\\n        address owner;\\r\\n\\r\\n        uint256 debt;\\r\\n        uint256 coll;\\r\\n        uint256 stake;\\r\\n\\r\\n        uint256 snapshotCollateral;\\r\\n        uint256 snapshotTHUSDDebt;\\r\\n    }\\r\\n\\r\\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\\r\\n    ISortedTroves public sortedTroves;\\r\\n\\r\\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\\r\\n        troveManager = _troveManager;\\r\\n        sortedTroves = _sortedTroves;\\r\\n    }\\r\\n\\r\\n    function getMultipleSortedTroves(int _startIdx, uint256 _count)\\r\\n        external view returns (CombinedTroveData[] memory _troves)\\r\\n    {\\r\\n        uint256 startIdx;\\r\\n        bool descend;\\r\\n\\r\\n        if (_startIdx >= 0) {\\r\\n            startIdx = uint(_startIdx);\\r\\n            descend = true;\\r\\n        } else {\\r\\n            startIdx = uint(-(_startIdx + 1));\\r\\n            descend = false;\\r\\n        }\\r\\n\\r\\n        uint256 sortedTrovesSize = sortedTroves.getSize();\\r\\n\\r\\n        if (startIdx >= sortedTrovesSize) {\\r\\n            _troves = new CombinedTroveData[](0);\\r\\n        } else {\\r\\n            uint256 maxCount = sortedTrovesSize - startIdx;\\r\\n\\r\\n            if (_count > maxCount) {\\r\\n                _count = maxCount;\\r\\n            }\\r\\n\\r\\n            if (descend) {\\r\\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\\r\\n            } else {\\r\\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getMultipleSortedTrovesFromHead(uint256 _startIdx, uint256 _count)\\r\\n        internal view returns (CombinedTroveData[] memory _troves)\\r\\n    {\\r\\n        address currentTroveowner = sortedTroves.getFirst();\\r\\n\\r\\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\\r\\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\\r\\n        }\\r\\n\\r\\n        _troves = new CombinedTroveData[](_count);\\r\\n\\r\\n        for (uint256 idx = 0; idx < _count; ++idx) {\\r\\n            _troves[idx].owner = currentTroveowner;\\r\\n            (\\r\\n                _troves[idx].debt,\\r\\n                _troves[idx].coll,\\r\\n                _troves[idx].stake,\\r\\n                /* status */,\\r\\n                /* arrayIndex */\\r\\n            ) = troveManager.Troves(currentTroveowner);\\r\\n            (\\r\\n                _troves[idx].snapshotCollateral,\\r\\n                _troves[idx].snapshotTHUSDDebt\\r\\n            ) = troveManager.rewardSnapshots(currentTroveowner);\\r\\n\\r\\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getMultipleSortedTrovesFromTail(uint256 _startIdx, uint256 _count)\\r\\n        internal view returns (CombinedTroveData[] memory _troves)\\r\\n    {\\r\\n        address currentTroveowner = sortedTroves.getLast();\\r\\n\\r\\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\\r\\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\\r\\n        }\\r\\n\\r\\n        _troves = new CombinedTroveData[](_count);\\r\\n\\r\\n        for (uint256 idx = 0; idx < _count; ++idx) {\\r\\n            _troves[idx].owner = currentTroveowner;\\r\\n            (\\r\\n                _troves[idx].debt,\\r\\n                _troves[idx].coll,\\r\\n                _troves[idx].stake,\\r\\n                /* status */,\\r\\n                /* arrayIndex */\\r\\n            ) = troveManager.Troves(currentTroveowner);\\r\\n            (\\r\\n                _troves[idx].snapshotCollateral,\\r\\n                _troves[idx].snapshotTHUSDDebt\\r\\n            ) = troveManager.rewardSnapshots(currentTroveowner);\\r\\n\\r\\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/SortedTroves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Interfaces/ISortedTroves.sol\\\";\\r\\nimport \\\"./Interfaces/ITroveManager.sol\\\";\\r\\nimport \\\"./Interfaces/IBorrowerOperations.sol\\\";\\r\\nimport \\\"./Dependencies/Ownable.sol\\\";\\r\\nimport \\\"./Dependencies/CheckContract.sol\\\";\\r\\n\\r\\n/*\\r\\n* A sorted doubly linked list with nodes sorted in descending order.\\r\\n*\\r\\n* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\\r\\n* Nodes are ordered according to their current nominal individual collateral ratio (NICR),\\r\\n* which is like the ICR but without the price, i.e., just collateral / debt.\\r\\n*\\r\\n* The list optionally accepts insert position hints.\\r\\n*\\r\\n* NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\\r\\n* change dynamically as liquidation events occur.\\r\\n*\\r\\n* The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\\r\\n* but maintains their order. A node inserted based on current NICR will maintain the correct position,\\r\\n* relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\\r\\n* Thus, Nodes remain sorted by current NICR.\\r\\n*\\r\\n* Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\\r\\n* to their position.\\r\\n*\\r\\n* The list is a modification of the following audited SortedDoublyLinkedList:\\r\\n* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\\r\\n*\\r\\n*\\r\\n* Changes made in the Liquity implementation:\\r\\n*\\r\\n* - Keys have been removed from nodes\\r\\n*\\r\\n* - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\\r\\n*   The list relies on the property that ordering by ICR is maintained as the collateral:USD price varies.\\r\\n*\\r\\n* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\\r\\n*/\\r\\ncontract SortedTroves is Ownable, CheckContract, ISortedTroves {\\r\\n\\r\\n    string constant public NAME = \\\"SortedTroves\\\";\\r\\n\\r\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\r\\n\\r\\n    address public borrowerOperationsAddress;\\r\\n\\r\\n    ITroveManager public troveManager;\\r\\n\\r\\n    // Information for a node in the list\\r\\n    struct Node {\\r\\n        bool exists;\\r\\n        address nextId;                  // Id of next node (smaller NICR) in the list\\r\\n        address prevId;                  // Id of previous node (larger NICR) in the list\\r\\n    }\\r\\n\\r\\n    // Information for the list\\r\\n    struct Data {\\r\\n        address head;                        // Head of the list. Also the node in the list with the largest NICR\\r\\n        address tail;                        // Tail of the list. Also the node in the list with the smallest NICR\\r\\n        uint256 maxSize;                     // Maximum size of the list\\r\\n        uint256 size;                        // Current size of the list\\r\\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\\r\\n    }\\r\\n\\r\\n    Data public data;\\r\\n\\r\\n    // --- Dependency setters ---\\r\\n\\r\\n    function setParams(uint256 _size, address _troveManagerAddress, address _borrowerOperationsAddress) external override onlyOwner {\\r\\n        require(_size > 0, \\\"SortedTroves: Size cant be zero\\\");\\r\\n        checkContract(_troveManagerAddress);\\r\\n        checkContract(_borrowerOperationsAddress);\\r\\n\\r\\n        data.maxSize = _size;\\r\\n\\r\\n        troveManager = ITroveManager(_troveManagerAddress);\\r\\n        borrowerOperationsAddress = _borrowerOperationsAddress;\\r\\n\\r\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\r\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\r\\n\\r\\n        _renounceOwnership();\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Add a node to the list\\r\\n     * @param _id Node's id\\r\\n     * @param _NICR Node's NICR\\r\\n     * @param _prevId Id of previous node for the insert position\\r\\n     * @param _nextId Id of next node for the insert position\\r\\n     */\\r\\n\\r\\n    function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {\\r\\n        ITroveManager troveManagerCached = troveManager;\\r\\n\\r\\n        _requireCallerIsBOorTroveM(troveManagerCached);\\r\\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\\r\\n    }\\r\\n\\r\\n    function _insert(ITroveManager _troveManager, address _id, uint256 _NICR, address _prevId, address _nextId) internal {\\r\\n        // List must not be full\\r\\n        require(!isFull(), \\\"SortedTroves: List is full\\\");\\r\\n        // List must not already contain node\\r\\n        require(!contains(_id), \\\"SortedTroves: List already contains the node\\\");\\r\\n        // Node id must not be null\\r\\n        require(_id != address(0), \\\"SortedTroves: Id cannot be zero\\\");\\r\\n        // NICR must be non-zero\\r\\n        require(_NICR > 0, \\\"SortedTroves: NICR must be positive\\\");\\r\\n\\r\\n        address prevId = _prevId;\\r\\n        address nextId = _nextId;\\r\\n\\r\\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\r\\n            // Sender's hint was not a valid insert position\\r\\n            // Use sender's hint to find a valid insert position\\r\\n            (prevId, nextId) = _findInsertPosition(_troveManager, _NICR, prevId, nextId);\\r\\n        }\\r\\n\\r\\n         data.nodes[_id].exists = true;\\r\\n\\r\\n        if (prevId == address(0) && nextId == address(0)) {\\r\\n            // Insert as head and tail\\r\\n            data.head = _id;\\r\\n            data.tail = _id;\\r\\n        } else if (prevId == address(0)) {\\r\\n            // Insert before `prevId` as the head\\r\\n            data.nodes[_id].nextId = data.head;\\r\\n            data.nodes[data.head].prevId = _id;\\r\\n            data.head = _id;\\r\\n        } else if (nextId == address(0)) {\\r\\n            // Insert after `nextId` as the tail\\r\\n            data.nodes[_id].prevId = data.tail;\\r\\n            data.nodes[data.tail].nextId = _id;\\r\\n            data.tail = _id;\\r\\n        } else {\\r\\n            // Insert at insert position between `prevId` and `nextId`\\r\\n            data.nodes[_id].nextId = nextId;\\r\\n            data.nodes[_id].prevId = prevId;\\r\\n            data.nodes[prevId].nextId = _id;\\r\\n            data.nodes[nextId].prevId = _id;\\r\\n        }\\r\\n\\r\\n        data.size += 1;\\r\\n        emit NodeAdded(_id, _NICR);\\r\\n    }\\r\\n\\r\\n    function remove(address _id) external override {\\r\\n        _requireCallerIsTroveManager();\\r\\n        _remove(_id);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Remove a node from the list\\r\\n     * @param _id Node's id\\r\\n     */\\r\\n    function _remove(address _id) internal {\\r\\n        // List must contain the node\\r\\n        require(contains(_id), \\\"SortedTroves: List does not contain the id\\\");\\r\\n\\r\\n        if (data.size > 1) {\\r\\n            // List contains more than a single node\\r\\n            if (_id == data.head) {\\r\\n                // The removed node is the head\\r\\n                // Set head to next node\\r\\n                data.head = data.nodes[_id].nextId;\\r\\n                // Set prev pointer of new head to null\\r\\n                data.nodes[data.head].prevId = address(0);\\r\\n            } else if (_id == data.tail) {\\r\\n                // The removed node is the tail\\r\\n                // Set tail to previous node\\r\\n                data.tail = data.nodes[_id].prevId;\\r\\n                // Set next pointer of new tail to null\\r\\n                data.nodes[data.tail].nextId = address(0);\\r\\n            } else {\\r\\n                // The removed node is neither the head nor the tail\\r\\n                // Set next pointer of previous node to the next node\\r\\n                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;\\r\\n                // Set prev pointer of next node to the previous node\\r\\n                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;\\r\\n            }\\r\\n        } else {\\r\\n            // List contains a single node\\r\\n            // Set the head and tail to null\\r\\n            data.head = address(0);\\r\\n            data.tail = address(0);\\r\\n        }\\r\\n\\r\\n        delete data.nodes[_id];\\r\\n        data.size -= 1;\\r\\n        emit NodeRemoved(_id);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Re-insert the node at a new position, based on its new NICR\\r\\n     * @param _id Node's id\\r\\n     * @param _newNICR Node's new NICR\\r\\n     * @param _prevId Id of previous node for the new insert position\\r\\n     * @param _nextId Id of next node for the new insert position\\r\\n     */\\r\\n    function reInsert(address _id, uint256 _newNICR, address _prevId, address _nextId) external override {\\r\\n        ITroveManager troveManagerCached = troveManager;\\r\\n\\r\\n        _requireCallerIsBOorTroveM(troveManagerCached);\\r\\n        // List must contain the node\\r\\n        require(contains(_id), \\\"SortedTroves: List does not contain the id\\\");\\r\\n        // NICR must be non-zero\\r\\n        require(_newNICR > 0, \\\"SortedTroves: NICR must be positive\\\");\\r\\n\\r\\n        // Remove node from the list\\r\\n        _remove(_id);\\r\\n\\r\\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Checks if the list contains a node\\r\\n     */\\r\\n    function contains(address _id) public view override returns (bool) {\\r\\n        return data.nodes[_id].exists;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Checks if the list is full\\r\\n     */\\r\\n    function isFull() public view override returns (bool) {\\r\\n        return data.size == data.maxSize;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Checks if the list is empty\\r\\n     */\\r\\n    function isEmpty() public view override returns (bool) {\\r\\n        return data.size == 0;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the current size of the list\\r\\n     */\\r\\n    function getSize() external view override returns (uint256) {\\r\\n        return data.size;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the maximum size of the list\\r\\n     */\\r\\n    function getMaxSize() external view override returns (uint256) {\\r\\n        return data.maxSize;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the first node in the list (node with the largest NICR)\\r\\n     */\\r\\n    function getFirst() external view override returns (address) {\\r\\n        return data.head;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the last node in the list (node with the smallest NICR)\\r\\n     */\\r\\n    function getLast() external view override returns (address) {\\r\\n        return data.tail;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\\r\\n     * @param _id Node's id\\r\\n     */\\r\\n    function getNext(address _id) external view override returns (address) {\\r\\n        return data.nodes[_id].nextId;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\\r\\n     * @param _id Node's id\\r\\n     */\\r\\n    function getPrev(address _id) external view override returns (address) {\\r\\n        return data.nodes[_id].prevId;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\\r\\n     * @param _NICR Node's NICR\\r\\n     * @param _prevId Id of previous node for the insert position\\r\\n     * @param _nextId Id of next node for the insert position\\r\\n     */\\r\\n    function validInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (bool) {\\r\\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\\r\\n    }\\r\\n\\r\\n    function _validInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (bool) {\\r\\n        if (_prevId == address(0) && _nextId == address(0)) {\\r\\n            // `(null, null)` is a valid insert position if the list is empty\\r\\n            return isEmpty();\\r\\n        } else if (_prevId == address(0)) {\\r\\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\\r\\n            return data.head == _nextId && _NICR >= _troveManager.getNominalICR(_nextId);\\r\\n        } else if (_nextId == address(0)) {\\r\\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\\r\\n            return data.tail == _prevId && _NICR <= _troveManager.getNominalICR(_prevId);\\r\\n        } else {\\r\\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\\r\\n            return data.nodes[_prevId].nextId == _nextId &&\\r\\n                   _troveManager.getNominalICR(_prevId) >= _NICR &&\\r\\n                   _NICR >= _troveManager.getNominalICR(_nextId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\\r\\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\u2019s\\r\\n     * @param _NICR Node's NICR\\r\\n     * @param _startId Id of node to start descending the list from\\r\\n     */\\r\\n    function _descendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\\r\\n        // If `_startId` is the head, check if the insert position is before the head\\r\\n        if (data.head == _startId && _NICR >= _troveManager.getNominalICR(_startId)) {\\r\\n            return (address(0), _startId);\\r\\n        }\\r\\n\\r\\n        address prevId = _startId;\\r\\n        address nextId = data.nodes[prevId].nextId;\\r\\n\\r\\n        // Descend the list until we reach the end or until we find a valid insert position\\r\\n        while (prevId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\r\\n            prevId = data.nodes[prevId].nextId;\\r\\n            nextId = data.nodes[prevId].nextId;\\r\\n        }\\r\\n\\r\\n        return (prevId, nextId);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\\r\\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD\u2019s\\r\\n     * @param _NICR Node's NICR\\r\\n     * @param _startId Id of node to start ascending the list from\\r\\n     */\\r\\n    function _ascendList(ITroveManager _troveManager, uint256 _NICR, address _startId) internal view returns (address, address) {\\r\\n        // If `_startId` is the tail, check if the insert position is after the tail\\r\\n        if (data.tail == _startId && _NICR <= _troveManager.getNominalICR(_startId)) {\\r\\n            return (_startId, address(0));\\r\\n        }\\r\\n\\r\\n        address nextId = _startId;\\r\\n        address prevId = data.nodes[nextId].prevId;\\r\\n\\r\\n        // Ascend the list until we reach the end or until we find a valid insertion point\\r\\n        while (nextId != address(0) && !_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\\r\\n            nextId = data.nodes[nextId].prevId;\\r\\n            prevId = data.nodes[nextId].prevId;\\r\\n        }\\r\\n\\r\\n        return (prevId, nextId);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Find the insert position for a new node with the given NICR\\r\\n     * @param _NICR Node's NICR\\r\\n     * @param _prevId Id of previous node for the insert position\\r\\n     * @param _nextId Id of next node for the insert position\\r\\n     */\\r\\n    function findInsertPosition(uint256 _NICR, address _prevId, address _nextId) external view override returns (address, address) {\\r\\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\\r\\n    }\\r\\n\\r\\n    function _findInsertPosition(ITroveManager _troveManager, uint256 _NICR, address _prevId, address _nextId) internal view returns (address, address) {\\r\\n        address prevId = _prevId;\\r\\n        address nextId = _nextId;\\r\\n\\r\\n        if (prevId != address(0)) {\\r\\n            if (!contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)) {\\r\\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\\r\\n                prevId = address(0);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (nextId != address(0)) {\\r\\n            if (!contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)) {\\r\\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\\r\\n                nextId = address(0);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (prevId == address(0) && nextId == address(0)) {\\r\\n            // No hint - descend list starting from head\\r\\n            return _descendList(_troveManager, _NICR, data.head);\\r\\n        } else if (prevId == address(0)) {\\r\\n            // No `prevId` for hint - ascend list starting from `nextId`\\r\\n            return _ascendList(_troveManager, _NICR, nextId);\\r\\n        } else if (nextId == address(0)) {\\r\\n            // No `nextId` for hint - descend list starting from `prevId`\\r\\n            return _descendList(_troveManager, _NICR, prevId);\\r\\n        } else {\\r\\n            // Descend list starting from `prevId`\\r\\n            return _descendList(_troveManager, _NICR, prevId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // --- 'require' functions ---\\r\\n\\r\\n    function _requireCallerIsTroveManager() internal view {\\r\\n        require(msg.sender == address(troveManager), \\\"SortedTroves: Caller is not the TroveManager\\\");\\r\\n    }\\r\\n\\r\\n    function _requireCallerIsBOorTroveM(ITroveManager _troveManager) internal view {\\r\\n        require(msg.sender == borrowerOperationsAddress || msg.sender == address(_troveManager),\\r\\n                \\\"SortedTroves: Caller is neither BO nor TroveM\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/TroveManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Interfaces/ITroveManager.sol\\\";\\r\\nimport \\\"./Interfaces/IStabilityPool.sol\\\";\\r\\nimport \\\"./Interfaces/ICollSurplusPool.sol\\\";\\r\\nimport \\\"./Interfaces/IGasPool.sol\\\";\\r\\nimport \\\"./Interfaces/ITHUSDToken.sol\\\";\\r\\nimport \\\"./Interfaces/ISortedTroves.sol\\\";\\r\\nimport \\\"./Interfaces/IPCV.sol\\\";\\r\\nimport \\\"./Dependencies/LiquityBase.sol\\\";\\r\\nimport \\\"./Dependencies/Ownable.sol\\\";\\r\\nimport \\\"./Dependencies/CheckContract.sol\\\";\\r\\n\\r\\ncontract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {\\r\\n\\r\\n    string constant public NAME = \\\"TroveManager\\\";\\r\\n\\r\\n    // --- Connected contract declarations ---\\r\\n\\r\\n    address public borrowerOperationsAddress;\\r\\n\\r\\n    IStabilityPool public override stabilityPool;\\r\\n\\r\\n    address gasPoolAddress;\\r\\n\\r\\n    ICollSurplusPool collSurplusPool;\\r\\n\\r\\n    ITHUSDToken public override thusdToken;\\r\\n\\r\\n    IPCV public override pcv;\\r\\n\\r\\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\\r\\n    ISortedTroves public sortedTroves;\\r\\n\\r\\n    // --- Data structures ---\\r\\n\\r\\n    /*\\r\\n     * Half-life of 12h. 12h = 720 min\\r\\n     * (1/2) = d^720 => d = (1/2)^(1/720)\\r\\n     */\\r\\n    uint256 constant public MINUTE_DECAY_FACTOR = 999037758833783000;\\r\\n    uint256 constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\\r\\n    uint256 constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\\r\\n\\r\\n    /*\\r\\n    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\\r\\n    * Corresponds to (1 / ALPHA) in the white paper.\\r\\n    */\\r\\n    uint256 constant public BETA = 2;\\r\\n\\r\\n    uint256 public baseRate;\\r\\n\\r\\n    // The timestamp of the latest fee operation (redemption or new THUSD issuance)\\r\\n    uint256 public lastFeeOperationTime;\\r\\n\\r\\n    // Store the necessary data for a trove\\r\\n    struct Trove {\\r\\n        uint256 debt;\\r\\n        uint256 coll;\\r\\n        uint256 stake;\\r\\n        Status status;\\r\\n        uint128 arrayIndex;\\r\\n    }\\r\\n\\r\\n    mapping (address => Trove) public Troves;\\r\\n\\r\\n    uint256 public totalStakes;\\r\\n\\r\\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\\r\\n    uint256 public totalStakesSnapshot;\\r\\n\\r\\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\\r\\n    uint256 public totalCollateralSnapshot;\\r\\n\\r\\n    /*\\r\\n    * L_Collateral and L_THUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\\r\\n    *\\r\\n    * An collateral gain of ( stake * [L_Collateral - L_Collateral(0)] )\\r\\n    * A THUSDDebt increase  of ( stake * [L_THUSDDebt - L_THUSDDebt(0)] )\\r\\n    *\\r\\n    * Where L_Collateral(0) and L_THUSDDebt(0) are snapshots of L_Collateral and L_THUSDDebt for the active Trove taken at the instant the stake was made\\r\\n    */\\r\\n    uint256 public L_Collateral;\\r\\n    uint256 public L_THUSDDebt;\\r\\n\\r\\n    // Map addresses with active troves to their RewardSnapshot\\r\\n    mapping (address => RewardSnapshot) public rewardSnapshots;\\r\\n\\r\\n    // Object containing the collateral and THUSD snapshots for a given active trove\\r\\n    struct RewardSnapshot { uint256 collateral; uint256 THUSDDebt;}\\r\\n\\r\\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\\r\\n    address[] public TroveOwners;\\r\\n\\r\\n    // Error trackers for the trove redistribution calculation\\r\\n    uint256 public lastCollateralError_Redistribution;\\r\\n    uint256 public lastTHUSDDebtError_Redistribution;\\r\\n\\r\\n    /*\\r\\n    * --- Variable container structs for liquidations ---\\r\\n    *\\r\\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\\r\\n    * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\r\\n    **/\\r\\n\\r\\n    struct LocalVariables_OuterLiquidationFunction {\\r\\n        uint256 price;\\r\\n        uint256 THUSDInStabPool;\\r\\n        bool recoveryModeAtStart;\\r\\n        uint256 liquidatedDebt;\\r\\n        uint256 liquidatedColl;\\r\\n    }\\r\\n\\r\\n    struct LocalVariables_InnerSingleLiquidateFunction {\\r\\n        uint256 collToLiquidate;\\r\\n        uint256 pendingDebtReward;\\r\\n        uint256 pendingCollReward;\\r\\n    }\\r\\n\\r\\n    struct LocalVariables_LiquidationSequence {\\r\\n        uint256 remainingTHUSDInStabPool;\\r\\n        uint256 i;\\r\\n        uint256 ICR;\\r\\n        address user;\\r\\n        bool backToNormalMode;\\r\\n        uint256 entireSystemDebt;\\r\\n        uint256 entireSystemColl;\\r\\n    }\\r\\n\\r\\n    struct LiquidationValues {\\r\\n        uint256 entireTroveDebt;\\r\\n        uint256 entireTroveColl;\\r\\n        uint256 collGasCompensation;\\r\\n        uint256 THUSDGasCompensation;\\r\\n        uint256 debtToOffset;\\r\\n        uint256 collToSendToSP;\\r\\n        uint256 debtToRedistribute;\\r\\n        uint256 collToRedistribute;\\r\\n        uint256 collSurplus;\\r\\n    }\\r\\n\\r\\n    struct LiquidationTotals {\\r\\n        uint256 totalCollInSequence;\\r\\n        uint256 totalDebtInSequence;\\r\\n        uint256 totalCollGasCompensation;\\r\\n        uint256 totalTHUSDGasCompensation;\\r\\n        uint256 totalDebtToOffset;\\r\\n        uint256 totalCollToSendToSP;\\r\\n        uint256 totalDebtToRedistribute;\\r\\n        uint256 totalCollToRedistribute;\\r\\n        uint256 totalCollSurplus;\\r\\n    }\\r\\n\\r\\n    struct ContractsCache {\\r\\n        IActivePool activePool;\\r\\n        IDefaultPool defaultPool;\\r\\n        ITHUSDToken thusdToken;\\r\\n        IPCV pcv;\\r\\n        ISortedTroves sortedTroves;\\r\\n        ICollSurplusPool collSurplusPool;\\r\\n        address gasPoolAddress;\\r\\n    }\\r\\n    // --- Variable container structs for redemptions ---\\r\\n\\r\\n    struct RedemptionTotals {\\r\\n        uint256 remainingTHUSD;\\r\\n        uint256 totalTHUSDToRedeem;\\r\\n        uint256 totalCollateralDrawn;\\r\\n        uint256 collateralFee;\\r\\n        uint256 collateralToSendToRedeemer;\\r\\n        uint256 decayedBaseRate;\\r\\n        uint256 price;\\r\\n        uint256 totalTHUSDDebtAtStart;\\r\\n    }\\r\\n\\r\\n    struct SingleRedemptionValues {\\r\\n        uint256 THUSDLot;\\r\\n        uint256 collateralLot;\\r\\n        bool cancelledPartial;\\r\\n    }\\r\\n\\r\\n    // --- Events ---\\r\\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, TroveManagerOperation _operation);\\r\\n    event TroveLiquidated(address indexed _borrower, uint256 _debt, uint256 _coll, TroveManagerOperation _operation);\\r\\n\\r\\n    enum TroveManagerOperation {\\r\\n        applyPendingRewards,\\r\\n        liquidateInNormalMode,\\r\\n        liquidateInRecoveryMode,\\r\\n        redeemCollateral\\r\\n    }\\r\\n\\r\\n\\r\\n    // --- Dependency setter ---\\r\\n\\r\\n    function setAddresses(\\r\\n        address _borrowerOperationsAddress,\\r\\n        address _activePoolAddress,\\r\\n        address _defaultPoolAddress,\\r\\n        address _stabilityPoolAddress,\\r\\n        address _gasPoolAddress,\\r\\n        address _collSurplusPoolAddress,\\r\\n        address _priceFeedAddress,\\r\\n        address _thusdTokenAddress,\\r\\n        address _sortedTrovesAddress,\\r\\n        address _pcvAddress\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        onlyOwner\\r\\n    {\\r\\n        checkContract(_borrowerOperationsAddress);\\r\\n        checkContract(_activePoolAddress);\\r\\n        checkContract(_defaultPoolAddress);\\r\\n        checkContract(_stabilityPoolAddress);\\r\\n        checkContract(_gasPoolAddress);\\r\\n        checkContract(_collSurplusPoolAddress);\\r\\n        checkContract(_priceFeedAddress);\\r\\n        checkContract(_thusdTokenAddress);\\r\\n        checkContract(_sortedTrovesAddress);\\r\\n        checkContract(_pcvAddress);\\r\\n\\r\\n        borrowerOperationsAddress = _borrowerOperationsAddress;\\r\\n        activePool = IActivePool(_activePoolAddress);\\r\\n        defaultPool = IDefaultPool(_defaultPoolAddress);\\r\\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\\r\\n        gasPoolAddress = _gasPoolAddress;\\r\\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\\r\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\r\\n        thusdToken = ITHUSDToken(_thusdTokenAddress);\\r\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\r\\n        pcv = IPCV(_pcvAddress);\\r\\n\\r\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\r\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\r\\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\\r\\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\\r\\n        emit GasPoolAddressChanged(_gasPoolAddress);\\r\\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\\r\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\r\\n        emit THUSDTokenAddressChanged(_thusdTokenAddress);\\r\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\r\\n        emit PCVAddressChanged(_pcvAddress);\\r\\n\\r\\n        _renounceOwnership();\\r\\n    }\\r\\n\\r\\n    // --- Getters ---\\r\\n\\r\\n    function getTroveOwnersCount() external view override returns (uint) {\\r\\n        return TroveOwners.length;\\r\\n    }\\r\\n\\r\\n    function getTroveFromTroveOwnersArray(uint256 _index) external view override returns (address) {\\r\\n        return TroveOwners[_index];\\r\\n    }\\r\\n\\r\\n    // --- Trove Liquidation functions ---\\r\\n\\r\\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\\r\\n    function liquidate(address _borrower) external override {\\r\\n        _requireTroveIsActive(_borrower);\\r\\n\\r\\n        address[] memory borrowers = new address[](1);\\r\\n        borrowers[0] = _borrower;\\r\\n        batchLiquidateTroves(borrowers);\\r\\n    }\\r\\n\\r\\n    // --- Inner single liquidation functions ---\\r\\n\\r\\n    // Liquidate one trove, in Normal Mode.\\r\\n    function _liquidateNormalMode(\\r\\n        IActivePool _activePool,\\r\\n        IDefaultPool _defaultPool,\\r\\n        address _borrower,\\r\\n        uint256 _THUSDInStabPool\\r\\n    )\\r\\n        internal\\r\\n        returns (LiquidationValues memory singleLiquidation)\\r\\n    {\\r\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\r\\n\\r\\n        (singleLiquidation.entireTroveDebt,\\r\\n        singleLiquidation.entireTroveColl,\\r\\n        vars.pendingDebtReward,\\r\\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\\r\\n\\r\\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\r\\n        _removeStake(_borrower);\\r\\n\\r\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\\r\\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\\r\\n        uint256 collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\\r\\n\\r\\n        (singleLiquidation.debtToOffset,\\r\\n        singleLiquidation.collToSendToSP,\\r\\n        singleLiquidation.debtToRedistribute,\\r\\n        singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, collToLiquidate, _THUSDInStabPool);\\r\\n\\r\\n        _closeTrove(_borrower, Status.closedByLiquidation);\\r\\n        emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInNormalMode);\\r\\n        emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInNormalMode);\\r\\n        return singleLiquidation;\\r\\n    }\\r\\n\\r\\n    // Liquidate one trove, in Recovery Mode.\\r\\n    function _liquidateRecoveryMode(\\r\\n        IActivePool _activePool,\\r\\n        IDefaultPool _defaultPool,\\r\\n        address _borrower,\\r\\n        uint256 _ICR,\\r\\n        uint256 _THUSDInStabPool,\\r\\n        uint256 _TCR,\\r\\n        uint256 _price\\r\\n    )\\r\\n        internal\\r\\n        returns (LiquidationValues memory singleLiquidation)\\r\\n    {\\r\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\r\\n        if (TroveOwners.length <= 1) {return singleLiquidation;} // don't liquidate if last trove\\r\\n        (singleLiquidation.entireTroveDebt,\\r\\n        singleLiquidation.entireTroveColl,\\r\\n        vars.pendingDebtReward,\\r\\n        vars.pendingCollReward) = getEntireDebtAndColl(_borrower);\\r\\n\\r\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(singleLiquidation.entireTroveColl);\\r\\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\\r\\n        vars.collToLiquidate = singleLiquidation.entireTroveColl - singleLiquidation.collGasCompensation;\\r\\n\\r\\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\\r\\n        if (_ICR <= _100pct) {\\r\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\r\\n            _removeStake(_borrower);\\r\\n\\r\\n            singleLiquidation.debtToOffset = 0;\\r\\n            singleLiquidation.collToSendToSP = 0;\\r\\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\\r\\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\\r\\n\\r\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\r\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n\\r\\n        // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\\r\\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\\r\\n             _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\r\\n            _removeStake(_borrower);\\r\\n\\r\\n            (singleLiquidation.debtToOffset,\\r\\n            singleLiquidation.collToSendToSP,\\r\\n            singleLiquidation.debtToRedistribute,\\r\\n            singleLiquidation.collToRedistribute) = _getOffsetAndRedistributionVals(singleLiquidation.entireTroveDebt, vars.collToLiquidate, _THUSDInStabPool);\\r\\n\\r\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\r\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n        /*\\r\\n        * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\\r\\n        * and there is THUSD in the Stability Pool, only offset, with no redistribution,\\r\\n        * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\\r\\n        * The remainder due to the capped rate will be claimable as collateral surplus.\\r\\n        */\\r\\n        } else if ((_ICR >= MCR) && (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _THUSDInStabPool)) {\\r\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, vars.pendingCollReward);\\r\\n            assert(_THUSDInStabPool != 0);\\r\\n\\r\\n            _removeStake(_borrower);\\r\\n            singleLiquidation = _getCappedOffsetVals(singleLiquidation.entireTroveDebt, singleLiquidation.entireTroveColl, _price);\\r\\n\\r\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\r\\n            if (singleLiquidation.collSurplus > 0) {\\r\\n                collSurplusPool.accountSurplus(_borrower, singleLiquidation.collSurplus);\\r\\n            }\\r\\n\\r\\n            emit TroveLiquidated(_borrower, singleLiquidation.entireTroveDebt, singleLiquidation.collToSendToSP, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.liquidateInRecoveryMode);\\r\\n\\r\\n        } else { // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _THUSDInStabPool))\\r\\n            LiquidationValues memory zeroVals;\\r\\n            return zeroVals;\\r\\n        }\\r\\n\\r\\n        return singleLiquidation;\\r\\n    }\\r\\n\\r\\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\\r\\n    * redistributed to active troves.\\r\\n    */\\r\\n    function _getOffsetAndRedistributionVals\\r\\n    (\\r\\n        uint256 _debt,\\r\\n        uint256 _coll,\\r\\n        uint256 _THUSDInStabPool\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 debtToOffset, uint256 collToSendToSP, uint256 debtToRedistribute, uint256 collToRedistribute)\\r\\n    {\\r\\n        if (_THUSDInStabPool > 0) {\\r\\n        /*\\r\\n        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\\r\\n        * between all active troves.\\r\\n        *\\r\\n        *  If the trove's debt is larger than the deposited THUSD in the Stability Pool:\\r\\n        *\\r\\n        *  - Offset an amount of the trove's debt equal to the THUSD in the Stability Pool\\r\\n        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\\r\\n        *\\r\\n        */\\r\\n            debtToOffset = LiquityMath._min(_debt, _THUSDInStabPool);\\r\\n            collToSendToSP = _coll * debtToOffset / _debt;\\r\\n            debtToRedistribute = _debt - debtToOffset;\\r\\n            collToRedistribute = _coll - collToSendToSP;\\r\\n        } else {\\r\\n            debtToOffset = 0;\\r\\n            collToSendToSP = 0;\\r\\n            debtToRedistribute = _debt;\\r\\n            collToRedistribute = _coll;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    *  Get its offset coll/debt and collateral gas comp, and close the trove.\\r\\n    */\\r\\n    function _getCappedOffsetVals\\r\\n    (\\r\\n        uint256 _entireTroveDebt,\\r\\n        uint256 _entireTroveColl,\\r\\n        uint256 _price\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (LiquidationValues memory singleLiquidation)\\r\\n    {\\r\\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\\r\\n        singleLiquidation.entireTroveColl = _entireTroveColl;\\r\\n        uint256 cappedCollPortion = _entireTroveDebt * MCR / _price;\\r\\n\\r\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(cappedCollPortion);\\r\\n        singleLiquidation.THUSDGasCompensation = THUSD_GAS_COMPENSATION;\\r\\n\\r\\n        singleLiquidation.debtToOffset = _entireTroveDebt;\\r\\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\\r\\n        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;\\r\\n        singleLiquidation.debtToRedistribute = 0;\\r\\n        singleLiquidation.collToRedistribute = 0;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\\r\\n    * starting from the one with the lowest collateral ratio in the system, and moving upwards\\r\\n    */\\r\\n    function liquidateTroves(uint256 _n) external override {\\r\\n        ContractsCache memory contractsCache = ContractsCache(\\r\\n            activePool,\\r\\n            defaultPool,\\r\\n            ITHUSDToken(address(0)),\\r\\n            IPCV(address(0)),\\r\\n            sortedTroves,\\r\\n            ICollSurplusPool(address(0)),\\r\\n            address(0)\\r\\n        );\\r\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\r\\n\\r\\n        LocalVariables_OuterLiquidationFunction memory vars;\\r\\n\\r\\n        LiquidationTotals memory totals;\\r\\n\\r\\n        vars.price = priceFeed.fetchPrice();\\r\\n        vars.THUSDInStabPool = stabilityPoolCached.getTotalTHUSDDeposits();\\r\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\r\\n\\r\\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\\r\\n        if (vars.recoveryModeAtStart) {\\r\\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(contractsCache, vars.price, vars.THUSDInStabPool, _n);\\r\\n        } else { // if !vars.recoveryModeAtStart\\r\\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(contractsCache.activePool, contractsCache.defaultPool, vars.price, vars.THUSDInStabPool, _n);\\r\\n        }\\r\\n\\r\\n        require(totals.totalDebtInSequence > 0, \\\"TroveManager: nothing to liquidate\\\");\\r\\n\\r\\n        // Move liquidated collateral and THUSD to the appropriate pools\\r\\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\\r\\n        _redistributeDebtAndColl(contractsCache.activePool, contractsCache.defaultPool, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\\r\\n        if (totals.totalCollSurplus > 0) {\\r\\n            contractsCache.activePool.sendCollateral(address(collSurplusPool), totals.totalCollSurplus);\\r\\n        }\\r\\n\\r\\n        // Update system snapshots\\r\\n        _updateSystemSnapshots_excludeCollRemainder(contractsCache.activePool, totals.totalCollGasCompensation);\\r\\n\\r\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\r\\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\\r\\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalTHUSDGasCompensation);\\r\\n\\r\\n        // Send gas compensation to caller\\r\\n        _sendGasCompensation(contractsCache.activePool, msg.sender, totals.totalTHUSDGasCompensation, totals.totalCollGasCompensation);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\\r\\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\r\\n    */\\r\\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode\\r\\n    (\\r\\n        ContractsCache memory _contractsCache,\\r\\n        uint256 _price,\\r\\n        uint256 _THUSDInStabPool,\\r\\n        uint256 _n\\r\\n    )\\r\\n        internal\\r\\n        returns(LiquidationTotals memory totals)\\r\\n    {\\r\\n        LocalVariables_LiquidationSequence memory vars;\\r\\n        LiquidationValues memory singleLiquidation;\\r\\n\\r\\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\\r\\n        vars.backToNormalMode = false;\\r\\n        vars.entireSystemDebt = getEntireSystemDebt();\\r\\n        vars.entireSystemColl = getEntireSystemColl();\\r\\n\\r\\n        vars.user = _contractsCache.sortedTroves.getLast();\\r\\n        address firstUser = _contractsCache.sortedTroves.getFirst();\\r\\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\\r\\n            // we need to cache it, because current user is likely going to be deleted\\r\\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\\r\\n\\r\\n            vars.ICR = getCurrentICR(vars.user, _price);\\r\\n\\r\\n            if (!vars.backToNormalMode) {\\r\\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\\r\\n                if (vars.ICR >= MCR && vars.remainingTHUSDInStabPool == 0) { break; }\\r\\n\\r\\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\\r\\n\\r\\n                singleLiquidation = _liquidateRecoveryMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.ICR, vars.remainingTHUSDInStabPool, TCR, _price);\\r\\n\\r\\n                // Update aggregate trackers\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n                vars.entireSystemDebt -= singleLiquidation.debtToOffset;\\r\\n                vars.entireSystemColl -= singleLiquidation.collToSendToSP\\r\\n                    + singleLiquidation.collGasCompensation\\r\\n                    + singleLiquidation.collSurplus;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n\\r\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\\r\\n            }\\r\\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\\r\\n                singleLiquidation = _liquidateNormalMode(_contractsCache.activePool, _contractsCache.defaultPool, vars.user, vars.remainingTHUSDInStabPool);\\r\\n\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n\\r\\n            }  else break;  // break if the loop reaches a Trove with ICR >= MCR\\r\\n\\r\\n            vars.user = nextUser;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode\\r\\n    (\\r\\n        IActivePool _activePool,\\r\\n        IDefaultPool _defaultPool,\\r\\n        uint256 _price,\\r\\n        uint256 _THUSDInStabPool,\\r\\n        uint256 _n\\r\\n    )\\r\\n        internal\\r\\n        returns(LiquidationTotals memory totals)\\r\\n    {\\r\\n        LocalVariables_LiquidationSequence memory vars;\\r\\n        LiquidationValues memory singleLiquidation;\\r\\n        ISortedTroves sortedTrovesCached = sortedTroves;\\r\\n\\r\\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\\r\\n\\r\\n        for (vars.i = 0; vars.i < _n; vars.i++) {\\r\\n            vars.user = sortedTrovesCached.getLast();\\r\\n            vars.ICR = getCurrentICR(vars.user, _price);\\r\\n\\r\\n            if (vars.ICR < MCR) {\\r\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\\r\\n\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n\\r\\n            } else break;  // break if the loop reaches a Trove with ICR >= MCR\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Attempt to liquidate a custom list of troves provided by the caller.\\r\\n    */\\r\\n    function batchLiquidateTroves(address[] memory _troveArray) public override {\\r\\n        require(_troveArray.length != 0, \\\"TroveManager: Calldata address array must not be empty\\\");\\r\\n\\r\\n        IActivePool activePoolCached = activePool;\\r\\n        IDefaultPool defaultPoolCached = defaultPool;\\r\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\r\\n\\r\\n        LocalVariables_OuterLiquidationFunction memory vars;\\r\\n        LiquidationTotals memory totals;\\r\\n\\r\\n        vars.price = priceFeed.fetchPrice();\\r\\n        vars.THUSDInStabPool = stabilityPoolCached.getTotalTHUSDDeposits();\\r\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\r\\n\\r\\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\\r\\n        if (vars.recoveryModeAtStart) {\\r\\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(activePoolCached, defaultPoolCached, vars.price, vars.THUSDInStabPool, _troveArray);\\r\\n        } else {  //  if !vars.recoveryModeAtStart\\r\\n            totals = _getTotalsFromBatchLiquidate_NormalMode(activePoolCached, defaultPoolCached, vars.price, vars.THUSDInStabPool, _troveArray);\\r\\n        }\\r\\n\\r\\n        require(totals.totalDebtInSequence > 0, \\\"TroveManager: nothing to liquidate\\\");\\r\\n\\r\\n        // Move liquidated collateral and THUSD to the appropriate pools\\r\\n        stabilityPoolCached.offset(totals.totalDebtToOffset, totals.totalCollToSendToSP);\\r\\n        _redistributeDebtAndColl(activePoolCached, defaultPoolCached, totals.totalDebtToRedistribute, totals.totalCollToRedistribute);\\r\\n        if (totals.totalCollSurplus > 0) {\\r\\n            activePoolCached.sendCollateral(address(collSurplusPool), totals.totalCollSurplus);\\r\\n        }\\r\\n\\r\\n        // Update system snapshots\\r\\n        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.totalCollGasCompensation);\\r\\n\\r\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\r\\n        vars.liquidatedColl = totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollSurplus;\\r\\n        emit Liquidation(vars.liquidatedDebt, vars.liquidatedColl, totals.totalCollGasCompensation, totals.totalTHUSDGasCompensation);\\r\\n\\r\\n        // Send gas compensation to caller\\r\\n        _sendGasCompensation(activePoolCached, msg.sender, totals.totalTHUSDGasCompensation, totals.totalCollGasCompensation);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\\r\\n    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\r\\n    */\\r\\n    function _getTotalFromBatchLiquidate_RecoveryMode\\r\\n    (\\r\\n        IActivePool _activePool,\\r\\n        IDefaultPool _defaultPool,\\r\\n        uint256 _price,\\r\\n        uint256 _THUSDInStabPool,\\r\\n        address[] memory _troveArray\\r\\n    )\\r\\n        internal\\r\\n        returns(LiquidationTotals memory totals)\\r\\n    {\\r\\n        LocalVariables_LiquidationSequence memory vars;\\r\\n        LiquidationValues memory singleLiquidation;\\r\\n\\r\\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\\r\\n        vars.backToNormalMode = false;\\r\\n        vars.entireSystemDebt = getEntireSystemDebt();\\r\\n        vars.entireSystemColl = getEntireSystemColl();\\r\\n\\r\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\r\\n            vars.user = _troveArray[vars.i];\\r\\n            // Skip non-active troves\\r\\n            if (Troves[vars.user].status != Status.active) { continue; }\\r\\n            vars.ICR = getCurrentICR(vars.user, _price);\\r\\n\\r\\n            if (!vars.backToNormalMode) {\\r\\n\\r\\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\\r\\n                if (vars.ICR >= MCR && vars.remainingTHUSDInStabPool == 0) { continue; }\\r\\n\\r\\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\\r\\n\\r\\n                singleLiquidation = _liquidateRecoveryMode(_activePool, _defaultPool, vars.user, vars.ICR, vars.remainingTHUSDInStabPool, TCR, _price);\\r\\n\\r\\n                // Update aggregate trackers\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n                vars.entireSystemDebt -= singleLiquidation.debtToOffset;\\r\\n                vars.entireSystemColl -= singleLiquidation.collToSendToSP\\r\\n                    + singleLiquidation.collGasCompensation\\r\\n                    + singleLiquidation.collSurplus;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n\\r\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(vars.entireSystemColl, vars.entireSystemDebt, _price);\\r\\n            }\\r\\n\\r\\n            else if (vars.backToNormalMode && vars.ICR < MCR) {\\r\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n\\r\\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getTotalsFromBatchLiquidate_NormalMode\\r\\n    (\\r\\n        IActivePool _activePool,\\r\\n        IDefaultPool _defaultPool,\\r\\n        uint256 _price,\\r\\n        uint256 _THUSDInStabPool,\\r\\n        address[] memory _troveArray\\r\\n    )\\r\\n        internal\\r\\n        returns(LiquidationTotals memory totals)\\r\\n    {\\r\\n        LocalVariables_LiquidationSequence memory vars;\\r\\n        LiquidationValues memory singleLiquidation;\\r\\n\\r\\n        vars.remainingTHUSDInStabPool = _THUSDInStabPool;\\r\\n\\r\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\r\\n            vars.user = _troveArray[vars.i];\\r\\n            vars.ICR = getCurrentICR(vars.user, _price);\\r\\n\\r\\n            if (vars.ICR < MCR) {\\r\\n                singleLiquidation = _liquidateNormalMode(_activePool, _defaultPool, vars.user, vars.remainingTHUSDInStabPool);\\r\\n                vars.remainingTHUSDInStabPool -= singleLiquidation.debtToOffset;\\r\\n\\r\\n                // Add liquidation values to their respective running totals\\r\\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // --- Liquidation helper functions ---\\r\\n\\r\\n    function _addLiquidationValuesToTotals(LiquidationTotals memory oldTotals, LiquidationValues memory singleLiquidation)\\r\\n    internal pure returns(LiquidationTotals memory newTotals) {\\r\\n\\r\\n        // Tally all the values with their respective running totals\\r\\n        newTotals.totalCollGasCompensation = oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\\r\\n        newTotals.totalTHUSDGasCompensation = oldTotals.totalTHUSDGasCompensation + singleLiquidation.THUSDGasCompensation;\\r\\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence + singleLiquidation.entireTroveDebt;\\r\\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence + singleLiquidation.entireTroveColl;\\r\\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\\r\\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\\r\\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\\r\\n        newTotals.totalCollToRedistribute = oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\\r\\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;\\r\\n\\r\\n        return newTotals;\\r\\n    }\\r\\n\\r\\n    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _THUSD, uint256 _collateral) internal {\\r\\n        if (_THUSD > 0) {\\r\\n            IGasPool(gasPoolAddress).sendTHUSD(_liquidator, _THUSD);\\r\\n        }\\r\\n\\r\\n        if (_collateral > 0) {\\r\\n            _activePool.sendCollateral(_liquidator, _collateral);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\\r\\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint256 _THUSD, uint256 _collateral) internal {\\r\\n        _defaultPool.decreaseTHUSDDebt(_THUSD);\\r\\n        _activePool.increaseTHUSDDebt(_THUSD);\\r\\n        _defaultPool.sendCollateralToActivePool(_collateral);\\r\\n    }\\r\\n\\r\\n    // --- Redemption functions ---\\r\\n\\r\\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for THUSD up to _maxTHUSDamount\\r\\n    function _redeemCollateralFromTrove(\\r\\n        ContractsCache memory _contractsCache,\\r\\n        address _borrower,\\r\\n        uint256 _maxTHUSDamount,\\r\\n        uint256 _price,\\r\\n        address _upperPartialRedemptionHint,\\r\\n        address _lowerPartialRedemptionHint,\\r\\n        uint256 _partialRedemptionHintNICR\\r\\n    )\\r\\n        internal returns (SingleRedemptionValues memory singleRedemption)\\r\\n    {\\r\\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\\r\\n        singleRedemption.THUSDLot = LiquityMath._min(_maxTHUSDamount, Troves[_borrower].debt - THUSD_GAS_COMPENSATION);\\r\\n\\r\\n        // Get the collateralLot of equivalent value in USD\\r\\n        singleRedemption.collateralLot = singleRedemption.THUSDLot * DECIMAL_PRECISION / _price;\\r\\n\\r\\n        // Decrease the debt and collateral of the current Trove according to the THUSD lot and corresponding collateral to send\\r\\n        uint256 newDebt = Troves[_borrower].debt - singleRedemption.THUSDLot;\\r\\n        uint256 newColl = Troves[_borrower].coll - singleRedemption.collateralLot;\\r\\n\\r\\n        if (newDebt == THUSD_GAS_COMPENSATION) {\\r\\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\\r\\n            _removeStake(_borrower);\\r\\n            _closeTrove(_borrower, Status.closedByRedemption);\\r\\n            _redeemCloseTrove(_contractsCache, _borrower, THUSD_GAS_COMPENSATION, newColl);\\r\\n            emit TroveUpdated(_borrower, 0, 0, 0, TroveManagerOperation.redeemCollateral);\\r\\n\\r\\n        } else {\\r\\n            uint256 newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\\r\\n\\r\\n            /*\\r\\n            * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\\r\\n            * certainly result in running out of gas.\\r\\n            *\\r\\n            * If the resultant net debt of the partial is less than the minimum, net debt we bail.\\r\\n            */\\r\\n            if (newNICR != _partialRedemptionHintNICR || _getNetDebt(newDebt) < MIN_NET_DEBT) {\\r\\n                singleRedemption.cancelledPartial = true;\\r\\n                return singleRedemption;\\r\\n            }\\r\\n\\r\\n            _contractsCache.sortedTroves.reInsert(_borrower, newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint);\\r\\n\\r\\n            Troves[_borrower].debt = newDebt;\\r\\n            Troves[_borrower].coll = newColl;\\r\\n            _updateStakeAndTotalStakes(_borrower);\\r\\n\\r\\n            emit TroveUpdated(\\r\\n                _borrower,\\r\\n                newDebt, newColl,\\r\\n                Troves[_borrower].stake,\\r\\n                TroveManagerOperation.redeemCollateral\\r\\n            );\\r\\n        }\\r\\n\\r\\n        return singleRedemption;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Called when a full redemption occurs, and closes the trove.\\r\\n    * The redeemer swaps (debt - liquidation reserve) THUSD for (debt - liquidation reserve) worth of collateral, so the THUSD liquidation reserve left corresponds to the remaining debt.\\r\\n    * In order to close the trove, the THUSD liquidation reserve is burned, and the corresponding debt is removed from the active pool.\\r\\n    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\\r\\n    * Any surplus collateral left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\\r\\n    */\\r\\n    function _redeemCloseTrove(ContractsCache memory _contractsCache, address _borrower, uint256 _THUSD, uint256 _collateral) internal {\\r\\n        _contractsCache.thusdToken.burn(gasPoolAddress, _THUSD);\\r\\n        // Update Active Pool THUSD, and send collateral to account\\r\\n        _contractsCache.activePool.decreaseTHUSDDebt(_THUSD);\\r\\n\\r\\n        // send collateral from Active Pool to CollSurplus Pool\\r\\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _collateral);\\r\\n        _contractsCache.activePool.sendCollateral(address(_contractsCache.collSurplusPool), _collateral);\\r\\n    }\\r\\n\\r\\n    function _isValidFirstRedemptionHint(ISortedTroves _sortedTroves, address _firstRedemptionHint, uint256 _price) internal view returns (bool) {\\r\\n        if (_firstRedemptionHint == address(0) ||\\r\\n            !_sortedTroves.contains(_firstRedemptionHint) ||\\r\\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\\r\\n        ) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\\r\\n        return nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\\r\\n    }\\r\\n\\r\\n    /* Send _THUSDamount THUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\\r\\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\\r\\n    *\\r\\n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\\r\\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\\r\\n    *\\r\\n    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it\u2019s zero, it will be ignored).This makes it easier to\\r\\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the \u201ctopology\u201d\\r\\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\\r\\n    * costs can vary.\\r\\n    *\\r\\n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\\r\\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\\r\\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\\r\\n    * in the sortedTroves list along with the ICR value that the hint was found for.\\r\\n    *\\r\\n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\\r\\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\\r\\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining THUSD amount, which they can attempt\\r\\n    * to redeem later.\\r\\n    */\\r\\n    function redeemCollateral(\\r\\n        uint256 _THUSDamount,\\r\\n        address _firstRedemptionHint,\\r\\n        address _upperPartialRedemptionHint,\\r\\n        address _lowerPartialRedemptionHint,\\r\\n        uint256 _partialRedemptionHintNICR,\\r\\n        uint256 _maxIterations,\\r\\n        uint256 _maxFeePercentage\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        ContractsCache memory contractsCache = ContractsCache(\\r\\n            activePool,\\r\\n            defaultPool,\\r\\n            thusdToken,\\r\\n            pcv,\\r\\n            sortedTroves,\\r\\n            collSurplusPool,\\r\\n            gasPoolAddress\\r\\n        );\\r\\n        RedemptionTotals memory totals;\\r\\n\\r\\n        _requireValidMaxFeePercentage(_maxFeePercentage);\\r\\n        totals.price = priceFeed.fetchPrice();\\r\\n        _requireTCRoverMCR(totals.price);\\r\\n        _requireAmountGreaterThanZero(_THUSDamount);\\r\\n        _requireTHUSDBalanceCoversRedemption(contractsCache.thusdToken, msg.sender, _THUSDamount);\\r\\n\\r\\n        totals.totalTHUSDDebtAtStart = getEntireSystemDebt();\\r\\n        totals.remainingTHUSD = _THUSDamount;\\r\\n        address currentBorrower;\\r\\n\\r\\n        if (_isValidFirstRedemptionHint(contractsCache.sortedTroves, _firstRedemptionHint, totals.price)) {\\r\\n            currentBorrower = _firstRedemptionHint;\\r\\n        } else {\\r\\n            currentBorrower = contractsCache.sortedTroves.getLast();\\r\\n            // Find the first trove with ICR >= MCR\\r\\n            while (currentBorrower != address(0) && getCurrentICR(currentBorrower, totals.price) < MCR) {\\r\\n                currentBorrower = contractsCache.sortedTroves.getPrev(currentBorrower);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of THUSD is exchanged for collateral\\r\\n        if (_maxIterations == 0) { _maxIterations = type(uint256).max; }\\r\\n        while (currentBorrower != address(0) && totals.remainingTHUSD > 0 && _maxIterations > 0) {\\r\\n            _maxIterations--;\\r\\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\\r\\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(currentBorrower);\\r\\n\\r\\n            _applyPendingRewards(contractsCache.activePool, contractsCache.defaultPool, currentBorrower);\\r\\n\\r\\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrove(\\r\\n                contractsCache,\\r\\n                currentBorrower,\\r\\n                totals.remainingTHUSD,\\r\\n                totals.price,\\r\\n                _upperPartialRedemptionHint,\\r\\n                _lowerPartialRedemptionHint,\\r\\n                _partialRedemptionHintNICR\\r\\n            );\\r\\n\\r\\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\\r\\n\\r\\n            totals.totalTHUSDToRedeem  += singleRedemption.THUSDLot;\\r\\n            totals.totalCollateralDrawn += singleRedemption.collateralLot;\\r\\n\\r\\n            totals.remainingTHUSD -= singleRedemption.THUSDLot;\\r\\n            currentBorrower = nextUserToCheck;\\r\\n        }\\r\\n        require(totals.totalCollateralDrawn > 0, \\\"TroveManager: Unable to redeem any amount\\\");\\r\\n\\r\\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\\r\\n        // Use the saved total THUSD supply value, from before it was reduced by the redemption.\\r\\n        _updateBaseRateFromRedemption(totals.totalCollateralDrawn, totals.price, totals.totalTHUSDDebtAtStart);\\r\\n\\r\\n        // Calculate the collateral fee\\r\\n        totals.collateralFee = _getRedemptionFee(totals.totalCollateralDrawn);\\r\\n\\r\\n        _requireUserAcceptsFee(totals.collateralFee, totals.totalCollateralDrawn, _maxFeePercentage);\\r\\n\\r\\n        // Send the collateral fee to the PCV contract\\r\\n        contractsCache.activePool.sendCollateral(address(contractsCache.pcv), totals.collateralFee);\\r\\n\\r\\n        totals.collateralToSendToRedeemer = totals.totalCollateralDrawn - totals.collateralFee;\\r\\n\\r\\n        emit Redemption(_THUSDamount, totals.totalTHUSDToRedeem, totals.totalCollateralDrawn, totals.collateralFee);\\r\\n\\r\\n        // Burn the total THUSD that is cancelled with debt, and send the redeemed collateral to msg.sender\\r\\n        contractsCache.thusdToken.burn(msg.sender, totals.totalTHUSDToRedeem);\\r\\n        // Update Active Pool THUSD, and send collateral to account\\r\\n        contractsCache.activePool.decreaseTHUSDDebt(totals.totalTHUSDToRedeem);\\r\\n        contractsCache.activePool.sendCollateral(msg.sender, totals.collateralToSendToRedeemer);\\r\\n    }\\r\\n\\r\\n    // --- Helper functions ---\\r\\n\\r\\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\\r\\n    function getNominalICR(address _borrower) public view override returns (uint) {\\r\\n        (uint256 currentCollateral, uint256 currentTHUSDDebt) = _getCurrentTroveAmounts(_borrower);\\r\\n\\r\\n        uint256 NICR = LiquityMath._computeNominalCR(currentCollateral, currentTHUSDDebt);\\r\\n        return NICR;\\r\\n    }\\r\\n\\r\\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\\r\\n    function getCurrentICR(address _borrower, uint256 _price) public view override returns (uint) {\\r\\n        (uint256 currentCollateral, uint256 currentTHUSDDebt) = _getCurrentTroveAmounts(_borrower);\\r\\n\\r\\n        uint256 ICR = LiquityMath._computeCR(currentCollateral, currentTHUSDDebt, _price);\\r\\n        return ICR;\\r\\n    }\\r\\n\\r\\n    function _getCurrentTroveAmounts(address _borrower) internal view returns (uint, uint) {\\r\\n        uint256 pendingCollateralReward = getPendingCollateralReward(_borrower);\\r\\n        uint256 pendingTHUSDDebtReward = getPendingTHUSDDebtReward(_borrower);\\r\\n\\r\\n        uint256 currentCollateral = Troves[_borrower].coll + pendingCollateralReward;\\r\\n        uint256 currentTHUSDDebt = Troves[_borrower].debt + pendingTHUSDDebtReward;\\r\\n\\r\\n        return (currentCollateral, currentTHUSDDebt);\\r\\n    }\\r\\n\\r\\n    function applyPendingRewards(address _borrower) external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\\r\\n    }\\r\\n\\r\\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\\r\\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\\r\\n        if (hasPendingRewards(_borrower)) {\\r\\n            _requireTroveIsActive(_borrower);\\r\\n\\r\\n            // Compute pending rewards\\r\\n            uint256 pendingCollateralReward = getPendingCollateralReward(_borrower);\\r\\n            uint256 pendingTHUSDDebtReward = getPendingTHUSDDebtReward(_borrower);\\r\\n\\r\\n            // Apply pending rewards to trove's state\\r\\n            Troves[_borrower].coll += pendingCollateralReward;\\r\\n            Troves[_borrower].debt += pendingTHUSDDebtReward;\\r\\n\\r\\n            _updateTroveRewardSnapshots(_borrower);\\r\\n\\r\\n            // Transfer from DefaultPool to ActivePool\\r\\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingTHUSDDebtReward, pendingCollateralReward);\\r\\n\\r\\n            emit TroveUpdated(\\r\\n                _borrower,\\r\\n                Troves[_borrower].debt,\\r\\n                Troves[_borrower].coll,\\r\\n                Troves[_borrower].stake,\\r\\n                TroveManagerOperation.applyPendingRewards\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Update borrower's snapshots of L_Collateral and L_THUSDDebt to reflect the current values\\r\\n    function updateTroveRewardSnapshots(address _borrower) external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n       return _updateTroveRewardSnapshots(_borrower);\\r\\n    }\\r\\n\\r\\n    function _updateTroveRewardSnapshots(address _borrower) internal {\\r\\n        rewardSnapshots[_borrower].collateral = L_Collateral;\\r\\n        rewardSnapshots[_borrower].THUSDDebt = L_THUSDDebt;\\r\\n        emit TroveSnapshotsUpdated(L_Collateral, L_THUSDDebt);\\r\\n    }\\r\\n\\r\\n    // Get the borrower's pending accumulated collateral reward, earned by their stake\\r\\n    function getPendingCollateralReward(address _borrower) public view override returns (uint) {\\r\\n        uint256 snapshotCollateral = rewardSnapshots[_borrower].collateral;\\r\\n        uint256 rewardPerUnitStaked = L_Collateral - snapshotCollateral;\\r\\n\\r\\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\\r\\n\\r\\n        uint256 stake = Troves[_borrower].stake;\\r\\n\\r\\n        uint256 pendingCollateralReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\\r\\n\\r\\n        return pendingCollateralReward;\\r\\n    }\\r\\n\\r\\n    // Get the borrower's pending accumulated THUSD reward, earned by their stake\\r\\n    function getPendingTHUSDDebtReward(address _borrower) public view override returns (uint) {\\r\\n        uint256 snapshotTHUSDDebt = rewardSnapshots[_borrower].THUSDDebt;\\r\\n        uint256 rewardPerUnitStaked = L_THUSDDebt - snapshotTHUSDDebt;\\r\\n\\r\\n        if ( rewardPerUnitStaked == 0 || Troves[_borrower].status != Status.active) { return 0; }\\r\\n\\r\\n        uint256 stake =  Troves[_borrower].stake;\\r\\n\\r\\n        uint256 pendingTHUSDDebtReward = stake * rewardPerUnitStaked / DECIMAL_PRECISION;\\r\\n\\r\\n        return pendingTHUSDDebtReward;\\r\\n    }\\r\\n\\r\\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\\r\\n        /*\\r\\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\\r\\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\\r\\n        * pending rewards\\r\\n        */\\r\\n        if (Troves[_borrower].status != Status.active) {return false;}\\r\\n\\r\\n        return (rewardSnapshots[_borrower].collateral < L_Collateral);\\r\\n    }\\r\\n\\r\\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\\r\\n    function getEntireDebtAndColl(\\r\\n        address _borrower\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 debt, uint256 coll, uint256 pendingTHUSDDebtReward, uint256 pendingCollateralReward)\\r\\n    {\\r\\n        debt = Troves[_borrower].debt;\\r\\n        coll = Troves[_borrower].coll;\\r\\n\\r\\n        pendingTHUSDDebtReward = getPendingTHUSDDebtReward(_borrower);\\r\\n        pendingCollateralReward = getPendingCollateralReward(_borrower);\\r\\n\\r\\n        debt += pendingTHUSDDebtReward;\\r\\n        coll += pendingCollateralReward;\\r\\n    }\\r\\n\\r\\n    function removeStake(address _borrower) external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        return _removeStake(_borrower);\\r\\n    }\\r\\n\\r\\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\\r\\n    function _removeStake(address _borrower) internal {\\r\\n        uint256 stake = Troves[_borrower].stake;\\r\\n        totalStakes -= stake;\\r\\n        Troves[_borrower].stake = 0;\\r\\n    }\\r\\n\\r\\n    function updateStakeAndTotalStakes(address _borrower) external override returns (uint) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        return _updateStakeAndTotalStakes(_borrower);\\r\\n    }\\r\\n\\r\\n    // Update borrower's stake based on their latest collateral value\\r\\n    function _updateStakeAndTotalStakes(address _borrower) internal returns (uint) {\\r\\n        uint256 newStake = _computeNewStake(Troves[_borrower].coll);\\r\\n        uint256 oldStake = Troves[_borrower].stake;\\r\\n        Troves[_borrower].stake = newStake;\\r\\n\\r\\n        totalStakes = totalStakes - oldStake + newStake;\\r\\n        emit TotalStakesUpdated(totalStakes);\\r\\n\\r\\n        return newStake;\\r\\n    }\\r\\n\\r\\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\\r\\n    function _computeNewStake(uint256 _coll) internal view returns (uint) {\\r\\n        uint256 stake;\\r\\n        if (totalCollateralSnapshot == 0) {\\r\\n            stake = _coll;\\r\\n        } else {\\r\\n            /*\\r\\n            * The following assert() holds true because:\\r\\n            * - The system always contains >= 1 trove\\r\\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\\r\\n            * rewards would\u2019ve been emptied and totalCollateralSnapshot would be zero too.\\r\\n            */\\r\\n            assert(totalStakesSnapshot > 0);\\r\\n            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;\\r\\n        }\\r\\n        return stake;\\r\\n    }\\r\\n\\r\\n    function _redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint256 _debt, uint256 _coll) internal {\\r\\n        if (_debt == 0) { return; }\\r\\n\\r\\n        /*\\r\\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \\\"feedback\\\"\\r\\n        * error correction, to keep the cumulative error low in the running totals L_Collateral and L_THUSDDebt:\\r\\n        *\\r\\n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\r\\n        * function was called.\\r\\n        * 2) Calculate \\\"per-unit-staked\\\" ratios.\\r\\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\r\\n        * 4) Store these errors for use in the next correction when this function is called.\\r\\n        * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\r\\n        */\\r\\n        uint256 collateralNumerator = _coll * DECIMAL_PRECISION + lastCollateralError_Redistribution;\\r\\n        uint256 THUSDDebtNumerator = _debt * DECIMAL_PRECISION + lastTHUSDDebtError_Redistribution;\\r\\n\\r\\n        // Get the per-unit-staked terms\\r\\n        uint256 collateralRewardPerUnitStaked = collateralNumerator / totalStakes;\\r\\n        uint256 THUSDDebtRewardPerUnitStaked = THUSDDebtNumerator / totalStakes;\\r\\n\\r\\n        lastCollateralError_Redistribution = collateralNumerator - (collateralRewardPerUnitStaked * totalStakes);\\r\\n        lastTHUSDDebtError_Redistribution = THUSDDebtNumerator - (THUSDDebtRewardPerUnitStaked * totalStakes);\\r\\n\\r\\n        // Add per-unit-staked terms to the running totals\\r\\n        L_Collateral += collateralRewardPerUnitStaked;\\r\\n        L_THUSDDebt += THUSDDebtRewardPerUnitStaked;\\r\\n\\r\\n        emit LTermsUpdated(L_Collateral, L_THUSDDebt);\\r\\n\\r\\n        // Transfer coll and debt from ActivePool to DefaultPool\\r\\n        _activePool.decreaseTHUSDDebt(_debt);\\r\\n        _defaultPool.increaseTHUSDDebt(_debt);\\r\\n        _activePool.sendCollateral(address(_defaultPool), _coll);\\r\\n    }\\r\\n\\r\\n    function closeTrove(address _borrower) external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        return _closeTrove(_borrower, Status.closedByOwner);\\r\\n    }\\r\\n\\r\\n    function _closeTrove(address _borrower, Status closedStatus) internal {\\r\\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\\r\\n\\r\\n        uint256 TroveOwnersArrayLength = TroveOwners.length;\\r\\n        if (thusdToken.mintList(borrowerOperationsAddress)) {\\r\\n          _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\\r\\n        }\\r\\n\\r\\n        Troves[_borrower].status = closedStatus;\\r\\n        Troves[_borrower].coll = 0;\\r\\n        Troves[_borrower].debt = 0;\\r\\n\\r\\n        rewardSnapshots[_borrower].collateral = 0;\\r\\n        rewardSnapshots[_borrower].THUSDDebt = 0;\\r\\n\\r\\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\\r\\n        sortedTroves.remove(_borrower);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\\r\\n    * Used in a liquidation sequence.\\r\\n    *\\r\\n    * The calculation excludes a portion of collateral that is in the ActivePool:\\r\\n    *\\r\\n    * the total collateral gas compensation from the liquidation sequence\\r\\n    *\\r\\n    * The collateral as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\\r\\n    */\\r\\n    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {\\r\\n        totalStakesSnapshot = totalStakes;\\r\\n\\r\\n        uint256 activeColl = _activePool.getCollateralBalance();\\r\\n        uint256 liquidatedColl = defaultPool.getCollateralBalance();\\r\\n        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\\r\\n\\r\\n        emit SystemSnapshotsUpdated(totalStakesSnapshot, totalCollateralSnapshot);\\r\\n    }\\r\\n\\r\\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\\r\\n    function addTroveOwnerToArray(address _borrower) external override returns (uint256 index) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        return _addTroveOwnerToArray(_borrower);\\r\\n    }\\r\\n\\r\\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\\r\\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum THUSD\\r\\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 THUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\\r\\n\\r\\n        // Push the Troveowner to the array\\r\\n        TroveOwners.push(_borrower);\\r\\n\\r\\n        // Record the index of the new Troveowner on their Trove struct\\r\\n        index = uint128(TroveOwners.length - 1);\\r\\n        Troves[_borrower].arrayIndex = index;\\r\\n\\r\\n        return index;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\\r\\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\\r\\n    */\\r\\n    function _removeTroveOwner(address _borrower, uint256 TroveOwnersArrayLength) internal {\\r\\n        Status troveStatus = Troves[_borrower].status;\\r\\n        // It\u2019s set in caller function `_closeTrove`\\r\\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\\r\\n\\r\\n        uint128 index = Troves[_borrower].arrayIndex;\\r\\n        uint256 length = TroveOwnersArrayLength;\\r\\n        uint256 idxLast = length - 1;\\r\\n\\r\\n        assert(index <= idxLast);\\r\\n\\r\\n        address addressToMove = TroveOwners[idxLast];\\r\\n\\r\\n        TroveOwners[index] = addressToMove;\\r\\n        Troves[addressToMove].arrayIndex = index;\\r\\n        emit TroveIndexUpdated(addressToMove, index);\\r\\n\\r\\n        TroveOwners.pop();\\r\\n    }\\r\\n\\r\\n    // --- Recovery Mode and TCR functions ---\\r\\n\\r\\n    function getTCR(uint256 _price) external view override returns (uint) {\\r\\n        return _getTCR(_price);\\r\\n    }\\r\\n\\r\\n    function checkRecoveryMode(uint256 _price) external view override returns (bool) {\\r\\n        return _checkRecoveryMode(_price);\\r\\n    }\\r\\n\\r\\n    // Check whether or not the system *would be* in Recovery Mode, given an collateral:USD price, and the entire system coll and debt.\\r\\n    function _checkPotentialRecoveryMode(\\r\\n        uint256 _entireSystemColl,\\r\\n        uint256 _entireSystemDebt,\\r\\n        uint256 _price\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n    returns (bool)\\r\\n    {\\r\\n        uint256 TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\\r\\n\\r\\n        return TCR < CCR;\\r\\n    }\\r\\n\\r\\n    // --- Redemption fee functions ---\\r\\n\\r\\n    /*\\r\\n    * This function has two impacts on the baseRate state variable:\\r\\n    * 1) decays the baseRate based on time passed since last redemption or THUSD borrowing operation.\\r\\n    * then,\\r\\n    * 2) increases the baseRate based on the amount redeemed, as a proportion of total debt\\r\\n    */\\r\\n    function _updateBaseRateFromRedemption(uint256 _collateralDrawn,  uint256 _price, uint256 _totalTHUSDDebt) internal returns (uint) {\\r\\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\\r\\n\\r\\n        /* Convert the drawn collateral back to THUSD at face value rate (1 THUSD:1 USD), in order to get\\r\\n        * the fraction of total supply that was redeemed at face value. */\\r\\n        uint256 redeemedTHUSDFraction = _collateralDrawn * _price / _totalTHUSDDebt;\\r\\n\\r\\n        uint256 newBaseRate = decayedBaseRate + (redeemedTHUSDFraction / BETA);\\r\\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\\r\\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\\r\\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\\r\\n\\r\\n        // Update the baseRate state variable\\r\\n        baseRate = newBaseRate;\\r\\n        emit BaseRateUpdated(newBaseRate);\\r\\n\\r\\n        _updateLastFeeOpTime();\\r\\n\\r\\n        return newBaseRate;\\r\\n    }\\r\\n\\r\\n    function getRedemptionRate() public view override returns (uint) {\\r\\n        return _calcRedemptionRate(baseRate);\\r\\n    }\\r\\n\\r\\n    function getRedemptionRateWithDecay() public view override returns (uint) {\\r\\n        return _calcRedemptionRate(_calcDecayedBaseRate());\\r\\n    }\\r\\n\\r\\n    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint) {\\r\\n        return LiquityMath._min(\\r\\n            REDEMPTION_FEE_FLOOR + _baseRate,\\r\\n            DECIMAL_PRECISION // cap at a maximum of 100%\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _getRedemptionFee(uint256 _collateralDrawn) internal view returns (uint) {\\r\\n        return _calcRedemptionFee(getRedemptionRate(), _collateralDrawn);\\r\\n    }\\r\\n\\r\\n    function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view override returns (uint) {\\r\\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _collateralDrawn);\\r\\n    }\\r\\n\\r\\n    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _collateralDrawn) internal pure returns (uint) {\\r\\n        uint256 redemptionFee = _redemptionRate * _collateralDrawn / DECIMAL_PRECISION;\\r\\n        require(redemptionFee < _collateralDrawn, \\\"TroveManager: Fee would eat up all returned collateral\\\");\\r\\n        return redemptionFee;\\r\\n    }\\r\\n\\r\\n    // --- Borrowing fee functions ---\\r\\n\\r\\n    function getBorrowingRate() public view override returns (uint) {\\r\\n        return _calcBorrowingRate(baseRate);\\r\\n    }\\r\\n\\r\\n    function getBorrowingRateWithDecay() public view override returns (uint) {\\r\\n        return _calcBorrowingRate(_calcDecayedBaseRate());\\r\\n    }\\r\\n\\r\\n    function _calcBorrowingRate(uint256 _baseRate) internal pure returns (uint) {\\r\\n        return LiquityMath._min(\\r\\n            BORROWING_FEE_FLOOR + _baseRate,\\r\\n            MAX_BORROWING_FEE\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getBorrowingFee(uint256 _THUSDDebt) external view override returns (uint) {\\r\\n        return _calcBorrowingFee(getBorrowingRate(), _THUSDDebt);\\r\\n    }\\r\\n\\r\\n    function getBorrowingFeeWithDecay(uint256 _THUSDDebt) external view override returns (uint) {\\r\\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _THUSDDebt);\\r\\n    }\\r\\n\\r\\n    function _calcBorrowingFee(uint256 _borrowingRate, uint256 _THUSDDebt) internal pure returns (uint) {\\r\\n        return _borrowingRate * _THUSDDebt / DECIMAL_PRECISION;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Updates the baseRate state variable based on time elapsed since the last redemption or THUSD borrowing operation.\\r\\n    function decayBaseRateFromBorrowing() external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n\\r\\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\\r\\n        assert(decayedBaseRate <= DECIMAL_PRECISION);  // The baseRate can decay to 0\\r\\n\\r\\n        baseRate = decayedBaseRate;\\r\\n        emit BaseRateUpdated(decayedBaseRate);\\r\\n\\r\\n        _updateLastFeeOpTime();\\r\\n    }\\r\\n\\r\\n    // --- Internal fee functions ---\\r\\n\\r\\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\\r\\n    function _updateLastFeeOpTime() internal {\\r\\n        uint256 timePassed = block.timestamp - lastFeeOperationTime;\\r\\n\\r\\n        if (timePassed >= 1 minutes) {\\r\\n            lastFeeOperationTime = block.timestamp;\\r\\n            emit LastFeeOpTimeUpdated(block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _calcDecayedBaseRate() internal view returns (uint) {\\r\\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\\r\\n        uint256 decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\\r\\n\\r\\n        return baseRate * decayFactor / DECIMAL_PRECISION;\\r\\n    }\\r\\n\\r\\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\\r\\n        return (block.timestamp - lastFeeOperationTime) / 1 minutes;\\r\\n    }\\r\\n\\r\\n    // --- 'require' wrapper functions ---\\r\\n\\r\\n    function _requireCallerIsBorrowerOperations() internal view {\\r\\n        require(msg.sender == borrowerOperationsAddress, \\\"TroveManager: Caller is not the BorrowerOperations contract\\\");\\r\\n    }\\r\\n\\r\\n    function _requireTroveIsActive(address _borrower) internal view {\\r\\n        require(Troves[_borrower].status == Status.active, \\\"TroveManager: Trove does not exist or is closed\\\");\\r\\n    }\\r\\n\\r\\n    function _requireTHUSDBalanceCoversRedemption(ITHUSDToken _thusdToken, address _redeemer, uint256 _amount) internal view {\\r\\n        require(_thusdToken.balanceOf(_redeemer) >= _amount, \\\"TroveManager: Requested redemption amount must be <= user's THUSD token balance\\\");\\r\\n    }\\r\\n\\r\\n    function _requireMoreThanOneTroveInSystem(uint256 TroveOwnersArrayLength) internal view {\\r\\n        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, \\\"TroveManager: Only one trove in the system\\\");\\r\\n    }\\r\\n\\r\\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\\r\\n        require(_amount > 0, \\\"TroveManager: Amount must be greater than zero\\\");\\r\\n    }\\r\\n\\r\\n    function _requireTCRoverMCR(uint256 _price) internal view {\\r\\n        require(_getTCR(_price) >= MCR, \\\"TroveManager: Cannot redeem when TCR < MCR\\\");\\r\\n    }\\r\\n\\r\\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\\r\\n        require(_maxFeePercentage >= REDEMPTION_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\\r\\n            \\\"Max fee percentage must be between 0.5% and 100%\\\");\\r\\n    }\\r\\n\\r\\n    // --- Trove property getters ---\\r\\n\\r\\n    function getTroveStatus(address _borrower) external view override returns (Status) {\\r\\n        return Troves[_borrower].status;\\r\\n    }\\r\\n\\r\\n    function getTroveStake(address _borrower) external view override returns (uint) {\\r\\n        return Troves[_borrower].stake;\\r\\n    }\\r\\n\\r\\n    function getTroveDebt(address _borrower) external view override returns (uint) {\\r\\n        return Troves[_borrower].debt;\\r\\n    }\\r\\n\\r\\n    function getTroveColl(address _borrower) external view override returns (uint) {\\r\\n        return Troves[_borrower].coll;\\r\\n    }\\r\\n\\r\\n    // --- Trove property setters, called by BorrowerOperations ---\\r\\n\\r\\n    function setTroveStatus(address _borrower, Status _status) external override {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        Troves[_borrower].status = _status;\\r\\n    }\\r\\n\\r\\n    function increaseTroveColl(address _borrower, uint256 _collIncrease) external override returns (uint) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        uint256 newColl = Troves[_borrower].coll + _collIncrease;\\r\\n        Troves[_borrower].coll = newColl;\\r\\n        return newColl;\\r\\n    }\\r\\n\\r\\n    function decreaseTroveColl(address _borrower, uint256 _collDecrease) external override returns (uint) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        uint256 newColl = Troves[_borrower].coll - _collDecrease;\\r\\n        Troves[_borrower].coll = newColl;\\r\\n        return newColl;\\r\\n    }\\r\\n\\r\\n    function increaseTroveDebt(address _borrower, uint256 _debtIncrease) external override returns (uint) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        uint256 newDebt = Troves[_borrower].debt + _debtIncrease;\\r\\n        Troves[_borrower].debt = newDebt;\\r\\n        return newDebt;\\r\\n    }\\r\\n\\r\\n    function decreaseTroveDebt(address _borrower, uint256 _debtDecrease) external override returns (uint) {\\r\\n        _requireCallerIsBorrowerOperations();\\r\\n        uint256 newDebt = Troves[_borrower].debt - _debtDecrease;\\r\\n        Troves[_borrower].debt = newDebt;\\r\\n        return newDebt;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"contract ISortedTroves\",\"name\":\"_sortedTroves\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_startIdx\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getMultipleSortedTroves\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"snapshotTHUSDDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiTroveGetter.CombinedTroveData[]\",\"name\":\"_troves\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract TroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiTroveGetter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000e103c279f1c1693914890c4fcf269c917bf3e5590000000000000000000000009f1040ff6adc3f484af4c140b4da398aa28d3a32", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}