{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Proxy.sol\": {\r\n      \"content\": \"// hevm: flattened sources of contracts/Proxy.sol\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.7 <0.9.0;\\n\\n////// contracts/SlotManipulatable.sol\\n/* pragma solidity ^0.8.7; */\\n\\nabstract contract SlotManipulatable {\\n\\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\\n        return keccak256(abi.encodePacked(key_, slot_));\\n    }\\n\\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\\n        assembly {\\n            value_ := sload(slot_)\\n        }\\n    }\\n\\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\\n        assembly {\\n            sstore(slot_, value_)\\n        }\\n    }\\n\\n}\\n\\n////// contracts/interfaces/IDefaultImplementationBeacon.sol\\n/* pragma solidity ^0.8.7; */\\n\\n/// @title An beacon that provides a default implementation for proxies, must implement IDefaultImplementationBeacon.\\ninterface IDefaultImplementationBeacon {\\n\\n    /// @dev The address of an implementation for proxies.\\n    function defaultImplementation() external view returns (address defaultImplementation_);\\n\\n}\\n\\n////// contracts/Proxy.sol\\n/* pragma solidity ^0.8.7; */\\n\\n/* import { IDefaultImplementationBeacon } from \\\"./interfaces/IDefaultImplementationBeacon.sol\\\"; */\\n\\n/* import { SlotManipulatable } from \\\"./SlotManipulatable.sol\\\"; */\\n\\n/// @title A completely transparent, and thus interface-less, proxy contract.\\ncontract Proxy is SlotManipulatable {\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\\n\\n    /**\\n     *  @dev   The constructor requires at least one of `factory_` or `implementation_`.\\n     *         If an implementation is not provided, the factory is treated as an IDefaultImplementationBeacon to fetch the default implementation.\\n     *  @param factory_        The address of a proxy factory, if any.\\n     *  @param implementation_ The address of the implementation contract being proxied, if any.\\n     */\\n    constructor(address factory_, address implementation_) {\\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\\n\\n        // If the implementation is empty, fetch it from the factory, which can act as a beacon.\\n        address implementation = implementation_ == address(0) ? IDefaultImplementationBeacon(factory_).defaultImplementation() : implementation_;\\n\\n        require(implementation != address(0));\\n\\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation))));\\n    }\\n\\n    fallback() payable external virtual {\\n        bytes32 implementation = _getSlotValue(IMPLEMENTATION_SLOT);\\n\\n        require(address(uint160(uint256(implementation))).code.length != uint256(0));\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000036a7350309b2eb30f3b908ab0154851b5ed81db00000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "1", "Implementation": "0x98b7893c5717af41d3e351c6e3445be02a062a90", "SwarmSource": "none://none"}