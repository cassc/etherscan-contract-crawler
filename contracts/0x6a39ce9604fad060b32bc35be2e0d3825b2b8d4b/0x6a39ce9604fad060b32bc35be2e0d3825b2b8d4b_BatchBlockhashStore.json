{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/dev/BatchBlockhashStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/**\\n * @title BatchBlockhashStore\\n * @notice The BatchBlockhashStore contract acts as a proxy to write many blockhashes to the\\n *   provided BlockhashStore contract efficiently in a single transaction. This results\\n *   in plenty of gas savings and higher throughput of blockhash storage, which is desirable\\n *   in times of high network congestion.\\n */\\ncontract BatchBlockhashStore {\\n  BlockhashStore public immutable BHS;\\n\\n  constructor(address blockhashStoreAddr) {\\n    BHS = BlockhashStore(blockhashStoreAddr);\\n  }\\n\\n  /**\\n   * @notice stores blockhashes of the given block numbers in the configured blockhash store, assuming\\n   *   they are availble though the blockhash() instruction.\\n   * @param blockNumbers the block numbers to store the blockhashes of. Must be available via the\\n   *   blockhash() instruction, otherwise this function call will revert.\\n   */\\n  function store(uint256[] memory blockNumbers) public {\\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\\n      // skip the block if it's not storeable, the caller will have to check\\n      // after the transaction is mined to see if the blockhash was truly stored.\\n      if (!storeableBlock(blockNumbers[i])) {\\n        continue;\\n      }\\n      BHS.store(blockNumbers[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice stores blockhashes after verifying blockheader of child/subsequent block\\n   * @param blockNumbers the block numbers whose blockhashes should be stored, in decreasing order\\n   * @param headers the rlp-encoded block headers of blockNumbers[i] + 1.\\n   */\\n  function storeVerifyHeader(uint256[] memory blockNumbers, bytes[] memory headers) public {\\n    require(blockNumbers.length == headers.length, \\\"input array arg lengths mismatch\\\");\\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\\n      BHS.storeVerifyHeader(blockNumbers[i], headers[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice retrieves blockhashes of all the given block numbers from the blockhash store, if available.\\n   * @param blockNumbers array of block numbers to fetch blockhashes for\\n   * @return blockhashes array of block hashes corresponding to each block number provided in the `blockNumbers`\\n   *   param. If the blockhash is not found, 0x0 is returned instead of the real blockhash, indicating\\n   *   that it is not in the blockhash store.\\n   */\\n  function getBlockhashes(uint256[] memory blockNumbers) external view returns (bytes32[] memory) {\\n    bytes32[] memory blockHashes = new bytes32[](blockNumbers.length);\\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\\n      try BHS.getBlockhash(blockNumbers[i]) returns (bytes32 bh) {\\n        blockHashes[i] = bh;\\n      } catch Error(\\n        string memory /* reason */\\n      ) {\\n        blockHashes[i] = 0x0;\\n      }\\n    }\\n    return blockHashes;\\n  }\\n\\n  /**\\n   * @notice returns true if and only if the given block number's blockhash can be retrieved\\n   *   using the blockhash() instruction.\\n   * @param blockNumber the block number to check if it's storeable with blockhash()\\n   */\\n  function storeableBlock(uint256 blockNumber) private view returns (bool) {\\n    // handle edge case on simulated chains which possibly have < 256 blocks total.\\n    return block.number <= 256 ? true : blockNumber >= (block.number - 256);\\n  }\\n}\\n\\ninterface BlockhashStore {\\n  function storeVerifyHeader(uint256 n, bytes memory header) external;\\n\\n  function store(uint256 n) external;\\n\\n  function getBlockhash(uint256 n) external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blockhashStoreAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BHS\",\"outputs\":[{\"internalType\":\"contract BlockhashStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockNumbers\",\"type\":\"uint256[]\"}],\"name\":\"getBlockhashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockNumbers\",\"type\":\"uint256[]\"}],\"name\":\"store\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockNumbers\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"headers\",\"type\":\"bytes[]\"}],\"name\":\"storeVerifyHeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BatchBlockhashStore", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000aa25602bccf3bbde8e2f0f09f3a1f6def54593c0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}