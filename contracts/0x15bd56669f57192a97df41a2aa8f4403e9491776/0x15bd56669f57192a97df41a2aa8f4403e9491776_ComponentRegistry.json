{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ComponentRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./UnitRegistry.sol\\\";\\n\\n/// @title Component Registry - Smart contract for registering components\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\ncontract ComponentRegistry is UnitRegistry {\\n    // Component registry version number\\n    string public constant VERSION = \\\"1.0.0\\\";\\n\\n    /// @dev Component registry constructor.\\n    /// @param _name Component registry contract name.\\n    /// @param _symbol Component registry contract symbol.\\n    /// @param _baseURI Component registry token base URI.\\n    constructor(string memory _name, string memory _symbol, string memory _baseURI)\\n        UnitRegistry(UnitType.Component)\\n        ERC721(_name, _symbol)\\n    {\\n        baseURI = _baseURI;\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Checks provided component dependencies.\\n    /// @param dependencies Set of component dependencies.\\n    /// @param maxComponentId Maximum component Id.\\n    function _checkDependencies(uint32[] memory dependencies, uint32 maxComponentId) internal virtual override {\\n        uint32 lastId;\\n        for (uint256 iDep = 0; iDep < dependencies.length; ++iDep) {\\n            if (dependencies[iDep] < (lastId + 1) || dependencies[iDep] > maxComponentId) {\\n                revert ComponentNotFound(dependencies[iDep]);\\n            }\\n            lastId = dependencies[iDep];\\n        }\\n    }\\n\\n    /// @dev Gets subcomponents of a provided component Id.\\n    /// @notice For components this means getting the linearized map of components from the local map of subcomponents.\\n    /// @param componentId Component Id.\\n    /// @return subComponentIds Set of subcomponents.\\n    function _getSubComponents(UnitType, uint32 componentId) internal view virtual override\\n        returns (uint32[] memory subComponentIds)\\n    {\\n        subComponentIds = mapSubComponents[uint256(componentId)];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UnitRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./GenericRegistry.sol\\\";\\n\\n/// @title Unit Registry - Smart contract for registering generalized units / units\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\nabstract contract UnitRegistry is GenericRegistry {\\n    event CreateUnit(uint256 unitId, UnitType uType, bytes32 unitHash);\\n    event UpdateUnitHash(uint256 unitId, UnitType uType, bytes32 unitHash);\\n\\n    enum UnitType {\\n        Component,\\n        Agent\\n    }\\n\\n    // Unit parameters\\n    struct Unit {\\n        // Primary IPFS hash of the unit\\n        bytes32 unitHash;\\n        // Set of component dependencies (agents are also based on components)\\n        // We assume that the system is expected to support no more than 2^32-1 components\\n        uint32[] dependencies;\\n    }\\n\\n    // Type of the unit: component or unit\\n    UnitType public immutable unitType;\\n    // Map of unit Id => set of updated IPFS hashes\\n    mapping(uint256 => bytes32[]) public mapUnitIdHashes;\\n    // Map of unit Id => set of subcomponents (possible to derive from any registry)\\n    mapping(uint256 => uint32[]) public mapSubComponents;\\n    // Map of unit Id => unit\\n    mapping(uint256 => Unit) public mapUnits;\\n\\n    constructor(UnitType _unitType) {\\n        unitType = _unitType;\\n    }\\n\\n    /// @dev Checks the provided component dependencies.\\n    /// @param dependencies Set of component dependencies.\\n    /// @param maxUnitId Maximum unit Id.\\n    function _checkDependencies(uint32[] memory dependencies, uint32 maxUnitId) internal virtual;\\n\\n    /// @dev Creates unit.\\n    /// @param unitOwner Owner of the unit.\\n    /// @param unitHash IPFS CID hash of the unit.\\n    /// @param dependencies Set of unit dependencies in a sorted ascending order (unit Ids).\\n    /// @return unitId The id of a minted unit.\\n    function create(address unitOwner, bytes32 unitHash, uint32[] memory dependencies)\\n        external virtual returns (uint256 unitId)\\n    {\\n        // Reentrancy guard\\n        if (_locked > 1) {\\n            revert ReentrancyGuard();\\n        }\\n        _locked = 2;\\n\\n        // Check for the manager privilege for a unit creation\\n        if (manager != msg.sender) {\\n            revert ManagerOnly(msg.sender, manager);\\n        }\\n\\n        // Checks for a non-zero owner address\\n        if(unitOwner == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        // Check for the non-zero hash value\\n        if (unitHash == 0) {\\n            revert ZeroValue();\\n        }\\n        \\n        // Check for dependencies validity: must be already allocated, must not repeat\\n        unitId = totalSupply;\\n        _checkDependencies(dependencies, uint32(unitId));\\n\\n        // Unit with Id = 0 is left empty not to do additional checks for the index zero\\n        unitId++;\\n\\n        // Initialize the unit and mint its token\\n        Unit storage unit = mapUnits[unitId];\\n        unit.unitHash = unitHash;\\n        unit.dependencies = dependencies;\\n\\n        // Update the map of subcomponents with calculated subcomponents for the new unit Id\\n        // In order to get the correct set of subcomponents, we need to differentiate between the callers of this function\\n        // Self contract (unit registry) can only call subcomponents calculation from the component level\\n        uint32[] memory subComponentIds = _calculateSubComponents(UnitType.Component, dependencies);\\n        // We need to add a current component Id to the set of subcomponents if the unit is a component\\n        // For example, if component 3 (c3) has dependencies of [c1, c2], then the subcomponents will return [c1, c2].\\n        // The resulting set will be [c1, c2, c3]. So we write into the map of component subcomponents: c3=>[c1, c2, c3].\\n        // This is done such that the subcomponents start getting explored, and when the agent calls its subcomponents,\\n        // it would have [c1, c2, c3] right away instead of adding c3 manually and then (for services) checking\\n        // if another agent also has c3 as a component dependency. The latter will consume additional computation.\\n        if (unitType == UnitType.Component) {\\n            uint256 numSubComponents = subComponentIds.length;\\n            uint32[] memory addSubComponentIds = new uint32[](numSubComponents + 1);\\n            for (uint256 i = 0; i < numSubComponents; ++i) {\\n                addSubComponentIds[i] = subComponentIds[i];\\n            }\\n            // Adding self component Id\\n            addSubComponentIds[numSubComponents] = uint32(unitId);\\n            subComponentIds = addSubComponentIds;\\n        }\\n        mapSubComponents[unitId] = subComponentIds;\\n\\n        // Set total supply to the unit Id number\\n        totalSupply = unitId;\\n        // Safe mint is needed since contracts can create units as well\\n        _safeMint(unitOwner, unitId);\\n\\n        emit CreateUnit(unitId, unitType, unitHash);\\n        _locked = 1;\\n    }\\n\\n    /// @dev Updates the unit hash.\\n    /// @param unitOwner Owner of the unit.\\n    /// @param unitId Unit Id.\\n    /// @param unitHash Updated IPFS hash of the unit.\\n    /// @return success True, if function executed successfully.\\n    function updateHash(address unitOwner, uint256 unitId, bytes32 unitHash) external virtual\\n        returns (bool success)\\n    {\\n        // Check the manager privilege for a unit modification\\n        if (manager != msg.sender) {\\n            revert ManagerOnly(msg.sender, manager);\\n        }\\n\\n        // Checking the unit ownership\\n        if (ownerOf(unitId) != unitOwner) {\\n            if (unitType == UnitType.Component) {\\n                revert ComponentNotFound(unitId);\\n            } else {\\n                revert AgentNotFound(unitId);\\n            }\\n        }\\n\\n        // Check for the hash value\\n        if (unitHash == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        mapUnitIdHashes[unitId].push(unitHash);\\n        success = true;\\n\\n        emit UpdateUnitHash(unitId, unitType, unitHash);\\n    }\\n\\n    /// @dev Gets the unit instance.\\n    /// @param unitId Unit Id.\\n    /// @return unit Corresponding Unit struct.\\n    function getUnit(uint256 unitId) external view virtual returns (Unit memory unit) {\\n        unit = mapUnits[unitId];\\n    }\\n\\n    /// @dev Gets unit dependencies.\\n    /// @param unitId Unit Id.\\n    /// @return numDependencies The number of units in the dependency list.\\n    /// @return dependencies The list of unit dependencies.\\n    function getDependencies(uint256 unitId) external view virtual\\n        returns (uint256 numDependencies, uint32[] memory dependencies)\\n    {\\n        Unit memory unit = mapUnits[unitId];\\n        return (unit.dependencies.length, unit.dependencies);\\n    }\\n\\n    /// @dev Gets updated unit hashes.\\n    /// @param unitId Unit Id.\\n    /// @return numHashes Number of hashes.\\n    /// @return unitHashes The list of updated unit hashes (without the primary one).\\n    function getUpdatedHashes(uint256 unitId) external view virtual\\n        returns (uint256 numHashes, bytes32[] memory unitHashes)\\n    {\\n        unitHashes = mapUnitIdHashes[unitId];\\n        return (unitHashes.length, unitHashes);\\n    }\\n\\n    /// @dev Gets the set of subcomponent Ids from a local map of subcomponent.\\n    /// @param unitId Component Id.\\n    /// @return subComponentIds Set of subcomponent Ids.\\n    /// @return numSubComponents Number of subcomponents.\\n    function getLocalSubComponents(uint256 unitId) external view\\n        returns (uint32[] memory subComponentIds, uint256 numSubComponents)\\n    {\\n        subComponentIds = mapSubComponents[uint256(unitId)];\\n        numSubComponents = subComponentIds.length;\\n    }\\n\\n    /// @dev Gets subcomponents of a provided unit Id.\\n    /// @param subcomponentsFromType Type of the unit: component or agent.\\n    /// @param unitId Unit Id.\\n    /// @return subComponentIds Set of subcomponents.\\n    function _getSubComponents(UnitType subcomponentsFromType, uint32 unitId) internal view virtual\\n        returns (uint32[] memory subComponentIds);\\n\\n    /// @dev Calculates the set of subcomponent Ids.\\n    /// @param subcomponentsFromType Type of the unit: component or agent.\\n    /// @param unitIds Unit Ids.\\n    /// @return subComponentIds Subcomponent Ids.\\n    function _calculateSubComponents(UnitType subcomponentsFromType, uint32[] memory unitIds) internal view virtual\\n        returns (uint32[] memory subComponentIds)\\n    {\\n        uint32 numUnits = uint32(unitIds.length);\\n        // Array of numbers of components per each unit Id\\n        uint32[] memory numComponents = new uint32[](numUnits);\\n        // 2D array of all the sets of components per each unit Id\\n        uint32[][] memory components = new uint32[][](numUnits);\\n\\n        // Get total possible number of components and lists of components\\n        uint32 maxNumComponents;\\n        for (uint32 i = 0; i < numUnits; ++i) {\\n            // Get subcomponents for each unit Id based on the subcomponentsFromType\\n            components[i] = _getSubComponents(subcomponentsFromType, unitIds[i]);\\n            numComponents[i] = uint32(components[i].length);\\n            maxNumComponents += numComponents[i];\\n        }\\n\\n        // Lists of components are sorted, take unique values in ascending order\\n        uint32[] memory allComponents = new uint32[](maxNumComponents);\\n        // Processed component counter\\n        uint32[] memory processedComponents = new uint32[](numUnits);\\n        // Minimal component Id\\n        uint32 minComponent;\\n        // Overall component counter\\n        uint32 counter;\\n        // Iterate until we process all components, at the maximum of the sum of all the components in all units\\n        for (counter = 0; counter < maxNumComponents; ++counter) {\\n            // Index of a minimal component\\n            uint32 minIdxComponent;\\n            // Amount of components identified as the next minimal component number\\n            uint32 numComponentsCheck;\\n            uint32 tryMinComponent = type(uint32).max;\\n            // Assemble an array of all first components from each component array\\n            for (uint32 i = 0; i < numUnits; ++i) {\\n                // Either get a component that has a higher id than the last one ore reach the end of the processed Ids\\n                for (; processedComponents[i] < numComponents[i]; ++processedComponents[i]) {\\n                    if (minComponent < components[i][processedComponents[i]]) {\\n                        // Out of those component Ids that are higher than the last one, pick the minimal one\\n                        if (components[i][processedComponents[i]] < tryMinComponent) {\\n                            tryMinComponent = components[i][processedComponents[i]];\\n                            minIdxComponent = i;\\n                        }\\n                        // If we found a minimal component Id, we increase the counter and break to start the search again\\n                        numComponentsCheck++;\\n                        break;\\n                    }\\n                }\\n            }\\n            minComponent = tryMinComponent;\\n\\n            // If minimal component Id is greater than the last one, it should be added, otherwise we reached the end\\n            if (numComponentsCheck > 0) {\\n                allComponents[counter] = minComponent;\\n                processedComponents[minIdxComponent]++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        // Return the exact set of found subcomponents with the counter length\\n        subComponentIds = new uint32[](counter);\\n        for (uint32 i = 0; i < counter; ++i) {\\n            subComponentIds[i] = allComponents[i];\\n        }\\n    }\\n\\n    /// @dev Gets the hash of the unit.\\n    /// @param unitId Unit Id.\\n    /// @return Unit hash.\\n    function _getUnitHash(uint256 unitId) internal view override returns (bytes32) {\\n        return mapUnits[unitId].unitHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GenericRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"../lib/solmate/src/tokens/ERC721.sol\\\";\\nimport \\\"./interfaces/IErrorsRegistries.sol\\\";\\n\\n/// @title Generic Registry - Smart contract for generic registry template\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\nabstract contract GenericRegistry is IErrorsRegistries, ERC721 {\\n    event OwnerUpdated(address indexed owner);\\n    event ManagerUpdated(address indexed manager);\\n    event BaseURIChanged(string baseURI);\\n\\n    // Owner address\\n    address public owner;\\n    // Unit manager\\n    address public manager;\\n    // Base URI\\n    string public baseURI;\\n    // Unit counter\\n    uint256 public totalSupply;\\n    // Reentrancy lock\\n    uint256 internal _locked = 1;\\n    // To better understand the CID anatomy, please refer to: https://proto.school/anatomy-of-a-cid/05\\n    // CID = <multibase_encoding>multibase_encoding(<cid-version><multicodec><multihash-algorithm><multihash-length><multihash-hash>)\\n    // CID prefix = <multibase_encoding>multibase_encoding(<cid-version><multicodec><multihash-algorithm><multihash-length>)\\n    // to complement the multibase_encoding(<multihash-hash>)\\n    // multibase_encoding = base16 = \\\"f\\\"\\n    // cid-version = version 1 = \\\"0x01\\\"\\n    // multicodec = dag-pb = \\\"0x70\\\"\\n    // multihash-algorithm = sha2-256 = \\\"0x12\\\"\\n    // multihash-length = 256 bits = \\\"0x20\\\"\\n    string public constant CID_PREFIX = \\\"f01701220\\\";\\n\\n    /// @dev Changes the owner address.\\n    /// @param newOwner Address of a new owner.\\n    function changeOwner(address newOwner) external virtual {\\n        // Check for the ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Check for the zero address\\n        if (newOwner == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        owner = newOwner;\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    /// @dev Changes the unit manager.\\n    /// @param newManager Address of a new unit manager.\\n    function changeManager(address newManager) external virtual {\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Check for the zero address\\n        if (newManager == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        manager = newManager;\\n        emit ManagerUpdated(newManager);\\n    }\\n\\n    /// @dev Checks for the unit existence.\\n    /// @notice Unit counter starts from 1.\\n    /// @param unitId Unit Id.\\n    /// @return true if the unit exists, false otherwise.\\n    function exists(uint256 unitId) external view virtual returns (bool) {\\n        return unitId > 0 && unitId < (totalSupply + 1);\\n    }\\n    \\n    /// @dev Sets unit base URI.\\n    /// @param bURI Base URI string.\\n    function setBaseURI(string memory bURI) external virtual {\\n        // Check for the ownership\\n        if (msg.sender != owner) {\\n            revert OwnerOnly(msg.sender, owner);\\n        }\\n\\n        // Check for the zero value\\n        if (bytes(bURI).length == 0) {\\n            revert ZeroValue();\\n        }\\n\\n        baseURI = bURI;\\n        emit BaseURIChanged(bURI);\\n    }\\n\\n    /// @dev Gets the valid unit Id from the provided index.\\n    /// @notice Unit counter starts from 1.\\n    /// @param id Unit counter.\\n    /// @return unitId Unit Id.\\n    function tokenByIndex(uint256 id) external view virtual returns (uint256 unitId) {\\n        unitId = id + 1;\\n        if (unitId > totalSupply) {\\n            revert Overflow(unitId, totalSupply);\\n        }\\n    }\\n\\n    // Open sourced from: https://stackoverflow.com/questions/67893318/solidity-how-to-represent-bytes32-as-string\\n    /// @dev Converts bytes16 input data to hex16.\\n    /// @notice This method converts bytes into the same bytes-character hex16 representation.\\n    /// @param data bytes16 input data.\\n    /// @return result hex16 conversion from the input bytes16 data.\\n    function _toHex16(bytes16 data) internal pure returns (bytes32 result) {\\n        result = bytes32 (data) & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 |\\n        (bytes32 (data) & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 64;\\n        result = result & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 |\\n        (result & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >> 32;\\n        result = result & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 |\\n        (result & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >> 16;\\n        result = result & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 |\\n        (result & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >> 8;\\n        result = (result & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >> 4 |\\n        (result & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >> 8;\\n        result = bytes32 (0x3030303030303030303030303030303030303030303030303030303030303030 +\\n        uint256 (result) +\\n            (uint256 (result) + 0x0606060606060606060606060606060606060606060606060606060606060606 >> 4 &\\n            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) * 39);\\n    }\\n\\n    /// @dev Gets the hash of the unit.\\n    /// @param unitId Unit Id.\\n    /// @return Unit hash.\\n    function _getUnitHash(uint256 unitId) internal view virtual returns (bytes32);\\n\\n    /// @dev Returns unit token URI.\\n    /// @notice Expected multicodec: dag-pb; hashing function: sha2-256, with base16 encoding and leading CID_PREFIX removed.\\n    /// @param unitId Unit Id.\\n    /// @return Unit token URI string.\\n    function tokenURI(uint256 unitId) public view virtual override returns (string memory) {\\n        bytes32 unitHash = _getUnitHash(unitId);\\n        // Parse 2 parts of bytes32 into left and right hex16 representation, and concatenate into string\\n        // adding the base URI and a cid prefix for the full base16 multibase prefix IPFS hash representation\\n        return string(abi.encodePacked(baseURI, CID_PREFIX, _toHex16(bytes16(unitHash)),\\n            _toHex16(bytes16(unitHash << 128))));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0)\\n            require(\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                    ERC721TokenReceiver.onERC721Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IErrorsRegistries.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n/// @dev Errors.\\ninterface IErrorsRegistries {\\n    /// @dev Only `manager` has a privilege, but the `sender` was provided.\\n    /// @param sender Sender address.\\n    /// @param manager Required sender address as a manager.\\n    error ManagerOnly(address sender, address manager);\\n\\n    /// @dev Only `owner` has a privilege, but the `sender` was provided.\\n    /// @param sender Sender address.\\n    /// @param owner Required sender address as an owner.\\n    error OwnerOnly(address sender, address owner);\\n\\n    /// @dev Hash already exists in the records.\\n    error HashExists();\\n\\n    /// @dev Provided zero address.\\n    error ZeroAddress();\\n\\n    /// @dev Agent Id is not correctly provided for the current routine.\\n    /// @param agentId Component Id.\\n    error WrongAgentId(uint256 agentId);\\n\\n    /// @dev Wrong length of two arrays.\\n    /// @param numValues1 Number of values in a first array.\\n    /// @param numValues2 Numberf of values in a second array.\\n    error WrongArrayLength(uint256 numValues1, uint256 numValues2);\\n\\n    /// @dev Canonical agent Id is not found.\\n    /// @param agentId Canonical agent Id.\\n    error AgentNotFound(uint256 agentId);\\n\\n    /// @dev Component Id is not found.\\n    /// @param componentId Component Id.\\n    error ComponentNotFound(uint256 componentId);\\n\\n    /// @dev Multisig threshold is out of bounds.\\n    /// @param currentThreshold Current threshold value.\\n    /// @param minThreshold Minimum possible threshold value.\\n    /// @param maxThreshold Maximum possible threshold value.\\n    error WrongThreshold(uint256 currentThreshold, uint256 minThreshold, uint256 maxThreshold);\\n\\n    /// @dev Agent instance is already registered with a specified `operator`.\\n    /// @param operator Operator that registered an instance.\\n    error AgentInstanceRegistered(address operator);\\n\\n    /// @dev Wrong operator is specified when interacting with a specified `serviceId`.\\n    /// @param serviceId Service Id.\\n    error WrongOperator(uint256 serviceId);\\n\\n    /// @dev Operator has no registered instances in the service.\\n    /// @param operator Operator address.\\n    /// @param serviceId Service Id.\\n    error OperatorHasNoInstances(address operator, uint256 serviceId);\\n\\n    /// @dev Canonical `agentId` is not found as a part of `serviceId`.\\n    /// @param agentId Canonical agent Id.\\n    /// @param serviceId Service Id.\\n    error AgentNotInService(uint256 agentId, uint256 serviceId);\\n\\n    /// @dev The contract is paused.\\n    error Paused();\\n\\n    /// @dev Zero value when it has to be different from zero.\\n    error ZeroValue();\\n\\n    /// @dev Value overflow.\\n    /// @param provided Overflow value.\\n    /// @param max Maximum possible value.\\n    error Overflow(uint256 provided, uint256 max);\\n\\n    /// @dev Service must be inactive.\\n    /// @param serviceId Service Id.\\n    error ServiceMustBeInactive(uint256 serviceId);\\n\\n    /// @dev All the agent instance slots for a specific `serviceId` are filled.\\n    /// @param serviceId Service Id.\\n    error AgentInstancesSlotsFilled(uint256 serviceId);\\n\\n    /// @dev Wrong state of a service.\\n    /// @param state Service state.\\n    /// @param serviceId Service Id.\\n    error WrongServiceState(uint256 state, uint256 serviceId);\\n\\n    /// @dev Only own service multisig is allowed.\\n    /// @param provided Provided address.\\n    /// @param expected Expected multisig address.\\n    /// @param serviceId Service Id.\\n    error OnlyOwnServiceMultisig(address provided, address expected, uint256 serviceId);\\n\\n    /// @dev Multisig is not whitelisted.\\n    /// @param multisig Address of a multisig implementation.\\n    error UnauthorizedMultisig(address multisig);\\n\\n    /// @dev Incorrect deposit provided for the registration activation.\\n    /// @param sent Sent amount.\\n    /// @param expected Expected amount.\\n    /// @param serviceId Service Id.\\n    error IncorrectRegistrationDepositValue(uint256 sent, uint256 expected, uint256 serviceId);\\n\\n    /// @dev Insufficient value provided for the agent instance bonding.\\n    /// @param sent Sent amount.\\n    /// @param expected Expected amount.\\n    /// @param serviceId Service Id.\\n    error IncorrectAgentBondingValue(uint256 sent, uint256 expected, uint256 serviceId);\\n\\n    /// @dev Failure of a transfer.\\n    /// @param token Address of a token.\\n    /// @param from Address `from`.\\n    /// @param to Address `to`.\\n    /// @param value Value.\\n    error TransferFailed(address token, address from, address to, uint256 value);\\n\\n    /// @dev Caught reentrancy violation.\\n    error ReentrancyGuard();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 750\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"AgentInstanceRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"AgentInstancesSlotsFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"agentId\",\"type\":\"uint256\"}],\"name\":\"AgentNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"agentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"AgentNotInService\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"componentId\",\"type\":\"uint256\"}],\"name\":\"ComponentNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HashExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"IncorrectAgentBondingValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"IncorrectRegistrationDepositValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"OnlyOwnServiceMultisig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"OperatorHasNoInstances\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"ServiceMustBeInactive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisig\",\"type\":\"address\"}],\"name\":\"UnauthorizedMultisig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"agentId\",\"type\":\"uint256\"}],\"name\":\"WrongAgentId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numValues1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numValues2\",\"type\":\"uint256\"}],\"name\":\"WrongArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"WrongOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"serviceId\",\"type\":\"uint256\"}],\"name\":\"WrongServiceState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxThreshold\",\"type\":\"uint256\"}],\"name\":\"WrongThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum UnitRegistry.UnitType\",\"name\":\"uType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"}],\"name\":\"CreateUnit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"ManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum UnitRegistry.UnitType\",\"name\":\"uType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"}],\"name\":\"UpdateUnitHash\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CID_PREFIX\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unitOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32[]\",\"name\":\"dependencies\",\"type\":\"uint32[]\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getDependencies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numDependencies\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"dependencies\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getLocalSubComponents\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"subComponentIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"numSubComponents\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getUnit\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32[]\",\"name\":\"dependencies\",\"type\":\"uint32[]\"}],\"internalType\":\"struct UnitRegistry.Unit\",\"name\":\"unit\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getUpdatedHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numHashes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"unitHashes\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapSubComponents\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapUnitIdHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapUnits\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unitType\",\"outputs\":[{\"internalType\":\"enum UnitRegistry.UnitType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unitOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unitId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"unitHash\",\"type\":\"bytes32\"}],\"name\":\"updateHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ComponentRegistry", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "750", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000012436f6d706f6e656e74205265676973747279000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000164155544f4e4f4c41532d434f4d504f4e454e542d563100000000000000000000000000000000000000000000000000000000000000000000000000000000002468747470733a2f2f676174657761792e6175746f6e6f6c61732e746563682f697066732f00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}