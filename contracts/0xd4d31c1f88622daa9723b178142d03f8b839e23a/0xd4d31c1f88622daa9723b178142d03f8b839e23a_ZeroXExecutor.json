{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroReceiver {\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n    // @param _srcChainId - the source endpoint identifier\\n    // @param _srcAddress - the source sending contract address from the source chain\\n    // @param _nonce - the ordered message nonce\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/solidity-examples/contracts/interfaces/IStargateReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IStargateReceiver {\\n    function sgReceive(\\n        uint16 _chainId,\\n        bytes memory _srcAddress,\\n        uint256 _nonce,\\n        address _token,\\n        uint256 amountLD,\\n        bytes memory payload\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/solidity-examples/contracts/interfaces/IStargateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\npragma abicoder v2;\\n\\ninterface IStargateRouter {\\n    struct lzTxObj {\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n    }\\n\\n    function addLiquidity(\\n        uint256 _poolId,\\n        uint256 _amountLD,\\n        address _to\\n    ) external;\\n\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable;\\n\\n    function redeemRemote(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        uint256 _minAmountLD,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function instantRedeemLocal(\\n        uint16 _srcPoolId,\\n        uint256 _amountLP,\\n        address _to\\n    ) external returns (uint256);\\n\\n    function redeemLocal(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function sendCredits(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress\\n    ) external payable;\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\n\\ninterface IOwnable is IERC173 {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\\n\\ninterface IOwnableInternal is IERC173Internal {\\n    error Ownable__NotOwner();\\n    error Ownable__NotTransitiveOwner();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IOwnable } from './IOwnable.sol';\\n\\ninterface ISafeOwnable is IOwnable {\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function nomineeOwner() external view returns (address);\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\n\\ninterface ISafeOwnableInternal is IOwnableInternal {\\n    error SafeOwnable__NotNomineeOwner();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { IOwnable } from './IOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173\\n */\\nabstract contract Ownable is IOwnable, OwnableInternal {\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function transferOwnership(address account) public virtual onlyOwner {\\n        _transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173 } from '../../interfaces/IERC173.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal is IOwnableInternal {\\n    using AddressUtils for address;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\\n        _;\\n    }\\n\\n    modifier onlyTransitiveOwner() {\\n        if (msg.sender != _transitiveOwner())\\n            revert Ownable__NotTransitiveOwner();\\n        _;\\n    }\\n\\n    function _owner() internal view virtual returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    function _transitiveOwner() internal view virtual returns (address owner) {\\n        owner = _owner();\\n\\n        while (owner.isContract()) {\\n            try IERC173(owner).owner() returns (address transitiveOwner) {\\n                owner = transitiveOwner;\\n            } catch {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transferOwnership(address account) internal virtual {\\n        _setOwner(account);\\n    }\\n\\n    function _setOwner(address account) internal virtual {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, account);\\n        l.owner = account;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { Ownable } from './Ownable.sol';\\nimport { ISafeOwnable } from './ISafeOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173 with ownership transfer safety check\\n */\\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function nomineeOwner() public view virtual returns (address) {\\n        return _nomineeOwner();\\n    }\\n\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function acceptOwnership() public virtual onlyNomineeOwner {\\n        _acceptOwnership();\\n    }\\n\\n    function _transferOwnership(\\n        address account\\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\\n        super._transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\\n    modifier onlyNomineeOwner() {\\n        if (msg.sender != _nomineeOwner())\\n            revert SafeOwnable__NotNomineeOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function _nomineeOwner() internal view virtual returns (address) {\\n        return SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function _acceptOwnership() internal virtual {\\n        _setOwner(msg.sender);\\n        delete SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @notice set nominee owner, granting permission to call acceptOwnership\\n     */\\n    function _transferOwnership(address account) internal virtual override {\\n        SafeOwnableStorage.layout().nomineeOwner = account;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary SafeOwnableStorage {\\n    struct Layout {\\n        address nomineeOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.SafeOwnable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Map implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableMap {\\n    error EnumerableMap__IndexOutOfBounds();\\n    error EnumerableMap__NonExistentKey();\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct AddressToAddressMap {\\n        Map _inner;\\n    }\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function at(\\n        AddressToAddressMap storage map,\\n        uint256 index\\n    ) internal view returns (address, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n\\n        return (\\n            address(uint160(uint256(key))),\\n            address(uint160(uint256(value)))\\n        );\\n    }\\n\\n    function at(\\n        UintToAddressMap storage map,\\n        uint256 index\\n    ) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function contains(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function contains(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(\\n        AddressToAddressMap storage map\\n    ) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function length(\\n        UintToAddressMap storage map\\n    ) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    function get(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal view returns (address) {\\n        return\\n            address(\\n                uint160(\\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\\n                )\\n            );\\n    }\\n\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function set(\\n        AddressToAddressMap storage map,\\n        address key,\\n        address value\\n    ) internal returns (bool) {\\n        return\\n            _set(\\n                map._inner,\\n                bytes32(uint256(uint160(key))),\\n                bytes32(uint256(uint160(value)))\\n            );\\n    }\\n\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        AddressToAddressMap storage map,\\n        address key\\n    ) internal returns (bool) {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function remove(\\n        UintToAddressMap storage map,\\n        uint256 key\\n    ) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function toArray(\\n        AddressToAddressMap storage map\\n    )\\n        internal\\n        view\\n        returns (address[] memory keysOut, address[] memory valuesOut)\\n    {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new address[](len);\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._key))\\n                );\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function toArray(\\n        UintToAddressMap storage map\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\\n    {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new uint256[](len);\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = uint256(map._inner._entries[i]._key);\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function keys(\\n        AddressToAddressMap storage map\\n    ) internal view returns (address[] memory keysOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._key))\\n                );\\n            }\\n        }\\n    }\\n\\n    function keys(\\n        UintToAddressMap storage map\\n    ) internal view returns (uint256[] memory keysOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        keysOut = new uint256[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                keysOut[i] = uint256(map._inner._entries[i]._key);\\n            }\\n        }\\n    }\\n\\n    function values(\\n        AddressToAddressMap storage map\\n    ) internal view returns (address[] memory valuesOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function values(\\n        UintToAddressMap storage map\\n    ) internal view returns (address[] memory valuesOut) {\\n        uint256 len = map._inner._entries.length;\\n\\n        valuesOut = new address[](len);\\n\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                valuesOut[i] = address(\\n                    uint160(uint256(map._inner._entries[i]._value))\\n                );\\n            }\\n        }\\n    }\\n\\n    function _at(\\n        Map storage map,\\n        uint256 index\\n    ) private view returns (bytes32, bytes32) {\\n        if (index >= map._entries.length)\\n            revert EnumerableMap__IndexOutOfBounds();\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _contains(\\n        Map storage map,\\n        bytes32 key\\n    ) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\\n        unchecked {\\n            return map._entries[keyIndex - 1]._value;\\n        }\\n    }\\n\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            unchecked {\\n                map._entries[keyIndex - 1]._value = value;\\n            }\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) {\\n            unchecked {\\n                MapEntry storage last = map._entries[map._entries.length - 1];\\n\\n                // move last entry to now-vacant index\\n                map._entries[keyIndex - 1] = last;\\n                map._indexes[last._key] = keyIndex;\\n            }\\n\\n            // clear last index\\n            map._entries.pop();\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/data/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165Internal } from './IERC165Internal.sol';\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 is IERC165Internal {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC165Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165Internal } from './IERC165Internal.sol';\\n\\n/**\\n * @title ERC165 interface registration interface\\n */\\ninterface IERC165Internal {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC173Internal } from './IERC173Internal.sol';\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 is IERC173Internal {\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return conrtact owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC173Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC173 interface needed by internal functions\\n */\\ninterface IERC173Internal {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { IERC721Internal } from './IERC721Internal.sol';\\n\\n/**\\n * @title ERC721 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721 is IERC721Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given address\\n     * @return balance quantity of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice query the owner of given token\\n     * @param tokenId token to query\\n     * @return owner token owner\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice grant approval to given account to spend token\\n     * @param operator address to be approved\\n     * @param tokenId token to approve\\n     */\\n    function approve(address operator, uint256 tokenId) external payable;\\n\\n    /**\\n     * @notice get approval status for given token\\n     * @param tokenId token to query\\n     * @return operator address approved to spend token\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) external view returns (address operator);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\\n     * @param operator address to be approved\\n     * @param status approval status\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return status whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Partial ERC721 interface needed by internal functions\\n */\\ninterface IERC721Internal {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed operator,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165Base } from './IERC165Base.sol';\\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n        return _supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\\n    /**\\n     * @notice indicates whether an interface is already supported based on the interfaceId\\n     * @param interfaceId id of interface to check\\n     * @return bool indicating whether interface is supported\\n     */\\n    function _supportsInterface(\\n        bytes4 interfaceId\\n    ) internal view returns (bool) {\\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @notice sets status of interface support\\n     * @param interfaceId id of interface to set status for\\n     * @param status boolean indicating whether interface will be set as supported\\n     */\\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC165BaseStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\n\\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\\n\\ninterface IERC165BaseInternal is IERC165Internal {\\n    error ERC165Base__InvalidInterfaceId();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Diamond proxy introspection interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondReadable {\\n    struct Facet {\\n        address target;\\n        bytes4[] selectors;\\n    }\\n\\n    /**\\n     * @notice get all facets and their selectors\\n     * @return diamondFacets array of structured facet data\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /**\\n     * @notice get all selectors for given facet address\\n     * @param facet address of facet to query\\n     * @return selectors array of function selectors\\n     */\\n    function facetFunctionSelectors(\\n        address facet\\n    ) external view returns (bytes4[] memory selectors);\\n\\n    /**\\n     * @notice get addresses of all facets used by diamond\\n     * @return addresses array of facet addresses\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses);\\n\\n    /**\\n     * @notice get the address of the facet associated with given selector\\n     * @param selector function selector to query\\n     * @return facet facet address (zero address if not found)\\n     */\\n    function facetAddress(\\n        bytes4 selector\\n    ) external view returns (address facet);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IProxy {\\n    error Proxy__ImplementationIsNotContract();\\n\\n    fallback() external payable;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\nimport { IProxy } from './IProxy.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy is IProxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        if (!implementation.isContract())\\n            revert Proxy__ImplementationIsNotContract();\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { PausableInternal } from './PausableInternal.sol';\\n\\n/**\\n * @title Pausable security control module.\\n */\\nabstract contract Pausable is PausableInternal {\\n    function paused() external view virtual returns (bool) {\\n        return _paused();\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/PausableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { PausableStorage } from './PausableStorage.sol';\\n\\n/**\\n * @title Internal functions for Pausable security control module.\\n */\\nabstract contract PausableInternal {\\n    error Pausable__Paused();\\n    error Pausable__NotPaused();\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    modifier whenNotPaused() {\\n        if (_paused()) revert Pausable__Paused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!_paused()) revert Pausable__NotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice query the contracts paused state.\\n     * @return true if paused, false if unpaused.\\n     */\\n    function _paused() internal view virtual returns (bool) {\\n        return PausableStorage.layout().paused;\\n    }\\n\\n    /**\\n     * @notice Triggers paused state, when contract is unpaused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        PausableStorage.layout().paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Triggers unpaused state, when contract is paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        PausableStorage.layout().paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/security/PausableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary PausableStorage {\\n    struct Layout {\\n        bool paused;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Pausable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata is IERC20MetadataInternal {\\n    /**\\n     * @notice return token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice return token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice return token decimals, generally used only for display purposes\\n     * @return token decimals\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC20 metadata internal interface\\n */\\ninterface IERC20MetadataInternal {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\\nimport { IERC721Base } from './IERC721Base.sol';\\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\\n\\n/**\\n * @title Base ERC721 implementation, excluding optional extensions\\n */\\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address) {\\n        return _ownerOf(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address) {\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool) {\\n        return _isApprovedForAll(account, operator);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable {\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable {\\n        _safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external payable {\\n        _safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function approve(address operator, uint256 tokenId) external payable {\\n        _approve(operator, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function setApprovalForAll(address operator, bool status) external {\\n        _setApprovalForAll(operator, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\n\\n/**\\n * @title Base ERC721 internal functions\\n */\\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    function _balanceOf(\\n        address account\\n    ) internal view virtual returns (uint256) {\\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\\n        return ERC721BaseStorage.layout().holderTokens[account].length();\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\\n        return owner;\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\\n    }\\n\\n    function _getApproved(\\n        uint256 tokenId\\n    ) internal view virtual returns (address) {\\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\\n\\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\\n    }\\n\\n    function _isApprovedForAll(\\n        address account,\\n        address operator\\n    ) internal view virtual returns (bool) {\\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\\n    }\\n\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        return (spender == owner ||\\n            _getApproved(tokenId) == spender ||\\n            _isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, '');\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\\n            revert ERC721Base__ERC721ReceiverNotImplemented();\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = _ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[owner].remove(tokenId);\\n        l.tokenOwners.remove(tokenId);\\n\\n        l.tokenApprovals[tokenId] = address(0);\\n\\n        emit Approval(owner, address(0), tokenId);\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        address owner = _ownerOf(tokenId);\\n\\n        if (owner != from) revert ERC721Base__NotTokenOwner();\\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        l.holderTokens[from].remove(tokenId);\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n        l.tokenApprovals[tokenId] = address(0);\\n\\n        emit Approval(owner, address(0), tokenId);\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\\n            revert ERC721Base__NotOwnerOrApproved();\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data))\\n            revert ERC721Base__ERC721ReceiverNotImplemented();\\n    }\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        _safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\\n            revert ERC721Base__NotOwnerOrApproved();\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    function _approve(address operator, uint256 tokenId) internal virtual {\\n        _handleApproveMessageValue(operator, tokenId, msg.value);\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        if (operator == owner) revert ERC721Base__SelfApproval();\\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\\n            revert ERC721Base__NotOwnerOrApproved();\\n\\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\\n        emit Approval(owner, operator, tokenId);\\n    }\\n\\n    function _setApprovalForAll(\\n        address operator,\\n        bool status\\n    ) internal virtual {\\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\\n            operator\\n        ] = status;\\n        emit ApprovalForAll(msg.sender, operator, status);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes memory returnData = to.functionCall(\\n            abi.encodeWithSelector(\\n                IERC721Receiver(to).onERC721Received.selector,\\n                msg.sender,\\n                from,\\n                tokenId,\\n                data\\n            ),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n\\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\\n        return returnValue == type(IERC721Receiver).interfaceId;\\n    }\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\\n     * @param operator beneficiary of approval\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\n\\nlibrary ERC721BaseStorage {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Base');\\n\\n    struct Layout {\\n        EnumerableMap.UintToAddressMap tokenOwners;\\n        mapping(address => EnumerableSet.UintSet) holderTokens;\\n        mapping(uint256 => address) tokenApprovals;\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/IERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\\n\\n/**\\n * @title ERC721 base interface\\n */\\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\\n\\n/**\\n * @title ERC721 base interface\\n */\\ninterface IERC721BaseInternal is IERC721Internal {\\n    error ERC721Base__NotOwnerOrApproved();\\n    error ERC721Base__SelfApproval();\\n    error ERC721Base__BalanceQueryZeroAddress();\\n    error ERC721Base__ERC721ReceiverNotImplemented();\\n    error ERC721Base__InvalidOwner();\\n    error ERC721Base__MintToZeroAddress();\\n    error ERC721Base__NonExistentToken();\\n    error ERC721Base__NotTokenOwner();\\n    error ERC721Base__TokenAlreadyMinted();\\n    error ERC721Base__TransferToZeroAddress();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\\n\\nabstract contract ERC721Enumerable is\\n    IERC721Enumerable,\\n    ERC721EnumerableInternal\\n{\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) public view returns (uint256) {\\n        return _tokenOfOwnerByIndex(owner, index);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        return _tokenByIndex(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\n\\nabstract contract ERC721EnumerableInternal {\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _totalSupply() internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().tokenOwners.length();\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenByIndex(\\n        uint256 index\\n    ) internal view returns (uint256 tokenId) {\\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\ninterface IERC721Enumerable {\\n    /**\\n     * @notice get total token supply\\n     * @return total supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice get token of given owner at given internal storage index\\n     * @param owner token holder to query\\n     * @param index position in owner's token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenOfOwnerByIndex(\\n        address owner,\\n        uint256 index\\n    ) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @notice get token at given internal storage index\\n     * @param index position in global token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenByIndex(\\n        uint256 index\\n    ) external view returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/ISolidStateERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721Base } from './base/IERC721Base.sol';\\nimport { IERC721Enumerable } from './enumerable/IERC721Enumerable.sol';\\nimport { IERC721Metadata } from './metadata/IERC721Metadata.sol';\\n\\ninterface ISolidStateERC721 is IERC721Base, IERC721Enumerable, IERC721Metadata {\\n    error SolidStateERC721__PayableApproveNotSupported();\\n    error SolidStateERC721__PayableTransferNotSupported();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\\nimport { IERC721Metadata } from './IERC721Metadata.sol';\\n\\n/**\\n * @title ERC721 metadata extensions\\n */\\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function name() external view virtual returns (string memory) {\\n        return _name();\\n    }\\n\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function symbol() external view virtual returns (string memory) {\\n        return _symbol();\\n    }\\n\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function tokenURI(\\n        uint256 tokenId\\n    ) external view virtual returns (string memory) {\\n        return _tokenURI(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721MetadataInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from '../../../utils/UintUtils.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\\n\\n/**\\n * @title ERC721Metadata internal functions\\n */\\nabstract contract ERC721MetadataInternal is\\n    IERC721MetadataInternal,\\n    ERC721BaseInternal\\n{\\n    using UintUtils for uint256;\\n\\n    /**\\n     * @notice get token name\\n     * @return token name\\n     */\\n    function _name() internal view virtual returns (string memory) {\\n        return ERC721MetadataStorage.layout().name;\\n    }\\n\\n    /**\\n     * @notice get token symbol\\n     * @return token symbol\\n     */\\n    function _symbol() internal view virtual returns (string memory) {\\n        return ERC721MetadataStorage.layout().symbol;\\n    }\\n\\n    /**\\n     * @notice get generated URI for given token\\n     * @return token URI\\n     */\\n    function _tokenURI(\\n        uint256 tokenId\\n    ) internal view virtual returns (string memory) {\\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\\n\\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\\n\\n        string memory tokenIdURI = l.tokenURIs[tokenId];\\n        string memory baseURI = l.baseURI;\\n\\n        if (bytes(baseURI).length == 0) {\\n            return tokenIdURI;\\n        } else if (bytes(tokenIdURI).length > 0) {\\n            return string(abi.encodePacked(baseURI, tokenIdURI));\\n        } else {\\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\\n        }\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: clear per-token URI data on burn\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (to == address(0)) {\\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC721MetadataStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\\n\\n    struct Layout {\\n        string name;\\n        string symbol;\\n        string baseURI;\\n        mapping(uint256 => string) tokenURIs;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\\n\\n/**\\n * @title ERC721Metadata interface\\n */\\ninterface IERC721Metadata is IERC721MetadataInternal {\\n    /**\\n     * @notice get token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice get token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice get generated URI for given token\\n     * @return token URI\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\\n\\n/**\\n * @title ERC721Metadata internal interface\\n */\\ninterface IERC721MetadataInternal is IERC721BaseInternal {\\n    error ERC721Metadata__NonExistentToken();\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/SolidStateERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\\nimport { ISolidStateERC721 } from './ISolidStateERC721.sol';\\n\\n/**\\n * @title SolidState ERC721 implementation, including recommended extensions\\n */\\nabstract contract SolidStateERC721 is\\n    ISolidStateERC721,\\n    ERC721Base,\\n    ERC721Enumerable,\\n    ERC721Metadata,\\n    ERC165Base\\n{\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external approve function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override {\\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\\n        super._handleApproveMessageValue(operator, tokenId, value);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external transfer function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override {\\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\\n        super._handleTransferMessageValue(from, to, tokenId, value);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { ReentrancyGuardStorage } from './ReentrancyGuardStorage.sol';\\n\\n/**\\n * @title Utility contract for preventing reentrancy attacks\\n */\\nabstract contract ReentrancyGuard {\\n    error ReentrancyGuard__ReentrantCall();\\n\\n    modifier nonReentrant() {\\n        ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage\\n            .layout();\\n        if (l.status == 2) revert ReentrancyGuard__ReentrantCall();\\n        l.status = 2;\\n        _;\\n        l.status = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/ReentrancyGuardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ReentrancyGuardStorage {\\n    struct Layout {\\n        uint256 status;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\nimport { AddressUtils } from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    error SafeERC20__ApproveFromNonZeroToNonZero();\\n    error SafeERC20__DecreaseAllowanceBelowZero();\\n    error SafeERC20__OperationFailed();\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            if (oldAllowance < value)\\n                revert SafeERC20__DecreaseAllowanceBelowZero();\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(\\n                    token.approve.selector,\\n                    spender,\\n                    newAllowance\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n\\n        if (returndata.length > 0) {\\n            if (!abi.decode(returndata, (bool)))\\n                revert SafeERC20__OperationFailed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Accountant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\nimport { AddressUtils } from '@solidstate/contracts/utils/AddressUtils.sol';\\n\\nimport { Registry } from './registry/Registry.sol';\\nimport { VaultBaseExternal } from './vault-base/VaultBaseExternal.sol';\\nimport { IAggregatorV3Interface } from './interfaces/IAggregatorV3Interface.sol';\\nimport { IValioCustomAggregator } from './aggregators/IValioCustomAggregator.sol';\\nimport { IValuer } from './valuers/IValuer.sol';\\n\\nimport { Constants } from './lib/Constants.sol';\\n\\ncontract Accountant {\\n    using AddressUtils for address;\\n\\n    Registry registry;\\n\\n    constructor(address _registry) {\\n        require(_registry != address(0), 'Invalid registry');\\n        registry = Registry(_registry);\\n    }\\n\\n    function isSupportedAsset(address asset) external view returns (bool) {\\n        return registry.valuers(asset) != address(0);\\n    }\\n\\n    function isDeprecated(address asset) external view returns (bool) {\\n        return registry.deprecatedAssets(asset);\\n    }\\n\\n    function getVaultValue(\\n        address vault\\n    ) external view returns (uint minValue, uint maxValue) {\\n        address[] memory activeAssets = VaultBaseExternal(vault)\\n            .assetsWithBalances();\\n        for (uint i = 0; i < activeAssets.length; i++) {\\n            (uint minAssetValue, uint maxAssetValue) = _assetValueOfVault(\\n                activeAssets[i],\\n                vault\\n            );\\n            minValue += minAssetValue;\\n            maxValue += maxAssetValue;\\n        }\\n    }\\n\\n    function assetValueOfVault(\\n        address asset,\\n        address vault\\n    ) external view returns (uint minValue, uint maxValue) {\\n        return _assetValueOfVault(asset, vault);\\n    }\\n\\n    function assetIsActive(\\n        address asset,\\n        address vault\\n    ) external view returns (bool) {\\n        return _assetIsActive(vault, asset);\\n    }\\n\\n    function assetValue(\\n        address asset,\\n        uint amount\\n    ) external view returns (uint minValue, uint maxValue) {\\n        int256 unitPrice = _getUSDPrice(asset);\\n        address valuer = registry.valuers(asset);\\n        require(valuer != address(0), 'No valuer');\\n        return IValuer(valuer).getAssetValue(amount, asset, unitPrice);\\n    }\\n\\n    function assetBreakDownOfVault(\\n        address vault\\n    ) external view returns (IValuer.AssetValue[] memory) {\\n        address[] memory activeAssets = VaultBaseExternal(vault)\\n            .assetsWithBalances();\\n        IValuer.AssetValue[] memory ava = new IValuer.AssetValue[](\\n            activeAssets.length\\n        );\\n        for (uint i = 0; i < activeAssets.length; i++) {\\n            int256 unitPrice = _getUSDPrice(activeAssets[i]);\\n            address valuer = registry.valuers(activeAssets[i]);\\n            require(valuer != address(0), 'No valuer');\\n            ava[i] = IValuer(valuer).getAssetBreakdown(\\n                vault,\\n                activeAssets[i],\\n                unitPrice\\n            );\\n        }\\n        return ava;\\n    }\\n\\n    function _assetValueOfVault(\\n        address asset,\\n        address vault\\n    ) internal view returns (uint minValue, uint maxValue) {\\n        int256 unitPrice = _getUSDPrice(asset);\\n        address valuer = registry.valuers(asset);\\n        require(valuer != address(0), 'No valuer');\\n        return IValuer(valuer).getVaultValue(vault, asset, unitPrice);\\n    }\\n\\n    function _assetIsActive(\\n        address asset,\\n        address vault\\n    ) internal view returns (bool) {\\n        address valuer = registry.valuers(asset);\\n        require(valuer != address(0), 'No valuer');\\n        return IValuer(valuer).getAssetActive(vault, asset);\\n    }\\n\\n    function _getUSDPrice(address asset) internal view returns (int256 price) {\\n        IAggregatorV3Interface chainlinkAggregator = registry\\n            .chainlinkV3USDAggregators(asset);\\n\\n        uint256 updatedAt;\\n        if (address(chainlinkAggregator) != address(0)) {\\n            (, price, , updatedAt, ) = chainlinkAggregator.latestRoundData();\\n        } else {\\n            IValioCustomAggregator valioAggregator = registry\\n                .valioCustomAggregators(asset);\\n            require(\\n                valioAggregator != IValioCustomAggregator(address(0)),\\n                'No aggregator'\\n            );\\n            (price, updatedAt) = valioAggregator.latestRoundData(asset);\\n        }\\n\\n        require(\\n            updatedAt + registry.chainlinkTimeout() >= block.timestamp,\\n            'Price expired'\\n        );\\n\\n        require(price > 0, 'Price not available');\\n\\n        price = price * (int(Constants.VAULT_PRECISION) / 10 ** 8);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/aggregators/IValioCustomAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IValioCustomAggregator {\\n    function description() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function latestRoundData(\\n        address asset\\n    ) external view returns (int256 answer, uint256 updatedAt);\\n}\\n\"\r\n    },\r\n    \"contracts/cpit/CPIT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\nimport { CPITStorage } from './CPITStorage.sol';\\nimport { Constants } from '../lib/Constants.sol';\\n\\ncontract CPIT {\\n    uint256 constant WINDOW_SIZE = 6 hours; // window size for rolling 24 hours\\n    uint256 constant CPIT_LOCK_TIME = 1 days; // Lock time for exceeding the CPIT Threshold\\n\\n    event CPITVaultLocked(uint256 lockedUntil);\\n\\n    modifier isNotCPITLocked() {\\n        require(!_isCpitLocked(), 'CPIT: locked');\\n        _;\\n    }\\n\\n    function _updatePriceImpact(\\n        uint preTransactionValue,\\n        uint postTransactionValue,\\n        uint max24HourCPITBips\\n    ) internal returns (uint priceImpactBips) {\\n        CPITStorage.Layout storage l = CPITStorage.layout();\\n        // calculate price impact in BIPs\\n        priceImpactBips = _calculatePriceImpact(\\n            preTransactionValue,\\n            postTransactionValue\\n        );\\n\\n        if (priceImpactBips == 0) {\\n            return priceImpactBips;\\n        }\\n\\n        uint currentWindow = _getCurrentWindow();\\n\\n        // update priceImpact for current window\\n        l.deviation[currentWindow] += priceImpactBips;\\n\\n        uint cumulativePriceImpact = _calculateCumulativePriceImpact(\\n            currentWindow\\n        );\\n\\n        // check if 24 hour cumulative price impact threshold is exceeded\\n        if (cumulativePriceImpact > max24HourCPITBips) {\\n            revert('price impact exceeded');\\n        }\\n    }\\n\\n    function _cpitLockedUntil() internal view returns (uint256) {\\n        CPITStorage.Layout storage l = CPITStorage.layout();\\n        return l.lockedUntil;\\n    }\\n\\n    function _isCpitLocked() internal view returns (bool) {\\n        return _cpitLockedUntil() > block.timestamp;\\n    }\\n\\n    function _getCurrentCpit() internal view returns (uint256) {\\n        return _calculateCumulativePriceImpact(_getCurrentWindow());\\n    }\\n\\n    function _getCurrentWindow() internal view returns (uint256 currentWindow) {\\n        currentWindow = block.timestamp / WINDOW_SIZE;\\n    }\\n\\n    // calculate the 24 hour cumulative price impact\\n    function _calculateCumulativePriceImpact(\\n        uint currentWindow\\n    ) internal view returns (uint cumulativePriceImpact) {\\n        CPITStorage.Layout storage l = CPITStorage.layout();\\n        uint windowsInDay = 24 hours / WINDOW_SIZE;\\n        uint startWindow = currentWindow - (windowsInDay - 1);\\n        for (uint256 i = startWindow; i <= currentWindow; i++) {\\n            cumulativePriceImpact += l.deviation[i];\\n        }\\n    }\\n\\n    function _calculatePriceImpact(\\n        uint oldValue,\\n        uint newValue\\n    ) internal pure returns (uint priceImpactBips) {\\n        if (newValue >= oldValue) {\\n            return 0;\\n        }\\n        // Calculate the deviation between the old and new values\\n        uint deviation = oldValue - newValue;\\n        // Calculate the impact on price in basis points (BIPs)\\n        priceImpactBips = ((deviation * Constants.BASIS_POINTS_DIVISOR) /\\n            oldValue);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cpit/CPITStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary CPITStorage {\\n    bytes32 internal constant STORAGE_SLOT = keccak256('valio.storage.CPIT');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        uint256 lockedUntil; // timestamp of when vault is locked until\\n        mapping(uint256 => uint) deviation; // deviation for each window\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/executors/IExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { ExecutorIntegration, ExecutorAction, IExecutorEvents } from './IExecutorEvents.sol';\\n\\ninterface IExecutor is IExecutorEvents {}\\n\"\r\n    },\r\n    \"contracts/executors/IExecutorEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nenum ExecutorIntegration {\\n    ZeroX,\\n    GMX\\n}\\n\\nenum ExecutorAction {\\n    Swap,\\n    PerpLongIncrease,\\n    PerpShortIncrease,\\n    PerpLongDecrease,\\n    PerpShortDecrease\\n}\\n\\ninterface IExecutorEvents {\\n    event ExecutedManagerAction(\\n        ExecutorIntegration indexed integration,\\n        ExecutorAction indexed action,\\n        address inputToken,\\n        uint inputTokenAmount,\\n        address outputToken,\\n        uint outputTokenAmount,\\n        uint price\\n    );\\n\\n    event ExecutedCallback(\\n        ExecutorIntegration indexed integration,\\n        ExecutorAction indexed action,\\n        address inputToken,\\n        address outputToken,\\n        bool wasExecuted\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/executors/ZeroXExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport { I0xExchangeRouter } from '../interfaces/I0xExchangeRouter.sol';\\nimport { IExecutor, ExecutorIntegration, ExecutorAction } from '../executors/IExecutor.sol';\\nimport { VaultBaseExternal } from '../vault-base/VaultBaseExternal.sol';\\nimport { Registry } from '../registry/Registry.sol';\\n\\nimport { Call } from '../lib/Call.sol';\\nimport { Constants } from '../lib/Constants.sol';\\n\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\n\\nimport { IERC20Metadata } from '@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol';\\n\\ncontract ZeroXExecutor is IExecutor {\\n    using SafeERC20 for IERC20;\\n\\n    // This function is called by the vault via delegatecall cannot access state of this contract\\n    function swap(\\n        address sellTokenAddress,\\n        uint sellAmount,\\n        address buyTokenAddress,\\n        uint buyAmount,\\n        bytes memory zeroXSwapData\\n    ) external {\\n        Registry registry = VaultBaseExternal(address(this)).registry();\\n        require(\\n            registry.accountant().isDeprecated(buyTokenAddress) == false,\\n            'ZeroXExecutor: OutputToken is deprecated'\\n        );\\n\\n        address _0xExchangeRouter = registry.zeroXExchangeRouter();\\n\\n        IERC20(sellTokenAddress).approve(_0xExchangeRouter, sellAmount);\\n\\n        uint balanceBefore = IERC20(buyTokenAddress).balanceOf(address(this));\\n        // Blindly execute the call to the 0x exchange router\\n        Call._call(_0xExchangeRouter, zeroXSwapData);\\n\\n        uint balanceAfter = IERC20(buyTokenAddress).balanceOf(address(this));\\n        uint amountReceived = balanceAfter - balanceBefore;\\n\\n        require(\\n            amountReceived >= buyAmount,\\n            'ZeroXExecutor: Not enough received'\\n        );\\n\\n        uint unitPrice = _checkSingleSwapPriceImpact(\\n            registry,\\n            sellTokenAddress,\\n            sellAmount,\\n            buyTokenAddress,\\n            amountReceived\\n        );\\n\\n        VaultBaseExternal(address(this)).updateActiveAsset(sellTokenAddress);\\n        VaultBaseExternal(address(this)).addActiveAsset(buyTokenAddress);\\n        registry.emitEvent();\\n        emit ExecutedManagerAction(\\n            ExecutorIntegration.ZeroX,\\n            ExecutorAction.Swap,\\n            sellTokenAddress,\\n            sellAmount,\\n            buyTokenAddress,\\n            amountReceived,\\n            unitPrice\\n        );\\n    }\\n\\n    function _checkSingleSwapPriceImpact(\\n        Registry registry,\\n        address sellTokenAddress,\\n        uint sellAmount,\\n        address buyTokenAddress,\\n        uint buyAmount\\n    ) internal view returns (uint unitPrice) {\\n        uint priceImpactToleranceBasisPoints = registry\\n            .zeroXMaximumSingleSwapPriceImpactBips();\\n\\n        (uint inputValue, ) = registry.accountant().assetValue(\\n            sellTokenAddress,\\n            sellAmount\\n        );\\n\\n        (uint outputValue, ) = registry.accountant().assetValue(\\n            buyTokenAddress,\\n            buyAmount\\n        );\\n\\n        unitPrice = (buyAmount * Constants.VAULT_PRECISION) / sellAmount;\\n\\n        if (outputValue >= inputValue) {\\n            return unitPrice;\\n        }\\n\\n        uint priceImpact = ((inputValue - outputValue) *\\n            Constants.BASIS_POINTS_DIVISOR) / inputValue;\\n\\n        require(\\n            priceImpact <= priceImpactToleranceBasisPoints,\\n            'ZeroXExecutor: Price impact too high'\\n        );\\n\\n        return unitPrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GmxConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\nimport { Accountant } from './Accountant.sol';\\nimport { ITransport } from './transport/ITransport.sol';\\nimport { ExecutorIntegration } from './executors/IExecutor.sol';\\nimport { IntegrationDataTracker } from './integration-data-tracker/IntegrationDataTracker.sol';\\n\\nimport { IGmxRouter } from './interfaces/IGmxRouter.sol';\\nimport { IGmxVault } from './interfaces/IGmxVault.sol';\\nimport { IGmxPositionRouter } from './interfaces/IGmxPositionRouter.sol';\\n\\ncontract GmxConfig {\\n    IGmxRouter public router;\\n    IGmxPositionRouter public positionRouter;\\n    IGmxVault public vault;\\n    bytes32 public referralCode;\\n    uint public maxPositions = 2;\\n    uint public maxOpenRequests = 2; // The number of unexecuted requests a vault can have open at 1 time.\\n    uint public acceptablePriceDeviationBasisPoints = 200; // 2%\\n\\n    constructor(\\n        address _gmxRouter,\\n        address _gmxPositionRouter,\\n        address _gmxVault,\\n        bytes32 _gmxReferralCode\\n    ) {\\n        router = IGmxRouter(_gmxRouter);\\n        positionRouter = IGmxPositionRouter(_gmxPositionRouter);\\n        vault = IGmxVault(_gmxVault);\\n        referralCode = _gmxReferralCode;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/integration-data-tracker/IntegrationDataTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { IntegrationDataTrackerStorage, Integration } from './IntegrationDataTrackerStorage.sol';\\n\\n// This contract is a general store for when we need to store data that is relevant to an integration\\n// For example with GMX we must track what positions are open for each vault\\n\\ncontract IntegrationDataTracker {\\n    /**\\n     * @notice record new raw data\\n     * @param _integration used as the namespace for the data\\n     * @param _data the data track data to be recorded in storage\\n     */\\n    function pushData(Integration _integration, bytes memory _data) external {\\n        _pushData(_integration, msg.sender, _data);\\n    }\\n\\n    /**\\n     * @notice delete data\\n     * @param _integration used as the namespace for the data\\n     * @param _index data index to be removed from storage\\n     */\\n    function removeData(Integration _integration, uint256 _index) external {\\n        _removeData(_integration, msg.sender, _index);\\n    }\\n\\n    /**\\n     * @notice returns tracked data by index\\n     * @param _integration used as the namespace for the data\\n     * @param _vault the vaultAddress\\n     * @param _index the index of data track data\\n     * @return data the data track data of given NFT_TYPE & poolLogic & index\\n     */\\n    function getData(\\n        Integration _integration,\\n        address _vault,\\n        uint256 _index\\n    ) external view returns (bytes memory) {\\n        return\\n            IntegrationDataTrackerStorage.layout().trackedData[_integration][\\n                _vault\\n            ][_index];\\n    }\\n\\n    /**\\n     * @notice returns all tracked datas by NFT_TYPE & poolLogic\\n     * @param _integration used as the namespace for the data\\n     * @param _vault the vaultAddress\\n     * @return data all tracked datas of given NFT_TYPE & poolLogic\\n     */\\n    function getAllData(\\n        Integration _integration,\\n        address _vault\\n    ) public view returns (bytes[] memory) {\\n        return\\n            IntegrationDataTrackerStorage.layout().trackedData[_integration][\\n                _vault\\n            ];\\n    }\\n\\n    /**\\n     * @notice returns all tracked datas by NFT_TYPE & poolLogic\\n     * @param _integration used as the namespace for the data\\n     * @param _vault the vaultAddress\\n     * @return count all tracked datas count of given NFT_TYPE & poolLogic\\n     */\\n    function getDataCount(\\n        Integration _integration,\\n        address _vault\\n    ) public view returns (uint256) {\\n        return\\n            IntegrationDataTrackerStorage\\n            .layout()\\n            .trackedData[_integration][_vault].length;\\n    }\\n\\n    /**\\n     * @notice record new raw data\\n     * @param _integration used as the namespace for the data\\n     * @param _vault the vaultAddress\\n     * @param _data the data track data to be recorded in storage\\n     */\\n    function _pushData(\\n        Integration _integration,\\n        address _vault,\\n        bytes memory _data\\n    ) private {\\n        IntegrationDataTrackerStorage\\n        .layout()\\n        .trackedData[_integration][_vault].push(_data);\\n    }\\n\\n    /**\\n     * @notice delete data\\n     * @param _integration used as the namespace for the data\\n     * @param _vault the vaultAddress\\n     * @param _index data index to be removed from storage\\n     */\\n    function _removeData(\\n        Integration _integration,\\n        address _vault,\\n        uint256 _index\\n    ) private {\\n        IntegrationDataTrackerStorage.Layout\\n            storage l = IntegrationDataTrackerStorage.layout();\\n        uint256 length = l.trackedData[_integration][_vault].length;\\n        require(_index < length, 'invalid index');\\n\\n        l.trackedData[_integration][_vault][_index] = l.trackedData[\\n            _integration\\n        ][_vault][length - 1];\\n        l.trackedData[_integration][_vault].pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/integration-data-tracker/IntegrationDataTrackerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\n// Not sure if we should use an enum here because the integrations are not fixed\\n// We could use a keccak(\\\"IntegrationName\\\") instead, this contract will have to be upgraded if we add a new integration\\n// Because solidity validates enum params at runtime\\nenum Integration {\\n    GMXRequests,\\n    GMXPositions\\n}\\n\\nlibrary IntegrationDataTrackerStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.IntegationDataTracker');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        // used as the namespace for the data -> poolAddress -> data[]\\n        mapping(Integration => mapping(address => bytes[])) trackedData;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/I0xExchangeRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface I0xExchangeRouter {\\n    struct ZeroXTransformation {\\n        // The deployment nonce for the transformer.\\n        // The address of the transformer contract will be derived from this\\n        // value.\\n        uint32 deploymentNonce;\\n        // Arbitrary data to pass to the transformer.\\n        bytes data;\\n    }\\n\\n    function transformERC20(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputTokenAmount,\\n        uint256 minOutputTokenAmount,\\n        ZeroXTransformation[] memory transformations\\n    ) external returns (uint256 outputTokenAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAggregatorV3Interface {\\n    function description() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGmxPositionRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// solhint-disable ordering\\ninterface IGmxPositionRouter {\\n    struct IncreasePositionRequest {\\n        address account;\\n        address[] path;\\n        address indexToken;\\n        uint256 amountIn;\\n        uint256 minOut;\\n        uint256 sizeDelta;\\n        bool isLong;\\n        uint256 acceptablePrice;\\n        uint256 executionFee;\\n        uint256 blockNumber;\\n        uint256 blockTime;\\n        bool hasCollateralInETH;\\n        address callbackTarget;\\n    }\\n\\n    struct DecreasePositionRequest {\\n        address account;\\n        address[] path;\\n        address indexToken;\\n        uint256 collateralDelta;\\n        uint256 sizeDelta;\\n        bool isLong;\\n        address receiver;\\n        uint256 acceptablePrice;\\n        uint256 minOut;\\n        uint256 executionFee;\\n        uint256 blockNumber;\\n        uint256 blockTime;\\n        bool withdrawETH;\\n        address callbackTarget;\\n    }\\n\\n    function setPositionKeeper(address _account, bool _isActive) external;\\n\\n    function executeIncreasePosition(\\n        bytes32 _key,\\n        address payable _executionFeeReceiver\\n    ) external returns (bool);\\n\\n    function executeDecreasePosition(\\n        bytes32 _key,\\n        address payable _executionFeeReceiver\\n    ) external returns (bool);\\n\\n    function createIncreasePosition(\\n        address[] memory _path,\\n        address _indexToken,\\n        uint256 _amountIn,\\n        uint256 _minOut,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        uint256 _acceptablePrice,\\n        uint256 _executionFee,\\n        bytes32 _referralCode,\\n        address _callbackTarget\\n    ) external payable returns (bytes32);\\n\\n    function createDecreasePosition(\\n        address[] memory _path,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver,\\n        uint256 _acceptablePrice,\\n        uint256 _minOut,\\n        uint256 _executionFee,\\n        bool _withdrawETH,\\n        address _callbackTarget\\n    ) external payable returns (bytes32);\\n\\n    function minExecutionFee() external view returns (uint256);\\n\\n    function getRequestKey(\\n        address _account,\\n        uint256 _index\\n    ) external pure returns (bytes32);\\n\\n    function cancelIncreasePosition(\\n        bytes32 _key,\\n        address payable _executionFeeReceiver\\n    ) external returns (bool);\\n\\n    function cancelDecreasePosition(\\n        bytes32 _key,\\n        address payable _executionFeeReceiver\\n    ) external returns (bool);\\n\\n    function executeIncreasePositions(\\n        uint256 _count,\\n        address payable _executionFeeReceiver\\n    ) external;\\n\\n    function executeDecreasePositions(\\n        uint256 _count,\\n        address payable _executionFeeReceiver\\n    ) external;\\n\\n    function increasePositionRequestKeysStart() external view returns (uint256);\\n\\n    function decreasePositionRequestKeysStart() external view returns (uint256);\\n\\n    function increasePositionsIndex(\\n        address account\\n    ) external view returns (uint256);\\n\\n    function increasePositionRequests(\\n        bytes32 key\\n    )\\n        external\\n        view\\n        returns (\\n            address account,\\n            // address[] memory path,\\n            address indexToken,\\n            uint256 amountIn,\\n            uint256 minOut,\\n            uint256 sizeDelta,\\n            bool isLong,\\n            uint256 acceptablePrice,\\n            uint256 executionFee,\\n            uint256 blockNumber,\\n            uint256 blockTime,\\n            bool hasCollateralInETH,\\n            address callbackTarget\\n        );\\n\\n    function getIncreasePositionRequestPath(\\n        bytes32 _key\\n    ) external view returns (address[] memory);\\n\\n    function getDecreasePositionRequestPath(\\n        bytes32 _key\\n    ) external view returns (address[] memory);\\n\\n    function decreasePositionsIndex(\\n        address account\\n    ) external view returns (uint256);\\n\\n    function vault() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function getRequestQueueLengths()\\n        external\\n        view\\n        returns (uint256, uint256, uint256, uint256);\\n\\n    function decreasePositionRequests(\\n        bytes32\\n    )\\n        external\\n        view\\n        returns (\\n            address account,\\n            address indexToken,\\n            uint256 collateralDelta,\\n            uint256 sizeDelta,\\n            bool isLong,\\n            address receiver,\\n            uint256 acceptablePrice,\\n            uint256 minOut,\\n            uint256 executionFee,\\n            uint256 blockNumber,\\n            uint256 blockTime,\\n            bool withdrawETH,\\n            address callbackTarget\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGmxPositionRouterCallbackReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGmxPositionRouterCallbackReceiver {\\n    function gmxPositionCallback(\\n        bytes32 positionKey,\\n        bool isExecuted,\\n        bool isIncrease\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGmxRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGmxRouter {\\n    function addPlugin(address _plugin) external;\\n\\n    function pluginTransfer(\\n        address _token,\\n        address _account,\\n        address _receiver,\\n        uint256 _amount\\n    ) external;\\n\\n    function pluginIncreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _sizeDelta,\\n        bool _isLong\\n    ) external;\\n\\n    function pluginDecreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function swap(\\n        address[] memory _path,\\n        uint256 _amountIn,\\n        uint256 _minOut,\\n        address _receiver\\n    ) external;\\n\\n    function directPoolDeposit(address _token, uint256 _amount) external;\\n\\n    function approvePlugin(address) external;\\n\\n    function decreasePosition(\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver,\\n        uint256 _price\\n    ) external;\\n\\n    function swapETHToTokens(\\n        address[] memory _path,\\n        uint256 _minOut,\\n        address _receiver\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGmxVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n// solhint-disable ordering\\ninterface IGmxVault {\\n    function maxGasPrice() external view returns (uint256);\\n\\n    function approvedRouters(\\n        address _account,\\n        address _router\\n    ) external view returns (bool);\\n\\n    function isLiquidator(address _account) external view returns (bool);\\n\\n    function isManager(address _account) external view returns (bool);\\n\\n    function minProfitBasisPoints(\\n        address _token\\n    ) external view returns (uint256);\\n\\n    function tokenBalances(address _token) external view returns (uint256);\\n\\n    function lastFundingTimes(address _token) external view returns (uint256);\\n\\n    function setLiquidator(address _liquidator, bool _isActive) external;\\n\\n    function setFundingRate(\\n        uint256 _fundingInterval,\\n        uint256 _fundingRateFactor,\\n        uint256 _stableFundingRateFactor\\n    ) external;\\n\\n    function setFees(\\n        uint256 _taxBasisPoints,\\n        uint256 _stableTaxBasisPoints,\\n        uint256 _mintBurnFeeBasisPoints,\\n        uint256 _swapFeeBasisPoints,\\n        uint256 _stableSwapFeeBasisPoints,\\n        uint256 _marginFeeBasisPoints,\\n        uint256 _liquidationFeeUsd,\\n        uint256 _minProfitTime,\\n        bool _hasDynamicFees\\n    ) external;\\n\\n    function setTokenConfig(\\n        address _token,\\n        uint256 _tokenDecimals,\\n        uint256 _redemptionBps,\\n        uint256 _minProfitBps,\\n        uint256 _maxUsdgAmount,\\n        bool _isStable,\\n        bool _isShortable\\n    ) external;\\n\\n    function setPriceFeed(address _aggregatorAddress) external;\\n\\n    function withdrawFees(\\n        address _token,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function directPoolDeposit(address _token) external;\\n\\n    function buyUSDG(\\n        address _token,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function sellUSDG(\\n        address _token,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function swap(\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function increasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _sizeDelta,\\n        bool _isLong\\n    ) external;\\n\\n    function decreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function validateLiquidation(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        bool _raise\\n    ) external view returns (uint256, uint256);\\n\\n    function liquidatePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        address _feeReceiver\\n    ) external;\\n\\n    function tokenToUsdMin(\\n        address _token,\\n        uint256 _tokenAmount\\n    ) external view returns (uint256);\\n\\n    function usdToTokenMax(\\n        address _token,\\n        uint256 _usdAmount\\n    ) external view returns (uint256);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function fundingRateFactor() external view returns (uint256);\\n\\n    function stableFundingRateFactor() external view returns (uint256);\\n\\n    function cumulativeFundingRates(\\n        address _token\\n    ) external view returns (uint256);\\n\\n    function getNextFundingRate(address _token) external view returns (uint256);\\n\\n    function getFeeBasisPoints(\\n        address _token,\\n        uint256 _usdgDelta,\\n        uint256 _feeBasisPoints,\\n        uint256 _taxBasisPoints,\\n        bool _increment\\n    ) external view returns (uint256);\\n\\n    function liquidationFeeUsd() external view returns (uint256);\\n\\n    function taxBasisPoints() external view returns (uint256);\\n\\n    function stableTaxBasisPoints() external view returns (uint256);\\n\\n    function mintBurnFeeBasisPoints() external view returns (uint256);\\n\\n    function swapFeeBasisPoints() external view returns (uint256);\\n\\n    function stableSwapFeeBasisPoints() external view returns (uint256);\\n\\n    function marginFeeBasisPoints() external view returns (uint256);\\n\\n    function allWhitelistedTokensLength() external view returns (uint256);\\n\\n    function allWhitelistedTokens(uint256) external view returns (address);\\n\\n    function whitelistedTokens(address _token) external view returns (bool);\\n\\n    function stableTokens(address _token) external view returns (bool);\\n\\n    function shortableTokens(address _token) external view returns (bool);\\n\\n    function feeReserves(address _token) external view returns (uint256);\\n\\n    function globalShortSizes(address _token) external view returns (uint256);\\n\\n    function globalShortAveragePrices(\\n        address _token\\n    ) external view returns (uint256);\\n\\n    function maxGlobalShortSizes(\\n        address _token\\n    ) external view returns (uint256);\\n\\n    function tokenDecimals(address _token) external view returns (uint256);\\n\\n    function tokenWeights(address _token) external view returns (uint256);\\n\\n    function guaranteedUsd(address _token) external view returns (uint256);\\n\\n    function poolAmounts(address _token) external view returns (uint256);\\n\\n    function bufferAmounts(address _token) external view returns (uint256);\\n\\n    function reservedAmounts(address _token) external view returns (uint256);\\n\\n    function usdgAmounts(address _token) external view returns (uint256);\\n\\n    function maxUsdgAmounts(address _token) external view returns (uint256);\\n\\n    function getRedemptionAmount(\\n        address _token,\\n        uint256 _usdgAmount\\n    ) external view returns (uint256);\\n\\n    function getMaxPrice(address _token) external view returns (uint256);\\n\\n    function getMinPrice(address _token) external view returns (uint256);\\n\\n    function getDelta(\\n        address _indexToken,\\n        uint256 _size,\\n        uint256 _averagePrice,\\n        bool _isLong,\\n        uint256 _lastIncreasedTime\\n    ) external view returns (bool, uint256);\\n\\n    function getPositionDelta(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong\\n    ) external view returns (bool, uint256);\\n\\n    function getPositionKey(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong\\n    ) external pure returns (bytes32);\\n\\n    function getPosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 size,\\n            uint256 collateral,\\n            uint256 averagePrice,\\n            uint256 entryFundingRate,\\n            uint256 reserveAmount,\\n            uint256 realisedPnl,\\n            bool hasRealisedProfit,\\n            uint256 lastIncreasedTime\\n        );\\n\\n    function getFundingFee(\\n        address _token,\\n        uint256 _size,\\n        uint256 _entryFundingRate\\n    ) external view returns (uint256);\\n\\n    function getPositionFee(uint256 _sizeDelta) external view returns (uint256);\\n\\n    function PRICE_PRECISION() external view returns (uint256);\\n\\n    function BASIS_POINTS_DIVISOR() external view returns (uint256);\\n\\n    function setError(uint256 _errorCode, string calldata _error) external;\\n\\n    function isInitialized() external view returns (bool);\\n\\n    function isSwapEnabled() external view returns (bool);\\n\\n    function isLeverageEnabled() external view returns (bool);\\n\\n    function router() external view returns (address);\\n\\n    function usdg() external view returns (address);\\n\\n    function gov() external view returns (address);\\n\\n    function whitelistedTokenCount() external view returns (uint256);\\n\\n    function maxLeverage() external view returns (uint256);\\n\\n    function minProfitTime() external view returns (uint256);\\n\\n    function hasDynamicFees() external view returns (bool);\\n\\n    function fundingInterval() external view returns (uint256);\\n\\n    function totalTokenWeights() external view returns (uint256);\\n\\n    function getTargetUsdgAmount(\\n        address _token\\n    ) external view returns (uint256);\\n\\n    function inManagerMode() external view returns (bool);\\n\\n    function inPrivateLiquidationMode() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Call.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// Bubbles up errors from delegatecall\\nlibrary Call {\\n    function _delegate(address to, bytes memory data) internal {\\n        (bool success, bytes memory result) = to.delegatecall(data);\\n\\n        if (!success) {\\n            if (result.length < 68) revert();\\n            assembly {\\n                result := add(result, 0x04)\\n            }\\n            revert(abi.decode(result, (string)));\\n        }\\n    }\\n\\n    function _call(address to, bytes memory data) internal {\\n        (bool success, bytes memory result) = to.call(data);\\n\\n        if (!success) {\\n            if (result.length < 68) revert('call failed');\\n            assembly {\\n                result := add(result, 0x04)\\n            }\\n            revert(abi.decode(result, (string)));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Constants {\\n    uint internal constant VAULT_PRECISION = 10 ** 8;\\n    uint internal constant BASIS_POINTS_DIVISOR = 10000;\\n    uint internal constant PORTION_DIVISOR = 10 ** 18;\\n}\\n\"\r\n    },\r\n    \"contracts/redeemers/IRedeemer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { IRedeemerEvents } from './IRedeemerEvents.sol';\\n\\ninterface IRedeemer is IRedeemerEvents {\\n    // For some assets, closing a portion directly to the user is not possible\\n    // Or some assets only allow the claiming all rewards to the owner (you can't claim a portion of the rewards)\\n    // In this case these operations have to happen first, returning those assets to the vault\\n    // And then being distributed to the withdrawer during normal erc20 withdraw processing\\n    // A good example of this is with GMX, where sometimes we will have to close the entire position to the vault\\n    // And then distribute a portion of the proceeds downstream to the withdrawer.\\n    // The function of having preWithdraw saves us the drama of having to try and ORDER asset withdraws.\\n    function preWithdraw(\\n        uint tokenId,\\n        address asset,\\n        address withdrawer,\\n        uint portion\\n    ) external payable;\\n\\n    function withdraw(\\n        uint tokenId,\\n        address asset,\\n        address withdrawer,\\n        uint portion\\n    ) external payable;\\n\\n    function hasPreWithdraw() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/redeemers/IRedeemerEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IRedeemerEvents {\\n    event Redeemed(\\n        uint tokenId,\\n        address indexed asset,\\n        address to,\\n        address redeemedAs,\\n        uint amount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/registry/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\nimport { Accountant } from '../Accountant.sol';\\nimport { ITransport } from '../transport/ITransport.sol';\\nimport { ExecutorIntegration } from '../executors/IExecutor.sol';\\nimport { IntegrationDataTracker } from '../integration-data-tracker/IntegrationDataTracker.sol';\\nimport { RegistryStorage } from './RegistryStorage.sol';\\nimport { GmxConfig } from '../GmxConfig.sol';\\nimport { Transport } from '../transport/Transport.sol';\\nimport { Constants } from '../lib/Constants.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\nimport { SafeOwnable } from '@solidstate/contracts/access/ownable/SafeOwnable.sol';\\n\\nimport { IAggregatorV3Interface } from '../interfaces/IAggregatorV3Interface.sol';\\nimport { IValioCustomAggregator } from '../aggregators/IValioCustomAggregator.sol';\\n\\nimport { ILayerZeroEndpoint } from '@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol';\\n\\nimport { Pausable } from '@solidstate/contracts/security/Pausable.sol';\\n\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\ncontract Registry is SafeOwnable, Pausable {\\n    // Emit event that informs that the other event was emitted on the target address\\n    event EventEmitted(address target);\\n\\n    event AssetTypeChanged(address asset, RegistryStorage.AssetType assetType);\\n    event AssetDeprecationChanged(address asset, bool deprecated);\\n\\n    modifier onlyTransport() {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        require(address(l.transport) == msg.sender, 'not transport');\\n        _;\\n    }\\n\\n    function initialize(\\n        uint16 _chainId,\\n        address _protocolTreasury,\\n        address payable _transport,\\n        address _parentVaultDiamond,\\n        address _childVaultDiamond,\\n        address _accountant,\\n        address _integrationDataTracker\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        require(l.chainId == 0, 'Already initialized');\\n        l.chainId = _chainId;\\n        l.protocolTreasury = _protocolTreasury;\\n        l.transport = Transport(_transport);\\n        l.parentVaultDiamond = _parentVaultDiamond;\\n        l.childVaultDiamond = _childVaultDiamond;\\n        l.accountant = Accountant(_accountant);\\n        l.integrationDataTracker = IntegrationDataTracker(\\n            _integrationDataTracker\\n        );\\n        l.chainlinkTimeout = 24 hours;\\n    }\\n\\n    /// MODIFIERS\\n\\n    function emitEvent() external {\\n        _emitEvent(msg.sender);\\n    }\\n\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    function addVaultParent(address vault) external onlyTransport {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.parentVaults[vault] = true;\\n        l.parentVaultList.push(vault);\\n    }\\n\\n    function addVaultChild(address vault) external onlyTransport {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.childVaults[vault] = true;\\n        l.childVaultList.push(vault);\\n    }\\n\\n    function setDeprecatedAsset(\\n        address asset,\\n        bool deprecated\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.deprecatedAssets[asset] = deprecated;\\n        emit AssetDeprecationChanged(asset, deprecated);\\n        _emitEvent(address(this));\\n    }\\n\\n    function setAssetType(\\n        address asset,\\n        RegistryStorage.AssetType assetType\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.assetTypes[asset] = assetType;\\n        l.assetList.push(asset);\\n        emit AssetTypeChanged(asset, assetType);\\n        _emitEvent(address(this));\\n    }\\n\\n    function setValuer(\\n        RegistryStorage.AssetType assetType,\\n        address valuer\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.valuers[assetType] = valuer;\\n    }\\n\\n    function setRedeemer(\\n        RegistryStorage.AssetType assetType,\\n        address redeemer\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.redeemers[assetType] = redeemer;\\n    }\\n\\n    function setChainlinkV3USDAggregator(\\n        address asset,\\n        IAggregatorV3Interface aggregator\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.chainlinkV3USDAggregators[asset] = aggregator;\\n    }\\n\\n    function setValioCustomAggregator(\\n        address asset,\\n        IValioCustomAggregator aggregator\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.valioCustomUSDAggregators[asset] = aggregator;\\n    }\\n\\n    function setAccountant(address _accountant) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.accountant = Accountant(_accountant);\\n    }\\n\\n    function setTransport(address payable _transport) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.transport = Transport(_transport);\\n    }\\n\\n    function setProtocolTreasury(address payable _treasury) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.protocolTreasury = (_treasury);\\n    }\\n\\n    function setIntegrationDataTracker(\\n        address _integrationDataTracker\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.integrationDataTracker = IntegrationDataTracker(\\n            _integrationDataTracker\\n        );\\n    }\\n\\n    function setZeroXExchangeRouter(\\n        address _zeroXExchangeRouter\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.zeroXExchangeRouter = _zeroXExchangeRouter;\\n    }\\n\\n    function setZeroXMaximumSingleSwapPriceImpactBips(\\n        uint256 _zeroXMaximumSingleSwapPriceImpactBips\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l\\n            .zeroXMaximumSingleSwapPriceImpactBips = _zeroXMaximumSingleSwapPriceImpactBips;\\n    }\\n\\n    function setExecutor(\\n        ExecutorIntegration integration,\\n        address executor\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.executors[integration] = executor;\\n    }\\n\\n    function setDepositLockupTime(uint _depositLockupTime) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.depositLockupTime = _depositLockupTime;\\n    }\\n\\n    function setMaxActiveAssets(uint _maxActiveAssets) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.maxActiveAssets = _maxActiveAssets;\\n    }\\n\\n    function setCanChangeManager(bool _canChangeManager) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.canChangeManager = _canChangeManager;\\n    }\\n\\n    function setGmxConfig(address _gmxConfig) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.gmxConfig = GmxConfig(_gmxConfig);\\n    }\\n\\n    function setLivelinessThreshold(\\n        uint256 _livelinessThreshold\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.livelinessThreshold = _livelinessThreshold;\\n    }\\n\\n    function setMaxCpitBips(\\n        VaultRiskProfile riskProfile,\\n        uint256 _maxCpitBips\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.maxCpitBips[riskProfile] = _maxCpitBips;\\n    }\\n\\n    function setMinDepositAmount(uint256 _minDepositAmount) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.minDepositAmount = _minDepositAmount;\\n    }\\n\\n    function setCanChangeManagerFees(\\n        bool _canChangeManagerFees\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.canChangeManagerFees = _canChangeManagerFees;\\n    }\\n\\n    function setMaxSingleActionImpactBips(\\n        uint256 _maxSingleActionImpactBips\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.maxSingleActionImpactBips = _maxSingleActionImpactBips;\\n    }\\n\\n    function setDepositAsset(\\n        address _depositAsset,\\n        bool canDeposit\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.depositAssets[_depositAsset] = canDeposit;\\n    }\\n\\n    function setVaultValueCap(uint256 _vaultValueCap) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.vaultValueCap = _vaultValueCap;\\n    }\\n\\n    function addRemoveAllowedInvestors(\\n        address[] memory allowed,\\n        address[] memory notAllowed\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        for (uint256 i = 0; i < allowed.length; i++) {\\n            l.allowedInvestors[allowed[i]] = true;\\n        }\\n        for (uint256 i = 0; i < notAllowed.length; i++) {\\n            l.allowedInvestors[notAllowed[i]] = false;\\n        }\\n    }\\n\\n    function setInvestorWhitelistEnabled(bool enabled) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.investorWhitelistEnabled = enabled;\\n    }\\n\\n    function addRemoveAllowedManagers(\\n        address[] memory allowed,\\n        address[] memory notAllowed\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        for (uint256 i = 0; i < allowed.length; i++) {\\n            l.allowedManagers[allowed[i]] = true;\\n        }\\n        for (uint256 i = 0; i < notAllowed.length; i++) {\\n            l.allowedManagers[notAllowed[i]] = false;\\n        }\\n    }\\n\\n    function setManagerWhitelistEnabled(bool enabled) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.managerWhitelistEnabled = enabled;\\n    }\\n\\n    function setWithdrawAutomator(\\n        address _withdrawAutomator\\n    ) external onlyOwner {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        l.withdrawAutomator = _withdrawAutomator;\\n    }\\n\\n    /// VIEWS\\n\\n    function withdrawAutomator() external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.withdrawAutomator;\\n    }\\n\\n    function allowedInvestors(address investor) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        if (l.investorWhitelistEnabled == true) {\\n            return l.allowedInvestors[investor];\\n        }\\n        return true;\\n    }\\n\\n    function allowedManagers(address manager) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        if (l.managerWhitelistEnabled == true) {\\n            return l.allowedManagers[manager];\\n        }\\n        return true;\\n    }\\n\\n    function vaultValueCap() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.vaultValueCap;\\n    }\\n\\n    function maxCpitBips(\\n        VaultRiskProfile riskProfile\\n    ) external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.maxCpitBips[riskProfile];\\n    }\\n\\n    function maxSingleActionImpactBips() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.maxSingleActionImpactBips;\\n    }\\n\\n    function parentVaultDiamond() external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.parentVaultDiamond;\\n    }\\n\\n    function childVaultDiamond() external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.childVaultDiamond;\\n    }\\n\\n    function chainId() external view returns (uint16) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.chainId;\\n    }\\n\\n    function protocolTreasury() external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.protocolTreasury;\\n    }\\n\\n    function isVault(address vault) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.parentVaults[vault] || l.childVaults[vault];\\n    }\\n\\n    function isVaultParent(address vault) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.parentVaults[vault];\\n    }\\n\\n    function isVaultChild(address vault) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.childVaults[vault];\\n    }\\n\\n    function executors(\\n        ExecutorIntegration integration\\n    ) external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.executors[integration];\\n    }\\n\\n    function redeemers(address asset) external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.redeemers[l.assetTypes[asset]];\\n    }\\n\\n    function valuers(address asset) external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.valuers[l.assetTypes[asset]];\\n    }\\n\\n    function deprecatedAssets(address asset) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.deprecatedAssets[asset];\\n    }\\n\\n    function depositAssets(address asset) external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.depositAssets[asset];\\n    }\\n\\n    function chainlinkV3USDAggregators(\\n        address asset\\n    ) external view returns (IAggregatorV3Interface) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.chainlinkV3USDAggregators[asset];\\n    }\\n\\n    function valioCustomAggregators(\\n        address asset\\n    ) external view returns (IValioCustomAggregator) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.valioCustomUSDAggregators[asset];\\n    }\\n\\n    function maxActiveAssets() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.maxActiveAssets;\\n    }\\n\\n    function chainlinkTimeout() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.chainlinkTimeout;\\n    }\\n\\n    function depositLockupTime() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.depositLockupTime;\\n    }\\n\\n    function minDepositAmount() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.minDepositAmount;\\n    }\\n\\n    function canChangeManager() external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.canChangeManager;\\n    }\\n\\n    function canChangeManagerFees() external view returns (bool) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.canChangeManagerFees;\\n    }\\n\\n    function livelinessThreshold() external view returns (uint256) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.livelinessThreshold;\\n    }\\n\\n    function zeroXExchangeRouter() external view returns (address) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.zeroXExchangeRouter;\\n    }\\n\\n    function zeroXMaximumSingleSwapPriceImpactBips()\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.zeroXMaximumSingleSwapPriceImpactBips;\\n    }\\n\\n    function vaultParentList() external view returns (address[] memory) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.parentVaultList;\\n    }\\n\\n    function vaultChildList() external view returns (address[] memory) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.childVaultList;\\n    }\\n\\n    function assetList() external view returns (address[] memory) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.assetList;\\n    }\\n\\n    // Contracts\\n\\n    function integrationDataTracker()\\n        external\\n        view\\n        returns (IntegrationDataTracker)\\n    {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.integrationDataTracker;\\n    }\\n\\n    function gmxConfig() external view returns (GmxConfig) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.gmxConfig;\\n    }\\n\\n    function accountant() external view returns (Accountant) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.accountant;\\n    }\\n\\n    function transport() external view returns (Transport) {\\n        RegistryStorage.Layout storage l = RegistryStorage.layout();\\n        return l.transport;\\n    }\\n\\n    function VAULT_PRECISION() external pure returns (uint256) {\\n        return Constants.VAULT_PRECISION;\\n    }\\n\\n    function _emitEvent(address caller) internal {\\n        emit EventEmitted(caller);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/RegistryStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Accountant } from '../Accountant.sol';\\nimport { Transport } from '../transport/Transport.sol';\\nimport { ExecutorIntegration } from '../executors/IExecutor.sol';\\n\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\nimport { IntegrationDataTracker } from '../integration-data-tracker/IntegrationDataTracker.sol';\\nimport { GmxConfig } from '../GmxConfig.sol';\\nimport { ILayerZeroEndpoint } from '@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol';\\nimport { IAggregatorV3Interface } from '../interfaces/IAggregatorV3Interface.sol';\\nimport { IValioCustomAggregator } from '../aggregators/IValioCustomAggregator.sol';\\n\\nlibrary RegistryStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.Registry');\\n\\n    // Cannot use struct with diamond storage,\\n    // as adding any extra storage slots will break the following already declared members\\n    // solhint-disable-next-line ordering\\n    struct VaultSettings {\\n        bool ___deprecated;\\n        uint ____deprecated;\\n        uint _____deprecated;\\n        uint ______deprecated;\\n    }\\n\\n    // solhint-disable-next-line ordering\\n    enum AssetType {\\n        Erc20,\\n        GMX\\n    }\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        uint16 chainId;\\n        address protocolTreasury;\\n        address parentVaultDiamond;\\n        address childVaultDiamond;\\n        mapping(address => bool) parentVaults;\\n        mapping(address => bool) childVaults;\\n        VaultSettings _deprecated;\\n        Accountant accountant;\\n        Transport transport;\\n        IntegrationDataTracker integrationDataTracker;\\n        GmxConfig gmxConfig;\\n        mapping(ExecutorIntegration => address) executors;\\n        // Price get will revert if the price hasn't be updated in the below time\\n        uint256 chainlinkTimeout;\\n        mapping(AssetType => address) valuers;\\n        mapping(AssetType => address) redeemers;\\n        mapping(address => AssetType) assetTypes;\\n        // All must return USD price and be 8 decimals\\n        mapping(address => IAggregatorV3Interface) chainlinkV3USDAggregators;\\n        mapping(address => bool) deprecatedAssets; // Assets that cannot be traded into, only out of\\n        address zeroXExchangeRouter;\\n        uint zeroXMaximumSingleSwapPriceImpactBips;\\n        bool canChangeManager;\\n        // The number of assets that can be active at once for a vault\\n        // This is important so withdraw processing doesn't consume > max gas\\n        uint maxActiveAssets;\\n        uint depositLockupTime;\\n        uint livelinessThreshold;\\n        mapping(VaultRiskProfile => uint) maxCpitBips;\\n        uint maxSingleActionImpactBips;\\n        uint minDepositAmount;\\n        bool canChangeManagerFees;\\n        mapping(address => bool) depositAssets; // Assets that can be deposited into the vault\\n        uint vaultValueCap;\\n        bool managerWhitelistEnabled;\\n        mapping(address => bool) allowedManagers;\\n        bool investorWhitelistEnabled;\\n        mapping(address => bool) allowedInvestors;\\n        address withdrawAutomator;\\n        // All must return USD price and be 8 decimals\\n        mapping(address => IValioCustomAggregator) valioCustomUSDAggregators;\\n        address[] parentVaultList;\\n        address[] childVaultList;\\n        address[] assetList;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/transport/ITransport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport { IStargateRouter } from '@layerzerolabs/solidity-examples/contracts/interfaces/IStargateRouter.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\nenum GasFunctionType {\\n    standardNoReturnMessage,\\n    createChildRequiresReturnMessage,\\n    getVaultValueRequiresReturnMessage,\\n    withdrawRequiresReturnMessage,\\n    sgReceiveRequiresReturnMessage\\n}\\n\\ninterface ITransport {\\n    struct SGReceivePayload {\\n        address dstVault;\\n        address srcVault;\\n        uint16 parentChainId;\\n        address parentVault;\\n    }\\n\\n    struct SGBridgedAssetReceivedAcknoledgementRequest {\\n        uint16 parentChainId;\\n        address parentVault;\\n        uint16 receivingChainId;\\n    }\\n\\n    struct ChildVault {\\n        uint16 chainId;\\n        address vault;\\n    }\\n\\n    struct VaultChildCreationRequest {\\n        address parentVault;\\n        uint16 parentChainId;\\n        uint16 newChainId;\\n        address manager;\\n        VaultRiskProfile riskProfile;\\n        ChildVault[] children;\\n    }\\n\\n    struct ChildCreatedRequest {\\n        address parentVault;\\n        uint16 parentChainId;\\n        ChildVault newChild;\\n    }\\n\\n    struct AddVaultSiblingRequest {\\n        ChildVault child;\\n        ChildVault newSibling;\\n    }\\n\\n    struct BridgeApprovalRequest {\\n        uint16 approvedChainId;\\n        address approvedVault;\\n    }\\n\\n    struct BridgeApprovalCancellationRequest {\\n        uint16 parentChainId;\\n        address parentVault;\\n        address requester;\\n    }\\n\\n    struct ValueUpdateRequest {\\n        uint16 parentChainId;\\n        address parentVault;\\n        ChildVault child;\\n    }\\n\\n    struct ValueUpdatedRequest {\\n        uint16 parentChainId;\\n        address parentVault;\\n        ChildVault child;\\n        uint time;\\n        uint minValue;\\n        uint maxValue;\\n    }\\n\\n    struct WithdrawRequest {\\n        uint16 parentChainId;\\n        address parentVault;\\n        ChildVault child;\\n        uint tokenId;\\n        address withdrawer;\\n        uint portion;\\n    }\\n\\n    struct WithdrawComplete {\\n        uint16 parentChainId;\\n        address parentVault;\\n    }\\n\\n    struct ChangeManagerRequest {\\n        ChildVault child;\\n        address newManager;\\n    }\\n\\n    receive() external payable;\\n\\n    function addSibling(AddVaultSiblingRequest memory request) external;\\n\\n    function bridgeApproval(BridgeApprovalRequest memory request) external;\\n\\n    function bridgeApprovalCancellation(\\n        BridgeApprovalCancellationRequest memory request\\n    ) external;\\n\\n    function bridgeAsset(\\n        uint16 dstChainId,\\n        address dstVault,\\n        uint16 parentChainId,\\n        address parentVault,\\n        address bridgeToken,\\n        uint256 amount,\\n        uint256 minAmountOut\\n    ) external payable;\\n\\n    function childCreated(ChildCreatedRequest memory request) external;\\n\\n    function createVaultChild(\\n        VaultChildCreationRequest memory request\\n    ) external;\\n\\n    function createParentVault(\\n        string memory name,\\n        string memory symbol,\\n        address manager,\\n        uint streamingFee,\\n        uint performanceFee,\\n        VaultRiskProfile riskProfile\\n    ) external returns (address deployment);\\n\\n    function getVaultValue(ValueUpdateRequest memory request) external;\\n\\n    function sendChangeManagerRequest(\\n        ChangeManagerRequest memory request\\n    ) external payable;\\n\\n    function sendAddSiblingRequest(\\n        AddVaultSiblingRequest memory request\\n    ) external;\\n\\n    function sendBridgeApproval(\\n        BridgeApprovalRequest memory request\\n    ) external payable;\\n\\n    function sendBridgeApprovalCancellation(\\n        BridgeApprovalCancellationRequest memory request\\n    ) external payable;\\n\\n    function sendVaultChildCreationRequest(\\n        VaultChildCreationRequest memory request\\n    ) external payable;\\n\\n    function sendWithdrawRequest(\\n        WithdrawRequest memory request\\n    ) external payable;\\n\\n    function sendValueUpdateRequest(\\n        ValueUpdateRequest memory request\\n    ) external payable;\\n\\n    function updateVaultValue(ValueUpdatedRequest memory request) external;\\n\\n    function getLzFee(\\n        GasFunctionType gasFunctionType,\\n        uint16 dstChainId\\n    ) external returns (uint256 sendFee, bytes memory adapterParams);\\n}\\n\"\r\n    },\r\n    \"contracts/transport/Transport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.15;\\n\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\n\\nimport { ITransport } from './ITransport.sol';\\nimport { VaultChildProxy } from '../vault-child/VaultChildProxy.sol';\\nimport { VaultParentProxy } from '../vault-parent/VaultParentProxy.sol';\\nimport { VaultChild } from '../vault-child/VaultChild.sol';\\nimport { VaultParent } from '../vault-parent/VaultParent.sol';\\n\\nimport { VaultBaseExternal } from '../vault-base/VaultBaseExternal.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\nimport { Accountant } from '../Accountant.sol';\\nimport { Registry } from '../registry/Registry.sol';\\nimport { TransportStorage } from './TransportStorage.sol';\\nimport { GasFunctionType } from './ITransport.sol';\\n\\nimport { ILayerZeroReceiver } from '@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroReceiver.sol';\\nimport { ILayerZeroEndpoint } from '@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol';\\n\\nimport { IStargateRouter } from '@layerzerolabs/solidity-examples/contracts/interfaces/IStargateRouter.sol';\\nimport { IStargateReceiver } from '@layerzerolabs/solidity-examples/contracts/interfaces/IStargateReceiver.sol';\\n\\nimport { SafeOwnable } from '@solidstate/contracts/access/ownable/SafeOwnable.sol';\\n\\nimport { Call } from '../lib/Call.sol';\\n\\n// solhint-disable ordering\\ncontract Transport is\\n    SafeOwnable,\\n    ITransport,\\n    ILayerZeroReceiver,\\n    IStargateReceiver\\n{\\n    using SafeERC20 for IERC20;\\n\\n    // EVENTS\\n\\n    event VaultParentCreated(address target);\\n    event VaultChildCreated(address target);\\n\\n    function initialize(\\n        address __registry,\\n        address __lzEndpoint,\\n        address __stargateRouter\\n    ) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.registry = Registry(__registry);\\n        l.lzEndpoint = ILayerZeroEndpoint(__lzEndpoint);\\n        l.stargateRouter = __stargateRouter;\\n    }\\n\\n    receive() external payable {}\\n\\n    modifier whenNotPaused() {\\n        require(!_registry().paused(), 'paused');\\n        _;\\n    }\\n\\n    modifier onlyThis() {\\n        require(address(this) == msg.sender, 'not this');\\n        _;\\n    }\\n\\n    modifier onlyVaultParent() {\\n        require(_registry().isVaultParent(msg.sender), 'not parent vault');\\n        _;\\n    }\\n\\n    modifier onlyVaultChild() {\\n        require(_registry().isVaultChild(msg.sender), 'not child vault');\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(_registry().isVault(msg.sender), 'not child vault');\\n        _;\\n    }\\n\\n    function registry() external view returns (Registry) {\\n        return _registry();\\n    }\\n\\n    function bridgeApprovalCancellationTime() public view returns (uint256) {\\n        return _bridgeApprovalCancellationTime();\\n    }\\n\\n    function lzEndpoint() public view returns (ILayerZeroEndpoint) {\\n        return _lzEndpoint();\\n    }\\n\\n    function trustedRemoteLookup(\\n        uint16 remoteChainId\\n    ) public view returns (bytes memory) {\\n        return _trustedRemoteLookup(remoteChainId);\\n    }\\n\\n    function stargateRouter() public view returns (address) {\\n        return _stargateRouter();\\n    }\\n\\n    function stargateAssetToDstPoolId(\\n        uint16 dstChainId,\\n        address srcBridgeToken\\n    ) external view returns (uint256) {\\n        return _stargateAssetToDstPoolId(dstChainId, srcBridgeToken);\\n    }\\n\\n    function stargateAssetToSrcPoolId(\\n        address bridgeToken\\n    ) external view returns (uint256) {\\n        return _stargateAssetToSrcPoolId(bridgeToken);\\n    }\\n\\n    function getGasUsage(\\n        GasFunctionType gasFunctionType\\n    ) external view returns (uint) {\\n        return _destinationGasUsage(gasFunctionType);\\n    }\\n\\n    function returnMessageCost(uint16 chainId) external view returns (uint) {\\n        return _returnMessageCost(chainId);\\n    }\\n\\n    function _stargateAssetToSrcPoolId(\\n        address bridgeToken\\n    ) internal view returns (uint256) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.stargateAssetToSrcPoolId[bridgeToken];\\n    }\\n\\n    function _stargateAssetToDstPoolId(\\n        uint16 dstChainId,\\n        address srcBridgeToken\\n    ) internal view returns (uint256) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.stargateAssetToDstPoolId[dstChainId][srcBridgeToken];\\n    }\\n\\n    function _bridgeApprovalCancellationTime() internal view returns (uint256) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.bridgeApprovalCancellationTime;\\n    }\\n\\n    function _trustedRemoteLookup(\\n        uint16 remoteChainId\\n    ) internal view returns (bytes memory) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.trustedRemoteLookup[remoteChainId];\\n    }\\n\\n    function _lzEndpoint() internal view returns (ILayerZeroEndpoint) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.lzEndpoint;\\n    }\\n\\n    function _stargateRouter() internal view returns (address) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.stargateRouter;\\n    }\\n\\n    function _destinationGasUsage(\\n        GasFunctionType gasFunctionType\\n    ) internal view returns (uint) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.gasUsage[gasFunctionType];\\n    }\\n\\n    function _registry() internal view returns (Registry) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.registry;\\n    }\\n\\n    function _returnMessageCost(uint16 chainId) internal view returns (uint) {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        return l.returnMessageCosts[chainId];\\n    }\\n\\n    function lzReceive(\\n        uint16 srcChainId,\\n        bytes calldata srcAddress,\\n        uint64, // nonce\\n        bytes calldata payload\\n    ) external {\\n        require(\\n            msg.sender == address(lzEndpoint()),\\n            'LzApp: invalid endpoint caller'\\n        );\\n\\n        bytes memory trustedRemote = trustedRemoteLookup(srcChainId);\\n        require(\\n            srcAddress.length == trustedRemote.length &&\\n                keccak256(srcAddress) == keccak256(trustedRemote),\\n            'LzApp: invalid source sending contract'\\n        );\\n        Call._call(address(this), payload);\\n    }\\n\\n    function getLzFee(\\n        GasFunctionType gasFunctionType,\\n        uint16 dstChainId\\n    ) external view returns (uint256 sendFee, bytes memory adapterParams) {\\n        return _getLzFee(gasFunctionType, dstChainId);\\n    }\\n\\n    function _getLzFee(\\n        GasFunctionType gasFunctionType,\\n        uint16 dstChainId\\n    ) internal view returns (uint256 sendFee, bytes memory adapterParams) {\\n        // We just use the largest message for now\\n        ChildVault memory childVault = ChildVault({\\n            chainId: 0,\\n            vault: address(0)\\n        });\\n        ChildVault[] memory childVaults = new ChildVault[](2);\\n        childVaults[0] = childVault;\\n        childVaults[1] = childVault;\\n\\n        VaultChildCreationRequest memory request = VaultChildCreationRequest({\\n            parentVault: address(0),\\n            parentChainId: 0,\\n            newChainId: 0,\\n            manager: address(0),\\n            riskProfile: VaultRiskProfile.low,\\n            children: childVaults\\n        });\\n\\n        bytes memory payload = abi.encodeWithSelector(\\n            this.sendVaultChildCreationRequest.selector,\\n            request\\n        );\\n\\n        address dstAddr = _getTrustedRemoteDestination(dstChainId);\\n\\n        adapterParams = _getAdapterParams(dstChainId, gasFunctionType);\\n\\n        (sendFee, ) = lzEndpoint().estimateFees(\\n            dstChainId,\\n            dstAddr,\\n            payload,\\n            false,\\n            adapterParams\\n        );\\n    }\\n\\n    function _requiresReturnMessage(\\n        GasFunctionType gasFunctionType\\n    ) internal pure returns (bool) {\\n        if (gasFunctionType == GasFunctionType.standardNoReturnMessage) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function _getAdapterParams(\\n        uint16 dstChainId,\\n        GasFunctionType gasFunctionType\\n    ) internal view returns (bytes memory) {\\n        bool requiresReturnMessage = _requiresReturnMessage(gasFunctionType);\\n        return\\n            abi.encodePacked(\\n                uint16(2),\\n                // The amount of gas the destination consumes when it receives the messaage\\n                _destinationGasUsage(gasFunctionType),\\n                // Amount to Airdrop to the remote transport\\n                requiresReturnMessage ? _returnMessageCost(dstChainId) : 0,\\n                // Gas Receiver\\n                requiresReturnMessage\\n                    ? _getTrustedRemoteDestination(dstChainId)\\n                    : address(0)\\n            );\\n    }\\n\\n    ///\\n    /// Stargate\\n    ///\\n\\n    function getBridgeAssetQuote(\\n        uint16 dstChainId, // Stargate/LayerZero chainId\\n        address dstVault, // the address to send the destination tokens to\\n        uint16 parentChainId,\\n        address parentVault\\n    ) external view returns (uint fee) {\\n        address dstAddr = _getTrustedRemoteDestination(dstChainId);\\n\\n        // encode payload data to send to destination contract, which it will handle with sgReceive()\\n        bytes memory data = abi.encode(\\n            SGReceivePayload({\\n                dstVault: dstVault,\\n                srcVault: msg.sender,\\n                parentChainId: parentChainId,\\n                parentVault: parentVault\\n            })\\n        );\\n\\n        // this contract calls stargate swap()\\n        uint DST_GAS = _destinationGasUsage(\\n            GasFunctionType.sgReceiveRequiresReturnMessage\\n        );\\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj({\\n            ///\\n            /// This needs to be enough for the sgReceive to execute successfully on the remote\\n            /// We will need to accurately access how much the Transport.sgReceive function needs\\n            ///\\n            dstGasForCall: DST_GAS,\\n            // Once the receiving vault receives the bridge the transport sends a message to the parent\\n            dstNativeAmount: _returnMessageCost(dstChainId),\\n            dstNativeAddr: abi.encodePacked(dstVault)\\n        });\\n\\n        (fee, ) = IStargateRouter(stargateRouter()).quoteLayerZeroFee(\\n            dstChainId,\\n            1, // function type: see Stargate Bridge.sol for all types\\n            abi.encodePacked(dstAddr), // destination contract. it must implement sgReceive()\\n            data,\\n            lzTxObj\\n        );\\n    }\\n\\n    function bridgeAsset(\\n        uint16 dstChainId, // Stargate/LayerZero chainId\\n        address dstVault, // the address to send the destination tokens to\\n        uint16 parentChainId,\\n        address parentVault,\\n        address bridgeToken, // the address of the native ERC20 to swap() - *must* be the token for the poolId\\n        uint amount,\\n        uint minAmountOut\\n    ) external payable onlyVault whenNotPaused {\\n        require(amount > 0, 'error: swap() requires amount > 0');\\n        address dstAddr = _getTrustedRemoteDestination(dstChainId);\\n\\n        uint srcPoolId = _stargateAssetToSrcPoolId(bridgeToken);\\n        uint dstPoolId = _stargateAssetToDstPoolId(dstChainId, bridgeToken);\\n        require(srcPoolId != 0, 'no srcPoolId');\\n        require(dstPoolId != 0, 'no dstPoolId');\\n\\n        // encode payload data to send to destination contract, which it will handle with sgReceive()\\n        bytes memory data = abi.encode(\\n            SGReceivePayload({\\n                dstVault: dstVault,\\n                srcVault: msg.sender,\\n                parentChainId: parentChainId,\\n                parentVault: parentVault\\n            })\\n        );\\n\\n        uint DST_GAS = _destinationGasUsage(\\n            GasFunctionType.sgReceiveRequiresReturnMessage\\n        );\\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj({\\n            ///\\n            /// This needs to be enough for the sgReceive to execute successfully on the remote\\n            /// We will need to accurately access how much the Transport.sgReceive function needs\\n            ///\\n            dstGasForCall: DST_GAS,\\n            dstNativeAmount: _returnMessageCost(dstChainId),\\n            dstNativeAddr: abi.encodePacked(dstVault)\\n        });\\n\\n        // this contract calls stargate swap()\\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\\n        IERC20(bridgeToken).safeApprove(address(stargateRouter()), amount);\\n\\n        // Stargate's Router.swap() function sends the tokens to the destination chain.\\n        IStargateRouter(stargateRouter()).swap{ value: msg.value }(\\n            dstChainId, // the destination chain id\\n            srcPoolId, // the source Stargate poolId\\n            dstPoolId, // the destination Stargate poolId\\n            payable(address(this)), // refund adddress. if msg.sender pays too much gas, return extra eth\\n            amount, // total tokens to send to destination chain\\n            minAmountOut, // min amount allowed out\\n            lzTxObj, // default lzTxObj\\n            abi.encodePacked(dstAddr), // destination address, the sgReceive() implementer\\n            data // bytes payload\\n        );\\n    }\\n\\n    ///\\n    /// Message senders\\n    ///\\n\\n    function sendChangeManagerRequest(\\n        ChangeManagerRequest memory request\\n    ) external payable onlyVaultParent whenNotPaused {\\n        _send(\\n            request.child.chainId,\\n            abi.encodeWithSelector(this.changeManager.selector, request),\\n            msg.value,\\n            _getAdapterParams(\\n                request.child.chainId,\\n                GasFunctionType.standardNoReturnMessage\\n            )\\n        );\\n    }\\n\\n    function sendWithdrawRequest(\\n        WithdrawRequest memory request\\n    ) external payable onlyVaultParent whenNotPaused {\\n        _send(\\n            request.child.chainId,\\n            abi.encodeWithSelector(this.withdraw.selector, request),\\n            msg.value,\\n            _getAdapterParams(\\n                request.child.chainId,\\n                GasFunctionType.withdrawRequiresReturnMessage\\n            )\\n        );\\n    }\\n\\n    function sendBridgeApproval(\\n        BridgeApprovalRequest memory request\\n    ) external payable onlyVaultParent whenNotPaused {\\n        _send(\\n            request.approvedChainId,\\n            abi.encodeWithSelector(this.bridgeApproval.selector, request),\\n            msg.value,\\n            _getAdapterParams(\\n                request.approvedChainId,\\n                GasFunctionType.standardNoReturnMessage\\n            )\\n        );\\n    }\\n\\n    function sendBridgeApprovalCancellation(\\n        BridgeApprovalCancellationRequest memory request\\n    ) external payable onlyVaultChild whenNotPaused {\\n        _send(\\n            request.parentChainId,\\n            abi.encodeWithSelector(\\n                this.bridgeApprovalCancellation.selector,\\n                request\\n            ),\\n            msg.value,\\n            _getAdapterParams(\\n                request.parentChainId,\\n                GasFunctionType.standardNoReturnMessage\\n            )\\n        );\\n    }\\n\\n    function sendValueUpdateRequest(\\n        ValueUpdateRequest memory request\\n    ) external payable onlyVault whenNotPaused {\\n        _send(\\n            request.child.chainId,\\n            abi.encodeWithSelector(this.getVaultValue.selector, request),\\n            msg.value,\\n            _getAdapterParams(\\n                request.child.chainId,\\n                GasFunctionType.getVaultValueRequiresReturnMessage\\n            )\\n        );\\n    }\\n\\n    function sendVaultChildCreationRequest(\\n        VaultChildCreationRequest memory request\\n    ) external payable onlyVaultParent whenNotPaused {\\n        require(\\n            _getTrustedRemoteDestination(request.newChainId) != address(0),\\n            'unsupported destination chain'\\n        );\\n        _send(\\n            request.newChainId,\\n            abi.encodeWithSelector(this.createVaultChild.selector, request),\\n            msg.value,\\n            _getAdapterParams(\\n                request.newChainId,\\n                GasFunctionType.createChildRequiresReturnMessage\\n            )\\n        );\\n    }\\n\\n    /// Return message senders\\n\\n    function sendAddSiblingRequest(\\n        AddVaultSiblingRequest memory request\\n    ) external onlyVaultParent whenNotPaused {\\n        (uint fee, bytes memory adapterParams) = _getLzFee(\\n            GasFunctionType.standardNoReturnMessage,\\n            request.child.chainId\\n        );\\n        _send(\\n            request.child.chainId,\\n            abi.encodeWithSelector(this.addSibling.selector, request),\\n            fee,\\n            adapterParams\\n        );\\n    }\\n\\n    function sendWithdrawComplete(WithdrawComplete memory request) internal {\\n        (uint fee, bytes memory adapterParams) = _getLzFee(\\n            GasFunctionType.standardNoReturnMessage,\\n            request.parentChainId\\n        );\\n        _send(\\n            request.parentChainId,\\n            abi.encodeWithSelector(this.withdrawComplete.selector, request),\\n            fee,\\n            adapterParams\\n        );\\n    }\\n\\n    function _sendValueUpdatedRequest(\\n        ValueUpdatedRequest memory request\\n    ) internal {\\n        (uint fee, bytes memory adapterParams) = _getLzFee(\\n            GasFunctionType.standardNoReturnMessage,\\n            request.parentChainId\\n        );\\n        _send(\\n            request.parentChainId,\\n            abi.encodeWithSelector(this.updateVaultValue.selector, request),\\n            fee,\\n            adapterParams\\n        );\\n    }\\n\\n    function _sendSGBridgedAssetAcknowledment(\\n        SGBridgedAssetReceivedAcknoledgementRequest memory request\\n    ) internal {\\n        (uint fee, bytes memory adapterParams) = _getLzFee(\\n            GasFunctionType.standardNoReturnMessage,\\n            request.parentChainId\\n        );\\n        _send(\\n            request.parentChainId,\\n            abi.encodeWithSelector(\\n                this.sgBridgedAssetReceived.selector,\\n                request\\n            ),\\n            fee,\\n            adapterParams\\n        );\\n    }\\n\\n    function _sendChildCreatedRequest(\\n        ChildCreatedRequest memory request\\n    ) internal {\\n        (uint fee, bytes memory adapterParams) = _getLzFee(\\n            GasFunctionType.standardNoReturnMessage,\\n            request.parentChainId\\n        );\\n        _send(\\n            request.parentChainId,\\n            abi.encodeWithSelector(this.childCreated.selector, request),\\n            fee,\\n            adapterParams\\n        );\\n    }\\n\\n    ///\\n    /// Message received callbacks\\n    ///\\n\\n    function bridgeApprovalCancellation(\\n        BridgeApprovalCancellationRequest memory request\\n    ) public onlyThis {\\n        VaultParent(request.parentVault).receiveBridgeApprovalCancellation(\\n            request.requester\\n        );\\n    }\\n\\n    function bridgeApproval(\\n        BridgeApprovalRequest memory request\\n    ) public onlyThis {\\n        VaultChild(request.approvedVault).receiveBridgeApproval();\\n    }\\n\\n    function withdraw(WithdrawRequest memory request) public onlyThis {\\n        VaultChild(request.child.vault).receiveWithdrawRequest(\\n            request.tokenId,\\n            request.withdrawer,\\n            request.portion\\n        );\\n\\n        sendWithdrawComplete(\\n            ITransport.WithdrawComplete({\\n                parentChainId: request.parentChainId,\\n                parentVault: request.parentVault\\n            })\\n        );\\n    }\\n\\n    function withdrawComplete(WithdrawComplete memory request) public onlyThis {\\n        VaultParent(request.parentVault).receiveWithdrawComplete();\\n    }\\n\\n    function getVaultValue(ValueUpdateRequest memory request) public onlyThis {\\n        try\\n            // This would fail if for instance chainlink timeout\\n            // If a callback fails the message is deemed failed to deliver by LZ and is queued\\n            // This is not the behaviour we want\\n            VaultChild(request.child.vault).getVaultValue()\\n        returns (uint _minValue, uint _maxValue) {\\n            _sendValueUpdatedRequest(\\n                ValueUpdatedRequest({\\n                    parentChainId: request.parentChainId,\\n                    parentVault: request.parentVault,\\n                    child: request.child,\\n                    time: block.timestamp,\\n                    minValue: _minValue,\\n                    maxValue: _maxValue\\n                })\\n            );\\n        } catch {}\\n    }\\n\\n    function updateVaultValue(\\n        ValueUpdatedRequest memory request\\n    ) public onlyThis {\\n        VaultParent(request.parentVault).receiveChildValue(\\n            request.child.chainId,\\n            request.minValue,\\n            request.maxValue,\\n            request.time\\n        );\\n    }\\n\\n    function createVaultChild(\\n        VaultChildCreationRequest memory request\\n    ) public onlyThis {\\n        address child = _deployChild(\\n            request.parentChainId,\\n            request.parentVault,\\n            request.manager,\\n            request.riskProfile,\\n            request.children\\n        );\\n        _sendChildCreatedRequest(\\n            ChildCreatedRequest({\\n                parentVault: request.parentVault,\\n                parentChainId: request.parentChainId,\\n                newChild: ChildVault({\\n                    chainId: _registry().chainId(),\\n                    vault: child\\n                })\\n            })\\n        );\\n    }\\n\\n    function childCreated(ChildCreatedRequest memory request) public onlyThis {\\n        VaultParent(request.parentVault).receiveChildCreated(\\n            request.newChild.chainId,\\n            request.newChild.vault\\n        );\\n    }\\n\\n    function addSibling(AddVaultSiblingRequest memory request) public onlyThis {\\n        VaultChild(request.child.vault).receiveAddSibling(\\n            request.newSibling.chainId,\\n            request.newSibling.vault\\n        );\\n    }\\n\\n    function changeManager(\\n        ChangeManagerRequest memory request\\n    ) public onlyThis {\\n        VaultChild(request.child.vault).receiveManagerChange(\\n            request.newManager\\n        );\\n    }\\n\\n    function createParentVault(\\n        string memory name,\\n        string memory symbol,\\n        address manager,\\n        uint streamingFee,\\n        uint performanceFee,\\n        VaultRiskProfile riskProfile\\n    ) external whenNotPaused returns (address deployment) {\\n        return\\n            _createParentVault(\\n                name,\\n                symbol,\\n                manager,\\n                streamingFee,\\n                performanceFee,\\n                riskProfile\\n            );\\n    }\\n\\n    function createParentAndChildVault(\\n        string memory name,\\n        string memory symbol,\\n        address manager,\\n        uint streamingFee,\\n        uint performanceFee,\\n        VaultRiskProfile riskProfile,\\n        uint16 childChainId,\\n        uint lzFee\\n    ) external payable whenNotPaused returns (address deployment) {\\n        address parentVault = _createParentVault(\\n            name,\\n            symbol,\\n            manager,\\n            streamingFee,\\n            performanceFee,\\n            riskProfile\\n        );\\n        VaultParent(parentVault).requestCreateChild{ value: msg.value }(\\n            childChainId,\\n            lzFee\\n        );\\n        return parentVault;\\n    }\\n\\n    // sgReceive() - the destination contract must implement this function to receive the tokens and payload\\n    // Does not currently support weth\\n    function sgReceive(\\n        uint16, // _srcChainId,\\n        bytes memory, // _srcAddress\\n        uint, // _nonce\\n        address _token,\\n        uint amountLD,\\n        bytes memory _payload\\n    ) external override {\\n        require(\\n            msg.sender == address(stargateRouter()),\\n            'only stargate router can call sgReceive!'\\n        );\\n        SGReceivePayload memory payload = abi.decode(\\n            _payload,\\n            (SGReceivePayload)\\n        );\\n        // send transfer _token/amountLD to _toAddr\\n        IERC20(_token).transfer(payload.dstVault, amountLD);\\n        VaultBaseExternal(payload.dstVault).receiveBridgedAsset(_token);\\n        // Already on the parent chain - no need to send a message\\n        if (_registry().chainId() == payload.parentChainId) {\\n            this.sgBridgedAssetReceived(\\n                SGBridgedAssetReceivedAcknoledgementRequest({\\n                    parentChainId: payload.parentChainId,\\n                    parentVault: payload.parentVault,\\n                    receivingChainId: payload.parentChainId\\n                })\\n            );\\n        } else {\\n            _sendSGBridgedAssetAcknowledment(\\n                SGBridgedAssetReceivedAcknoledgementRequest({\\n                    parentChainId: payload.parentChainId,\\n                    parentVault: payload.parentVault,\\n                    receivingChainId: _registry().chainId()\\n                })\\n            );\\n        }\\n    }\\n\\n    function setTrustedRemoteAddress(\\n        uint16 _remoteChainId,\\n        bytes calldata _remoteAddress\\n    ) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.trustedRemoteLookup[_remoteChainId] = abi.encodePacked(\\n            _remoteAddress,\\n            address(this)\\n        );\\n    }\\n\\n    function setSGAssetToSrcPoolId(\\n        address asset,\\n        uint poolId\\n    ) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.stargateAssetToSrcPoolId[asset] = poolId;\\n    }\\n\\n    function setSGAssetToDstPoolId(\\n        uint16 chainId,\\n        address asset,\\n        uint poolId\\n    ) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.stargateAssetToDstPoolId[chainId][asset] = poolId;\\n    }\\n\\n    function setGasUsage(\\n        GasFunctionType gasUsage,\\n        uint gas\\n    ) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.gasUsage[gasUsage] = gas;\\n    }\\n\\n    function setReturnMessageCost(uint16 chainId, uint cost) external {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.returnMessageCosts[chainId] = cost;\\n    }\\n\\n    function setBridgeApprovalCancellationTime(uint time) external onlyOwner {\\n        TransportStorage.Layout storage l = TransportStorage.layout();\\n        l.bridgeApprovalCancellationTime = time;\\n    }\\n\\n    function _send(\\n        uint16 dstChainId,\\n        bytes memory payload,\\n        uint sendFee,\\n        bytes memory adapterParams\\n    ) internal {\\n        lzEndpoint().send{ value: sendFee }(\\n            dstChainId,\\n            trustedRemoteLookup(dstChainId),\\n            payload,\\n            payable(address(this)),\\n            payable(address(this)),\\n            adapterParams\\n        );\\n    }\\n\\n    function _getTrustedRemoteDestination(\\n        uint16 dstChainId\\n    ) internal view returns (address dstAddr) {\\n        bytes memory trustedRemote = trustedRemoteLookup(dstChainId);\\n        require(\\n            trustedRemote.length != 0,\\n            'LzApp: destination chain is not a trusted source'\\n        );\\n        assembly {\\n            dstAddr := mload(add(trustedRemote, 20))\\n        }\\n    }\\n\\n    function _createParentVault(\\n        string memory name,\\n        string memory symbol,\\n        address manager,\\n        uint streamingFee,\\n        uint performanceFee,\\n        VaultRiskProfile riskProfile\\n    ) internal returns (address deployment) {\\n        require(\\n            _registry().parentVaultDiamond() != address(0),\\n            'not parent chain'\\n        );\\n        require(_registry().allowedManagers(manager), 'manager not allowed');\\n        deployment = address(\\n            new VaultParentProxy(_registry().parentVaultDiamond())\\n        );\\n\\n        VaultParent(deployment).initialize(\\n            name,\\n            symbol,\\n            manager,\\n            streamingFee,\\n            performanceFee,\\n            riskProfile,\\n            _registry()\\n        );\\n\\n        _registry().addVaultParent(deployment);\\n\\n        emit VaultParentCreated(deployment);\\n        _registry().emitEvent();\\n    }\\n\\n    function _deployChild(\\n        uint16 parentChainId,\\n        address parentVault,\\n        address manager,\\n        VaultRiskProfile riskProfile,\\n        Transport.ChildVault[] memory children\\n    ) internal whenNotPaused returns (address deployment) {\\n        deployment = address(\\n            new VaultChildProxy(_registry().childVaultDiamond())\\n        );\\n        VaultChild(deployment).initialize(\\n            parentChainId,\\n            parentVault,\\n            manager,\\n            riskProfile,\\n            _registry(),\\n            children\\n        );\\n        _registry().addVaultChild(deployment);\\n\\n        emit VaultChildCreated(deployment);\\n        _registry().emitEvent();\\n    }\\n\\n    function sgBridgedAssetReceived(\\n        SGBridgedAssetReceivedAcknoledgementRequest memory request\\n    ) public onlyThis {\\n        VaultParent(request.parentVault).receiveBridgedAssetAcknowledgement(\\n            request.receivingChainId\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/transport/TransportStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Registry } from '../registry/Registry.sol';\\nimport { ILayerZeroEndpoint } from '@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol';\\n\\nimport { GasFunctionType } from './ITransport.sol';\\n\\nlibrary TransportStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.Transport');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        Registry registry;\\n        ILayerZeroEndpoint lzEndpoint;\\n        mapping(address => bool) isVault;\\n        mapping(uint16 => bytes) trustedRemoteLookup;\\n        address stargateRouter;\\n        mapping(address => uint) stargateAssetToSrcPoolId;\\n        // (chainId => (asset => poolId))\\n        mapping(uint16 => mapping(address => uint)) stargateAssetToDstPoolId;\\n        uint bridgeApprovalCancellationTime;\\n        mapping(GasFunctionType => uint) gasUsage;\\n        mapping(uint16 => uint) returnMessageCosts;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/valuers/IValuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IValuer {\\n    struct AssetValue {\\n        address asset;\\n        uint256 totalMinValue;\\n        uint256 totalMaxValue;\\n        AssetBreakDown[] breakDown;\\n    }\\n\\n    struct AssetBreakDown {\\n        address asset;\\n        uint256 balance;\\n        uint256 minValue;\\n        uint256 maxValue;\\n    }\\n\\n    function getVaultValue(\\n        address vault,\\n        address asset,\\n        int256 unitPrice\\n    ) external view returns (uint256 minValue, uint256 maxValue);\\n\\n    function getAssetValue(\\n        uint amount,\\n        address asset,\\n        int256 unitPrice\\n    ) external view returns (uint256 minValue, uint256 maxValue);\\n\\n    // This returns an array because later on we may support assets that have multiple tokens\\n    // Or we may want to break GMX down into individual positions\\n    function getAssetBreakdown(\\n        address vault,\\n        address asset,\\n        int256 unitPrice\\n    ) external view returns (AssetValue memory);\\n\\n    function getAssetActive(\\n        address vault,\\n        address asset\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/vault-base/IVaultRiskProfile.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nenum VaultRiskProfile {\\n    low,\\n    medium,\\n    high\\n}\\n\"\r\n    },\r\n    \"contracts/vault-base/VaultBaseExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Registry } from '../registry/Registry.sol';\\nimport { IGmxPositionRouterCallbackReceiver } from '../interfaces/IGmxPositionRouterCallbackReceiver.sol';\\nimport { VaultBaseInternal } from './VaultBaseInternal.sol';\\nimport { ExecutorIntegration } from '../executors/IExecutor.sol';\\nimport { VaultBaseStorage } from './VaultBaseStorage.sol';\\nimport { VaultRiskProfile } from './IVaultRiskProfile.sol';\\n\\ncontract VaultBaseExternal is\\n    IGmxPositionRouterCallbackReceiver,\\n    VaultBaseInternal\\n{\\n    function receiveBridgedAsset(address asset) external onlyTransport {\\n        _receiveBridgedAsset(asset);\\n    }\\n\\n    // The Executor runs as the Vault. I'm not sure this is ideal but it makes writing executors easy\\n    // Other solutions are\\n    // 1. The executor returns transactions to be executed which are then assembly called by the this\\n    // 2. We write the executor code in the vault\\n    function execute(\\n        ExecutorIntegration integration,\\n        bytes memory encodedWithSelectorPayload\\n    ) external payable onlyManager whenNotPaused nonReentrant {\\n        _execute(integration, encodedWithSelectorPayload);\\n    }\\n\\n    function gmxPositionCallback(\\n        bytes32 positionKey,\\n        bool isExecuted,\\n        bool isIncrease\\n    ) external nonReentrant {\\n        _gmxPositionCallback(positionKey, isExecuted, isIncrease);\\n    }\\n\\n    function registry() external view returns (Registry) {\\n        return _registry();\\n    }\\n\\n    function manager() external view returns (address) {\\n        return _manager();\\n    }\\n\\n    function vaultId() external view returns (bytes32) {\\n        return _vaultId();\\n    }\\n\\n    function getVaultValue()\\n        external\\n        view\\n        returns (uint minValue, uint maxValue)\\n    {\\n        return _getVaultValue();\\n    }\\n\\n    function cpitLockedUntil() external view returns (uint) {\\n        return _cpitLockedUntil();\\n    }\\n\\n    function isCpitLocked() external view returns (bool) {\\n        return _isCpitLocked();\\n    }\\n\\n    function getCurrentCpit() external view returns (uint256) {\\n        return _getCurrentCpit();\\n    }\\n\\n    function riskProfile() external view returns (VaultRiskProfile) {\\n        return _riskProfile();\\n    }\\n\\n    function enabledAssets(address asset) external view returns (bool) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.enabledAssets[asset];\\n    }\\n\\n    function assetsWithBalances() external view returns (address[] memory) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.assets;\\n    }\\n\\n    // This can be called by the executors to update the vaults active assets after a tx\\n    function addActiveAsset(address asset) public onlyThis {\\n        _addAsset(asset);\\n    }\\n\\n    // This can be called by the executors to update the vaults active assets after a tx\\n    function updateActiveAsset(address asset) public onlyThis {\\n        _updateActiveAsset(asset);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-base/VaultBaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Registry } from '../registry/Registry.sol';\\nimport { Constants } from '../lib/Constants.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\nimport { IGmxPositionRouterCallbackReceiver } from '../interfaces/IGmxPositionRouterCallbackReceiver.sol';\\nimport { ExecutorIntegration } from '../executors/IExecutor.sol';\\nimport { IRedeemer } from '../redeemers/IRedeemer.sol';\\nimport { Call } from '../lib/Call.sol';\\nimport { VaultBaseStorage } from './VaultBaseStorage.sol';\\nimport { CPIT } from '../cpit/CPIT.sol';\\n\\nimport { ReentrancyGuard } from '@solidstate/contracts/utils/ReentrancyGuard.sol';\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\n\\ncontract VaultBaseInternal is ReentrancyGuard, CPIT {\\n    using SafeERC20 for IERC20;\\n\\n    event Withdraw(\\n        uint tokenId,\\n        address withdrawer,\\n        uint portion,\\n        address[] assets\\n    );\\n    event AssetAdded(address asset);\\n    event AssetRemoved(address asset);\\n    event BridgeReceived(address asset);\\n    event BridgeSent(\\n        uint16 dstChainId,\\n        address dstVault,\\n        address asset,\\n        uint amount\\n    );\\n\\n    modifier whenNotPaused() {\\n        require(!_registry().paused(), 'paused');\\n        _;\\n    }\\n\\n    modifier onlyTransport() {\\n        require(\\n            address(_registry().transport()) == msg.sender,\\n            'not transport'\\n        );\\n        _;\\n    }\\n\\n    modifier onlyThis() {\\n        require(address(this) == msg.sender, 'not this');\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(_manager() == msg.sender, 'not manager');\\n        _;\\n    }\\n\\n    function initialize(\\n        Registry registry,\\n        address manager,\\n        VaultRiskProfile riskProfile\\n    ) internal {\\n        require(manager != address(0), 'invalid _manager');\\n        require(address(registry) != address(0), 'invalid _registry');\\n\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        l.registry = Registry(registry);\\n        l.manager = manager;\\n        l.riskProfile = riskProfile;\\n    }\\n\\n    function _updateActiveAsset(address asset) internal {\\n        if (_hasValue(asset)) {\\n            _addAsset(asset);\\n        } else {\\n            _removeAsset(asset);\\n        }\\n    }\\n\\n    function _receiveBridgedAsset(address asset) internal {\\n        _updateActiveAsset(asset);\\n        emit BridgeReceived(asset);\\n        _registry().emitEvent();\\n    }\\n\\n    // The Executor runs as the Vault. I'm not sure this is ideal but it makes writing executors easy\\n    // Other solutions are\\n    // 1. The executor returns transactions to be executed which are then assembly called by the this\\n    // 2. We write the executor code in the vault\\n    function _execute(\\n        ExecutorIntegration integration,\\n        bytes memory encodedWithSelectorPayload\\n    ) internal isNotCPITLocked {\\n        // Get value before for CPIT\\n        (, uint valueBefore) = _getVaultValue();\\n\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        address executor = l.registry.executors(integration);\\n        require(executor != address(0), 'no executor');\\n        // Make the external call\\n        Call._delegate(executor, encodedWithSelectorPayload);\\n\\n        // Get value after for CPIT\\n        (, uint valueAfter) = _getVaultValue();\\n        uint txPriceImpact = _updatePriceImpact(\\n            valueBefore,\\n            valueAfter,\\n            _registry().maxCpitBips(l.riskProfile)\\n        );\\n        require(\\n            txPriceImpact < _registry().maxSingleActionImpactBips(),\\n            'Max price impact exceeded'\\n        );\\n    }\\n\\n    // The Redeemer runs as the Vault. I'm not sure this is ideal but it makes writing Redeemers easy\\n    // Other solutions are\\n    // 1. The Redeemer returns transactions to be executed which are then assembly called by the this\\n    // 2. We write the Redeemer code in the vault\\n    function _withdraw(\\n        uint tokenId,\\n        address withdrawer,\\n        uint portion\\n    ) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n\\n        for (uint i = 0; i < l.assets.length; i++) {\\n            address redeemer = l.registry.redeemers(l.assets[i]);\\n            require(redeemer != address(0), 'no redeemer');\\n            if (IRedeemer(redeemer).hasPreWithdraw()) {\\n                Call._delegate(\\n                    redeemer,\\n                    abi.encodeWithSelector(\\n                        IRedeemer.preWithdraw.selector,\\n                        tokenId,\\n                        l.assets[i],\\n                        withdrawer,\\n                        portion\\n                    )\\n                );\\n            }\\n        }\\n\\n        // We need to take a memory refence as we remove assets that are fully withdrawn\\n        // And this means that the assets array will change length\\n        // This should not be moved before preWithdraw because preWithdraw can add active assets\\n        address[] memory assets = l.assets;\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            address redeemer = l.registry.redeemers(assets[i]);\\n            Call._delegate(\\n                redeemer,\\n                abi.encodeWithSelector(\\n                    IRedeemer.withdraw.selector,\\n                    tokenId,\\n                    assets[i],\\n                    withdrawer,\\n                    portion\\n                )\\n            );\\n            // In some cases such as gmx the position will be closed down and we should stop tracking\\n            // In the case of the withdrawer owns 100% of the vault\\n            _updateActiveAsset(assets[i]);\\n        }\\n\\n        emit Withdraw(tokenId, withdrawer, portion, assets);\\n        _registry().emitEvent();\\n    }\\n\\n    function _bridgeAsset(\\n        uint16 dstChainId,\\n        address dstVault,\\n        uint16 parentChainId,\\n        address vaultParent,\\n        address asset,\\n        uint amount,\\n        uint minAmountOut,\\n        uint lzFee\\n    ) internal {\\n        // The max slippage the stargate ui shows is 1%\\n        // check minAmountOut is within this threshold\\n        uint internalMinAmountOut = (amount * 99) / 100;\\n        require(minAmountOut >= internalMinAmountOut, 'minAmountOut too low');\\n\\n        IERC20(asset).safeApprove(address(_registry().transport()), amount);\\n        _registry().transport().bridgeAsset{ value: lzFee }(\\n            dstChainId,\\n            dstVault,\\n            parentChainId,\\n            vaultParent,\\n            asset,\\n            amount,\\n            minAmountOut\\n        );\\n        emit BridgeSent(dstChainId, dstVault, asset, amount);\\n        _registry().emitEvent();\\n        _updateActiveAsset(asset);\\n    }\\n\\n    function _gmxPositionCallback(\\n        bytes32 positionKey,\\n        bool isExecuted,\\n        bool isIncrease\\n    ) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        require(\\n            msg.sender == address(l.registry.gmxConfig().positionRouter()),\\n            'not gmx'\\n        );\\n        address executor = l.registry.executors(ExecutorIntegration.GMX);\\n        require(executor != address(0), 'no executor');\\n        Call._delegate(\\n            executor,\\n            abi.encodeWithSelector(\\n                IGmxPositionRouterCallbackReceiver.gmxPositionCallback.selector,\\n                positionKey,\\n                isExecuted,\\n                isIncrease\\n            )\\n        );\\n    }\\n\\n    function _removeAsset(address asset) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        if (l.enabledAssets[asset]) {\\n            for (uint i = 0; i < l.assets.length; i++) {\\n                if (l.assets[i] == asset) {\\n                    _removeFromArray(l.assets, i);\\n                    l.enabledAssets[asset] = false;\\n\\n                    emit AssetRemoved(asset);\\n                    _registry().emitEvent();\\n                }\\n            }\\n        }\\n    }\\n\\n    function _addAsset(address asset) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        require(\\n            l.registry.accountant().isSupportedAsset(asset),\\n            'asset not supported'\\n        );\\n        if (!l.enabledAssets[asset]) {\\n            l.enabledAssets[asset] = true;\\n            l.assets.push(asset);\\n            require(\\n                l.assets.length <= l.registry.maxActiveAssets(),\\n                'too many assets'\\n            );\\n\\n            emit AssetAdded(asset);\\n            _registry().emitEvent();\\n        }\\n    }\\n\\n    function _removeFromArray(address[] storage array, uint index) internal {\\n        require(index < array.length);\\n        array[index] = array[array.length - 1];\\n        array.pop();\\n    }\\n\\n    function _changeManager(address newManager) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        l.manager = newManager;\\n    }\\n\\n    function _setVaultId(bytes32 vaultId) internal {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        l.vaultId = vaultId;\\n    }\\n\\n    function _registry() internal view returns (Registry) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.registry;\\n    }\\n\\n    function _riskProfile() internal view returns (VaultRiskProfile) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.riskProfile;\\n    }\\n\\n    function _manager() internal view returns (address) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.manager;\\n    }\\n\\n    function _vaultId() internal view returns (bytes32) {\\n        VaultBaseStorage.Layout storage l = VaultBaseStorage.layout();\\n        return l.vaultId;\\n    }\\n\\n    function _getVaultValue()\\n        internal\\n        view\\n        returns (uint minValue, uint maxValue)\\n    {\\n        return _registry().accountant().getVaultValue(address(this));\\n    }\\n\\n    function _hasValue(address asset) internal view returns (bool) {\\n        (, uint maxValue) = _registry().accountant().assetValueOfVault(\\n            asset,\\n            address(this)\\n        );\\n        return maxValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-base/VaultBaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Registry } from '../registry/Registry.sol';\\n\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\nlibrary VaultBaseStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.VaultBase');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        Registry registry;\\n        address manager;\\n        address[] assets;\\n        mapping(address => bool) enabledAssets;\\n        VaultRiskProfile riskProfile;\\n        bytes32 vaultId;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-child/VaultChild.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { ITransport, GasFunctionType } from '../transport/ITransport.sol';\\nimport { VaultBaseInternal } from '../vault-base/VaultBaseInternal.sol';\\nimport { VaultBaseExternal } from '../vault-base/VaultBaseExternal.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\nimport { Registry } from '../registry/Registry.sol';\\nimport { RegistryStorage } from '../registry/RegistryStorage.sol';\\nimport { VaultChildStorage } from './VaultChildStorage.sol';\\n\\nimport { IRedeemerEvents } from '../redeemers/IRedeemerEvents.sol';\\nimport { IExecutorEvents } from '../executors/IExecutorEvents.sol';\\n\\nimport { IStargateRouter } from '@layerzerolabs/solidity-examples/contracts/interfaces/IStargateRouter.sol';\\n\\ncontract VaultChild is\\n    VaultBaseInternal,\\n    VaultBaseExternal,\\n    IRedeemerEvents,\\n    IExecutorEvents\\n{\\n    modifier bridgingApproved() {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        require(l.bridgeApproved, 'bridge not approved');\\n        _;\\n    }\\n\\n    function initialize(\\n        uint16 _parentChainId,\\n        address _vaultParentAddress,\\n        address _manager,\\n        VaultRiskProfile _riskProfile,\\n        Registry _registry,\\n        ITransport.ChildVault[] memory _existingSiblings\\n    ) external {\\n        require(_vaultId() == 0, 'already initialized');\\n\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n        VaultBaseInternal.initialize(_registry, _manager, _riskProfile);\\n        require(_parentChainId != 0, 'invalid _parentChainId');\\n        require(\\n            _vaultParentAddress != address(0),\\n            'invalid _vaultParentAddress'\\n        );\\n\\n        bytes32 vaultId = keccak256(\\n            abi.encodePacked(_parentChainId, _vaultParentAddress)\\n        );\\n        _setVaultId(vaultId);\\n\\n        l.parentChainId = _parentChainId;\\n        l.vaultParent = _vaultParentAddress;\\n        for (uint8 i = 0; i < _existingSiblings.length; i++) {\\n            l.siblingChains.push(_existingSiblings[i].chainId);\\n            l.siblings[_existingSiblings[i].chainId] = _existingSiblings[i]\\n                .vault;\\n        }\\n    }\\n\\n    ///\\n    /// Receivers/CallBacks\\n    ///\\n\\n    // called by the dstChain via lz to federate a new sibling\\n    function receiveAddSibling(\\n        uint16 siblingChainId,\\n        address siblingVault\\n    ) external onlyTransport {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        l.siblings[siblingChainId] = siblingVault;\\n        l.siblingChains.push(siblingChainId);\\n    }\\n\\n    function receiveBridgeApproval() external onlyTransport {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        l.bridgeApproved = true;\\n        l.bridgeApprovalTime = block.timestamp;\\n    }\\n\\n    function receiveWithdrawRequest(\\n        uint tokenId,\\n        address withdrawer,\\n        uint portion\\n    ) external onlyTransport {\\n        _withdraw(tokenId, withdrawer, portion);\\n    }\\n\\n    function receiveManagerChange(address newManager) external onlyTransport {\\n        _changeManager(newManager);\\n    }\\n\\n    ///\\n    /// Cross Chain Requests\\n    ///\\n\\n    // Allows anyone to unlock the bridge lock on the parent after 5 minutes\\n    function requestBridgeApprovalCancellation(\\n        uint lzFee\\n    ) external payable whenNotPaused {\\n        require(msg.value >= lzFee, 'insufficient fee');\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        require(l.bridgeApproved, 'must be already approved');\\n        uint timeout = _registry().transport().bridgeApprovalCancellationTime();\\n\\n        if (msg.sender != _manager()) {\\n            require(\\n                l.bridgeApprovalTime + timeout < block.timestamp,\\n                'cannot cancel yet'\\n            );\\n        }\\n\\n        l.bridgeApproved = false;\\n        _registry().transport().sendBridgeApprovalCancellation{ value: lzFee }(\\n            ITransport.BridgeApprovalCancellationRequest({\\n                parentChainId: l.parentChainId,\\n                parentVault: l.vaultParent,\\n                requester: msg.sender\\n            })\\n        );\\n    }\\n\\n    function requestBridgeToChain(\\n        uint16 dstChainId,\\n        address asset,\\n        uint amount,\\n        uint minAmountOut,\\n        uint lzFee\\n    ) external payable onlyManager whenNotPaused bridgingApproved {\\n        require(msg.value >= lzFee, 'insufficient fee');\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        address dstVault;\\n        if (dstChainId == l.parentChainId) {\\n            dstVault = l.vaultParent;\\n        } else {\\n            dstVault = l.siblings[dstChainId];\\n        }\\n\\n        require(dstVault != address(0), 'no dst vault');\\n\\n        l.bridgeApproved = false;\\n        _bridgeAsset(\\n            dstChainId,\\n            dstVault,\\n            l.parentChainId,\\n            l.vaultParent,\\n            asset,\\n            amount,\\n            minAmountOut,\\n            lzFee\\n        );\\n    }\\n\\n    ///\\n    /// Views\\n    ///\\n\\n    function parentChainId() external view returns (uint16) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        return l.parentChainId;\\n    }\\n\\n    function parentVault() external view returns (address) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        return l.vaultParent;\\n    }\\n\\n    function allSiblingChainIds() external view returns (uint16[] memory) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n        return l.siblingChains;\\n    }\\n\\n    function siblings(uint16 chainId) external view returns (address) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n        return l.siblings[chainId];\\n    }\\n\\n    function bridgeApproved() external view returns (bool) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n        return l.bridgeApproved;\\n    }\\n\\n    function getLzFee(\\n        bytes4 funcHash,\\n        uint16 chainId\\n    ) public view returns (uint fee) {\\n        if (funcHash == this.requestBridgeToChain.selector) {\\n            fee = _bridgeQuote(chainId);\\n        } else {\\n            (fee, ) = _registry().transport().getLzFee(\\n                GasFunctionType.standardNoReturnMessage,\\n                chainId\\n            );\\n        }\\n    }\\n\\n    function _bridgeQuote(uint16 dstChainId) internal view returns (uint fee) {\\n        VaultChildStorage.Layout storage l = VaultChildStorage.layout();\\n\\n        address dstVault;\\n        if (dstChainId == l.parentChainId) {\\n            dstVault = l.vaultParent;\\n        } else {\\n            dstVault = l.siblings[dstChainId];\\n        }\\n\\n        require(dstVault != address(0), 'no dst vault');\\n\\n        fee = _registry().transport().getBridgeAssetQuote(\\n            dstChainId,\\n            dstVault,\\n            _registry().chainId(),\\n            address(this)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-child/VaultChildProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\\n\\ncontract VaultChildProxy is Proxy {\\n    address private immutable DIAMOND;\\n\\n    constructor(address diamond) {\\n        DIAMOND = diamond;\\n    }\\n\\n    function _getImplementation() internal view override returns (address) {\\n        return IDiamondReadable(DIAMOND).facetAddress(msg.sig);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-child/VaultChildStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary VaultChildStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.VaultChild');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        bytes32 _deprecated_vaultId;\\n        uint16 parentChainId;\\n        address vaultParent;\\n        bool bridgeApproved;\\n        uint bridgeApprovalTime;\\n        uint16[] siblingChains;\\n        mapping(uint16 => address) siblings;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-fees/VaultFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport { VaultFeesStorage } from './VaultFeesStorage.sol';\\nimport { Constants } from '../lib/Constants.sol';\\n\\ncontract VaultFees {\\n    uint internal constant _PROTOCOL_FEE_BASIS_POINTS = 2000; // 20% of ManagerFees\\n    uint internal constant _STEAMING_FEE_DURATION = 365 days;\\n\\n    uint internal constant _MAX_STREAMING_FEE_BASIS_POINTS = 300; // 3%\\n    uint internal constant _MAX_STREAMING_FEE_BASIS_POINTS_STEP = 50; // 0.5%\\n    uint internal constant _MAX_PERFORMANCE_FEE_BASIS_POINTS = 4000; // 40%\\n    uint internal constant _MAX_PERFORMANCE_FEE_BASIS_POINTS_STEP = 1000; // 10%\\n    uint internal constant _FEE_ANNOUNCE_WINDOW = 30 days;\\n\\n    event FeeIncreaseAnnounced(uint streamingFee, uint performanceFee);\\n    event FeeIncreaseCommitted(uint streamingFee, uint performanceFee);\\n    event FeeIncreaseRenounced();\\n\\n    function initialize(\\n        uint _managerStreamingFeeBasisPoints,\\n        uint _managerPerformanceFeeBasisPoints\\n    ) internal {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        l.managerStreamingFee = _managerStreamingFeeBasisPoints;\\n        l.managerPerformanceFee = _managerPerformanceFeeBasisPoints;\\n    }\\n\\n    function _announceFeeIncrease(\\n        uint256 newStreamingFee,\\n        uint256 newPerformanceFee\\n    ) internal {\\n        require(\\n            newStreamingFee <= _MAX_STREAMING_FEE_BASIS_POINTS,\\n            'streamingFee to high'\\n        );\\n\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        require(\\n            newStreamingFee <=\\n                l.managerStreamingFee + _MAX_STREAMING_FEE_BASIS_POINTS_STEP,\\n            'streamingFee step exceeded'\\n        );\\n        require(\\n            newPerformanceFee <= _MAX_PERFORMANCE_FEE_BASIS_POINTS,\\n            'performanceFee to high'\\n        );\\n        require(\\n            newPerformanceFee <=\\n                l.managerPerformanceFee +\\n                    _MAX_PERFORMANCE_FEE_BASIS_POINTS_STEP,\\n            'performanceFee step exceeded'\\n        );\\n\\n        l.announcedFeeIncreaseTimestamp = block.timestamp;\\n        l.announcedManagerStreamingFee = newStreamingFee;\\n        l.announcedManagerPerformanceFee = newPerformanceFee;\\n        emit FeeIncreaseAnnounced(newStreamingFee, newPerformanceFee);\\n    }\\n\\n    function _renounceFeeIncrease() internal {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        require(\\n            l.announcedFeeIncreaseTimestamp != 0,\\n            'no fee increase announced'\\n        );\\n\\n        l.announcedFeeIncreaseTimestamp = 0;\\n        l.announcedManagerStreamingFee = 0;\\n        l.announcedManagerPerformanceFee = 0;\\n\\n        emit FeeIncreaseRenounced();\\n    }\\n\\n    function _commitFeeIncrease() internal {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        require(\\n            l.announcedFeeIncreaseTimestamp != 0,\\n            'no fee increase announced'\\n        );\\n        require(\\n            block.timestamp >=\\n                l.announcedFeeIncreaseTimestamp + _FEE_ANNOUNCE_WINDOW,\\n            'fee delay active'\\n        );\\n\\n        l.managerStreamingFee = l.announcedManagerStreamingFee;\\n        l.managerPerformanceFee = l.announcedManagerPerformanceFee;\\n\\n        l.announcedFeeIncreaseTimestamp = 0;\\n        l.announcedManagerStreamingFee = 0;\\n        l.announcedManagerPerformanceFee = 0;\\n\\n        emit FeeIncreaseCommitted(\\n            l.managerStreamingFee,\\n            l.managerPerformanceFee\\n        );\\n    }\\n\\n    function _managerPerformanceFee() internal view returns (uint) {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        return l.managerPerformanceFee;\\n    }\\n\\n    function _managerStreamingFee() internal view returns (uint) {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        return l.managerStreamingFee;\\n    }\\n\\n    function _announcedManagerPerformanceFee() internal view returns (uint) {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        return l.announcedManagerPerformanceFee;\\n    }\\n\\n    function _announcedManagerStreamingFee() internal view returns (uint) {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n        return l.announcedManagerStreamingFee;\\n    }\\n\\n    function _announcedFeeIncreaseTimestamp() internal view returns (uint) {\\n        VaultFeesStorage.Layout storage l = VaultFeesStorage.layout();\\n\\n        return l.announcedFeeIncreaseTimestamp;\\n    }\\n\\n    function _streamingFee(\\n        uint fee,\\n        uint discount,\\n        uint lastFeeTime,\\n        uint totalShares,\\n        uint timeNow\\n    ) internal pure returns (uint tokensOwed) {\\n        if (lastFeeTime >= timeNow) {\\n            return 0;\\n        }\\n\\n        uint discountAdjustment = Constants.BASIS_POINTS_DIVISOR - discount;\\n        uint timeSinceLastFee = timeNow - lastFeeTime;\\n        tokensOwed =\\n            (totalShares * fee * timeSinceLastFee * discountAdjustment) /\\n            _STEAMING_FEE_DURATION /\\n            Constants.BASIS_POINTS_DIVISOR /\\n            Constants.BASIS_POINTS_DIVISOR;\\n    }\\n\\n    function _performanceFee(\\n        uint fee,\\n        uint discount,\\n        uint totalShares,\\n        uint tokenPriceStart,\\n        uint tokenPriceFinish\\n    ) internal pure returns (uint tokensOwed) {\\n        if (tokenPriceFinish <= tokenPriceStart) {\\n            return 0;\\n        }\\n\\n        uint discountAdjustment = Constants.BASIS_POINTS_DIVISOR - discount;\\n        uint priceIncrease = tokenPriceFinish - (tokenPriceStart);\\n        tokensOwed =\\n            (priceIncrease * fee * totalShares * discountAdjustment) /\\n            tokenPriceStart /\\n            Constants.BASIS_POINTS_DIVISOR /\\n            Constants.BASIS_POINTS_DIVISOR;\\n    }\\n\\n    function _protocolFee(uint managerFees) internal pure returns (uint) {\\n        return\\n            (managerFees * _PROTOCOL_FEE_BASIS_POINTS) /\\n            Constants.BASIS_POINTS_DIVISOR;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-fees/VaultFeesStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary VaultFeesStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.VaultFees');\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        uint managerStreamingFee;\\n        uint managerPerformanceFee;\\n        uint announcedFeeIncreaseTimestamp;\\n        uint announcedManagerStreamingFee;\\n        uint announcedManagerPerformanceFee;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-ownership/VaultOwnershipInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { VaultFees } from '../vault-fees/VaultFees.sol';\\nimport { VaultOwnershipStorage } from './VaultOwnershipStorage.sol';\\n\\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\\nimport { ERC721BaseInternal, ERC165Base } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\\n\\nimport { ERC165BaseStorage } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\\n\\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\\n\\nimport { Constants } from '../lib/Constants.sol';\\n\\ncontract VaultOwnershipInternal is\\n    ERC721BaseInternal, //ERC165BaseInternal causes Linearization issue in vaultParentErc721\\n    VaultFees\\n{\\n    uint internal constant _MANAGER_TOKEN_ID = 0;\\n    uint internal constant _PROTOCOL_TOKEN_ID = 1;\\n\\n    uint internal constant BURN_LOCK_TIME = 24 hours;\\n\\n    event FeesLevied(\\n        uint tokenId,\\n        uint streamingFees,\\n        uint performanceFees,\\n        uint currentUnitPrice\\n    );\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        address _manager,\\n        uint _managerStreamingFeeBasisPoints,\\n        uint _managerPerformanceFeeBasisPoints,\\n        address _protocolAddress\\n    ) internal {\\n        super.initialize(\\n            _managerStreamingFeeBasisPoints,\\n            _managerPerformanceFeeBasisPoints\\n        );\\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\\n        l.name = _name;\\n        l.symbol = _symbol;\\n\\n        _createManagerHolding(_manager);\\n        _createProtocolHolding(_protocolAddress);\\n    }\\n\\n    function _mint(address to) internal returns (uint256 tokenId) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        tokenId = l._tokenIdCounter;\\n        _safeMint(to, tokenId);\\n        l._tokenIdCounter++;\\n    }\\n\\n    function _createManagerHolding(address manager) internal {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n\\n        require(\\n            _exists(_MANAGER_TOKEN_ID) == false,\\n            'manager holding already exists'\\n        );\\n        require(\\n            l._tokenIdCounter == _MANAGER_TOKEN_ID,\\n            'manager holding must be token 0'\\n        );\\n        _mint(manager);\\n    }\\n\\n    function _createProtocolHolding(address protocolTreasury) internal {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n\\n        require(\\n            _exists(_PROTOCOL_TOKEN_ID) == false,\\n            'protcool holding already exists'\\n        );\\n        require(\\n            l._tokenIdCounter == _PROTOCOL_TOKEN_ID,\\n            'protocol holding must be token 1'\\n        );\\n        _mint(protocolTreasury);\\n    }\\n\\n    function _issueShares(\\n        uint tokenId,\\n        address owner,\\n        uint shares,\\n        uint currentUnitPrice,\\n        uint lockupTime\\n    ) internal returns (uint) {\\n        // Managers cannot deposit directly into their holding, they can only accrue fees there.\\n        // Users or the Manger can pass tokenId == 0 and it will create a new holding for them.\\n        require(_exists(tokenId), 'token does not exist');\\n\\n        if (tokenId == _MANAGER_TOKEN_ID) {\\n            tokenId = _mint(owner);\\n        }\\n\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n\\n        if (holding.totalShares == 0) {\\n            holding.streamingFee = _managerStreamingFee();\\n            holding.performanceFee = _managerPerformanceFee();\\n            holding.lastStreamingFeeTime = block.timestamp;\\n            holding.lastPerformanceFeeUnitPrice = currentUnitPrice;\\n            holding.averageEntryPrice = currentUnitPrice;\\n        } else {\\n            _levyFees(tokenId, currentUnitPrice);\\n            holding.averageEntryPrice = _calculateAverageEntryPrice(\\n                holding.totalShares,\\n                holding.averageEntryPrice,\\n                shares,\\n                currentUnitPrice\\n            );\\n        }\\n\\n        l.totalShares += shares;\\n        holding.unlockTime = block.timestamp + lockupTime;\\n        holding.totalShares += shares;\\n\\n        return tokenId;\\n    }\\n\\n    function _burnShares(\\n        uint tokenId,\\n        uint shares,\\n        uint currentUnitPrice\\n    ) internal {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n        require(!_holdingLocked(tokenId), 'locked');\\n        _levyFees(tokenId, currentUnitPrice);\\n        require(shares <= holding.totalShares, 'not enough shares');\\n        holding.lastBurnTime = block.timestamp;\\n        holding.totalShares -= shares;\\n        l.totalShares -= shares;\\n    }\\n\\n    function _levyFees(uint tokenId, uint currentUnitPrice) internal {\\n        if (isSystemToken(tokenId)) {\\n            return;\\n        }\\n\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n\\n        (uint streamingFees, uint performanceFees) = _levyFeesOnHolding(\\n            tokenId,\\n            _managerStreamingFee(),\\n            _managerPerformanceFee(),\\n            currentUnitPrice\\n        );\\n\\n        emit FeesLevied(\\n            tokenId,\\n            streamingFees,\\n            performanceFees,\\n            currentUnitPrice\\n        );\\n\\n        uint totalManagerFees = streamingFees + performanceFees;\\n\\n        uint protocolFees = _protocolFee(streamingFees + performanceFees);\\n        uint managerFees = totalManagerFees - protocolFees;\\n        require(protocolFees + managerFees == totalManagerFees, 'fee math');\\n\\n        l.holdings[_PROTOCOL_TOKEN_ID].totalShares += protocolFees;\\n        l.holdings[_MANAGER_TOKEN_ID].totalShares += managerFees;\\n    }\\n\\n    function _levyFeesOnHolding(\\n        uint tokenId,\\n        uint newStreamingFee,\\n        uint newPerformanceFee,\\n        uint currentUnitPrice\\n    ) internal returns (uint streamingFees, uint performanceFees) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n\\n        uint initialTotalShares = holding.totalShares;\\n\\n        holding.lastManagerFeeLevyTime = block.timestamp;\\n\\n        (streamingFees, performanceFees) = _calculateUnpaidFees(\\n            tokenId,\\n            currentUnitPrice\\n        );\\n\\n        if (streamingFees > 0 || holding.streamingFee != newStreamingFee) {\\n            holding.lastStreamingFeeTime = block.timestamp;\\n        }\\n\\n        if (\\n            performanceFees > 0 || holding.performanceFee != newPerformanceFee\\n        ) {\\n            holding.lastPerformanceFeeUnitPrice = currentUnitPrice;\\n        }\\n\\n        holding.totalShares -= streamingFees + performanceFees;\\n\\n        if (holding.streamingFee != newStreamingFee) {\\n            holding.streamingFee = newStreamingFee;\\n        }\\n\\n        if (holding.performanceFee != newPerformanceFee) {\\n            holding.performanceFee = newPerformanceFee;\\n        }\\n\\n        require(\\n            holding.totalShares + streamingFees + performanceFees ==\\n                initialTotalShares,\\n            'check failed'\\n        );\\n\\n        return (streamingFees, performanceFees);\\n    }\\n\\n    function _setDiscountForHolding(\\n        uint tokenId,\\n        uint streamingFeeDiscount,\\n        uint performanceFeeDiscount\\n    ) internal {\\n        require(\\n            streamingFeeDiscount <= Constants.BASIS_POINTS_DIVISOR,\\n            'invalid streamingFeeDiscount'\\n        );\\n        require(\\n            performanceFeeDiscount <= Constants.BASIS_POINTS_DIVISOR,\\n            'invalid performanceFeeDiscount'\\n        );\\n\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n\\n        holding.streamingFeeDiscount = streamingFeeDiscount;\\n        holding.performanceFeeDiscount = performanceFeeDiscount;\\n    }\\n\\n    function _holdings(\\n        uint tokenId\\n    ) internal view returns (VaultOwnershipStorage.Holding memory) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        return l.holdings[tokenId];\\n    }\\n\\n    function _holdingLocked(uint tokenId) internal view returns (bool) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n        if (block.timestamp < holding.unlockTime) {\\n            return true;\\n        }\\n        if (block.timestamp < holding.lastBurnTime + BURN_LOCK_TIME) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _totalShares() internal view returns (uint) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        return l.totalShares;\\n    }\\n\\n    function _calculateUnpaidFees(\\n        uint tokenId,\\n        uint currentUnitPrice\\n    ) internal view returns (uint streamingFees, uint performanceFees) {\\n        VaultOwnershipStorage.Layout storage l = VaultOwnershipStorage.layout();\\n        VaultOwnershipStorage.Holding storage holding = l.holdings[tokenId];\\n\\n        uint initialTotalShares = holding.totalShares;\\n\\n        streamingFees = _streamingFee(\\n            holding.streamingFee,\\n            holding.streamingFeeDiscount,\\n            holding.lastStreamingFeeTime,\\n            initialTotalShares,\\n            block.timestamp\\n        );\\n\\n        performanceFees = _performanceFee(\\n            holding.performanceFee,\\n            holding.performanceFeeDiscount,\\n            // We levy performance fees after levying streamingFees\\n            initialTotalShares - streamingFees,\\n            holding.lastPerformanceFeeUnitPrice,\\n            currentUnitPrice\\n        );\\n    }\\n\\n    function _calculateAverageEntryPrice(\\n        uint currentShares,\\n        uint previousPrice,\\n        uint newShares,\\n        uint newPrice\\n    ) internal pure returns (uint) {\\n        return\\n            ((currentShares * previousPrice) + (newShares * newPrice)) /\\n            (currentShares + newShares);\\n    }\\n\\n    function isSystemToken(uint tokenId) internal pure returns (bool) {\\n        return tokenId == _PROTOCOL_TOKEN_ID || tokenId == _MANAGER_TOKEN_ID;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-ownership/VaultOwnershipStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary VaultOwnershipStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.VaultOwnership');\\n\\n    // TODO: Move to interface\\n    // solhint-disable-next-line ordering\\n    struct Holding {\\n        uint totalShares;\\n        uint lastStreamingFeeTime;\\n        uint lastPerformanceFeeUnitPrice;\\n        uint streamingFeeDiscount;\\n        uint performanceFeeDiscount;\\n        uint streamingFee;\\n        uint performanceFee;\\n        uint unlockTime;\\n        uint averageEntryPrice;\\n        uint lastManagerFeeLevyTime;\\n        uint lastBurnTime;\\n    }\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        // The manager is issued token 0; The protocol is issued token 1; all other tokens are issued to investors\\n        // All fees are levied to token 0 and a portion to token 1;\\n        // tokenId to Holding\\n        mapping(uint => Holding) holdings;\\n        uint totalShares;\\n        uint256 _tokenIdCounter;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/IVaultParentInvestor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.4;\\n\\ninterface IVaultParentInvestor {\\n    function withdrawMultiChain(\\n        uint tokenId,\\n        uint amount,\\n        uint[] memory lzFees\\n    ) external;\\n\\n    function withdrawAllMultiChain(uint tokenId, uint[] memory lzFees) external;\\n\\n    function requestTotalValueUpdateMultiChain(uint[] memory lzFees) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/IVaultParentManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.4;\\n\\ninterface IVaultParentManager {\\n    function requestBridgeToChain(\\n        uint16 dstChainId,\\n        address asset,\\n        uint256 amount,\\n        uint256 minAmountOut,\\n        uint lzFee\\n    ) external payable;\\n\\n    function requestCreateChild(uint16 newChainId, uint lzFee) external payable;\\n\\n    function sendBridgeApproval(uint16 dstChainId, uint lzFee) external payable;\\n\\n    function changeManagerMultiChain(\\n        address newManager,\\n        uint[] memory lzFees\\n    ) external payable;\\n\\n    function setDiscountForHolding(\\n        uint256 tokenId,\\n        uint256 streamingFeeDiscount,\\n        uint256 performanceFeeDiscount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { VaultParentTransport } from './VaultParentTransport.sol';\\nimport { VaultParentInvestor } from './VaultParentInvestor.sol';\\nimport { VaultParentManager } from './VaultParentManager.sol';\\nimport { VaultParentErc721 } from './VaultParentErc721.sol';\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\nimport { VaultBaseExternal } from '../vault-base/VaultBaseExternal.sol';\\nimport { IRedeemerEvents } from '../redeemers/IRedeemerEvents.sol';\\nimport { IExecutorEvents } from '../executors/IExecutorEvents.sol';\\n\\nimport { ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\\n\\nimport { SolidStateERC721 } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\\nimport { ERC721BaseInternal, ERC165Base } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\\n\\n// Not deployed directly as It's to large\\n// ONLY used to generate the ABI and for test interface\\ncontract VaultParent is\\n    VaultParentInvestor,\\n    VaultParentErc721,\\n    VaultParentManager,\\n    VaultParentTransport,\\n    VaultBaseExternal,\\n    IRedeemerEvents,\\n    IExecutorEvents\\n{\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal override(VaultParentErc721, VaultParentInternal) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external approve function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override(VaultParentErc721, ERC721BaseInternal) {\\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\\n        super._handleApproveMessageValue(operator, tokenId, value);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external transfer function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override(VaultParentErc721, ERC721BaseInternal) {\\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\\n        super._handleTransferMessageValue(from, to, tokenId, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentErc721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\n\\nimport { Constants } from '../lib/Constants.sol';\\n\\nimport { SolidStateERC721, ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\\n\\nimport { ITransport } from '../transport/ITransport.sol';\\nimport { Registry } from '../registry/Registry.sol';\\nimport { RegistryStorage } from '../registry/RegistryStorage.sol';\\nimport { VaultParentStorage } from './VaultParentStorage.sol';\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\nimport { VaultBaseInternal } from '../vault-base/VaultBaseInternal.sol';\\nimport { VaultOwnershipInternal } from '../vault-ownership/VaultOwnershipInternal.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\\n\\ncontract VaultParentErc721 is SolidStateERC721, VaultParentInternal {\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        address _manager,\\n        uint _managerStreamingFeeBasisPoints,\\n        uint _managerPerformanceFeeBasisPoints,\\n        VaultRiskProfile _riskProfile,\\n        Registry _registry\\n    ) external {\\n        require(_vaultId() == 0, 'already initialized');\\n\\n        bytes32 vaultId = keccak256(\\n            abi.encodePacked(_registry.chainId(), address(this))\\n        );\\n        _setVaultId(vaultId);\\n        VaultBaseInternal.initialize(_registry, _manager, _riskProfile);\\n        VaultOwnershipInternal.initialize(\\n            _name,\\n            _symbol,\\n            _manager,\\n            _managerStreamingFeeBasisPoints,\\n            _managerPerformanceFeeBasisPoints,\\n            _registry.protocolTreasury()\\n        );\\n\\n        _setSupportsInterface(type(IERC165).interfaceId, true);\\n        _setSupportsInterface(type(IERC721).interfaceId, true);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override(SolidStateERC721, VaultParentInternal) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external approve function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override(SolidStateERC721, ERC721BaseInternal) {\\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\\n        super._handleApproveMessageValue(operator, tokenId, value);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external transfer function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override(SolidStateERC721, ERC721BaseInternal) {\\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\\n        super._handleTransferMessageValue(from, to, tokenId, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { VaultBaseInternal } from '../vault-base/VaultBaseInternal.sol';\\nimport { VaultOwnershipInternal } from '../vault-ownership/VaultOwnershipInternal.sol';\\nimport { Registry } from '../registry/Registry.sol';\\nimport { VaultParentStorage } from './VaultParentStorage.sol';\\nimport { IVaultParentManager } from './IVaultParentManager.sol';\\nimport { IVaultParentInvestor } from './IVaultParentInvestor.sol';\\n\\nimport { ITransport, GasFunctionType } from '../transport/ITransport.sol';\\n\\nimport { Constants } from '../lib/Constants.sol';\\n\\ncontract VaultParentInternal is VaultOwnershipInternal, VaultBaseInternal {\\n    modifier noBridgeInProgress() {\\n        require(!_bridgeInProgress(), 'bridge in progress');\\n        _;\\n    }\\n\\n    modifier noWithdrawInProgress() {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        require(!_withdrawInProgress(), 'withdraw in progress');\\n        _;\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        // If minting just return\\n        if (from == address(0)) {\\n            return;\\n        }\\n        // When using changeManager(), allow transfer to new manager\\n        if (tokenId == _MANAGER_TOKEN_ID) {\\n            require(to == _manager(), 'must use changeManager');\\n            return;\\n        }\\n\\n        revert('transfers disabled');\\n    }\\n\\n    function _withdrawInProgress() internal view returns (bool) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        return l.withdrawsInProgress > 0;\\n    }\\n\\n    function _bridgeInProgress() internal view returns (bool) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        return l.bridgeInProgress;\\n    }\\n\\n    function _bridgeApprovedFor() internal view returns (uint16) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        return l.bridgeApprovedFor;\\n    }\\n\\n    function _hasActiveChildren() internal view returns (bool) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            if (!_childIsInactive(l.childChains[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _getLzFee(\\n        bytes4 sigHash,\\n        uint16 chainId\\n    ) internal view returns (uint fee) {\\n        if (sigHash == IVaultParentManager.requestBridgeToChain.selector) {\\n            fee = _bridgeQuote(chainId);\\n        } else if (sigHash == IVaultParentManager.requestCreateChild.selector) {\\n            (fee, ) = _registry().transport().getLzFee(\\n                GasFunctionType.createChildRequiresReturnMessage,\\n                chainId\\n            );\\n        } else if (\\n            sigHash ==\\n            IVaultParentInvestor.requestTotalValueUpdateMultiChain.selector\\n        ) {\\n            if (_childIsInactive(chainId)) {\\n                return 0;\\n            }\\n            (fee, ) = _registry().transport().getLzFee(\\n                GasFunctionType.getVaultValueRequiresReturnMessage,\\n                chainId\\n            );\\n        } else if (\\n            sigHash == IVaultParentInvestor.withdrawMultiChain.selector ||\\n            sigHash == IVaultParentInvestor.withdrawAllMultiChain.selector\\n        ) {\\n            if (_childIsInactive(chainId)) {\\n                return 0;\\n            }\\n            (fee, ) = _registry().transport().getLzFee(\\n                GasFunctionType.withdrawRequiresReturnMessage,\\n                chainId\\n            );\\n        } else {\\n            (fee, ) = _registry().transport().getLzFee(\\n                GasFunctionType.standardNoReturnMessage,\\n                chainId\\n            );\\n        }\\n    }\\n\\n    function _getLzFeesMultiChain(\\n        bytes4 sigHash,\\n        uint16[] memory chainIds\\n    ) internal view returns (uint[] memory fees, uint256 totalSendFee) {\\n        fees = new uint[](chainIds.length);\\n        for (uint i = 0; i < chainIds.length; i++) {\\n            fees[i] = _getLzFee(sigHash, chainIds[i]);\\n            totalSendFee += fees[i];\\n        }\\n    }\\n\\n    function _bridgeQuote(uint16 dstChainId) internal view returns (uint fee) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        address dstVault = l.children[dstChainId];\\n        require(dstVault != address(0), 'no dst vault');\\n\\n        fee = _registry().transport().getBridgeAssetQuote(\\n            dstChainId,\\n            dstVault,\\n            _registry().chainId(),\\n            address(this)\\n        );\\n    }\\n\\n    function _childIsInactive(uint16 chainId) internal view returns (bool) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        return l.childIsInactive[chainId];\\n    }\\n\\n    function _inSync() internal view returns (bool) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            if (_childIsInactive(l.childChains[i])) {\\n                continue;\\n            }\\n            if (_isNotStale(l.chainTotalValues[l.childChains[i]].lastUpdate)) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function _totalValueAcrossAllChains()\\n        internal\\n        view\\n        returns (uint minValue, uint maxValue)\\n    {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        (uint minVaultValue, uint maxVaultValue) = _getVaultValue();\\n\\n        minValue += minVaultValue;\\n        maxValue += maxVaultValue;\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            if (_childIsInactive(l.childChains[i])) {\\n                continue;\\n            }\\n            require(\\n                _isNotStale(l.chainTotalValues[l.childChains[i]].lastUpdate),\\n                'stale'\\n            );\\n            minValue += l.chainTotalValues[l.childChains[i]].minValue;\\n            maxValue += l.chainTotalValues[l.childChains[i]].maxValue;\\n        }\\n    }\\n\\n    function _unitPrice() internal view returns (uint minPrice, uint maxPrice) {\\n        (uint minValue, uint maxValue) = _totalValueAcrossAllChains();\\n        minPrice = _unitPrice(minValue, _totalShares());\\n        maxPrice = _unitPrice(maxValue, _totalShares());\\n    }\\n\\n    function _childChains(uint index) internal view returns (uint16 chainId) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        return l.childChains[index];\\n    }\\n\\n    function _allChildChains() internal view returns (uint16[] memory) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        return l.childChains;\\n    }\\n\\n    function _children(uint16 chainId) internal view returns (address) {\\n        return VaultParentStorage.layout().children[chainId];\\n    }\\n\\n    function _timeUntilExpiry() internal view returns (uint) {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        uint timeTillExpiry;\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            uint expiryTime = _timeUntilExpiry(\\n                l.chainTotalValues[l.childChains[i]].lastUpdate\\n            );\\n            // The shortest expiry time is the time until expiry\\n            if (expiryTime == 0) {\\n                return 0;\\n            } else {\\n                if (expiryTime < timeTillExpiry || timeTillExpiry == 0) {\\n                    timeTillExpiry = expiryTime;\\n                }\\n            }\\n        }\\n        return timeTillExpiry;\\n    }\\n\\n    function _timeUntilExpiry(uint lastUpdate) internal view returns (uint) {\\n        uint expiry = lastUpdate + _registry().livelinessThreshold();\\n        if (expiry > block.timestamp) {\\n            return expiry - block.timestamp;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _isNotStale(uint lastUpdate) internal view returns (bool) {\\n        return lastUpdate > block.timestamp - _registry().livelinessThreshold();\\n    }\\n\\n    function _unitPrice(\\n        uint totalValueAcrossAllChains,\\n        uint totalShares\\n    ) internal pure returns (uint price) {\\n        price =\\n            (totalValueAcrossAllChains * Constants.VAULT_PRECISION) /\\n            totalShares;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentInvestor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { ITransport } from '../transport/ITransport.sol';\\nimport { Registry } from '../registry/Registry.sol';\\nimport { Constants } from '../lib/Constants.sol';\\nimport { RegistryStorage } from '../registry/RegistryStorage.sol';\\nimport { VaultParentStorage } from './VaultParentStorage.sol';\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\nimport { VaultBaseInternal } from '../vault-base/VaultBaseInternal.sol';\\nimport { VaultOwnershipInternal } from '../vault-ownership/VaultOwnershipInternal.sol';\\nimport { VaultRiskProfile } from '../vault-base/IVaultRiskProfile.sol';\\n\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\n\\ncontract VaultParentInvestor is VaultParentInternal {\\n    using SafeERC20 for IERC20;\\n\\n    event Deposit(\\n        address depositer,\\n        uint tokenId,\\n        address asset,\\n        uint amount,\\n        uint currentUnitPrice,\\n        uint shares\\n    );\\n\\n    event WithdrawMultiChain(\\n        address withdrawer,\\n        uint tokenId,\\n        uint portion,\\n        uint currentUnitPrice,\\n        uint shares\\n    );\\n\\n    modifier isInSync() {\\n        require(_inSync(), 'not synced');\\n        _;\\n    }\\n\\n    function requestTotalValueUpdateMultiChain(\\n        uint[] memory lzFees\\n    ) external payable noBridgeInProgress noWithdrawInProgress whenNotPaused {\\n        _requestTotalValueUpdateMultiChain(lzFees);\\n    }\\n\\n    function deposit(\\n        uint tokenId,\\n        address asset,\\n        uint amount\\n    ) external noBridgeInProgress isInSync whenNotPaused nonReentrant {\\n        _deposit(tokenId, asset, amount);\\n    }\\n\\n    function withdrawMultiChain(\\n        uint tokenId,\\n        uint amount,\\n        uint[] memory lzFees\\n    ) external payable noBridgeInProgress whenNotPaused nonReentrant {\\n        _withdrawMultiChain(tokenId, amount, lzFees);\\n    }\\n\\n    function withdrawAllMultiChain(\\n        uint tokenId,\\n        uint[] memory lzFees\\n    )\\n        external\\n        payable\\n        noWithdrawInProgress\\n        noBridgeInProgress\\n        whenNotPaused\\n        nonReentrant\\n    {\\n        _withdrawAll(tokenId, lzFees);\\n    }\\n\\n    function getLzFee(\\n        bytes4 sigHash,\\n        uint16 chainId\\n    ) external view returns (uint fee) {\\n        return _getLzFee(sigHash, chainId);\\n    }\\n\\n    function getLzFeesMultiChain(\\n        bytes4 sigHash\\n    ) external view returns (uint[] memory lzFees, uint256 totalSendFee) {\\n        return _getLzFeesMultiChain(sigHash, _allChildChains());\\n    }\\n\\n    function childChains(uint index) external view returns (uint16) {\\n        return _childChains(index);\\n    }\\n\\n    function children(uint16 chainId) external view returns (address) {\\n        return _children(chainId);\\n    }\\n\\n    function allChildChains() external view returns (uint16[] memory) {\\n        return _allChildChains();\\n    }\\n\\n    function totalValueAcrossAllChains()\\n        external\\n        view\\n        returns (uint minValue, uint maxValue)\\n    {\\n        return _totalValueAcrossAllChains();\\n    }\\n\\n    function inSync() external view returns (bool) {\\n        return _inSync();\\n    }\\n\\n    function withdrawInProgress() external view returns (bool) {\\n        return _withdrawInProgress();\\n    }\\n\\n    function requiresSyncForWithdraw(\\n        uint tokenId\\n    ) external view returns (bool) {\\n        return _requiresSyncForWithdraw(tokenId);\\n    }\\n\\n    function requiresSyncForDeposit() external view returns (bool) {\\n        return _requiresSyncForDeposit();\\n    }\\n\\n    // Returns the number of seconds until the totalValueSync expires\\n    function timeUntilExpiry() external view returns (uint) {\\n        return _timeUntilExpiry();\\n    }\\n\\n    function holdingLocked(uint tokenId) external view returns (bool) {\\n        return _holdingLocked(tokenId);\\n    }\\n\\n    ///\\n    /// Internal\\n    ///\\n\\n    function _deposit(uint tokenId, address asset, uint amount) internal {\\n        require(_registry().depositAssets(asset), 'not deposit asset');\\n        require(\\n            _registry().allowedInvestors(msg.sender),\\n            'investor not allowed'\\n        );\\n        (, uint maxVaultValue) = _totalValueAcrossAllChains();\\n        uint totalShares = _totalShares();\\n\\n        if (totalShares > 0 && maxVaultValue == 0) {\\n            // This means all the shares issue are currently worthless\\n            // We can't issue anymore shares\\n            revert('vault closed');\\n        }\\n        (uint depositValueInUSD, ) = _registry().accountant().assetValue(\\n            asset,\\n            amount\\n        );\\n\\n        require(\\n            maxVaultValue + depositValueInUSD <= _registry().vaultValueCap(),\\n            'vault will exceed cap'\\n        );\\n\\n        // if tokenId == 0 means were creating a new holding\\n        if (tokenId == 0) {\\n            require(\\n                depositValueInUSD >= _registry().minDepositAmount(),\\n                'min deposit not met'\\n            );\\n        }\\n\\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\\n        _updateActiveAsset(asset);\\n\\n        uint shares;\\n        uint currentUnitPrice;\\n        if (totalShares == 0) {\\n            shares = depositValueInUSD;\\n            // We should debate if the base unit of the vaults is to be 10**18 or 10**8.\\n            // 10**8 is the natural unit for USD (which is what the unitPrice is denominated in),\\n            // but 10**18 gives us more precision when it comes to leveling fees.\\n            currentUnitPrice = _unitPrice(depositValueInUSD, shares);\\n        } else {\\n            shares = (depositValueInUSD * totalShares) / maxVaultValue;\\n            // Don't used unitPrice() because it will encorporate the deposited funds, but shares haven't been issue yet\\n            currentUnitPrice = _unitPrice(maxVaultValue, totalShares);\\n        }\\n\\n        uint issuedToTokenId = _issueShares(\\n            tokenId,\\n            msg.sender,\\n            shares,\\n            currentUnitPrice,\\n            _registry().depositLockupTime()\\n        );\\n\\n        emit Deposit(\\n            msg.sender,\\n            issuedToTokenId,\\n            asset,\\n            amount,\\n            currentUnitPrice,\\n            shares\\n        );\\n        _registry().emitEvent();\\n    }\\n\\n    function _withdrawAll(uint tokenId, uint[] memory lzFees) internal {\\n        (uint minPrice, ) = _unitPrice();\\n        _levyFees(tokenId, minPrice);\\n        _withdrawMultiChain(tokenId, _holdings(tokenId).totalShares, lzFees);\\n    }\\n\\n    function _withdrawMultiChain(\\n        uint tokenId,\\n        uint amount,\\n        uint[] memory lzFees\\n    ) internal {\\n        address owner = _ownerOf(tokenId);\\n        require(\\n            msg.sender == owner ||\\n                msg.sender == _registry().withdrawAutomator(),\\n            'not allowed'\\n        );\\n\\n        uint portion = (amount * Constants.PORTION_DIVISOR) / _totalShares();\\n        uint minUnitPrice;\\n\\n        // If a Manager is not charging a performance fee we do not need the currentUnitPrice\\n        // To process a withdraw, because all withdraws are porpotional.\\n        // I don't really like smuggling this logic in here at this level\\n        // But it means that if a manager isn't charging a performanceFee then we don't have to impose a totalValueSync\\n        if (!_inSync() && !_requiresUnitPrice(tokenId)) {\\n            minUnitPrice = 0;\\n        } else {\\n            // This will revert if the vault is not in sync\\n            (minUnitPrice, ) = _unitPrice();\\n        }\\n        _burnShares(tokenId, amount, minUnitPrice);\\n        _withdraw(tokenId, owner, portion);\\n        _sendWithdrawRequestsToChildrenMultiChain(\\n            tokenId,\\n            owner,\\n            portion,\\n            lzFees\\n        );\\n\\n        emit WithdrawMultiChain(owner, tokenId, portion, minUnitPrice, amount);\\n        _registry().emitEvent();\\n    }\\n\\n    ///\\n    /// Cross Chain Requests\\n    ///\\n\\n    function _requestTotalValueUpdateMultiChain(uint[] memory lzFees) internal {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        uint totalFees;\\n\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            if (_childIsInactive(l.childChains[i])) {\\n                require(lzFees[i] == 0, 'no fee required');\\n                continue;\\n            }\\n            totalFees += lzFees[i];\\n            uint16 childChainId = l.childChains[i];\\n\\n            _registry().transport().sendValueUpdateRequest{ value: lzFees[i] }(\\n                ITransport.ValueUpdateRequest({\\n                    parentChainId: _registry().chainId(),\\n                    parentVault: address(this),\\n                    child: ITransport.ChildVault({\\n                        vault: l.children[childChainId],\\n                        chainId: childChainId\\n                    })\\n                })\\n            );\\n        }\\n\\n        require(msg.value >= totalFees, 'insufficient fee sent');\\n    }\\n\\n    function _sendWithdrawRequestsToChildrenMultiChain(\\n        uint tokenId,\\n        address withdrawer,\\n        uint portion,\\n        uint[] memory lzFees\\n    ) internal {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        uint totalFees;\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            if (_childIsInactive(l.childChains[i])) {\\n                require(lzFees[i] == 0, 'no fee required');\\n                continue;\\n            }\\n            totalFees += lzFees[i];\\n            _sendWithdrawRequest(\\n                l.childChains[i],\\n                tokenId,\\n                withdrawer,\\n                portion,\\n                lzFees[i]\\n            );\\n        }\\n        require(msg.value >= totalFees, 'insufficient fee');\\n    }\\n\\n    function _sendWithdrawRequest(\\n        uint16 dstChainId,\\n        uint tokenId,\\n        address withdrawer,\\n        uint portion,\\n        uint sendFee\\n    ) internal {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        l.withdrawsInProgress++;\\n        _registry().transport().sendWithdrawRequest{ value: sendFee }(\\n            ITransport.WithdrawRequest({\\n                parentChainId: _registry().chainId(),\\n                parentVault: address(this),\\n                child: ITransport.ChildVault({\\n                    chainId: dstChainId,\\n                    vault: l.children[dstChainId]\\n                }),\\n                tokenId: tokenId,\\n                withdrawer: withdrawer,\\n                portion: portion\\n            })\\n        );\\n    }\\n\\n    function _requiresUnitPrice(uint tokenId) internal view returns (bool) {\\n        if (isSystemToken(tokenId)) {\\n            return false;\\n        }\\n        if (\\n            (_managerPerformanceFee() == 0 &&\\n                _holdings(tokenId).performanceFee == 0)\\n        ) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function _requiresSyncForWithdraw(\\n        uint tokenId\\n    ) internal view returns (bool) {\\n        if (!_hasActiveChildren() || !_requiresUnitPrice(tokenId)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    function _requiresSyncForDeposit() internal view returns (bool) {\\n        if (!_hasActiveChildren()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { ITransport } from '../transport/ITransport.sol';\\nimport { IStargateRouter } from '@layerzerolabs/solidity-examples/contracts/interfaces/IStargateRouter.sol';\\nimport { VaultParentStorage } from './VaultParentStorage.sol';\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\nimport { IVaultParentManager } from './IVaultParentManager.sol';\\nimport { Constants } from '../lib/Constants.sol';\\nimport { VaultOwnershipStorage } from '../vault-ownership/VaultOwnershipStorage.sol';\\n\\nimport { IERC20 } from '@solidstate/contracts/interfaces/IERC20.sol';\\nimport { SafeERC20 } from '@solidstate/contracts/utils/SafeERC20.sol';\\n\\ncontract VaultParentManager is VaultParentInternal, IVaultParentManager {\\n    using SafeERC20 for IERC20;\\n\\n    modifier onlyManagerOrTransport() {\\n        require(\\n            msg.sender == _manager() ||\\n                msg.sender == address(_registry().transport()),\\n            'only manager or transport'\\n        );\\n        _;\\n    }\\n\\n    /// Ownership\\n\\n    function setDiscountForHolding(\\n        uint tokenId,\\n        uint streamingFeeDiscount,\\n        uint performanceFeeDiscount\\n    ) external onlyManager whenNotPaused {\\n        _setDiscountForHolding(\\n            tokenId,\\n            streamingFeeDiscount,\\n            performanceFeeDiscount\\n        );\\n    }\\n\\n    function levyFeesOnHoldings(\\n        uint[] memory tokenIds\\n    ) external onlyManager whenNotPaused {\\n        (uint minPrice, ) = _unitPrice();\\n        for (uint i = 0; i < tokenIds.length; i++) {\\n            require(\\n                block.timestamp >=\\n                    _holdings(tokenIds[i]).lastManagerFeeLevyTime + 24 hours,\\n                'already levied this period'\\n            );\\n            _levyFees(tokenIds[i], minPrice);\\n        }\\n        _registry().emitEvent();\\n    }\\n\\n    /// Fees\\n\\n    function announceFeeIncrease(\\n        uint256 newStreamingFee,\\n        uint256 newPerformanceFee\\n    ) external onlyManager whenNotPaused {\\n        require(_registry().canChangeManagerFees(), 'fee change disabled');\\n        _announceFeeIncrease(newStreamingFee, newPerformanceFee);\\n        _registry().emitEvent();\\n    }\\n\\n    function commitFeeIncrease() external onlyManager whenNotPaused {\\n        _commitFeeIncrease();\\n        _registry().emitEvent();\\n    }\\n\\n    function renounceFeeIncrease() external onlyManager whenNotPaused {\\n        _renounceFeeIncrease();\\n        _registry().emitEvent();\\n    }\\n\\n    // Manager Actions\\n\\n    function sendBridgeApproval(\\n        uint16 dstChainId,\\n        uint lzFee\\n    )\\n        external\\n        payable\\n        onlyManager\\n        noBridgeInProgress\\n        whenNotPaused\\n        nonReentrant\\n    {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        require(msg.value >= lzFee, 'insufficient fee');\\n        // If the bridge approval is cancelled the manager is block from initiating another for 1 hour\\n        // This protects users from being ddos'd and not being able to withdraw\\n        // because the manager keeps applying a bridge lock\\n        require(\\n            l.lastBridgeCancellation + 1 hours < block.timestamp,\\n            'bridge approval timeout'\\n        );\\n        address dstVault = l.children[dstChainId];\\n        require(dstVault != address(0), 'no dst vault');\\n        l.bridgeInProgress = true;\\n        l.bridgeApprovedFor = dstChainId;\\n\\n        _registry().transport().sendBridgeApproval{ value: lzFee }(\\n            ITransport.BridgeApprovalRequest({\\n                approvedChainId: dstChainId,\\n                approvedVault: dstVault\\n            })\\n        );\\n    }\\n\\n    function requestBridgeToChain(\\n        uint16 dstChainId,\\n        address asset,\\n        uint amount,\\n        uint minAmountOut,\\n        uint lzFee\\n    )\\n        external\\n        payable\\n        onlyManager\\n        noBridgeInProgress\\n        whenNotPaused\\n        nonReentrant\\n    {\\n        require(msg.value >= lzFee, 'insufficient fee');\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        address dstVault = l.children[dstChainId];\\n        require(dstVault != address(0), 'no dst vault');\\n        l.bridgeInProgress = true;\\n        // Once the manager has bridged we must include the childChains in our total value\\n        l.childIsInactive[dstChainId] = false;\\n        _bridgeAsset(\\n            dstChainId,\\n            dstVault,\\n            _registry().chainId(),\\n            address(this),\\n            asset,\\n            amount,\\n            minAmountOut,\\n            lzFee\\n        );\\n    }\\n\\n    function requestCreateChild(\\n        uint16 newChainId,\\n        uint lzFee\\n    ) external payable onlyManagerOrTransport whenNotPaused nonReentrant {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        require(msg.value >= lzFee, 'insufficient fee');\\n\\n        require(!l.childCreationInProgress, 'sibling creation inprogress');\\n        require(l.children[newChainId] == address(0), 'sibling exists');\\n        require(newChainId != _registry().chainId(), 'not same chain');\\n        l.childCreationInProgress = true;\\n        ITransport.ChildVault[]\\n            memory existingChildren = new ITransport.ChildVault[](\\n                l.childChains.length\\n            );\\n\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            existingChildren[i].chainId = l.childChains[i];\\n            existingChildren[i].vault = l.children[l.childChains[i]];\\n        }\\n        _registry().transport().sendVaultChildCreationRequest{ value: lzFee }(\\n            ITransport.VaultChildCreationRequest({\\n                parentVault: address(this),\\n                parentChainId: _registry().chainId(),\\n                newChainId: newChainId,\\n                manager: _manager(),\\n                riskProfile: _riskProfile(),\\n                children: existingChildren\\n            })\\n        );\\n    }\\n\\n    function changeManagerMultiChain(\\n        address newManager,\\n        uint[] memory lzFees\\n    ) external payable onlyManager whenNotPaused nonReentrant {\\n        require(_registry().canChangeManager(), 'manager change disabled');\\n        require(newManager != address(0), 'invalid newManager');\\n        address oldManager = _manager();\\n        _changeManager(newManager);\\n        _transfer(oldManager, newManager, _MANAGER_TOKEN_ID);\\n        _sendChangeManagerRequestToChildren(newManager, lzFees);\\n    }\\n\\n    function hasActiveChildren() external view returns (bool) {\\n        return _hasActiveChildren();\\n    }\\n\\n    function totalShares() external view returns (uint) {\\n        return _totalShares();\\n    }\\n\\n    function unitPrice() external view returns (uint minPrice, uint maxPrice) {\\n        return _unitPrice();\\n    }\\n\\n    function holdings(\\n        uint tokenId\\n    ) external view returns (VaultOwnershipStorage.Holding memory) {\\n        return _holdings(tokenId);\\n    }\\n\\n    function bridgeInProgress() external view returns (bool) {\\n        return _bridgeInProgress();\\n    }\\n\\n    function bridgeApprovedFor() external view returns (uint16) {\\n        return _bridgeApprovedFor();\\n    }\\n\\n    function calculateUnpaidFees(\\n        uint tokenId,\\n        uint currentUnitPrice\\n    ) external view returns (uint streamingFees, uint performanceFees) {\\n        return _calculateUnpaidFees(tokenId, currentUnitPrice);\\n    }\\n\\n    /// Fees\\n\\n    function managerPerformanceFee() external view returns (uint) {\\n        return _managerPerformanceFee();\\n    }\\n\\n    function managerStreamingFee() external view returns (uint) {\\n        return _managerStreamingFee();\\n    }\\n\\n    function announcedManagerPerformanceFee() external view returns (uint) {\\n        return _announcedManagerPerformanceFee();\\n    }\\n\\n    function announcedManagerStreamingFee() external view returns (uint) {\\n        return _announcedManagerStreamingFee();\\n    }\\n\\n    function announcedFeeIncreaseTimestamp() external view returns (uint) {\\n        return _announcedFeeIncreaseTimestamp();\\n    }\\n\\n    function VAULT_PRECISION() external pure returns (uint) {\\n        return Constants.VAULT_PRECISION;\\n    }\\n\\n    function performanceFee(\\n        uint fee,\\n        uint discount,\\n        uint _totalShares,\\n        uint tokenPriceStart,\\n        uint tokenPriceFinish\\n    ) external pure returns (uint tokensOwed) {\\n        return\\n            _performanceFee(\\n                fee,\\n                discount,\\n                _totalShares,\\n                tokenPriceStart,\\n                tokenPriceFinish\\n            );\\n    }\\n\\n    function streamingFee(\\n        uint fee,\\n        uint discount,\\n        uint lastFeeTime,\\n        uint _totalShares,\\n        uint timeNow\\n    ) external pure returns (uint tokensOwed) {\\n        return _streamingFee(fee, discount, lastFeeTime, _totalShares, timeNow);\\n    }\\n\\n    function protocolFee(uint managerFees) external pure returns (uint) {\\n        return _protocolFee(managerFees);\\n    }\\n\\n    function FEE_ANNOUNCE_WINDOW() external pure returns (uint) {\\n        return _FEE_ANNOUNCE_WINDOW;\\n    }\\n\\n    function MAX_STREAMING_FEE_BASIS_POINTS() external pure returns (uint) {\\n        return _MAX_STREAMING_FEE_BASIS_POINTS;\\n    }\\n\\n    function MAX_STREAMING_FEE_BASIS_POINTS_STEP()\\n        external\\n        pure\\n        returns (uint)\\n    {\\n        return _MAX_STREAMING_FEE_BASIS_POINTS_STEP;\\n    }\\n\\n    function MAX_PERFORMANCE_FEE_BASIS_POINTS() external pure returns (uint) {\\n        return _MAX_PERFORMANCE_FEE_BASIS_POINTS;\\n    }\\n\\n    function STEAMING_FEE_DURATION() external pure returns (uint) {\\n        return _STEAMING_FEE_DURATION;\\n    }\\n\\n    function PROTOCOL_FEE_BASIS_POINTS() external pure returns (uint) {\\n        return _PROTOCOL_FEE_BASIS_POINTS;\\n    }\\n\\n    function MANAGER_TOKEN_ID() external pure returns (uint) {\\n        return _MANAGER_TOKEN_ID;\\n    }\\n\\n    function PROTOCOL_TOKEN_ID() external pure returns (uint) {\\n        return _PROTOCOL_TOKEN_ID;\\n    }\\n\\n    function MAX_PERFORMANCE_FEE_BASIS_POINTS_STEP()\\n        external\\n        pure\\n        returns (uint)\\n    {\\n        return _MAX_PERFORMANCE_FEE_BASIS_POINTS_STEP;\\n    }\\n\\n    function _sendChangeManagerRequestToChildren(\\n        address newManager,\\n        uint[] memory lzFees\\n    ) internal {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        uint totalFees;\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            totalFees += lzFees[i];\\n            _sendChangeManagerRequest(l.childChains[i], newManager, lzFees[i]);\\n        }\\n        require(msg.value >= totalFees, 'insufficient fee');\\n    }\\n\\n    function _sendChangeManagerRequest(\\n        uint16 dstChainId,\\n        address newManager,\\n        uint sendFee\\n    ) internal {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        _registry().transport().sendChangeManagerRequest{ value: sendFee }(\\n            ITransport.ChangeManagerRequest({\\n                child: ITransport.ChildVault({\\n                    chainId: dstChainId,\\n                    vault: l.children[dstChainId]\\n                }),\\n                newManager: newManager\\n            })\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\\nimport { VaultParentInternal } from './VaultParentInternal.sol';\\n\\ncontract VaultParentProxy is Proxy {\\n    address private immutable DIAMOND;\\n\\n    constructor(address diamond) {\\n        DIAMOND = diamond;\\n    }\\n\\n    function _getImplementation() internal view override returns (address) {\\n        return IDiamondReadable(DIAMOND).facetAddress(msg.sig);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary VaultParentStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('valio.storage.vaultParent');\\n\\n    // solhint-disable-next-line ordering\\n    struct ChainValue {\\n        uint minValue;\\n        uint lastUpdate;\\n        uint maxValue;\\n    }\\n\\n    // solhint-disable-next-line ordering\\n    struct Layout {\\n        bytes32 _deprecated_vaultId;\\n        bool childCreationInProgress;\\n        bool bridgeInProgress;\\n        uint lastBridgeCancellation;\\n        uint withdrawsInProgress;\\n        uint16[] childChains;\\n        // chainId => childVault address\\n        mapping(uint16 => address) children;\\n        mapping(uint16 => ChainValue) chainTotalValues;\\n        uint16 bridgeApprovedFor;\\n        // Not a big fan of inverted flags, but some vaults were already deployed.\\n        // Would have preferred to have childIsActive\\n        mapping(uint16 => bool) childIsInactive;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault-parent/VaultParentTransport.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport { ITransport } from '../transport/ITransport.sol';\\nimport { VaultBaseInternal } from '../vault-base/VaultBaseInternal.sol';\\nimport { VaultParentStorage } from './VaultParentStorage.sol';\\n\\ncontract VaultParentTransport is VaultBaseInternal {\\n    event ReceivedChildValue();\\n    event ReceivedWithdrawComplete(uint withdrawsStillInProgress);\\n\\n    ///\\n    /// Receivers/CallBacks\\n    ///\\n\\n    function receiveWithdrawComplete() external onlyTransport {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        l.withdrawsInProgress--;\\n        _registry().emitEvent();\\n        emit ReceivedWithdrawComplete(l.withdrawsInProgress);\\n    }\\n\\n    // Callback for once the sibling has been created on the dstChain\\n    function receiveChildCreated(\\n        uint16 childChainId,\\n        address childVault\\n    ) external onlyTransport {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        if (l.children[childChainId] == address(0)) {\\n            l.childCreationInProgress = false;\\n            l.childIsInactive[childChainId] = true;\\n            for (uint8 i = 0; i < l.childChains.length; i++) {\\n                // Federate the new sibling to the other children\\n                _registry().transport().sendAddSiblingRequest(\\n                    ITransport.AddVaultSiblingRequest({\\n                        // The existing child\\n                        child: ITransport.ChildVault({\\n                            vault: l.children[l.childChains[i]],\\n                            chainId: l.childChains[i]\\n                        }),\\n                        // The new Sibling\\n                        newSibling: ITransport.ChildVault({\\n                            vault: childVault,\\n                            chainId: childChainId\\n                        })\\n                    })\\n                );\\n            }\\n\\n            l.children[childChainId] = childVault;\\n            l.childChains.push(childChainId);\\n        }\\n    }\\n\\n    // Callback to notify the parent the bridge has taken place\\n    function receiveBridgedAssetAcknowledgement(\\n        uint16 receivingChainId\\n    ) external onlyTransport {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n        // While a bridge is underway everything is locked (deposits/withdraws etc)\\n        // Once the bridge is complete we need to clear the stale values we have for the childVaults\\n        // If a requestTotalSync completes (which is valid for 10 mins),\\n        // then a bridge takes place from a child to the parent and completes within 10 mins,\\n        // then the parent will have stale values for the childVaults but the extra value from the bridge\\n        // This enforces that a requestTotalSync must happen after a bridge completes.\\n        for (uint8 i = 0; i < l.childChains.length; i++) {\\n            l.chainTotalValues[l.childChains[i]].lastUpdate = 0;\\n        }\\n        // Update the childChain to be active\\n        l.childIsInactive[receivingChainId] = false;\\n        l.bridgeInProgress = false;\\n        l.bridgeApprovedFor = 0;\\n    }\\n\\n    // Allows the bridge approval to be cancelled by the receiver\\n    // after a period of time if the bridge doesn't take place\\n    function receiveBridgeApprovalCancellation(\\n        address requester\\n    ) external onlyTransport {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        l.bridgeInProgress = false;\\n        l.bridgeApprovedFor = 0;\\n        if (requester != _manager()) {\\n            l.lastBridgeCancellation = block.timestamp;\\n        }\\n    }\\n\\n    // Callback to receive value/supply updates\\n    function receiveChildValue(\\n        uint16 childChainId,\\n        uint minValue,\\n        uint maxValue,\\n        uint time\\n    ) external onlyTransport {\\n        VaultParentStorage.Layout storage l = VaultParentStorage.layout();\\n\\n        l.chainTotalValues[childChainId] = VaultParentStorage.ChainValue({\\n            minValue: minValue,\\n            maxValue: maxValue,\\n            lastUpdate: time\\n        });\\n\\n        _registry().emitEvent();\\n        emit ReceivedChildValue();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum ExecutorIntegration\",\"name\":\"integration\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"enum ExecutorAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasExecuted\",\"type\":\"bool\"}],\"name\":\"ExecutedCallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum ExecutorIntegration\",\"name\":\"integration\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"enum ExecutorAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedManagerAction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zeroXSwapData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ZeroXExecutor", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}