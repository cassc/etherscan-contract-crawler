{"SourceCode": "pragma solidity ^0.4.0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupply;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - \r\n     *\r\n     *  @param from  - \r\n     *  @param to    - \r\n     *  @param value - \r\n     *\r\n     *  @return \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476799200,  // P1: GMT: 18-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"createHKG\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalValue\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"multisig\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "HackerGold", "CompilerVersion": "v0.4.2-nightly.2016.9.9+commit.51a98ab", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b10ba7b334d3bd1b2110ba00bca39696b6df406d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}