{"SourceCode": "{\"IDparam.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0 \\u003c0.8.0;\\n\\ninterface IDparam {\\n    event FeeRateEvent(uint256 feeRate);\\n    event LiquidationLineEvent(uint256 liquidationRate);\\n    event MinMintEvent(uint256 minMint);\\n\\n    function stakeRate() external view returns (uint256);\\n\\n    function liquidationLine() external view returns (uint256);\\n\\n    function feeRate() external view returns (uint256);\\n\\n    function minMint() external view returns (uint256);\\n\\n    function setFeeRate(uint256 _feeRate) external;\\n\\n    function setLiquidationLine(uint256 _liquidationLine) external;\\n\\n    function setMinMint(uint256 _minMint) external;\\n\\n    function isLiquidation(uint256 price) external view returns (bool);\\n\\n    function isNormal(uint256 price) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n}\\n\"},\"OinStake.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0 \\u003c0.8.0;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./IDparam.sol\\\";\\nimport \\\"./WhiteList.sol\\\";\\n\\ninterface IOracle {\\n    function val() external returns (uint256);\\n\\n    function poke(uint256 price) external;\\n\\n    function peek() external;\\n}\\n\\ninterface IESM {\\n    function isStakePaused() external view returns (bool);\\n\\n    function isRedeemPaused() external view returns (bool);\\n\\n    function isClosed() external view returns (bool);\\n\\n    function time() external view returns (uint256);\\n}\\n\\ninterface ICoin {\\n    function burn(address account, uint256 amount) external;\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract OinStake is Owned, WhiteList {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @notice Struct reward pools state\\n     * @param index Accumulated earnings index\\n     * @param block Update index, updating blockNumber together\\n     */\\n    struct RewardState {\\n        uint256 index;\\n        uint256 block;\\n    }\\n    /**\\n     * @notice reward pools state\\n     * @param index Accumulated earnings index by staker\\n     * @param reward Accumulative reward\\n     */\\n    struct StakerState {\\n        uint256 index;\\n        uint256 reward;\\n    }\\n\\n    /// @notice TThe reward pool put into by the project side\\n    uint256 public reward;\\n    /// @notice The number of token per-block\\n    uint256 public rewardSpeed = 5e8;\\n    /// @notice Inital index\\n    uint256 public initialIndex = 1e16;\\n    /// @notice Amplification factor\\n    uint256 public doubleScale = 1e16;\\n    /// @notice The instance reward pools state\\n    RewardState public rewardState;\\n\\n    /// @notice All staker-instances state\\n    mapping(address =\\u003e StakerState) public stakerStates;\\n\\n    /// @notice The amount by staker with token\\n    mapping(address =\\u003e uint256) public tokens;\\n    /// @notice The amount by staker with coin\\n    mapping(address =\\u003e uint256) public coins;\\n    /// @notice The total amount of out-coin in sys\\n    uint256 public totalCoin;\\n    /// @notice The total amount of stake-token in sys\\n    uint256 public totalToken;\\n    /// @notice Cumulative  service fee, it will be burn, not join reward.\\n    uint256 public sFee;\\n    uint256 constant ONE = 10**8;\\n    address constant blackhole = 0x1111111111111111111111111111111111111111;\\n\\n    /// @notice Dparam address\\n    IDparam params;\\n    /// @notice Oracle address\\n    IOracle orcl;\\n    /// @notice Esm address\\n    IESM esm;\\n    /// @notice Coin address\\n    ICoin coin;\\n    /// @notice Token address\\n    IERC20 token;\\n\\n    /// @notice Setup Oracle address success\\n    event SetupOracle(address orcl);\\n    /// @notice Setup Dparam address success\\n    event SetupParam(address param);\\n    /// @notice Setup Esm address success\\n    event SetupEsm(address esm);\\n    /// @notice Setup Token\\u0026Coin address success\\n    event SetupCoin(address token, address coin);\\n    /// @notice Stake success\\n    event StakeEvent(uint256 token, uint256 coin);\\n    /// @notice redeem success\\n    event RedeemEvent(uint256 token, uint256 move, uint256 fee, uint256 coin);\\n    /// @notice Update index success\\n    event IndexUpdate(uint256 delt, uint256 block, uint256 index);\\n    /// @notice ClaimToken success\\n    event ClaimToken(address holder, uint256 amount);\\n    /// @notice InjectReward success\\n    event InjectReward(uint256 amount);\\n    /// @notice ExtractReward success\\n    event ExtractReward(address reciver, uint256 amount);\\n\\n    /**\\n     * @notice Construct a new OinStake, owner by msg.sender\\n     * @param _param Dparam address\\n     * @param _orcl Oracle address\\n     * @param _esm Esm address\\n     */\\n    constructor(\\n        address _param,\\n        address _orcl,\\n        address _esm\\n    ) public Owned(msg.sender) {\\n        params = IDparam(_param);\\n        orcl = IOracle(_orcl);\\n        esm = IESM(_esm);\\n        rewardState = RewardState(initialIndex, getBlockNumber());\\n    }\\n\\n    modifier notClosed() {\\n        require(!esm.isClosed(), \\\"System closed\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice reset Dparams address.\\n     * @param _params Configuration dynamic params contract address\\n     */\\n    function setupParams(address _params) public onlyWhiter {\\n        params = IDparam(_params);\\n        emit SetupParam(_params);\\n    }\\n\\n    /**\\n     * @notice reset Oracle address.\\n     * @param _orcl Configuration Oracle contract address\\n     */\\n    function setupOracle(address _orcl) public onlyWhiter {\\n        orcl = IOracle(_orcl);\\n        emit SetupOracle(_orcl);\\n    }\\n\\n    /**\\n     * @notice reset Esm address.\\n     * @param _esm Configuration Esm contract address\\n     */\\n    function setupEsm(address _esm) public onlyWhiter {\\n        esm = IESM(_esm);\\n        emit SetupEsm(_esm);\\n    }\\n\\n    /**\\n     * @notice get Dparam address.\\n     * @return Dparam contract address\\n     */\\n    function getParamsAddr() public view returns (address) {\\n        return address(params);\\n    }\\n\\n    /**\\n     * @notice get Oracle address.\\n     * @return Oracle contract address\\n     */\\n    function getOracleAddr() public view returns (address) {\\n        return address(orcl);\\n    }\\n\\n    /**\\n     * @notice get Esm address.\\n     * @return Esm contract address\\n     */\\n    function getEsmAddr() public view returns (address) {\\n        return address(esm);\\n    }\\n\\n    /**\\n     * @notice get token of staking address.\\n     * @return ERC20 address\\n     */\\n    function getCoinAddress() public view returns (address) {\\n        return address(coin);\\n    }\\n\\n    /**\\n     * @notice get StableToken address.\\n     * @return ERC20 address\\n     */\\n    function getTokenAddress() public view returns (address) {\\n        return address(token);\\n    }\\n\\n    /**\\n     * @notice inject token address \\u0026 coin address only once.\\n     * @param _token token address\\n     * @param _coin coin address\\n     */\\n    function setup(address _token, address _coin) public onlyWhiter {\\n        require(\\n            address(token) == address(0) \\u0026\\u0026 address(coin) == address(0),\\n            \\\"setuped yet.\\\"\\n        );\\n        token = IERC20(_token);\\n        coin = ICoin(_coin);\\n\\n        emit SetupCoin(_token, _coin);\\n    }\\n\\n    /**\\n     * @notice Get the number of debt by the `account`\\n     * @param account token address\\n     * @return (tokenAmount,coinAmount)\\n     */\\n    function debtOf(address account) public view returns (uint256, uint256) {\\n        return (tokens[account], coins[account]);\\n    }\\n\\n    /**\\n     * @notice Get the number of debt by the `account`\\n     * @param coinAmount The amount that staker want to get stableToken\\n     * @return The amount that staker want to transfer token.\\n     */\\n    function getInputToken(uint256 coinAmount)\\n        public\\n        view\\n        returns (uint256 tokenAmount)\\n    {\\n        tokenAmount = coinAmount.mul(params.stakeRate());\\n    }\\n\\n    /**\\n     * @notice Normally redeem anyAmount internal\\n     * @param coinAmount The number of coin will be staking\\n     */\\n    function stake(uint256 coinAmount) external notClosed {\\n        require(!esm.isStakePaused(), \\\"Stake paused\\\");\\n        require(coinAmount \\u003e 0, \\\"The quantity is less than the minimum\\\");\\n        require(orcl.val() \\u003e 0, \\\"Oracle price not initialized.\\\");\\n        require(params.isNormal(orcl.val()), \\\"Oin\\u0027s price is too low.\\\");\\n\\n        address from = msg.sender;\\n\\n        if (coins[from] == 0) {\\n            require(\\n                coinAmount \\u003e= params.minMint(),\\n                \\\"First make coin must grater than 100.\\\"\\n            );\\n        }\\n\\n        accuredToken(from);\\n\\n        uint256 tokenAmount = getInputToken(coinAmount);\\n\\n        token.transferFrom(from, address(this), tokenAmount);\\n        coin.mint(from, coinAmount);\\n\\n        totalCoin = totalCoin.add(coinAmount);\\n        totalToken = totalToken.add(tokenAmount);\\n        coins[from] = coins[from].add(coinAmount);\\n        tokens[from] = tokens[from].add(tokenAmount);\\n\\n        emit StakeEvent(tokenAmount, coinAmount);\\n    }\\n\\n    /**\\n     * @notice Normally redeem anyAmount internal\\n     * @param coinAmount The number of coin will be redeemed\\n     * @param receiver Address of receiving\\n     */\\n    function _normalRedeem(uint256 coinAmount, address receiver)\\n        internal\\n        notClosed\\n    {\\n        require(!esm.isRedeemPaused(), \\\"Redeem paused\\\");\\n        address staker = msg.sender;\\n        require(coins[staker] \\u003e 0, \\\"No collateral\\\");\\n        require(coinAmount \\u003e 0, \\\"The quantity is less than zero\\\");\\n        require(coinAmount \\u003c= coins[staker], \\\"input amount overflow\\\");\\n\\n        accuredToken(staker);\\n\\n        uint256 tokenAmount = getInputToken(coinAmount);\\n\\n        uint256 feeRate = params.feeRate();\\n        uint256 fee = tokenAmount.mul(feeRate).div(1000);\\n        uint256 move = tokenAmount.sub(fee);\\n        sFee = sFee.add(fee);\\n\\n        token.transfer(blackhole, fee);\\n        coin.burn(staker, coinAmount);\\n        token.transfer(receiver, move);\\n\\n        coins[staker] = coins[staker].sub(coinAmount);\\n        tokens[staker] = tokens[staker].sub(tokenAmount);\\n        totalCoin = totalCoin.sub(coinAmount);\\n        totalToken = totalToken.sub(tokenAmount);\\n\\n        emit RedeemEvent(tokenAmount, move, fee, coinAmount);\\n    }\\n\\n    /**\\n     * @notice Abnormally redeem anyAmount internal\\n     * @param coinAmount The number of coin will be redeemed\\n     * @param receiver Address of receiving\\n     */\\n    function _abnormalRedeem(uint256 coinAmount, address receiver) internal {\\n        require(esm.isClosed(), \\\"System not Closed yet.\\\");\\n        address from = msg.sender;\\n        require(coinAmount \\u003e 0, \\\"The quantity is less than zero\\\");\\n        require(coin.balanceOf(from) \\u003e 0, \\\"The coin no balance.\\\");\\n        require(coinAmount \\u003c= coin.balanceOf(from), \\\"Coin balance exceed\\\");\\n\\n        uint256 tokenAmount = getInputToken(coinAmount);\\n\\n        coin.burn(from, coinAmount);\\n        token.transfer(receiver, tokenAmount);\\n\\n        totalCoin = totalCoin.sub(coinAmount);\\n        totalToken = totalToken.sub(tokenAmount);\\n\\n        emit RedeemEvent(tokenAmount, tokenAmount, 0, coinAmount);\\n    }\\n\\n    /**\\n     * @notice Normally redeem anyAmount\\n     * @param coinAmount The number of coin will be redeemed\\n     * @param receiver Address of receiving\\n     */\\n    function redeem(uint256 coinAmount, address receiver) public {\\n        _normalRedeem(coinAmount, receiver);\\n    }\\n\\n    /**\\n     * @notice Normally redeem anyAmount to msg.sender\\n     * @param coinAmount The number of coin will be redeemed\\n     */\\n    function redeem(uint256 coinAmount) public {\\n        redeem(coinAmount, msg.sender);\\n    }\\n\\n    /**\\n     * @notice normally redeem them all at once\\n     * @param holder reciver\\n     */\\n    function redeemMax(address holder) public {\\n        redeem(coins[msg.sender], holder);\\n    }\\n\\n    /**\\n     * @notice normally redeem them all at once to msg.sender\\n     */\\n    function redeemMax() public {\\n        redeemMax(msg.sender);\\n    }\\n\\n    /**\\n     * @notice System shutdown under the redemption rule\\n     * @param coinAmount The number coin\\n     * @param receiver Address of receiving\\n     */\\n    function oRedeem(uint256 coinAmount, address receiver) public {\\n        _abnormalRedeem(coinAmount, receiver);\\n    }\\n\\n    /**\\n     * @notice System shutdown under the redemption rule\\n     * @param coinAmount The number coin\\n     */\\n    function oRedeem(uint256 coinAmount) public {\\n        oRedeem(coinAmount, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Refresh reward speed.\\n     */\\n    function setRewardSpeed(uint256 speed) public onlyWhiter {\\n        updateIndex();\\n        rewardSpeed = speed;\\n    }\\n\\n    /**\\n     * @notice Used to correct the effect of one\\u0027s actions on one\\u0027s own earnings\\n     *         System shutdown will no longer count\\n     */\\n    function updateIndex() public {\\n        if (esm.isClosed()) {\\n            return;\\n        }\\n\\n        uint256 blockNumber = getBlockNumber();\\n        uint256 deltBlock = blockNumber.sub(rewardState.block);\\n\\n        if (deltBlock \\u003e 0) {\\n            uint256 accruedReward = rewardSpeed.mul(deltBlock);\\n            uint256 ratio = totalToken == 0\\n                ? 0\\n                : accruedReward.mul(doubleScale).div(totalToken);\\n            rewardState.index = rewardState.index.add(ratio);\\n            rewardState.block = blockNumber;\\n            emit IndexUpdate(deltBlock, blockNumber, rewardState.index);\\n        }\\n    }\\n\\n    /**\\n     * @notice Used to correct the effect of one\\u0027s actions on one\\u0027s own earnings\\n     *         System shutdown will no longer count\\n     * @param account staker address\\n     */\\n    function accuredToken(address account) internal {\\n        updateIndex();\\n        StakerState storage stakerState = stakerStates[account];\\n        stakerState.reward = _getReward(account);\\n        stakerState.index = rewardState.index;\\n    }\\n\\n    /**\\n     * @notice Calculate the current holder\\u0027s mining income\\n     * @param staker Address of holder\\n     */\\n    function _getReward(address staker) internal view returns (uint256 value) {\\n        StakerState storage stakerState = stakerStates[staker];\\n        value = stakerState.reward.add(\\n            rewardState.index.sub(stakerState.index).mul(tokens[staker]).div(\\n                doubleScale\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Estimate the mortgagor\\u0027s reward\\n     * @param account Address of staker\\n     */\\n    function getHolderReward(address account)\\n        public\\n        view\\n        returns (uint256 value)\\n    {\\n        uint256 blockReward2 = (totalToken == 0 || esm.isClosed())\\n            ? 0\\n            : getBlockNumber()\\n                .sub(rewardState.block)\\n                .mul(rewardSpeed)\\n                .mul(tokens[account])\\n                .div(totalToken);\\n        value = _getReward(account) + blockReward2;\\n    }\\n\\n    /**\\n     * @notice Extract the current reward in one go\\n     * @param holder Address of receiver\\n     */\\n    function claimToken(address holder) public {\\n        accuredToken(holder);\\n        StakerState storage stakerState = stakerStates[holder];\\n        uint256 value = stakerState.reward.min(reward);\\n        require(value \\u003e 0, \\\"The reward of address is zero.\\\");\\n\\n        token.transfer(holder, value);\\n        reward = reward.sub(value);\\n\\n        stakerState.index = rewardState.index;\\n        stakerState.reward = stakerState.reward.sub(value);\\n        emit ClaimToken(holder, value);\\n    }\\n\\n    /**\\n     * @notice Get block number now\\n     */\\n    function getBlockNumber() public view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Inject token to reward\\n     * @param amount The number of injecting\\n     */\\n    function injectReward(uint256 amount) external onlyOwner {\\n        token.transferFrom(msg.sender, address(this), amount);\\n        reward = reward.add(amount);\\n        emit InjectReward(amount);\\n    }\\n\\n    /**\\n     * @notice Extract token from reward\\n     * @param account Address of receiver\\n     * @param amount The number of extracting\\n     */\\n    function extractReward(address account, uint256 amount) external onlyOwner {\\n        require(amount \\u003c= reward, \\\"withdraw overflow.\\\");\\n        token.transfer(account, amount);\\n        reward = reward.sub(amount);\\n        emit ExtractReward(account, amount);\\n    }\\n}\\n\"},\"Owned.sol\":{\"content\":\"pragma solidity ^0.5.16;\\n\\n// https://docs.synthetix.io/contracts/Owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor(address _owner) public {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(\\n            msg.sender == nominatedOwner,\\n            \\\"You must be nominated before you can accept ownership\\\"\\n        );\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only the contract owner may perform this action\\\"\\n        );\\n        _;\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"WhiteList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0 \\u003c0.8.0;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract WhiteList is Owned {\\n    /// @notice Users with permissions\\n    mapping(address =\\u003e uint256) public whiter;\\n\\n    /// @notice Append address into whiteList successevent\\n    event AppendWhiter(address adder);\\n\\n    /// @notice Remove address into whiteList successevent\\n    event RemoveWhiter(address remover);\\n\\n    /**\\n     * @notice Construct a new WhiteList, default owner in whiteList\\n     */\\n    constructor() internal {\\n        appendWhiter(owner);\\n    }\\n\\n    modifier onlyWhiter() {\\n        require(isWhiter(), \\\"WhiteList: msg.sender not in whilteList.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only onwer can append address into whitelist\\n     * @param account The address not added, can added to the whitelist\\n     */\\n    function appendWhiter(address account) public onlyOwner {\\n        require(account != address(0), \\\"WhiteList: address not zero\\\");\\n        require(\\n            !isWhiter(account),\\n            \\\"WhiteListe: the account exsit whilteList yet\\\"\\n        );\\n        whiter[account] = 1;\\n        emit AppendWhiter(account);\\n    }\\n\\n    /**\\n     * @notice Only onwer can remove address into whitelist\\n     * @param account The address in whitelist yet\\n     */\\n    function removeWhiter(address account) public onlyOwner {\\n        require(\\n            isWhiter(account),\\n            \\\"WhiteListe: the account not exist whilteList\\\"\\n        );\\n        delete whiter[account];\\n        emit RemoveWhiter(account);\\n    }\\n\\n    /**\\n     * @notice Check whether acccount in whitelist\\n     * @param account Any address\\n     */\\n    function isWhiter(address account) public view returns (bool) {\\n        return whiter[account] == 1;\\n    }\\n\\n    /**\\n     * @notice Check whether msg.sender in whitelist overrides.\\n     */\\n    function isWhiter() public view returns (bool) {\\n        return isWhiter(msg.sender);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_param\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orcl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_esm\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adder\",\"type\":\"address\"}],\"name\":\"AppendWhiter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reciver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExtractReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"IndexUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InjectReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"move\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"RedeemEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"remover\",\"type\":\"address\"}],\"name\":\"RemoveWhiter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"SetupCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"esm\",\"type\":\"address\"}],\"name\":\"SetupEsm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orcl\",\"type\":\"address\"}],\"name\":\"SetupOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"param\",\"type\":\"address\"}],\"name\":\"SetupParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"StakeEvent\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"appendWhiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"debtOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"doubleScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"extractReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEsmAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getHolderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"}],\"name\":\"getInputToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParamsAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"injectReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhiter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhiter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"oRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"}],\"name\":\"oRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"redeemMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"name\":\"setRewardSpeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coin\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_esm\",\"type\":\"address\"}],\"name\":\"setupEsm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_orcl\",\"type\":\"address\"}],\"name\":\"setupOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_params\",\"type\":\"address\"}],\"name\":\"setupParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerStates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OinStake", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009278a2967770cbd357031681f455b500e44c3d840000000000000000000000001248460fd7e9c7148f2c11e94e0524c3dcfa72190000000000000000000000009278a2967770cbd357031681f455b500e44c3d84", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://6e56814a1f55ec0be86f69a809e9d0f79f1f3472df39e646a97cd326b27085bc"}