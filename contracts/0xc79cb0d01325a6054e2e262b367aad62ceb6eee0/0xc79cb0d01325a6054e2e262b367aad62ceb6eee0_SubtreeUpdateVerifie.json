{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/ISubtreeUpdateVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport {IVerifier} from \\\"./IVerifier.sol\\\";\\n\\n/// @title Verifier interface.\\n/// @dev Interface of Verifier contract.\\ninterface ISubtreeUpdateVerifier is IVerifier {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../libs/Types.sol\\\";\\n\\ninterface ITeller {\\n    function processBundle(\\n        Bundle calldata bundle\\n    )\\n        external\\n        returns (\\n            uint256[] memory opDigests,\\n            OperationResult[] memory opResults\\n        );\\n\\n    function depositFunds(\\n        Deposit calldata deposit\\n    ) external returns (uint128 merkleIndex);\\n\\n    function requestAsset(\\n        EncodedAsset calldata encodedAsset,\\n        uint256 value\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\nimport {Groth16} from \\\"../libs/Groth16.sol\\\";\\n\\n/// @title interface for verifiers that support batch verification.\\n/// @dev Interface for verifiers that support batch verification.\\ninterface IVerifier {\\n    /// @param proof: the proof to verify\\n    /// @param pis: an array of containing the public inputs for the proof\\n    function verifyProof(\\n        uint256[8] memory proof,\\n        uint256[] memory pis\\n    ) external view returns (bool);\\n\\n    /// @param proofs: an array containing the proofs to verify\\n    /// @param pis: an array of length `NUM_PIS * numProofs` containing the PIs for each proof concatenated together\\n    function batchVerifyProofs(\\n        uint256[8][] memory proofs,\\n        uint256[][] memory pis\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Groth16.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\nimport {Pairing} from \\\"./Pairing.sol\\\";\\nimport {Utils} from \\\"./Utils.sol\\\";\\n\\nlibrary Groth16 {\\n    struct VerifyingKey {\\n        Pairing.G1Point alpha1;\\n        Pairing.G2Point beta2;\\n        Pairing.G2Point gamma2;\\n        Pairing.G2Point delta2;\\n        Pairing.G1Point[] IC;\\n    }\\n\\n    struct Proof {\\n        Pairing.G1Point A;\\n        Pairing.G2Point B;\\n        Pairing.G1Point C;\\n    }\\n\\n    // Verifying a single Groth16 proof\\n    function verifyProof(\\n        VerifyingKey memory vk,\\n        uint256[8] memory proof8,\\n        uint256[] memory pi\\n    ) internal view returns (bool) {\\n        require(vk.IC.length == pi.length + 1, \\\"Public input length mismatch.\\\");\\n        Pairing.G1Point memory vk_x = vk.IC[0];\\n        for (uint i = 0; i < pi.length; i++) {\\n            require(\\n                pi[i] < Utils.BN254_SCALAR_FIELD_MODULUS,\\n                \\\"Malformed public input.\\\"\\n            );\\n            vk_x = Pairing.addition(\\n                vk_x,\\n                Pairing.scalar_mul(vk.IC[i + 1], pi[i])\\n            );\\n        }\\n\\n        Proof memory proof = _proof8ToStruct(proof8);\\n\\n        return\\n            Pairing.pairingProd4(\\n                Pairing.negate(proof.A),\\n                proof.B,\\n                vk.alpha1,\\n                vk.beta2,\\n                vk_x,\\n                vk.gamma2,\\n                proof.C,\\n                vk.delta2\\n            );\\n    }\\n\\n    function accumulate(\\n        Proof[] memory proofs,\\n        uint256[][] memory allPis\\n    )\\n        internal\\n        view\\n        returns (\\n            Pairing.G1Point[] memory proofAsandAggegateC,\\n            uint256[] memory publicInputAccumulators\\n        )\\n    {\\n        uint256 allPisLength = allPis.length;\\n        uint256 numProofs = proofs.length;\\n\\n        uint256 numPublicInputs = allPis[0].length;\\n        for (uint256 i = 1; i < allPisLength; i++) {\\n            require(\\n                numPublicInputs == allPis[i].length,\\n                \\\"Public input mismatch during batch verification.\\\"\\n            );\\n        }\\n        uint256[] memory entropy = new uint256[](numProofs);\\n        publicInputAccumulators = new uint256[](numPublicInputs + 1);\\n\\n        // Generate entropy for each proof and accumulate each PI\\n        // seed a challenger by hashing all of the proofs and the current blockhash togethre\\n        uint256 challengerState = uint256(\\n            keccak256(abi.encode(proofs, blockhash(block.number - 1)))\\n        );\\n        for (uint256 proofIndex = 0; proofIndex < numProofs; proofIndex++) {\\n            if (proofIndex == 0) {\\n                entropy[proofIndex] = 1;\\n            } else {\\n                challengerState = uint256(\\n                    keccak256(abi.encodePacked(challengerState))\\n                );\\n                entropy[proofIndex] = challengerState;\\n            }\\n            require(entropy[proofIndex] != 0, \\\"Entropy should not be zero\\\");\\n            // here multiplication by 1 is implied\\n            publicInputAccumulators[0] = addmod(\\n                publicInputAccumulators[0],\\n                entropy[proofIndex],\\n                Utils.BN254_SCALAR_FIELD_MODULUS\\n            );\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                require(\\n                    allPis[proofIndex][i] < Utils.BN254_SCALAR_FIELD_MODULUS,\\n                    \\\"Malformed public input\\\"\\n                );\\n                // accumulate the exponent with extra entropy mod Utils.BN254_SCALAR_FIELD_MODULUS\\n                publicInputAccumulators[i + 1] = addmod(\\n                    publicInputAccumulators[i + 1],\\n                    mulmod(\\n                        entropy[proofIndex],\\n                        allPis[proofIndex][i],\\n                        Utils.BN254_SCALAR_FIELD_MODULUS\\n                    ),\\n                    Utils.BN254_SCALAR_FIELD_MODULUS\\n                );\\n            }\\n        }\\n\\n        proofAsandAggegateC = new Pairing.G1Point[](numProofs + 1);\\n        proofAsandAggegateC[0] = proofs[0].A;\\n\\n        // raise As from each proof to entropy[i]\\n        for (uint256 proofIndex = 1; proofIndex < numProofs; proofIndex++) {\\n            uint256 s = entropy[proofIndex];\\n            proofAsandAggegateC[proofIndex] = Pairing.scalar_mul(\\n                proofs[proofIndex].A,\\n                s\\n            );\\n        }\\n\\n        // MSM(proofCs, entropy)\\n        Pairing.G1Point memory msmProduct = proofs[0].C;\\n        for (uint256 proofIndex = 1; proofIndex < numProofs; proofIndex++) {\\n            uint256 s = entropy[proofIndex];\\n            Pairing.G1Point memory term = Pairing.scalar_mul(\\n                proofs[proofIndex].C,\\n                s\\n            );\\n            msmProduct = Pairing.addition(msmProduct, term);\\n        }\\n\\n        proofAsandAggegateC[numProofs] = msmProduct;\\n\\n        return (proofAsandAggegateC, publicInputAccumulators);\\n    }\\n\\n    function batchVerifyProofs(\\n        VerifyingKey memory vk,\\n        uint256[8][] memory proof8s,\\n        uint256[][] memory allPis\\n    ) internal view returns (bool success) {\\n        uint256 proof8sLength = proof8s.length;\\n        require(\\n            allPis.length == proof8sLength,\\n            \\\"Invalid inputs length for a batch\\\"\\n        );\\n\\n        Proof[] memory proofs = new Proof[](proof8sLength);\\n        for (uint256 i = 0; i < proof8sLength; i++) {\\n            proofs[i] = _proof8ToStruct(proof8s[i]);\\n        }\\n\\n        // strategy is to accumulate entropy separately for some proof elements\\n        // (accumulate only for G1, can't in G2) of the pairing equation, as well as input verification key,\\n        // postpone scalar multiplication as much as possible and check only one equation\\n        // by using 3 + proofs.length pairings only plus 2*proofs.length + (num_inputs+1) + 1 scalar multiplications compared to naive\\n        // 4*proofs.length pairings and proofs.length*(num_inputs+1) scalar multiplications\\n\\n        (\\n            Pairing.G1Point[] memory proofAsandAggegateC,\\n            uint256[] memory publicInputAccumulators\\n        ) = accumulate(proofs, allPis);\\n\\n        Pairing.G1Point[2] memory finalVKAlphaAndX = _prepareBatch(\\n            vk,\\n            publicInputAccumulators\\n        );\\n\\n        Pairing.G1Point[] memory p1s = new Pairing.G1Point[](proofs.length + 3);\\n        Pairing.G2Point[] memory p2s = new Pairing.G2Point[](proofs.length + 3);\\n\\n        // first proofs.length pairings e(ProofA, ProofB)\\n        for (\\n            uint256 proofNumber = 0;\\n            proofNumber < proofs.length;\\n            proofNumber++\\n        ) {\\n            p1s[proofNumber] = proofAsandAggegateC[proofNumber];\\n            p2s[proofNumber] = proofs[proofNumber].B;\\n        }\\n\\n        // second pairing e(-finalVKaplha, vk.beta)\\n        p1s[proofs.length] = Pairing.negate(finalVKAlphaAndX[0]);\\n        p2s[proofs.length] = vk.beta2;\\n\\n        // third pairing e(-finalVKx, vk.gamma)\\n        p1s[proofs.length + 1] = Pairing.negate(finalVKAlphaAndX[1]);\\n        p2s[proofs.length + 1] = vk.gamma2;\\n\\n        // fourth pairing e(-proof.C, vk.delta)\\n        p1s[proofs.length + 2] = Pairing.negate(\\n            proofAsandAggegateC[proofs.length]\\n        );\\n        p2s[proofs.length + 2] = vk.delta2;\\n\\n        return Pairing.pairing(p1s, p2s);\\n    }\\n\\n    function _prepareBatch(\\n        VerifyingKey memory vk,\\n        uint256[] memory publicInputAccumulators\\n    ) internal view returns (Pairing.G1Point[2] memory finalVKAlphaAndX) {\\n        // Compute the linear combination vk_x using accumulator\\n\\n        // Performs an MSM(vkIC, publicInputAccumulators)\\n        Pairing.G1Point memory msmProduct = Pairing.scalar_mul(\\n            vk.IC[0],\\n            publicInputAccumulators[0]\\n        );\\n\\n        uint256 piAccumulatorsLength = publicInputAccumulators.length;\\n        for (uint256 i = 1; i < piAccumulatorsLength; i++) {\\n            Pairing.G1Point memory product = Pairing.scalar_mul(\\n                vk.IC[i],\\n                publicInputAccumulators[i]\\n            );\\n            msmProduct = Pairing.addition(msmProduct, product);\\n        }\\n\\n        finalVKAlphaAndX[1] = msmProduct;\\n\\n        // add one extra memory slot for scalar for multiplication usage\\n        Pairing.G1Point memory finalVKalpha = vk.alpha1;\\n        finalVKalpha = Pairing.scalar_mul(\\n            finalVKalpha,\\n            publicInputAccumulators[0]\\n        );\\n        finalVKAlphaAndX[0] = finalVKalpha;\\n\\n        return finalVKAlphaAndX;\\n    }\\n\\n    function _proof8ToStruct(\\n        uint256[8] memory proof\\n    ) internal pure returns (Proof memory) {\\n        return\\n            Groth16.Proof(\\n                Pairing.G1Point(proof[0], proof[1]),\\n                Pairing.G2Point([proof[2], proof[3]], [proof[4], proof[5]]),\\n                Pairing.G1Point(proof[6], proof[7])\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Pairing.sol\": {\r\n      \"content\": \"// Copyright 2017 Christian Reitwiessner\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n//\\n// 2019 OKIMS\\n//      ported to solidity 0.6\\n//      fixed linter warnings\\n//      added requiere error messages\\n//\\n//\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.2;\\n\\nlibrary Pairing {\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    /// @return the generator of G1\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    /// @return the generator of G2\\n    function P2() internal pure returns (G2Point memory) {\\n        // Original code point\\n        return\\n            G2Point(\\n                [\\n                    11559732032986387107991004021392285783925812861821192530917403151452391805634,\\n                    10857046999023057135944570762232829481370756359578518086990519993285655852781\\n                ],\\n                [\\n                    4082367875863433681332203403145435568316851327593401208105741076214120093531,\\n                    8495653923123431417604973247489272438418190587263600148770280649306958101930\\n                ]\\n            );\\n\\n        /*\\n        // Changed by Jordi point\\n        return G2Point(\\n            [10857046999023057135944570762232829481370756359578518086990519993285655852781,\\n             11559732032986387107991004021392285783925812861821192530917403151452391805634],\\n            [8495653923123431417604973247489272438418190587263600148770280649306958101930,\\n             4082367875863433681332203403145435568316851327593401208105741076214120093531]\\n        );\\n*/\\n    }\\n\\n    /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\\n    function negate(G1Point memory p) internal pure returns (G1Point memory r) {\\n        // The prime q in the base field F_q for G1\\n        uint256 q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n        if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\\n        return G1Point(p.X, q - (p.Y % q));\\n    }\\n\\n    /// @return r the sum of two points of G1\\n    function addition(\\n        G1Point memory p1,\\n        G1Point memory p2\\n    ) internal view returns (G1Point memory r) {\\n        uint256[4] memory input;\\n        input[0] = p1.X;\\n        input[1] = p1.Y;\\n        input[2] = p2.X;\\n        input[3] = p2.Y;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                invalid()\\n            }\\n        }\\n        require(success, \\\"pairing-add-failed\\\");\\n    }\\n\\n    /// @return r the product of a point on G1 and a scalar, i.e.\\n    /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\\n    function scalar_mul(\\n        G1Point memory p,\\n        uint256 s\\n    ) internal view returns (G1Point memory r) {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                invalid()\\n            }\\n        }\\n        require(success, \\\"pairing-mul-failed\\\");\\n    }\\n\\n    /// @return the result of computing the pairing check\\n    /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\\n    /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should\\n    /// return true.\\n    function pairing(\\n        G1Point[] memory p1,\\n        G2Point[] memory p2\\n    ) internal view returns (bool) {\\n        require(p1.length == p2.length, \\\"pairing-lengths-failed\\\");\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; i++) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := staticcall(\\n                sub(gas(), 2000),\\n                8,\\n                add(input, 0x20),\\n                mul(inputSize, 0x20),\\n                out,\\n                0x20\\n            )\\n            // Use \\\"invalid\\\" to make gas estimation work\\n            switch success\\n            case 0 {\\n                invalid()\\n            }\\n        }\\n        require(success, \\\"pairing-opcode-failed\\\");\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n\\n    /// Convenience method for a pairing check for three pairs.\\n    function pairingProd3(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2,\\n        G1Point memory c1,\\n        G2Point memory c2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](3);\\n        G2Point[] memory p2 = new G2Point[](3);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p1[2] = c1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        p2[2] = c2;\\n        return pairing(p1, p2);\\n    }\\n\\n    /// Convenience method for a pairing check for four pairs.\\n    function pairingProd4(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2,\\n        G1Point memory c1,\\n        G2Point memory c2,\\n        G1Point memory d1,\\n        G2Point memory d2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](4);\\n        G2Point[] memory p2 = new G2Point[](4);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p1[2] = c1;\\n        p1[3] = d1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        p2[2] = c2;\\n        p2[3] = d2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\n\\nuint256 constant GAS_PER_JOINSPLIT_HANDLE = 110_000; // two 20k SSTOREs from NF insertions, ~70k for merkle tree checks + NF mapping checks + processing joinsplits not including tree insertions\\nuint256 constant GAS_PER_INSERTION_SUBTREE_UPDATE = 25_000; // Full 16 leaf non-zero subtree update = 320k / 16 = 20k per insertion (+5k buffer)\\nuint256 constant GAS_PER_INSERTION_ENQUEUE = 25_000; // 20k for enqueueing note commitment not including subtree update cost (+5k buffer)\\nuint256 constant GAS_PER_OPERATION_MISC = 100_000; // remaining gas cost for operation including  miscellaneous costs such as sending gas tokens to bundler, requesting assets from teller, sending tokens back for refunds, calldata, event, etc.\\n\\nuint256 constant ERC20_ID = 0;\\n\\nenum AssetType {\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\\nstruct EncodedAsset {\\n    uint256 encodedAssetAddr;\\n    uint256 encodedAssetId;\\n}\\n\\nstruct CompressedStealthAddress {\\n    uint256 h1;\\n    uint256 h2;\\n}\\n\\nstruct EncryptedNote {\\n    bytes ciphertextBytes;\\n    bytes encapsulatedSecretBytes;\\n}\\n\\nstruct PublicJoinSplit {\\n    JoinSplit joinSplit;\\n    uint8 assetIndex; // Index in op.joinSplitAssets\\n    uint256 publicSpend;\\n}\\n\\nstruct JoinSplit {\\n    uint256 commitmentTreeRoot;\\n    uint256 nullifierA;\\n    uint256 nullifierB;\\n    uint256 newNoteACommitment;\\n    uint256 newNoteBCommitment;\\n    uint256 senderCommitment;\\n    uint256 joinSplitInfoCommitment;\\n    uint256[8] proof;\\n    EncryptedNote newNoteAEncrypted;\\n    EncryptedNote newNoteBEncrypted;\\n}\\n\\nstruct JoinSplitInfo {\\n    uint256 compressedSenderCanonAddr;\\n    uint256 compressedReceiverCanonAddr;\\n    uint256 oldMerkleIndicesWithSignBits;\\n    uint256 newNoteValueA;\\n    uint256 newNoteValueB;\\n    uint256 nonce;\\n}\\n\\nstruct EncodedNote {\\n    uint256 ownerH1;\\n    uint256 ownerH2;\\n    uint256 nonce;\\n    uint256 encodedAssetAddr;\\n    uint256 encodedAssetId;\\n    uint256 value;\\n}\\n\\nstruct DepositRequest {\\n    address spender;\\n    EncodedAsset encodedAsset;\\n    uint256 value;\\n    CompressedStealthAddress depositAddr;\\n    uint256 nonce;\\n    uint256 gasCompensation;\\n}\\n\\nstruct Deposit {\\n    address spender;\\n    EncodedAsset encodedAsset;\\n    uint256 value;\\n    CompressedStealthAddress depositAddr;\\n}\\n\\nstruct Action {\\n    address contractAddress;\\n    bytes encodedFunction;\\n}\\n\\nstruct TrackedAsset {\\n    EncodedAsset encodedAsset;\\n    uint256 minRefundValue;\\n}\\n\\nstruct Operation {\\n    PublicJoinSplit[] pubJoinSplits;\\n    JoinSplit[] confJoinSplits;\\n    CompressedStealthAddress refundAddr;\\n    TrackedAsset[] trackedAssets;\\n    Action[] actions;\\n    EncodedAsset encodedGasAsset;\\n    uint256 gasAssetRefundThreshold;\\n    uint256 executionGasLimit;\\n    uint256 gasPrice;\\n    uint256 deadline;\\n    bool atomicActions;\\n}\\n\\n// An operation is processed if its joinsplitTxs are processed.\\n// If an operation is processed, the following is guaranteeed to happen:\\n// 1. Encoded calls are attempted (not necessarily successfully)\\n// 2. The bundler is compensated verification and execution gas\\n// Bundlers should only be submitting operations that can be processed.\\nstruct OperationResult {\\n    bool opProcessed;\\n    bool assetsUnwrapped;\\n    string failureReason;\\n    bool[] callSuccesses;\\n    bytes[] callResults;\\n    uint256 verificationGas;\\n    uint256 executionGas;\\n    uint256 numRefunds;\\n    uint128 preOpMerkleCount;\\n    uint128 postOpMerkleCount;\\n}\\n\\nstruct Bundle {\\n    Operation[] operations;\\n}\\n\\nstruct CanonAddrRegistryEntry {\\n    address ethAddress;\\n    uint256 compressedCanonAddr;\\n    uint256 perCanonAddrNonce;\\n}\\n\\nlibrary OperationLib {\\n    function maxGasLimit(\\n        Operation calldata self,\\n        uint256 perJoinSplitVerifyGas\\n    ) internal pure returns (uint256) {\\n        uint256 numJoinSplits = totalNumJoinSplits(self);\\n        return\\n            self.executionGasLimit +\\n            ((perJoinSplitVerifyGas + GAS_PER_JOINSPLIT_HANDLE) *\\n                numJoinSplits) +\\n            ((GAS_PER_INSERTION_SUBTREE_UPDATE + GAS_PER_INSERTION_ENQUEUE) *\\n                (self.trackedAssets.length + (numJoinSplits * 2))) + // NOTE: assume refund for every asset\\n            GAS_PER_OPERATION_MISC;\\n    }\\n\\n    function maxGasAssetCost(\\n        Operation calldata self,\\n        uint256 perJoinSplitVerifyGas\\n    ) internal pure returns (uint256) {\\n        return self.gasPrice * maxGasLimit(self, perJoinSplitVerifyGas);\\n    }\\n\\n    function totalNumJoinSplits(\\n        Operation calldata self\\n    ) internal pure returns (uint256) {\\n        return self.pubJoinSplits.length + self.confJoinSplits.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\nimport {ITeller} from \\\"../interfaces/ITeller.sol\\\";\\nimport {Groth16} from \\\"../libs/Groth16.sol\\\";\\nimport {Pairing} from \\\"../libs/Pairing.sol\\\";\\nimport \\\"../libs/Types.sol\\\";\\n\\n// helpers for converting to/from field elems, uint256s, and/or bytes, and hashing them\\nlibrary Utils {\\n    uint256 public constant BN254_SCALAR_FIELD_MODULUS =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    uint256 constant COMPRESSED_POINT_SIGN_MASK = 1 << 254;\\n\\n    // takes a compressed point and extracts the sign bit and y coordinate\\n    // returns (sign, y)\\n    function decomposeCompressedPoint(\\n        uint256 compressedPoint\\n    ) internal pure returns (uint256 sign, uint256 y) {\\n        sign = (compressedPoint & COMPRESSED_POINT_SIGN_MASK) >> 254;\\n        y = compressedPoint & (COMPRESSED_POINT_SIGN_MASK - 1);\\n        return (sign, y);\\n    }\\n\\n    // return the minimum of the two values\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return (a >= b) ? b : a;\\n    }\\n\\n    function sum(uint256[] calldata arr) internal pure returns (uint256) {\\n        uint256 total = 0;\\n        uint256 arrLength = arr.length;\\n        for (uint256 i = 0; i < arrLength; i++) {\\n            total += arr[i];\\n        }\\n        return total;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SubtreeUpdateVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport {Pairing} from \\\"./libs/Pairing.sol\\\";\\nimport {Groth16} from \\\"./libs/Groth16.sol\\\";\\nimport {ISubtreeUpdateVerifier} from \\\"./interfaces/ISubtreeUpdateVerifier.sol\\\";\\n\\ncontract SubtreeUpdateVerifier is ISubtreeUpdateVerifier {\\n    function verifyingKey()\\n        internal\\n        pure\\n        returns (Groth16.VerifyingKey memory vk)\\n    {\\n        vk.alpha1 = Pairing.G1Point(\\n            20491192805390485299153009773594534940189261866228447918068658471970481763042,\\n            9383485363053290200918347156157836566562967994039712273449902621266178545958\\n        );\\n\\n        vk.beta2 = Pairing.G2Point(\\n            [\\n                4252822878758300859123897981450591353533073413197771768651442665752259397132,\\n                6375614351688725206403948262868962793625744043794305715222011528459656738731\\n            ],\\n            [\\n                21847035105528745403288232691147584728191162732299865338377159692350059136679,\\n                10505242626370262277552901082094356697409835680220590971873171140371331206856\\n            ]\\n        );\\n        vk.gamma2 = Pairing.G2Point(\\n            [\\n                11559732032986387107991004021392285783925812861821192530917403151452391805634,\\n                10857046999023057135944570762232829481370756359578518086990519993285655852781\\n            ],\\n            [\\n                4082367875863433681332203403145435568316851327593401208105741076214120093531,\\n                8495653923123431417604973247489272438418190587263600148770280649306958101930\\n            ]\\n        );\\n        vk.delta2 = Pairing.G2Point(\\n            [\\n                8375128401361197305554037484636724635621163262025162484255049675568974900459,\\n                7546132081304320305218259491541072721508954086036704036715956488223498511411\\n            ],\\n            [\\n                17157702631452704384720772426929820293586762510291689109924933160402979104497,\\n                20123063533604111324217499491522387896118699589610997967488719641070889045752\\n            ]\\n        );\\n        vk.IC = new Pairing.G1Point[](5);\\n\\n        vk.IC[0] = Pairing.G1Point(\\n            20652569512815664849625012136995289033137195992280887453381673336448907268802,\\n            7484049491656221335515662968781090800302317043578621431095133515268475163229\\n        );\\n        vk.IC[1] = Pairing.G1Point(\\n            7731982575410388714584746429686474504878221480656364039184630344777623741410,\\n            10105243033893519232528285859526601258334362972865394097850134068069372503538\\n        );\\n        vk.IC[2] = Pairing.G1Point(\\n            7357780158476298173467882518507052968508835768404159766830106776863976384567,\\n            10084034431275621207696706431676491777536005260955582471281696365384459062793\\n        );\\n        vk.IC[3] = Pairing.G1Point(\\n            3378904791035310730291772500625091534148858013520416497759095808615884468818,\\n            11200279180504860759436136121936450003352812925848094310533381754207972372219\\n        );\\n        vk.IC[4] = Pairing.G1Point(\\n            13493104793259691851423643824999274788920554901338293626179565314961892609760,\\n            18620874801238109909556671856595600704446001285185360730192248483904228304634\\n        );\\n    }\\n\\n    /// @return r  bool true if proof is valid\\n    function verifyProof(\\n        uint256[8] memory proof,\\n        uint256[] memory pi\\n    ) public view override returns (bool r) {\\n        return Groth16.verifyProof(verifyingKey(), proof, pi);\\n    }\\n\\n    /// @return r bool true if proofs are valid\\n    function batchVerifyProofs(\\n        uint256[8][] memory proofs,\\n        uint256[][] memory allPis\\n    ) public view override returns (bool) {\\n        return Groth16.batchVerifyProofs(verifyingKey(), proofs, allPis);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[8][]\",\"name\":\"proofs\",\"type\":\"uint256[8][]\"},{\"internalType\":\"uint256[][]\",\"name\":\"allPis\",\"type\":\"uint256[][]\"}],\"name\":\"batchVerifyProofs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"proof\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[]\",\"name\":\"pi\",\"type\":\"uint256[]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SubtreeUpdateVerifier", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}