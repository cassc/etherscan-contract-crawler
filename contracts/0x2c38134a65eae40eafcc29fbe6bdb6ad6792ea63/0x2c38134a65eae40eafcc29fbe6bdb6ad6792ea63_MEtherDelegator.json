{"SourceCode": "{\"InterestRateModel.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\n/**\\n  * @title Compound\\u0027s InterestRateModel Interface\\n  * @author Compound\\n  */\\ncontract InterestRateModel {\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n    bool public constant isInterestRateModel = true;\\n\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param fees The total amount of fees the market has\\n      * @param momaFees The total amount of Moma fees the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(\\n        uint cash, \\n        uint borrows, \\n        uint reserves, \\n        uint fees, \\n        uint momaFees\\n    ) external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @param fees The total amount of fees the market has\\n      * @param feeFactorMantissa The current fee factor the market has\\n      * @param momaFees The total amount of Moma fees the market has\\n      * @param momaFeeFactorMantissa The current Moma fees factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(\\n        uint cash, \\n        uint borrows, \\n        uint reserves, \\n        uint reserveFactorMantissa, \\n        uint fees, \\n        uint feeFactorMantissa, \\n        uint momaFees, \\n        uint momaFeeFactorMantissa\\n    ) external view returns (uint);\\n}\\n\"},\"MEtherDelegator.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./MTokenInterfaces.sol\\\";\\nimport \\\"./MomaFactoryInterface.sol\\\";\\n\\n/**\\n * @title Moma\\u0027s MEtherDelegator Contract\\n * @notice Ether MToken which delegate to an implementation\\n * @author Moma\\n */\\ncontract MEtherDelegator is MTokenStorage, MDelegatorInterface {\\n    /**\\n     * @notice Construct a new money market\\n     * @param momaMaster_ The address of the momaMaster\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     * @param becomeImplementationData The encoded args for becomeImplementation\\n     * @param feeReceiver_ Address of the free receiver of this token\\n     */\\n    constructor(MomaMasterInterface momaMaster_,\\n                uint initialExchangeRateMantissa_,\\n                string memory name_,\\n                string memory symbol_,\\n                uint8 decimals_,\\n                bytes memory becomeImplementationData,\\n                address payable feeReceiver_) public {\\n        // Get the address of the implementation the contract delegates to from factory\\n        address implementation_ = MomaFactoryInterface(momaMaster_.factory()).mEtherImplementation();\\n        require(implementation_ != address(0), \\u0027MEtherDelegator: ZERO FORBIDDEN\\u0027);\\n\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,uint256,string,string,uint8,address)\\\",\\n                                                            momaMaster_,\\n                                                            initialExchangeRateMantissa_,\\n                                                            name_,\\n                                                            symbol_,\\n                                                            decimals_,\\n                                                            feeReceiver_));\\n\\n        // New implementations always get set via the settor (post-initialize)\\n        _setImplementation(implementation_, false, becomeImplementationData);\\n\\n    }\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\\n        require(msg.sender == momaMaster.admin(), \\\"MEtherDelegator::_setImplementation: Caller must be admin\\\");\\n\\n        // Check is mEther\\n        require(MomaFactoryInterface(momaMaster.factory()).isMEtherImplementation(implementation_) == true, \\u0027MEtherDelegator: not mEtherImplementation\\u0027);\\n\\n        if (allowResign) {\\n            delegateToImplementation(abi.encodeWithSignature(\\\"_resignImplementation()\\\"));\\n        }\\n\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n\\n        delegateToImplementation(abi.encodeWithSignature(\\\"_becomeImplementation(bytes)\\\", becomeImplementationData));\\n\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint amount) external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", src, dst, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\\\"approve(address,uint256)\\\", spender, amount));\\n        return abi.decode(data, (bool));\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"allowance(address,address)\\\", owner, spender));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) external view returns (uint) {\\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\\\"balanceOf(address)\\\", owner));\\n        return abi.decode(data, (uint));\\n    }\\n\\n    /**\\n     * @notice Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize)\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    /**\\n     * @notice Delegates execution to the implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\n        return delegateTo(implementation, data);\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize)\\n            }\\n        }\\n        return abi.decode(returnData, (bytes));\\n    }\\n\\n    /**\\n     * @notice Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     */\\n    function () external payable {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = implementation.delegatecall(msg.data);\\n\\n        assembly {\\n            let free_mem_ptr := mload(0x40)\\n            returndatacopy(free_mem_ptr, 0, returndatasize)\\n\\n            switch success\\n            case 0 { revert(free_mem_ptr, returndatasize) }\\n            default { return(free_mem_ptr, returndatasize) }\\n        }\\n    }\\n}\\n\"},\"MomaFactoryInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ninterface MomaFactoryInterface {\\n\\n    event PoolCreated(address pool, address creator, uint poolLength);\\n    event NewMomaFarming(address oldMomaFarming, address newMomaFarming);\\n    event NewFarmingDelegate(address oldDelegate, address newDelegate);\\n    event NewFeeAdmin(address oldFeeAdmin, address newFeeAdmin);\\n    event NewDefualtFeeReceiver(address oldFeeReceiver, address newFeeReceiver);\\n    event NewDefualtFeeFactor(uint oldFeeFactor, uint newFeeFactor);\\n    event NewNoFeeTokenStatus(address token, bool oldNoFeeTokenStatus, bool newNoFeeTokenStatus);\\n    event NewTokenFeeFactor(address token, uint oldFeeFactor, uint newFeeFactor);\\n    event NewOracle(address oldOracle, address newOracle);\\n    event NewTimelock(address oldTimelock, address newTimelock);\\n    event NewMomaMaster(address oldMomaMaster, address newMomaMaster);\\n    event NewMEther(address oldMEther, address newMEther);\\n    event NewMErc20(address oldMErc20, address newMErc20);\\n    event NewMErc20Implementation(address oldMErc20Implementation, address newMErc20Implementation);\\n    event NewMEtherImplementation(address oldMEtherImplementation, address newMEtherImplementation);\\n    event NewLendingPool(address pool);\\n    event NewPoolFeeAdmin(address pool, address oldPoolFeeAdmin, address newPoolFeeAdmin);\\n    event NewPoolFeeReceiver(address pool, address oldPoolFeeReceiver, address newPoolFeeReceiver);\\n    event NewPoolFeeFactor(address pool, uint oldPoolFeeFactor, uint newPoolFeeFactor);\\n    event NewPoolFeeStatus(address pool, bool oldPoolFeeStatus, bool newPoolFeeStatus);\\n\\n    function isMomaFactory() external view returns (bool);\\n    function oracle() external view returns (address);\\n    function momaFarming() external view returns (address);\\n    function farmingDelegate() external view returns (address);\\n    function mEtherImplementation() external view returns (address);\\n    function mErc20Implementation() external view returns (address);\\n    function admin() external view returns (address);\\n    function feeAdmin() external view returns (address);\\n    function defualtFeeReceiver() external view returns (address);\\n    function defualtFeeFactorMantissa() external view returns (uint);\\n    function feeFactorMaxMantissa() external view returns (uint);\\n\\n    function tokenFeeFactors(address token) external view returns (uint);\\n    // function pools(address pool) external view returns (PoolInfo memory);\\n    function allPools(uint) external view returns (address);\\n\\n    function createPool() external returns (address);\\n    function allPoolsLength() external view returns (uint);\\n    function getMomaFeeAdmin(address pool) external view returns (address);\\n    function getMomaFeeReceiver(address pool) external view returns (address payable);\\n    function getMomaFeeFactorMantissa(address pool, address underlying) external view returns (uint);\\n    function isMomaPool(address pool) external view returns (bool);\\n    function isLendingPool(address pool) external view returns (bool);\\n    function isTimelock(address b) external view returns (bool);\\n    function isMomaMaster(address b) external view returns (bool);\\n    function isMEtherImplementation(address b) external view returns (bool);\\n    function isMErc20Implementation(address b) external view returns (bool);\\n    function isMToken(address b) external view returns (bool);\\n    function isCodeSame(address a, address b) external view returns (bool);\\n\\n    function upgradeLendingPool() external returns (bool);\\n    \\n    function setFeeAdmin(address _newFeeAdmin) external;\\n    function setDefualtFeeReceiver(address payable _newFeeReceiver) external;\\n    function setDefualtFeeFactor(uint _newFeeFactor) external;\\n    function setTokenFeeFactor(address token, uint _newFeeFactor) external;\\n\\n    function setPoolFeeAdmin(address pool, address _newPoolFeeAdmin) external;\\n    function setPoolFeeReceiver(address pool, address payable _newPoolFeeReceiver) external;\\n    function setPoolFeeFactor(address pool, uint _newFeeFactor) external;\\n    function setPoolFeeStatus(address pool, bool _noFee) external;\\n}\\n\"},\"MomaMasterInterface.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\ninterface MomaMasterInterface {\\n    /// @notice Indicator that this is a MomaMaster contract (for inspection)\\n    function isMomaMaster() external view returns (bool);\\n\\n    function factory() external view returns (address);\\n    function admin() external view returns (address payable);\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata mTokens) external returns (uint[] memory);\\n    function exitMarket(address mToken) external returns (uint);\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(address mToken, address minter, uint mintAmount) external returns (uint);\\n    function mintVerify(address mToken, address minter, uint mintAmount, uint mintTokens) external;\\n\\n    function redeemAllowed(address mToken, address redeemer, uint redeemTokens) external returns (uint);\\n    function redeemVerify(address mToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\\n\\n    function borrowAllowed(address mToken, address borrower, uint borrowAmount) external returns (uint);\\n    function borrowVerify(address mToken, address borrower, uint borrowAmount) external;\\n\\n    function repayBorrowAllowed(\\n        address mToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) external returns (uint);\\n    function repayBorrowVerify(\\n        address mToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount,\\n        uint borrowerIndex) external;\\n\\n    function liquidateBorrowAllowed(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) external returns (uint);\\n    function liquidateBorrowVerify(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount,\\n        uint seizeTokens) external;\\n\\n    function seizeAllowed(\\n        address mTokenCollateral,\\n        address mTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) external returns (uint);\\n    function seizeVerify(\\n        address mTokenCollateral,\\n        address mTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) external;\\n\\n    function transferAllowed(address mToken, address src, address dst, uint transferTokens) external returns (uint);\\n    function transferVerify(address mToken, address src, address dst, uint transferTokens) external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address mTokenBorrowed,\\n        address mTokenCollateral,\\n        uint repayAmount) external view returns (uint, uint);\\n}\\n\"},\"MTokenInterfaces.sol\":{\"content\":\"pragma solidity 0.5.17;\\n\\nimport \\\"./MomaMasterInterface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\n\\ncontract MTokenStorage {\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    /**\\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\\n     */\\n\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    /**\\n     * @notice Maximum fraction of interest that can be set aside for fees\\n     */\\n    uint internal constant feeFactorMaxMantissa = 0.3e18;\\n\\n    /**\\n     * @notice Maximum fraction of interest that can be set aside for moma fees\\n     */\\n    uint internal constant momaFeeFactorMaxMantissa = 0.3e18;\\n\\n    /**\\n     * @notice Maximum fraction of interest that can be set aside for reserves\\n     */\\n    uint internal constant reserveFactorMaxMantissa = 0.4e18;\\n\\n    /**\\n     * @notice Fee receiver for this market\\n     */\\n    address payable public feeReceiver;\\n\\n    /**\\n     * @notice Contract which oversees inter-mToken operations\\n     */\\n    MomaMasterInterface public momaMaster;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    /**\\n     * @notice Initial exchange rate used when minting the first MTokens (used when totalSupply = 0)\\n     */\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for fees\\n     */\\n    uint public feeFactorMantissa = 0.1e18;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint public reserveFactorMantissa = 0.1e18;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of fees of the underlying held in this market\\n     */\\n    uint public totalFees;\\n\\n    /**\\n     * @notice Total amount of Moma fees of the underlying held in this market\\n     */\\n    uint public totalMomaFees;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint public totalSupply;\\n\\n    /**\\n     * @notice Official record of token balances for each account\\n     */\\n    mapping (address =\\u003e uint) internal accountTokens;\\n\\n    /**\\n     * @notice Approved token transfer amounts on behalf of others\\n     */\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) internal transferAllowances;\\n\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n    }\\n\\n    /**\\n     * @notice Mapping of account addresses to outstanding borrow balances\\n     */\\n    mapping(address =\\u003e BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Indicator that this is a MToken contract (for inspection)\\n     */\\n    bool public constant isMToken = true;\\n}\\n\\n\\ncontract MTokenInterface is MTokenStorage {\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address mTokenCollateral, uint seizeTokens);\\n\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when momaMaster is changed\\n     */\\n    event NewMomaMaster(MomaMasterInterface oldMomaMaster, MomaMasterInterface newMomaMaster);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\n\\n    /**\\n     * @notice Event emitted when feeReceiver is changed\\n     */\\n    event NewFeeReceiver(address oldFeeReceiver, address newFeeReceiver);\\n\\n    /**\\n     * @notice Event emitted when the fee factor is changed\\n     */\\n    event NewFeeFactor(uint oldFeeFactorMantissa, uint newFeeFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the fees are collected\\n     */\\n    event FeesCollected(address feeReceiver, uint collectAmount, uint newTotalFees);\\n\\n    /**\\n     * @notice Event emitted when the moma fees are collected\\n     */\\n    event MomaFeesCollected(address momaFeeReceiver, uint collectAmount, uint newTotalMomaFees);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /**\\n     * @notice Failure event\\n     */\\n    event Failure(uint error, uint info, uint detail);\\n\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrowBalanceStored(address account) public view returns (uint);\\n    function exchangeRateCurrent() public returns (uint);\\n    function exchangeRateStored() public view returns (uint);\\n    function getCash() external view returns (uint);\\n    function getMomaFeeFactor() external view returns (uint);\\n    function accrueInterest() public returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _setFeeReceiver(address payable newFeeReceiver) external returns (uint);\\n    function _setFeeFactor(uint newFeeFactorMantissa) external returns (uint);\\n    function _collectFees(uint collectAmount) external returns (uint);\\n    function _collectMomaFees(uint collectAmount) external returns (uint);\\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\\n    function _reduceReserves(uint reduceAmount) external returns (uint);\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) external returns (uint);\\n}\\n\\ncontract MErc20Storage {\\n    /**\\n     * @notice Underlying asset for this MToken\\n     */\\n    address public underlying;\\n}\\n\\ncontract MErc20Interface is MErc20Storage {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, MTokenInterface mTokenCollateral) external returns (uint);\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint addAmount) external returns (uint);\\n}\\n\\ncontract MDelegationStorage {\\n    /**\\n     * @notice Implementation address for this contract\\n     */\\n    address public implementation;\\n}\\n\\ncontract MDelegatorInterface is MDelegationStorage {\\n    /**\\n     * @notice Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\\n}\\n\\ncontract MDelegateInterface is MDelegationStorage {\\n    /**\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\n     * @param data The encoded bytes data for any initialization\\n     */\\n    function _becomeImplementation(bytes memory data) public;\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\n     */\\n    function _resignImplementation() public;\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract MomaMasterInterface\",\"name\":\"momaMaster_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialExchangeRateMantissa_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"feeReceiver_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowResign\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"becomeImplementationData\",\"type\":\"bytes\"}],\"name\":\"_setImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToViewImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRateModel\",\"outputs\":[{\"internalType\":\"contract InterestRateModel\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"momaMaster\",\"outputs\":[{\"internalType\":\"contract MomaMasterInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFactorMantissa\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMomaFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MEtherDelegator", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001d6426d6f55ad3b36f7a4fdf328a16064df380bf000000000000000000000000000000000000000000a56fa5b99019a5c800000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000160000000000000000000000000376fe4d01f14ed16ddda449f8dd331e2970b33d600000000000000000000000000000000000000000000000000000000000000084d6f6d612045544800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046d455448000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "1", "Implementation": "0xf844e4db41c7dab7a7b548248d7ace39e694c9b8", "SwarmSource": "bzzr://75c18f2496806c6da6f5e00c95967b888767a368217dd6fc93fa18d2da11ca61"}