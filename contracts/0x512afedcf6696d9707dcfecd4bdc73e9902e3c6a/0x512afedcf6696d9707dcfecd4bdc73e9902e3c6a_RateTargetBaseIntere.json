{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RateTargetBaseInterestRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport { IRateSource } from './interfaces/IRateSource.sol';\\n\\nimport {\\n    VariableBorrowInterestRateStrategy,\\n    IPoolAddressesProvider\\n} from './VariableBorrowInterestRateStrategy.sol';\\n\\n/**\\n * @title  RateTargetBaseInterestRateStrategy\\n * @notice Sets the base interest rate as a fixed spread from a rate source.\\n */\\ncontract RateTargetBaseInterestRateStrategy is VariableBorrowInterestRateStrategy {\\n\\n    IRateSource public immutable RATE_SOURCE;\\n\\n    // Base variable borrow rate spread when usage rate = 0. Expressed in ray.\\n    uint256 internal immutable _baseVariableBorrowRateSpread;\\n\\n    /**\\n     * @dev   Constructor.\\n     * @param provider                     The address of the PoolAddressesProvider contract.\\n     * @param rateSource                   The address of the rate source contract.\\n     * @param optimalUsageRatio            The optimal usage ratio.\\n     * @param baseVariableBorrowRateSpread The base variable borrow rate spread.\\n     * @param variableRateSlope1           The variable rate slope below optimal usage ratio.\\n     * @param variableRateSlope2           The variable rate slope above optimal usage ratio.\\n     */\\n    constructor(\\n        IPoolAddressesProvider provider,\\n        address rateSource,\\n        uint256 optimalUsageRatio,\\n        uint256 baseVariableBorrowRateSpread,\\n        uint256 variableRateSlope1,\\n        uint256 variableRateSlope2\\n    ) VariableBorrowInterestRateStrategy(\\n        provider,\\n        optimalUsageRatio,\\n        0,\\n        variableRateSlope1,\\n        variableRateSlope2\\n    ) {\\n        RATE_SOURCE = IRateSource(rateSource);\\n\\n        _baseVariableBorrowRateSpread = baseVariableBorrowRateSpread;\\n    }\\n\\n    function _getBaseVariableBorrowRate() internal override view returns (uint256) {\\n        uint256 apr = RATE_SOURCE.getAPR();\\n        return apr + _baseVariableBorrowRateSpread;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRateSource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\ninterface IRateSource {\\n    function getAPR() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/VariableBorrowInterestRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport { IERC20 } from 'aave-v3-core/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\\n\\nimport { IDefaultInterestRateStrategy } from 'aave-v3-core/contracts/interfaces/IDefaultInterestRateStrategy.sol';\\nimport { IPoolAddressesProvider }       from 'aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol';\\nimport { IReserveInterestRateStrategy } from 'aave-v3-core/contracts/interfaces/IReserveInterestRateStrategy.sol';\\n\\nimport { DataTypes }      from 'aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol';\\nimport { Errors }         from 'aave-v3-core/contracts/protocol/libraries/helpers/Errors.sol';\\nimport { PercentageMath } from 'aave-v3-core/contracts/protocol/libraries/math/PercentageMath.sol';\\nimport { WadRayMath }     from 'aave-v3-core/contracts/protocol/libraries/math/WadRayMath.sol';\\n\\n/**\\n * @title  VariableBorrowInterestRateStrategy contract\\n * @author Aave\\n * @notice Implements the calculation of the interest rates depending on the reserve state.\\n * @dev    The model of interest rate is based on 2 slopes, one before the `OPTIMAL_USAGE_RATIO`\\n *         point of usage and another from that one to 100%.\\n *         - An instance of this same contract, can't be used across different Aave markets,\\n *           due to the caching of the PoolAddressesProvider.\\n *         - NOTE: This is a modified version of DefaultReserveInterestRateStrategy with\\n *                 the stable borrow feature disabled.\\n */\\ncontract VariableBorrowInterestRateStrategy is IDefaultInterestRateStrategy {\\n\\n    using WadRayMath     for uint256;\\n    using PercentageMath for uint256;\\n\\n    /**********************************************************************************************/\\n    /*** Declarations and Constructor                                                           ***/\\n    /**********************************************************************************************/\\n\\n    // Unused functionality, so initialized to 100% and 0% respectively.\\n    uint256 public override constant MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = WadRayMath.RAY;\\n    uint256 public override constant OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO    = 0;\\n\\n    uint256 public override immutable MAX_EXCESS_USAGE_RATIO;\\n    uint256 public override immutable OPTIMAL_USAGE_RATIO;\\n\\n    IPoolAddressesProvider public override immutable ADDRESSES_PROVIDER;\\n\\n    // Base variable borrow rate when usage rate = 0.\\n    // Expressed in ray.\\n    uint256 internal immutable _baseVariableBorrowRate;\\n\\n    // Slope of the variable interest curve when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO.\\n    // Expressed in ray.\\n    uint256 internal immutable _variableRateSlope1;\\n\\n    // Slope of the variable interest curve when usage ratio > OPTIMAL_USAGE_RATIO.\\n    // Expressed in ray.\\n    uint256 internal immutable _variableRateSlope2;\\n\\n    /**\\n     * @dev   Constructor.\\n     * @param provider               The address of the PoolAddressesProvider contract.\\n     * @param optimalUsageRatio      The optimal usage ratio.\\n     * @param baseVariableBorrowRate The base variable borrow rate.\\n     * @param variableRateSlope1     The variable rate slope below optimal usage ratio.\\n     * @param variableRateSlope2     The variable rate slope above optimal usage ratio.\\n     */\\n    constructor(\\n        IPoolAddressesProvider provider,\\n        uint256 optimalUsageRatio,\\n        uint256 baseVariableBorrowRate,\\n        uint256 variableRateSlope1,\\n        uint256 variableRateSlope2\\n    ) {\\n        require(WadRayMath.RAY >= optimalUsageRatio, Errors.INVALID_OPTIMAL_USAGE_RATIO);\\n\\n        OPTIMAL_USAGE_RATIO    = optimalUsageRatio;\\n        MAX_EXCESS_USAGE_RATIO = WadRayMath.RAY - optimalUsageRatio;\\n        ADDRESSES_PROVIDER     = provider;\\n\\n        _baseVariableBorrowRate = baseVariableBorrowRate;\\n        _variableRateSlope1     = variableRateSlope1;\\n        _variableRateSlope2     = variableRateSlope2;\\n    }\\n\\n    /**********************************************************************************************/\\n    /*** Internal Virtual Functions (Override for different functionality)                      ***/\\n    /**********************************************************************************************/\\n\\n    function _getBaseVariableBorrowRate() internal virtual view returns (uint256) {\\n        return _baseVariableBorrowRate;\\n    }\\n\\n    function _getVariableRateSlope1() internal virtual view returns (uint256) {\\n        return _variableRateSlope1;\\n    }\\n\\n    function _getVariableRateSlope2() internal virtual view returns (uint256) {\\n        return _variableRateSlope2;\\n    }\\n\\n    /**********************************************************************************************/\\n    /*** Standard Interface Getter Functions                                                    ***/\\n    /**********************************************************************************************/\\n\\n    function getBaseStableBorrowRate() external override view returns (uint256) {\\n        return _getVariableRateSlope1();\\n    }\\n\\n    function getBaseVariableBorrowRate() external override view returns (uint256) {\\n        return _getBaseVariableBorrowRate();\\n    }\\n\\n    function getVariableRateSlope1() external override view returns (uint256) {\\n        return _getVariableRateSlope1();\\n    }\\n\\n    function getVariableRateSlope2() external override view returns (uint256) {\\n        return _getVariableRateSlope2();\\n    }\\n\\n    function getStableRateSlope1() external override pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function getStableRateSlope2() external override pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function getStableRateExcessOffset() external override pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function getMaxVariableBorrowRate() external view override returns (uint256) {\\n        return _getBaseVariableBorrowRate() + _getVariableRateSlope1() + _getVariableRateSlope2();\\n    }\\n\\n    /**********************************************************************************************/\\n    /*** Interest Calculation Function                                                          ***/\\n    /**********************************************************************************************/\\n\\n    struct CalcInterestRatesLocalVars {\\n        uint256 availableLiquidity;\\n        uint256 currentVariableBorrowRate;\\n        uint256 currentLiquidityRate;\\n        uint256 borrowUsageRatio;\\n        uint256 supplyUsageRatio;\\n        uint256 availableLiquidityPlusDebt;\\n    }\\n\\n    function calculateInterestRates(\\n        DataTypes.CalculateInterestRatesParams memory params\\n    )\\n        external view override\\n        returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate)\\n    {\\n        CalcInterestRatesLocalVars memory vars;\\n\\n        // 1. Set the current variable borrow rate to the base rate.\\n\\n        vars.currentLiquidityRate      = 0;\\n        vars.currentVariableBorrowRate = _getBaseVariableBorrowRate();\\n\\n        // 2. Calculate the borrow and supply usage ratios.\\n\\n        if (params.totalVariableDebt != 0) {\\n            // Calculate the total resulting cash in the reserve after the call is complete.\\n            vars.availableLiquidity =\\n                IERC20(params.reserve).balanceOf(params.aToken) +\\n                params.liquidityAdded -\\n                params.liquidityTaken;\\n\\n            // Calculate the total value of the asset in the reserve (cash + debt).\\n            vars.availableLiquidityPlusDebt = vars.availableLiquidity + params.totalVariableDebt;\\n\\n            // Calculate the borrowUsageRatio (debt / total value).\\n            vars.borrowUsageRatio = params.totalVariableDebt.rayDiv(vars.availableLiquidityPlusDebt);\\n\\n            // Calculate the supplyUsageRatio (debt / total value + unbacked).\\n            // NOTE: The supplyUsageRatio will almost always equal the borrowUsageRatio, except\\n            //       when unbacked aTokens are minted.\\n            vars.supplyUsageRatio\\n                = params.totalVariableDebt.rayDiv(vars.availableLiquidityPlusDebt + params.unbacked);\\n        }\\n\\n        // 3. Calculate the variable borrow rate, using the 2-slope model.\\n\\n        if (vars.borrowUsageRatio > OPTIMAL_USAGE_RATIO) {\\n            // excessBorrowUsageRatio = (borrowRatio - optimalRatio) / (1 - optimalRatio)\\n            uint256 excessBorrowUsageRatio\\n                = (vars.borrowUsageRatio - OPTIMAL_USAGE_RATIO).rayDiv(MAX_EXCESS_USAGE_RATIO);\\n\\n            vars.currentVariableBorrowRate +=\\n                _getVariableRateSlope1() +\\n                _getVariableRateSlope2().rayMul(excessBorrowUsageRatio);\\n        } else {\\n            vars.currentVariableBorrowRate +=\\n                _getVariableRateSlope1().rayMul(vars.borrowUsageRatio).rayDiv(OPTIMAL_USAGE_RATIO);\\n        }\\n\\n        // 4. Calculate the liquidity rate by multiplying the current variable borrow rate by\\n        //    the supply usage ratio and multiplying by (100% - the protocol's reserve factor).\\n        //    This yields the amount that the lenders are earning based on the interest paid by\\n        //    the borrowers, before the protocol's cut, taking into account idle capital.\\n\\n        if (params.totalVariableDebt != 0) {\\n            vars.currentLiquidityRate =\\n                vars.currentVariableBorrowRate\\n                .rayMul(vars.supplyUsageRatio)\\n                .percentMul(PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor);\\n        }\\n\\n        return (\\n            vars.currentLiquidityRate,\\n            0,\\n            vars.currentVariableBorrowRate\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/dependencies/openzeppelin/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/interfaces/IDefaultInterestRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\\n\\n/**\\n * @title IDefaultInterestRateStrategy\\n * @author Aave\\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\\n */\\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\\n  /**\\n   * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\\n   * @return The optimal usage ratio, expressed in ray.\\n   */\\n  function OPTIMAL_USAGE_RATIO() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the optimal stable to total debt ratio of the reserve.\\n   * @return The optimal stable to total debt ratio, expressed in ray.\\n   */\\n  function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the excess usage ratio above the optimal.\\n   * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\\n   * @return The max excess usage ratio, expressed in ray.\\n   */\\n  function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the excess stable debt ratio above the optimal.\\n   * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\\n   * @return The max excess stable to total debt ratio, expressed in ray.\\n   */\\n  function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the address of the PoolAddressesProvider\\n   * @return The address of the PoolAddressesProvider contract\\n   */\\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\\n\\n  /**\\n   * @notice Returns the variable rate slope below optimal usage ratio\\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\\n   * @return The variable rate slope, expressed in ray\\n   */\\n  function getVariableRateSlope1() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the variable rate slope above optimal usage ratio\\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\\n   * @return The variable rate slope, expressed in ray\\n   */\\n  function getVariableRateSlope2() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the stable rate slope below optimal usage ratio\\n   * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\\n   * @return The stable rate slope, expressed in ray\\n   */\\n  function getStableRateSlope1() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the stable rate slope above optimal usage ratio\\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\\n   * @return The stable rate slope, expressed in ray\\n   */\\n  function getStableRateSlope2() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the stable rate excess offset\\n   * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\\n   * @return The stable rate excess offset, expressed in ray\\n   */\\n  function getStableRateExcessOffset() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the base stable borrow rate\\n   * @return The base stable borrow rate, expressed in ray\\n   */\\n  function getBaseStableBorrowRate() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the base variable borrow rate\\n   * @return The base variable borrow rate, expressed in ray\\n   */\\n  function getBaseVariableBorrowRate() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the maximum variable borrow rate\\n   * @return The maximum variable borrow rate, expressed in ray\\n   */\\n  function getMaxVariableBorrowRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n  /**\\n   * @dev Emitted when the market identifier is updated.\\n   * @param oldMarketId The old id of the market\\n   * @param newMarketId The new id of the market\\n   */\\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n\\n  /**\\n   * @dev Emitted when the pool is updated.\\n   * @param oldAddress The old address of the Pool\\n   * @param newAddress The new address of the Pool\\n   */\\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool configurator is updated.\\n   * @param oldAddress The old address of the PoolConfigurator\\n   * @param newAddress The new address of the PoolConfigurator\\n   */\\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle is updated.\\n   * @param oldAddress The old address of the PriceOracle\\n   * @param newAddress The new address of the PriceOracle\\n   */\\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL manager is updated.\\n   * @param oldAddress The old address of the ACLManager\\n   * @param newAddress The new address of the ACLManager\\n   */\\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL admin is updated.\\n   * @param oldAddress The old address of the ACLAdmin\\n   * @param newAddress The new address of the ACLAdmin\\n   */\\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle sentinel is updated.\\n   * @param oldAddress The old address of the PriceOracleSentinel\\n   * @param newAddress The new address of the PriceOracleSentinel\\n   */\\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool data provider is updated.\\n   * @param oldAddress The old address of the PoolDataProvider\\n   * @param newAddress The new address of the PoolDataProvider\\n   */\\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when a new proxy is created.\\n   * @param id The identifier of the proxy\\n   * @param proxyAddress The address of the created proxy contract\\n   * @param implementationAddress The address of the implementation contract\\n   */\\n  event ProxyCreated(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address indexed implementationAddress\\n  );\\n\\n  /**\\n   * @dev Emitted when a new non-proxied contract address is registered.\\n   * @param id The identifier of the contract\\n   * @param oldAddress The address of the old contract\\n   * @param newAddress The address of the new contract\\n   */\\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the implementation of the proxy registered with id is updated\\n   * @param id The identifier of the contract\\n   * @param proxyAddress The address of the proxy contract\\n   * @param oldImplementationAddress The address of the old implementation contract\\n   * @param newImplementationAddress The address of the new implementation contract\\n   */\\n  event AddressSetAsProxy(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address oldImplementationAddress,\\n    address indexed newImplementationAddress\\n  );\\n\\n  /**\\n   * @notice Returns the id of the Aave market to which this contract points to.\\n   * @return The market id\\n   */\\n  function getMarketId() external view returns (string memory);\\n\\n  /**\\n   * @notice Associates an id with a specific PoolAddressesProvider.\\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n   * identify and validate multiple Aave markets.\\n   * @param newMarketId The market id\\n   */\\n  function setMarketId(string calldata newMarketId) external;\\n\\n  /**\\n   * @notice Returns an address by its identifier.\\n   * @dev The returned address might be an EOA or a contract, potentially proxied\\n   * @dev It returns ZERO if there is no registered address with the given id\\n   * @param id The id\\n   * @return The address of the registered for the specified id\\n   */\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  /**\\n   * @notice General function to update the implementation of a proxy registered with\\n   * certain `id`. If there is no proxy registered, it will instantiate one and\\n   * set as implementation the `newImplementationAddress`.\\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n   * setter function, in order to avoid unexpected consequences\\n   * @param id The id\\n   * @param newImplementationAddress The address of the new implementation\\n   */\\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\\n\\n  /**\\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n   * @param id The id\\n   * @param newAddress The address to set\\n   */\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  /**\\n   * @notice Returns the address of the Pool proxy.\\n   * @return The Pool proxy address\\n   */\\n  function getPool() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the Pool, or creates a proxy\\n   * setting the new `pool` implementation when the function is called for the first time.\\n   * @param newPoolImpl The new Pool implementation\\n   */\\n  function setPoolImpl(address newPoolImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the PoolConfigurator proxy.\\n   * @return The PoolConfigurator proxy address\\n   */\\n  function getPoolConfigurator() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n   */\\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle.\\n   * @return The address of the PriceOracle\\n   */\\n  function getPriceOracle() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle.\\n   * @param newPriceOracle The address of the new PriceOracle\\n   */\\n  function setPriceOracle(address newPriceOracle) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL manager.\\n   * @return The address of the ACLManager\\n   */\\n  function getACLManager() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL manager.\\n   * @param newAclManager The address of the new ACLManager\\n   */\\n  function setACLManager(address newAclManager) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL admin.\\n   * @return The address of the ACL admin\\n   */\\n  function getACLAdmin() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL admin.\\n   * @param newAclAdmin The address of the new ACL admin\\n   */\\n  function setACLAdmin(address newAclAdmin) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle sentinel.\\n   * @return The address of the PriceOracleSentinel\\n   */\\n  function getPriceOracleSentinel() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle sentinel.\\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n   */\\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n\\n  /**\\n   * @notice Returns the address of the data provider.\\n   * @return The address of the DataProvider\\n   */\\n  function getPoolDataProvider() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the data provider.\\n   * @param newDataProvider The address of the new DataProvider\\n   */\\n  function setPoolDataProvider(address newDataProvider) external;\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/interfaces/IReserveInterestRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\\n\\n/**\\n * @title IReserveInterestRateStrategy\\n * @author Aave\\n * @notice Interface for the calculation of the interest rates\\n */\\ninterface IReserveInterestRateStrategy {\\n  /**\\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\\n   * @param params The parameters needed to calculate interest rates\\n   * @return liquidityRate The liquidity rate expressed in rays\\n   * @return stableBorrowRate The stable borrow rate expressed in rays\\n   * @return variableBorrowRate The variable borrow rate expressed in rays\\n   */\\n  function calculateInterestRates(\\n    DataTypes.CalculateInterestRatesParams memory params\\n  ) external view returns (uint256, uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    //timestamp of last update\\n    uint40 lastUpdateTimestamp;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint16 id;\\n    //aToken address\\n    address aTokenAddress;\\n    //stableDebtToken address\\n    address stableDebtTokenAddress;\\n    //variableDebtToken address\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the current treasury balance, scaled\\n    uint128 accruedToTreasury;\\n    //the outstanding unbacked aTokens minted through the bridging feature\\n    uint128 unbacked;\\n    //the outstanding debt borrowed against this asset in isolation mode\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60: asset is paused\\n    //bit 61: borrowing in isolation mode is enabled\\n    //bit 62: siloed borrowing enabled\\n    //bit 63: flashloaning enabled\\n    //bit 64-79: reserve factor\\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n    //bit 152-167 liquidation protocol fee\\n    //bit 168-175 eMode category\\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n    //bit 252-255 unused\\n\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    /**\\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n     * asset is borrowed by the user.\\n     */\\n    uint256 data;\\n  }\\n\\n  struct EModeCategory {\\n    // each eMode category has a custom ltv and liquidation threshold\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n    address priceSource;\\n    string label;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n\\n  struct ReserveCache {\\n    uint256 currScaledVariableDebt;\\n    uint256 nextScaledVariableDebt;\\n    uint256 currPrincipalStableDebt;\\n    uint256 currAvgStableBorrowRate;\\n    uint256 currTotalStableDebt;\\n    uint256 nextAvgStableBorrowRate;\\n    uint256 nextTotalStableDebt;\\n    uint256 currLiquidityIndex;\\n    uint256 nextLiquidityIndex;\\n    uint256 currVariableBorrowIndex;\\n    uint256 nextVariableBorrowIndex;\\n    uint256 currLiquidityRate;\\n    uint256 currVariableBorrowRate;\\n    uint256 reserveFactor;\\n    ReserveConfigurationMap reserveConfiguration;\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    uint40 reserveLastUpdateTimestamp;\\n    uint40 stableDebtLastUpdateTimestamp;\\n  }\\n\\n  struct ExecuteLiquidationCallParams {\\n    uint256 reservesCount;\\n    uint256 debtToCover;\\n    address collateralAsset;\\n    address debtAsset;\\n    address user;\\n    bool receiveAToken;\\n    address priceOracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteSupplyParams {\\n    address asset;\\n    uint256 amount;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address asset;\\n    address user;\\n    address onBehalfOf;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint16 referralCode;\\n    bool releaseUnderlying;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address asset;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    address onBehalfOf;\\n    bool useATokens;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address asset;\\n    uint256 amount;\\n    address to;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ExecuteSetUserEModeParams {\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 categoryId;\\n  }\\n\\n  struct FinalizeTransferParams {\\n    address asset;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 balanceFromBefore;\\n    uint256 balanceToBefore;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 fromEModeCategory;\\n  }\\n\\n  struct FlashloanParams {\\n    address receiverAddress;\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] interestRateModes;\\n    address onBehalfOf;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address addressesProvider;\\n    uint8 userEModeCategory;\\n    bool isAuthorizedFlashBorrower;\\n  }\\n\\n  struct FlashloanSimpleParams {\\n    address receiverAddress;\\n    address asset;\\n    uint256 amount;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n  }\\n\\n  struct FlashLoanRepaymentParams {\\n    uint256 amount;\\n    uint256 totalPremium;\\n    uint256 flashLoanPremiumToProtocol;\\n    address asset;\\n    address receiverAddress;\\n    uint16 referralCode;\\n  }\\n\\n  struct CalculateUserAccountDataParams {\\n    UserConfigurationMap userConfig;\\n    uint256 reservesCount;\\n    address user;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ValidateBorrowParams {\\n    ReserveCache reserveCache;\\n    UserConfigurationMap userConfig;\\n    address asset;\\n    address userAddress;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint256 maxStableLoanPercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n    bool isolationModeActive;\\n    address isolationModeCollateralAddress;\\n    uint256 isolationModeDebtCeiling;\\n  }\\n\\n  struct ValidateLiquidationCallParams {\\n    ReserveCache debtReserveCache;\\n    uint256 totalDebt;\\n    uint256 healthFactor;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct CalculateInterestRatesParams {\\n    uint256 unbacked;\\n    uint256 liquidityAdded;\\n    uint256 liquidityTaken;\\n    uint256 totalStableDebt;\\n    uint256 totalVariableDebt;\\n    uint256 averageStableBorrowRate;\\n    uint256 reserveFactor;\\n    address reserve;\\n    address aToken;\\n  }\\n\\n  struct InitReserveParams {\\n    address asset;\\n    address aTokenAddress;\\n    address stableDebtAddress;\\n    address variableDebtAddress;\\n    address interestRateStrategyAddress;\\n    uint16 reservesCount;\\n    uint16 maxNumberReserves;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/protocol/libraries/helpers/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Errors library\\n * @author Aave\\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\\n */\\nlibrary Errors {\\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\\n  string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = '62'; // 'User is in isolation mode or ltv is zero'\\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/protocol/libraries/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n */\\nlibrary PercentageMath {\\n  // Maximum percentage factor (100.00%)\\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\\n\\n  // Half percentage factor (50.00%)\\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\\n\\n  /**\\n   * @notice Executes a percentage multiplication\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return result value percentmul percentage\\n   */\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\\n    assembly {\\n      if iszero(\\n        or(\\n          iszero(percentage),\\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\\n        )\\n      ) {\\n        revert(0, 0)\\n      }\\n\\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\\n    }\\n  }\\n\\n  /**\\n   * @notice Executes a percentage division\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return result value percentdiv percentage\\n   */\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\\n    assembly {\\n      if or(\\n        iszero(percentage),\\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\\n      ) {\\n        revert(0, 0)\\n      }\\n\\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/aave-v3-core/contracts/protocol/libraries/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n */\\nlibrary WadRayMath {\\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant HALF_WAD = 0.5e18;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant HALF_RAY = 0.5e27;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @param b Wad\\n   * @return c = a*b, in wad\\n   */\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n    assembly {\\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\\n        revert(0, 0)\\n      }\\n\\n      c := div(add(mul(a, b), HALF_WAD), WAD)\\n    }\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @param b Wad\\n   * @return c = a/b, in wad\\n   */\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n    assembly {\\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\\n        revert(0, 0)\\n      }\\n\\n      c := div(add(mul(a, WAD), div(b, 2)), b)\\n    }\\n  }\\n\\n  /**\\n   * @notice Multiplies two ray, rounding half up to the nearest ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @param b Ray\\n   * @return c = a raymul b\\n   */\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n    assembly {\\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\\n        revert(0, 0)\\n      }\\n\\n      c := div(add(mul(a, b), HALF_RAY), RAY)\\n    }\\n  }\\n\\n  /**\\n   * @notice Divides two ray, rounding half up to the nearest ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @param b Ray\\n   * @return c = a raydiv b\\n   */\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n    assembly {\\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\\n        revert(0, 0)\\n      }\\n\\n      c := div(add(mul(a, RAY), div(b, 2)), b)\\n    }\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Ray\\n   * @return b = a converted to wad, rounded half up to the nearest wad\\n   */\\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n    assembly {\\n      b := div(a, WAD_RAY_RATIO)\\n      let remainder := mod(a, WAD_RAY_RATIO)\\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n        b := add(b, 1)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n   * @param a Wad\\n   * @return b = a converted in ray\\n   */\\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n    // to avoid overflow, b/WAD_RAY_RATIO == a\\n    assembly {\\n      b := mul(a, WAD_RAY_RATIO)\\n\\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n        revert(0, 0)\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"aave-v3-core/=lib/aave-v3-core/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc20-helpers/=lib/erc20-helpers/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rateSource\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"optimalUsageRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVariableBorrowRateSpread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableRateSlope2\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESSES_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EXCESS_USAGE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPTIMAL_USAGE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_SOURCE\",\"outputs\":[{\"internalType\":\"contract IRateSource\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unbacked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTaken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVariableDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"averageStableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactor\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aToken\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.CalculateInterestRatesParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calculateInterestRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseStableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseVariableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxVariableBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateExcessOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateSlope1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableRateSlope2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVariableRateSlope1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVariableRateSlope2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RateTargetBaseInterestRateStrategy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000002c3ea4e34c0cbd694d2adfa2c690eecbc1793ee00000000000000000000000062b122a1d1ea2082c47c3fb70e788c168e96afd80000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000b6c2a2d2289f967b7918000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}