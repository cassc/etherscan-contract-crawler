{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interpreter/run/LibInterpreterState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"rain.interface.interpreter/IInterpreterV1.sol\\\";\\nimport \\\"rain.interface.interpreter/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackPointer.sol\\\";\\nimport \\\"rain.lib.typecast/LibConvert.sol\\\";\\nimport \\\"sol.lib.memory/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Debugging options for a standard console log over the interpreter state.\\n/// - Stack: Log the entire stack, respects the current stack top, i.e. DOES NOT\\n///   log every value of the underlying `uint256[]` unless the stack top points\\n///   to the end of the array.\\n/// - Constant: Log every constant available to the current expression.\\n/// - Context: Log every column/row of context available to the current eval.\\n/// - Source: Log all the raw bytes of the compiled sources being evaluated.\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// The standard in-memory representation of an interpreter that facilitates\\n/// decoupled coordination between opcodes. Opcodes MAY:\\n///\\n/// - push and pop values to the shared stack\\n/// - read per-expression constants\\n/// - write to the final state changes set within the fully qualified namespace\\n/// - read per-eval context values\\n/// - recursively evaluate any compiled source associated with the expression\\n///\\n/// As the interpreter defines the opcodes it is its responsibility to ensure the\\n/// opcodes are incapable of doing anything to undermine security or correctness.\\n/// For example, a hypothetical opcode could modify the current namespace from\\n/// the stack, but this would be a very bad idea as it would allow expressions\\n/// to hijack storage values associated with other callers, fundamentally\\n/// breaking the state sandbox model.\\n///\\n/// The iterpreter MAY skip any runtime integrity checks that can be reasonably\\n/// assumed to have been performed by a competent expression deployer, such as\\n/// guarding against stack underflow. A competent expression deployer MAY NOT\\n/// have deployed the currently evaluating expression, so the interpreter MUST\\n/// avoid state changes during evaluation, but MAY return garbage data if the\\n/// calling contract fails to leverage an appropriate expression deployer.\\n///\\n/// @param stackBottom Opcodes write to the stack starting at the stack bottom,\\n/// ideally using `LibStackPointer` to normalise push and pop behaviours. A\\n/// competent expression deployer will calculate a memory preallocation that\\n/// pushes and pops above the stack bottom effectively allocate and deallocate\\n/// memory within.\\n/// @param constantsBottom Opcodes read constants starting at the pointer to\\n/// the bottom of the constants array. As the name implies the interpreter MUST\\n/// NOT write to the constants, it is read only.\\n/// @param stateKV The in memory key/value store that tracks reads/writes over\\n/// the underlying interpreter storage for the duration of a single expression\\n/// evaluation.\\n/// @param namespace The fully qualified namespace that all state reads and\\n/// writes MUST be performed under.\\n/// @param store The store to reference ostensibly for gets but perhaps other\\n/// things.\\n/// @param context A 2-dimensional array of per-eval data provided by the calling\\n/// contract. Opaque to the interpreter but presumably meaningful to the\\n/// expression.\\n/// @param compiledSources A list of sources that can be directly evaluated by\\n/// the interpreter, either as a top level entrypoint or nested e.g. under a\\n/// dispatch by `call`.\\nstruct InterpreterState {\\n    StackPointer stackBottom;\\n    StackPointer constantsBottom;\\n    MemoryKV stateKV;\\n    FullyQualifiedNamespace namespace;\\n    IInterpreterStoreV1 store;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\n/// @dev squiggly lines to make the debug output easier to read. Intentionlly\\n/// short to keep compiled code size down.\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\n/// @title LibInterpreterState\\n/// @notice Main workhorse for `InterpeterState` including:\\n///\\n/// - the standard `eval` loop\\n/// - source compilation from opcodes\\n/// - state (de)serialization (more gas efficient than abi encoding)\\n/// - low level debugging utility\\n///\\n/// Interpreters are designed to be highly moddable behind the `IInterpreterV1`\\n/// interface, but pretty much any interpreter that uses `InterpreterState` will\\n/// need these low level facilities verbatim. Further, these facilities\\n/// (with possible exception of debugging logic), while relatively short in terms\\n/// of lines of code, are surprisingly fragile to maintain in a gas efficient way\\n/// so we don't recommend reinventing this wheel.\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for bytes;\\n\\n    function serializeSize(\\n        bytes[] memory sources_,\\n        uint256[] memory constants_,\\n        uint256 stackLength_\\n    ) internal pure returns (uint256) {\\n        uint256 size_ = 0;\\n        size_ += stackLength_.size();\\n        size_ += constants_.size();\\n        for (uint256 i_ = 0; i_ < sources_.length; i_++) {\\n            size_ += sources_[i_].size();\\n        }\\n        return size_;\\n    }\\n\\n    /// Efficiently serializes some `IInterpreterV1` state config into bytes that\\n    /// can be deserialized to an `InterpreterState` without memory allocation or\\n    /// copying of data on the return trip. This is achieved by mutating data in\\n    /// place for both serialization and deserialization so it is much more gas\\n    /// efficient than abi encode/decode but is NOT SAFE to use the\\n    /// `ExpressionConfig` after it has been serialized. Notably the index based\\n    /// opcodes in the sources in `ExpressionConfig` will be replaced by function\\n    /// pointer based opcodes in place, so are no longer usable in a portable\\n    /// format.\\n    /// @param sources_ As per `IExpressionDeployerV1`.\\n    /// @param constants_ As per `IExpressionDeployerV1`.\\n    /// @param stackLength_ Stack length calculated by `IExpressionDeployerV1`\\n    /// that will be used to allocate memory for the stack upon deserialization.\\n    /// @param opcodeFunctionPointers_ As per `IInterpreterV1.functionPointers`,\\n    /// bytes to be compiled into the final `InterpreterState.compiledSources`.\\n    function serialize(\\n        Pointer memPointer_,\\n        bytes[] memory sources_,\\n        uint256[] memory constants_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure {\\n        unchecked {\\n            StackPointer pointer_ = StackPointer.wrap(\\n                Pointer.unwrap(memPointer_)\\n            );\\n            // Copy stack length.\\n            pointer_ = pointer_.push(stackLength_);\\n\\n            // Then the constants.\\n            pointer_ = pointer_.pushWithLength(constants_);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < sources_.length; i_++) {\\n                source_ = sources_[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                pointer_ = pointer_.unalignedPushWithLength(source_);\\n            }\\n        }\\n    }\\n\\n    /// Return trip from `serialize` but targets an `InterpreterState` NOT a\\n    /// `ExpressionConfig`. Allows serialized bytes to be written directly into\\n    /// contract code on the other side of an expression address, then loaded\\n    /// directly into an eval-able memory layout. The only allocation required\\n    /// is to initialise the stack for eval, there is no copying in memory from\\n    /// the serialized data as the deserialization merely calculates Solidity\\n    /// compatible pointers to positions in the raw serialized data. This is much\\n    /// more gas efficient than an equivalent abi.decode call which would involve\\n    /// more processing, copying and allocating.\\n    ///\\n    /// Note that per-eval data such as namespace and context is NOT initialised\\n    /// by the deserialization process and so will need to be handled by the\\n    /// interpreter as part of `eval`.\\n    ///\\n    /// @param serialized_ Bytes previously serialized by\\n    /// `LibInterpreterState.serialize`.\\n    /// @return An eval-able interpreter state with initialized stack.\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n            // The end of processing is the end of the state bytes.\\n            StackPointer end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackPointerUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackPointer lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (\\n                StackPointer.unwrap(lengthCursor_) < StackPointer.unwrap(end_)\\n            ) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackPointer.unwrap(cursor_) < StackPointer.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order. As the\\n    /// expression deployer is typically handling compilation during\\n    /// serialization, NOT the interpreter, the interpreter MUST guard against\\n    /// the compilation being garbage or outright hostile during `eval` by\\n    /// pointing to arbitrary internal functions of the interpreter.\\n    /// @param source_ The input source as index based opcodes.\\n    /// @param pointers_ The function pointers ordered by index to replace the\\n    /// index based opcodes with.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// The main eval loop. Does as little as possible as it is an extremely hot\\n    /// performance and critical security path. Loads opcode/operand pairs from\\n    /// a precompiled source in the interpreter state and calls the function\\n    /// that the opcode points to. This function is in turn responsible for\\n    /// actually pushing/popping from the stack, etc. As `eval` receives the\\n    /// source index and stack top alongside its state, it supports recursive\\n    /// calls via. opcodes that can manage scoped substacks, etc. without `eval`\\n    /// needing to house that complexity itself.\\n    /// @param state_ The interpreter state to evaluate a source over.\\n    /// @param sourceIndex_ The index of the source to evaluate. MAY be an\\n    /// entrypoint or a nested call.\\n    /// @param stackTop_ The current stack top, MUST be equal to the stack bottom\\n    /// on the intepreter state if the current eval is for an entrypoint.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        // MUST point to compiled sources. Needs updating if the\\n                        // `IntepreterState` struct changes fields.\\n                        mload(add(state_, 0xC0)),\\n                        add(\\n                            0x20,\\n                            mul(\\n                                0x20,\\n                                // SourceIndex is a uint16 so needs cleaning.\\n                                and(sourceIndex_, 0xFFFF)\\n                            )\\n                        )\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackPointer)\\n                    internal\\n                    view\\n                    returns (StackPointer) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Standard way to elevate a caller-provided state namespace to a universal\\n    /// namespace that is disjoint from all other caller-provided namespaces.\\n    /// Essentially just hashes the `msg.sender` into the state namespace as-is.\\n    ///\\n    /// This is deterministic such that the same combination of state namespace\\n    /// and caller will produce the same fully qualified namespace, even across\\n    /// multiple transactions/blocks.\\n    ///\\n    /// @param stateNamespace_ The state namespace as specified by the caller.\\n    /// @return A fully qualified namespace that cannot collide with any other\\n    /// state namespace specified by any other caller.\\n    function qualifyNamespace(\\n        StateNamespace stateNamespace_\\n    ) internal view returns (FullyQualifiedNamespace) {\\n        return\\n            FullyQualifiedNamespace.wrap(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            StateNamespace.unwrap(stateNamespace_)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interpreter/run/LibStackPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"rain.interface.interpreter/IInterpreterV1.sol\\\";\\nimport \\\"sol.lib.memory/LibUint256Array.sol\\\";\\nimport \\\"sol.lib.memory/LibMemory.sol\\\";\\nimport \\\"sol.lib.memory/LibMemCpy.sol\\\";\\n\\n/// Thrown when the length of an array as the result of an applied function does\\n/// not match expectations.\\nerror UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackPointer is uint256;\\n\\n/// @title LibStackPointer\\n/// @notice A `StackPointer` is just a pointer to some memory. Ostensibly it is\\n/// pointing at a stack item in memory used by the `RainInterpreter` so that\\n/// means it can move \\\"up\\\" and \\\"down\\\" (increment and decrement) by `uint256`\\n/// (32 bytes) increments. Structurally a stack is a `uint256[]` but we can save\\n/// a lot of gas vs. default Solidity handling of array indexes by using assembly\\n/// to bypass runtime bounds checks on every read and write. Of course, this\\n/// means we have to introduce some mechanism that gives us equivalent guarantees\\n/// and we do, in the form of the `IExpressionDeployerV1` integrity check.\\n///\\n/// The pointer to the bottom of a stack points at the 0th item, NOT the length\\n/// of the implied `uint256[]` and the top of a stack points AFTER the last item.\\n/// e.g. consider a `uint256[]` in memory with values `3 A B C` and assume this\\n/// starts at position `0` in memory, i.e. `0` points to value `3` for the\\n/// array length. In this case the stack bottom would be\\n/// `StackPointer.wrap(0x20)` (32 bytes above 0, past the length) and the stack\\n/// top would be `StackPointer.wrap(0x80)` (96 bytes above the stack bottom).\\n///\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much overloaded/duplicated\\n/// logic is that the Solidity compiler seems to fail at inlining equivalent\\n/// logic quite a lot. Perhaps once the IR compilation of Solidity is better\\n/// supported by tooling etc. we could remove a lot of this duplication as the\\n/// compiler itself would handle the optimisations.\\nlibrary LibStackPointer {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibMemory for uint256;\\n\\n    /// Reads the value above the stack pointer. If the stack pointer is the\\n    /// current stack top this is an out of bounds read! The caller MUST ensure\\n    /// that this is not the case and that the stack pointer being read is within\\n    /// the stack and not after it.\\n    /// @param stackPointer_ Position to read past/above.\\n    function peekUp(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackPointer_)\\n        }\\n        return a_;\\n    }\\n\\n    /// Read the value immediately below the given stack pointer. Equivalent to\\n    /// calling `pop` and discarding the `stackPointerAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackPointer stackPointer_) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return a_;\\n    }\\n\\n    /// Reads 2 values below the given stack pointer.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint256 a_, uint256 b_) = stackPointer_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint256 b_;\\n    /// (stackPointer_, b_) = stackPointer_.pop();\\n    /// uint256 a_ = stackPointer_.peek();\\n    /// ```\\n    /// @param stackPointer_ The stack top to peek below.\\n    function peek2(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 a_;\\n        uint256 b_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x40))\\n            b_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return (a_, b_);\\n    }\\n\\n    /// Read the value immediately below the given stack pointer and return the\\n    /// stack pointer that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint256 a_;\\n    /// (stackPointer_, a_) = stackPointer_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.down();\\n    /// uint256 a_ = stackPointer_.peekUp();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return stackPointerAfter_ Points to the value that was read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer, uint256) {\\n        StackPointer stackPointerAfter_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointerAfter_ := sub(stackPointer_, 0x20)\\n            a_ := mload(stackPointerAfter_)\\n        }\\n        return (stackPointerAfter_, a_);\\n    }\\n\\n    /// Given two stack pointers that bound a stack build an array of all values\\n    /// above the given sentinel value. The sentinel will be _replaced_ by the\\n    /// length of the array, allowing for efficient construction of a valid\\n    /// `uint256[]` without additional allocation or copying in memory. As the\\n    /// returned value is a `uint256[]` it can be treated as a substack and the\\n    /// same (or different) sentinel can be consumed many times to build many\\n    /// arrays from the main stack.\\n    ///\\n    /// As the sentinel is mutated in place into a length it is NOT safe to call\\n    /// this in a context where the stack is expected to be immutable.\\n    ///\\n    /// The sentinel MUST be chosen to have a negligible chance of colliding with\\n    /// a real value in the array, otherwise an intended array item will be\\n    /// interpreted as a sentinel and the array will be split into two slices.\\n    ///\\n    /// If the sentinel is absent in the stack this WILL REVERT. The intent is\\n    /// to represent dynamic length arrays without forcing expression authors to\\n    /// calculate lengths on the stack. If the expression author wants to model\\n    /// an empty/optional/absent value they MAY provided a sentinel for a zero\\n    /// length array and the calling contract SHOULD handle this.\\n    ///\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param sentinel_ The value to expect as the sentinel. MUST be present in\\n    /// the stack or `consumeSentinel` will revert. MUST NOT collide with valid\\n    /// stack items (or be cryptographically improbable to do so).\\n    /// @param stepSize_ Number of items to move over in the array per loop\\n    /// iteration. If the array has a known multiple of items it can be more\\n    /// efficient to find a sentinel moving in N-item increments rather than\\n    /// reading every item individually.\\n    function consumeSentinel(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    /// Abstraction over `consumeSentinel` to build an array of solidity structs.\\n    /// Solidity won't exactly allow this due to its type system not supporting\\n    /// generics, so instead we return an array of references to struct data that\\n    /// can be assigned/cast to an array of structs easily with assembly. This\\n    /// is NOT intended to be a general purpose workhorse for this task, only\\n    /// structs of pointers to `uint256[]` values are supported.\\n    ///\\n    /// ```\\n    /// struct Foo {\\n    ///   uint256[] a;\\n    ///   uint256[] b;\\n    /// }\\n    ///\\n    /// (StackPointer stackPointer_, uint256[] memory refs_) = consumeStructs(...);\\n    /// Foo[] memory foo_;\\n    /// assembly (\\\"memory-safe\\\") {\\n    ///   mstore(foo_, refs_)\\n    /// }\\n    /// ```\\n    ///\\n    /// @param stackTop_ The top of the stack as per `consumeSentinel`.\\n    /// @param stackBottom_ The bottom of the stack as per `consumeSentinel`.\\n    /// @param sentinel_ The sentinel as per `consumeSentinel`.\\n    /// @param structSize_ The number of `uint256[]` fields on the struct.\\n    function consumeStructs(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        (StackPointer stackTopAfter_, uint256[] memory tempArray_) = stackTop_\\n            .consumeSentinel(stackBottom_, sentinel_, structSize_);\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(mload(refs_), 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTopAfter_, refs_);\\n    }\\n\\n    /// Write a value at the stack pointer. Typically only useful as intermediate\\n    /// logic within some opcode etc. as the value will be treated as an out of\\n    /// bounds for future reads unless the stack top after the opcode logic is\\n    /// above the pointer.\\n    /// @param stackPointer_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackPointer stackPointer_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_.set(a_);\\n    /// stackPointer_ = stackPointer_.up();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack pointer above where `a_` was written to.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            stackPointer_ := add(stackPointer_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackPointer_ = stackPointer_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack pointer above the array.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        LibMemCpy.unsafeCopyWordsTo(\\n            array_.dataPointer(),\\n            Pointer.wrap(StackPointer.unwrap(stackPointer_)),\\n            array_.length\\n        );\\n        return stackPointer_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack pointer above the array.\\n    function pushWithLength(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack pointer above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        LibMemCpy.unsafeCopyBytesTo(\\n            Pointer.wrap(StackPointer.unwrap(bytes_.asStackPointer().up())),\\n            Pointer.wrap(StackPointer.unwrap(stackPointer_)),\\n            bytes_.length\\n        );\\n        return stackPointer_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack top above the\\n    /// written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack pointer.\\n    /// @return The stack pointer above the written bytes.\\n    function unalignedPushWithLength(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack pointer above where `h_` was written.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            mstore(add(stackPointer_, 0x20), b_)\\n            mstore(add(stackPointer_, 0x40), c_)\\n            mstore(add(stackPointer_, 0x60), d_)\\n            mstore(add(stackPointer_, 0x80), e_)\\n            mstore(add(stackPointer_, 0xA0), f_)\\n            mstore(add(stackPointer_, 0xC0), g_)\\n            mstore(add(stackPointer_, 0xE0), h_)\\n            stackPointer_ := add(stackPointer_, 0x100)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            StackPointer stackTopAfter_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n            return stackTopAfter_;\\n        }\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        StackPointer stackTopAfter_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackPointer().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        StackPointer stackTopAfter_ = tail_.asStackPointer();\\n        (StackPointer location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackPointer stackTopAfter_, uint256 b_) = tail_\\n            .asStackPointer()\\n            .pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        StackPointer csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = new uint256[](length_);\\n        LibMemCpy.unsafeCopyWordsTo(\\n            Pointer.wrap(StackPointer.unwrap(csStart_)),\\n            cs_.dataPointer(),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        if (results_.length != length_) {\\n            revert UnexpectedResultLength(length_, results_.length);\\n        }\\n\\n        StackPointer bottom_ = bs_.asStackPointer();\\n        LibMemCpy.unsafeCopyWordsTo(\\n            results_.dataPointer(),\\n            Pointer.wrap(StackPointer.unwrap(bottom_)),\\n            length_\\n        );\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackPointer_ The stack pointer to read the values below into an\\n    /// array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackPointer stackPointer_,\\n        uint256 length_\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        uint256 head_;\\n        uint256[] memory tail_;\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackPointer_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n        return (head_, tail_);\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer. The stack pointer will\\n    /// point to the length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the length of the\\n    /// array.\\n    function asStackPointer(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := array_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a stack pointer to an array. The value immediately above the stack\\n    /// pointer will be treated as the length of the array, so the proceeding\\n    /// length values will be the items of the array. The caller MUST ensure the\\n    /// values above the stack position constitute a valid array. The returned\\n    /// array will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned array after the stack writes over it.\\n    /// @param stackPointer_ The stack pointer that will be cast to an array.\\n    /// @return array_ The array above the stack pointer.\\n    function asUint256Array(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackPointer_\\n        }\\n        return array_;\\n    }\\n\\n    /// Cast a stack position to bytes. The value immediately above the stack\\n    /// position will be treated as the length of the `bytes`, so the proceeding\\n    /// length bytes will be the data of the `bytes`. The caller MUST ensure the\\n    /// length and bytes above the stack top constitute valid `bytes` data. The\\n    /// returned `bytes` will be corrupt if/when the stack subsequently moves\\n    /// into it and writes to those memory locations. The caller MUST ensure\\n    // that it does NOT read from the returned bytes after the stack writes over\\n    /// it.\\n    /// @param stackPointer_ The stack pointer that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackPointer stackPointer_\\n    ) internal pure returns (bytes memory) {\\n        bytes memory bytes_;\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackPointer_\\n        }\\n        return bytes_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its length. The stack\\n    /// pointer will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the first item of\\n    /// the array.\\n    function asStackPointerUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its items. The stack\\n    /// pointer will point after the last item of the array. It is out of bounds\\n    /// to read above the returned pointer. This can be interpreted as the stack\\n    /// top assuming the entire given array is a valid stack.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points after the last item\\n    /// of the array.\\n    function asStackPointerAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast `bytes` to a stack pointer. The stack pointer will point to the\\n    /// length of the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack pointer.\\n    /// @return stackPointer_ The stack top that points to the length of the\\n    /// bytes.\\n    function asStackPointer(\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := bytes_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Returns the stack pointer 32 bytes above/past the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes above the input stack pointer.\\n    function up(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes above/past the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack pointer `n_ * 32` bytes above/past the input stack\\n    /// pointer.\\n    function up(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) + 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_` bytes above/past the given stack pointer.\\n    /// The returned stack pointer MAY NOT be aligned with the given stack\\n    /// pointer for subsequent 32 byte reads and writes. The caller MUST ensure\\n    /// that it is safe to read and write data relative to the returned stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack pointer `n_` bytes above/past the given stack pointer.\\n    function upBytes(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack pointer 32 bytes below/before the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes below/before the given stack pointer.\\n    function down(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    function down(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) - 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Convert two stack pointer values to a single stack index. A stack index\\n    /// is the distance in 32 byte increments between two stack pointers. The\\n    /// calculations assumes the two stack pointers are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the top and bottom.\\n    function toIndex(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackPointer.unwrap(stackTop_) -\\n                    StackPointer.unwrap(stackBottom_)) / 0x20;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interpreter/shared/RainterpreterStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"rain.interface.interpreter/IInterpreterStoreV1.sol\\\";\\nimport \\\"../run/LibInterpreterState.sol\\\";\\nimport {IERC165Upgradeable as IERC165} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/// @title RainterpreterStore\\n/// @notice Simplest possible `IInterpreterStoreV1` that could work.\\n/// Takes key/value pairings from the input array and stores each in an internal\\n/// mapping. `StateNamespace` is fully qualified only by `msg.sender` on set and\\n/// doesn't attempt to do any deduping etc. if the same key appears twice it will\\n/// be set twice.\\ncontract RainterpreterStore is IInterpreterStoreV1, IERC165 {\\n    using LibInterpreterState for StateNamespace;\\n\\n    /// Store is several tiers of sandbox.\\n    ///\\n    /// 0. Address hashed into `FullyQualifiedNamespace` is `msg.sender` so that\\n    ///    callers cannot attack each other\\n    /// 1. StateNamespace is caller-provided namespace so that expressions cannot\\n    ///    attack each other\\n    /// 2. `uint256` is expression-provided key\\n    /// 3. `uint256` is expression-provided value\\n    ///\\n    /// tiers 0 and 1 are both embodied in the `FullyQualifiedNamespace`.\\n    mapping(FullyQualifiedNamespace => mapping(uint256 => uint256))\\n        internal store;\\n\\n    // @inheritdoc IERC165\\n    function supportsInterface(\\n        bytes4 interfaceId_\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId_ == type(IInterpreterStoreV1).interfaceId ||\\n            interfaceId_ == type(IERC165).interfaceId;\\n    }\\n\\n    /// @inheritdoc IInterpreterStoreV1\\n    function set(StateNamespace namespace_, uint256[] calldata kvs_) external {\\n        unchecked {\\n            FullyQualifiedNamespace fullyQualifiedNamespace_ = namespace_\\n                .qualifyNamespace();\\n            for (uint256 i_ = 0; i_ < kvs_.length; i_ += 2) {\\n                store[fullyQualifiedNamespace_][kvs_[i_]] = kvs_[i_ + 1];\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IInterpreterStoreV1\\n    function get(\\n        FullyQualifiedNamespace namespace_,\\n        uint256 key_\\n    ) external view returns (uint256) {\\n        return store[namespace_][key_];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/kv/LibMemoryKV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"sol.lib.binmaskflag/Binary.sol\\\";\\n\\n/// Thrown when attempting to read a value from the other side of a zero pointer.\\nerror InvalidPtr(MemoryKVPtr ptr);\\n\\n/// Entrypoint into the key/value store. Is a mutable pointer to the head of the\\n/// linked list. Initially points to `0` for an empty list. The total length of\\n/// the linked list is also encoded alongside the pointer to allow efficient O(1)\\n/// memory allocation for a `uint256[]` in the case of a final snapshot/export.\\ntype MemoryKV is uint256;\\n/// The key associated with the value for each item in the linked list.\\ntype MemoryKVKey is uint256;\\n/// The pointer to the next item in the list. `0` signifies the end of the list.\\ntype MemoryKVPtr is uint256;\\n/// The value associated with the key for each item in the linked list.\\ntype MemoryKVVal is uint256;\\n\\n/// @title LibMemoryKV\\n/// @notice Implements an in-memory key/value store in terms of a linked list\\n/// that can be snapshotted/exported to a `uint256[]` of pairwise keys/values as\\n/// its items. Ostensibly supports reading/writing to storage within a read only\\n/// context in an interpreter `eval` by tracking changes requested by an\\n/// expression in memory as a cache-like structure over the underlying storage.\\n///\\n/// A linked list is required because unlike stack movements we do NOT have any\\n/// way to precalculate how many items will be included in the final set at\\n/// deploy time. Any two writes may share the same key known only at runtime, so\\n/// any two writes may result in either 2 or 1 insertions (and 0 or 1 updates).\\n/// We could attempt to solve this by allowing duplicate keys and simply append\\n/// values for each write, so two writes will always insert 2 values, but then\\n/// looping constructs such as `OpDoWhile` and `OpFoldContext` with net 0 stack\\n/// movements (i.e. predictably deallocateable memory) can still cause\\n/// unbounded/unknown inserts for our state changes. The linked list allows us\\n/// to both dedupe same-key writes and also safely handle an unknown\\n/// (at deploy time) number of upserts. New items are inserted at the head of\\n/// the list and a pointer to `0` is the sentinel that defines the end of the\\n/// list. It is an error to dereference the `0` pointer.\\n///\\n/// Currently implemented as O(n) where n is likely relatively small, in future\\n/// could be reimplemented as 8 linked lists over a single `MemoryKV` by packing\\n/// many `MemoryKVPtr` and using `%` to distribute keys between lists. The\\n/// extremely high gas cost of writing to storage itself should be a natural\\n/// disincentive for n getting large enough to cause the linked list traversal\\n/// to be a significant gas cost itself.\\n///\\n/// Currently implemented in terms of raw `uint256` custom types that represent\\n/// keys, values and pointers. Could be reimplemented in terms of an equivalent\\n/// struct with key, value and pointer fields.\\nlibrary LibMemoryKV {\\n    /// Reads the `MemoryKVVal` that some `MemoryKVPtr` is pointing to. It is an\\n    /// error to call this if `ptr_` is `0`.\\n    /// @param ptr_ The pointer to read the value\\n    function readPtrVal(\\n        MemoryKVPtr ptr_\\n    ) internal pure returns (MemoryKVVal v_) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        if (MemoryKVPtr.unwrap(ptr_) == 0) {\\n            revert InvalidPtr(ptr_);\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n    }\\n\\n    /// Finds the pointer to the item that holds the value associated with the\\n    /// given key. Walks the linked list from the entrypoint into the key/value\\n    /// store until it finds the specified key. As the last pointer in the list\\n    /// is always `0`, `0` is what will be returned if the key is not found. Any\\n    /// non-zero pointer implies the value it points to is for the provided key.\\n    /// @param kv_ The entrypoint to the key/value store.\\n    /// @param k_ The key to lookup a pointer for.\\n    /// @return ptr_ The _pointer_ to the value for the key, if it exists, else\\n    /// a pointer to `0`. If the pointer is non-zero the associated value can be\\n    /// read to a `MemoryKVVal` with `LibMemoryKV.readPtrVal`.\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr ptr_) {\\n        uint256 mask_ = MASK_16BIT;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Upserts a value in the set by its key. I.e. if the key exists then the\\n    /// associated value will be mutated in place, else a new key/value pair will\\n    /// be inserted. The key/value store pointer will be mutated and returned as\\n    /// it MAY point to a new list item in memory.\\n    /// @param kv_ The key/value store pointer to modify.\\n    /// @param k_ The key to upsert against.\\n    /// @param v_ The value to associate with the upserted key.\\n    /// @return The final value of `kv_` as it MAY be modified if the upsert\\n    /// resulted in an insert operation.\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint256 mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    /// Export/snapshot the underlying linked list of the key/value store into\\n    /// a standard `uint256[]`. Reads the total length to preallocate the\\n    /// `uint256[]` then walks the entire linked list, copying every key and\\n    /// value into the array, until it reaches a pointer to `0`. Note this is a\\n    /// one time export, if the key/value store is subsequently mutated the built\\n    /// array will not reflect these mutations.\\n    /// @param kv_ The entrypoint into the key/value store.\\n    /// @return All the keys and values copied pairwise into a `uint256[]`.\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            uint256 ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint256 length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint256[] memory arr_ = new uint256[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/memory/LibMemorySize.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IExpressionDeployerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interface.interpreter/src/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"lib/rain.lib.typecast/src/LibConvert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    ///\\n    /// It is unsafe for the caller to use `us_` after it has been converted to\\n    /// bytes because there is now two pointers to the same mutable data\\n    /// structure AND the length prefix for the `uint256[]` version is corrupt.\\n    ///\\n    /// @param us_ The integer array to convert to `bytes`.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function unsafeToBytes(uint256[] memory us_) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := us_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    /// Truncate `uint256[]` values down to `uint16[]` then pack this to `bytes`\\n    /// without padding or length prefix. Unsafe because the starting `uint256`\\n    /// values are not checked for overflow due to the truncation. The caller\\n    /// MUST ensure that all values fit in `type(uint16).max` or that silent\\n    /// overflow is safe.\\n    /// @param us_ The `uint256[]` to truncate and concatenate to 16 bit `bytes`.\\n    /// @return The concatenated 2-byte chunks.\\n    function unsafeTo16BitBytes(uint256[] memory us_) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(us_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(us_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(us_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(bytesCursor_, or(and(preserveMask_, data_), and(replaceMask_, mload(cursor_))))\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.binmaskflag/src/Binary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev Binary 1.\\nuint256 constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint256 constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint256 constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint256 constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint256 constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint256 constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint256 constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint256 constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint256 constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint256 constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint256 constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint256 constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint256 constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint256 constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint256 constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint256 constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint256 constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint256 constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint256 constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint256 constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint256 constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint256 constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint256 constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint256 constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint256 constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint256 constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint256 constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint256 constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint256 constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint256 constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint256 constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint256 constant MASK_16BIT = B_1111111111111111;\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibMemCpy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\nlibrary LibMemCpy {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param source The starting pointer to read from.\\n    /// @param target The starting pointer to write to.\\n    /// @param length The number of bytes to read/write.\\n    function unsafeCopyBytesTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {} iszero(lt(length, 0x20)) {\\n                length := sub(length, 0x20)\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n\\n            if iszero(iszero(length)) {\\n                //slither-disable-next-line incorrect-shift\\n                let mask_ := shr(mul(length, 8), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                // preserve existing bytes\\n                mstore(\\n                    target,\\n                    or(\\n                        // input\\n                        and(mload(source), not(mask_)),\\n                        and(mload(target), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /// Copies `length` `uint256` values starting from `source` to `target`\\n    /// with NO attempt to check that this is safe to do so. The caller MUST\\n    /// ensure that there exists allocated memory at `target` in which it is\\n    /// safe and appropriate to copy `length * 32` bytes to. Anything that was\\n    /// already written to memory at `[target:target+(length * 32 bytes)]`\\n    /// will be overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param source The starting position in memory that data will be copied\\n    /// from.\\n    /// @param target The starting position in memory that data will be copied\\n    /// to.\\n    /// @param length The number of 32 byte (i.e. `uint256`) words that will\\n    /// be copied.\\n    function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for { let end_ := add(source, mul(0x20, length)) } lt(source, end_) {\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibMemory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nlibrary LibMemory {\\n    /// Returns true if the free memory pointer is pointing at a multiple of 32\\n    /// bytes, false otherwise. If all memory allocations are handled by Solidity\\n    /// then this will always be true, but assembly blocks can violate this, so\\n    /// this is a useful tool to test compliance of a custom assembly block with\\n    /// the solidity allocator.\\n    /// @return isAligned true if the memory is currently aligned to 32 bytes.\\n    function memoryIsAligned() internal pure returns (bool isAligned) {\\n        assembly (\\\"memory-safe\\\") {\\n            isAligned := iszero(mod(mload(0x40), 0x20))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// A pointer to a location in memory. This is a `uint256` to save gas on low\\n/// level operations on the evm stack. These same low level operations typically\\n/// WILL NOT check for overflow or underflow, so all pointer logic MUST ensure\\n/// that reads, writes and movements are not out of bounds.\\ntype Pointer is uint256;\\n\\n/// @title LibPointer\\n/// Ergonomic wrappers around common pointer movements, reading and writing. As\\n/// wrappers on such low level operations often introduce too much jump gas\\n/// overhead, these functions MAY find themselves used in reference\\n/// implementations that more optimised code can be fuzzed against. MAY also be\\n/// situationally useful on cooler performance paths.\\nlibrary LibPointer {\\n    /// Cast a `Pointer` to `bytes` without modification or any safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `bytes`.\\n    /// @param pointer The pointer to cast to `bytes`.\\n    /// @return data The cast `bytes`.\\n    function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data) {\\n        assembly (\\\"memory-safe\\\") {\\n            data := pointer\\n        }\\n    }\\n\\n    /// Increase some pointer by a number of bytes.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// Note that moving a pointer by some bytes offset is likely to unalign it\\n    /// with the 32 byte increments of the Solidity allocator.\\n    ///\\n    /// @param pointer The pointer to increase by `length`.\\n    /// @param length The number of bytes to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, length)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase by a single word.\\n    /// @return The increased pointer.\\n    function unsafeAddWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase.\\n    /// @param words The number of words to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease by a single word.\\n    /// @return The decreased pointer.\\n    function unsafeSubWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease.\\n    /// @param words The number of words to decrease the pointer by.\\n    /// @return The decreased pointer.\\n    function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Read the word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can read outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to read the word at.\\n    /// @return word The word read from the pointer.\\n    function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word) {\\n        assembly (\\\"memory-safe\\\") {\\n            word := mload(pointer)\\n        }\\n    }\\n\\n    /// Write a word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can write outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to write the word at.\\n    /// @param word The word to write.\\n    function unsafeWriteWord(Pointer pointer, uint256 word) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(pointer, word)\\n        }\\n    }\\n\\n    /// Get the pointer to the end of all allocated memory.\\n    /// As per Solidity docs, there is no guarantee that the region of memory\\n    /// beyond this pointer is zeroed out, as assembly MAY write beyond allocated\\n    /// memory for temporary use if the scratch space is insufficient.\\n    /// @return pointer The pointer to the end of all allocated memory.\\n    function allocatedMemoryPointer() internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := mload(0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/sol.lib.memory/src/LibUint256Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibMemCpy.sol\\\";\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Pointer to the start (length prefix) of a `uint256[]`.\\n    /// @param array The array to get the start pointer of.\\n    /// @return pointer The pointer to the start of `array`.\\n    function startPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := array\\n        }\\n    }\\n\\n    /// Pointer to the data of a `uint256[]` NOT the length prefix.\\n    /// @param array The array to get the data pointer of.\\n    /// @return pointer The pointer to the data of `array`.\\n    function dataPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, 0x20)\\n        }\\n    }\\n\\n    /// Pointer to the end of the allocated memory of an array.\\n    /// @param array The array to get the end pointer of.\\n    /// @return pointer The pointer to the end of `array`.\\n    function endPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, add(0x20, mul(0x20, mload(array))))\\n        }\\n    }\\n\\n    /// Cast a `Pointer` to `uint256[]` without modification or safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `uint256[]`.\\n    /// @param pointer The pointer to cast to `uint256[]`.\\n    /// @return array The cast `uint256[]`.\\n    function unsafeAsUint256Array(Pointer pointer) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := pointer\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a A single integer to build an array around.\\n    /// @return array The newly allocated array including `a` as a single item.\\n    function arrayFrom(uint256 a) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 1)\\n            mstore(add(array, 0x20), a)\\n            mstore(0x40, add(array, 0x40))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @return array The newly allocated array including `a` and `b` as the only\\n    /// items.\\n    function arrayFrom(uint256 a, uint256 b) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 2)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(0x40, add(array, 0x60))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b` and `c` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 3)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(0x40, add(array, 0x80))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c` and `d` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 4)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(0x40, add(array, 0xA0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d` and\\n    /// `e` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 5)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(0x40, add(array, 0xC0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @param f The sixth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d`, `e`\\n    /// and `f` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 6)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(add(array, 0xC0), f)\\n            mstore(0x40, add(array, 0xE0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The head of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 1)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x40)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first item of the new array.\\n    /// @param b The second item of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256 b, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 2)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n            mstore(add(outputCursor, 0x40), b)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x60)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array The array to truncate.\\n    /// @param newLength The new length of the array after truncation.\\n    function truncate(uint256[] memory array, uint256 newLength) internal pure {\\n        if (newLength > array.length) {\\n            revert OutOfBoundsTruncate(array.length, newLength);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating only an additional\\n    /// `extend_.length` words onto `base_` and copying only `extend_` if\\n    /// possible. If `base_` is large this MAY be significantly more efficient\\n    /// than allocating `base_.length + extend_.length` for an entirely new array\\n    /// and copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    ///\\n    /// The efficient version of extension is only possible if the free memory\\n    /// pointer sits at the end of the base array at the moment of extension. If\\n    /// there is allocated memory after the end of base then extension will\\n    /// require copying both the base and extend arays to a new region of memory.\\n    /// The caller is responsible for optimising code paths to avoid additional\\n    /// allocations.\\n    ///\\n    /// This function is UNSAFE because the base array IS MUTATED DIRECTLY by\\n    /// some code paths AND THE FINAL RETURN ARRAY MAY POINT TO THE SAME REGION\\n    /// OF MEMORY. It is NOT POSSIBLE to reliably see this behaviour from the\\n    /// caller in all cases as the Solidity compiler optimisations may switch the\\n    /// caller between the allocating and non-allocating logic due to subtle\\n    /// optimisation reasons. To use this function safely THE CALLER MUST NOT USE\\n    /// THE BASE ARRAY AND MUST USE THE RETURNED ARRAY ONLY. It is safe to use\\n    /// the extend array after calling this function as it is never mutated, it\\n    /// is only copied from.\\n    ///\\n    /// @param b The base integer array that will be extended by `e`.\\n    /// @param e The extend integer array that extends `b`.\\n    /// @return extended The extended array of `b` extended by `e`.\\n    function unsafeExtend(uint256[] memory b, uint256[] memory e) internal pure returns (uint256[] memory extended) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Slither doesn't recognise assembly function names as mixed case\\n            // even if they are.\\n            // https://github.com/crytic/slither/issues/1815\\n            //slither-disable-next-line naming-convention\\n            function extendInline(base, extend) -> baseAfter {\\n                let outputCursor := mload(0x40)\\n                let baseLength := mload(base)\\n                let baseEnd := add(base, add(0x20, mul(baseLength, 0x20)))\\n\\n                // If base is NOT the last thing in allocated memory, allocate,\\n                // copy and recurse.\\n                switch eq(outputCursor, baseEnd)\\n                case 0 {\\n                    let newBase := outputCursor\\n                    let newBaseEnd := add(newBase, sub(baseEnd, base))\\n                    mstore(0x40, newBaseEnd)\\n                    for { let inputCursor := base } lt(outputCursor, newBaseEnd) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := extendInline(newBase, extend)\\n                }\\n                case 1 {\\n                    let totalLength_ := add(baseLength, mload(extend))\\n                    let outputEnd_ := add(base, add(0x20, mul(totalLength_, 0x20)))\\n                    mstore(base, totalLength_)\\n                    mstore(0x40, outputEnd_)\\n                    for { let inputCursor := add(extend, 0x20) } lt(outputCursor, outputEnd_) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := base\\n                }\\n            }\\n\\n            extended := extendInline(b, e)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"rain.cooldown/=lib/rain.cooldown/src/\",\r\n      \"rain.interface.factory/=lib/rain.interface.factory/src/\",\r\n      \"rain.interface.flow/=lib/rain.interface.flow/src/\",\r\n      \"rain.interface.interpreter/=lib/rain.interface.interpreter/src/\",\r\n      \"rain.interface.orderbook/=lib/rain.interface.orderbook/src/\",\r\n      \"rain.interface.sale/=lib/rain.interface.sale/src/\",\r\n      \"rain.lib.hash/=lib/rain.interface.interpreter/lib/rain.lib.hash/src/\",\r\n      \"rain.lib.typecast/=lib/rain.lib.typecast/src/\",\r\n      \"rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\r\n      \"rain.math.saturating/=lib/rain.math.saturating/src/\",\r\n      \"sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\r\n      \"sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\r\n      \"sol.lib.memory/=lib/sol.lib.memory/src/\",\r\n      \"sol.metadata/=lib/sol.metadata/src/\"\r\n    ],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"FullyQualifiedNamespace\",\"name\":\"namespace_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"key_\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"StateNamespace\",\"name\":\"namespace_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"kvs_\",\"type\":\"uint256[]\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RainterpreterStore", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}