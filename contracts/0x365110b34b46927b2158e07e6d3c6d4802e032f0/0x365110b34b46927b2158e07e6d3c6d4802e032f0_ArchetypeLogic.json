{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ArchetypeLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ArchetypeLogic v0.6.0 - ERC1155-random\\n//\\n//        d8888                 888               888\\n//       d88888                 888               888\\n//      d88P888                 888               888\\n//     d88P 888 888d888 .d8888b 88888b.   .d88b.  888888 888  888 88888b.   .d88b.\\n//    d88P  888 888P\\\"  d88P\\\"    888 \\\"88b d8P  Y8b 888    888  888 888 \\\"88b d8P  Y8b\\n//   d88P   888 888    888      888  888 88888888 888    888  888 888  888 88888888\\n//  d8888888888 888    Y88b.    888  888 Y8b.     Y88b.  Y88b 888 888 d88P Y8b.\\n// d88P     888 888     \\\"Y8888P 888  888  \\\"Y8888   \\\"Y888  \\\"Y88888 88888P\\\"   \\\"Y8888\\n//                                                            888 888\\n//                                                       Y8b d88P 888\\n//                                                        \\\"Y88P\\\"  888\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"solady/src/utils/MerkleProofLib.sol\\\";\\nimport \\\"solady/src/utils/ECDSA.sol\\\";\\n\\nerror InvalidConfig();\\nerror MintNotYetStarted();\\nerror MintEnded();\\nerror WalletUnauthorizedToMint();\\nerror InsufficientEthSent();\\nerror ExcessiveEthSent();\\nerror Erc20BalanceTooLow();\\nerror MaxSupplyExceeded();\\nerror ListMaxSupplyExceeded();\\nerror TokenPoolEmpty();\\nerror NumberOfMintsExceeded();\\nerror MintingPaused();\\nerror InvalidReferral();\\nerror InvalidSignature();\\nerror BalanceEmpty();\\nerror TransferFailed();\\nerror MaxBatchSizeExceeded();\\nerror BurnToMintDisabled();\\nerror NotTokenOwner();\\nerror NotPlatform();\\nerror NotOwner();\\nerror NotVRF();\\nerror NotApprovedToTransfer();\\nerror InvalidAmountOfTokens();\\nerror WrongPassword();\\nerror LockedForever();\\nerror URIQueryForNonexistentToken();\\nerror InvalidTokenId();\\nerror MaxRetriesExceeded();\\nerror InvalidRequestId();\\n\\n//\\n// STRUCTS\\n//\\nstruct Auth {\\n  bytes32 key;\\n  bytes32[] proof;\\n}\\n\\nstruct MintTier {\\n  uint16 numMints;\\n  uint16 mintDiscount; //BPS\\n}\\n\\nstruct Discount {\\n  uint16 affiliateDiscount; //BPS\\n  MintTier[] mintTiers;\\n}\\n\\nstruct Config {\\n  string baseUri;\\n  address affiliateSigner;\\n  address ownerAltPayout; // optional alternative address for owner withdrawals.\\n  address superAffiliatePayout; // optional super affiliate address, will receive half of platform fee if set.\\n  uint32 maxSupply;\\n  uint16 maxBatchSize;\\n  uint16 affiliateFee; //BPS\\n  uint16 platformFee; //BPS\\n  uint16 defaultRoyalty; //BPS\\n  Discount discounts;\\n  uint16[] tokenPool; // flattened list of all mintable tokens\\n}\\n\\nstruct Options {\\n  bool uriLocked;\\n  bool maxSupplyLocked;\\n  bool tokenPoolLocked;\\n  bool affiliateFeeLocked;\\n  bool discountsLocked;\\n  bool ownerAltPayoutLocked;\\n  bool provenanceHashLocked;\\n  bool airdropLocked;\\n  bool useChainlinkVRF;\\n}\\n\\nstruct DutchInvite {\\n  uint128 price;\\n  uint128 reservePrice;\\n  uint128 delta;\\n  uint32 start;\\n  uint32 end;\\n  uint32 limit;\\n  uint32 maxSupply;\\n  uint32 interval;\\n  uint32 unitSize; // mint 1 get x\\n  address tokenAddress;\\n  uint16[] tokenIdsExcluded; // token ids excluded from this list\\n}\\n\\nstruct Invite {\\n  uint128 price;\\n  uint32 start;\\n  uint32 end;\\n  uint32 limit;\\n  uint32 maxSupply;\\n  uint32 unitSize; // mint 1 get x\\n  address tokenAddress;\\n  uint16[] tokenIdsExcluded; // token ids excluded from this list\\n}\\n\\nstruct OwnerBalance {\\n  uint128 owner;\\n  uint128 platform;\\n}\\n\\nstruct ValidationArgs {\\n  address owner;\\n  address affiliate;\\n  uint256 quantity;\\n  uint256 curSupply;\\n}\\n\\nstruct BurnConfig {\\n  address tokenAddress;\\n  address burnAddress;\\n}\\n\\nstruct VrfConfig {\\n  bool enabled;\\n  uint64 subId;\\n}\\n\\nstruct VrfMintInfo {\\n  bytes32 key;\\n  address to;\\n  uint256 quantity;\\n}\\n\\naddress constant PLATFORM = 0x86B82972282Dd22348374bC63fd21620F7ED847B;\\naddress constant BATCH = 0x6Bc558A6DC48dEfa0e7022713c23D65Ab26e4Fa7;\\nuint16 constant MAXBPS = 5000; // max fee or discount is 50%\\n\\naddress constant VRF_CORDINATOR = 0x271682DEB8C4E0901D1a1550aD2e64D568E69909;\\nbytes32 constant VRF_KEYHASH = 0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef;\\n\\nlibrary ArchetypeLogic {\\n  //\\n  // EVENTS\\n  //\\n  event Invited(bytes32 indexed key, bytes32 indexed cid);\\n  event Referral(address indexed affiliate, address token, uint128 wad, uint256 numMints);\\n  event Withdrawal(address indexed src, address token, uint128 wad);\\n\\n  // calculate price based on affiliate usage and mint discounts\\n  function computePrice(\\n    DutchInvite storage invite,\\n    Discount storage discounts,\\n    uint256 numTokens,\\n    bool affiliateUsed\\n  ) public view returns (uint256) {\\n    uint256 price = invite.price;\\n    if (invite.interval != 0) {\\n      uint256 diff = (((block.timestamp - invite.start) / invite.interval) * invite.delta);\\n      if (price > invite.reservePrice) {\\n        if (diff > price - invite.reservePrice) {\\n          price = invite.reservePrice;\\n        } else {\\n          price = price - diff;\\n        }\\n      } else if (price < invite.reservePrice) {\\n        if (diff > invite.reservePrice - price) {\\n          price = invite.reservePrice;\\n        } else {\\n          price = price + diff;\\n        }\\n      }\\n    }\\n\\n    uint256 cost = price * numTokens;\\n\\n    if (affiliateUsed) {\\n      cost = cost - ((cost * discounts.affiliateDiscount) / 10000);\\n    }\\n\\n    for (uint256 i = 0; i < discounts.mintTiers.length; i++) {\\n      if (numTokens >= discounts.mintTiers[i].numMints) {\\n        return cost = cost - ((cost * discounts.mintTiers[i].mintDiscount) / 10000);\\n      }\\n    }\\n    return cost;\\n  }\\n\\n  function validateMint(\\n    DutchInvite storage i,\\n    Config storage config,\\n    Auth calldata auth,\\n    mapping(address => mapping(bytes32 => uint256)) storage minted,\\n    mapping(bytes32 => uint256) storage listSupply,\\n    bytes calldata signature,\\n    ValidationArgs memory args\\n  ) public view {\\n    address msgSender = _msgSender();\\n    if (args.affiliate != address(0)) {\\n      if (\\n        args.affiliate == PLATFORM || args.affiliate == args.owner || args.affiliate == msgSender\\n      ) {\\n        revert InvalidReferral();\\n      }\\n      validateAffiliate(args.affiliate, signature, config.affiliateSigner);\\n    }\\n\\n    if (i.limit == 0) {\\n      revert MintingPaused();\\n    }\\n\\n    if (!verify(auth, i.tokenAddress, msgSender)) {\\n      revert WalletUnauthorizedToMint();\\n    }\\n\\n    if (block.timestamp < i.start) {\\n      revert MintNotYetStarted();\\n    }\\n\\n    if (i.end > i.start && block.timestamp > i.end) {\\n      revert MintEnded();\\n    }\\n\\n    {\\n      uint256 totalAfterMint;\\n      if (i.limit < i.maxSupply) {\\n        totalAfterMint = minted[msgSender][auth.key] + args.quantity;\\n\\n        if (totalAfterMint > i.limit) {\\n          revert NumberOfMintsExceeded();\\n        }\\n      }\\n\\n      if (i.maxSupply < config.maxSupply) {\\n        totalAfterMint = listSupply[auth.key] + args.quantity;\\n        if (totalAfterMint > i.maxSupply) {\\n          revert ListMaxSupplyExceeded();\\n        }\\n      }\\n    }\\n\\n    if (args.quantity > config.maxBatchSize) {\\n      revert MaxBatchSizeExceeded();\\n    }\\n\\n    if ((args.curSupply + args.quantity) > config.maxSupply) {\\n      revert MaxSupplyExceeded();\\n    }\\n\\n    if (args.quantity > config.tokenPool.length) {\\n      revert TokenPoolEmpty();\\n    }\\n\\n    uint256 cost = computePrice(i, config.discounts, args.quantity, args.affiliate != address(0));\\n\\n    if (i.tokenAddress != address(0)) {\\n      IERC20Upgradeable erc20Token = IERC20Upgradeable(i.tokenAddress);\\n      if (erc20Token.allowance(msgSender, address(this)) < cost) {\\n        revert NotApprovedToTransfer();\\n      }\\n\\n      if (erc20Token.balanceOf(msgSender) < cost) {\\n        revert Erc20BalanceTooLow();\\n      }\\n\\n      if (msg.value != 0) {\\n        revert ExcessiveEthSent();\\n      }\\n    } else {\\n      if (msg.value < cost) {\\n        revert InsufficientEthSent();\\n      }\\n\\n      if (msg.value > cost) {\\n        revert ExcessiveEthSent();\\n      }\\n    }\\n  }\\n\\n  function updateBalances(\\n    DutchInvite storage i,\\n    Config storage config,\\n    mapping(address => OwnerBalance) storage _ownerBalance,\\n    mapping(address => mapping(address => uint128)) storage _affiliateBalance,\\n    address affiliate,\\n    uint256 quantity\\n  ) public {\\n    address tokenAddress = i.tokenAddress;\\n    uint128 value = uint128(msg.value);\\n    if (tokenAddress != address(0)) {\\n      value = uint128(computePrice(i, config.discounts, quantity, affiliate != address(0)));\\n    }\\n\\n    uint128 affiliateWad = 0;\\n    if (affiliate != address(0)) {\\n      affiliateWad = (value * config.affiliateFee) / 10000;\\n      _affiliateBalance[affiliate][tokenAddress] += affiliateWad;\\n      emit Referral(affiliate, tokenAddress, affiliateWad, quantity);\\n    }\\n\\n    uint128 superAffiliateWad = 0;\\n    if (config.superAffiliatePayout != address(0)) {\\n      superAffiliateWad = ((value * config.platformFee) / 2) / 10000;\\n      _affiliateBalance[config.superAffiliatePayout][tokenAddress] += superAffiliateWad;\\n    }\\n\\n    OwnerBalance memory balance = _ownerBalance[tokenAddress];\\n    uint128 platformWad = ((value * config.platformFee) / 10000) - superAffiliateWad;\\n    uint128 ownerWad = value - affiliateWad - platformWad - superAffiliateWad;\\n    _ownerBalance[tokenAddress] = OwnerBalance({\\n      owner: balance.owner + ownerWad,\\n      platform: balance.platform + platformWad\\n    });\\n\\n    if (tokenAddress != address(0)) {\\n      IERC20Upgradeable erc20Token = IERC20Upgradeable(tokenAddress);\\n      erc20Token.transferFrom(_msgSender(), address(this), value);\\n    }\\n  }\\n\\n  function withdrawTokens(\\n    Config storage config,\\n    mapping(address => OwnerBalance) storage _ownerBalance,\\n    mapping(address => mapping(address => uint128)) storage _affiliateBalance,\\n    address owner,\\n    address[] calldata tokens\\n  ) public {\\n    address msgSender = _msgSender();\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address tokenAddress = tokens[i];\\n      uint128 wad = 0;\\n\\n      if (msgSender == owner || msgSender == config.ownerAltPayout || msgSender == PLATFORM) {\\n        OwnerBalance storage balance = _ownerBalance[tokenAddress];\\n        if (msgSender == owner || msgSender == config.ownerAltPayout) {\\n          wad = balance.owner;\\n          balance.owner = 0;\\n        } else {\\n          wad = balance.platform;\\n          balance.platform = 0;\\n        }\\n      } else {\\n        wad = _affiliateBalance[msgSender][tokenAddress];\\n        _affiliateBalance[msgSender][tokenAddress] = 0;\\n      }\\n\\n      if (wad == 0) {\\n        revert BalanceEmpty();\\n      }\\n\\n      if (tokenAddress == address(0)) {\\n        bool success = false;\\n        // send to ownerAltPayout if set and owner is withdrawing\\n        if (msgSender == owner && config.ownerAltPayout != address(0)) {\\n          (success, ) = payable(config.ownerAltPayout).call{ value: wad }(\\\"\\\");\\n        } else {\\n          (success, ) = msgSender.call{ value: wad }(\\\"\\\");\\n        }\\n        if (!success) {\\n          revert TransferFailed();\\n        }\\n      } else {\\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(tokenAddress);\\n\\n        if (msgSender == owner && config.ownerAltPayout != address(0)) {\\n          erc20Token.transfer(config.ownerAltPayout, wad);\\n        } else {\\n          erc20Token.transfer(msgSender, wad);\\n        }\\n      }\\n      emit Withdrawal(msgSender, tokenAddress, wad);\\n    }\\n  }\\n\\n  function validateAffiliate(\\n    address affiliate,\\n    bytes calldata signature,\\n    address affiliateSigner\\n  ) public view {\\n    bytes32 signedMessagehash = ECDSA.toEthSignedMessageHash(\\n      keccak256(abi.encodePacked(affiliate))\\n    );\\n    address signer = ECDSA.recover(signedMessagehash, signature);\\n\\n    if (signer != affiliateSigner) {\\n      revert InvalidSignature();\\n    }\\n  }\\n\\n  function verify(\\n    Auth calldata auth,\\n    address tokenAddress,\\n    address account\\n  ) public pure returns (bool) {\\n    // keys 0-255 and tokenAddress are public\\n    if (uint256(auth.key) <= 0xff || auth.key == keccak256(abi.encodePacked(tokenAddress))) {\\n      return true;\\n    }\\n\\n    return MerkleProofLib.verify(auth.proof, auth.key, keccak256(abi.encodePacked(account)));\\n  }\\n\\n  function getRandomTokenIds(\\n    uint16[] storage tokenPool,\\n    uint16[] memory tokenIdsExcluded,\\n    uint256 quantity,\\n    uint256 seed\\n  ) public returns (uint16[] memory) {\\n    uint16[] memory tokenIds = new uint16[](quantity);\\n\\n    uint256 retries = 0;\\n    uint256 MAX_RETRIES = 5;\\n\\n    uint256 i = 0;\\n    while (i < quantity) {\\n      if (tokenPool.length == 0) {\\n        revert MaxSupplyExceeded();\\n      }\\n\\n      uint256 rand = uint256(keccak256(abi.encode(seed, i)));\\n      uint256 randIdx = rand % tokenPool.length;\\n      uint16 selectedToken = tokenPool[randIdx];\\n\\n      if (tokenIdsExcluded.length > 0 && isExcluded(selectedToken, tokenIdsExcluded)) {\\n        // If the token is excluded, retry for this position in tokenIds array\\n        seed = rand; // Update the seed for the next iteration\\n\\n        retries++;\\n        if (retries >= MAX_RETRIES) {\\n          revert MaxRetriesExceeded();\\n        }\\n        continue;\\n      }\\n\\n      tokenIds[i] = selectedToken;\\n\\n      // remove token from pool\\n      tokenPool[randIdx] = tokenPool[tokenPool.length - 1];\\n      tokenPool.pop();\\n\\n      retries = 0;\\n      i++;\\n    }\\n\\n    return tokenIds;\\n  }\\n\\n  function isExcluded(uint16 tokenId, uint16[] memory excludedList) internal pure returns (bool) {\\n    for (uint256 i = 0; i < excludedList.length; i++) {\\n      if (tokenId == excludedList[i]) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function random() public view returns (uint256) {\\n    uint256 randomHash = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\\n    return randomHash;\\n  }\\n\\n  function _msgSender() internal view returns (address) {\\n    return msg.sender == BATCH ? tx.origin : msg.sender;\\n  }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\nlibrary ECDSA {\\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address result) {\\n        assembly {\\n            if eq(signature.length, 65) {\\n                // Copy the free memory pointer so that we can restore it later.\\n                let m := mload(0x40)\\n                // Directly copy `r` and `s` from the calldata.\\n                calldatacopy(0x40, signature.offset, 0x40)\\n\\n                // If `s` in lower half order, such that the signature is not malleable.\\n                // prettier-ignore\\n                if iszero(gt(mload(0x60), 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                    mstore(0x00, hash)\\n                    // Compute `v` and store it in the scratch space.\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\\n                    pop(\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            0x01, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x40, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    )\\n                    // Restore the zero slot.\\n                    mstore(0x60, 0)\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    result := mload(sub(0x60, returndatasize()))\\n                }\\n                // Restore the free memory pointer.\\n                mstore(0x40, m)\\n            }\\n        }\\n    }\\n\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (address result) {\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // prettier-ignore\\n            let s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            // prettier-ignore\\n            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27))\\n                mstore(0x40, r)\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(sub(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        assembly {\\n            // Store into scratch space for keccak256.\\n            mstore(0x20, hash)\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            // 0x40 - 0x04 = 0x3c\\n            result := keccak256(0x04, 0x3c)\\n        }\\n    }\\n\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We need at most 128 bytes for Ethereum signed message header.\\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\\n            // The length of \\\"\\\\x19Ethereum Signed Message:\\\\n\\\" is 26 bytes (i.e. 0x1a).\\n            // The next multiple of 32 above 78 + 26 is 128 (i.e. 0x80).\\n\\n            // Instead of allocating, we temporarily copy the 128 bytes before the\\n            // start of `s` data to some variables.\\n            let m3 := mload(sub(s, 0x60))\\n            let m2 := mload(sub(s, 0x40))\\n            let m1 := mload(sub(s, 0x20))\\n            // The length of `s` is in bytes.\\n            let sLength := mload(s)\\n\\n            let ptr := add(s, 0x20)\\n\\n            // `end` marks the end of the memory which we will compute the keccak256 of.\\n            let end := add(ptr, sLength)\\n\\n            // Convert the length of the bytes to ASCII decimal representation\\n            // and store it into the memory.\\n            // prettier-ignore\\n            for { let temp := sLength } 1 {} {\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Copy the header over to the memory.\\n            mstore(sub(ptr, 0x20), \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n\\\")\\n            // Compute the keccak256 of the memory.\\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\\n\\n            // Restore the previous memory.\\n            mstore(s, sLength)\\n            mstore(sub(s, 0x20), m1)\\n            mstore(sub(s, 0x40), m2)\\n            mstore(sub(s, 0x60), m3)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    function verify(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool isValid) {\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    function verifyMultiProof(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leafs,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leafs` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        assembly {\\n            // If the number of flags is correct.\\n            // prettier-ignore\\n            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                // Compute the end calldata offset of `leafs`.\\n                let leafsEnd := add(leafs.offset, shl(5, leafs.length))\\n                // These are the calldata offsets.\\n                let leafsOffset := leafs.offset\\n                let flagsOffset := flags.offset\\n                let proofOffset := proof.offset\\n\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                let hashesBack := hashesFront\\n                // This is the end of the memory for the queue.\\n                let end := add(hashesBack, shl(5, flags.length))\\n\\n                // For the case where `proof.length + leafs.length == 1`.\\n                if iszero(flags.length) {\\n                    // If `proof.length` is zero, `leafs.length` is 1.\\n                    if iszero(proof.length) {\\n                        isValid := eq(calldataload(leafsOffset), root)\\n                        break\\n                    }\\n                    // If `leafs.length` is zero, `proof.length` is 1.\\n                    if iszero(leafs.length) {\\n                        isValid := eq(calldataload(proofOffset), root)\\n                        break\\n                    }\\n                }\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let a := 0\\n                    // Pops a value from the queue into `a`.\\n                    switch lt(leafsOffset, leafsEnd)\\n                    case 0 {\\n                        // Pop from `hashes` if there are no more leafs.\\n                        a := mload(hashesFront)\\n                        hashesFront := add(hashesFront, 0x20)\\n                    }\\n                    default {\\n                        // Otherwise, pop from `leafs`.\\n                        a := calldataload(leafsOffset)\\n                        leafsOffset := add(leafsOffset, 0x20)\\n                    }\\n\\n                    let b := 0\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    switch calldataload(flagsOffset)\\n                    case 0 {\\n                        // Loads the next proof.\\n                        b := calldataload(proofOffset)\\n                        proofOffset := add(proofOffset, 0x20)\\n                    }\\n                    default {\\n                        // Pops a value from the queue into `a`.\\n                        switch lt(leafsOffset, leafsEnd)\\n                        case 0 {\\n                            // Pop from `hashes` if there are no more leafs.\\n                            b := mload(hashesFront)\\n                            hashesFront := add(hashesFront, 0x20)\\n                        }\\n                        default {\\n                            // Otherwise, pop from `leafs`.\\n                            b := calldataload(leafsOffset)\\n                            leafsOffset := add(leafsOffset, 0x20)\\n                        }\\n                    }\\n                    // Advance to the next flag offset.\\n                    flagsOffset := add(flagsOffset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(hashesBack, end)) { break }\\n                }\\n                // Checks if the last value in the queue is same as the root.\\n                isValid := eq(mload(sub(hashesBack, 0x20)), root)\\n                break\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BalanceEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Erc20BalanceTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExcessiveEthSent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEthSent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReferral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListMaxSupplyExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxBatchSizeExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxRetriesExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotYetStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedToTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NumberOfMintsExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenPoolEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WalletUnauthorizedToMint\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"}],\"name\":\"Invited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"wad\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numMints\",\"type\":\"uint256\"}],\"name\":\"Referral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"wad\",\"type\":\"uint128\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliateSigner\",\"type\":\"address\"}],\"name\":\"validateAffiliate\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Auth\",\"name\":\"auth\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ArchetypeLogic", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}