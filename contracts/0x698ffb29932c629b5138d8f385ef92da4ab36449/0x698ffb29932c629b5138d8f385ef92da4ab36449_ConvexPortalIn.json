{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/PortalBaseV1.sol\": {\r\n      \"content\": \"/// Copyright (C) 2022 Portals.fi\\n\\n/// @author Portals.fi\\n/// @notice Base contract inherited by Portal Factories\\n\\n/// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../libraries/solmate/utils/SafeTransferLib.sol\\\";\\nimport \\\"../interface/IWETH.sol\\\";\\nimport \\\"../interface/IPortalFactory.sol\\\";\\nimport \\\"../interface/IPortalRegistry.sol\\\";\\n\\nabstract contract PortalBaseV1 is Ownable {\\n    using SafeTransferLib for address;\\n    using SafeTransferLib for ERC20;\\n\\n    // Active status of this contract. If false, contract is active (i.e un-paused)\\n    bool public paused;\\n\\n    // Fee in basis points (bps)\\n    uint256 public fee;\\n\\n    // Address of the Portal Registry\\n    IPortalRegistry public registry;\\n\\n    // Address of the exchange used for swaps\\n    address public immutable exchange;\\n\\n    // Address of the wrapped network token (e.g. WETH, wMATIC, wFTM, wAVAX, etc.)\\n    address public immutable wrappedNetworkToken;\\n\\n    // Circuit breaker\\n    modifier pausable() {\\n        require(!paused, \\\"Paused\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        bytes32 protocolId,\\n        PortalType portalType,\\n        IPortalRegistry _registry,\\n        address _exchange,\\n        address _wrappedNetworkToken,\\n        uint256 _fee\\n    ) {\\n        wrappedNetworkToken = _wrappedNetworkToken;\\n        setFee(_fee);\\n        exchange = _exchange;\\n        registry = _registry;\\n        registry.addPortal(address(this), portalType, protocolId);\\n        transferOwnership(registry.owner());\\n    }\\n\\n    /// @notice Transfers tokens or the network token from the caller to this contract\\n    /// @param token The address of the token to transfer (address(0) if network token)\\n    /// @param quantity The quantity of tokens to transfer from the caller\\n    /// @dev quantity must == msg.value when token == address(0)\\n    /// @dev msg.value must == 0 when token != address(0)\\n    /// @return The quantity of tokens or network tokens transferred from the caller to this contract\\n    function _transferFromCaller(address token, uint256 quantity)\\n        internal\\n        virtual\\n        returns (uint256)\\n    {\\n        if (token == address(0)) {\\n            require(\\n                msg.value > 0 && msg.value == quantity,\\n                \\\"Invalid quantity or msg.value\\\"\\n            );\\n\\n            return msg.value;\\n        }\\n\\n        require(\\n            quantity > 0 && msg.value == 0,\\n            \\\"Invalid quantity or msg.value\\\"\\n        );\\n\\n        ERC20(token).safeTransferFrom(msg.sender, address(this), quantity);\\n\\n        return quantity;\\n    }\\n\\n    /// @notice Returns the quantity of tokens or network tokens after accounting for the fee\\n    /// @param quantity The quantity of tokens to subtract the fee from\\n    /// @param feeBps The fee in basis points (BPS)\\n    /// @return The quantity of tokens or network tokens to transact with less the fee\\n    function _getFeeAmount(uint256 quantity, uint256 feeBps)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return quantity - (quantity * feeBps) / 10000;\\n    }\\n\\n    /// @notice Executes swap or portal data at the target address\\n    /// @param sellToken The sell token\\n    /// @param sellAmount The quantity of sellToken (in sellToken base units) to send\\n    /// @param buyToken The buy token\\n    /// @param target The execution target for the data\\n    /// @param data The swap or portal data\\n    /// @return amountBought Quantity of buyToken acquired\\n    function _execute(\\n        address sellToken,\\n        uint256 sellAmount,\\n        address buyToken,\\n        address target,\\n        bytes memory data\\n    ) internal virtual returns (uint256 amountBought) {\\n        if (sellToken == buyToken) {\\n            return sellAmount;\\n        }\\n\\n        if (sellToken == address(0) && buyToken == wrappedNetworkToken) {\\n            IWETH(wrappedNetworkToken).deposit{ value: sellAmount }();\\n            return sellAmount;\\n        }\\n\\n        if (sellToken == wrappedNetworkToken && buyToken == address(0)) {\\n            IWETH(wrappedNetworkToken).withdraw(sellAmount);\\n            return sellAmount;\\n        }\\n\\n        uint256 valueToSend;\\n        if (sellToken == address(0)) {\\n            valueToSend = sellAmount;\\n        } else {\\n            _approve(sellToken, target, sellAmount);\\n        }\\n\\n        uint256 initialBalance = _getBalance(address(this), buyToken);\\n\\n        require(\\n            target == exchange || registry.isPortal(target),\\n            \\\"Unauthorized target\\\"\\n        );\\n        (bool success, bytes memory returnData) = target.call{\\n            value: valueToSend\\n        }(data);\\n        require(success, string(returnData));\\n\\n        amountBought = _getBalance(address(this), buyToken) - initialBalance;\\n\\n        require(amountBought > 0, \\\"Invalid execution\\\");\\n    }\\n\\n    /// @notice Get the token or network token balance of an account\\n    /// @param account The owner of the tokens or network tokens whose balance is being queried\\n    /// @param token The address of the token (address(0) if network token)\\n    /// @return The owner's token or network token balance\\n    function _getBalance(address account, address token)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        if (token == address(0)) {\\n            return account.balance;\\n        } else {\\n            return ERC20(token).balanceOf(account);\\n        }\\n    }\\n\\n    /// @notice Approve a token for spending with finite allowance\\n    /// @param token The ERC20 token to approve\\n    /// @param spender The spender of the token\\n    /// @param amount The allowance to grant to the spender\\n    function _approve(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        ERC20 _token = ERC20(token);\\n        _token.safeApprove(spender, 0);\\n        _token.safeApprove(spender, amount);\\n    }\\n\\n    /// @notice Collects tokens or network tokens from this contract\\n    /// @param tokens An array of the tokens to withdraw (address(0) if network token)\\n    function collect(address[] calldata tokens) external {\\n        address collector = registry.collector();\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 qty;\\n\\n            if (tokens[i] == address(0)) {\\n                qty = address(this).balance;\\n                collector.safeTransferETH(qty);\\n            } else {\\n                qty = ERC20(tokens[i]).balanceOf(address(this));\\n                ERC20(tokens[i]).safeTransfer(collector, qty);\\n            }\\n        }\\n    }\\n\\n    /// @dev Pause or unpause the contract\\n    function pause() external onlyOwner {\\n        paused = !paused;\\n    }\\n\\n    /// @notice Sets the fee\\n    /// @param _fee The new fee amount between 0.06-1%\\n    function setFee(uint256 _fee) public onlyOwner {\\n        require(_fee >= 6 && _fee <= 100, \\\"Invalid Fee\\\");\\n        fee = _fee;\\n    }\\n\\n    /// @notice Updates the registry\\n    /// @param _registry The address of the new registry\\n    function updateRegistry(IPortalRegistry _registry) external onlyOwner {\\n        registry = _registry;\\n    }\\n\\n    /// @notice Reverts if networks tokens are sent directly to this contract\\n    receive() external payable {\\n        require(msg.sender != tx.origin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/convex/ConvexPortalIn.sol\": {\r\n      \"content\": \"/// Copyright (C) 2022 Portals.fi\\n\\n/// @author Portals.fi\\n/// @notice This contract adds liquidity and stakes liquiditity into Convex like pools using any ERC20 token or the network token.\\n\\n/// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.11;\\n\\nimport \\\"../base/PortalBaseV1.sol\\\";\\nimport \\\"../interface/IPortalRegistry.sol\\\";\\nimport \\\"./interface/IBaseRewardPool.sol\\\";\\nimport \\\"./interface/IBooster.sol\\\";\\n\\n/// Thrown when insufficient liquidity is received after deposit\\n/// @param buyAmount The amount of liquidity received\\n/// @param minBuyAmount The minimum acceptable quantity of liquidity received\\nerror InsufficientBuy(uint256 buyAmount, uint256 minBuyAmount);\\n\\ncontract ConvexPortalIn is PortalBaseV1 {\\n    using SafeTransferLib for address;\\n    using SafeTransferLib for ERC20;\\n\\n    IBooster internal immutable BOOSTER;\\n\\n    /// @notice Emitted when a portal is entered\\n    /// @param sellToken The ERC20 token address to spend (address(0) if network token)\\n    /// @param sellAmount The quantity of sellToken to Portal in\\n    /// @param buyToken The ERC20 token address to buy (address(0) if network token)\\n    /// @param buyAmount The quantity of buyToken received\\n    /// @param fee The fee in BPS\\n    /// @param sender The  msg.sender\\n    /// @param partner The front end operator address\\n    event PortalIn(\\n        address sellToken,\\n        uint256 sellAmount,\\n        address buyToken,\\n        uint256 buyAmount,\\n        uint256 fee,\\n        address indexed sender,\\n        address indexed partner\\n    );\\n\\n    constructor(\\n        bytes32 protocolId,\\n        PortalType portalType,\\n        IPortalRegistry registry,\\n        address exchange,\\n        address wrappedNetworkToken,\\n        uint256 fee,\\n        IBooster _booster\\n    )\\n        PortalBaseV1(\\n            protocolId,\\n            portalType,\\n            registry,\\n            exchange,\\n            wrappedNetworkToken,\\n            fee\\n        )\\n    {\\n        BOOSTER = _booster;\\n    }\\n\\n    /// @notice Add liquidity and stake into Convex like pools with network tokens/ERC20 tokens\\n    /// @param sellToken The ERC20 token address to spend (address(0) if network token)\\n    /// @param sellAmount The quantity of sellToken to Portal in\\n    /// @param intermediateToken The intermediate token to swap to (must be the underlying LP token)\\n    /// @param buyToken The Convex like deposit token address (i.e. the cvxToken)\\n    /// @param minBuyAmount The minimum quantity of buyTokens to receive. Reverts otherwise\\n    /// note: crv tokens are 1:1 with cvx tokens\\n    /// @param target The excecution target for the intermediate swap\\n    /// @param data  The encoded call for the intermediate swap\\n    /// @param partner The front end operator address\\n    /// @param rewardPool The base reward pool for the buyToken\\n    /// @return buyAmount The quantity of buyToken acquired\\n    /// @dev buyAmount is staked and not returned to msg.sender!\\n    function portalIn(\\n        address sellToken,\\n        uint256 sellAmount,\\n        address intermediateToken,\\n        address buyToken,\\n        uint256 minBuyAmount,\\n        address target,\\n        bytes calldata data,\\n        address partner,\\n        IBaseRewardPool rewardPool\\n    ) external payable pausable returns (uint256 buyAmount) {\\n        uint256 amount = _transferFromCaller(sellToken, sellAmount);\\n        amount = _getFeeAmount(amount, fee);\\n        amount = _execute(sellToken, amount, intermediateToken, target, data);\\n\\n        buyAmount = _deposit(intermediateToken, amount, buyToken, rewardPool);\\n\\n        if (buyAmount < minBuyAmount)\\n            revert InsufficientBuy(buyAmount, minBuyAmount);\\n\\n        _stake(buyToken, buyAmount, rewardPool);\\n\\n        emit PortalIn(\\n            sellToken,\\n            sellAmount,\\n            buyToken,\\n            buyAmount,\\n            fee,\\n            msg.sender,\\n            partner\\n        );\\n    }\\n\\n    /// @notice Deposits the Underlying LP (e.g. Curve LP) into the pool\\n    /// @param intermediateToken The underlying LP token to deposit\\n    /// @param amount The quantity of intermediateToken to deposit\\n    /// @param buyToken The Convex like deposit token address (i.e. the cvxToken)\\n    /// @param rewardPool The base reward pool for the buyToken\\n    function _deposit(\\n        address intermediateToken,\\n        uint256 amount,\\n        address buyToken,\\n        IBaseRewardPool rewardPool\\n    ) internal returns (uint256 buyAmount) {\\n        uint256 pid = rewardPool.pid();\\n\\n        uint256 balance = _getBalance(address(this), buyToken);\\n\\n        _approve(intermediateToken, address(BOOSTER), amount);\\n        BOOSTER.deposit(pid, amount, false);\\n\\n        buyAmount = _getBalance(address(this), buyToken) - balance;\\n    }\\n\\n    /// @notice Stakes the cvxToken into the reward pool\\n    /// @param buyToken The Convex like deposit token address (i.e. the cvxToken)\\n    /// @param buyAmount The quantity of buyToken to deposit\\n    /// @param rewardPool The base reward pool for the buyToken\\n    function _stake(\\n        address buyToken,\\n        uint256 buyAmount,\\n        IBaseRewardPool rewardPool\\n    ) internal {\\n        _approve(buyToken, address(rewardPool), buyAmount);\\n        rewardPool.stakeFor(msg.sender, buyAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/convex/interface/IBaseRewardPool.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\ninterface IBaseRewardPool {\\n    function pid() external view returns (uint256);\\n\\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/convex/interface/IBooster.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\ninterface IBooster {\\n    function deposit(\\n        uint256 _pid,\\n        uint256 _amount,\\n        bool _stake\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPortalFactory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./IPortalRegistry.sol\\\";\\n\\ninterface IPortalFactory {\\n    function fee() external view returns (uint256 fee);\\n\\n    function registry() external view returns (IPortalRegistry registry);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPortalRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.11;\\n\\nenum PortalType {\\n    IN,\\n    OUT\\n}\\n\\ninterface IPortalRegistry {\\n    function addPortal(\\n        address portal,\\n        PortalType portalType,\\n        bytes32 protocolId\\n    ) external;\\n\\n    function addPortalFactory(\\n        address portalFactory,\\n        PortalType portalType,\\n        bytes32 protocolId\\n    ) external;\\n\\n    function removePortal(bytes32 protocolId, PortalType portalType) external;\\n\\n    function owner() external view returns (address owner);\\n\\n    function registrars(address origin) external view returns (bool isDeployer);\\n\\n    function collector() external view returns (address collector);\\n\\n    function isPortal(address portal) external view returns (bool isPortal);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IWETH.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.11;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/solmate/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max)\\n            allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(\\n                recoveredAddress != address(0) && recoveredAddress == owner,\\n                \\\"INVALID_SIGNER\\\"\\n            );\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return\\n            block.chainid == INITIAL_CHAIN_ID\\n                ? INITIAL_DOMAIN_SEPARATOR\\n                : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/solmate/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport { ERC20 } from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    event Debug(bool one, bool two, uint256 retsize);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"protocolId\",\"type\":\"bytes32\"},{\"internalType\":\"enum PortalType\",\"name\":\"portalType\",\"type\":\"uint8\"},{\"internalType\":\"contract IPortalRegistry\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedNetworkToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"contract IBooster\",\"name\":\"_booster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBuyAmount\",\"type\":\"uint256\"}],\"name\":\"InsufficientBuy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"PortalIn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"intermediateToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minBuyAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"contract IBaseRewardPool\",\"name\":\"rewardPool\",\"type\":\"address\"}],\"name\":\"portalIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IPortalRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPortalRegistry\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNetworkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ConvexPortalIn", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "636f6e76657800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ea49d02c248b357b99670d9e9741f54f72df9cb3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000f403c135812408bfbe8713b5a23a04b3d48aae31", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}