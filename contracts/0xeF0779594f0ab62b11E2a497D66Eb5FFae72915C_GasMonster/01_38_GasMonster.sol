// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import 'erc721a/contracts/ERC721A.sol';
import './ChainlinkInfrastructureClient.sol';
import './TokenURIResolver.sol';
import './PausableMint.sol';
import './Withdrawable.sol';
import './Royalty.sol';
import './interfaces/IERC20.sol';
import './libs/SignerVerification.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import 'hardhat/console.sol';

struct NFT {
	uint8 level; // 1-7
	/*
	 * COMMON PARTS
	 * value from 0 to n, where n - is max number of property,
	 * 10 (NULL) - absence of params
	 */
	uint8 gender; // 0-1
	uint8 color; // 0-4
	uint8 background; // 1-4 on levels 1-4 and 5-9 on levels 5-7
	uint8 necklace; // 0-9
	uint8 accessories; // 0-9
	uint8 weapon; //  0-9
	/*
	 * ROBO PARTS
	 * head, body, tail, wingLeft, wingRight, armLeft, armRight, legLeft, legRight
	 */
	bool[9] roboParts;
}

contract GasMonster is
	ERC721A,
	ChainlinkInfrastructureClient,
	TokenURIResolver,
	PausableMint,
	Withdrawable,
	Royalty,
	ReentrancyGuard
{
	using Chainlink for Chainlink.Request;

	address private signer; // Address of presale signatures creator

	// NULL definition that suits for NFT properties
	uint8 private constant NULL = 10;

	uint256 public publicSaleTimestamp;
	uint256 public preSaleTimestamp;

	uint256 public preSalePriceOfNFT = 0.000005 ether;
	uint256 public publicSalePriceOfNFT = 0.00001 ether;
	uint256 public discountedGirlDragonPrice = 0.0000075 ether;
	// uint256 public maxSupply = 10000

	uint256 public timestampOfSexChangeAtMint = 1661990400; // 1 sepetember 2022

	// Mapping of supported interfaces
	mapping(bytes4 => bool) private _supportedInterfaces;

	struct Upgrade {
		bool inProgress;
		uint256 timestamp;
	}

	// NFT properties by tokenId
	mapping(uint256 => NFT) internal Tokens;

	/*
	 * Requests to get update availability
	 * @param requestId - generated by Chainlink
	 * @return tokenId  - NFT ID
	 */
	mapping(bytes32 => uint256) private UpgradeRequests;

	/*
	 * Requests to get random number
	 * @param requestId - ID returned from request builder function
	 * @return tokenId - NFT ID
	 */
	mapping(uint256 => uint256[]) internal VRFRequests;

	/*
	 * Requests to get random number
	 * @param tokenId - NFT ID for what was request
	 * @return lastUpdateRequestTimestamp
	 */
	mapping(uint256 => Upgrade) internal LastUpgrades;

	/**
	 * Events
	 * @notice they are needed for backend to refresh data in DB and create/update NFT images
	 */
	event MintFinal(address owner, uint256 tokenId, uint8 gender, uint8 color);

	// Event for NFT that just have been upgraded
	event LevelUp(
		uint256 tokenId,
		uint8 level,
		uint8 gender,
		uint8 color,
		uint8 background,
		uint8 necklace,
		uint8 accessories,
		uint8 weapon,
		bool[9] roboParts
	);

	event UpgradeFailed(bytes32 requestId);

	constructor(
		ChainlinkConfig memory _chainlinkConfig,
		ChainlinkVRFConfig memory _chainlinkVRFConfig,
		string memory _ipfsMetadataURL,
		string memory _backendBaseURL,
		uint256 _preSalePriceOfNFT,
		uint256 _publicSalePriceOfNFT,
		uint256 _discountedGirlDragonPrice,
		uint256 _preSaleTimestamp,
		uint256 _publicSaleTimestamp,
		address royaltyReceiver
	)
		ChainlinkInfrastructureClient(_chainlinkConfig, _chainlinkVRFConfig)
		ERC721A('GasMonsterNFT', 'GMN')
		Royalty(royaltyReceiver)
		TokenURIResolver(_backendBaseURL, _ipfsMetadataURL)
	{
		preSalePriceOfNFT = _preSalePriceOfNFT;
		publicSalePriceOfNFT = _publicSalePriceOfNFT;
		discountedGirlDragonPrice = _discountedGirlDragonPrice;

		preSaleTimestamp = _preSaleTimestamp;
		publicSaleTimestamp = _publicSaleTimestamp;

		signer = msg.sender;

		_registerInterface(_INTERFACE_ID_ERC2981);
		_registerInterface(type(IERC165).interfaceId);
		_registerInterface(type(IERC721).interfaceId);
		_registerInterface(type(IERC721Metadata).interfaceId);
	}

	/**
	 * Mints some quantity of NFTs on pre sale stage
	 * @param quantity of NFTs to mint
	 * @param signature address of msg.sender signed by owner of contract
	 * needed for WL
	 * @notice msg.value should be enough for mint, including NFT price (preSalePriceOfNFT * quantity)
	 * @notice presale should start, otherwise tx will be reverted
	 */
	function mintOnPreSale(uint256 quantity, bytes memory signature) external payable {
		require(_currentTime() > preSaleTimestamp, 'Pre-sale is not started yet');

		// Verify signature
		require(
			SignerVerification.isMessageVerified(signer, signature, _addressToString(msg.sender)),
			'Presale signature is wrong'
		);
		require(msg.value >= preSalePriceOfNFT * quantity, 'GasMonster: Not enough ethers to mint NFTs');

		_mint(quantity, msg.sender);
	}

	/**
	 * Mints some quantity of NFTs on public sale stage
	 * @param quantity of NFTs to mint
	 * @notice msg.value should be enough for mint, including NFT price (publicSalePriceOfNFT * quantity)
	 * @notice public sale should start, otherwise tx will be reverted
	 */
	function mintOnPublicSale(uint256 quantity) external payable {
		require(_currentTime() > publicSaleTimestamp, 'Public sale is not started yet');
		require(msg.value >= publicSalePriceOfNFT * quantity, 'GasMonster: Not enough ethers to mint NFTs');

		_mint(quantity, msg.sender);
	}

	/**
	 * Mints some quantity of NFTs
	 * @param quantity of NFTs to mint
	 * @param boyDragonId ID of dragon boy of msg.sender that can give discount for mint girl dragon
	 *
	 * @notice msg.value should be enough for mint, including NFT price (discountedGirlDragonPrice * quantity)
	 * @notice Boy dragon ID must be owned by msg.sender
	 */
	function mintDragonGirlWithDiscount(uint256 boyDragonId, uint256 quantity) external payable {
		require(_currentTime() >= timestampOfSexChangeAtMint, 'Mint of girl dragons is not started yet');

		NFT storage dragon = Tokens[boyDragonId];
		require(dragon.gender == 1, 'Given boyDragonId is the ID of girl dragon');

		require(ownerOf(boyDragonId) == msg.sender, 'You are not the owner of boy dragon');

		require(msg.value >= quantity * discountedGirlDragonPrice, 'GasMonster: Not enough ethers to mint NFTs');

		_mint(quantity, msg.sender);
	}

	/**
	 * Mints some quantity of NFTs
	 * @param quantity of NFTs to mint
	 * @param receiver address that will receive NFT
	 *
	 * @notice Mints not more than 10 NFTs by transaction
	 * @notice Can mint not more than 20 NFTs by account
	 */
	function _mint(uint256 quantity, address receiver) internal whenNotPaused {
		require(balanceOf(receiver) + quantity <= 20, 'GasMonster: You are allowed to get only 20 NFTs');
		require(quantity <= 10, 'GasMonster: You can mint only 10 mint in one transaction');

		uint256 startTokenId = _totalMinted();

		_safeMint(receiver, quantity);

		_recordMintedTokens(startTokenId, quantity, receiver);
	}

	function _recordMintedTokens(
		uint256 startTokenId,
		uint256 quantity,
		address tokenOwner
	) internal {
		// Array of minted tokens
		uint256[] memory mintedTokensIds = new uint256[](quantity);

		// last token number
		uint256 currentIndex = startTokenId;

		for (uint256 i = 0; i < quantity; ) {
			// Define nft gender
			uint8 nftGender;
			if (_currentTime() < timestampOfSexChangeAtMint) {
				// Male
				nftGender = 1;
			} else {
				// Female
				nftGender = 0;
			}
			// Define nft color
			uint8 nftColor = uint8(
				uint256(keccak256(abi.encodePacked(block.timestamp, block.number, currentIndex))) % 5
			);

			Tokens[currentIndex] = NFT(
				1,
				nftGender,
				nftColor,
				NULL,
				NULL,
				NULL,
				NULL,
				[false, false, false, false, false, false, false, false, false]
			);

			mintedTokensIds[i] = currentIndex;

			emit MintFinal(tokenOwner, currentIndex, nftGender, nftColor);

			unchecked {
				currentIndex++;
				i++;
			}
		}

		// TODO: Delete before deployment
		if (block.chainid != 31337) {
			_requestNFTPropsFullfillmentWithRandom(mintedTokensIds);
		}
	}

	// /**
	//  * Creates struct of NFT
	//  * @notice creates NFT of 1 level with empty params to fulfill them later
	//  */
	// function createEmptyNFT() internal pure returns (NFT memory) {
	// 	NFT memory token =
	// 	return token;
	// }

	/**
	 * Called by user to update NFT
	 * @param tokenId - ID of user's NFT
	 * @notice must be called to upgrade NFT
	 * @dev Builds Chainlink request to backend to get level-up availability
	 */
	function triggerUpgrade(uint256 tokenId) external nonReentrant {
		// Check for existence and for ownership
		require(msg.sender == ownerOf(tokenId), 'GasMonster: Only owner can upgrade NFT');
		require(Tokens[tokenId].level < 7, 'GasMonster: Token had alreay reached max level'); // all requirements take 7314 gas units
		require(
			_canRequestUpgrade(tokenId),
			'GasMonster: Upgrade already in progress. If request will not complete in 15 minutes, you will be able to request upgrade again'
		);

		Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.upgrade.selector);

		request.add(
			'get',
			string(abi.encodePacked(TokenURIResolver.backendBaseURL, '/canUpgrade/', Strings.toString(tokenId)))
		);
		request.add('path', 'data');

		// TODO: Delete before deployment
		if (block.chainid != 31337) {
			UpgradeRequests[sendChainlinkRequestTo(oracle, request, fee)] = tokenId;
		}

		LastUpgrades[tokenId] = Upgrade(true, _currentTime());
	}

	/**
	 * Check if upgrade is already in progres or user requested upgrade recently
	 * @param tokenId - ID of user's NFT
	 * @notice prevetns multiple requests that can create conflicts
	 */
	function _canRequestUpgrade(uint256 tokenId) internal view returns (bool) {
		Upgrade memory lastTokenUpgrade = LastUpgrades[tokenId];
		return !lastTokenUpgrade.inProgress || _currentTime() >= lastTokenUpgrade.timestamp + 15 minutes;
	}

	/**
	 * Upgrade that should be called fullfilled by Oracle
	 * @notice shouldn't be called to upgrade NFT (internal logic function)
	 * @param requestId - ID of Chainlink request
	 * @param canBeUpgraded - result of external request (must be boolean)
	 */
	function upgrade(bytes32 requestId, bool canBeUpgraded) public recordChainlinkFulfillment(requestId) {
		if (!canBeUpgraded) {
			emit UpgradeFailed(requestId);
			return;
		}

		uint256 tokenId = UpgradeRequests[requestId];

		NFT storage token = Tokens[tokenId];
		token.level = token.level + 1;

		uint256[] memory Ids = new uint256[](1);
		Ids[0] = tokenId;

		if (token.level == 7) {
			_fillInMissingPropsOfToken(tokenId, 12345678910111213);
			_emitSuitingEvent(tokenId);
			delete LastUpgrades[tokenId];
		} else {
			_requestNFTPropsFullfillmentWithRandom(Ids);
		}

		delete UpgradeRequests[requestId];
	}

	/**
	 * Makes request to ChainlinkVRF for random number
	 * @param tokenIds NFT IDs with empty properties to fill in
	 */
	function _requestNFTPropsFullfillmentWithRandom(uint256[] memory tokenIds) internal {
		uint256 requestId = COORDINATOR.requestRandomWords(
			keyHash,
			subscriptionId,
			requestConfirmations,
			callbackGasLimit,
			1 // Count of random words
		);

		// Record requestId and tokenId pair to get that as context later (in fulfillRandomWords())
		VRFRequests[requestId] = tokenIds;

		for (uint8 i = 0; i < tokenIds.length; ) {
			console.log('check');
			LastUpgrades[tokenIds[i]] = Upgrade(true, _currentTime());
			unchecked {
				i++;
			}
		}
	}

	/**
	 * Called by Chainlink VRF to fill in missing NFT params with random words
	 * @param _requestId unique request identifier
	 * @param _randomWords - some big random numbers
	 * @dev function name can't be changed! That is the standard name in Chainlink VRF
	 */
	function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
		uint256[] memory tokenIds = VRFRequests[_requestId];

		uint256 tempRandomWord = _randomWords[0];
		uint256 randomWordLength;

		while (tempRandomWord > 0) {
			tempRandomWord = tempRandomWord / 10;
			randomWordLength++;
		}

		// Random word like 10 can't be used to fill in 2 props, it's too short. Minimum is 4 digit number (1000-9999)
		// require(
		// 	randomWordLength >= tokenIds.length * 4,
		// 	string(
		// 		abi.encodePacked(
		// 			'GasMonster: Random number is too short to fullfill ',
		// 			Strings.toString(tokenIds.length),
		// 			' NFTs properties'
		// 		)
		// 	)
		// );

		uint256 randomWord = _randomWords[0];

		// Fill in every NFT properties with different parts of random word
		for (uint8 i = 0; i < tokenIds.length; ) {
			_fillInMissingPropsOfToken(tokenIds[i], randomWord);
			// Emits MintFinal() or LevelUp() event
			_emitSuitingEvent(tokenIds[i]);

			uint8 tokenLevel = Tokens[tokenIds[i]].level;

			delete LastUpgrades[tokenIds[i]];

			if (tokenLevel >= 5) {
				// Generating robo parts takes at least 6 digit random number
				randomWord = randomWord / 1000000;
			} else {
				// Generating parts for 1 and 2 levels takes at least 4 digit random number
				randomWord = randomWord / 10000;
			}

			unchecked {
				i++;
			}
		}

		// Clear requests mapping
		delete VRFRequests[_requestId];
	}

	/**
	 * @param tokenId NFT ID
	 * @return boolean of having of all params required by the level
	 */
	// function _hasAllParamsAccordingToLevel(uint256 tokenId) internal view returns (bool) {
	// 	NFT storage token = Tokens[tokenId];

	// 	if (token.level == 1) {
	// 		return token.color != NULL && token.gender != NULL;
	// 	} else if (token.level == 2) {
	// 		return token.background != NULL && token.necklace != NULL;
	// 	} else if (token.level == 3) {
	// 		return token.accessories != NULL;
	// 	} else if (token.level == 4) {
	// 		return token.weapon != NULL;

	// 		// Robo parts counting
	// 	} else if (token.level == 5) {
	// 		return _countFilledRoboPartsOfToken(tokenId) == 3 && token.background >= 5 && token.background <= 9;
	// 	} else if (token.level == 6) {
	// 		return _countFilledRoboPartsOfToken(tokenId) == 6;
	// 	} else {
	// 		return _countFilledRoboPartsOfToken(tokenId) == 9;
	// 	}
	// }

	/**
	 * Fills NFT params required by level with random number
	 * @param tokenId NFT ID
	 * @param _randomNumber number recevied from Chainlink VRF
	 */
	function _fillInMissingPropsOfToken(uint256 tokenId, uint256 _randomNumber) internal {
		NFT storage token = Tokens[tokenId];

		// require(!_hasAllParamsAccordingToLevel(tokenId), 'All necessary properties are already filled in');

		// Checking random number to be long enough to fill params
		// if (token.level >= 5) {
		// 	_requireNumberToBeMoreThan(_randomNumber, 99999);
		// } else if (token.level < 3) {
		// 	_requireNumberToBeMoreThan(_randomNumber, 999);
		// } else {
		// 	_requireNumberToBeMoreThan(_randomNumber, 9);
		// }

		uint256 randomNumber = _randomNumber;

		if (token.level == 1) {
			// Define gender
			if (_currentTime() < timestampOfSexChangeAtMint) {
				// Male
				token.gender = 1;
			} else {
				// Female
				token.gender = 0;
			}

			// Dividing by 100 to get other part of the number
			token.color = uint8(randomNumber % 5);
		} else if (token.level == 2) {
			token.background = uint8(randomNumber % 5);
			// Dividing by 100 to get other part of the number
			token.necklace = uint8((randomNumber / 100) % 10);
		} else if (token.level == 3) {
			token.accessories = uint8(randomNumber % 10);
		} else if (token.level == 4) {
			token.weapon = uint8(randomNumber % 10);

			// Robo parts fullfilment
		} else if (token.level >= 5) {
			uint256 roboPartsCounter = _countFilledRoboPartsOfToken(tokenId);

			while (roboPartsCounter < 3 * (token.level - 4)) {
				_fillInRoboPartOfToken(tokenId, randomNumber);
				randomNumber = randomNumber / 100;
				roboPartsCounter++;
			}
		}

		// Update background on level 5
		if (token.level == 5) {
			// On level 5 background is changing to 5-9 value
			token.background = uint8(randomNumber % 5) + 5;
		}
	}

	/**
	 * @param tokenId NFT ID
	 * @return counter - number of robo parts NFT currently have
	 * @dev order of robo parts can be viewed in NFT struct
	 */
	function _countFilledRoboPartsOfToken(uint256 tokenId) internal view returns (uint8 counter) {
		NFT storage token = Tokens[tokenId];

		for (uint8 i = 0; i < 9; ) {
			if (token.roboParts[i]) counter++;
			unchecked {
				i++;
			}
		}
	}

	/**
	 * Fills one random robo part of token with given ID
	 * @param tokenId ID of NFT to update
	 * @param randomNumber random number from ChainlinkVRF
	 */
	function _fillInRoboPartOfToken(uint256 tokenId, uint256 randomNumber) internal {
		// _requireNumberToBeMoreThan(randomNumber, 9);

		NFT storage token = Tokens[tokenId];

		uint8 filledParts = _countFilledRoboPartsOfToken(tokenId);

		uint8 randomPositionCounter = uint8((randomNumber % (9 - filledParts)) + 1);

		uint8 trueCounter;
		// Iterator
		uint8 i;

		do {
			if (token.roboParts[i]) {
				trueCounter++;
			}
			unchecked {
				i++;
			}
		} while (i < randomPositionCounter + trueCounter);

		token.roboParts[i - 1] = true;
	}

	/**
	 * Emits event depending on NFT level
	 * @param tokenId ID of NFT to update
	 * @notice correct event is required for backend to generate or update image
	 */
	function _emitSuitingEvent(uint256 tokenId) internal {
		NFT storage token = Tokens[tokenId];

		if (token.level == 1) {
			// Sub 1 needs because backend expects numbers 0-1 and 0-4
			emit MintFinal(ownerOf(tokenId), tokenId, token.gender, token.color);
		} else {
			emit LevelUp(
				tokenId,
				token.level,
				token.gender,
				token.color,
				token.background,
				token.necklace,
				token.accessories,
				token.weapon,
				token.roboParts
			);
		}
	}

	/**
	 * Returns URL to token metadata
	 * @param tokenId ID of NFT to return URL
	 * @return string URI to backend or IPFS
	 * @dev Uses TokenURIManager to generate url
	 */
	function tokenURI(uint256 tokenId) public view override returns (string memory) {
		require(_exists(tokenId), 'GasMonster: URI request for non existen token');

		NFT memory token = Tokens[tokenId];

		return TokenURIResolver.formatTokenURI(tokenId, token);
	}

	/**
	 * @param tokenId ID of NFT
	 */
	function getTokenById(uint256 tokenId) external view returns (NFT memory) {
		return Tokens[tokenId];
	}

	/** Updates pre-sale price of NFT
	 * @param _preSalePriceOfNFT new pre-sale price for NFT
	 * @dev only owner of contract can change price
	 */
	function setPreSalePriceOfNFT(uint256 _preSalePriceOfNFT) external onlyOwner {
		preSalePriceOfNFT = _preSalePriceOfNFT;
	}

	/** Updates public sale price of NFT
	 * @param _publicSalePriceOfNFT public sale price for NFT
	 * @dev only owner of contract can change price
	 */
	function setPublicSalePriceOfNFT(uint256 _publicSalePriceOfNFT) external onlyOwner {
		publicSalePriceOfNFT = _publicSalePriceOfNFT;
	}

	function setDiscountedGirlDragonPrice(uint256 _discountedGirlDragonPrice) external onlyOwner {
		discountedGirlDragonPrice = _discountedGirlDragonPrice;
	}

	// function _requireNumberToBeMoreThan(uint256 number, uint256 minValue) internal pure {
	// 	require(number > minValue, 'GasMonster: number is too small');
	// }

	function changeRoyaltyReceiver(address receiver) external onlyOwner {
		_changeRoyaltyReceiver(receiver);
	}

	function _registerInterface(bytes4 interfaceId) internal {
		_supportedInterfaces[interfaceId] = true;
	}

	function supportsInterface(bytes4 interfaceId) public view override(ERC721A, IERC165, ERC165) returns (bool) {
		return _supportedInterfaces[interfaceId];
	}

	bool private isChainlinkNodeWorks = false;

	function testChainlinkRequest() external {
		isChainlinkNodeWorks = false;

		Chainlink.Request memory request = buildChainlinkRequest(
			jobId,
			address(this),
			this.fullfilChainlinkRequest.selector
		);

		request.add(
			'get',
			string(abi.encodePacked('https://my-json-server.typicode.com/lamerest/mock-backend/canUpgrade/0'))
		);
		request.add('path', 'data');

		sendChainlinkRequestTo(oracle, request, fee);
	}

	event ChainlinkRequestTestSuccessful(bytes32 requestId);

	function fullfilChainlinkRequest(bytes32 requestId, bool) public recordChainlinkFulfillment(requestId) {
		isChainlinkNodeWorks = true;
		emit ChainlinkRequestTestSuccessful(requestId);
	}

	function getLastChainlinkNodeWorkState() public view returns (bool) {
		return isChainlinkNodeWorks;
	}

	function setTimestampOfSexChangeAtMint(uint256 _timestampOfSexChangeAtMint) external onlyOwner {
		timestampOfSexChangeAtMint = _timestampOfSexChangeAtMint;
	}

	function setPreSaleTimestamp(uint256 _preSaleTimestamp) external {
		preSaleTimestamp = _preSaleTimestamp;
	}

	function setPublicSaleTimestamp(uint256 _publicSaleTimestamp) external {
		publicSaleTimestamp = _publicSaleTimestamp;
	}

	function _addressToString(address _addr) internal pure returns (string memory) {
		bytes memory addressBytes = abi.encodePacked(_addr);

		bytes memory stringBytes = new bytes(42);

		stringBytes[0] = '0';
		stringBytes[1] = 'x';

		for (uint256 i = 0; i < 20; ) {
			uint8 leftValue = uint8(addressBytes[i]) / 16;
			uint8 rightValue = uint8(addressBytes[i]) - 16 * leftValue;

			bytes1 leftChar = leftValue < 10 ? bytes1(leftValue + 48) : bytes1(leftValue + 87);
			bytes1 rightChar = rightValue < 10 ? bytes1(rightValue + 48) : bytes1(rightValue + 87);

			stringBytes[2 * i + 3] = rightChar;
			stringBytes[2 * i + 2] = leftChar;

			unchecked {
				i++;
			}
		}

		return string(stringBytes);
	}

	function _currentTime() internal view returns (uint64) {
		return uint64(block.timestamp);
	}
}