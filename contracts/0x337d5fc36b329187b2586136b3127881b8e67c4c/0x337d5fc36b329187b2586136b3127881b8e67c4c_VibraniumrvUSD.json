{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT  \\npragma solidity ^0.8.0;\\n//  AggregatorV3Interface\\ninterface AggregatorV3Interface {\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\"\r\n    },\r\n    \"contracts/esVIBMinter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n\\ninterface esVIBMinter {\\n    function refreshReward(address user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\ncontract Governable {\\n    address public gov;\\n\\n    modifier onlyGov() {\\n        require(msg.sender == gov, \\\"Governable: forbidden\\\");\\n        _;\\n    }\\n\\n    function setGov(address _gov) external onlyGov {\\n        gov = _gov;\\n    }\\n}\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/Ireth.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n\\ninterface Ireth {\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n\\n    function transfer(address _recipient, uint256 _amount)\\n        external\\n        returns (bool);\\n\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) external returns (bool);\\n\\n    function getExchangeRate() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/ISwap.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n\\ninterface ISwap {\\n    function mintSwap(address _account, uint _amount) external;\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/RVUSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n/**\\n * @title Interest-bearing ERC20-like token for Vibranium protocol.\\n *\\n * This contract is abstract. To make the contract deployable override the\\n * `_getTotalMintedVUSD` function. `Vibranium.sol` contract inherits VUSD and defines\\n * the `_getTotalMintedVUSD` function.\\n *\\n * VUSD balances are dynamic and represent the holder's share in the total amount\\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\\n * contract also stores the sum of all shares to calculate each account's token balance\\n * which equals to:\\n *\\n *   shares[account] * _getTotalMintedVUSD() / _getTotalShares()\\n *\\n * For example, assume that we have:\\n *\\n *   _getTotalMintedVUSD() -> 1000 VUSD\\n *   sharesOf(user1) -> 100\\n *   sharesOf(user2) -> 400\\n *\\n * Therefore:\\n *\\n *   balanceOf(user1) -> 2 tokens which corresponds 200 VUSD\\n *   balanceOf(user2) -> 8 tokens which corresponds 800 VUSD\\n *\\n * Since balances of all token holders change when the amount of total supplied VUSD\\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\\n * events upon explicit transfer between holders. In contrast, when total amount of\\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\\n * emitting an event for each token holder and thus running an unbounded loop.\\n */\\nabstract contract RVUSD is IERC20 {\\n    using SafeMath for uint256;\\n    uint256 private totalShares;\\n\\n    /**\\n     * @dev VUSD balances are dynamic and are calculated based on the accounts' shares\\n     * and the total supply by the protocol. Account shares aren't\\n     * normalized, so the contract also stores the sum of all shares to calculate\\n     * each account's token balance which equals to:\\n     *\\n     *   shares[account] * _getTotalMintedVUSD() / _getTotalShares()\\n     */\\n    mapping(address => uint256) private shares;\\n\\n    /**\\n     * @dev Allowances are nominated in tokens, not token shares.\\n     */\\n    mapping(address => mapping(address => uint256)) private allowances;\\n\\n    /**\\n     * @notice An executed shares transfer from `sender` to `recipient`.\\n     *\\n     * @dev emitted in pair with an ERC20-defined `Transfer` event.\\n     */\\n    event TransferShares(\\n        address indexed from,\\n        address indexed to,\\n        uint256 sharesValue\\n    );\\n\\n    /**\\n     * @notice An executed `burnShares` request\\n     *\\n     * @dev Reports simultaneously burnt shares amount\\n     * and corresponding VUSD amount.\\n     * The VUSD amount is calculated twice: before and after the burning incurred rebase.\\n     *\\n     * @param account holder of the burnt shares\\n     * @param preRebaseTokenAmount amount of VUSD the burnt shares corresponded to before the burn\\n     * @param postRebaseTokenAmount amount of VUSD the burnt shares corresponded to after the burn\\n     * @param sharesAmount amount of burnt shares\\n     */\\n    event SharesBurnt(\\n        address indexed account,\\n        uint256 preRebaseTokenAmount,\\n        uint256 postRebaseTokenAmount,\\n        uint256 sharesAmount\\n    );\\n\\n    /**\\n     * @return the name of the token.\\n     */\\n    function name() public pure returns (string memory) {\\n        return \\\"rvUSD\\\";\\n    }\\n\\n    /**\\n     * @return the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public pure returns (string memory) {\\n        return \\\"rvUSD\\\";\\n    }\\n\\n    /**\\n     * @return the number of decimals for getting user representation of a token amount.\\n     */\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @return the amount of VUSD in existence.\\n     *\\n     * @dev Always equals to `_getTotalMintedVUSD()` since token amount\\n     * is pegged to the total amount of VUSD controlled by the protocol.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _getTotalMintedVUSD();\\n    }\\n\\n    /**\\n     * @return the amount of tokens owned by the `_account`.\\n     *\\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\\n     * total Ether controlled by the protocol. See `sharesOf`.\\n     */\\n    function balanceOf(address _account) public view returns (uint256) {\\n        return getMintedVUSDByShares(_sharesOf(_account));\\n    }\\n\\n    /**\\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     * Emits a `Transfer` event.\\n     * Emits a `TransferShares` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `_amount`.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function transfer(\\n        address _recipient,\\n        uint256 _amount\\n    ) public returns (bool) {\\n        _transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @return the remaining number of tokens that `_spender` is allowed to spend\\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\\n     *\\n     * @dev This value changes when `approve` or `transferFrom` is called.\\n     */\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    ) public view returns (uint256) {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    /**\\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\n        _approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\\n     * allowance mechanism. `_amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * @return a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     * Emits a `TransferShares` event.\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` and `_recipient` cannot be the zero addresses.\\n     * - `_sender` must have a balance of at least `_amount`.\\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_amount` argument is the amount of tokens, not shares.\\n     */\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) public returns (bool) {\\n        uint256 currentAllowance = allowances[_sender][msg.sender];\\n        require(\\n            currentAllowance >= _amount,\\n            \\\"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\\\"\\n        );\\n\\n        _transfer(_sender, _recipient, _amount);\\n        _approve(_sender, msg.sender, currentAllowance.sub(_amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in:\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function increaseAllowance(\\n        address _spender,\\n        uint256 _addedValue\\n    ) public returns (bool) {\\n        _approve(\\n            msg.sender,\\n            _spender,\\n            allowances[msg.sender][_spender].add(_addedValue)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in:\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `_spender` cannot be the zero address.\\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\\n     * - the contract must not be paused.\\n     */\\n    function decreaseAllowance(\\n        address _spender,\\n        uint256 _subtractedValue\\n    ) public returns (bool) {\\n        uint256 currentAllowance = allowances[msg.sender][_spender];\\n        require(\\n            currentAllowance >= _subtractedValue,\\n            \\\"DECREASED_ALLOWANCE_BELOW_ZERO\\\"\\n        );\\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @return the total amount of shares in existence.\\n     *\\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\\n     * it is necessary to store it in order to calculate each account's relative share.\\n     */\\n    function getTotalShares() public view returns (uint256) {\\n        return _getTotalShares();\\n    }\\n\\n    /**\\n     * @return the amount of shares owned by `_account`.\\n     */\\n    function sharesOf(address _account) public view returns (uint256) {\\n        return _sharesOf(_account);\\n    }\\n\\n    /**\\n     * @return the amount of shares that corresponds to `_VUSDAmount` protocol-supplied VUSD.\\n     */\\n    function getSharesByMintedVUSD(\\n        uint256 _VUSDAmount\\n    ) public view returns (uint256) {\\n        uint256 totalMintedVUSD = _getTotalMintedVUSD();\\n        if (totalMintedVUSD == 0) {\\n            return 0;\\n        } else {\\n            return _VUSDAmount.mul(_getTotalShares()).div(totalMintedVUSD);\\n        }\\n    }\\n\\n    /**\\n     * @return the amount of VUSD that corresponds to `_sharesAmount` token shares.\\n     */\\n    function getMintedVUSDByShares(\\n        uint256 _sharesAmount\\n    ) public view returns (uint256) {\\n        uint256 totalSharesAmount = _getTotalShares();\\n        if (totalShares == 0) {\\n            return 0;\\n        } else {\\n            return\\n                _sharesAmount.mul(_getTotalMintedVUSD()).div(totalSharesAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\\n     *\\n     * @return amount of transferred tokens.\\n     * Emits a `TransferShares` event.\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_recipient` cannot be the zero address.\\n     * - the caller must have at least `_sharesAmount` shares.\\n     * - the contract must not be paused.\\n     *\\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\\n     */\\n    function transferShares(\\n        address _recipient,\\n        uint256 _sharesAmount\\n    ) public returns (uint256) {\\n        _transferShares(msg.sender, _recipient, _sharesAmount);\\n        emit TransferShares(msg.sender, _recipient, _sharesAmount);\\n        uint256 tokensAmount = getMintedVUSDByShares(_sharesAmount);\\n        emit Transfer(msg.sender, _recipient, tokensAmount);\\n        return tokensAmount;\\n    }\\n\\n    /**\\n     * @return the total amount of VUSD.\\n     * @dev This is used for calculating tokens from shares and vice versa.\\n     * @dev This function is required to be implemented in a derived contract.\\n     */\\n    function _getTotalMintedVUSD() internal view virtual returns (uint256);\\n\\n    /**\\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\\n     * Emits a `Transfer` event.\\n     * Emits a `TransferShares` event.\\n     */\\n    function _transfer(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) internal {\\n        uint256 _sharesToTransfer = getSharesByMintedVUSD(_amount);\\n        _transferShares(_sender, _recipient, _sharesToTransfer);\\n        emit Transfer(_sender, _recipient, _amount);\\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\\n    }\\n\\n    /**\\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `_owner` cannot be the zero address.\\n     * - `_spender` cannot be the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    ) internal {\\n        require(_owner != address(0), \\\"APPROVE_FROM_ZERO_ADDRESS\\\");\\n        require(_spender != address(0), \\\"APPROVE_TO_ZERO_ADDRESS\\\");\\n\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /**\\n     * @return the total amount of shares in existence.\\n     */\\n    function _getTotalShares() internal view returns (uint256) {\\n        return totalShares;\\n    }\\n\\n    /**\\n     * @return the amount of shares owned by `_account`.\\n     */\\n    function _sharesOf(address _account) internal view returns (uint256) {\\n        return shares[_account];\\n    }\\n\\n    /**\\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\\n     *\\n     * Requirements:\\n     *\\n     * - `_sender` cannot be the zero address.\\n     * - `_recipient` cannot be the zero address.\\n     * - `_sender` must hold at least `_sharesAmount` shares.\\n     * - the contract must not be paused.\\n     */\\n    function _transferShares(\\n        address _sender,\\n        address _recipient,\\n        uint256 _sharesAmount\\n    ) internal {\\n        require(_sender != address(0), \\\"TRANSFER_FROM_THE_ZERO_ADDRESS\\\");\\n        require(_recipient != address(0), \\\"TRANSFER_TO_THE_ZERO_ADDRESS\\\");\\n\\n        uint256 currentSenderShares = shares[_sender];\\n        require(\\n            _sharesAmount <= currentSenderShares,\\n            \\\"TRANSFER_AMOUNT_EXCEEDS_BALANCE\\\"\\n        );\\n\\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\n    }\\n\\n    /**\\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\\n     * @dev This doesn't increase the token total supply.\\n     *\\n     * Requirements:\\n     *\\n     * - `_recipient` cannot be the zero address.\\n     * - the contract must not be paused.\\n     */\\n    function _mintShares(\\n        address _recipient,\\n        uint256 _sharesAmount\\n    ) internal returns (uint256 newTotalShares) {\\n        require(_recipient != address(0), \\\"MINT_TO_THE_ZERO_ADDRESS\\\");\\n\\n        newTotalShares = _getTotalShares().add(_sharesAmount);\\n        totalShares = newTotalShares;\\n\\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\\n\\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\\n        // works by taking the amount of tokens corresponding to the minted shares from all other\\n        // token holders, proportionally to their share. The total supply of the token doesn't change\\n        // as the result. This is equivalent to performing a send from each other token holder's\\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\\n        // number of events.\\n    }\\n\\n    /**\\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\\n     * @dev This doesn't decrease the token total supply.\\n     *\\n     * Requirements:\\n     *\\n     * - `_account` cannot be the zero address.\\n     * - `_account` must hold at least `_sharesAmount` shares.\\n     * - the contract must not be paused.\\n     */\\n    function _burnShares(\\n        address _account,\\n        uint256 _sharesAmount\\n    ) internal returns (uint256 newTotalShares) {\\n        require(_account != address(0), \\\"BURN_FROM_THE_ZERO_ADDRESS\\\");\\n\\n        uint256 accountShares = shares[_account];\\n        require(_sharesAmount <= accountShares, \\\"BURN_AMOUNT_EXCEEDS_BALANCE\\\");\\n\\n        uint256 preRebaseTokenAmount = getMintedVUSDByShares(_sharesAmount);\\n\\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\\n        totalShares = newTotalShares;\\n\\n        shares[_account] = accountShares.sub(_sharesAmount);\\n\\n        uint256 postRebaseTokenAmount = getMintedVUSDByShares(_sharesAmount);\\n\\n        emit SharesBurnt(\\n            _account,\\n            preRebaseTokenAmount,\\n            postRebaseTokenAmount,\\n            _sharesAmount\\n        );\\n\\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\\n        // works by redistributing the amount of tokens corresponding to the burned shares between\\n        // all other token holders. The total supply of the token doesn't change as the result.\\n        // This is equivalent to performing a send from `address` to each other token holder address,\\n        // but we cannot reflect this as it would require sending an unbounded number of events.\\n\\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\\n    }\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/VibraniumrvUSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./RVUSD.sol\\\";\\nimport \\\"./Governable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\nimport \\\"./Ireth.sol\\\";\\nimport \\\"./VibStakingPool.sol\\\";\\nimport \\\"./esVIBMinter.sol\\\";\\nimport \\\"./ISwap.sol\\\";\\n\\ncontract VibraniumrvUSD is RVUSD, Governable {\\n    uint256 public totalDepositedEther;\\n    uint256 public lastReportTime;\\n    uint256 public totalRVUSDCirculation;\\n    uint256 year = 86400 * 365;\\n\\n    uint256 public mintFeeApy = 150;\\n    uint256 public safeCollateralRate = 160 * 1e18;\\n    uint256 public immutable badCollateralRate = 140 * 1e18;\\n    uint256 public redemptionFee = 50;\\n    uint8 public keeperRate = 1;\\n\\n    mapping(address => uint256) public depositedEther;\\n    mapping(address => uint256) borrowed;\\n    mapping(address => bool) redemptionProvider;\\n    uint256 public feeStored;\\n\\n    bool public initializer;\\n\\n    Ireth reth;\\n    AggregatorV3Interface internal priceFeed;\\n    esVIBMinter public esvibMinter;\\n    VibStakingPool public serviceFeePool;\\n    address public vUSD;\\n\\n    event DepositEther(\\n        address sponsor,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n    event WithdrawEther(\\n        address sponsor,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n    event Mint(\\n        address sponsor,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n    event Burn(\\n        address sponsor,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n    event LiquidationRecord(\\n        address provider,\\n        address keeper,\\n        address indexed onBehalfOf,\\n        uint256 rvusdamount,\\n        uint256 LiquidateEtherAmount,\\n        uint256 keeperReward,\\n        bool superLiquidation,\\n        uint256 timestamp\\n    );\\n    event LSDistribution(\\n        uint256 rETHAdded,\\n        uint256 payoutRVUSD,\\n        uint256 timestamp\\n    );\\n    \\n    event RedemptionProvider(address user, bool status);\\n    event RigidRedemption(\\n        address indexed caller,\\n        address indexed provider,\\n        uint256 rvusdAmount,\\n        uint256 etherAmount,\\n        uint256 timestamp\\n    );\\n    event FeeDistribution(\\n        address indexed feeAddress,\\n        uint256 feeAmount,\\n        uint256 timestamp\\n    );\\n\\n    constructor(address _reth, address _priceFeed) {\\n        gov = msg.sender;\\n        reth = Ireth(_reth);\\n        priceFeed = AggregatorV3Interface(_priceFeed);\\n    }\\n\\n    function initialize(address _vUSD) public {\\n        require(!initializer);\\n        vUSD = _vUSD;\\n        initializer = true;\\n    } \\n    function setBorrowApy(uint256 newApy) external onlyGov {\\n        require(newApy <= 150, \\\"Borrow APY > 1.5%\\\");\\n        _saveReport();\\n        mintFeeApy = newApy;\\n    }\\n\\n    /**\\n     * @notice  safeCollateralRate can be decided by DAO,starts at 160%\\n     */\\n    function setSafeCollateralRate(uint256 newRatio) external onlyGov {\\n        require(\\n            newRatio >= 160 * 1e18,\\n            \\\"Safe CollateralRate > 160%\\\"\\n        );\\n        safeCollateralRate = newRatio;\\n    }\\n\\n    /**\\n     * @notice KeeperRate can be decided by DAO,1 means 1% of revenue\\n     */\\n    function setKeeperRate(uint8 newRate) external onlyGov {\\n        require(newRate <= 5, \\\"Max Keeper reward is 5%\\\");\\n        keeperRate = newRate;\\n    }\\n\\n    /**\\n     * @notice DAO sets RedemptionFee, 100 means 1%\\n     */\\n    function setRedemptionFee(uint8 newFee) external onlyGov {\\n        require(newFee <= 500, \\\"Max Redemption Fee is 5%\\\");\\n        redemptionFee = newFee;\\n    }\\n\\n    function setVibStakingPool(address addr) external onlyGov {\\n        serviceFeePool = VibStakingPool(addr);\\n    }\\n\\n    function setESVIBMinter(address addr) external onlyGov {\\n        esvibMinter = esVIBMinter(addr);\\n    }\\n\\n     /**\\n     * @notice User chooses to become a Redemption Provider\\n     */\\n    function becomeRedemptionProvider(bool _bool) external {\\n        esvibMinter.refreshReward(msg.sender);\\n        redemptionProvider[msg.sender] = _bool;\\n        emit RedemptionProvider(msg.sender, _bool);\\n    }\\n    /**\\n     * @notice Deposit rETH on behalf of an address, update the interest distribution and deposit record the this address, can mint RVUSD directly\\n     * Emits a `DepositEther` event.\\n     *\\n     * Requirements:\\n     * - `onBehalfOf` cannot be the zero address.\\n     * - `rETHamount` Must be higher than 0.\\n     * - `mintAmount` Send 0 if doesn't mint RVUSD\\n     * @dev Record the deposited rETH in the ratio of 1:1.\\n     */\\n    function depositrETHToMint(\\n        address onBehalfOf,\\n        uint256 rETHamount,\\n        uint256 mintAmount\\n    ) external {\\n        require(onBehalfOf != address(0) && rETHamount >= 1 * 1e17, \\\"INPUT_WRONG\\\");\\n        reth.transferFrom(msg.sender, address(this), rETHamount);\\n\\n        totalDepositedEther += rETHamount;\\n        depositedEther[onBehalfOf] += rETHamount;\\n        if (mintAmount > 0) {\\n            _mintRVUSD(onBehalfOf, onBehalfOf, mintAmount);\\n        }\\n        emit DepositEther(msg.sender, onBehalfOf, rETHamount, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Withdraw collateral assets to an address\\n     * Emits a `WithdrawEther` event.\\n     *\\n     * Requirements:\\n     * - `onBehalfOf` cannot be the zero address.\\n     * - `amount` Must be higher than 0.\\n     *\\n     * @dev Withdraw rETH. Check user\u2019s collateral rate after withdrawal, should be higher than `safeCollateralRate`\\n     */\\n    function withdraw(address onBehalfOf, uint256 amount) external {\\n        require(onBehalfOf != address(0) && amount > 0 && depositedEther[msg.sender] >= amount, \\\"INPUT_WRONG\\\");\\n        totalDepositedEther -= amount;\\n        depositedEther[msg.sender] -= amount;\\n\\n        reth.transfer(onBehalfOf, amount);\\n        if (borrowed[msg.sender] > 0) {\\n            _checkHealth(msg.sender);\\n        }\\n        emit WithdrawEther(msg.sender, onBehalfOf, amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice The mint amount number of RVUSD is minted to the address\\n     * Emits a `Mint` event.\\n     *\\n     * Requirements:\\n     * - `onBehalfOf` cannot be the zero address.\\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\\n     */\\n    function mint(address onBehalfOf, uint256 amount) public {\\n        require(onBehalfOf != address(0) && amount > 0 , \\\"INPUT_WRONG\\\");\\n        _mintRVUSD(msg.sender, onBehalfOf, amount);\\n        if (\\n            (borrowed[msg.sender] * 100) / totalSupply() > 10 &&\\n            totalSupply() > 10_000_000 * 1e18\\n        ) revert(\\\"Mint Amount > 10% of total circulation\\\");\\n    }\\n\\n    /**\\n     * @notice Burn the amount of RVUSD and payback the amount of minted RVUSD\\n     * Emits a `Burn` event.\\n     * Requirements:\\n     * - `onBehalfOf` cannot be the zero address.\\n     * - `amount` Must be higher than 0.\\n     * @dev Calling the internal`_repay`function.\\n     */\\n    function burn(address onBehalfOf, uint256 amount) external {\\n        require(onBehalfOf != address(0), \\\"BURN_ZERO_ADDRESS\\\");\\n        _repay(msg.sender, onBehalfOf, amount);\\n    }\\n\\n    /**\\n     * @notice When overallCollateralRate is above 150%, Keeper liquidates borrowers whose collateral rate is below badCollateralRate, using RVUSD provided by Liquidation Provider.\\n     *\\n     * Requirements:\\n     * - onBehalfOf Collateral Rate should be below badCollateralRate\\n     * - etherAmount should be less than 50% of collateral\\n     * - provider should authorize Vibranium to utilize RVUSD\\n     * @dev After liquidation, borrower's debt is reduced by etherAmount * etherPrice, collateral is reduced by the etherAmount corresponding to 110% of the value. Keeper gets keeperRate / 110 of Liquidation Reward and Liquidator gets the remaining rETH.\\n     */\\n    function liquidation(\\n        address provider,\\n        address onBehalfOf,\\n        uint256 etherAmount\\n    ) external {\\n        uint256 etherPrice = _etherPrice();\\n        uint256 onBehalfOfCollateralRate = (depositedEther[onBehalfOf] *\\n            etherPrice *\\n            100) / borrowed[onBehalfOf];\\n        require(\\n            onBehalfOfCollateralRate < badCollateralRate,\\n            \\\"Borrowers collateral rate should below badCollateralRate\\\"\\n        );\\n\\n        require(\\n            etherAmount * 2 <= depositedEther[onBehalfOf],\\n            \\\"a max of 50% collateral can be liquidated\\\"\\n        );\\n        uint256 rvusdAmount = (etherAmount * etherPrice) / 1e18;\\n\\n        _repay(provider, onBehalfOf, rvusdAmount);\\n        uint256 reducedEther = (etherAmount * 11) / 10;\\n        totalDepositedEther -= reducedEther;\\n        depositedEther[onBehalfOf] -= reducedEther;\\n        uint256 reward2keeper;\\n        if (provider == msg.sender) {\\n            reth.transfer(msg.sender, reducedEther);\\n        } else {\\n            reward2keeper = (reducedEther * keeperRate) / 110;\\n            reth.transfer(provider, reducedEther - reward2keeper);\\n            reth.transfer(msg.sender, reward2keeper);\\n        }\\n        emit LiquidationRecord(\\n            provider,\\n            msg.sender,\\n            onBehalfOf,\\n            rvusdAmount,\\n            reducedEther,\\n            reward2keeper,\\n            false,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @notice When overallCollateralRate is below badCollateralRate, borrowers with collateralRate below 125% could be fully liquidated.\\n     * Emits a `LiquidationRecord` event.\\n     *\\n     * Requirements:\\n     * - Current overallCollateralRate should be below badCollateralRate\\n     * - `onBehalfOf`collateralRate should be below 125%\\n     * @dev After Liquidation, borrower's debt is reduced by etherAmount * etherPrice, deposit is reduced by etherAmount * borrower's collateralRate. Keeper gets a liquidation reward of `keeperRate / borrower's collateralRate\\n     */\\n    function superLiquidation(\\n        address provider,\\n        address onBehalfOf,\\n        uint256 etherAmount\\n    ) external {\\n        uint256 etherPrice = _etherPrice();\\n        require(\\n            (totalDepositedEther * etherPrice * 100) / totalSupply() <\\n                badCollateralRate,\\n            \\\"overallCollateralRate > 150%\\\"\\n        );\\n        uint256 onBehalfOfCollateralRate = (depositedEther[onBehalfOf] *\\n            etherPrice *\\n            100) / borrowed[onBehalfOf];\\n        require(\\n            onBehalfOfCollateralRate < 125 * 1e18,\\n            \\\"borrowers collateralRate > 125%\\\"\\n        );\\n        require(\\n            etherAmount <= depositedEther[onBehalfOf],\\n            \\\"total of collateral can be liquidated at most\\\"\\n        );\\n        uint256 rvusdAmount = (etherAmount * etherPrice) / 1e18;\\n        if (onBehalfOfCollateralRate >= 1e20) {\\n            rvusdAmount = (rvusdAmount * 1e20) / onBehalfOfCollateralRate;\\n        }\\n        require(\\n            allowance(provider, address(this)) >= rvusdAmount,\\n            \\\"provider should authorize to provide liquidation RVUSD\\\"\\n        );\\n\\n        _repay(provider, onBehalfOf, rvusdAmount);\\n\\n        totalDepositedEther -= etherAmount;\\n        depositedEther[onBehalfOf] -= etherAmount;\\n        uint256 reward2keeper;\\n        if (\\n            msg.sender != provider &&\\n            onBehalfOfCollateralRate >= 1e20 + keeperRate * 1e18\\n        ) {\\n            reward2keeper =\\n                ((etherAmount * keeperRate) * 1e18) /\\n                onBehalfOfCollateralRate;\\n            reth.transfer(msg.sender, reward2keeper);\\n        }\\n        reth.transfer(provider, etherAmount - reward2keeper);\\n\\n        emit LiquidationRecord(\\n            provider,\\n            msg.sender,\\n            onBehalfOf,\\n            rvusdAmount,\\n            etherAmount,\\n            reward2keeper,\\n            true,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @notice When rETH balance increases through LSD or other reasons, the excess income is sold for RVUSD, allocated to RVUSD holders through rebase mechanism.\\n     * Emits a `LSDistribution` event.\\n     *\\n     * *Requirements:\\n     * - rETH balance in the contract cannot be less than totalDepositedEther after exchange.\\n     * @dev Income is used to cover accumulated Service Fee first.\\n     */\\n    function excessIncomeDistribution(uint256 payAmount) external {\\n        uint256 payoutEther = (payAmount * 1e18) / _etherPrice();\\n        require(\\n            payoutEther <=\\n                reth.balanceOf(address(this)) - totalDepositedEther &&\\n                payoutEther > 0,\\n            \\\"Only LSD excess income can be exchanged\\\"\\n        );\\n\\n        uint256 income = feeStored + _newFee();\\n\\n        if (payAmount > income) {\\n            _transfer(msg.sender, address(serviceFeePool), income);\\n            serviceFeePool.notifyRewardAmount(income);\\n\\n            uint256 sharesAmount = getSharesByMintedVUSD(payAmount - income);\\n            if (sharesAmount == 0) {\\n                //RVUSD totalSupply is 0: assume that shares correspond to RVUSD 1-to-1\\n                sharesAmount = payAmount - income;\\n            }\\n            //Income is distributed to VIB staker.\\n            _burnShares(msg.sender, sharesAmount);\\n            feeStored = 0;\\n            emit FeeDistribution(\\n                address(serviceFeePool),\\n                income,\\n                block.timestamp\\n            );\\n        } else {\\n            _transfer(msg.sender, address(serviceFeePool), payAmount);\\n            serviceFeePool.notifyRewardAmount(payAmount);\\n            feeStored = income - payAmount;\\n            emit FeeDistribution(\\n                address(serviceFeePool),\\n                payAmount,\\n                block.timestamp\\n            );\\n        }\\n\\n        lastReportTime = block.timestamp;\\n        reth.transfer(msg.sender, payoutEther);\\n\\n        emit LSDistribution(payoutEther, payAmount, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Choose a Redemption Provider, Rigid Redeem `rvusdAmount` of RVUSD and get 1:1 value of rETH\\n     * Emits a `RigidRedemption` event.\\n     *\\n     * *Requirements:\\n     * - `provider` must be a Redemption Provider\\n     * - `provider`debt must equal to or above`rvusdAmount`\\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\\n     */\\n    function rigidRedemption(address provider, uint256 rvusdAmount) external {\\n        uint256 etherPrice = _etherPrice();\\n        uint256 providerCollateralRate = (depositedEther[provider] *\\n            etherPrice *\\n            100) / borrowed[provider];\\n        require(\\n            !redemptionProvider[provider] && borrowed[provider] >= rvusdAmount && providerCollateralRate >= 100 * 1e18,\\n            \\\"provider's collateral rate should more than 100%\\\"\\n        );\\n        _repay(msg.sender, provider, rvusdAmount);\\n        uint256 etherAmount = (((rvusdAmount * 1e18) / etherPrice) *\\n            (10000 - redemptionFee)) / 10000;\\n        depositedEther[provider] -= etherAmount;\\n        totalDepositedEther -= etherAmount;\\n        reth.transfer(msg.sender, etherAmount);\\n        emit RigidRedemption(\\n            msg.sender,\\n            provider,\\n            rvusdAmount,\\n            etherAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Refresh VIB reward before adding providers debt. Refresh Vibranium generated service fee before adding totalRVUSDCirculation. Check providers collateralRate cannot below `safeCollateralRate`after minting.\\n     */\\n    function _mintRVUSD(\\n        address _provider,\\n        address _onBehalfOf,\\n        uint256 _amount\\n    ) internal {\\n        uint256 sharesAmount = getSharesByMintedVUSD(_amount);\\n        if (sharesAmount == 0) {\\n            //RVUSD totalSupply is 0: assume that shares correspond to RVUSD 1-to-1\\n            sharesAmount = _amount;\\n        }\\n        esvibMinter.refreshReward(_provider);\\n        borrowed[_provider] += _amount;\\n\\n        _mintShares(_onBehalfOf, sharesAmount);\\n\\n        _saveReport();\\n        totalRVUSDCirculation += _amount;\\n        _checkHealth(_provider);\\n        emit Mint(msg.sender, _onBehalfOf, _amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Burn _provideramount RVUSD to payback minted RVUSD for _onBehalfOf.\\n     *\\n     * @dev Refresh VIB reward before reducing providers debt. Refresh Vibranium generated service fee before reducing totalRVUSDCirculation.\\n     */\\n    function _repay(\\n        address _provider,\\n        address _onBehalfOf,\\n        uint256 _amount\\n    ) internal {\\n        require(\\n            borrowed[_onBehalfOf] >= _amount,\\n            \\\"Repaying Amount Surpasses Borrowing Amount\\\"\\n        );\\n\\n        uint256 sharesAmount = getSharesByMintedVUSD(_amount);\\n        _burnShares(_provider, sharesAmount);\\n\\n        esvibMinter.refreshReward(_onBehalfOf);\\n\\n        borrowed[_onBehalfOf] -= _amount;\\n        _saveReport();\\n        totalRVUSDCirculation -= _amount;\\n\\n        emit Burn(_provider, _onBehalfOf, _amount, block.timestamp);\\n    }\\n\\n    function _saveReport() internal {\\n        feeStored += _newFee();\\n        lastReportTime = block.timestamp;\\n    }\\n\\n    function mintSwap(address _account, uint _amount) external {\\n        require(msg.sender == vUSD, \\\"INPUT_WRONG\\\");\\n        uint256 sharesAmount = getSharesByMintedVUSD(_amount);\\n        if (sharesAmount == 0) {\\n            //VUSD totalSupply is 0: assume that shares correspond to VUSD 1-to-1\\n            sharesAmount = _amount;\\n        }\\n        esvibMinter.refreshReward(_account);\\n        _mintShares(_account, sharesAmount);\\n        _saveReport();\\n        totalRVUSDCirculation += _amount;\\n    }\\n\\n    function swap(uint _amount) external{\\n        uint256 sharesAmount = getSharesByMintedVUSD(_amount);\\n        _burnShares(msg.sender, sharesAmount);\\n        esvibMinter.refreshReward(msg.sender);\\n        _saveReport();\\n        totalRVUSDCirculation -= _amount;\\n        ISwap(vUSD).mintSwap(msg.sender, _amount);\\n        emit Burn(msg.sender, msg.sender, _amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Get USD value of current collateral asset and minted RVUSD through price oracle / Collateral asset USD value must higher than safe Collateral Rate.\\n     */\\n    function _checkHealth(address user) internal {\\n        if (\\n            ((depositedEther[user] * _etherPrice() * 100) / borrowed[user]) <\\n            safeCollateralRate\\n        ) revert(\\\"collateralRate is Below safeCollateralRate\\\");\\n    }\\n\\n    /**\\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\\n     * https://etherscan.io/address/0x4c517D4e2C851CA76d7eC94B805269Df0f2201De#code\\n     */\\n    function _etherPrice() internal returns (uint256) {\\n         // prettier-ignore\\n        (\\n            /* uint80 roundID */,\\n            int price,\\n            /*uint startedAt*/,\\n            /*uint timeStamp*/,\\n            /*uint80 answeredInRound*/\\n        ) = priceFeed.latestRoundData();\\n        // return uint256(price) * 1e10;\\n        return (uint256(price) * reth.getExchangeRate() * 1e10) / 1e18;\\n    }\\n\\n    function _newFee() internal view returns (uint256) {\\n        return\\n            (totalRVUSDCirculation *\\n                mintFeeApy *\\n                (block.timestamp - lastReportTime)) /\\n            year /\\n            10000;\\n    }\\n\\n    /**\\n     * @dev total circulation of RVUSD\\n     */\\n    function _getTotalMintedVUSD() internal view override returns (uint256) {\\n        return totalRVUSDCirculation;\\n    }\\n\\n    function getBorrowedOf(address user) external view returns (uint256) {\\n        return borrowed[user];\\n    }\\n\\n    function isRedemptionProvider(address user) external view returns (bool) {\\n        return redemptionProvider[user];\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/VibStakingPool.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n\\ninterface VibStakingPool {\\n    function notifyRewardAmount(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FeeDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rETHAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payoutRVUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LSDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rvusdamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LiquidateEtherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keeperReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"superLiquidation\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LiquidationRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RedemptionProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rvusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RigidRedemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"preRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"SharesBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesValue\",\"type\":\"uint256\"}],\"name\":\"TransferShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"badCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"becomeRedemptionProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rETHamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"depositrETHToMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"esvibMinter\",\"outputs\":[{\"internalType\":\"contract esVIBMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"excessIncomeDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBorrowedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"getMintedVUSDByShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_VUSDAmount\",\"type\":\"uint256\"}],\"name\":\"getSharesByMintedVUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vUSD\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isRedemptionProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastReportTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"liquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFeeApy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rvusdAmount\",\"type\":\"uint256\"}],\"name\":\"rigidRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFeePool\",\"outputs\":[{\"internalType\":\"contract VibStakingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newApy\",\"type\":\"uint256\"}],\"name\":\"setBorrowApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setESVIBMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newRate\",\"type\":\"uint8\"}],\"name\":\"setKeeperRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFee\",\"type\":\"uint8\"}],\"name\":\"setRedemptionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRatio\",\"type\":\"uint256\"}],\"name\":\"setSafeCollateralRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVibStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"superLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositedEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRVUSDCirculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VibraniumrvUSD", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ae78736cd615f374d3085123a210448e74fc63930000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}