{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ArchipelagoMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./ITraitOracle.sol\\\";\\nimport \\\"./IRoyaltyOracle.sol\\\";\\nimport \\\"./IWeth.sol\\\";\\nimport \\\"./MarketMessages.sol\\\";\\nimport \\\"./SignatureChecker.sol\\\";\\n\\ncontract ArchipelagoMarket is Ownable {\\n    using MarketMessages for Ask;\\n    using MarketMessages for Bid;\\n    using MarketMessages for OrderAgreement;\\n\\n    event NonceCancellation(address indexed participant, uint256 indexed nonce);\\n\\n    event BidApproval(\\n        address indexed participant,\\n        bytes32 indexed bidHash,\\n        bool approved,\\n        Bid bid\\n    );\\n    event AskApproval(\\n        address indexed participant,\\n        bytes32 indexed askHash,\\n        bool approved,\\n        Ask ask\\n    );\\n\\n    event Trade(\\n        bytes32 indexed tradeId,\\n        address indexed buyer,\\n        address indexed seller,\\n        uint256 price,\\n        uint256 proceeds,\\n        uint256 cost,\\n        IERC20 currency\\n    );\\n    /// Emitted in one-to-one correspondence with `Trade` events. This is a\\n    /// separate event just so that we can index more fields.\\n    event TokenTrade(\\n        bytes32 indexed tradeId,\\n        IERC721 indexed tokenAddress,\\n        uint256 indexed tokenId\\n    );\\n\\n    event RoyaltyPayment(\\n        bytes32 indexed tradeId,\\n        address indexed payer,\\n        address indexed recipient,\\n        uint256 micros,\\n        uint256 amount,\\n        IERC20 currency\\n    );\\n\\n    mapping(address => mapping(uint256 => bool)) public nonceCancelled;\\n\\n    /// `onChainApproval[address][structHash]` is `true` if `address` has\\n    /// provided on-chain approval of a message with hash `structHash`.\\n    ///\\n    /// These approvals are not bounded by a domain separator; the contract\\n    /// storage itself is the signing domain.\\n    mapping(address => mapping(bytes32 => bool)) public onChainApproval;\\n\\n    /// Whether the market is in emergencyShutdown mode (in which case, no trades\\n    /// can be made).\\n    bool public emergencyShutdown;\\n\\n    /// Address of the Archipelago protocol treasury (to which hardcoded\\n    /// royalties accrue)\\n    address public archipelagoRoyaltyAddress;\\n\\n    /// Royalty rate that accrues to the Archipelago protocol treasury\\n    /// (expressed as millionths of each transaction value)\\n    uint256 public archipelagoRoyaltyMicros;\\n\\n    /// Hardcap the Archipelago royalty rate at 50 basis points.\\n    /// Prevents \\\"rug\\\" attacks where the contract owner unexpectedly\\n    /// spikes the royalty rate, abusing existing asks. Also, it's a nice\\n    /// commitment to our users.\\n    uint256 constant MAX_ARCHIPELAGO_ROYALTY_MICROS = 5000;\\n\\n    uint256 constant ONE_MILLION = 1000000;\\n\\n    string constant ORDER_CANCELLED_OR_EXPIRED =\\n        \\\"Market: order cancelled or expired\\\";\\n\\n    string constant AGREEMENT_MISMATCH =\\n        \\\"Market: bid/ask agreement hash doesn't match order agreement\\\";\\n\\n    string constant TRANSFER_FAILED = \\\"Market: transfer failed\\\";\\n\\n    bytes32 constant TYPEHASH_DOMAIN_SEPARATOR =\\n        keccak256(\\n            \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// Needs to be present so that the WETH contract can send ETH here for\\n    /// automatic unwrapping on behalf of sellers. No-one else should send\\n    /// ETH to this contract.\\n    receive() external payable {}\\n\\n    /// Shut down the market. Should be used if a critical security\\n    /// flaw is discovered.\\n    function setEmergencyShutdown(bool isShutdown) external onlyOwner {\\n        emergencyShutdown = isShutdown;\\n    }\\n\\n    function setArchipelagoRoyaltyAddress(address newRoyaltyAddress)\\n        external\\n        onlyOwner\\n    {\\n        archipelagoRoyaltyAddress = newRoyaltyAddress;\\n    }\\n\\n    function setArchipelagoRoyaltyMicros(uint256 newRoyaltyMicros)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            newRoyaltyMicros <= MAX_ARCHIPELAGO_ROYALTY_MICROS,\\n            \\\"Market: protocol royalty too high\\\"\\n        );\\n        archipelagoRoyaltyMicros = newRoyaltyMicros;\\n    }\\n\\n    function computeDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_DOMAIN_SEPARATOR,\\n                    keccak256(\\\"ArchipelagoMarket\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function verify(\\n        bytes32 domainSeparator,\\n        bytes32 structHash,\\n        bytes memory signature,\\n        SignatureKind signatureKind\\n    ) internal view returns (address) {\\n        if (signatureKind != SignatureKind.EXTERNAL) {\\n            return\\n                SignatureChecker.recover(\\n                    domainSeparator,\\n                    structHash,\\n                    signature,\\n                    signatureKind\\n                );\\n        }\\n        address signer = abi.decode(signature, (address));\\n        require(\\n            signer == msg.sender || onChainApproval[signer][structHash],\\n            \\\"Market: on-chain approval missing\\\"\\n        );\\n        return signer;\\n    }\\n\\n    function setOnChainBidApproval(Bid memory bid, bool approved) external {\\n        bytes32 hash = bid.structHash();\\n        onChainApproval[msg.sender][hash] = approved;\\n        emit BidApproval(msg.sender, hash, approved, bid);\\n    }\\n\\n    function setOnChainAskApproval(Ask memory ask, bool approved) external {\\n        bytes32 hash = ask.structHash();\\n        onChainApproval[msg.sender][hash] = approved;\\n        emit AskApproval(msg.sender, hash, approved, ask);\\n    }\\n\\n    /// Computes the EIP-712 struct hash of the given bid. The resulting hash\\n    /// can be passed to `onChainApproval(address, bytes32)` to check whether\\n    /// a given account has signed this bid.\\n    function bidHash(Bid memory bid) external pure returns (bytes32) {\\n        return bid.structHash();\\n    }\\n\\n    /// Computes the EIP-712 struct hash of the given ask. The resulting hash\\n    /// can be passed to `onChainApproval(address, bytes32)` to check whether\\n    /// a given account has signed this ask.\\n    function askHash(Ask memory ask) external pure returns (bytes32) {\\n        return ask.structHash();\\n    }\\n\\n    /// Computes the EIP-712 struct hash of the parts of an order that must be\\n    /// shared between a bid and an ask. The resulting hash should appear as\\n    /// the `agreementHash` field of both the `Bid` and the `Ask` structs.\\n    function orderAgreementHash(OrderAgreement memory agreement)\\n        external\\n        pure\\n        returns (bytes32)\\n    {\\n        return agreement.structHash();\\n    }\\n\\n    function cancelNonces(uint256[] calldata nonces) external {\\n        for (uint256 i; i < nonces.length; i++) {\\n            uint256 nonce = nonces[i];\\n            nonceCancelled[msg.sender][nonce] = true;\\n            emit NonceCancellation(msg.sender, nonce);\\n        }\\n    }\\n\\n    function _verifyOrder(\\n        OrderAgreement memory agreement,\\n        Bid memory bid,\\n        bytes memory bidSignature,\\n        SignatureKind bidSignatureKind,\\n        Ask memory ask,\\n        bytes memory askSignature,\\n        SignatureKind askSignatureKind\\n    ) internal view returns (address bidder, address asker) {\\n        bytes32 agreementHash = agreement.structHash();\\n        require(bid.agreementHash == agreementHash, AGREEMENT_MISMATCH);\\n        require(ask.agreementHash == agreementHash, AGREEMENT_MISMATCH);\\n\\n        bytes32 domainSeparator = computeDomainSeparator();\\n        bidder = verify(\\n            domainSeparator,\\n            bid.structHash(),\\n            bidSignature,\\n            bidSignatureKind\\n        );\\n        asker = verify(\\n            domainSeparator,\\n            ask.structHash(),\\n            askSignature,\\n            askSignatureKind\\n        );\\n    }\\n\\n    function fillOrder(\\n        OrderAgreement memory agreement,\\n        Bid memory bid,\\n        bytes memory bidSignature,\\n        SignatureKind bidSignatureKind,\\n        Ask memory ask,\\n        bytes memory askSignature,\\n        SignatureKind askSignatureKind\\n    ) external {\\n        (address bidder, address asker) = _verifyOrder(\\n            agreement,\\n            bid,\\n            bidSignature,\\n            bidSignatureKind,\\n            ask,\\n            askSignature,\\n            askSignatureKind\\n        );\\n        _fillOrder(agreement, bid, bidder, ask, asker);\\n    }\\n\\n    /// Variant of fill order where the buyer pays in ETH (which is converted to\\n    /// WETH under the hood). Added as a convenience. Code is mostly a repeat of\\n    /// fillOrder, since we need to get the bidder from the signature, and then\\n    /// convert the paid ETH to WETH.\\n    ///\\n    /// We don't know exactly how much the order will cost the bidder upfront\\n    /// (we'd need to calculate royalties). So instead, the bidder just provides\\n    /// any amount of ETH they want, which will be added to their WETH balance\\n    /// before attempting to fill the transaction. If they haven't sent enough,\\n    /// the tx will fail; if they sent extra, they wil have a remaining WETH\\n    /// balance afterwards, which we assume was their intent (maybe they have\\n    /// other bids outstanding).\\n    function fillOrderEth(\\n        OrderAgreement memory agreement,\\n        Bid memory bid,\\n        bytes memory bidSignature,\\n        SignatureKind bidSignatureKind,\\n        Ask memory ask,\\n        bytes memory askSignature,\\n        SignatureKind askSignatureKind\\n    ) external payable {\\n        (address bidder, address asker) = _verifyOrder(\\n            agreement,\\n            bid,\\n            bidSignature,\\n            bidSignatureKind,\\n            ask,\\n            askSignature,\\n            askSignatureKind\\n        );\\n        require(msg.sender == bidder, \\\"Market: only bidder may fill with ETH\\\");\\n        IWeth currency = IWeth(address(agreement.currencyAddress));\\n        currency.deposit{value: msg.value}();\\n        require(currency.transfer(bidder, msg.value), TRANSFER_FAILED);\\n        _fillOrder(agreement, bid, bidder, ask, asker);\\n    }\\n\\n    function _fillOrder(\\n        OrderAgreement memory agreement,\\n        Bid memory bid,\\n        address bidder,\\n        Ask memory ask,\\n        address asker\\n    ) internal {\\n        require(!emergencyShutdown, \\\"Market: shut down\\\");\\n\\n        IERC721 token = agreement.tokenAddress;\\n        uint256 price = agreement.price;\\n        IERC20 currency = agreement.currencyAddress;\\n\\n        uint256 tokenId = ask.tokenId;\\n\\n        require(\\n            ask.authorizedBidder == address(0) ||\\n                ask.authorizedBidder == bidder,\\n            \\\"Market: bidder is not authorized\\\"\\n        );\\n\\n        require(block.timestamp <= bid.deadline, ORDER_CANCELLED_OR_EXPIRED);\\n        require(block.timestamp <= ask.deadline, ORDER_CANCELLED_OR_EXPIRED);\\n\\n        require(!nonceCancelled[bidder][bid.nonce], ORDER_CANCELLED_OR_EXPIRED);\\n        require(!nonceCancelled[asker][ask.nonce], ORDER_CANCELLED_OR_EXPIRED);\\n\\n        // Bids and asks are cancelled on execution, to prevent replays. Cancel\\n        // upfront so that external calls (`transferFrom`, `safeTransferFrom`,\\n        // the ERC-721 receive hook) only observe the cancelled state.\\n        nonceCancelled[bidder][bid.nonce] = true;\\n        nonceCancelled[asker][ask.nonce] = true;\\n        emit NonceCancellation(bidder, bid.nonce);\\n        emit NonceCancellation(asker, ask.nonce);\\n\\n        bytes32 tradeId = keccak256(\\n            abi.encode(bidder, bid.nonce, asker, ask.nonce)\\n        );\\n        // amount paid to seller, after subtracting asker royalties\\n        uint256 proceeds = price;\\n        // amount spent by the buyer, after including bidder royalties\\n        uint256 cost = price;\\n\\n        if (address(bid.traitOracle) == address(0)) {\\n            uint256 expectedTokenId = uint256(bytes32(bid.trait));\\n            require(expectedTokenId == tokenId, \\\"Market: token ID mismatch\\\");\\n        } else {\\n            require(\\n                bid.traitOracle.hasTrait(token, tokenId, bid.trait),\\n                \\\"Market: missing trait\\\"\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < agreement.requiredRoyalties.length; i++) {\\n            proceeds -= _payRoyalty(\\n                agreement.requiredRoyalties[i],\\n                bidder,\\n                asker,\\n                price,\\n                tradeId,\\n                currency,\\n                token,\\n                tokenId\\n            );\\n        }\\n        // Note that the extra royalties on the ask is basically duplicated\\n        // from the required royalties. If you make a change to one code path,\\n        // you should also change the other.\\n        // We're support \\\"extra\\\" asker royalties so that the seller can reward\\n        // an agent, broker, or advisor, as appropriate.\\n        for (uint256 i = 0; i < ask.extraRoyalties.length; i++) {\\n            proceeds -= _payRoyalty(\\n                ask.extraRoyalties[i],\\n                bidder,\\n                asker,\\n                price,\\n                tradeId,\\n                currency,\\n                token,\\n                tokenId\\n            );\\n        }\\n\\n        // Finally, we pay the hardcoded protocol royalty. It also comes from\\n        // the asker, so it's in the same style as the required royalties and\\n        // asker's extra royalties.\\n        if (archipelagoRoyaltyAddress != address(0)) {\\n            uint256 amt = (archipelagoRoyaltyMicros * price) / 1000000;\\n            proceeds -= amt;\\n            require(\\n                currency.transferFrom(bidder, archipelagoRoyaltyAddress, amt),\\n                TRANSFER_FAILED\\n            );\\n            emit RoyaltyPayment(\\n                tradeId,\\n                asker,\\n                archipelagoRoyaltyAddress,\\n                archipelagoRoyaltyMicros,\\n                amt,\\n                currency\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < bid.extraRoyalties.length; i++) {\\n            // Now we handle bid extra royalties.\\n            // This time we are increasing the cost (not decreasing the\\n            // proceeds) and the RoyaltyPayment event will specify the bidder\\n            // as the entity paying the royalty.\\n            cost += _payRoyalty(\\n                bid.extraRoyalties[i],\\n                bidder,\\n                bidder,\\n                price,\\n                tradeId,\\n                currency,\\n                token,\\n                tokenId\\n            );\\n        }\\n\\n        bool ownerOrApproved;\\n        address tokenOwner = token.ownerOf(tokenId);\\n        if (tokenOwner == asker) {\\n            ownerOrApproved = true;\\n        } else if (token.getApproved(tokenId) == asker) {\\n            ownerOrApproved = true;\\n        } else if (token.isApprovedForAll(tokenOwner, asker)) {\\n            ownerOrApproved = true;\\n        }\\n        require(ownerOrApproved, \\\"Market: asker is not owner or approved\\\");\\n        token.safeTransferFrom(tokenOwner, bidder, tokenId);\\n        if (ask.unwrapWeth) {\\n            require(\\n                currency.transferFrom(bidder, address(this), proceeds),\\n                TRANSFER_FAILED\\n            );\\n            IWeth(address(currency)).withdraw(proceeds);\\n            // Note: This invokes the asker's fallback function. Be careful of\\n            // re-entrancy attacks. We deliberately invalidate the bid and ask\\n            // nonces before this point, to prevent replay attacks.\\n            payable(asker).transfer(proceeds);\\n        } else {\\n            require(\\n                currency.transferFrom(bidder, asker, proceeds),\\n                TRANSFER_FAILED\\n            );\\n        }\\n\\n        emit Trade(tradeId, bidder, asker, price, proceeds, cost, currency);\\n        emit TokenTrade(tradeId, token, tokenId);\\n    }\\n\\n    function _computeRoyalty(\\n        bytes32 royalty,\\n        IERC721 tokenContract,\\n        uint256 tokenId\\n    ) internal view returns (RoyaltyResult[] memory) {\\n        address target = address(bytes20(royalty));\\n        uint32 micros = uint32(uint256(royalty));\\n        uint32 staticBit = 1 << 31;\\n        bool isStatic = (micros & (staticBit)) != 0;\\n        micros &= ~staticBit;\\n        if (isStatic) {\\n            RoyaltyResult[] memory results = new RoyaltyResult[](1);\\n            results[0].micros = micros;\\n            results[0].recipient = target;\\n            return results;\\n        } else {\\n            uint64 data = uint64(uint256(royalty) >> 32);\\n            RoyaltyResult[] memory results = IRoyaltyOracle(target).royalties(\\n                tokenContract,\\n                tokenId,\\n                micros,\\n                data\\n            );\\n            uint256 totalMicros = 0;\\n            for (uint256 i = 0; i < results.length; i++) {\\n                totalMicros += results[i].micros;\\n            }\\n            require(\\n                totalMicros <= micros,\\n                \\\"Market: oracle would overspend royalty allotment\\\"\\n            );\\n            return results;\\n        }\\n    }\\n\\n    function _payComputedRoyalties(\\n        RoyaltyResult[] memory results,\\n        address bidder,\\n        // `logicalPayer` is either the bidder or the asker, depending on who\\n        // semantically is bearing the cost of this royalty. In all cases, the\\n        // funds will actually be transferred from the bidder; this only\\n        // affects the emitted event.\\n        address logicalPayer,\\n        uint256 price,\\n        bytes32 tradeId,\\n        IERC20 currency\\n    ) internal returns (uint256) {\\n        uint256 totalAmount;\\n        for (uint256 i = 0; i < results.length; i++) {\\n            RoyaltyResult memory result = results[i];\\n            uint256 amt = (result.micros * price) / ONE_MILLION;\\n            totalAmount += amt;\\n            require(\\n                currency.transferFrom(bidder, result.recipient, amt),\\n                TRANSFER_FAILED\\n            );\\n            emit RoyaltyPayment(\\n                tradeId,\\n                logicalPayer,\\n                result.recipient,\\n                result.micros,\\n                amt,\\n                currency\\n            );\\n        }\\n        return totalAmount;\\n    }\\n\\n    function _payRoyalty(\\n        bytes32 royalty,\\n        address bidder,\\n        address logicalPayer,\\n        uint256 price,\\n        bytes32 tradeId,\\n        IERC20 currency,\\n        IERC721 tokenContract,\\n        uint256 tokenId\\n    ) internal returns (uint256) {\\n        RoyaltyResult[] memory results = _computeRoyalty(\\n            royalty,\\n            tokenContract,\\n            tokenId\\n        );\\n        return\\n            _payComputedRoyalties(\\n                results,\\n                bidder,\\n                logicalPayer,\\n                price,\\n                tradeId,\\n                currency\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITraitOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ITraitOracle {\\n    /// Queries whether the given ERC-721 token has the given trait.\\n    ///\\n    /// The interpretation of the trait bytestring may be domain-specific and\\n    /// is at the discretion of the trait oracle. For example, an oracle might\\n    /// choose to encode traits called \\\"Normal\\\" and \\\"Rare\\\" as `\\\"\\\\x00\\\"` and\\n    /// `\\\"\\\\x01\\\"` respectively, or as `bytes(keccak256(\\\"Normal\\\"))` and\\n    /// `bytes(keccak256(\\\"Rare\\\"))`, or as something else. The trait oracle may\\n    /// expose other domain-specific methods to describe these traits.\\n    function hasTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes calldata _trait\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/IRoyaltyOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IRoyaltyOracle {\\n    function royalties(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        uint32 _micros,\\n        uint64 _data\\n    ) external view returns (RoyaltyResult[] memory);\\n}\\n\\nstruct RoyaltyResult {\\n    address recipient;\\n    uint32 micros;\\n}\\n\"\r\n    },\r\n    \"contracts/IWeth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWeth is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/MarketMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"./ITraitOracle.sol\\\";\\n\\n/// On Royalty Representations\\n///\\n/// Royalties take two possible forms. There are \\\"static\\\" and \\\"dynamic\\\"\\n/// royalties.\\n///\\n/// Static royalties consist of a specific recipient address, and a uint32\\n/// number of micros of royalty payment. Each micro corresponds to one\\n/// millionth of the purchase price.\\n///\\n/// Dynamic royalties have a royalty oracle address, and a uint32 max number\\n/// of micros that the oracle may allocate. The dynamic royalty also includes\\n/// a uint64 of arbitrary data that may be passed to the royalty oracle.\\n///\\n/// Whether a royalty is static or dynamic is encoded in the most significant\\n/// bit of the royalty micros value. Thus, while micros are encoded as a\\n/// uint32, there are only actually 31 bits available. This only rules out\\n/// unreasonably massive royalty values (billions of micros, or 1000x the total\\n/// purchase price), so it's not a serious limitation in practice. The sdk\\n/// prohibits setting the most significant bit in royalty micros.\\n///\\n/// Representationally, each royalty is a bytes32 where the first 20 bytes are\\n/// the recipient or oracle address, the next 8 bytes are the royalty oracle\\n/// calldata, and the final 4 bytes are the micros value.\\n\\n/// Fields that a bid and ask must agree upon exactly for an order to be\\n/// filled.\\nstruct OrderAgreement {\\n    /// Address of the ERC-20 contract being used as payment currency\\n    /// (typically WETH).\\n    IERC20 currencyAddress;\\n    /// Order price, in units of the ERC-20 given by `currencyAddress`.\\n    uint256 price;\\n    /// Address of the ERC-721 whose tokens are being traded.\\n    IERC721 tokenAddress;\\n    /// Royalties paid by the seller. This typically includes a royalty to the\\n    /// artist and to platforms supporting the token or the order.\\n    ///\\n    /// This is separated from the extra royalties on the ask to prevent token\\n    /// holders from taking an open bid on the orderbook and filling it without\\n    /// the conventional seller royalties.\\n    bytes32[] requiredRoyalties;\\n}\\n\\nstruct Bid {\\n    /// EIP-712 struct hash of the parts of this order shared between the bid\\n    /// and the ask, as an `OrderAgreement` struct.\\n    bytes32 agreementHash;\\n    uint256 nonce;\\n    /// Timestamp past which this order is no longer valid.\\n    uint40 deadline;\\n    /// Extra royalties specified by the participant who created this order.\\n    /// If the extra royalties are added on an Ask, they will be paid by the\\n    /// seller; extra royalties on a Bid are paid by the buyer (i.e. on top of\\n    /// the listed sale price).\\n    bytes32[] extraRoyalties;\\n    /// This is either: an encoding of the trait data that will be passed to\\n    /// the trait oracle (if one is provided), or the raw token id for the token\\n    /// being bid on (if the traitOracle is address zero).\\n    bytes trait;\\n    /// The address of the trait oracle used to interpret the trait data.\\n    /// If this is the zero address, the trait must be a uint256 token ID.\\n    ITraitOracle traitOracle;\\n}\\n\\nstruct Ask {\\n    /// EIP-712 struct hash of the parts of this order shared between the bid\\n    /// and the ask, as an `OrderAgreement` struct.\\n    bytes32 agreementHash;\\n    uint256 nonce;\\n    /// Timestamp past which this order is no longer valid.\\n    uint40 deadline;\\n    /// Extra royalties specified by the participant who created this order.\\n    /// If the extra royalties are added on an Ask, they will be paid by the\\n    /// seller; extra royalties on a Bid are paid by the buyer (i.e. on top of\\n    /// the listed sale price).\\n    bytes32[] extraRoyalties;\\n    /// The token ID listed for sale, under the token contract given by\\n    /// `orderAgreement.tokenAddress`.\\n    uint256 tokenId;\\n    /// Whether the asker would like their WETH proceeds to be automatically\\n    /// unwrapped to ETH on order execution.\\n    /// Purely a convenience for people who prefer ETH to WETH.\\n    bool unwrapWeth;\\n    /// The address of the account that is allowed to fill this order.\\n    /// If this address is the zero address, then anyone's bid may match.\\n    /// If this address is nonzero, they are the only address allowed to match\\n    /// this ask.\\n    address authorizedBidder;\\n}\\n\\nlibrary MarketMessages {\\n    using MarketMessages for OrderAgreement;\\n    using MarketMessages for bytes32[];\\n\\n    bytes32 internal constant TYPEHASH_BID =\\n        keccak256(\\n            \\\"Bid(bytes32 agreementHash,uint256 nonce,uint40 deadline,bytes32[] extraRoyalties,bytes trait,address traitOracle)\\\"\\n        );\\n    bytes32 internal constant TYPEHASH_ASK =\\n        keccak256(\\n            \\\"Ask(bytes32 agreementHash,uint256 nonce,uint40 deadline,bytes32[] extraRoyalties,uint256 tokenId,bool unwrapWeth,address authorizedBidder)\\\"\\n        );\\n    bytes32 internal constant TYPEHASH_ORDER_AGREEMENT =\\n        keccak256(\\n            \\\"OrderAgreement(address currencyAddress,uint256 price,address tokenAddress,bytes32[] requiredRoyalties)\\\"\\n        );\\n\\n    function structHash(Bid memory _self) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_BID,\\n                    _self.agreementHash,\\n                    _self.nonce,\\n                    _self.deadline,\\n                    _self.extraRoyalties.structHash(),\\n                    keccak256(_self.trait),\\n                    _self.traitOracle\\n                )\\n            );\\n    }\\n\\n    function structHash(Ask memory _self) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_ASK,\\n                    _self.agreementHash,\\n                    _self.nonce,\\n                    _self.deadline,\\n                    _self.extraRoyalties.structHash(),\\n                    _self.tokenId,\\n                    _self.unwrapWeth,\\n                    _self.authorizedBidder\\n                )\\n            );\\n    }\\n\\n    function structHash(OrderAgreement memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_ORDER_AGREEMENT,\\n                    _self.currencyAddress,\\n                    _self.price,\\n                    _self.tokenAddress,\\n                    _self.requiredRoyalties.structHash()\\n                )\\n            );\\n    }\\n\\n    function structHash(bytes32[] memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(_self));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nenum SignatureKind {\\n    /// A message for which authorization is handled specially by the verifying\\n    /// contract. Signatures with this kind will always be rejected by\\n    /// `SignatureChecker.recover`; this enum variant exists to let callers\\n    /// handle other types of authorization, such as pre-authorization in\\n    /// contract storage or association with `msg.sender`.\\n    EXTERNAL,\\n    /// A message that starts with \\\"\\\\x19Ethereum Signed Message[...]\\\", as\\n    /// implemented by the `personal_sign` JSON-RPC method.\\n    ETHEREUM_SIGNED_MESSAGE,\\n    /// A message that starts with \\\"\\\\x19\\\\x01\\\" and follows the EIP-712 typed\\n    /// data specification.\\n    EIP_712\\n}\\n\\nlibrary SignatureChecker {\\n    function recover(\\n        bytes32 _domainSeparator,\\n        bytes32 _structHash,\\n        bytes memory _signature,\\n        SignatureKind _kind\\n    ) internal pure returns (address) {\\n        bytes32 _hash;\\n        if (_kind == SignatureKind.ETHEREUM_SIGNED_MESSAGE) {\\n            _hash = ECDSA.toEthSignedMessageHash(\\n                keccak256(abi.encode(_domainSeparator, _structHash))\\n            );\\n        } else if (_kind == SignatureKind.EIP_712) {\\n            _hash = ECDSA.toTypedDataHash(_domainSeparator, _structHash);\\n        } else {\\n            revert(\\\"SignatureChecker: no signature given\\\");\\n        }\\n        return ECDSA.recover(_hash, _signature);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"askHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"authorizedBidder\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct Ask\",\"name\":\"ask\",\"type\":\"tuple\"}],\"name\":\"AskApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bidHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"trait\",\"type\":\"bytes\"},{\"internalType\":\"contract ITraitOracle\",\"name\":\"traitOracle\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct Bid\",\"name\":\"bid\",\"type\":\"tuple\"}],\"name\":\"BidApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonceCancellation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tradeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"micros\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"RoyaltyPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tradeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract IERC721\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tradeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proceeds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"archipelagoRoyaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"archipelagoRoyaltyMicros\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"authorizedBidder\",\"type\":\"address\"}],\"internalType\":\"struct Ask\",\"name\":\"ask\",\"type\":\"tuple\"}],\"name\":\"askHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"trait\",\"type\":\"bytes\"},{\"internalType\":\"contract ITraitOracle\",\"name\":\"traitOracle\",\"type\":\"address\"}],\"internalType\":\"struct Bid\",\"name\":\"bid\",\"type\":\"tuple\"}],\"name\":\"bidHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"cancelNonces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredRoyalties\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OrderAgreement\",\"name\":\"agreement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"trait\",\"type\":\"bytes\"},{\"internalType\":\"contract ITraitOracle\",\"name\":\"traitOracle\",\"type\":\"address\"}],\"internalType\":\"struct Bid\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"bidSignature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"bidSignatureKind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"authorizedBidder\",\"type\":\"address\"}],\"internalType\":\"struct Ask\",\"name\":\"ask\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"askSignature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"askSignatureKind\",\"type\":\"uint8\"}],\"name\":\"fillOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredRoyalties\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OrderAgreement\",\"name\":\"agreement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"trait\",\"type\":\"bytes\"},{\"internalType\":\"contract ITraitOracle\",\"name\":\"traitOracle\",\"type\":\"address\"}],\"internalType\":\"struct Bid\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"bidSignature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"bidSignatureKind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"authorizedBidder\",\"type\":\"address\"}],\"internalType\":\"struct Ask\",\"name\":\"ask\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"askSignature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"askSignatureKind\",\"type\":\"uint8\"}],\"name\":\"fillOrderEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"onChainApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"currencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"requiredRoyalties\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OrderAgreement\",\"name\":\"agreement\",\"type\":\"tuple\"}],\"name\":\"orderAgreementHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRoyaltyAddress\",\"type\":\"address\"}],\"name\":\"setArchipelagoRoyaltyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRoyaltyMicros\",\"type\":\"uint256\"}],\"name\":\"setArchipelagoRoyaltyMicros\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isShutdown\",\"type\":\"bool\"}],\"name\":\"setEmergencyShutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapWeth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"authorizedBidder\",\"type\":\"address\"}],\"internalType\":\"struct Ask\",\"name\":\"ask\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setOnChainAskApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deadline\",\"type\":\"uint40\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraRoyalties\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"trait\",\"type\":\"bytes\"},{\"internalType\":\"contract ITraitOracle\",\"name\":\"traitOracle\",\"type\":\"address\"}],\"internalType\":\"struct Bid\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setOnChainBidApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ArchipelagoMarket", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}