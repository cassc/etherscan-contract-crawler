{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\ncontract INTIME {\r\n    using SafeMath for *;\r\n    \r\n    struct Player {\r\n        uint id;\r\n        uint referrer;\r\n        uint generation;\r\n        string name;\r\n        uint256 weight;\r\n        uint256 balance;\r\n        uint256 withdrawal;\r\n        uint256 referralBonus;\r\n        uint256 lastKeyBonus;\r\n        uint256 potBonus;\r\n        uint256 stakingBonus;\r\n        uint256 airdropBonus;\r\n    }\r\n    \r\n    mapping(address => Player) public players;\r\n    \r\n    // System\r\n    address public teamAddress;\r\n    uint256 public teamNamingIncome;\r\n    address public keyAddress;\r\n    address[] participantPool;\r\n    uint256 participantPoolStart;\r\n    uint256 participantPoolEnd;\r\n    address[] public participants;\r\n    uint256 public participantsLength;\r\n    address[] public winner;\r\n    uint256 public deadline;\r\n    uint256 keyPrice_min;\r\n    uint256 keyPrice_max;\r\n    uint256 public keyPrice;\r\n    uint256 public currentGeneration;\r\n    uint256 public currentKeyRound;\r\n    uint256 public duration;\r\n    uint256[] public durationPhaseArray;\r\n    uint256 public durationPhaseIndex;\r\n    uint256 public poolWeight;\r\n    uint256 public poolBalance;\r\n    uint256 public poolReward;\r\n    uint256 public poolWithdraw;\r\n    bool public airdropped;\r\n    bool public keyLocked;\r\n    uint256 public airdropWinTime;\r\n    uint256 public airdropBalance;\r\n    uint256 public airdroppedAmount;\r\n    uint256 public unitStake;\r\n    uint256 public potReserve;\r\n    \r\n    mapping(string => address) addressFromName;\r\n    \r\n    event Withdrawal(\r\n        address indexed _from,\r\n        uint256 _value\r\n    );\r\n    event Deposit(\r\n        address indexed _keyHolder,\r\n        uint256 _weight,\r\n        uint256 _keyPrice,\r\n        uint256 _deadline,\r\n        uint256 _durationPhaseIndex,\r\n        bool _phaseChanged,\r\n        uint256 _poolBalance,\r\n        uint256 _poolReward,\r\n        uint256 _poolWeight,\r\n        // If Airdrop\r\n        bool _airdropped,\r\n        uint256 _airdropBalance,\r\n        // If Trigger Reserve\r\n        bool _potReserveGive,\r\n        uint256 _potReserve\r\n    );\r\n    \r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    /**\r\n     * Constructor function\r\n     * \r\n     */\r\n    constructor (\r\n        address _teamAddress\r\n    ) public {\r\n        teamAddress = _teamAddress;\r\n        keyPrice_min = 1e14;       // in wei, 0.0001 eth\r\n        keyPrice_max = 15e15;      // in wei, 0.015 eth\r\n        keyPrice = keyPrice_min;   // in wei, 0.0001 eth\r\n        keyAddress = msg.sender;\r\n        durationPhaseArray = [1440, 720, 360, 180, 90, 60, 30];\r\n        durationPhaseIndex = 0;\r\n        duration = durationPhaseArray[durationPhaseIndex];\r\n        currentGeneration = 0;\r\n        resetGame();\r\n    }\r\n    \r\n    function resetGame() private {\r\n        uint256 residualBalance = 0;\r\n        if(currentGeneration != 0) {\r\n            // Distribute tokens\r\n            // Staking distribution => distributed on deposit\r\n            // Pool distribution => 20%\r\n            unitStake = 0;\r\n            // 75% for the winner;\r\n            players[keyAddress].balance += poolBalance / 5 * 75 / 100;\r\n            players[keyAddress].lastKeyBonus += poolBalance / 5 * 75 / 100;\r\n            // 15% for random participant\r\n            if(participantPoolEnd - participantPoolStart > 0) {\r\n                uint randParticipantIndex = rand(participantPoolStart + 1, participantPoolEnd);\r\n                players[participantPool[randParticipantIndex - 1]].balance += poolBalance / 5 * 15 / 100;\r\n                players[participantPool[randParticipantIndex - 1]].lastKeyBonus += poolBalance / 5 * 15 / 100;\r\n            } else {\r\n                players[keyAddress].balance += poolBalance / 5 * 15 / 100;\r\n                players[keyAddress].lastKeyBonus += poolBalance / 5 * 15 / 100;\r\n            }\r\n            // 10% and pot reserve for next round\r\n            residualBalance += poolBalance / 5 * 10 / 100 + potReserve;\r\n            winner.push(keyAddress);\r\n        }\r\n        airdropWinTime = now;\r\n        keyPrice = 1e15;\r\n        poolWeight = 0;\r\n        poolReward = 0;\r\n        potReserve = 0;\r\n        \r\n        // Reset duration and deadline\r\n        durationPhaseIndex = 0;\r\n        duration = durationPhaseArray[durationPhaseIndex];\r\n        deadline = now + duration * 1 minutes;\r\n        \r\n        poolBalance = residualBalance;\r\n        keyLocked = false;\r\n        currentKeyRound = 0;\r\n        currentGeneration ++;\r\n        keyAddress = teamAddress;\r\n        participantPoolStart = participantPool.length;\r\n        participantPoolEnd = participantPool.length;\r\n    }\r\n    \r\n    /**\r\n     * Unique address\r\n     *\r\n     */\r\n    function setName(string name) isHuman() payable public {\r\n        uint256 amount = msg.value;\r\n        require(amount >= 1e15);\r\n        require(addressFromName[name] == address(0));\r\n        players[teamAddress].balance += amount;\r\n        teamNamingIncome += amount;\r\n        players[msg.sender].name = name;\r\n        addressFromName[name] = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Fallback function\r\n     *\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract\r\n     */\r\n    function referralName (string name) isHuman() payable public {\r\n        if(addressFromName[name] != address(0) && addressFromName[name] != msg.sender && players[msg.sender].referrer == 0)\r\n            players[msg.sender].referrer = players[addressFromName[name]].id;\r\n        uint256 amount = msg.value;\r\n        deposit(amount);\r\n    }\r\n    function referralPay (uint referrer) isHuman() payable public {\r\n        if(referrer > participants.length)\r\n            referrer = 0;\r\n        if(players[msg.sender].id != referrer && players[msg.sender].referrer == 0)\r\n            players[msg.sender].referrer = referrer;\r\n        uint256 amount = msg.value;\r\n        deposit(amount);\r\n    }\r\n    function () isHuman() payable public {\r\n        uint256 amount = msg.value;\r\n        deposit(amount);\r\n    }\r\n    function depositVault (uint keyCount, uint referrer) isHuman() public {\r\n        require(keyLocked == false);\r\n        keyLocked = true;\r\n        // Buy key from current balance\r\n        uint256 amount = keyCount * keyPrice;\r\n        uint256 availableWithdrawal = players[msg.sender].balance - players[msg.sender].withdrawal;\r\n        require(amount <= availableWithdrawal);\r\n        require(amount > 0);\r\n        players[msg.sender].withdrawal += amount;\r\n        \r\n        if(referrer > participants.length)\r\n            referrer = 0;\r\n        if(players[msg.sender].id != referrer && players[msg.sender].referrer == 0)\r\n            players[msg.sender].referrer = referrer;\r\n        keyLocked = false;\r\n        deposit(amount);\r\n    }\r\n    function deposit(uint256 amount) private {\r\n        if(now >= deadline) resetGame();\r\n        require(keyLocked == false);\r\n        keyLocked = true;\r\n        \r\n        // Update pool balance\r\n\t\trequire(amount >= keyPrice, \"You have to buy at least one key.\");\r\n\t\tpoolBalance += amount;\r\n\t\t\r\n\t\tcurrentKeyRound ++;\r\n\t\tparticipantPool.push(msg.sender);\r\n\t\tparticipantPoolEnd = participantPool.length;\r\n\t\t// Update deadline if not last round\r\n\t\tif(durationPhaseIndex < 6) deadline = now + duration * 1 minutes;\r\n\t\t\r\n\t\t// Update key holder\r\n\t\tkeyAddress = msg.sender;\r\n\t\t\r\n\t\tif(players[msg.sender].generation == 0) {\r\n\t\t    participants.push(msg.sender);\r\n\t\t    participantsLength = participants.length;\r\n\t\t    players[msg.sender].id = participants.length;\r\n\t\t}\r\n\t\tif(players[msg.sender].generation != currentGeneration) {\r\n\t\t\tplayers[msg.sender].generation = currentGeneration;\r\n\t\t\tplayers[msg.sender].weight = 0;\r\n\t\t}\r\n\t\t// Handling stake distribution\r\n\t\tuint256 p_i = 0;\r\n\t\tuint256 deltaStake = 0;\r\n\t\taddress _addr;\r\n\t\t// 58% for staking\r\n\t\tif(poolWeight > 0) {\r\n\t\t    unitStake = amount * 58 / 100 / poolWeight;\r\n\t\t    for(p_i = 0; p_i < participants.length; p_i++) {\r\n\t\t        _addr = participants[p_i];\r\n\t\t        if(players[_addr].generation == currentGeneration) {\r\n\t\t            players[_addr].balance += players[_addr].weight * unitStake;\r\n\t\t            players[_addr].stakingBonus += players[_addr].weight * unitStake;\r\n\t\t        }\r\n\t\t    }\r\n\t\t}\r\n\t\t// 15% for referral\r\n\t\tif(players[msg.sender].referrer > 0) {\r\n\t\t    _addr = participants[players[msg.sender].referrer - 1];\r\n\t\t    players[_addr].balance += amount * 15 / 100;\r\n\t\t    players[_addr].referralBonus += amount * 15 / 100;\r\n\t\t} else {\r\n\t\t    if(poolWeight > 0) {\r\n\t\t        deltaStake = amount * 15 / 100 / poolWeight;\r\n\t\t        for(p_i = 0; p_i < participants.length; p_i++) {\r\n\t\t            _addr = participants[p_i];\r\n\t\t            if(players[_addr].generation == currentGeneration) {\r\n\t\t                players[_addr].balance += players[_addr].weight * deltaStake;\r\n\t\t                players[_addr].stakingBonus += players[_addr].weight * deltaStake;\r\n\t\t            }\r\n\t\t        }\r\n\t\t    } else {\r\n\t\t        players[teamAddress].balance += amount * 15 / 100;\r\n\t\t        players[teamAddress].stakingBonus += amount * 15 / 100;\r\n\t\t    }\r\n\t\t}\r\n\t\t// 4% for team\r\n\t\tunitStake += deltaStake;\r\n\t\tplayers[teamAddress].balance += amount * 4 / 100;\r\n\t\tplayers[teamAddress].stakingBonus += amount * 4 / 100;\r\n\t\t\r\n\t\tpoolReward += amount * 77 / 100;\r\n\t\t\r\n\t\tairdropBalance += amount * 2 / 100;\r\n\t\tairdropped = false;\r\n\t\tairdroppedAmount = 0;\r\n\t\tuint randNum = 0;\r\n\t\tif(amount >= 1e17 && amount < 1e18) {\r\n\t\t    // 0.1 ~ 1 eth, 1% chance\r\n\t\t    randNum = rand(1, 10000);\r\n\t\t    if(randNum <= 10) airdropped = true;\r\n\t\t} else if(amount >= 1e18 && amount < 1e19) {\r\n\t\t    // 1 eth ~ 10 eth, 10% chance\r\n\t\t    randNum = rand(1, 10000);\r\n\t\t    if(randNum <= 100) airdropped = true;\r\n\t\t} else if(amount >= 1e19) {\r\n\t\t    // greater than 1 eth, 5% chance\r\n\t\t    randNum = rand(1, 10000);\r\n\t\t    if(randNum <= 500) airdropped = true;\r\n\t\t}\r\n\t\tbool _phaseChanged = false;\r\n\t\tif(airdropped) {\r\n\t\t    \r\n\t\t    airdropWinTime = now;\r\n\t\t    players[msg.sender].balance += airdropBalance;\r\n            players[msg.sender].airdropBonus += airdropBalance;\r\n            poolReward += airdropBalance;\r\n            \r\n            airdroppedAmount = airdropBalance;\r\n            airdropBalance = 0;\r\n            if(durationPhaseIndex == 0 && airdropBalance >= 1e18) _phaseChanged = true;\r\n            else if(durationPhaseIndex == 1 && airdropBalance >= 2e18) _phaseChanged = true;\r\n            else if(durationPhaseIndex == 2 && airdropBalance >= 3e18) _phaseChanged = true;\r\n            else if(durationPhaseIndex == 3 && airdropBalance >= 5e18) _phaseChanged = true;\r\n            else if(durationPhaseIndex == 4 && airdropBalance >= 7e18) _phaseChanged = true;\r\n            else if(durationPhaseIndex == 5 && airdropBalance >= 1e19) _phaseChanged = true;\r\n            if(_phaseChanged) {\r\n                durationPhaseIndex ++;\r\n                duration = durationPhaseArray[durationPhaseIndex];\r\n                deadline = now + duration * 1 minutes;\r\n            }\r\n            \r\n\t\t}\r\n\t\t\r\n\t\t// Staking weight calculation\r\n\t\tuint256 weight = amount.mul(1e7).div(keyPrice);\r\n\t\tplayers[msg.sender].weight += weight;\r\n\t\tuint256 originalPoolSegment = poolWeight / ((5e5).mul(1e7));\r\n\t\tpoolWeight += weight;\r\n\t\tuint256 afterPoolSegment = poolWeight / ((5e5).mul(1e7));\r\n\t\t\r\n\t\t// Different Segment => giveout potReserve, every 1e5 keys\r\n\t\tpotReserve += amount * 1 / 100;\r\n\t\tbool _potReserveGive = false;\r\n\t\tuint256 _potReserve = potReserve;\r\n\t\tif(originalPoolSegment != afterPoolSegment) {\r\n\t\t    _potReserveGive = true;\r\n\t\t    players[msg.sender].balance += potReserve;\r\n\t\t    players[msg.sender].potBonus += potReserve;\r\n\t\t    poolReward += potReserve;\r\n\t\t    potReserve = 0;\r\n\t\t}\r\n\t\t\r\n\t\t// Grow key price\r\n\t\tif(keyPrice < keyPrice_max) {\r\n\t\t    keyPrice = keyPrice_max - (1e23 - poolBalance).mul(keyPrice_max - keyPrice_min).div(1e23);\r\n\t\t} else {\r\n\t\t    keyPrice = keyPrice_max;\r\n\t\t}\r\n\t\tkeyLocked = false;\r\n\t\temit Deposit(\r\n\t\t    msg.sender,\r\n\t\t    weight,\r\n\t\t    keyPrice,\r\n\t\t    deadline,\r\n\t\t    durationPhaseIndex,\r\n\t\t    _phaseChanged,\r\n\t\t    poolBalance,\r\n\t\t    poolReward,\r\n\t\t    poolWeight,\r\n\t\t    airdropped,\r\n\t\t    airdropBalance,\r\n\t\t    _potReserveGive,\r\n\t\t    _potReserve\r\n        );\r\n    }\r\n    uint256 nonce = 0;\r\n    function rand(uint min, uint max) private returns (uint){\r\n        nonce++;\r\n        return uint(keccak256(toBytes(nonce)))%(min+max)-min;\r\n    }\r\n    function toBytes(uint256 x) private pure returns (bytes b) {\r\n        b = new bytes(32);\r\n        assembly { mstore(add(b, 32), x) }\r\n    }\r\n    /**\r\n     * Withdraw the funds\r\n     */\r\n    function safeWithdrawal() isHuman() public {\r\n        uint256 availableWithdrawal = players[msg.sender].balance - players[msg.sender].withdrawal;\r\n        require(availableWithdrawal > 0);\r\n        require(keyLocked == false);\r\n        keyLocked = true;\r\n        poolWithdraw += availableWithdrawal;\r\n        players[msg.sender].withdrawal += availableWithdrawal;\r\n        msg.sender.transfer(availableWithdrawal);\r\n        keyLocked = false;\r\n        emit Withdrawal(msg.sender, availableWithdrawal);\r\n    }\r\n    function helpWithdrawal(address userAddress) isHuman() public {\r\n        // Will only be executed when user himself cannot withdraw and asks our team for help\r\n        require(msg.sender == teamAddress);\r\n        uint256 availableWithdrawal = players[userAddress].balance - players[userAddress].withdrawal;\r\n        require(availableWithdrawal > 0);\r\n        require(keyLocked == false);\r\n        keyLocked = true;\r\n        poolWithdraw += availableWithdrawal;\r\n        players[userAddress].withdrawal += availableWithdrawal;\r\n        // Service fee: 5%\r\n        players[teamAddress].balance += availableWithdrawal * 5 / 100;\r\n        // User get 95%\r\n        userAddress.transfer(availableWithdrawal * 95 / 100);\r\n        keyLocked = false;\r\n        emit Withdrawal(userAddress, availableWithdrawal);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"uint256\"}],\"name\":\"referralPay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdroppedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unitStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"durationPhaseIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"durationPhaseArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentKeyRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keyCount\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"uint256\"}],\"name\":\"depositVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamNamingIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"helpWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"uint256\"},{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"weight\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"withdrawal\",\"type\":\"uint256\"},{\"name\":\"referralBonus\",\"type\":\"uint256\"},{\"name\":\"lastKeyBonus\",\"type\":\"uint256\"},{\"name\":\"potBonus\",\"type\":\"uint256\"},{\"name\":\"stakingBonus\",\"type\":\"uint256\"},{\"name\":\"airdropBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropWinTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"referralName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_teamAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_keyHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_weight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_keyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_deadline\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_durationPhaseIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_phaseChanged\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_poolBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_poolReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_poolWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_airdropped\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_airdropBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_potReserveGive\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_potReserve\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"}]", "ContractName": "INTIME", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b15abd315e436616ffc1bdd042fe0114dea9279f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://fb13e3c4025a48bbfcdfdab6de83cc4c3585b7782cdabdc8c4cd5613f603ffc1"}