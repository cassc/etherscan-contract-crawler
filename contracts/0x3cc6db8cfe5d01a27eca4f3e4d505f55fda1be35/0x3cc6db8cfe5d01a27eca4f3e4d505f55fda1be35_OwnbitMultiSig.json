{"SourceCode": "pragma solidity >=0.8.0 <0.9.0;\r\n\r\n// This is the ETH/ERC20/NFT multisig contract for Ownbit.\r\n//\r\n// For 2-of-3 multisig, to authorize a spend, two signtures must be provided by 2 of the 3 owners.\r\n// To generate the message to be signed, provide the destination address and\r\n// spend amount (in wei) to the generateMessageToSign method.\r\n// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\r\n// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\r\n//\r\n// WARNING: The generated message is only valid until the next spend is executed.\r\n//          after that, a new message will need to be calculated.\r\n//\r\n//\r\n// Accident Protection MultiSig, rules:\r\n//\r\n// Participants must keep themselves active by submitting transactions. \r\n// Not submitting any transaction within 3,000,000 ETH blocks (roughly 416 days) will be treated as wallet lost (i.e. accident happened), \r\n// other participants can still spend the assets as along as: valid signing count >= Min(mininual required count, active owners).\r\n//\r\n// INFO: This contract is ERC20/ERC721/ERC1155 compatible.\r\n// This contract can both receive ETH, ERC20 and NFT (ERC721/ERC1155) tokens.\r\n// Last update time: 2023-06-04.\r\n// copyright@ownbit.io\r\n\r\ncontract OwnbitMultiSig {\r\n    \r\n  uint constant public MAX_OWNER_COUNT = 9;\r\n  uint constant public MAX_INACTIVE_TIME = 416 days; \r\n\r\n  // The N addresses which control the funds in this contract. The\r\n  // owners of M of these addresses will need to both sign a message\r\n  // allowing the funds in this contract to be spent.\r\n  mapping(address => uint256) private ownerActiveTimeMap; //uint256 is the active timestamp(in secs) of this owner\r\n  address[] private owners;\r\n  uint private required;\r\n\r\n  // The contract nonce is not accessible to the contract so we\r\n  // implement a nonce-like variable for replay protection.\r\n  uint256 private spendNonce = 0;\r\n  \r\n  // An event sent when funds are received.\r\n  event Funded(address from, uint value);\r\n  \r\n  // An event sent when an spendAny is executed.\r\n  event Spent(address to, uint value);\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n    require (ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required >= 1);\r\n    _;\r\n  }\r\n  \r\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n  /// @param _owners List of initial owners.\r\n  /// @param _required Number of required confirmations.\r\n  constructor(address[] memory _owners, uint _required) validRequirement(_owners.length, _required) {\r\n    for (uint i = 0; i < _owners.length; i++) {\r\n        //onwer should be distinct, and non-zero\r\n        if (ownerActiveTimeMap[_owners[i]] > 0 || _owners[i] == address(0x0)) {\r\n            revert();\r\n        }\r\n        ownerActiveTimeMap[_owners[i]] = block.timestamp;\r\n    }\r\n    owners = _owners;\r\n    required = _required;\r\n  }\r\n\r\n  // The fallback function for this contract.\r\n  fallback() external payable {\r\n    if (msg.value > 0) {\r\n        emit Funded(msg.sender, msg.value);\r\n    }\r\n  }\r\n  \r\n  // @dev Returns list of owners.\r\n  // @return List of owner addresses.\r\n  function getOwners() public view returns (address[] memory) {\r\n    return owners;\r\n  }\r\n    \r\n  function getSpendNonce() public view returns (uint256) {\r\n    return spendNonce;\r\n  }\r\n    \r\n  function getRequired() public view returns (uint) {\r\n    return required;\r\n  }\r\n  \r\n  //return the active timestamp of this owner\r\n  function getOwnerActiveTime(address addr) public view returns (uint256) {\r\n    return ownerActiveTimeMap[addr];\r\n  }\r\n\r\n  // Generates the message to sign given the output destination address and amount.\r\n  // includes this contract's address and a nonce for replay protection.\r\n  // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\r\n  function generateMessageToSign(address destination, uint256 value, bytes memory data) private view returns (bytes32) {\r\n    //the sequence must match generateMultiSigV3 in JS\r\n    bytes32 message = keccak256(abi.encodePacked(address(this), destination, value, data, spendNonce));\r\n    return message;\r\n  }\r\n  \r\n  function _messageToRecover(address destination, uint256 value, bytes memory data) private view returns (bytes32) {\r\n    bytes32 hashedUnsignedMessage = generateMessageToSign(destination, value, data);\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    return keccak256(abi.encodePacked(prefix, hashedUnsignedMessage));\r\n  }\r\n  \r\n  //destination can be a normal address or a contract address, such as ERC20 contract address.\r\n  //value is the wei transferred to the destination.\r\n  //data for transfer ether: 0x\r\n  //data for transfer erc20 example: 0xa9059cbb000000000000000000000000ac6342a7efb995d63cc91db49f6023e95873d25000000000000000000000000000000000000000000000000000000000000003e8\r\n  //data for transfer erc721 example: 0x42842e0e00000000000000000000000097b65ad59c8c96f2dd786751e6279a1a6d34a4810000000000000000000000006cb33e7179860d24635c66850f1f6a5d4f8eee6d0000000000000000000000000000000000000000000000000000000000042134\r\n  //data can contain any data to be executed. \r\n  function spend(address destination, uint256 value, uint8[] memory vs, bytes32[] memory rs, bytes32[] memory ss, bytes calldata data) external {\r\n    require(destination != address(this), \"Not allow sending to yourself\");\r\n    require(_validSignature(destination, value, vs, rs, ss, data), \"invalid signatures\");\r\n    spendNonce = spendNonce + 1;\r\n    //transfer tokens from this contract to the destination address\r\n    (bool sent,) = destination.call{value: value}(data);\r\n    if (sent) {\r\n        emit Spent(destination, value);\r\n    }\r\n  }\r\n  \r\n  //send a tx from the owner address to active the owner\r\n  //Allow the owner to transfer some ETH, although this is not necessary.\r\n  function active() external payable {\r\n    require(ownerActiveTimeMap[msg.sender] > 0, \"Not an owner\");\r\n    ownerActiveTimeMap[msg.sender] = block.timestamp;\r\n  }\r\n  \r\n  function getRequiredWithoutInactive() public view returns (uint) {\r\n    uint activeOwner = 0;  \r\n    for (uint i = 0; i < owners.length; i++) {\r\n        //if the owner is active\r\n        if (ownerActiveTimeMap[owners[i]] + MAX_INACTIVE_TIME >= block.timestamp) {\r\n            activeOwner++;\r\n        }\r\n    }\r\n    //active owners still equal or greater then required\r\n    if (activeOwner >= required) {\r\n        return required;\r\n    }\r\n    //active less than required, all active must sign\r\n    if (activeOwner >= 1) {\r\n        return activeOwner;\r\n    }\r\n    //at least one sign.\r\n    return 1;\r\n  }\r\n\r\n  // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...\r\n  // authorize a spend of this contract's funds to the given destination address.\r\n  function _validSignature(address destination, uint256 value, uint8[] memory vs, bytes32[] memory rs, bytes32[] memory ss, bytes memory data) private returns (bool) {\r\n    require(vs.length == rs.length);\r\n    require(rs.length == ss.length);\r\n    require(vs.length <= owners.length);\r\n    require(vs.length >= getRequiredWithoutInactive());\r\n    bytes32 message = _messageToRecover(destination, value, data);\r\n    address[] memory addrs = new address[](vs.length);\r\n    for (uint i = 0; i < vs.length; i++) {\r\n        //recover the address associated with the public key from elliptic curve signature or return zero on error \r\n        addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]);\r\n    }\r\n    require(_distinctOwners(addrs));\r\n    _updateActiveTime(addrs); //update addrs' active timestamp\r\n    \r\n    //check again, this is important to prevent inactive owners from stealing the money.\r\n    require(vs.length >= getRequiredWithoutInactive(), \"Active owners updated after the call, please call active() before calling spend.\");\r\n    \r\n    return true;\r\n  }\r\n  \r\n  // Confirm the addresses as distinct owners of this contract.\r\n  function _distinctOwners(address[] memory addrs) private view returns (bool) {\r\n    if (addrs.length > owners.length) {\r\n        return false;\r\n    }\r\n    for (uint i = 0; i < addrs.length; i++) {\r\n        //> 0 means one of the owner\r\n        if (ownerActiveTimeMap[addrs[i]] == 0) {\r\n            return false;\r\n        }\r\n        //address should be distinct\r\n        for (uint j = 0; j < i; j++) {\r\n            if (addrs[i] == addrs[j]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  //update the active block number for those owners\r\n  function _updateActiveTime(address[] memory addrs) private {\r\n    for (uint i = 0; i < addrs.length; i++) {\r\n        //only update active timestamp for owners\r\n        if (ownerActiveTimeMap[addrs[i]] > 0) {\r\n            ownerActiveTimeMap[addrs[i]] = block.timestamp;\r\n        }\r\n    }\r\n  }\r\n\r\n  //support ERC721 safeTransferFrom\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4) {\r\n      return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n  }\r\n\r\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4) {\r\n      return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_required\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Spent\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MAX_INACTIVE_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getOwnerActiveTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRequiredWithoutInactive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpendNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"vs\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ss\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"spend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnbitMultiSig", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000bc43e7d3d69f2352cf766b2fd386c985cc3c805f000000000000000000000000904536876e72560e2198f2414dc9123a675c8c99000000000000000000000000053bf03b46d92bc9ed00fe32ca1f1fe93fa5c202", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b7c21cbe7e6d41bdb7321d5469afdb5b32c40fd02772b2b5fbb5c2aebd34e83c"}