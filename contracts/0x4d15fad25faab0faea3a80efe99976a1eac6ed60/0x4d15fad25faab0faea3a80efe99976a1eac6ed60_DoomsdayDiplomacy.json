{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DoomsdayAlliance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"./interfaces/ISettlersAllied.sol\\\";\\nimport \\\"./interfaces/IBatcher.sol\\\";\\n\\ncontract DoomsdayAlliance{\\n    ISettlersAllied immutable settlers;\\n    IBatcher immutable batcher;\\n\\n    receive() external payable{\\n        if(\\n            msg.sender != address(settlers) &&\\n            msg.sender != address(batcher)\\n        ){\\n            payable(msg.sender).transfer(msg.value);\\n        }\\n    }\\n\\n    event Fund(address indexed _funder, uint value);\\n    event Contribute(address indexed _contributor, uint _tokenId);\\n    event Member(address indexed _member);\\n    event Leader(address indexed _leader, bool promoted);\\n\\n    string public name;\\n    string public symbol;\\n\\n    uint16 immutable age;\\n    mapping(address => bool) members;\\n    mapping(address => bool) leaders;\\n    address[] public memberList;\\n\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n\\n    uint public constant decimals = 18;\\n\\n    uint immutable settlementValue;\\n    bool winningTokenBurned;\\n    address acquired;\\n    address[] pricesSet;\\n    mapping(address => uint) acquisitionPrices;\\n\\n    function data() public view returns(\\n        uint _settlementValue,\\n        bool _winningTokenBurned,\\n        address _acquired,\\n        Contribution _contribution,\\n        uint _acquisitionPrice,\\n        uint16 _age\\n    ){\\n        return (\\n            settlementValue,\\n            winningTokenBurned,\\n            acquired,\\n            contribution,\\n            getAcquisitionPrice(),\\n            age\\n        );\\n    }\\n\\n    function memberData(address _address) public view returns (\\n        bool _member,\\n        bool _leader,\\n        uint _acquisitionPrice\\n    ){\\n        return (\\n            members[_address],\\n            leaders[_address],\\n            acquisitionPrices[_address]\\n        );\\n    }\\n\\n    enum Contribution{PRIVATE,FUNDING,SETTLEMENTS}\\n    Contribution immutable contribution;\\n\\n    constructor(address _settlers, address _batcher, uint _settlementValue, string memory _name, string memory _symbol, Contribution _contribution, uint16 _age , address _founder){\\n        settlers = ISettlersAllied(_settlers);\\n        batcher = IBatcher(_batcher);\\n        settlementValue = _settlementValue;\\n\\n        settlers.setApprovalForAll(_batcher,true);\\n\\n        name = _name;\\n        symbol = _symbol;\\n\\n        contribution = _contribution;\\n\\n        age = _age;\\n\\n        members[_founder] = true;\\n        leaders[_founder] = true;\\n        memberList.push(_founder);\\n\\n\\n        emit Member(_founder);\\n        emit Leader(_founder,true);\\n    }\\n\\n    function initialShares(address _founder, uint value) external{\\n        require(totalSupply == 0,\\\"has value\\\");\\n\\n        totalSupply = value;\\n        balanceOf[_founder] = value;\\n        emit Transfer(address(0),_founder,value);\\n\\n    }\\n\\n    modifier onlyLeader(){\\n        require(leaders[msg.sender],\\\"leader\\\");\\n        _;\\n    }\\n    modifier onlyMember(){\\n        require(members[msg.sender],\\\"member\\\");\\n        _;\\n    }\\n\\n    function requireGameOver(bool _isOver) internal view{\\n        (\\n            bool _itIsTheDawnOfANewAge,\\n            uint32 _firstSettlement,\\n            uint16 _age,\\n            uint80 _creatorEarnings,\\n            uint80 _relics,\\n            uint80 _supplies,\\n            address _creator,\\n            uint256 _blockNumber\\n        ) = settlers.currentState();\\n\\n        _firstSettlement;\\n        _creatorEarnings;\\n        _relics;\\n        _supplies;\\n        _creator;\\n        _blockNumber;\\n\\n        require(\\n            (!_itIsTheDawnOfANewAge && _age == age)\\n                != _isOver\\n            ,\\\"game over\\\");\\n    }\\n\\n    modifier notAcquired(){\\n        require(acquired == address(0),\\\"acquired\\\");\\n        _;\\n    }\\n\\n    modifier canContribute(bool _isSettlement){\\n        if(!members[msg.sender]){\\n            if(contribution == Contribution.PRIVATE){\\n                revert(\\\"private\\\");\\n            }else if(contribution == Contribution.FUNDING){\\n                require(!_isSettlement,\\\"contribution\\\");\\n            }\\n        }\\n        _;\\n    }\\n\\n\\n    function addMember(address _member) public onlyLeader{\\n        members[_member] = true;\\n        memberList.push(_member);\\n\\n        emit Member(_member);\\n    }\\n    function promoteMember(address _member, bool _promote) public onlyLeader{\\n        require(members[_member],\\\"member\\\");\\n        require(_member != msg.sender,\\\"self\\\");\\n        leaders[_member] = _promote;\\n\\n        emit Leader(_member,_promote);\\n    }\\n\\n    function getMintCost() internal view returns(uint80){\\n        (\\n            bytes32 _lastHash,\\n            uint32 _settled,\\n            uint32 _abandoned,\\n            uint32 _lastSettleBlock,\\n            uint32 _collapseBlock,\\n            uint80 _mintFee,\\n            uint256 _blockNumber\\n        ) = settlers.miningState();\\n\\n        _lastHash;\\n        _settled;\\n        _abandoned;\\n        _lastSettleBlock;\\n        _collapseBlock;\\n        _blockNumber;\\n\\n//        unchecked{\\n            return uint80((uint(_mintFee) + uint(0.01 ether)) * 115 / 100);\\n//        }\\n    }\\n\\n    function addSettlements(uint[] calldata _tokenIds) public canContribute(true) notAcquired {\\n//        unchecked{\\n            requireGameOver(false);\\n            uint _shareValue;\\n            if(settlementValue == 0){\\n                //get mint cost\\n                _shareValue = getMintCost() * _tokenIds.length;\\n            }else{\\n                _shareValue = settlementValue * _tokenIds.length;\\n            }\\n\\n            for(uint i = 0; i < _tokenIds.length; i++){\\n                settlers.transferFrom(msg.sender,address(this),_tokenIds[i]);\\n                emit Contribute(msg.sender,_tokenIds[i]);\\n            }\\n\\n            totalSupply += _shareValue;\\n            balanceOf[msg.sender] += _shareValue;\\n            emit Transfer(address(0),msg.sender,_shareValue);\\n//        }\\n    }\\n\\n    function fundAlliance() public payable canContribute(false) notAcquired{\\n//        unchecked{\\n            requireGameOver(false);\\n            totalSupply += msg.value;\\n            balanceOf[msg.sender] += msg.value;\\n\\n            emit Fund(msg.sender,msg.value);\\n            emit Transfer(address(0),msg.sender,msg.value);\\n//        }\\n    }\\n\\n//    function reinforce(uint32 _tokenId, bool[4] calldata _resources, uint _cost) external payable onlyMember{\\n//        if(msg.value > 0){\\n//            fundAlliance();\\n//        }\\n//        settlers.reinforce{value:_cost}(_tokenId,_resources);\\n//    }\\n    function multiTokenReinforce(uint32[] memory _tokenIds, uint80[4][] memory _currentLevels, uint80[4][] memory _extraLevels, uint8[] memory _highest, uint80 _baseCost, uint _cost) external payable onlyMember notAcquired{\\n        if(msg.value > 0){\\n            fundAlliance();\\n        }\\n        batcher.multiTokenReinforce{value:_cost}(_tokenIds, _currentLevels, _extraLevels, _highest, _baseCost);\\n    }\\n//    function multiLevelReinforce(uint32 _tokenId, uint80[4] memory _currentLevels, uint80[4] memory _extraLevels, uint80 _highest, uint80 _baseCost, uint _cost) external payable onlyMember notAcquired{\\n//        if(msg.value > 0){\\n//            fundAlliance();\\n//        }\\n//        batcher.multiLevelReinforce{value:_cost}(_tokenId, _currentLevels, _extraLevels, _highest, _baseCost);\\n//    }\\n\\n    function setAcquisitionPrice(uint _price) public onlyMember{\\n        require(_price > 0,\\\"zero\\\");\\n        if(acquisitionPrices[msg.sender] == 0){\\n            pricesSet.push(msg.sender);\\n        }\\n        acquisitionPrices[msg.sender] = _price;\\n    }\\n    function getAcquisitionPrice() internal view returns(uint){\\n//        unchecked{\\n            uint _max;\\n            for(uint i = 0; i < pricesSet.length; i++){\\n                uint _price = acquisitionPrices[pricesSet[i]];\\n                if(_price > _max){\\n                    _max = _price;\\n                }\\n            }\\n            return _max;\\n//        }\\n    }\\n\\n\\n    function acquire() notAcquired payable external{\\n//        unchecked{\\n            requireGameOver(false);\\n            require(pricesSet.length > 0,\\\"no price\\\");\\n            require(msg.value == getAcquisitionPrice(),\\\"msg.value\\\");\\n            acquired = msg.sender;\\n\\n            (\\n                bool _itIsTheDawnOfANewAge,\\n                uint32 _firstSettlement,\\n                uint16 _age,\\n                uint80 _creatorEarnings,\\n                uint80 _relics,\\n                uint80 _supplies,\\n                address _creator,\\n                uint256 _blockNumber\\n            ) = settlers.currentState();\\n\\n            _itIsTheDawnOfANewAge;\\n            _firstSettlement;\\n            _age;\\n            _creatorEarnings;\\n            _relics;\\n            _supplies;\\n            _blockNumber;\\n\\n\\n            payable(_creator).transfer(msg.value * 5 / 100);\\n\\n//        }\\n    }\\n    function removeTokens(uint[] calldata _tokenIds) public{\\n//        unchecked{\\n            require(msg.sender == acquired,\\\"sender\\\");\\n            for(uint i = 0; i < _tokenIds.length; i++){\\n                settlers.transferFrom(\\n                    address(this),\\n                    msg.sender,\\n                    _tokenIds[i]\\n                );\\n            }\\n//        }\\n    }\\n\\n    function abandonWinningToken(uint32 _tokenId,uint32 _data) public onlyMember notAcquired{\\n        (\\n            uint32 _settleBlock,\\n            uint24 supplyAtMint,\\n            uint16 _age,\\n            uint8 settlementType,\\n            uint80 relics,\\n            uint80 supplies\\n        ) = settlers.settlements(_tokenId);\\n\\n        _settleBlock;\\n        supplyAtMint;\\n        _age;\\n        settlementType;\\n\\n        require (supplies > 0 || relics > 0,\\\"victory\\\");\\n\\n\\n        uint32[] memory _tokenIds = new uint32[](   1   );\\n        _tokenIds[0] = _tokenId;\\n\\n        settlers.abandon(_tokenIds,_data);\\n    }\\n\\n    function cashOut() public {\\n//        unchecked{\\n            if(acquired == address(0)){\\n                requireGameOver(true);\\n            }\\n\\n            uint _balanceOf = balanceOf[msg.sender];\\n            require(_balanceOf > 0,\\\"share count\\\");\\n\\n            uint _payout = address(this).balance * _balanceOf / totalSupply;\\n\\n            delete balanceOf[msg.sender];\\n            totalSupply -= _balanceOf;\\n\\n    //        if(_payout > address(this).balance){\\n    //            _payout = address(this).balance;\\n    //        }\\n\\n            emit Transfer(msg.sender,address(0),_payout);\\n            payable(msg.sender).transfer(_payout);\\n\\n//        }\\n    }\\n\\n    function confirmDisaster(uint32 _tokenId, uint32 _data) public onlyMember notAcquired{\\n        settlers.confirmDisaster(_tokenId,_data);\\n        try settlers.ownerOf(_tokenId) returns (address _owner){\\n            //Still alive\\n            _owner;\\n            payable(msg.sender).transfer(0.008 ether);\\n        }catch{\\n            //Destroyed\\n            payable(msg.sender).transfer(0.01 ether);\\n        }\\n    }\\n\\n\\n    // ERC20\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    function transfer(address _to, uint256 _value) public returns (bool success){\\n        _transferFrom(msg.sender,_to,_value);\\n        return true;\\n    }\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\\n        require(msg.sender == _from || allowance[_from][msg.sender] >= _value,\\\"permission\\\");\\n        if(_from != msg.sender){\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n        _transferFrom(_from,_to,_value);\\n        return true;\\n    }\\n    function _transferFrom(address _from, address _to, uint256 _value) private{\\n        require(balanceOf[_from] >= _value,\\\"balance\\\");\\n        require(_to != address(0),\\\"zero\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from,_to,_value);\\n    }\\n    function approve(address _spender, uint256 _value) public returns (bool success){\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/DoomsdayDiplomacy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"./DoomsdayAlliance.sol\\\";\\nimport \\\"./interfaces/ISettlersAllied.sol\\\";\\n\\ncontract DoomsdayDiplomacy{\\n\\n\\n    address immutable settlers;\\n    address immutable batcher;\\n    constructor(address _settlers, address _batcher){\\n        settlers = _settlers;\\n        batcher = _batcher;\\n    }\\n\\n    address[] public alliances;\\n\\n    event CreateAlliance(string name, string symbol, uint settlementValue, address _address, address indexed creator, uint16 _age);\\n\\n    function getAge() internal view returns(uint16){\\n        unchecked{\\n            (\\n            bool _itIsTheDawnOfANewAge,\\n            uint32 _firstSettlement,\\n            uint16 _age,\\n            uint80 _creatorEarnings,\\n            uint80 _relics,\\n            uint80 _supplies,\\n            address _creator,\\n            uint256 _blockNumber\\n            ) = ISettlersAllied(settlers).currentState();\\n\\n            _itIsTheDawnOfANewAge;\\n            _firstSettlement;\\n            _creatorEarnings;\\n            _relics;\\n            _supplies;\\n            _creator;\\n            _blockNumber;\\n\\n            return _age;\\n        }\\n    }\\n\\n    function createAlliance(uint _settlementValue, string memory _name, string memory _symbol, DoomsdayAlliance.Contribution _contribution) public returns(address){\\n\\n        unchecked{\\n            require(keccak256(abi.encodePacked(_symbol))!=0x217fc9d4f07e3d0aaca833f6b7fc7bb8775a7042e43311edb5c9cc9cf369629d,\\\"symbol\\\");\\n\\n            uint gasBefore = gasleft();\\n\\n            uint16 _age = getAge();\\n            DoomsdayAlliance alliance = new DoomsdayAlliance(settlers,batcher,_settlementValue,_name,_symbol,_contribution,_age, msg.sender);\\n            alliance.initialShares( msg.sender,(gasBefore - gasleft()) * tx.gasprice );\\n\\n            emit CreateAlliance(_name, _symbol, _settlementValue,address(alliance),msg.sender,_age);\\n\\n            alliances.push(address(alliance));\\n\\n            return address(alliance);\\n        }\\n\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\ninterface IBatcher {\\n    //    function isDarkAge() external view returns(bool);\\n//\\n//    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n    function multiTokenReinforce(uint32[] memory _tokenIds, uint80[4][] memory _currentLevels, uint80[4][] memory _extraLevels, uint8[] memory _highest, uint80 _baseCost) external payable;\\n    function multiLevelReinforce(uint32 _tokenId, uint80[4] memory _currentLevels, uint80[4] memory _extraLevels, uint80 _highest, uint80 _baseCost) external payable;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISettlersAllied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.21;\\n\\ninterface ISettlersAllied {\\n//    function isDarkAge() external view returns(bool);\\n\\n    function reinforce(uint32 _tokenId, bool[4] memory _resources) external payable;\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    function miningState() external view returns(bytes32 _lastHash, uint32 _settled, uint32 _abandoned, uint32 _lastSettleBlock, uint32 _collapseBlock, uint80 _mintFee, uint256 _blockNumber);\\n    function currentState() external view returns(bool _itIsTheDawnOfANewAge, uint32 _firstSettlement, uint16 _age, uint80 _creatorEarnings, uint80 _relics, uint80 _supplies, address _creator, uint256 _blockNumber);\\n\\n//    struct Settlement{\\n//        uint32 settleBlock;\\n//        uint24 supplyAtMint;\\n//        uint16 age;\\n//        uint8 settlementType;\\n//        uint80 relics;\\n//        uint80 supplies;\\n//    }\\n    function settlements(uint32 _tokenId) external view returns(\\n        uint32 settleBlock,\\n        uint24 supplyAtMint,\\n        uint16 age,\\n        uint8 settlementType,\\n        uint80 relics,\\n        uint80 supplies\\n    );\\n\\n    function abandon(uint32[] calldata _tokenIds, uint32 _data) external;\\n    function confirmDisaster(uint32 _tokenId, uint32 _data) external;\\n\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settlers\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_batcher\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settlementValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_age\",\"type\":\"uint16\"}],\"name\":\"CreateAlliance\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"alliances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_settlementValue\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"enum DoomsdayAlliance.Contribution\",\"name\":\"_contribution\",\"type\":\"uint8\"}],\"name\":\"createAlliance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DoomsdayDiplomacy", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000028f670c8d3edca52db147b694030d4cf80ddcd7b000000000000000000000000e357f175dd6804fd245547f477397cc811a363b7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}