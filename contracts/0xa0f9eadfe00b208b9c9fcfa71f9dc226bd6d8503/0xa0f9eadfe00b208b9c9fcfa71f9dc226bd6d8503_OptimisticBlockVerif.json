{"SourceCode": "// Sources flattened with hardhat v2.19.0 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: AML\r\n\r\n// File contracts/block/optimistic/OptimisticBlockVerifier4.sol\r\n\r\n// Original license: SPDX_License_Identifier: AML\r\n// \r\n// Copyright 2017 Christian Reitwiessner\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n// IN THE SOFTWARE.\r\n\r\n// 2019 OKIMS\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Pairing {\r\n\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct G1Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n\r\n    // Encoding of field elements is: X[0] * z + X[1]\r\n    struct G2Point {\r\n        uint256[2] X;\r\n        uint256[2] Y;\r\n    }\r\n\r\n    /*\r\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero. \r\n     */\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n\r\n        // The prime q in the base field F_q for G1\r\n        if (p.X == 0 && p.Y == 0) {\r\n            return G1Point(0, 0);\r\n        } else {\r\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @return The sum of two points of G1\r\n     */\r\n    function plus(\r\n        G1Point memory p1,\r\n        G1Point memory p2\r\n    ) internal view returns (G1Point memory r) {\r\n\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-add-failed\");\r\n    }\r\n\r\n    /*\r\n     * @return The product of a point on G1 and a scalar, i.e.\r\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\r\n     *         points p.\r\n     */\r\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\r\n\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require (success,\"pairing-mul-failed\");\r\n    }\r\n\r\n    /* @return The result of computing the pairing check\r\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n     *         For example,\r\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\r\n     */\r\n    function pairing(\r\n        G1Point memory a1,\r\n        G2Point memory a2,\r\n        G1Point memory b1,\r\n        G2Point memory b2,\r\n        G1Point memory c1,\r\n        G2Point memory c2,\r\n        G1Point memory d1,\r\n        G2Point memory d2\r\n    ) internal view returns (bool) {\r\n\r\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\r\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\r\n        uint256 inputSize = 24;\r\n        uint256[] memory input = new uint256[](inputSize);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 j = i * 6;\r\n            input[j + 0] = p1[i].X;\r\n            input[j + 1] = p1[i].Y;\r\n            input[j + 2] = p2[i].X[0];\r\n            input[j + 3] = p2[i].X[1];\r\n            input[j + 4] = p2[i].Y[0];\r\n            input[j + 5] = p2[i].Y[1];\r\n        }\r\n\r\n        uint256[1] memory out;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-opcode-failed\");\r\n\r\n        return out[0] != 0;\r\n    }\r\n}\r\n\r\ncontract OptimisticBlockVerifier4 {\r\n\r\n    using Pairing for *;\r\n\r\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct VerifyingKey {\r\n        Pairing.G1Point alfa1;\r\n        Pairing.G2Point beta2;\r\n        Pairing.G2Point gamma2;\r\n        Pairing.G2Point delta2;\r\n        Pairing.G1Point[2] IC;\r\n    }\r\n\r\n    struct Proof {\r\n        Pairing.G1Point A;\r\n        Pairing.G2Point B;\r\n        Pairing.G1Point C;\r\n    }\r\n\r\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\r\n        vk.alfa1 = Pairing.G1Point(uint256(16443734812995274654196720676585139062224043380201187987635465448940709072183), uint256(13229797941597128611149555074667619632585702912983862182545492421332271384284));\r\n        vk.beta2 = Pairing.G2Point([uint256(558208246016583076906983549567953354976687112328029548388055446851649721891), uint256(6102922671037832619848923470159599994798839756266983795256953361206497526823)], [uint256(5094640338995898337151346990699813270257329972019527523048088760830590007035), uint256(16947501873861118274651518698381922545311168431049810060809179307410759668054)]);\r\n        vk.gamma2 = Pairing.G2Point([uint256(11853602326570026887833193101920858538307139411369669467697699991409113807171), uint256(17080990347820259959810378185571055095163718159198080828478482438834239191327)], [uint256(9820284564429816324851060371385632884524998452245805833053366495818490667071), uint256(8884247825896330638743663642994606637849833077789639484418309665437205851259)]);\r\n        vk.delta2 = Pairing.G2Point([uint256(16351008507358705140268501443352785394846554949930113648058666419706491186347), uint256(6991961052452508803186601829997600858486679216303659368410789393402361292236)], [uint256(12503103870725565112763915445660652757877659596485570201327869336110425590070), uint256(2264619451148572029122106054703871705779298395601830930227709989174002199531)]);   \r\n        vk.IC[0] = Pairing.G1Point(uint256(12192695026944320739025250403367979429958636541417208251472343274186636401110), uint256(14944998768095907865728206558445669021056071506495884174036834261551095438335));   \r\n        vk.IC[1] = Pairing.G1Point(uint256(823275436220840284699408815129612633300154876463759202808293230858449000652), uint256(21484827016712615514878262051000434911086479429927941462826694182433091772100));\r\n    }\r\n    \r\n    /*\r\n     * @returns Whether the proof is valid given the hardcoded verifying key\r\n     *          above and the public inputs\r\n     */\r\n    function verifyProof(\r\n        uint256[2] memory a,\r\n        uint256[2][2] memory b,\r\n        uint256[2] memory c,\r\n        uint256[1] memory input\r\n    ) public view returns (bool r) {\r\n\r\n        Proof memory proof;\r\n        proof.A = Pairing.G1Point(a[0], a[1]);\r\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\r\n        proof.C = Pairing.G1Point(c[0], c[1]);\r\n\r\n        VerifyingKey memory vk = verifyingKey();\r\n\r\n        // Compute the linear combination vk_x\r\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\r\n\r\n        // Make sure that proof.A, B, and C are each less than the prime q\r\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\r\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\r\n\r\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\r\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\r\n\r\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\r\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\r\n\r\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\r\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\r\n\r\n        // Make sure that every input is less than the snark scalar field\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\r\n            vk_x = Pairing.plus(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));\r\n        }\r\n\r\n        vk_x = Pairing.plus(vk_x, vk.IC[0]);\r\n\r\n        return Pairing.pairing(\r\n            Pairing.negate(proof.A),\r\n            proof.B,\r\n            vk.alfa1,\r\n            vk.beta2,\r\n            vk_x,\r\n            vk.gamma2,\r\n            proof.C,\r\n            vk.delta2\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[1]\",\"name\":\"input\",\"type\":\"uint256[1]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OptimisticBlockVerifier4", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://55de2a5147e933866ff20ffcfe997c686ab9bdd989fc6b9edb080da8fdfd63f8"}